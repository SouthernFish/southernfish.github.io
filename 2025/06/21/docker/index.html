<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Docker | Southern Fish</title><meta name="keywords" content="Docker"><meta name="author" content="Southern Fish"><meta name="copyright" content="Southern Fish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Docker">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="https://southernfish.github.io/2025/06/21/docker/index.html">
<meta property="og:site_name" content="Southern Fish">
<meta property="og:description" content="Docker">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://southernfish.github.io/img/article/article1.png">
<meta property="article:published_time" content="2025-06-21T04:55:36.000Z">
<meta property="article:modified_time" content="2025-06-21T08:08:32.091Z">
<meta property="article:author" content="Southern Fish">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://southernfish.github.io/img/article/article1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://southernfish.github.io/2025/06/21/docker/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-21 16:08:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Southern Fish" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/article/article1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Southern Fish</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Docker</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-21T04:55:36.000Z" title="发表于 2025-06-21 12:55:36">2025-06-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-21T08:08:32.091Z" title="更新于 2025-06-21 16:08:32">2025-06-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Containerization-Platform/">Containerization Platform</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Docker"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Docker是一组平台即服务（PaaS）的产品。它基于操作系统层级的虚拟化技术，将软件与其依赖项打包为容器。托管容器的软件称为Docker引擎。Docker能够帮助开发者在轻量级容器中自动部署应用程序，并使得不同容器中的应用程序彼此隔离，高效工作。</p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="参考文档链接"><a href="#参考文档链接" class="headerlink" title="参考文档链接"></a>参考文档链接</h2><p>官网：<a target="_blank" rel="noopener" href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/">https://docs.docker.com/</a>   </p>
<p>仓库：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p><code>Docker</code> 是基于Go语言开发的开源项目，是开源的容器化平台，旨在简化应用程序的开发、部署和运行过程。它提供了一种轻量级、可移植和自包含的容器化环境，使开发人员能够在不同的计算机上以一致的方式构建、打包和分发应用程序。<br><strong>核心概念：</strong></p>
<ul>
<li><strong>容器（<code>Container</code>）：</strong>容器是 Docker 的<strong>基本部署单元</strong>。它是一个轻量级的、独立的运行时环境，包含应用程序及其相关依赖。容器利用 Linux 内核的命名空间和控制组技术，实现了隔离性和资源管理，使得应用程序在不同的容器中运行不会相互影响。</li>
<li><strong>镜像（<code>Image</code>）：</strong>镜像是用于<strong>创建容器的模板</strong>。它包含了一个完整的文件系统，其中包括应用程序运行所需的所有文件、依赖和配置信息。镜像是不可变的，通过 Docker 镜像可以创建多个相同的容器实例。</li>
<li><strong>镜像仓库（<code>Image Registry</code>）：</strong>镜像仓库是用于<strong>存储和分发 Docker 镜像的地方</strong>。最常用的公共镜像仓库是 <code>Docker Hub</code>，上面有大量的官方和社区共享的镜像。也可以搭建私有的镜像仓库，用于存放自己的镜像。</li>
<li><strong><code>Dockerfile</code>：</strong>Dockerfile 是一种<strong>文本文件</strong>，用于<strong>定义 Docker 镜像的构建过程</strong>。它包含了一系列的指令，用于<strong>指定基础镜像、安装软件、拷贝文件、配置环境等</strong>。通过 Dockerfile，可以自动化地构建镜像，确保镜像的一致性和可重复性。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621152126465.png" alt="image-20250621152126465"></p>
<p><strong>Docker 的优势</strong>：<code>轻量性、可移植性和灵活性</code>。通过使用 Docker，开发人员可以更轻松地创建一个可靠的开发环境、快速部署应用程序、实现弹性扩展和服务编排等。同时，它也提供了<code>生态系统丰富的工具和服务</code>，例如容器编排工具 <code>Docker Compose</code> 和容器编排平台 <code>Kubernetes</code>，使得容器化应用的管理更加便捷和高效。</p>
<p><strong>Linux容器技术：</strong></p>
<ul>
<li>Docker是在Linuk容器(<code>Linux Containers</code>)技术的基础上发展起来的。</li>
<li>LUX把单个操作系统的资源划分到多个孤立的组里，在孤立的组里平衡有冲突的资源使用需求。与虚拟机相比，这种通过划分组来平衡资源冲突的方式代价更小，它不需要指令级别模拟也不需要即使编译。</li>
<li><strong>容器直接在本地CPU上运行</strong>。</li>
</ul>
<h3 id="为什么要使用Docker"><a href="#为什么要使用Docker" class="headerlink" title="为什么要使用Docker"></a>为什么要使用Docker</h3><ul>
<li><strong>更快的交付和部署。</strong>开发人员使用镜像构建标准开发环境，运维和测试人员使用镜像来获得和开发人员相同的运行环境。开发环境和测试运维环境无缝对接，节约开发、测试、部署时间。</li>
<li><strong>更高效的资源利用。</strong>相较于虚拟机Docker不需要额外的<code>Hypervisor</code>支持，Docker是<strong>内核级别的虚拟化</strong>，实现更高的性能。</li>
<li><strong>更简单的更新管理。</strong>使用<code>Dockerfile</code>，通过简单的修改就可以代替大量的更新操作。</li>
</ul>
<h2 id="Docker与虚拟化"><a href="#Docker与虚拟化" class="headerlink" title="Docker与虚拟化"></a>Docker与虚拟化</h2><p><strong>虚拟化：</strong>虚拟化是对计算机资源的抽象，是为了更好的管理计算机资源。让同时运行在一个计算机上的多个进程以为自己能够独占当前操作系统资源。<br><strong>有三种类型的虚拟化：</strong>仿真、半虚拟化、基于容器的虚拟化<br><strong>Docker虚拟化与虚拟机比较</strong></p>
<ul>
<li><strong>Docker不是虚拟化方法</strong>。它依赖于实际实现基于容器的虚拟化或操作系统级虚拟化的其他工具。</li>
<li><strong>Docker是操作系统级的虚拟化</strong>，内核通过创建多个虚拟操作系统实例来隔离进程。虚拟机是硬件辅助虚拟化，虚拟的是整个硬件。</li>
<li>虚拟机需要模拟一个独立的<code>OS Kernel</code>而Docker不需要，与虚拟机映像相比，容器状态(<code>Docker或LXC映像</code>)的<strong>大小很小</strong>，因此容器映像很容易分发</li>
<li>虚拟机需要一个虚拟机管理程序如<code>VMware</code>，而Docker只需要一个Docker引擎，<strong>后者的开销更小</strong>。</li>
<li><strong>Docker更快秒级，虚拟机分钟级别</strong></li>
<li>Docker<strong>对系统资源需求更少</strong>。<ul>
<li>主机上的所有容器共享主机的调度程序，从而节省了额外资源的需求。容器中的资源管理是通过cgroup实现的。Cgroups不允许容器消耗比分配给它们更多的资源。</li>
</ul>
</li>
<li>Docker通过类似<code>Git</code>理念来方便用户获取、分发更新镜像</li>
<li>Docker通过<code>dockerfile</code>实现灵活的创建、部署机制</li>
</ul>
<p><strong>虚拟机和Docker本质的区别</strong>在于虚拟化的方式不同，虚拟机是一种硬件级别的虚拟化，通过软件去模拟硬件系统，并且虚拟机里需要虚拟OS Kernel。Docker是一种容器，是一种隔离机制，是软件级别的模拟。</p>
<p>虚拟机技术：资源占用十分多、冗余步骤多、启动慢；容器技术：不是模拟一个完整的OS</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151302533.png" alt="image-20250621151302533"></p>
<h2 id="Docker为什么比VM快"><a href="#Docker为什么比VM快" class="headerlink" title="Docker为什么比VM快"></a>Docker为什么比VM快</h2><p>1、Docker比VM有更少的抽象层<br>2、Docker利用的是宿主机的内核，VM需要的是Guest OS<br>故新建一个容器的时候，docker无需像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而docker利用宿主机的操作系统，省略了这个复杂的过程，秒级！</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151312130.png" alt="image-20250621151312130"></p>
<table>
<thead>
<tr>
<th></th>
<th>Docker容器</th>
<th>LXC</th>
<th>VM</th>
</tr>
</thead>
<tbody><tr>
<td>虚拟化类型</td>
<td>OS虚拟化</td>
<td>OS虚拟化</td>
<td>硬件虚拟化</td>
</tr>
<tr>
<td>性能</td>
<td>=物理机性能</td>
<td>=物理机性能</td>
<td>5%-20%损耗</td>
</tr>
<tr>
<td>隔离性</td>
<td>NS隔离</td>
<td>NS隔离</td>
<td>强</td>
</tr>
<tr>
<td>QoS</td>
<td>Cgroup 弱</td>
<td>Cgroup 弱</td>
<td>强</td>
</tr>
<tr>
<td>安全性</td>
<td>中</td>
<td>差</td>
<td>强</td>
</tr>
<tr>
<td>GuestOS</td>
<td>只支持Linux&lt;</td>
<td>只支持Linux&lt;</td>
<td>全部</td>
</tr>
<tr>
<td>可迁移性</td>
<td>强</td>
<td>弱</td>
<td>强</td>
</tr>
</tbody></table>
<h2 id="docker是怎么工作的"><a href="#docker是怎么工作的" class="headerlink" title="docker是怎么工作的?"></a>docker是怎么工作的?</h2><p>一个完整的Docker由<code>DockerClient</code>客户端、<code>Docker Daemon</code>守护进程、<code>Docker Image</code>镜像、<code>DockerContainer</code>容器四部分组成<br>Docker是一个<code>Client-Server</code>结构的系统，，<strong>docker client负责处理用户输入的各种命令</strong>，比如docker build、docker run，真正工作的其实是server，也就是docker daemon，值得注意的是，<strong>docker client和docker daemon可以运行在同一台机器上</strong>。<br>Docker守护进程运行在主机上，然后通过<code>Socket</code>连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151356904.png" alt="image-20250621151356904"></p>
<h2 id="基本的Docker使用工作流程是怎样的？"><a href="#基本的Docker使用工作流程是怎样的？" class="headerlink" title="基本的Docker使用工作流程是怎样的？"></a>基本的Docker使用工作流程是怎样的？</h2><ol>
<li><strong>构建镜像：</strong>Dockerfile是镜像的源代码；用其创建镜像</li>
<li><strong>推送镜像到注册表：</strong>将镜像上传到 <code>Docker Hub</code> 或<code>私有注册表</code>中。</li>
<li><strong>拉取镜像：</strong>通过 <code>docker pull</code> 从注册表中拉取镜像。</li>
<li><strong>运行容器：</strong>使用镜像创建并启动容器。</li>
<li><strong>管理容器：</strong>使用 Docker 客户端命令管理正在运行的容器(例如查看日志、停止容器、查看资源使用情况等)。</li>
<li><strong>网络与存储：</strong>容器之间通过 Docker 网络连接，数据通过 <code>Docker 卷</code>或<code>绑定挂载</code>进行持久化。</li>
</ol>
<h2 id="什么是docker-compose？"><a href="#什么是docker-compose？" class="headerlink" title="什么是docker-compose？"></a>什么是docker-compose？</h2><p><code>docker-compose</code>就是一个编排同时管理多个容器的工具，与它配对使用的是一个<code>docker-compose.yaml</code>文件，<code>docker-compose</code>命令必须在一个包含<code>docker-compose.yaml</code>文件目录下才能使用。且当下docker-compose命令<strong>只能管理当前目录docker-compose文件中所涉及的容器，安装在机器上的其他容器无法干扰</strong>。</p>
<p>docker-compose的大部分命令基本和docker的命令重合，他们唯一的区别是docker命令能管理机器上所有的容器和镜像文件，而docker-compose只能管理当前docker-compose文件所涉及的容器。</p>
<h2 id="如何在生产中监控Docker？"><a href="#如何在生产中监控Docker？" class="headerlink" title="如何在生产中监控Docker？"></a>如何在生产中监控Docker？</h2><p>Docker提供<code>docker status</code>和<code>docker事件</code>等工具来监控生产中的Docker。我们可以使用这些命令获取重要统计数据的报告。<br><strong>Docker统计数据：</strong>当我们使用容器ID调用docker status时，我们获得容器的CPU、内存使用情况等。它类似于Linux中<code>top</code>命令。<br><strong>Docker事件：</strong> Docker事件是一个命令，用于查看Docker守护进程中整改再进行的活动流。一些常见的Docker事件是：<code>attach</code>、<code>commit</code>、<code>die</code>、<code>datach</code>、<code>rename</code>、<code>destroy</code>。</p>
<h2 id="Docker安全么？"><a href="#Docker安全么？" class="headerlink" title="Docker安全么？"></a>Docker安全么？</h2><p>Docker<strong>利用了Linux内核中很多安全特性来保证不同容器之间的隔离，并且通过签名机制来对镜像进行验证</strong>。<br>Docker虽然隔离性无法与虚拟机相比，但仍然具有极高的安全性。</p>
<h2 id="Docker如何在非Linux系统中运行容器"><a href="#Docker如何在非Linux系统中运行容器" class="headerlink" title="Docker如何在非Linux系统中运行容器"></a>Docker如何在非Linux系统中运行容器</h2><p>通过添加到Linux内核版本2.6.24的<strong>名称空间功能</strong>，可以实现容器的概念。容器将其<code>ID</code><strong>添加到每个进程</strong>，并向每个系统调用添加新的访问控制检查。它由<code>clone</code>系统调用访问，该调用允许创建先前全局命名空间的单独实例。</p>
<h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><h2 id="什么是Docker镜像"><a href="#什么是Docker镜像" class="headerlink" title="什么是Docker镜像"></a>什么是Docker镜像</h2><p>Docker镜像是Docker容器的源代码。换句话说，Docker镜像用于创建容器。使用<code>build</code>创建镜像，用<code>run</code>启动时它们将生成容器。<br>镜像存储在Docker注册表（<code>docker hub</code>）中，<code>registry.hub.docker.com</code>因为它们可能变得非常大，镜像被设计为由其他镜像层组成，允许在通过网络传输镜像时发送最少量的数据。</p>
<h2 id="Docker镜像联合文件系统"><a href="#Docker镜像联合文件系统" class="headerlink" title="Docker镜像联合文件系统"></a>Docker镜像联合文件系统</h2><p><strong><code>UnionFS</code>（联合文件系统）：</strong>是一种分成，轻量级并且高性能的文件系统，支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统的Docker镜像可以<strong>通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像</strong>。<br><strong>特性：</strong><code>一次同时加载多个文件系统</code>，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统进行叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<h2 id="镜像与-UnionFS区别"><a href="#镜像与-UnionFS区别" class="headerlink" title="镜像与 UnionFS区别"></a>镜像与 UnionFS区别</h2><p>Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。<br><code>Docker 镜像</code>其实<strong>本质就是一个压缩包</strong>，我们可以使用命令将一个 Docker 镜像中的文件导出，你可以看到这个镜像中的目录结构与 Linux 操作系统的根目录中的内容并没有太多的区别，可以说 Docker 镜像就是一个文件。</p>
<h2 id="什么是Docker-Hub"><a href="#什么是Docker-Hub" class="headerlink" title="什么是Docker Hub"></a>什么是Docker Hub</h2><p><code>Docker Hub</code>是一个基于云的在线存储库，Docker进行可以由其他用户发布和使用。<br><code>Docker hub</code>是一个基于云的注册表服务，允许链接到代码存储库，构建镜像并测试，存储手动推送的镜像以及指向Docker云的链接，以便将镜像部署到主机。它为整个开发流程中的容器镜像发现，分发和变更管理，用户和团队协作以及工作流自动化提供了集中资源。</p>
<h1 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h1><h2 id="Docker容器可扩展到多远？"><a href="#Docker容器可扩展到多远？" class="headerlink" title="Docker容器可扩展到多远？"></a>Docker容器可扩展到多远？</h2><p>诸如<code>Foogle</code>和<code>Twitter</code>之类的大型Web部署以及诸如<code>Heroku</code>和<code>dotCloud</code>之类的平台提供商都基于容器技术运行，并行运行的容器数以十万甚至至数八百计。</p>
<h2 id="Docker容器退出时是否丢失数据"><a href="#Docker容器退出时是否丢失数据" class="headerlink" title="Docker容器退出时是否丢失数据"></a>Docker容器退出时是否丢失数据</h2><p>不、当Docker<strong>容器退出时，不会丢失数据</strong>。<br>应用程序写入磁盘的所有数据都会保留在其容器中<strong>直到明确删除该容器为止</strong>。即使在容器停止后，该容器的文件系统仍然存在。</p>
<h2 id="Docker容器有几种状态？"><a href="#Docker容器有几种状态？" class="headerlink" title="Docker容器有几种状态？"></a>Docker容器有几种状态？</h2><p>有四种状态：运行、已暂停、重新启动、已退出。</p>
<h2 id="容器内部机制"><a href="#容器内部机制" class="headerlink" title="容器内部机制"></a>容器内部机制</h2><p>每个容器都在自己的命名空间中运行，但使用与所有其他容器完全相同的内核。发生隔离是因为内核知道分配给进程的命名空间，并且在API调用期间确保进程只能访问其自己的命名空间中的资源。</p>
<h2 id="docker容器之间怎么隔离"><a href="#docker容器之间怎么隔离" class="headerlink" title="docker容器之间怎么隔离?"></a>docker容器之间怎么隔离?</h2><p>Linux中的<code>PID、IPC、网络</code>等资源是全局的，而<code>NameSpace机制</code>是一种资源隔离方案，在<strong>该机制下这些资源就不再是全局的</strong>了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰。<br>NameSpace技术可实现资源隔离，但进程仍可不受控的访问（CPU、内存、磁盘、网络等）系统资源，为了控制容器中进程对资源的访问，Docker采用<code>control groups</code>技术(也就是<code>cgroup</code>)<strong>控制容器中进程对系统资源的消耗</strong>，如限制某容器使用内存的上限、可在哪些CPU上运行等。这两项技术使容器像真正独立的操作系统。</p>
<h2 id="容器与主机之间的数据拷贝命令-docker-cp"><a href="#容器与主机之间的数据拷贝命令-docker-cp" class="headerlink" title="容器与主机之间的数据拷贝命令 docker cp"></a>容器与主机之间的数据拷贝命令 docker cp</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> /www 96f7f14e99ab:/www/     <span class="comment"># 主机到容器</span></span><br><span class="line">docker <span class="built_in">cp</span> 96f7f14e99ab:/www /tmp    <span class="comment"># 容器到主机</span></span><br></pre></td></tr></table></figure>

<h2 id="进入容器的方法"><a href="#进入容器的方法" class="headerlink" title="进入容器的方法"></a>进入容器的方法</h2><ol>
<li><code>docker attach</code>，用于附加到正在运行的容器的标准输入、输出和错误流。<strong>不会启动新的进程</strong>。</li>
<li><code>docker exec</code>，如<code>docker exec -it 容器id /bin/bash</code>，此命令将以<strong>交互模式（-i）和终端（-t）的方式进入指定容器，并开启起一个新的终端</strong>。</li>
<li>通过 <code>docker run</code> 命令来进入容器。这种方式<strong>适用于需要在容器内执行命令而不是交互式操作的情况</strong>，使用 docker run 命令指定容器镜像和执行的命令，类似于直接进入容器</li>
</ol>
<h2 id="无状态或有状态应用程序谁更适合Docker容器"><a href="#无状态或有状态应用程序谁更适合Docker容器" class="headerlink" title="无状态或有状态应用程序谁更适合Docker容器"></a>无状态或有状态应用程序谁更适合Docker容器</h2><p>最好为<code>Docker Container</code>创建<strong>无状态应用程序</strong>。我们可以从应用程序中创建一个容器，并<strong>从应用程序中取出可配置的状态参数</strong>。现在我们可以<strong>在生产环境和具有不同参数的QA环境中运行相同的容器</strong>。这有助于在不同场景中重用相同的镜像。另外，无状态应用程序比有状态应用程序<strong>更容易使用Docker容器进行扩展</strong>。</p>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="Dockerfile中最常见的指令是什么"><a href="#Dockerfile中最常见的指令是什么" class="headerlink" title="Dockerfile中最常见的指令是什么"></a>Dockerfile中最常见的指令是什么</h2><ul>
<li><code>FROM</code>：指定基础镜像；</li>
<li><code>LABEL</code>：功能是为镜像指定标签；</li>
<li><code>RUN</code>：运行指定的命令；</li>
<li><code>CMD</code>：容器启动时要运行的命令。</li>
</ul>
<h2 id="Dockerfile中的命令COPY和ADD命令区别"><a href="#Dockerfile中的命令COPY和ADD命令区别" class="headerlink" title="Dockerfile中的命令COPY和ADD命令区别"></a>Dockerfile中的命令COPY和ADD命令区别</h2><p>一般而言，<code>ADD</code>和<code>COPY</code>在功能上类似，但是首选COPY。因为COPY比ADD更易懂。<strong>COPY仅支持将本地文件复制到容器中</strong>，而ADD具有一些功能（如仅限本地的tar提取和远程URL支持），这些功能并不是很明显。<br>因此，<strong>ADD最佳用途是将本地tar文件自动提取到镜像中</strong>，如<code>ADD rootfs.tar.xz /</code>。</p>
<h2 id="使用dockerfile构建apache容器服务"><a href="#使用dockerfile构建apache容器服务" class="headerlink" title="使用dockerfile构建apache容器服务"></a>使用dockerfile构建apache容器服务</h2><ol>
<li><p>基础镜像目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir apache</span></span><br><span class="line"><span class="comment"># cd apache</span></span><br></pre></td></tr></table></figure></li>
<li><p>编辑镜像dockerfile</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim Dockerfile</span></span><br><span class="line"> </span><br><span class="line">FROM centos:7 <span class="comment"># 基于的基础镜像</span></span><br><span class="line">MAINTAINER The porject &lt;cloud-ops@centos.org&gt; <span class="comment"># 维护镜像的用户信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作指令安装apache软件</span></span><br><span class="line">RUN yum -y update    <span class="comment">#更新yum</span></span><br><span class="line">RUN yum -y install httpd</span><br><span class="line"></span><br><span class="line">EXPOSE 80 <span class="comment"># 开启80端口</span></span><br><span class="line">ADD index.html /var/www/html/index.html <span class="comment"># 复制网站首页文件</span></span><br><span class="line">ADD run.sh /run.sh <span class="comment"># 将执行脚本复制到镜像中</span></span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /run.sh <span class="comment"># 启动容器时执行脚本</span></span><br><span class="line"></span><br><span class="line">CMD [<span class="string">&quot;/run.sh&quot;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>编辑启动脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim run.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -rf /run/httpd/*</span><br><span class="line"><span class="built_in">exec</span> /usr/sbin/apachectl -D FOREGROUND</span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;web test&quot;</span> &gt; index.html</span><br></pre></td></tr></table></figure></li>
<li><p>构建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker build -t httpd:centos . (注意别忘 了末尾有&quot;.&quot;，且.前面有空格)</span></span><br></pre></td></tr></table></figure></li>
<li><p>镜像容器启动运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -d -p 1216:80 httpd:centos</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl http://192.168.40.30:1216</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ygq13572549874/article/details/136558153">Docker镜像及Dockerfile详解</a></p>
<h2 id="docker-构建一个服务的过程-node-js"><a href="#docker-构建一个服务的过程-node-js" class="headerlink" title="docker 构建一个服务的过程(node.js)"></a>docker 构建一个服务的过程(node.js)</h2><ol>
<li><p>编写应用代码。首先，你需要有一个应用代码。例如，一个简单的 Node.js 应用</p>
</li>
<li><p>创建 Dockerfile<br>在应用的根目录下创建一个名为 Dockerfile 的文件。Dockerfile 包含了一系列的指令，用于告诉 Docker 如何构建镜像。例如，对于 Node.js 应用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方 Node.js 镜像作为基础镜像</span></span><br><span class="line">FROM node:14</span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /usr/src/app</span><br><span class="line"><span class="comment"># 复制 package.json 和 package-lock.json (如果有) 到工作目录</span></span><br><span class="line">COPY package*.json ./</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">RUN npm install</span><br><span class="line"><span class="comment"># 复制项目文件到工作目录</span></span><br><span class="line">COPY . .</span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">EXPOSE 3000</span><br><span class="line"><span class="comment"># 定义容器启动时执行的命令</span></span><br><span class="line">CMD [ <span class="string">&quot;node&quot;</span>, <span class="string">&quot;app.js&quot;</span> ]</span><br></pre></td></tr></table></figure></li>
<li><p>构建 Docker 镜像。打开终端或命令行工具，导航到包含 Dockerfile 的目录，然后运行以下命令来构建 Docker 镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-nodejs-app .</span><br><span class="line"><span class="comment"># 这里，-t 参数用于标记你的镜像，my-nodejs-app 是你的镜像名称，. 表示 Dockerfile 所在的当前目录。</span></span><br></pre></td></tr></table></figure></li>
<li><p>运行 Docker 容器。构建完成后，你可以使用以下命令来运行你的 Docker 容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:3000 my-nodejs-app</span><br><span class="line"><span class="comment"># 这里，-p 参数将容器的 3000 端口映射到主机的 4000 端口。现在，如果你的机器上的任何程序访问 localhost:4000，它们将会看到你的 Node.js 应用运行。</span></span><br></pre></td></tr></table></figure></li>
<li><p>检查运行状态（可选）。可以使用以下命令来查看正在运行的容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li>
<li><p>停止并删除容器（可选）。当完成测试后，可以停止并删除容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;container_id&gt;  <span class="comment"># 使用 docker ps 获取 container_id</span></span><br><span class="line">docker <span class="built_in">rm</span> &lt;container_id&gt;    <span class="comment"># 使用 docker ps 获取 container_id 或 docker rm $(docker ps -aq) 来删除所有容器</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="部署相关"><a href="#部署相关" class="headerlink" title="部署相关"></a>部署相关</h1><h2 id="CI-CD聚焦代码集成与交付的自动化流程（Jenkins）"><a href="#CI-CD聚焦代码集成与交付的自动化流程（Jenkins）" class="headerlink" title="CI/CD聚焦代码集成与交付的自动化流程（Jenkins）"></a>CI/CD聚焦代码集成与交付的自动化流程（Jenkins）</h2><p>CI/CD 是指持续集成(<code>Continuous Integration</code>)和持续部署(<code>Continuous Deployment</code>)或持续交付(<code>Continuous Delivery</code>)<br><strong>持续集成(Continuous Integration)</strong><br>持续集成是一种软件开发实践，团队成员频繁地将他们的工作集成到共享的代码仓库中。<strong>其主要特点包括</strong>:</p>
<ol>
<li><code>频繁提交代码</code>：开发人员可以每天多次提交代码，确保代码库始终保持最新状态。</li>
<li><code>自动化构建</code>：每次提交后，自动触发构建过程，包括编译、测试、静态分析等</li>
<li><code>快速反馈</code>：如果构建失败或测试不通过，能够快速地向开发人员提供反馈，以便及时修复问题。</li>
</ol>
<p><strong>持续部署(Continuous Deployment)</strong><br>持续部署是在持续集成的基础上，将通过所有测试的代码自动部署到生产环境中。其<strong>特点如下</strong>:</p>
<ol>
<li><code>自动化流程</code>：从代码提交到生产环境的部署完全自动化，无需人工干预。</li>
<li><code>高频率部署</code>：可以实现频繁的部署，使得新功能能够快速地提供给用户,</li>
<li><code>风险控制</code>：需要有强大的测试和监控体系来确保部署的稳定性和可靠性。</li>
</ol>
<p><strong>持续交付(continuous Delivery)</strong><br>持续交付与持续部署类似，但不一定自动部署到生产环境，而是随时可以部署。重点在于确保软件随时处于可发布状态。</p>
<p><strong>CI/CD 好处包括:</strong></p>
<ol>
<li><code>提高开发效率</code>：减少手动操作和等待时间，加快开发周期。</li>
<li><code>尽早发现问题</code>：通过频繁的集成和测试，问题能够在早期被发现和解决。</li>
<li><code>降低风险</code>：减少了大规模部署时可能出现的问题，提高了软件的质量和稳定性。</li>
<li><code>增强团队协作</code>：促进团队成员之间的沟通和协作，提高团队的整体效率，</li>
</ol>
<h2 id="DevOps？"><a href="#DevOps？" class="headerlink" title="DevOps？"></a>DevOps？</h2><p>DevOps是涵盖开发与运维全生命周期协作的文化与实践体系。<br>DevOps是一种文化与方法论，旨在打破开发与运维的壁垒，通过自动化工具链、协作流程和共享责任，加速软件全生命周期交付。<br>DevOps覆盖更广包括需求规划、基础设施管理、监控反馈等全流程，强调团队协作、文化变革及工具整合。更强调“人+流程+工具”的系统性优化。<br><strong>技术优势：</strong>更快地解决问题<br><strong>商业利益：</strong>有更多时间可以增加价值（而不是修复/维护）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://southernfish.github.io">Southern Fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://southernfish.github.io/2025/06/21/docker/">https://southernfish.github.io/2025/06/21/docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://southernfish.github.io" target="_blank">Southern Fish</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post_share"><div class="social-share" data-image="/img/article/article1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/06/21/front-end-webpack/"><img class="prev-cover" src="/img/article/article3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">WebPack</div></div></a></div><div class="next-post pull-right"><a href="/2025/06/20/front-end-vue/"><img class="next-cover" src="/img/article/article3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">VUE</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/06/21/docker-commands/" title="Docker"><img class="cover" src="/img/article/article5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-21</div><div class="title">Docker</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southern Fish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SouthernFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1002721576@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker"><span class="toc-number">1.</span> <span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E9%93%BE%E6%8E%A5"><span class="toc-number">1.1.</span> <span class="toc-text">参考文档链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDocker"><span class="toc-number">1.2.</span> <span class="toc-text">什么是Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Docker"><span class="toc-number">1.2.1.</span> <span class="toc-text">为什么要使用Docker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">Docker与虚拟化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94VM%E5%BF%AB"><span class="toc-number">1.4.</span> <span class="toc-text">Docker为什么比VM快</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">1.5.</span> <span class="toc-text">docker是怎么工作的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84Docker%E4%BD%BF%E7%94%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">基本的Docker使用工作流程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFdocker-compose%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">什么是docker-compose？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E4%B8%AD%E7%9B%91%E6%8E%A7Docker%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">如何在生产中监控Docker？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%AE%89%E5%85%A8%E4%B9%88%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">Docker安全么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%A6%82%E4%BD%95%E5%9C%A8%E9%9D%9ELinux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">1.10.</span> <span class="toc-text">Docker如何在非Linux系统中运行容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F"><span class="toc-number">2.</span> <span class="toc-text">Docker镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDocker%E9%95%9C%E5%83%8F"><span class="toc-number">2.1.</span> <span class="toc-text">什么是Docker镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.2.</span> <span class="toc-text">Docker镜像联合文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E4%B8%8E-UnionFS%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">镜像与 UnionFS区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDocker-Hub"><span class="toc-number">2.4.</span> <span class="toc-text">什么是Docker Hub</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">Docker容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8%E5%8F%AF%E6%89%A9%E5%B1%95%E5%88%B0%E5%A4%9A%E8%BF%9C%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">Docker容器可扩展到多远？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA%E6%97%B6%E6%98%AF%E5%90%A6%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.</span> <span class="toc-text">Docker容器退出时是否丢失数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">Docker容器有几种状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text">容器内部机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E9%9A%94%E7%A6%BB"><span class="toc-number">3.5.</span> <span class="toc-text">docker容器之间怎么隔离?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4-docker-cp"><span class="toc-number">3.6.</span> <span class="toc-text">容器与主机之间的数据拷贝命令 docker cp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.</span> <span class="toc-text">进入容器的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E6%88%96%E6%9C%89%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%B0%81%E6%9B%B4%E9%80%82%E5%90%88Docker%E5%AE%B9%E5%99%A8"><span class="toc-number">3.8.</span> <span class="toc-text">无状态或有状态应用程序谁更适合Docker容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dockerfile"><span class="toc-number">4.</span> <span class="toc-text">Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile%E4%B8%AD%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8C%87%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.</span> <span class="toc-text">Dockerfile中最常见的指令是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4COPY%E5%92%8CADD%E5%91%BD%E4%BB%A4%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">Dockerfile中的命令COPY和ADD命令区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8dockerfile%E6%9E%84%E5%BB%BAapache%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.3.</span> <span class="toc-text">使用dockerfile构建apache容器服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B-node-js"><span class="toc-number">4.4.</span> <span class="toc-text">docker 构建一个服务的过程(node.js)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E7%9B%B8%E5%85%B3"><span class="toc-number">5.</span> <span class="toc-text">部署相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CI-CD%E8%81%9A%E7%84%A6%E4%BB%A3%E7%A0%81%E9%9B%86%E6%88%90%E4%B8%8E%E4%BA%A4%E4%BB%98%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%88Jenkins%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">CI&#x2F;CD聚焦代码集成与交付的自动化流程（Jenkins）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DevOps%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">DevOps？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/21/front-end-websocket/" title="WebSocket"><img src="/img/article/article6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebSocket"/></a><div class="content"><a class="title" href="/2025/06/21/front-end-websocket/" title="WebSocket">WebSocket</a><time datetime="2025-06-21T05:33:36.000Z" title="发表于 2025-06-21 13:33:36">2025-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/21/docker-commands/" title="Docker"><img src="/img/article/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/2025/06/21/docker-commands/" title="Docker">Docker</a><time datetime="2025-06-21T04:55:36.000Z" title="发表于 2025-06-21 12:55:36">2025-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/21/front-end-javascript/" title="JavaScript"><img src="/img/article/article6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript"/></a><div class="content"><a class="title" href="/2025/06/21/front-end-javascript/" title="JavaScript">JavaScript</a><time datetime="2025-06-21T04:55:36.000Z" title="发表于 2025-06-21 12:55:36">2025-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/21/front-end-webpack/" title="WebPack"><img src="/img/article/article3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebPack"/></a><div class="content"><a class="title" href="/2025/06/21/front-end-webpack/" title="WebPack">WebPack</a><time datetime="2025-06-21T04:55:36.000Z" title="发表于 2025-06-21 12:55:36">2025-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/21/docker/" title="Docker"><img src="/img/article/article1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/2025/06/21/docker/" title="Docker">Docker</a><time datetime="2025-06-21T04:55:36.000Z" title="发表于 2025-06-21 12:55:36">2025-06-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/article/article1.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Southern Fish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>