<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>高并发（High Concurrency） | Southern Fish</title><meta name="keywords" content="Concurrency"><meta name="author" content="Southern Fish"><meta name="copyright" content="Southern Fish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="高性能、高并发、高可用是现代系统设计中的三个重要指标，它们共同决定了一个系统在不同场景下的表现。">
<meta property="og:type" content="article">
<meta property="og:title" content="高并发（High Concurrency）">
<meta property="og:url" content="https://southernfish.github.io/2025/06/26/framwork/system-design-high-concurrency/index.html">
<meta property="og:site_name" content="Southern Fish">
<meta property="og:description" content="高性能、高并发、高可用是现代系统设计中的三个重要指标，它们共同决定了一个系统在不同场景下的表现。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://southernfish.github.io/img/article/article6.png">
<meta property="article:published_time" content="2025-06-26T01:13:36.000Z">
<meta property="article:modified_time" content="2025-07-22T14:13:04.246Z">
<meta property="article:author" content="Southern Fish">
<meta property="article:tag" content="Concurrency">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://southernfish.github.io/img/article/article6.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://southernfish.github.io/2025/06/26/framwork/system-design-high-concurrency/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '高并发（High Concurrency）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-22 22:13:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Southern Fish" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/article/article6.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Southern Fish</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">高并发（High Concurrency）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-26T01:13:36.000Z" title="发表于 2025-06-26 09:13:36">2025-06-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-22T14:13:04.246Z" title="更新于 2025-07-22 22:13:04">2025-07-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Framwork/">Framwork</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="高并发（High Concurrency）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>高性能、高并发、高可用是构建现代大规模系统的三个关键目标，它们各自解决不同的问题，但在实际系统中往往需要综合考虑，互为补充。本篇讨论高并发应对的策略、缓存、限流、降级等。原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ailiandeziwei/article/details/136561585">高并发架构设计（三大利器：缓存、限流和降级）</a></p>
<h1 id="高并发（High-Concurrency）"><a href="#高并发（High-Concurrency）" class="headerlink" title="高并发（High Concurrency）"></a>高并发（High Concurrency）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>高并发指的是系统能够同时处理大量请求或操作的能力。在互联网应用中，用户可能会同时访问某个功能，这就要求系统能够同时处理多个用户的请求而不发生性能下降或响应延迟。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><code>热门网站</code>、<code>电商平台</code>、<code>社交媒体</code>等互联网应用中。例如，在电商平台上有大量用户同时浏览、搜索商品，提交订单等操作；社交媒体平台上有大量用户同时发布、点赞、评论等操作。这些场景需要系统能够同时处理大量请求，并保证系统的性能、可用性和用户体验。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li><strong>大量请求：</strong>系统需要同时处理大量的请求，这些请求可能来自于不同的用户或客户端。 </li>
<li><strong>同时访问：</strong>这些请求几乎同时到达系统，需要在短时间内进行处理和响应。 </li>
<li><strong>资源竞争：</strong>由于大量请求同时到达，系统的资源（如CPU、内存、网络带宽等）可能会面临竞争和争夺。 </li>
<li><strong>响应时间要求高：</strong>高并发场景通常对系统的响应速度有较高的要求，用户期望能够快速获取响应结果。</li>
</ol>
<h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><ul>
<li>系统性能的下降和延迟增加</li>
<li>资源竞争和资源耗尽</li>
<li>系统稳定性和可用性的挑战</li>
</ul>
<h2 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h2><ul>
<li><strong>缓存：</strong>缓解系统负载压力，提高系统响应速度</li>
<li><strong>限流：</strong>控制并发访问量，保护系统免受过载影响</li>
<li><strong>降级：</strong>保证核心功能的稳定性，舍弃非关键业务或简化处理</li>
</ul>
<hr>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>缓存的工作原理是先从缓存中获取数据，如果有数据则直接返回给用户，如果没有数据则从慢速设备上读取实际数据并且将数据放入缓存</p>
<h2 id="常用技术"><a href="#常用技术" class="headerlink" title="常用技术"></a>常用技术</h2><table>
<thead>
<tr>
<th>缓存类型</th>
<th>介绍</th>
<th align="left">方案/工具</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>浏览器缓存</td>
<td>存储在用户设备上的缓存，用于存储静态资源和页面内容。</td>
<td align="left">通过设置<code>HTTP头</code>中的缓存相关字段来控制缓存行为。</td>
<td>1.快速响应，避免频繁访问服务器或网络<br /> 2.减少网络带宽消耗，提升网站性能</td>
<td>1.缓存数据可能不是最新的，需要考虑缓存一致性和更新机制的设计<br />2.缓存命中率受限于缓存容量和缓存策略的选择</td>
<td>1.静态资源的缓存<br />2.减少网络带宽消耗</td>
</tr>
<tr>
<td>客户端缓存</td>
<td>应用程序在用户设备上的缓存，用于存储数据、计算结果或其他业务相关的内容。</td>
<td align="left">使用<code>本地存储</code>、<code>SessionStorage</code>、<code>LocalStorage</code>或<code>IndexedDB</code>等<strong>Web API</strong>来进行数据的存储和读取。</td>
<td>1.减轻后端负载，提升系统性能<br />2.快速响应，避免频繁访问服务器或网络资源</td>
<td>1.缓存数据可能不是最新的，需要考虑缓存一致性和更新机制的设计<br />2.缓存命中率受限于缓存容量和缓存策略的选择</td>
<td>1.频繁访问的数据或计算结果<br />2.减轻后端负载</td>
</tr>
<tr>
<td>CDN缓存</td>
<td>内容分发网络的缓存，用于存储和加速静态资源的分发。</td>
<td align="left">部署静态资源到<code>CDN服务器</code>并配置<code>CDN缓存策略</code>，用户请求将被转发到就近的CDN节点，加速内容的分发和访问。</td>
<td>1.加速静态资源的访问速度，提升用户体验<br />2.减轻源服务器负载，提高系统可扩展性</td>
<td>1.只适用于静态资源的缓存，动态内容无法缓存<br />2.CDN配置和管理的复杂性</td>
<td>1.静态资源的分发和访问<br />2.加速静态资源的加载和访问</td>
</tr>
<tr>
<td></td>
<td></td>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>反向代理缓存</td>
<td>位于服务器前端的缓存，用于缓存和加速动态内容和静态资源的访问。</td>
<td align="left">配置<code>反向代理服务器</code>并<code>设置缓存策略</code>，将用户请求转发到缓存服务器，减轻后端服务器的负载并加速内容的访问。</td>
<td>1.加速内容的访问速度，提升用户体验<br />2.减轻源服务器负载，提高系统可扩展性</td>
<td>只适用于特定的Web服务器和应用程序</td>
<td>1.动态内容和静态资源的缓存和加速访问<br /> 2. 减轻后端服务器的负载</td>
</tr>
<tr>
<td>本地缓存</td>
<td>应用程序在用户设备上的缓存，用于缓存数据和资源以提高应用的性能和响应速度。</td>
<td align="left">使用缓存库或框架（如<code>localStorage</code>、<code>sessionStorage</code>、<code>Workbox</code>等）来实现。</td>
<td>1.提升应用的性能和响应速度<br />2. 减少对远程资源的依赖，提高离线使用体验</td>
<td>本地缓存容量受限于用户设备的存储空间</td>
<td>1.频繁访问的数据或资源<br /> 2.提升应用的性能和响应速度</td>
</tr>
<tr>
<td>分布式缓存</td>
<td>在分布式系统中使用的缓存，用于存储和共享数据。分布式缓存通常部署在多台服务器上，并提供高并发读写能力和数据访问的可扩展性。分布式缓存常用于大规模应用和系统中。</td>
<td align="left">使用分布式缓存系统（如<code>Redis</code>、<code>Memcached</code>等）来存储和访问缓存数据。</td>
<td>高并发读写能力和数据存储的可扩展性</td>
<td>1.需要额外的服务器资源来部署和管理分布式缓存系统<br /> 2.缓存一致性和数据同步问题需要考虑</td>
<td>1.高并发读写能力和数据存储的可扩展性<br /> 2.大规模应用和系统的缓存和数据共享</td>
</tr>
</tbody></table>
<p>根据具体需求和系统架构，选择适合的缓存类型和方案，以提高系统性能、减轻服务器负载、改善用户体验和保证数据一致性。</p>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>浏览器缓存是指<strong>将网页中的资源（如HTML、CSS、JavaScript、图像等）存储在用户的浏览器内部</strong>，以便在后续请求同一资源时可以直接从本地缓存中获取，而无需再次从服务器下载。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>浏览器缓存适用于<strong>静态内容变化较少的网页和静态资源</strong>，可以显著提升网站性能和用户体验，并减少服务器的负载。</p>
<h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>使用浏览器缓存可以通过<strong>设置响应头中的<code>Expires</code>和<code>Cache-Control</code>字段来控制缓存的行为</strong>。</p>
<ol>
<li><strong>使用Expires字段：</strong>Expires字段<strong>指定了缓存的过期时间，是一个具体的日期和时间</strong>。服务器可以在响应头中添加Expires字段，告诉浏览器在该时间之前可以直接从缓存中获取资源，而无需再向服务器发起请求。例如：Expires: Mon, 31 Dec 2022 23:59:59 GMT。</li>
<li><strong>使用Cache-Control字段：</strong>Cache-Control字段提供了更灵活的缓存控制选项。可以通过设置<code>max-age</code>指令来指定缓存的最大有效时间，单位是秒。例如：Cache-Control: max-age=3600 表示资源可以在1小时内直接从缓存中获取。还可以使用其他指令，如no-cache表示缓存但不使用缓存、no-store表示禁止缓存等。</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>浏览器缓存存储<strong>实时性不敏感的数据</strong>，如商品框架、商家评分、评价和广告词。它有过期时间，并通过响应头进行控制。实时性要求高的数据不适合使用浏览器缓存。</p>
<h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>客户端缓存是<strong>将数据存储在浏览器</strong>中，以提高访问速度和减少服务器请求。</p>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>在大促期间，为了防止服务端承受瞬间的高流量压力，可以<strong>提前将一些素材（如js/css/image等）下发到客户端进行缓存</strong>，避免在大促期间再次请求这些素材。此外，还可以<strong>将一些兜底数据或样式文件存放在客户端缓存</strong>中，以确保在服务端异常或网络异常的情况下，保持app的正常运行。</p>
<h2 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>CDN（<code>Content Delivery Network</code>）是建立在承载网之上的<strong>分布式网络，由分布在不同区域的边缘节点服务器组成</strong>。 </p>
<p>CDN缓存通常用于<strong>存放静态页面数据、活动页面、图片等数据</strong>。</p>
<p>CDN的两种<strong>缓存机制</strong>：<code>推送机制</code>（将数据主动推送到CDN节点）和<code>拉取机制</code>（首次访问时从源服务器获取数据并存储在CDN节点）。</p>
<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>CDN缓存可以提高网站访问速度，适用于<strong>网站访问量大、访问速度慢、数据变化不频繁的场景</strong>。</p>
<h3 id="常用工具以及用法"><a href="#常用工具以及用法" class="headerlink" title="常用工具以及用法"></a><strong>常用工具以及用法</strong></h3><p>常见的CDN缓存工具包括<code>Cloudflare</code>、<code>Akamai</code>、<code>Fastly</code>和<code>AWS CloudFront</code>等。这些工具提供了全球分布的CDN网络，以加速内容传输和提升性能。它们<strong>提供了控制台和API，用于配置CDN缓存规则、管理缓存内容、刷新和更新缓存等</strong>。</p>
<h2 id="反向代理缓存"><a href="#反向代理缓存" class="headerlink" title="反向代理缓存"></a>反向代理缓存</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>反向代理缓存是指<strong>在反向代理服务器上对请求的响应进行缓存</strong>，以提高服务的性能和用户体验。它<strong>将经常请求的静态内容缓存在代理服务器上</strong>，当有用户请求同样的内容时，代理服务器会直接返回缓存的响应，而无需再次向源服务器请求。</p>
<h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>适用于访问外部服务速度比较慢，但是<strong>数据变化不频繁</strong>的场景。</p>
<h3 id="常用工具以及用法-1"><a href="#常用工具以及用法-1" class="headerlink" title="常用工具以及用法"></a><strong>常用工具以及用法</strong></h3><p>1.<strong>Nginx：</strong>一款高性能的反向代理服务器，支持反向代理缓存功能，可通过配置文件进行缓存策略的设置。Nginx代理层缓存主要以<code>Http</code>模块与<code>proxy_cacahe</code>模块进行配置即可。</p>
<p>2.<strong>Varnish：</strong>一个专门用于反向代理缓存的开源软件，可以高效地缓存并提供快速的响应。</p>
<p>3.<strong>Squid：</strong>一款功能强大的缓存代理服务器，支持反向代理缓存和正向代理缓存。</p>
<h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>本地缓存是将数据或资源存储在客户端的存储介质中，如硬盘、内存或数据库。它可以是临时的，只在应用程序运行期间有效，或者可以是持久的，即在不同的应用程序会话中保持有效。</p>
<h3 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>本地缓存适用于<strong>频繁访问数据</strong>、离线访问、减少带宽消耗和提升用户体验的场景。</p>
<h3 id="常用工具以及用法-2"><a href="#常用工具以及用法-2" class="headerlink" title="常用工具以及用法"></a><strong>常用工具以及用法</strong></h3><p><strong>一般分为磁盘缓存、CPU缓存、应用缓存</strong></p>
<ol>
<li><strong>磁盘缓存：</strong>存储在硬盘等永久性存储介质上，用于加速数据的读取和访问。</li>
<li><strong><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=CPU%E7%BC%93%E5%AD%98&spm=1001.2101.3001.7020">CPU缓存</a>：</strong>位于处理器内部的高速存储器，用于<strong>暂时存储频繁访问的数据或指令</strong>，提高计算机的性能。</li>
<li><strong>应用缓存：</strong>存储在内存中的应用程序数据或资源，用于提高应用程序的响应速度和用户体验。用Java服务来举例，又分为 <strong>堆内缓存 与 堆外缓存</strong> 。</li>
</ol>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>分布式缓存是<strong>将缓存数据分散存储在多台服务器上</strong>的缓存解决方案。</p>
<h3 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p><strong>高并发读取、数据共享和协同处理、提供弹性和可扩展性、降低后端请求次数</strong>等场景。</p>
<h3 id="常用工具以及用法-3"><a href="#常用工具以及用法-3" class="headerlink" title="常用工具以及用法"></a><strong>常用工具以及用法</strong></h3><ol>
<li><strong><code>Redis</code>：</strong>Redis是一种<strong>高性能的键值存储系统，支持丰富的数据类型和灵活的缓存策略</strong>。可以使用Redis搭建分布式缓存集群，利用其快速的读写能力和一致性哈希算法实现数据分片和负载均衡。</li>
<li><strong><code>Memcached</code>：</strong>Memcached是一种<strong>简单而快速的分布式内存对象缓存系统</strong>，用于<strong>减轻数据库负载和加速动态Web应用程序</strong>。它采用分布哈希算法进行数据分片和分布式存储。</li>
<li><strong><code>Hazelcast</code>：</strong>Hazelcast是一个开源的<strong>分布式内存数据网格平台</strong>，<strong>提供分布式缓存和分布式计算能力</strong>。它可以用于构建高吞吐量和高可用性的分布式缓存系统。</li>
</ol>
<h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a><strong>缓存问题</strong></h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>关键词：<strong>强调缓存和数据库都没有数据+并发访问</strong>﻿<br>缓存穿透是指数据库和缓存都没有的数据，每次都要经过缓存去访问数据库，大量的请求有可能导致DB宕机。</p>
<h3 id="应对策略-1"><a href="#应对策略-1" class="headerlink" title="应对策略"></a><strong>应对策略</strong></h3><ol>
<li><strong>使用布隆过滤器（<code>Bloom Filter</code>）：</strong>布隆过滤器是一种<strong>快速判断元素是否存在的数据结构</strong>，它可以在很小的内存占用下，快速判断一个元素是否在一个集合中。<strong>将所有可能存在的数据哈希到一个足够大的位数组中</strong>，当一个请求过来时，先经过布隆过滤器判断是否存在于缓存中，如果不存在，则直接返回，避免对数据库的查询压力。</li>
<li><strong>空对象缓存：</strong>对于确定不存在的数据，在缓存中也存储一个空对象，表示该数据不存在。当请求访问这些不存在的数据时，直接从缓存中返回空对象，避免每次请求都穿透到数据库层进行查询。</li>
<li><strong>延迟双判：</strong>当一个查询请求穿透缓存到达数据库层后，先在数据库中进行查询，如果数据库也没有对应的数据，则将这个空结果写入缓存，并设置一个较短的过期时间。这样，下次相同的查询请求就会从缓存中得到空结果，而不会再次穿透到数据库。</li>
<li><strong>热点数据预加载：</strong>对于一些热点数据，在系统启动时或者在缓存过期前提前异步加载到缓存中，确保缓存的热点数据一直存在，避免被频繁请求的数据因为缓存过期而导致穿透问题。</li>
<li><strong>限流策略：</strong>针对频繁请求的特定数据，可以设置限流策略，例如使用<code>令牌桶算法</code>或<code>漏桶算法</code>，限制对这些数据的请求频率，减轻数据库的压力。</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>关键词：<strong>强调单个热点Key过期+并发访问</strong><br>缓存击穿是指数据库有，缓存没有的热点数据，大量请求访问这个缓存不存在的数据，最后请求打到DB可能导致DB宕机。</p>
<h3 id="应对策略-2"><a href="#应对策略-2" class="headerlink" title="应对策略"></a><strong>应对策略</strong></h3><ol>
<li><strong>设置热点数据的热度时间窗口：</strong>对于热点数据，可以设置一个热度时间窗口，在这个时间窗口内，如果一个数据被频繁访问，就将其缓存时间延长，避免频繁刷新缓存导致缓存击穿。</li>
<li><strong>使用互斥锁或分布式锁：</strong>在缓存失效时，只允许一个线程去查询数据库，其他线程等待查询结果。可以使用互斥锁或分布式锁来实现，确保只有一个线程能够查询数据库，其他线程等待结果，避免多个线程同时查询数据库造成数据库压力过大。</li>
<li><strong>缓存永不过期：</strong>对于一些热点数据，可以将其缓存设置为永不过期，或者设置一个很长的过期时间，这样即使缓存失效，也有足够的时间来刷新缓存，避免缓存击穿。</li>
<li><strong>异步更新缓存：</strong>在缓存失效时，可以异步地去更新缓存，而不是同步地去查询数据库并刷新缓存。这样可以减少对数据库的直接访问，并且不会阻塞其他请求的响应。</li>
<li><strong>多级缓存架构：</strong>使用多级缓存架构，将热点数据分散到多个缓存节点上，避免单一缓存节点发生故障导致整个缓存层崩溃。当某个缓存节点失效时，可以从其他缓存节点或数据库中获取数据。</li>
<li><strong>熔断机制：</strong>当缓存层发生故障或无法正常工作时，可以设置熔断机制，直接访问数据库，保证系统的正常运行。</li>
</ol>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>关键词：<strong>强调批量Key过期+并发访问</strong>﻿<br>缓存雪崩指的是在同一时段大量的缓存键（key）同时失效，导致大量请求打到数据库，最后请求打到DB可能导致DB宕机。</p>
<h3 id="应对策略-3"><a href="#应对策略-3" class="headerlink" title="应对策略"></a><strong>应对策略</strong></h3><ol>
<li><strong>使用多级缓存架构：</strong>将缓存划分为多个层级，每个层级的缓存设置不同的过期时间。例如，将热点数据存储在近期失效的缓存层级，而将非热点数据存储在长期失效的缓存层级。这样即使某一层级的缓存失效，仍然可以从其他层级获取数据，避免所有请求直接访问数据库。</li>
<li><strong>设置缓存数据的随机过期时间：</strong>在设置缓存数据的过期时间时，加上一个随机值，使得不同的缓存数据在过期时刻不一致。这样可以避免大量数据同时过期，减轻数据库负荷。</li>
<li><strong>分布式锁或互斥锁：</strong>在缓存失效时，使用分布式锁或互斥锁来保证只有一个请求可以重新加载缓存。其他请求等待该请求完成后，直接从缓存中获取数据。这样可以避免多个请求同时访问数据库。</li>
<li><strong>数据预热：</strong>在系统启动或者非高峰期，提前将热点数据加载到缓存中，预热缓存。这样即使在高并发时，也能够从缓存中获取到数据，减轻数据库的压力。</li>
<li><strong>缓存限流：</strong>当检测到缓存失效时，可以对请求进行限流处理，限制并发请求的数量。这样可以避免大量请求同时访问数据库，导致数据库负载过大。</li>
<li><strong>数据库优化：</strong>对于缓存雪崩问题，除了缓存层面的应对策略，还可以从数据库层面进行优化，如提升数据库性能、增加数据库的容量等，以应对大量请求导致的数据库压力。</li>
</ol>
<h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>缓存一致性指的是缓存与DB之间的数据一致性，我们需要通过各种手段来防止缓存与DB不一致，我们要保证缓存与DB的数据一致或者数据最终一致。</p>
<h3 id="应对策略-4"><a href="#应对策略-4" class="headerlink" title="应对策略"></a><strong>应对策略</strong></h3><p>针对缓存一致性问题，可以从不同的层次来应对：</p>
<ol>
<li><p><strong>数据库层</strong></p>
<ul>
<li><p>在数据库层面，可以使用<strong>事务</strong>来确保数据的一致性。通过<strong>将读写操作放在同一个事务中</strong>，可以保证数据的更新和查询是一致的。</p>
</li>
<li><p>使用数据库的<strong>触发器</strong>或者<strong>存储过程</strong>，在数据更新的同时，主动触发缓存的更新操作，确保缓存与数据库的数据保持一致。</p>
</li>
</ul>
</li>
<li><p><strong>缓存层</strong></p>
<ul>
<li><p>在缓存层面，可以使用缓存更新策略，通过<strong>定时任务、异步消息队列</strong>等方式，定期或者在数据更新时<strong>异步地更新缓存</strong>，保持缓存与数据库的数据一致性。</p>
</li>
<li><p>使用<strong>互斥锁或者分布式锁来保证对缓存的读写操作的原子性</strong>，避免数据冲突。</p>
</li>
<li><p>设置<strong>合适的缓存过期时间</strong>，避免缓存数据长时间过期而导致数据不一致的问题。</p>
</li>
</ul>
</li>
<li><p><strong>应用层</strong></p>
<ul>
<li><p>在应用层面，可以采用<strong>读写分离策略，将读请求和写请求分发到不同的节点</strong>，读请求直接从缓存中获取数据，写请求则更新数据库并更新缓存，保持数据的一致性。</p>
</li>
<li><p>使用<strong>缓存中间件或者缓存组件，提供自动更新缓存</strong>的功能，减少手动维护缓存的复杂性。</p>
</li>
</ul>
</li>
<li><p><strong>监控和报警</strong></p>
<ul>
<li>建立监控和报警机制，通过监控缓存层和数据库层状态、数据一致性等指标，及时发现异常情况，并触发报警，以便及时处理。</li>
</ul>
</li>
</ol>
<p>综合使用以上层次的策略，可以有效地应对缓存一致性问题，保证数据的一致性和系统的稳定性。不同层次的策略可以相互配合，形成一个完善的缓存一致性解决方案。</p>
<hr>
<h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><h2 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>再强大的系统，也怕<strong>流量短事件内集中爆发</strong>，就像银行怕挤兑一样，所以，高并发另一个必不可少的模块就是限流。</p>
<p>限流是一种通过<strong>控制请求的速率或数量</strong>来保护系统免受过载的技术。流控的精髓是<strong>限制单位时间内的请求量</strong>，最大程度保障系统的可靠性及可用性。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h2><p>限流是在高并发环境下，为了保护系统的稳定性和可用性而引入的一种策略。通过限制并发请求的数量或频率，可以防止系统被过多的请求压垮或耗尽资源。</p>
<h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a><strong>限流算法</strong></h2><p>常见的流控算法包括：<strong>固定窗口、滑动窗口、漏桶、令牌桶、滑动日志</strong>等算法。</p>
<h3 id="固定窗口算法（计数器）"><a href="#固定窗口算法（计数器）" class="headerlink" title="固定窗口算法（计数器）"></a>固定窗口算法（计数器）</h3><h4 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>固定窗口限流算法（<code>Fixed Window Rate Limiting Algorithm</code>）原理是<strong>在固定时间窗口(单位时间)内限制请求的数量</strong>。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>固定窗口是最简单的流控算法。即，给定<strong>时间窗口</strong>，维护一个<strong>计数器</strong>用于统计访问次数，并实现以下规则：</p>
<ol>
<li>如果<em>访问次数小于阈值</em>，则允许访问，访问次数+1；</li>
<li>如果<em>访问次数超出阈值</em>，则限制访问，访问次数不增；</li>
<li>如果<em>超过了时间窗口，计数器清零</em>，并重置清零后的首次成功访问时间为当前时间。</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedWindowRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 统计请求数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">lastAcquireTime</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 记录上一次获取请求的时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">windowUnit</span> <span class="operator">=</span> <span class="number">1000L</span>; <span class="comment">// 假设固定时间窗口是1000ms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 窗口阀值是10，表示在时间窗口内的请求数阀值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字来实现线程安全</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">// 获取系统当前时间</span></span><br><span class="line">        <span class="keyword">if</span> (currentTime - lastAcquireTime &gt; windowUnit) &#123;  <span class="comment">// 检查 当前时间距离上次获取请求的时间 是否在时间窗口内</span></span><br><span class="line">            counter = <span class="number">0</span>;  <span class="comment">// 计数器清零</span></span><br><span class="line">            lastAcquireTime = currentTime;  <span class="comment">// 开启新的时间窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (counter &lt; threshold) &#123;  <span class="comment">// 小于阀值</span></span><br><span class="line">            counter++;  <span class="comment">// 计数器加1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 超过阀值，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适用场景-6"><a href="#适用场景-6" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul>
<li>保护后端服务免受大流量冲击，避免服务崩溃</li>
<li>对 API 调用进行限制，保证公平使用</li>
<li>防止恶意用户对服务进行洪水攻击</li>
</ul>
<h4 id="优劣分析"><a href="#优劣分析" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul>
<li><p><strong>优势：</strong>算法简单，易于实现和理解；<strong>性能高</strong></p>
</li>
<li><p><strong>劣势：</strong>存在明显的<strong>临界问题</strong>。</p>
<ul>
<li>比如：假设限流阀值为5个请求，单位时间窗口是1s，如果我们在单位时间内的<strong>前0.8-1s</strong>和<strong>1-1.2s</strong>，分别并发5个请求。虽然都没有超过阀值，但是如果算<strong>0.8-1.2s</strong>内的，则并发数高达10，已经超过单位时间1s不超过5阀值的定义了。</li>
</ul>
</li>
</ul>
<h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><h4 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>滑动窗口算法是把大的时间窗口拆分成若干<strong>粒度更细</strong>的子窗口，每个子窗口独立统计，<strong>按子窗口时间滑动</strong>，统一限流。当滑动窗口的格子周期划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。（<strong>为了解决临界突变问题</strong>）</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>将单位时间周期分为<strong>n个小周期</strong>，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。它可以解决固定窗口临界值的问题。</p>
<p>假设单位时间是<strong>1s</strong>，滑动窗口算法把它划分为<strong>5个小周期</strong>，也就是滑动窗口（单位时间）被划分为<strong>5个小格子</strong>。每格表示<strong>0.2s</strong>。每过<strong>0.2s</strong>，时间窗口就会往右滑动一格。<strong>每个小周期，都有自己独立的计数器</strong>，如果请求是<strong>0.83s</strong>到达的，<strong>0.8~1.0s</strong>对应的计数器就会<strong>加1</strong>。</p>
<p>假设我们1s内的限流阀值还是5个请求，0.8<del>1.0s内（比如0.9s的时候）来了5个请求，落在黄色格子里。﻿时间过了1.0s这个点之后，又来5个请求，落在紫色格子里。如果是固定窗口算法，是不会被限流的，但是滑动窗口的话，每过一个小周期，它会右移一个小格。过了1.0s这个点后，会右移一小格，当前的单位时间段是0.2</del>1.2s，这个区域的请求已经超过限定的5了，已触发限流啦，实际上，紫色格子的请求都被拒绝。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/1bb637a70d4209bc6aefb86b4ae94704.png" alt="img"></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Long&gt; timestamps; <span class="comment">// 存储请求的时间戳队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> windowSize; <span class="comment">// 窗口大小，即时间窗口内允许的请求数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> windowDuration; <span class="comment">// 窗口持续时间，单位：毫秒</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SlidingWindowRateLimiter</span><span class="params">(<span class="type">int</span> windowSize, <span class="type">long</span> windowDuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.windowSize = windowSize;</span><br><span class="line">        <span class="built_in">this</span>.windowDuration = windowDuration;</span><br><span class="line">        <span class="built_in">this</span>.timestamps = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字来实现线程安全</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        <span class="comment">// 删除超过窗口持续时间的时间戳</span></span><br><span class="line">        <span class="keyword">while</span> (!timestamps.isEmpty() &amp;&amp; currentTime - timestamps.peek() &gt; windowDuration) &#123;</span><br><span class="line">            timestamps.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timestamps.size() &lt; windowSize) &#123; <span class="comment">// 判断当前窗口内请求数是否小于窗口大小</span></span><br><span class="line">            timestamps.offer(currentTime); <span class="comment">// 将当前时间戳加入队列</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 超过窗口大小，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适用场景-7"><a href="#适用场景-7" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>同固定窗口的场景，且对流量限制要求较高的场景，<strong>需要更好地应对突发流量</strong>。</p>
<h4 id="优劣分析-1"><a href="#优劣分析-1" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul>
<li><p><strong>优势：</strong>简单易懂；<strong>精度高</strong>（通过调整时间窗口的大小来实现不同的限流效果）；<strong>可扩展性强</strong>（易与其他限流算法结合使用）</p>
</li>
<li><p><strong>劣势：</strong>突发流量无法处理（无法应对短时间内的大量请求，但是一旦到达限流后，请求都会直接暴力被拒绝。这样我们会损失一部分请求，这其实对于产品来说，并不太友好），需要合理调整时间窗口大小。</p>
</li>
</ul>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><h4 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a><strong>简介</strong></h4><p><strong>基于（出口）流速来做流控。</strong>在网络通信中常用于流量整形，可以很好地解决平滑度问题。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul>
<li>可以以任意速率流入水滴到漏桶（流入请求）</li>
<li>漏桶具有固定容量，出水速率是固定常量（流出请求）</li>
<li>如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）</li>
</ul>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a><strong>原理</strong></h4><ul>
<li><p><strong>思想：</strong>将数据包看作是水滴，漏桶看作是一个固定容量的水桶，数据包像水滴一样从桶的顶部流入桶中，并通过桶底的一个小孔以一定的速度流出，从而限制了数据包的流量</p>
</li>
<li><p><strong>工作原理：</strong>对于每个到来的数据包，都将其加入到漏桶中，并检查漏桶中当前的水量是否超过了漏桶的容量。若超过了容量，就将多余的数据包丢弃。若漏桶中还有水，就以一定的速率从桶底输出数据包，保证输出的速率不超过预设的速率，从而达到限流目的。</p>
</li>
</ul>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakyBucketRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> capacity; <span class="comment">// 漏桶容量，即最大允许的请求数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> rate; <span class="comment">// 漏水速率，即每秒允许通过的请求数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> water; <span class="comment">// 漏桶当前水量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> lastTime; <span class="comment">// 上一次请求通过的时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeakyBucketRateLimiter</span><span class="params">(<span class="type">long</span> capacity, <span class="type">long</span> rate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.rate = rate;</span><br><span class="line">        <span class="built_in">this</span>.water = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lastTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字来实现线程安全</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> now - lastTime; <span class="comment">// 计算从上一次请求通过到当前的时间间隔</span></span><br><span class="line">        water = Math.max(<span class="number">0</span>, water - elapsedTime * rate / <span class="number">1000</span>); <span class="comment">// 计算漏桶中的水量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (water &lt; capacity) &#123; <span class="comment">// 判断漏桶中的水量是否小于容量</span></span><br><span class="line">            water++; <span class="comment">// 漏桶中的水量加1</span></span><br><span class="line">            lastTime = now; <span class="comment">// 更新上一次请求通过的时间戳</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 漏桶已满，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适用场景-8"><a href="#适用场景-8" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>一般用于保护第三方的系统，比如自身的系统需要调用第三方的接口，为了保护第三方的系统不被自身的调用打垮，便可以通过漏斗算法进行限流，保证自身的流量平稳的打到第三方的接口上。</p>
<h4 id="优劣分析-2"><a href="#优劣分析-2" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul>
<li><p><strong>优势</strong></p>
<ul>
<li><p>可以平滑限制请求的处理速度，<strong>避免瞬间请求过多导致系统崩溃或者雪崩</strong>。</p>
</li>
<li><p>可以<strong>控制请求的处理速度</strong>，使得系统可以适应不同的流量需求，<strong>避免过载或者过度闲置</strong>。</p>
</li>
<li><p>可以通过<strong>调整桶的大小和漏出速率来满足不同的限流需求</strong>，可以灵活地适应不同的场景。</p>
</li>
</ul>
</li>
<li><p><strong>劣势</strong></p>
<ul>
<li><p>需要<strong>对请求进行缓存</strong>，会增加服务器的内存消耗。</p>
</li>
<li><p>对于流量波动比较大的场景，需要较为灵活的参数配置才能达到较好的效果。</p>
</li>
<li><p>但是面对突发流量的时候，漏桶算法还是循规蹈矩地处理请求，这不是我们想看到的啦。流量变突发时，我们肯定希望系统尽量快点处理请求，提升用户体验。</p>
</li>
</ul>
</li>
</ul>
<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><h4 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>基于（入口）流速来做流控的一种限流算法。</p>
<h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>该算法维护一个固定容量的令牌桶，每秒钟会向令牌桶中放入一定数量的令牌。当有请求到来时，如果令牌桶中有足够的令牌，则请求被允许通过并从令牌桶中消耗一个令牌，否则请求被拒绝。<strong>Guava</strong>的<strong>RateLimiter</strong>限流组件，就是基于令牌桶算法实现的。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenBucketRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> capacity; <span class="comment">// 令牌桶容量，即最大允许的请求数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> rate; <span class="comment">// 令牌产生速率，即每秒产生的令牌数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> tokens; <span class="comment">// 当前令牌数量</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService scheduler; <span class="comment">// 调度器，用于调度令牌补充任务的线程池。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TokenBucketRateLimiter</span><span class="params">(<span class="type">long</span> capacity, <span class="type">long</span> rate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.rate = rate;</span><br><span class="line">        <span class="built_in">this</span>.tokens = capacity;</span><br><span class="line">        <span class="built_in">this</span>.scheduler = <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>);</span><br><span class="line">        scheduleRefill(); <span class="comment">// 启动令牌补充任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleRefill</span><span class="params">()</span> &#123; <span class="comment">// 使用调度器定期执行令牌补充任务，每秒补充一次令牌</span></span><br><span class="line">        scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">// 通过加锁的方式更新令牌数量，确保线程安全。</span></span><br><span class="line">                tokens = Math.min(capacity, tokens + rate); <span class="comment">// 补充令牌(当前令牌数量加上产生速率)，但不超过容量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS); <span class="comment">// 每秒产生一次令牌</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字实现线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (tokens &gt; <span class="number">0</span>) &#123; <span class="comment">// 判断令牌数量是否大于0</span></span><br><span class="line">            tokens--; <span class="comment">// 消耗一个令牌</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 令牌不足，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适用场景-9"><a href="#适用场景-9" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>一般用于保护自身的系统，对调用者进行限流，保护自身的系统不被突发的流量打垮。如果自身的系统实际的处理能力强于配置的流量限制时，可以允许一定程度的流量突发，使得实际的处理速率高于配置的速率，充分利用系统资源。</p>
<h4 id="优劣分析-3"><a href="#优劣分析-3" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul>
<li><p><strong>优势</strong></p>
<ul>
<li><p><strong>稳定性高：</strong>令牌桶算法可以<strong>控制请求的处理速度</strong>，可以使系统的负载变得稳定。</p>
</li>
<li><p><strong>精度高：</strong>令牌桶算法可以根据实际情况<strong>动态调整生成令牌的速率</strong>，可以实现较高精度的限流。</p>
</li>
<li><p><strong>弹性好：</strong>令牌桶算法可以<strong>处理突发流量</strong>，可以在短时间内提供更多的处理能力，以处理突发流量。</p>
</li>
</ul>
</li>
<li><p><strong>劣势</strong></p>
<ul>
<li><p><strong>实现复杂：</strong>相对于固定窗口算法等其他限流算法，令牌桶算法的实现较为复杂。</p>
</li>
<li><p><strong>对短时请求难以处理：</strong>在短时间内有大量请求到来时，可能会导致令牌桶中的令牌被快速消耗完，从而限流。这种情况下，可以考虑使用漏桶算法。</p>
</li>
<li><p><strong>时间精度要求高：</strong>令牌桶算法<strong>需要在固定的时间间隔内生成令牌</strong>，因此要求时间精度较高，如果系统时间不准确，可能会导致限流效果不理想。</p>
</li>
</ul>
</li>
</ul>
<h3 id="滑动日志算法（比较冷门）"><a href="#滑动日志算法（比较冷门）" class="headerlink" title="滑动日志算法（比较冷门）"></a>滑动日志算法（比较冷门）</h3><h4 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>滑动日志限速算法需要<strong>记录请求的时间戳</strong>，通常使用有序集合来存储，我们可以在单个有序集合中跟踪用户在一个时间段内所有的请求。</p>
<h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>滑动日志算法可以用于<strong>实现限流功能，即控制系统在单位时间内处理请求的数量</strong>，以保护系统免受过载的影响。以下是滑动日志算法用于限流的原理：</p>
<ol>
<li><strong>划分时间窗口：</strong>将时间划分为固定的时间窗口，例如每秒、每分钟或每小时等。</li>
<li><strong>维护滑动窗口：</strong>使用一个滑动窗口来记录每个时间窗口内的请求次数。这个滑动窗口可以是一个固定长度的队列或数组。</li>
<li><strong>请求计数：</strong>当一个请求到达时，将其计数加一并放入当前时间窗口中。</li>
<li><strong>滑动：</strong>随着时间的流逝，滑动窗口会根据当前时间窗口的长度，移除最旧的请求计数，并将新的请求计数添加到最新的时间窗口中。</li>
<li><strong>限流判断：</strong>在每个时间窗口结束时，统计滑动窗口中的请求计数总和，并与预设的阈值进行比较。如果总请求数超过阈值，则触发限流处理。</li>
<li><strong>限流处理：</strong>一旦触发限流，可以采取不同的处理策略，如拒绝请求、延迟处理、返回错误信息等。具体的限流策略可以根据实际情况进行选择。</li>
</ol>
<p>通过滑动日志算法进行限流，可以<strong>实现对单位时间内的请求进行精确控制</strong>。它<strong>基于实时统计的方式</strong>，能够动态地适应请求流量的变化，并且在内存使用上比较高效。同时，通过调整时间窗口的长度和阈值的设置，可以<strong>灵活地控制限流的精度和灵敏度</strong>。</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingLogRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> requests; <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; timestamps; <span class="comment">// 存储请求的时间戳列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> windowDuration; <span class="comment">// 窗口持续时间，单位：毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// 窗口内的请求数阀值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SlidingLogRateLimiter</span><span class="params">(<span class="type">int</span> threshold, <span class="type">long</span> windowDuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.requests = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.timestamps = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.windowDuration = windowDuration;</span><br><span class="line">        <span class="built_in">this</span>.threshold = threshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字实现线程安全</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 获取当前时间戳</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除超过窗口持续时间的时间戳</span></span><br><span class="line">        <span class="keyword">while</span> (!timestamps.isEmpty() &amp;&amp; currentTime - timestamps.get(<span class="number">0</span>) &gt; windowDuration) &#123;</span><br><span class="line">            timestamps.remove(<span class="number">0</span>);</span><br><span class="line">            requests--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (requests &lt; threshold) &#123; <span class="comment">// 判断当前窗口内请求数是否小于阀值</span></span><br><span class="line">            timestamps.add(currentTime); <span class="comment">// 将当前时间戳添加到列表</span></span><br><span class="line">            requests++; <span class="comment">// 请求总数增加</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 超过阀值，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适用场景-10"><a href="#适用场景-10" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>对<strong>实时性要求高</strong>，且需要精确控制请求速率的高级限流场景。</p>
<h4 id="优劣分析-4"><a href="#优劣分析-4" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul>
<li><p><strong>优势：</strong></p>
<ul>
<li><p>滑动日志能够<strong>避免突发流量</strong>，实现较为精准的限流；</p>
</li>
<li><p>更加灵活，能够<strong>支持更加复杂的限流策略</strong>，如多级限流，每分钟不超过100次，每小时不超过300次，每天不超过1000次，我们只需要保存最近24小时所有的请求日志即可实现。</p>
</li>
</ul>
</li>
<li><p><strong>劣势：</strong>占用存储空间要高于其他限流算法。</p>
</li>
</ul>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a><strong>常用工具</strong></h2><h3 id="RateLimiter（单机）"><a href="#RateLimiter（单机）" class="headerlink" title="RateLimiter（单机）"></a>RateLimiter（单机）</h3><h4 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>基于<strong>令牌桶算法</strong>实现的一个多线程限流器，它可以将请求均匀的进行处理，当然他并不是一个分布式限流器，只是对单机进行限流。它可以应用在定时拉取接口数。通过aop、filter、Interceptor 等都可以达到限流效果。</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h4><p>以下是一个基本的 RateLimiter 用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个每秒允许2个请求的RateLimiter</span></span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 请求RateLimiter一个令牌，会阻塞当前线程直到获取到许可</span></span><br><span class="line">            rateLimiter.acquire(); </span><br><span class="line">            <span class="comment">// 执行操作</span></span><br><span class="line">            doSomeLimitedOperation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomeLimitedOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟一些操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Operation executed at: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rateLimiter.acquire()</code> 方法会阻塞当前线程直到获取到许可，确保调用 <code>doSomeLimitedOperation()</code> 操作的频率不会超过限制。</p>
<p><code>RateLimiter</code> 还提供了其他的方法，例如<code>tryAcquire()</code>，它会尝试获取许可而不会阻塞，立即返回获取成功或失败的结果。还可以设置等待时间上限，比如 <code>tryAcquire(long timeout, TimeUnit unit) </code>可以设置最大等待时间。</p>
<p>Guava的RateLimiter非常灵活，它支持平滑突发限制（<code>SmoothBursty</code>）和平滑预热限制（<code>SmoothWarmingUp</code>）等多种模式，可以根据特定的应用场景来选择合适的限流策略。</p>
<h3 id="sentinel（单机或者分布式）"><a href="#sentinel（单机或者分布式）" class="headerlink" title="sentinel（单机或者分布式）"></a>sentinel（单机或者分布式）</h3><h4 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h4><p><code>Sentinel</code>是阿里巴巴开源的一款面向分布式系统的<strong>流量控制和熔断降级组件</strong>。它提供了实时的<strong>流量控制、熔断降级、系统负载保护和实时监控</strong>等功能，可以帮助开发者保护系统的稳定性和可靠性。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250626112616426.png" alt="image-20250626112616426"></p>
<ul>
<li><code>DefaultController</code>：是一个非常典型的<strong>滑动窗口计数器</strong>算法实现，将当前统计的qps和请求进来的qps进行求和，小于限流值则通过，大于则计算一个等待时间，稍后再试；</li>
<li><code>ThrottlingController</code>：是<strong>漏斗算法</strong>的实现，实现思路已经在源码片段中加了备注；</li>
<li><code>WarmUpController</code>：实现参考了Guava的带预热的RateLimiter，区别是Guava侧重于请求间隔，类似前面提到的<strong>令牌桶</strong>，而Sentinel更关注于请求数，和令牌桶算法有点类似；</li>
<li><code>WarmUpRateLimiterController</code>：低水位使用<strong>预热算法</strong>，高水位使用<strong>滑动窗口计数器</strong>算法排队。</li>
</ul>
<h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a><strong>集群模式</strong></h4><p>Sentinel 集群限流服务端有两种启动方式：</p>
<ul>
<li>嵌入模式（Embedded）适合应用级别的限流，部署简单，但对应用性能有影响</li>
<li>独立模式（Alone）适合全局限流，需要独立部署</li>
</ul>
<h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a><strong>用法</strong></h4><p>Sentinel的用法主要包括以下几个方面：</p>
<ol>
<li><p><strong>引入依赖：</strong>可以使用Maven或Gradle进行依赖管理。例如，在Maven项目的pom.xml文件中添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>配置规则：</strong>根据实际需求，配置Sentinel的<strong>流量控制规则、熔断降级规则</strong>等。可以通过编程方式或配置文件方式进行规则的配置。例如，可以在启动类中使用<strong>注解方式</strong>配置流量控制规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(value = &quot;demo&quot;, blockHandler = &quot;handleBlock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>启动Agent：</strong>在应用启动时，启动Sentinel的Agent，开启对系统的流量控制和熔断降级功能的保护。可以通过命令行启动Agent，或者在代码中进行启动。例如，在Spring Boot的启动类中添加如下代码：</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;    
    System.setProperty(&quot;csp.sentinel.dashboard.server&quot;, &quot;localhost:8080&quot;); // 设置控制台地址
    System.setProperty(&quot;project.name&quot;, &quot;your-project-name&quot;); // 设置应用名称 
    com.alibaba.csp.sentinel.init.InitExecutor.doInit();    
    SpringApplication.run(YourApplication.class, args);
&#125;
</code></pre>
</li>
<li><p><strong>监控和管理：</strong>使用Sentinel的控制台进行<strong>实时监控、配置管理</strong>等操作。可以通过浏览器访问<strong>Sentinel的控制台界面</strong>，查看系统的运行情况和流量控制情况。通过控制台，可以对规则进行动态修改，查看监控数据和告警信息。</p>
</li>
</ol>
<h3 id="Nginx（分布式）"><a href="#Nginx（分布式）" class="headerlink" title="Nginx（分布式）"></a>Nginx（分布式）</h3><h4 id="简介-14"><a href="#简介-14" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>Nginx从网关这一层面考虑，可以作为最前置的网关，抵挡大部分的网络流量，因此使用Nginx进行限流也是一个很好的选择，在Nginx中，也提供了常用的基于限流相关的策略配置。</p>
<h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a><strong>用法</strong></h4><p>Nginx 提供了两种限流方法：一种是<strong>控制速率</strong>，另一种是<strong>控制并发连接数</strong>。</p>
<h3 id="控制速率"><a href="#控制速率" class="headerlink" title="控制速率"></a><strong>控制速率</strong></h3><p>我们需要使用 <code>limit_req_zone</code> 用来限制单位时间内的请求数，即速率限制，因为Nginx的限流统计是基于毫秒的，我们设置的速度是 <code>2r/s</code>，转换一下就是500毫秒内单个IP只允许通过1个请求，从501ms开始才允许通过第2个请求。</p>
<h4 id="控制速率优化版"><a href="#控制速率优化版" class="headerlink" title="控制速率优化版"></a><strong>控制速率优化版</strong></h4><p>上面的速率控制虽然很精准但是在生产环境未免太苛刻了，实际情况下我们应该<strong>控制一个IP单位总时间内的总访问次数</strong>，而不是像上面那样精确到毫秒，我们可以使用 <code>burst</code> 关键字开启此设置。</p>
<p><code>burst=4</code>意思是<strong>每个IP最多允许4个突发请求</strong></p>
<h4 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a><strong>控制并发数</strong></h4><p>利用 <code>limit_conn_zone</code> 和 <code>limit_conn</code> 两个指令即可<strong>控制并发数</strong>，其中 <code>limit_conn perip 10</code> 表示<strong>限制单个 IP 同时最多能持有 10 个连接</strong>；<code>limit_conn perserver 100</code> 表示 <strong>server 同时能处理并发连接的总数为 100 个</strong>。</p>
<p><strong>注意：</strong>只有当 <code>request header</code> 被后端处理后，这个连接才进行计数。﻿</p>
<hr>
<h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><h2 id="简介-15"><a href="#简介-15" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>降级是在高并发或异常情况下<strong>舍弃非关键业务或简化处理的一种技术手段</strong>。按类型可分为有感降级，无感降级。</p>
<ul>
<li><strong>有感降级：</strong>主要是通过一定的监控感知到异常出现或即将出现，对调用服务进行快速失败返回或者进行切换，在指标回正的时候恢复服务调用，这个也可以称为熔断。</li>
<li><strong>无感降级：</strong>系统不作感知，在调用服务出现异常则自动忽略，进行空返回或无操作。降级的本质为作为服务调用方去规避提供方带来的风险。</li>
</ul>
<h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>在限流中，服务调用方为每一个调用的服务维护一个有限状态机，在这个状态机会有三种状态：关闭（调用远程服务）、半打开（尝试调用远程服务）和打开（返回错误）。这三种状态之间切换的过程如下：﻿</p>
<ul>
<li>当调用失败的次数累积到一定阈值，熔断机制从关闭态切换到打开态。一般在实现时，如果调用成功一次，就会重置调用失败次数。</li>
<li>当熔断处于打开状态时，我们会启动一个计时器，当计时器超时后，状态切换到半打开态。也可以通过设置一个定时器，定期的探测服务是否恢复。</li>
<li>当熔断处于半打开状态时，请求可以达到后端服务，如果累计一定的成功次数后，状态切换到关闭态；如果出现调用失败的情况，则切换到打开态。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250626114727317.png" alt="image-20250626114727317"></p>
<h2 id="常用工具-1"><a href="#常用工具-1" class="headerlink" title="常用工具"></a><strong>常用工具</strong></h2><ul>
<li>降级开源组件：<strong>sentinel和Hystrix(不展开)</strong></li>
<li>手动降级：可采用<strong>系统配置开关</strong>来控制</li>
</ul>
<hr>
<h1 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h1><h2 id="简介-16"><a href="#简介-16" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>熔断在程序中表示“断开”。如发生了某事件，程序为了整体的稳定性，<strong>暂时（断开）停止服务一段时间</strong>，以保证程序可用时再被使用。</p>
<h2 id="熔断和降级的区别"><a href="#熔断和降级的区别" class="headerlink" title="熔断和降级的区别"></a><strong>熔断和降级的区别</strong></h2><ul>
<li><p>概念不同</p>
<ul>
<li><p>熔断程序为了整体的稳定性，所以暂时（断开）停止服务一段时间；</p>
</li>
<li><p>降级（<code>Degradation</code>）降低级别的意思，它是指程序在出现问题时，<strong>仍能保证有限功能可用</strong>的一种机制；</p>
</li>
</ul>
</li>
<li><p>触发条件不同</p>
<p>不同框架的熔断和降级的触发条件是不同，以<code>Hystrix</code>为例：</p>
<ul>
<li><p>Hystrix 熔断触发条件</p>
<ul>
<li>默认情况 hystrix 如果检测到 10 秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求。</li>
</ul>
</li>
<li><p>Hystrix 降级触发条件</p>
<ul>
<li><p>默认情况下，Hystrix 在以下 4 种条件下都会触发降级机制：</p>
<ul>
<li><p>方法抛出 <code>HystrixBadRequestException</code></p>
</li>
<li><p>方法<strong>调用超时</strong></p>
</li>
<li><p>熔断器开启拦截调用</p>
</li>
<li><p><strong>线程池或队列或信号量已满</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>归属关系不同</p>
<p>熔断时可能会调用降级机制，而降级时通常不会调用熔断机制。因为熔断是从全局出发，为了保证系统稳定性而停用服务，而降级是退而求其次，提供一种保底的解决方案，所以它们的归属关系是不同的（熔断 &gt; 降级）。</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://southernfish.github.io">Southern Fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://southernfish.github.io/2025/06/26/framwork/system-design-high-concurrency/">https://southernfish.github.io/2025/06/26/framwork/system-design-high-concurrency/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://southernfish.github.io" target="_blank">Southern Fish</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Concurrency/">Concurrency</a></div><div class="post_share"><div class="social-share" data-image="/img/article/article6.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/06/27/large-model/aws-llm/"><img class="prev-cover" src="/img/article/article5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">AWS LLM</div></div></a></div><div class="next-post pull-right"><a href="/2025/06/25/framwork/system-design/"><img class="next-cover" src="/img/article/article4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">高性能、高并发、高可用、高安全</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/06/18/java/java-thread/" title="多线程"><img class="cover" src="/img/article/article4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-18</div><div class="title">多线程</div></div></a></div><div><a href="/2025/06/23/java/java-concurrency/" title="并发编程"><img class="cover" src="/img/article/article2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-23</div><div class="title">并发编程</div></div></a></div><div><a href="/2025/06/23/java/java-thread-impl/" title="使用多线程解决问题"><img class="cover" src="/img/article/article6.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-23</div><div class="title">使用多线程解决问题</div></div></a></div><div><a href="/2025/06/25/framwork/system-design/" title="高性能、高并发、高可用、高安全"><img class="cover" src="/img/article/article4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-25</div><div class="title">高性能、高并发、高可用、高安全</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southern Fish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SouthernFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1002721576@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">天下事岂能尽如吾意，心境须恰适，尽其在我，随遇而安。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%88High-Concurrency%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">高并发（High Concurrency）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D"><span class="toc-number">1.4.</span> <span class="toc-text">影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E5%AF%B9%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.</span> <span class="toc-text">应对策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">2.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">2.2.</span> <span class="toc-text">常用技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-number">2.3.</span> <span class="toc-text">浏览器缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.2.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">常见用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.3.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98"><span class="toc-number">2.4.</span> <span class="toc-text">客户端缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">2.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">2.4.2.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDN%E7%BC%93%E5%AD%98"><span class="toc-number">2.5.</span> <span class="toc-text">CDN缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">2.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">2.5.2.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95"><span class="toc-number">2.5.3.</span> <span class="toc-text">常用工具以及用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98"><span class="toc-number">2.6.</span> <span class="toc-text">反向代理缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-number">2.6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">2.6.2.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95-1"><span class="toc-number">2.6.3.</span> <span class="toc-text">常用工具以及用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">2.7.</span> <span class="toc-text">本地缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-number">2.7.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">2.7.2.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95-2"><span class="toc-number">2.7.3.</span> <span class="toc-text">常用工具以及用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="toc-number">2.8.</span> <span class="toc-text">分布式缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="toc-number">2.8.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="toc-number">2.8.2.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95-3"><span class="toc-number">2.8.3.</span> <span class="toc-text">常用工具以及用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">缓存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">3.1.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E5%AF%B9%E7%AD%96%E7%95%A5-1"><span class="toc-number">3.1.1.</span> <span class="toc-text">应对策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">3.2.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E5%AF%B9%E7%AD%96%E7%95%A5-2"><span class="toc-number">3.2.1.</span> <span class="toc-text">应对策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">3.3.</span> <span class="toc-text">缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E5%AF%B9%E7%AD%96%E7%95%A5-3"><span class="toc-number">3.3.1.</span> <span class="toc-text">应对策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">3.4.</span> <span class="toc-text">缓存一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E5%AF%B9%E7%AD%96%E7%95%A5-4"><span class="toc-number">3.4.1.</span> <span class="toc-text">应对策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%90%E6%B5%81"><span class="toc-number">4.</span> <span class="toc-text">限流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-6"><span class="toc-number">4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">限流算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%EF%BC%88%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">固定窗口算法（计数器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-7"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-6"><span class="toc-number">4.3.1.4.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%A3%E5%88%86%E6%9E%90"><span class="toc-number">4.3.1.5.</span> <span class="toc-text">优劣分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.2.</span> <span class="toc-text">滑动窗口算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-8"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-7"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%A3%E5%88%86%E6%9E%90-1"><span class="toc-number">4.3.2.5.</span> <span class="toc-text">优劣分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.3.</span> <span class="toc-text">漏桶算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-9"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.3.3.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-8"><span class="toc-number">4.3.3.5.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%A3%E5%88%86%E6%9E%90-2"><span class="toc-number">4.3.3.6.</span> <span class="toc-text">优劣分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.4.</span> <span class="toc-text">令牌桶算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-10"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">4.3.4.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-9"><span class="toc-number">4.3.4.4.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%A3%E5%88%86%E6%9E%90-3"><span class="toc-number">4.3.4.5.</span> <span class="toc-text">优劣分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E6%97%A5%E5%BF%97%E7%AE%97%E6%B3%95%EF%BC%88%E6%AF%94%E8%BE%83%E5%86%B7%E9%97%A8%EF%BC%89"><span class="toc-number">4.3.5.</span> <span class="toc-text">滑动日志算法（比较冷门）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-11"><span class="toc-number">4.3.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">4.3.5.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">4.3.5.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-10"><span class="toc-number">4.3.5.4.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%A3%E5%88%86%E6%9E%90-4"><span class="toc-number">4.3.5.5.</span> <span class="toc-text">优劣分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">4.4.</span> <span class="toc-text">常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RateLimiter%EF%BC%88%E5%8D%95%E6%9C%BA%EF%BC%89"><span class="toc-number">4.4.1.</span> <span class="toc-text">RateLimiter（单机）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-12"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinel%EF%BC%88%E5%8D%95%E6%9C%BA%E6%88%96%E8%80%85%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%89"><span class="toc-number">4.4.2.</span> <span class="toc-text">sentinel（单机或者分布式）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-13"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">集群模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95-1"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%89"><span class="toc-number">4.4.3.</span> <span class="toc-text">Nginx（分布式）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-14"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95-2"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E9%80%9F%E7%8E%87"><span class="toc-number">4.4.4.</span> <span class="toc-text">控制速率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E7%89%88"><span class="toc-number">4.4.4.1.</span> <span class="toc-text">控制速率优化版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0"><span class="toc-number">4.4.4.2.</span> <span class="toc-text">控制并发数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%8D%E7%BA%A7"><span class="toc-number">5.</span> <span class="toc-text">降级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-15"><span class="toc-number">5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-5"><span class="toc-number">5.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7-1"><span class="toc-number">5.3.</span> <span class="toc-text">常用工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%86%94%E6%96%AD"><span class="toc-number">6.</span> <span class="toc-text">熔断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-16"><span class="toc-number">6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E5%92%8C%E9%99%8D%E7%BA%A7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.2.</span> <span class="toc-text">熔断和降级的区别</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/14/java/java-job/" title="定时任务"><img src="/img/article/article4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="定时任务"/></a><div class="content"><a class="title" href="/2025/07/14/java/java-job/" title="定时任务">定时任务</a><time datetime="2025-07-14T06:18:36.000Z" title="发表于 2025-07-14 14:18:36">2025-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/10/middleware/dubbo/" title="Dubbo"><img src="/img/article/article3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dubbo"/></a><div class="content"><a class="title" href="/2025/07/10/middleware/dubbo/" title="Dubbo">Dubbo</a><time datetime="2025-07-10T08:11:36.000Z" title="发表于 2025-07-10 16:11:36">2025-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/09/middleware/skywalking/" title="SkyWalking"><img src="/img/article/article1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SkyWalking"/></a><div class="content"><a class="title" href="/2025/07/09/middleware/skywalking/" title="SkyWalking">SkyWalking</a><time datetime="2025-07-09T11:35:36.000Z" title="发表于 2025-07-09 19:35:36">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/09/middleware/rpc/" title="远程过程调用"><img src="/img/article/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="远程过程调用"/></a><div class="content"><a class="title" href="/2025/07/09/middleware/rpc/" title="远程过程调用">远程过程调用</a><time datetime="2025-07-09T11:35:36.000Z" title="发表于 2025-07-09 19:35:36">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/08/blog/jar-jpackage-exe/" title="Springboot项目+JDK17打包exe"><img src="/img/article/article6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Springboot项目+JDK17打包exe"/></a><div class="content"><a class="title" href="/2025/07/08/blog/jar-jpackage-exe/" title="Springboot项目+JDK17打包exe">Springboot项目+JDK17打包exe</a><time datetime="2025-07-08T07:27:36.000Z" title="发表于 2025-07-08 15:27:36">2025-07-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/article/article6.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Southern Fish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>