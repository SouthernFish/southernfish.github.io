<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>贪心算法 | Southern Fish</title><meta name="keywords" content="algorithm"><meta name="author" content="Southern Fish"><meta name="copyright" content="Southern Fish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="贪心算法是一种在每一步选择中都采取当前状态下最优（即最有利）的选择，从而希望导致结果是全局最优的算法策略。  参考文章： 贪心算法（Greedy Algorithm） 【算法&#x2F;训练】：贪心（算法理论学习及实践） ＜贪心算法＞学习及经典实例分析  贪心算法详解基本定义贪心算法（Greedy Algorithm）是一种分阶段决策策略：在对问题求解时，总是做出在当前看来是最好的选择的算法，也就是当前状态">
<meta property="og:type" content="article">
<meta property="og:title" content="贪心算法">
<meta property="og:url" content="https://southernfish.github.io/2025/08/04/algorithm/greedy-algorithm/index.html">
<meta property="og:site_name" content="Southern Fish">
<meta property="og:description" content="贪心算法是一种在每一步选择中都采取当前状态下最优（即最有利）的选择，从而希望导致结果是全局最优的算法策略。  参考文章： 贪心算法（Greedy Algorithm） 【算法&#x2F;训练】：贪心（算法理论学习及实践） ＜贪心算法＞学习及经典实例分析  贪心算法详解基本定义贪心算法（Greedy Algorithm）是一种分阶段决策策略：在对问题求解时，总是做出在当前看来是最好的选择的算法，也就是当前状态">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://southernfish.github.io/img/article/article2.png">
<meta property="article:published_time" content="2025-08-04T07:20:36.000Z">
<meta property="article:modified_time" content="2025-08-11T10:38:35.500Z">
<meta property="article:author" content="Southern Fish">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://southernfish.github.io/img/article/article2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://southernfish.github.io/2025/08/04/algorithm/greedy-algorithm/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '贪心算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-11 18:38:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Southern Fish" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/article/article2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Southern Fish</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">贪心算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-04T07:20:36.000Z" title="发表于 2025-08-04 15:20:36">2025-08-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-11T10:38:35.500Z" title="更新于 2025-08-11 18:38:35">2025-08-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/algorithm/">algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>55分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="贪心算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>贪心算法是一种在每一步选择中都采取当前状态下最优（即最有利）的选择，从而希望导致结果是全局最优的算法策略。</p>
<blockquote>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_67868534/article/details/149097914">贪心算法（Greedy Algorithm）</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2527732">【算法/训练】：贪心（算法理论学习及实践）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/WandZ123/article/details/125019048">＜贪心算法＞学习及经典实例分析</a></p>
</blockquote>
<h1 id="贪心算法详解"><a href="#贪心算法详解" class="headerlink" title="贪心算法详解"></a>贪心算法详解</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>贪心算法（Greedy Algorithm）是一种<strong>分阶段决策策略</strong>：在对问题求解时，总是做出在当前看来是最好的选择的算法，也就是当前状态的局部最优解，通过迭代累积这些局部最优解，期望得到全局最优解。其核心特征是 “<strong>无后效性</strong>”（当前决策不影响后续状态）和 “<strong>贪心选择性质</strong>”（局部最优可推导全局最优）。贪心算法的核心在于<strong>贪心策略的选择</strong>，即每一步的最优选择是否能推导出全局最优解。</p>
<p>贪心算法的价值在于其<strong>简洁性与高效性</strong>，但必须警惕其局限性——<strong>局部最优未必全局最优</strong>。掌握其适用条件（贪心选择性质+最优子结构）和证明方法，方能灵活应用于任务调度、图论、组合优化等场景。</p>
<h2 id="核心性质"><a href="#核心性质" class="headerlink" title="核心性质"></a>核心性质</h2><p><strong>贪心算法采用自顶向下，以迭代的方法做出相继的贪心选择</strong>，每做一次贪心选择就将所求问题简化为一个规模更小的子问题，通过每一步贪心选择，可得到问题的一个最优解，虽然每一步上都要保证能获得局部最优解，但由此产生的全局解有时不一定是最优的，所以贪婪法不要回溯。能够用贪心算法求解的问题一般具有两个重要特性：<strong>贪心选择性质和最优子结构性质</strong></p>
<ul>
<li><strong>贪心选择性质</strong>：每一步的最优解不依赖于未来决策或子问题的解。<ul>
<li><strong>所求问题的整体最优解可以通过一系列局部最优的选择</strong>，即贪心选择来达到。这是贪心算法可行的第一个基本要素。</li>
<li>对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。</li>
<li><strong>证明的大致过程如下：</strong><ul>
<li>首先考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始。</li>
<li>做了贪心选择后，原问题简化为规模更小的类似子问题。</li>
<li>然后用数学归纳法证明通过每一步做贪心选择，最终可得到问题的整体最优解。</li>
<li>其中，证明贪心选择后的问题简化为规模更小的类似子问题的关键在于利用该问题的<strong>最优子结构性质</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>最优子结构</strong>：问题的最优解包含其子问题的最优解，与动态规划共享此性质，但贪心算法<strong>无需回溯或存储子问题解</strong>。</li>
<li><strong>无后效性</strong>：决策一旦做出，不可更改，后续状态仅由当前状态决定。</li>
</ul>
<h2 id="贪心算法与动态规划的差异"><a href="#贪心算法与动态规划的差异" class="headerlink" title="贪心算法与动态规划的差异"></a>贪心算法与动态规划的差异</h2><ul>
<li>动态规划和贪心算法都是一种递推算法，均有最优子结构性质，通过局部最优解来推导全局最优解。</li>
<li>两者之间的区别在于：<ul>
<li>贪心算法中作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一步之前的最优解则不作保留，贪心算法每一步的最优解一定包含上一步的最优解。</li>
<li>动态规划算法中全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解。    </li>
</ul>
</li>
</ul>
<h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><p>贪心算法的通用实现步骤：</p>
<blockquote>
<ol>
<li>定义问题目标与约束条件</li>
<li>设计贪心选择策略（如排序、优先队列）</li>
<li>迭代选择局部最优解</li>
<li>验证并合并解到全局解</li>
<li>终止条件：问题规模归零或约束满足</li>
</ol>
</blockquote>
<p><strong>算法思路</strong>：</p>
<ol>
<li>建立数学模型来描述问题；</li>
<li>把求解的问题分成若干个子问题；</li>
<li>对每个子问题进行求解，得到子问题的局部最优解；</li>
<li>把子问题的解（局部最优解）合成原来问题的解；</li>
</ol>
<p><strong>算法实现</strong>：</p>
<ol>
<li>从问题的某个初始解出发；</li>
<li>采用循环语句，当可以向求解目标前进一步时，就根据局部最优策略，得到一个部分解，缩小问题的范围或规模；</li>
<li>将所有部分解综合起来，得到问题的最终解；</li>
</ol>
<p><strong>使用情况</strong></p>
<blockquote>
<p> <strong>举个例子：</strong>  有 6 张纸币，面额分别为 100，70，50， 20，20，10，现在我们可以拿走 3 张纸币，要求总金额最大，该怎么拿 </p>
</blockquote>
<ul>
<li>一看到这个问题，肯定就会想着拿最大的那三张就行了，其实这个想法是没错的，但可以把这个想法分解一下：</li>
<li>不考虑拿 3 张，只考虑拿走一张的最大值（局部最优），那这个问题就可以拆解为拿三次的情况，第一次拿 100，第二次拿 70，第三次拿 50，那我们最多可以拿 220</li>
</ul>
<h2 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h2><ol>
<li><p><strong>任务调度与区间问题</strong></p>
<ul>
<li><p><strong>活动选择</strong>：最大化不重叠活动数量（按结束时间排序）。</p>
</li>
<li><p><strong>会议室安排</strong>：最小化会议室使用数量（转化为区间重叠计数）。</p>
</li>
</ul>
</li>
<li><h5 id="图论问题"><a href="#图论问题" class="headerlink" title="图论问题"></a><strong>图论问题</strong></h5><ul>
<li><strong>最小生成树</strong><ul>
<li><strong>Prim算法</strong>：从单点出发，每次选择与树相连的最小边。</li>
<li><strong>Kruskal算法</strong>：按边权升序排序，选择不形成环的边。</li>
</ul>
</li>
<li><strong>最短路径</strong><ul>
<li><strong>Dijkstra算法</strong>：从源点出发，每次选择距离最小的未处理节点。</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="组合优化问题"><a href="#组合优化问题" class="headerlink" title="组合优化问题"></a><strong>组合优化问题</strong></h5><ul>
<li><strong>分数背包</strong>：按单位价值排序，优先装入高价值物品。</li>
<li><strong>找零问题</strong>：硬币面额满足贪心性质时（如人民币面额），优先使用大面额硬币。</li>
</ul>
</li>
</ol>
<h2 id="经典例题详解"><a href="#经典例题详解" class="headerlink" title="经典例题详解"></a>经典例题详解</h2><ul>
<li><p><strong>最小合并代价</strong><br>​<strong>​问题​</strong>​：合并n个部落，每次合并代价为两部落人数之和，求最小总代价。<br>​<strong>​解法​</strong>​：优先队列（最小堆）每次合并最小的两个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">min_cost</span>(<span class="params">nums</span>):</span><br><span class="line">    heapq.heapify(nums)</span><br><span class="line">    cost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(nums) &gt; <span class="number">1</span>:</span><br><span class="line">        a = heapq.heappop(nums)</span><br><span class="line">        b = heapq.heappop(nums)</span><br><span class="line">        cost += a + b</span><br><span class="line">        heapq.heappush(nums, a + b)</span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure></li>
<li><p><strong>纪念品分组</strong><br><strong>问题</strong>：将物品两两分组，每组和不超过W，求最少组数。<br><strong>解法</strong>：排序后双指针配对（最大与最小配对）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">min_groups</span>(<span class="params">items, W</span>):</span><br><span class="line">    items.sort()</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(items) - <span class="number">1</span></span><br><span class="line">    groups = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> items[left] + items[right] &lt;= W:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">        groups += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> groups</span><br></pre></td></tr></table></figure></li>
<li><h5 id="变种与挑战问题"><a href="#变种与挑战问题" class="headerlink" title="变种与挑战问题"></a><strong>变种与挑战问题</strong></h5><ol>
<li><strong>加油站问题</strong><ul>
<li>环形路线上，每个加油站有油量gas[i]，从第i站到下一站耗油cost[i]，求可行起点。</li>
<li><strong>贪心策略</strong>：若当前剩余油量&lt;0，则起点设为下一站，重置油量。</li>
</ul>
</li>
<li><strong>数列极差问题</strong><ul>
<li>操作：每次擦去两数a、b，加入a×b+1，求最终数的极差（max-min）。</li>
<li><strong>解法</strong>：最小化时合并最大数，最大化时合并最小数。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>实战训练建议</strong></p>
<ul>
<li><strong>入门题库</strong>：LeetCode “Assign Cookies”（分配问题）、”Best Time to Buy and Sell Stock II”（股票买卖）。</li>
<li><strong>进阶挑战</strong>：蓝桥杯 “答疑”（按s+a升序排序减少等待时间）、HackerRank “Greedy Florist”。</li>
<li><strong>竞赛考点</strong>：贪心常与排序、堆、双指针结合，需重点训练边界条件处理。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="贪心策略的代码实现范式"><a href="#贪心策略的代码实现范式" class="headerlink" title="贪心策略的代码实现范式"></a>贪心策略的代码实现范式</h1><h2 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h2><ul>
<li><strong>优先队列（堆）</strong>：用于快速获取最小值/最大值（如合并果子问题）。</li>
<li><strong>排序预处理</strong>：为贪心选择创造条件（如区间调度需按结束时间排序）。</li>
</ul>
<h2 id="经典问题实现"><a href="#经典问题实现" class="headerlink" title="经典问题实现"></a>经典问题实现</h2><h3 id="区间调度（最大不重叠区间）"><a href="#区间调度（最大不重叠区间）" class="headerlink" title="区间调度（最大不重叠区间）"></a>区间调度（最大不重叠区间）</h3><p><strong>问题描述</strong>：从一组区间中选择最多数量的互不重叠区间。<br><strong>贪心策略</strong>：按结束时间升序排序，优先选择结束早的区间。<br><strong>时间复杂度</strong>：O(n log n)，主要来自排序操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_non_overlapping</span>(<span class="params">intervals</span>):</span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])  <span class="comment"># 按结束时间排序</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    last_end = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> start, end <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">if</span> start &gt;= last_end:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            last_end = end</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h3 id="哈夫曼编码（数据压缩）"><a href="#哈夫曼编码（数据压缩）" class="headerlink" title="哈夫曼编码（数据压缩）"></a>哈夫曼编码（数据压缩）</h3><p><strong>问题描述</strong>：构造字符的最优前缀编码树，使带权路径长度最小。<br><strong>贪心策略</strong>：每次合并频率最小的两个节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_huffman_tree</span>(<span class="params">data</span>):</span><br><span class="line">    freq = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> data:</span><br><span class="line">        freq[char] = freq.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    heap = [[weight, [char, <span class="string">&quot;&quot;</span>]] <span class="keyword">for</span> char, weight <span class="keyword">in</span> freq.items()]</span><br><span class="line">    heapq.heapify(heap)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(heap) &gt; <span class="number">1</span>:</span><br><span class="line">        lo = heapq.heappop(heap)</span><br><span class="line">        hi = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> lo[<span class="number">1</span>:]:</span><br><span class="line">            pair[<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span> + pair[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> hi[<span class="number">1</span>:]:</span><br><span class="line">            pair[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span> + pair[<span class="number">1</span>]</span><br><span class="line">        heapq.heappush(heap, [lo[<span class="number">0</span>] + hi[<span class="number">0</span>]] + lo[<span class="number">1</span>:] + hi[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



<h2 id="正确性证明与复杂度分析"><a href="#正确性证明与复杂度分析" class="headerlink" title="正确性证明与复杂度分析"></a>正确性证明与复杂度分析</h2><h3 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h3><ul>
<li><strong>数学归纳法</strong>：证明每一步贪心选择均保持最优子结构。</li>
<li><strong>反证法</strong>：假设存在更优解，通过替换操作证明贪心解更优（如区间调度问题）。</li>
<li><strong>构造法</strong>：展示贪心解可逐步扩展为全局最优解（如哈夫曼树构造）。</li>
</ul>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table>
<thead>
<tr>
<th align="left">问题类型</th>
<th align="left">时间复杂度</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">区间调度</td>
<td align="left">O(n log n)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">哈夫曼编码</td>
<td align="left">O(n log n)</td>
<td align="left">O(n)</td>
</tr>
<tr>
<td align="left">最小生成树（Prim）</td>
<td align="left">O(E log V)</td>
<td align="left">O(V)</td>
</tr>
</tbody></table>
<h3 id="适用条件判断"><a href="#适用条件判断" class="headerlink" title="适用条件判断"></a>适用条件判断</h3><p>贪心算法<strong>仅适用于满足以下性质的问题</strong>：</p>
<ul>
<li><strong>贪心选择性质</strong>：局部最优可推导全局最优。</li>
<li><strong>最优子结构</strong>：子问题最优解可组合为原问题最优解。</li>
<li><strong>不适用场景</strong>：当前选择影响未来状态（如0-1背包问题需用动态规划）。</li>
</ul>
<hr>
<h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">LeetCode_135. 分发糖果</a></p>
<blockquote>
<p><strong>问题描述：</strong><br><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。需要按照以下要求，给这些孩子分发糖果：<br>每个孩子至少分配到 <code>1</code> 个糖果；相邻两个孩子中，评分更高的那个会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>
<p><strong>示例 1：</strong><br><strong>输入</strong>：ratings = [1,0,2]<br><strong>输出</strong>：5<br><strong>解释</strong>：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</p>
<p><strong>示例 2：</strong><br><strong>输入</strong>：ratings = [1,2,2]<br><strong>输出</strong>：4<br><strong>解释</strong>：可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</p>
<p><strong>提示：</strong><br><code>n == ratings.length</code><br><code>1 &lt;= n &lt;= 2 * 10^4</code><br><code>0 &lt;= ratings[i] &lt;= 2 * 10^4</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] candyVec = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length]; <span class="comment">// 每个小孩分的糖果</span></span><br><span class="line">    Arrays.fill(candyVec, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 从左往右遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ratings.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>])&#123;</span><br><span class="line">            candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右往左遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) &#123;</span><br><span class="line">            candyVec[i] = Math.max(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; candyVec.length; i++) &#123;</span><br><span class="line">        result += candyVec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">LeetCode_11. 盛最多水的容器</a></p>
<blockquote>
<p><strong>问题描述：</strong><br>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。<br>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。<br><strong>说明：</strong>你不能倾斜容器。</p>
<p><strong>示例 1：</strong><br><strong>输入</strong>：[1,8,6,2,5,4,8,3,7]<br><strong>输出</strong>：49<br><strong>解释</strong>：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807133603378.png" alt="image-20250807133603378"></p>
<p><strong>示例 2：</strong><br><strong>输入</strong>：height = [1,1]<br><strong>输出</strong>：1</p>
<p><strong>提示：</strong><br><code>n == height.length</code><br><code>2 &lt;= n &lt;= 10^5</code><br><code>0 &lt;= height[i] &lt;= 10^4</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> height.length - <span class="number">1</span>, max = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; r; ) &#123;</span><br><span class="line">       max = Math.max(max, Math.min(height[l], height[r]) * (r - l));</span><br><span class="line">       <span class="keyword">if</span> (height[l] &lt; height[r]) &#123;</span><br><span class="line">            l++;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           r--;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><blockquote>
<p><strong>问题描述：</strong><br>有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。<br>物品：A    B    C    D    E     F    G<br>重量：35  30  60  50  40  10  25<br>价值：10  40  30  50  35  40  30</p>
<p><strong>问题分析：</strong></p>
<ol>
<li><strong>目标函数</strong>：<code>∑pi</code> 求和，最大，使得装入背包中的所有物品 <code>pi</code> 的价值加起来最大；</li>
<li><strong>约束条件</strong>：装入的物品总重量不超过背包容量：<code>∑wi &lt;= M( M=150)</code>；</li>
<li>贪心策略：<ul>
<li>选择价值最大的物品。</li>
<li>选择重量最小的物品。</li>
<li>选择单位重量价值最大的物品。</li>
</ul>
</li>
</ol>
<p>1、值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。<br>2、贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。<br>3、可惜的是，它需要证明后才能真正运用到题目的算法中。</p>
</blockquote>
<p>一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。对于背包问题中的 3 种贪心策略，都是 <strong>无法成立（无法被证明）</strong> 的，解释如下：</p>
<ol>
<li><p><strong>选取价值最大者</strong>：W=30</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>28</td>
<td>30</td>
</tr>
<tr>
<td>B</td>
<td>12</td>
<td>20</td>
</tr>
<tr>
<td>C</td>
<td>12</td>
<td>20</td>
</tr>
</tbody></table>
<p>根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B和C一起，则更好。</p>
</li>
<li><p><strong>选取重量最小者</strong>：选取重量最小。它的反例与第一种策略的反例差不多。</p>
</li>
<li><p>选取单位重量价值最大者：W=30</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>28</td>
<td>28</td>
</tr>
<tr>
<td>B</td>
<td>20</td>
<td>20</td>
</tr>
<tr>
<td>C</td>
<td>10</td>
<td>10</td>
</tr>
</tbody></table>
</li>
</ol>
<p>根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。但是<strong>如果在条件中加一句当遇见单位价值相同的时候，优先装重量小的，这样的问题就可以解决。</strong></p>
<p>以下这个算法里面就是采用的贪心第三方案，一般这个方案是成功率最大的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// n：物品个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// m：背包容量</span></span><br><span class="line">    List&lt;Package&gt; p = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 输入物品的重量和价值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> value / weight * <span class="number">1.0</span>;</span><br><span class="line">        p.add(<span class="keyword">new</span> <span class="title class_">Package</span>(weight, value, average));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序默认升序，需要自定义为降序</span></span><br><span class="line">    Collections.sort(p, (pac1, pac2) -&gt; Double.compare(pac2.avg, pac1.avg));</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt;= p.get(i).weight) &#123;</span><br><span class="line">            m -= p.get(i).weight;</span><br><span class="line">            maxValue = maxValue + p.get(i).value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(maxValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Package</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;         <span class="comment">// 重量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;          <span class="comment">// 价值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> avg;         <span class="comment">// 单位价值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Package</span><span class="params">(<span class="type">int</span> weight, <span class="type">int</span> value, <span class="type">double</span> avg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight=weight;</span><br><span class="line">        <span class="built_in">this</span>.value=value;</span><br><span class="line">        <span class="built_in">this</span>.avg=avg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="购物清单（带条件的背包问题）"><a href="#购物清单（带条件的背包问题）" class="headerlink" title="购物清单（带条件的背包问题）"></a>购物清单（带条件的背包问题）</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4">牛客网_HJ16 购物单</a></p>
<blockquote>
<p><strong>问题描述：</strong>王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件。</p>
<ul>
<li>主件可以没有附件，至多有 22 个附件。附件不再有从属于自己的附件。</li>
<li>若要购买某附件，必须先购买该附件所属的主件，且每件物品只能购买一次。</li>
</ul>
<p>王强查到了 m 件物品的价格，而他只有 n 元的预算。为了先购买重要的物品，他给每件物品规定了一个重要度，用整数 1∼5 表示。他希望在不超过预算的前提下，使满意度最大。满意度定义为所购每件物品价格与重要度乘积之和。</p>
<p><strong>输入描述</strong>：第一行输入两个整数 n,m代表预算、查询到的物品总数。<br>此后 m 行，第 i 行输入三个整数 vi, wi, qi 分别代表价格、重要度、主件编号。特别地， qi = 0,代表该物品为主件，否则表示该附件从属于主件 。编号即输入顺序，从1开始。保证全部物品的价格 v 均为 10 的倍数；且每个主件的附件数不超过 2 个。</p>
<p><strong>输出描述</strong>：在一行上输出一个整数，代表王强可获得的最大满意度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">50 5</span><br><span class="line">20 3 5</span><br><span class="line">20 3 5</span><br><span class="line">10 3 0</span><br><span class="line">10 2 0</span><br><span class="line">10 1 0</span><br><span class="line">输出 130</span><br><span class="line">说明：在这个样例中，第三、四、五件物品为主件，第一、二件物品为第五件物品的附件。这就意味着，如果购买了第一件物品或第二件物品，则必须购买第五件物品；但是特别地，如果同时购买了第一件物品和第二件物品，则只需要购买一次第五件物品。</span><br><span class="line">我们可以证明，购买一、二、五件商品，获得的满意度最大，为 20×3+20×3+10×1=130。</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// 预算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// 物品数</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span> || m &lt;= <span class="number">0</span>) System.out.println(<span class="number">0</span>);</span><br><span class="line">    Package[] p = <span class="keyword">new</span> <span class="title class_">Package</span>[m + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[][] appendix =  <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][<span class="number">2</span>]; <span class="comment">// 附件 最多2个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123; <span class="comment">// 输入物品 价格、重要度、主件编号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// weight</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wi</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// value</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">qi</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        p[i] = <span class="keyword">new</span> <span class="title class_">Package</span>(vi, wi, qi);</span><br><span class="line">        <span class="keyword">if</span> (qi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (appendix[qi][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                appendix[qi][<span class="number">0</span>] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                appendix[qi][<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>]; <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">Package</span> <span class="variable">item</span> <span class="operator">=</span> p[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> p[i].vi;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> p[i].wi * vi; <span class="comment">// 只有主件</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> <span class="number">0</span>, dp2 = <span class="number">0</span>, dp3 = <span class="number">0</span>, v1 = <span class="number">0</span>, v2 = <span class="number">0</span>, v3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (appendix[i][<span class="number">0</span>] != <span class="number">0</span>) &#123; <span class="comment">// 附件1</span></span><br><span class="line">            v1 = vi + p[appendix[i][<span class="number">0</span>]].vi;</span><br><span class="line">            dp1 = dp0 + p[appendix[i][<span class="number">0</span>]].wi * p[appendix[i][<span class="number">0</span>]].vi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (appendix[i][<span class="number">1</span>] != <span class="number">0</span>) &#123; <span class="comment">// 附件2</span></span><br><span class="line">            v2 = vi + p[appendix[i][<span class="number">1</span>]].vi;</span><br><span class="line">            dp2 = dp0 + p[appendix[i][<span class="number">1</span>]].wi * p[appendix[i][<span class="number">1</span>]].vi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (appendix[i][<span class="number">0</span>] != <span class="number">0</span> &amp;&amp; appendix[i][<span class="number">1</span>] != <span class="number">0</span>) &#123; <span class="comment">// 附件1, 2</span></span><br><span class="line">            v3 = vi + p[appendix[i][<span class="number">0</span>]].vi + p[appendix[i][<span class="number">1</span>]].vi;</span><br><span class="line">            dp3 = dp0 + p[appendix[i][<span class="number">0</span>]].wi * p[appendix[i][<span class="number">0</span>]].vi + </span><br><span class="line">                p[appendix[i][<span class="number">1</span>]].wi * p[appendix[i][<span class="number">1</span>]].vi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (p[i].qi == <span class="number">0</span>) &#123; <span class="comment">// 主件</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= vi &amp;&amp; vi != <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - vi] + dp0);</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v1 &amp;&amp; v1 != <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - v1] + dp1);</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v2 &amp;&amp; v2 != <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - v2] + dp2);</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v3 &amp;&amp; v3 != <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - v3] + dp3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(dp[m][n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Package</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> vi;         <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> wi;          <span class="comment">// 重要性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> qi;      <span class="comment">// 0 为主件 否则为为从属主件parent - 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Package</span><span class="params">(<span class="type">int</span> vi, <span class="type">int</span> wi, <span class="type">int</span> qi)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vi=vi;</span><br><span class="line">        <span class="built_in">this</span>.wi=wi;</span><br><span class="line">        <span class="built_in">this</span>.qi=qi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="活动时间安排问题"><a href="#活动时间安排问题" class="headerlink" title="活动时间安排问题"></a>活动时间安排问题</h2><p><strong>问题描述</strong>：</p>
<p>设有 <code>n</code>个活动的集合 <code>E=&#123;1,2,…,n&#125;</code>，其中每个活动都<strong>要求使用同一资源</strong>，如：演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 i 都有一个要求使用该资源的起始时间 <code>si</code> 和一个结束时间 fi ,且 <code>si &lt; fi</code> 。<strong>要求设计程序，使得安排的活动最多</strong>。<br>注：活动结束时间从小到大排序</p>
<table>
<thead>
<tr>
<th>i</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td>S[i]</td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>8</td>
<td>8</td>
<td>2</td>
<td>12</td>
</tr>
<tr>
<td>f[i]</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
</tr>
</tbody></table>
<p><strong>问题分析：</strong></p>
<p>活动安排问题要求安排一系列争用某一公共资源的活动。贪心算法可提供一个简单、漂亮的方法，使尽可能多的活动能兼容的使用公共资源。设有 <code>n</code> 个活动的集合<code>｛0，1，2，…，n-1｝</code>，其中每个活动都要求使用同一资源，如会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 <code>i</code> 都有一个要求使用该资源的起始时间 <code>starti</code> 和一个结束时间 <code>endi</code> ，且 <code>starti &lt; endi</code>。如选择了活动 <code>i</code>，则它在半开时间区间 [starti, endi) 内占用资源。若区间 <code>[starti,endi)</code> 与区间 <code>[startj,endj)</code> 不相交，称活动 <code>i</code> 与活动 <code>j</code> 是<strong>相容的</strong>。即，当 <code>startj ≥ endi</code> 或 <code>starti ≥ endj</code> 时，活动 i 与活动 j 相容。<strong>活动安排问题就是在所给的活动集合中选出最多的不相容活动</strong>。</p>
<p><strong>算法设计：</strong></p>
<p>若被检查的 <code>活动 i</code> 的开始时间 <code>starti</code> 小于最近选择的 <code>活动 j</code> 的结束时间 <code>endj</code>，则不选择 <code>活动 i</code>，否则选择 <code>活动 i</code> 加入集合中。运用该算法解决活动安排问题的效率极高。当输入的活动已按结束时间的非减序排列，算法只需 <code>O(n)</code> 的时间安排 <code>n</code> 个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用 <code>O(nlogn)</code> 的时间重排。</p>
<p><strong>代码实现一：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();     <span class="comment">// n：活动个数</span></span><br><span class="line">    List&lt;Active&gt; act = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 输入开始和结束</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">finish</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        act.add(<span class="keyword">new</span> <span class="title class_">Active</span>(start, finish));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将活动按活动结束时间从小到大排序</span></span><br><span class="line">    Collections.sort(act, (o1, o2) -&gt; o1.finish - o2.finish);</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// t：与各个活动的起始时间相比较</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// total：最后的活动的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//循环访问所有活动</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt;= act.get(i).start) &#123;</span><br><span class="line">            total ++;</span><br><span class="line">            t = act.get(i).finish;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(total);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Active</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> start;     <span class="comment">// 开始时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> finish;    <span class="comment">// 结束时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Active</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> finish)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start=start;</span><br><span class="line">        <span class="built_in">this</span>.finish=finish;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码实现二：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">11</span>; <span class="comment">// 活动数</span></span><br><span class="line">    <span class="comment">// 将活动时间进行静态数组直接存储</span></span><br><span class="line">    <span class="type">int</span>[] s = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">12</span>&#125;; <span class="comment">// 下标从1开始,存储活动开始时间</span></span><br><span class="line">    <span class="type">int</span>[] f = &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>&#125;; <span class="comment">//下标从1开始,存储活动结束时间</span></span><br><span class="line">    <span class="type">boolean</span>[] A = <span class="keyword">new</span> <span class="title class_">boolean</span>[N + <span class="number">1</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;各活动的开始时间,结束时间分别为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + i + <span class="string">&quot;]:&quot;</span> + <span class="string">&quot;(&quot;</span> + s[i] + <span class="string">&quot;,&quot;</span> + f[i] + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    GreedySelector(N, s, f, A);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i]) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span> + i + <span class="string">&quot;]:&quot;</span> + <span class="string">&quot;(&quot;</span> + s[i] + <span class="string">&quot;,&quot;</span> + f[i] + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">GreedySelector</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] s, <span class="type">int</span>[] f, <span class="type">boolean</span>[] A)</span> &#123;</span><br><span class="line">    A[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 记录最近一次加入A中的活动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123; <span class="comment">// 依次检查活动i是否与当前已选择的活动相容</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= f[j]) &#123;</span><br><span class="line">            A[i] = <span class="literal">true</span>;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：虽然贪心算法不是一定可以得到最好的解 ，但是对于这种活动时间的问题，他却得到的总是最优解，这点可用数学归纳法证明。在这里，体现出来的贪心策略是：每一个活动时间的挑选总是选择最优的，就是刚好匹配的，这样得出的结果也就是最优的了。</p>
<h2 id="最小生成树（克鲁斯卡尔算法）"><a href="#最小生成树（克鲁斯卡尔算法）" class="headerlink" title="最小生成树（克鲁斯卡尔算法）"></a>最小生成树（克鲁斯卡尔算法）</h2><p>在连通网中查找最小生成树的常用方法有两个，分别称为普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法。</p>
<blockquote>
<p><strong>克鲁斯卡尔算法</strong> 查找最小生成树的方法是：将连通网中所有的边按照权值大小做升序排序，从权值最小的边开始选择，<strong>只要此边不和已选择的边一起构成环路，就可以选择它组成最小生成树</strong>。<strong>对于 <code>N</code> 个顶点的连通网，挑选出 <code>N-1</code> 条符合条件的边，这些边组成的生成树就是最小生成树</strong>。</p>
</blockquote>
<p><strong>问题描述：</strong>求一个连通无向图的最小生成树的代价（图边权值为正整数）。</p>
<p><strong>输入</strong>：第一行是一个整数N（1&lt;=N&lt;=20），表示有多少个图需要计算。以下有N个图，第i图的第一行是一个整数M（1&lt;=M&lt;=50），表示图的顶点数，第i图的第2行至1+M行为一个M*M的二维矩阵，其元素ai,j表示图的i顶点和j顶点的连接情况，如果ai,j=0，表示i顶点和j顶点不相连；如果ai,j&gt;0，表示i顶点和j顶点的连接权值。</p>
<p><strong>输出：</strong>每个用例，用一行输出对应图的最小生成树的代价。</p>
<p><strong>样例输入：</strong></p>
<blockquote>
<p>1<br>6<br>0 6 1 5 0 0<br>6 0 5 0 3 0<br>1 5 0 5 6 4<br>5 0 5 0 0 2<br>0 3 6 0 0 6<br>0 0 4 2 6 0</p>
</blockquote>
<p><strong>样例输出：</strong>15</p>
<p><strong>问题分析：</strong></p>
<ol>
<li>边的选择要求从小到大选择，则开始显然要对边进行升序排序；</li>
<li>选择的边是否需要，则从判断该边加入后是否构成环；</li>
</ol>
<p><strong>算法设计：</strong></p>
<ol>
<li><strong>对边进行升序排序</strong>：在此采用链式结构，通过插入排序完成。每一结点存放一条边的左右端点序号、权值及后继结点指针；</li>
<li><strong>边的加入后，是否会构成环</strong>：最开始假定各顶点分别为一组，其组号为端点序号。选择某边后看其两端点是否在同一组中，即所在组号是否相同，若是，表示构成了环，则舍去。若两个端点所在的组不同，则表示可以加入，则将该边两端的组合并成同一组。</li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// V是顶点数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">E</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// E是边数</span></span><br><span class="line">    Edge[] edge = <span class="keyword">new</span> <span class="title class_">Edge</span>[E]; <span class="comment">// 存储边的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">        edge[i] = <span class="keyword">new</span> <span class="title class_">Edge</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    kruskal(V, edge);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行克鲁斯卡尔算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">(<span class="type">int</span> V, Edge[] edge)</span> &#123;</span><br><span class="line">    Edge result[] = <span class="keyword">new</span> <span class="title class_">Edge</span>[V]; <span class="comment">// 存储结果的数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示result数组中的下标</span></span><br><span class="line">    Arrays.sort(edge);  <span class="comment">// 将边按照权重从小到大排序</span></span><br><span class="line">    Subset subsets[] = <span class="keyword">new</span> <span class="title class_">Subset</span>[V]; <span class="comment">// 创建V个子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; ++i) &#123; <span class="comment">// 初始化每个子集的父节点和秩</span></span><br><span class="line">        subsets[i] = <span class="keyword">new</span> <span class="title class_">Subset</span>(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取E-1条边</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (e &lt; V - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">Edge</span> <span class="variable">next_edge</span> <span class="operator">=</span> edge[i++];</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> findParentNode(subsets, next_edge.src);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> findParentNode(subsets, next_edge.dest);</span><br><span class="line">        <span class="comment">// 如果两个节点不在同一个集合中，合并它们</span></span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            result[e++] = next_edge;</span><br><span class="line">            unionSubsets(subsets, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Following are the edges in the constructed MST&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e; ++i)&#123;</span><br><span class="line">        System.out.println(result[i].src + <span class="string">&quot; - &quot;</span> + result[i].dest + <span class="string">&quot; - &quot;</span> + result[i].weight);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找父节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findParentNode</span><span class="params">(Subset subsets[], <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (subsets[i].parent != i)</span><br><span class="line">        subsets[i].parent = findParentNode(subsets, subsets[i].parent);</span><br><span class="line">    <span class="keyword">return</span> subsets[i].parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个子集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unionSubsets</span><span class="params">(Subset subsets[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xroot</span> <span class="operator">=</span> findParentNode(subsets, x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yroot</span> <span class="operator">=</span> findParentNode(subsets, y);</span><br><span class="line">    <span class="keyword">if</span> (subsets[xroot].rank &lt; subsets[yroot].rank)&#123;</span><br><span class="line">        subsets[xroot].parent = yroot;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subsets[xroot].rank &gt; subsets[yroot].rank) &#123;</span><br><span class="line">        subsets[yroot].parent = xroot;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subsets[yroot].parent = xroot;</span><br><span class="line">        subsets[xroot].rank++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义边的数据结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Edge&gt; &#123;</span><br><span class="line">    <span class="type">int</span> src, dest, weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Edge edge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - edge.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集数据结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Subset</span> &#123;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    <span class="type">int</span> rank;</span><br><span class="line">    Subset(<span class="type">int</span> parent, <span class="type">int</span> rank) &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent=parent;</span><br><span class="line">        <span class="built_in">this</span>.rank=rank;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------------------- 无用 --------------------------</span></span><br><span class="line"><span class="comment">// 定义一个辅助函数，用于查找结点所在的集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[i] == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> findNode(parent, parent[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个辅助函数，用于合并两个集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unionNode</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xset</span> <span class="operator">=</span> findNode(parent, x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yset</span> <span class="operator">=</span> findNode(parent, y);</span><br><span class="line">    parent[xset] = yset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线段覆盖（Lines-cover）"><a href="#线段覆盖（Lines-cover）" class="headerlink" title="线段覆盖（Lines cover）"></a>线段覆盖（Lines cover）</h2><p><strong>问题描述：</strong>在一维空间中告诉你N条线段的起始坐标与终止坐标，要求求出这些线段一共覆盖了多大的长度。</p>
<p><strong>解题思路：</strong>上述的表格中的数据代表10条线段的起始点和终点，对他们的起始点从小到大按顺序排列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] start = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;  <span class="comment">// 起始点</span></span><br><span class="line">    <span class="type">int</span>[] end = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>&#125;; <span class="comment">// 终点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total_len</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">//至少的长度为：3-2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start[i] &gt;= end[j]) &#123; <span class="comment">// 不相交</span></span><br><span class="line">            total_len = total_len + end[i] - start[i];</span><br><span class="line">            j = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (end[i] &lt;= end[j]) &#123; <span class="comment">// 重叠</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 相交</span></span><br><span class="line">                total_len = total_len + end[i] - end[j];</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(total_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数字组合问题"><a href="#数字组合问题" class="headerlink" title="数字组合问题"></a>数字组合问题</h2><p><strong>问题描述</strong>：设有N个正整数，现在需要你设计一个程序，使他们连接在一起成为最大的数字。</p>
<p><strong>输入</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">12 456 342</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：45634212</p>
<p><strong>程序要求</strong>：输入整数N 接下来一行输入N个数字，最后一行输出最大的那个数字。</p>
<p><strong>题目解析</strong>：</p>
<ol>
<li><p>首先想到如何使两个数连接在一起最大，例如 12 和 456 ，连接在一起有两种情况分别为 12456 和 45612 ，显然后者比前者大。</p>
</li>
<li><p>如果是多个正整数连在一起，我们则需要对元素进行比较，很显然这是一个排序的过程，而且 需要相邻的元素两两比较，由此可以想到 <code>冒泡排序</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用冒泡排序来实现升序序列</span></span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// 开始冒泡排序 总共排序轮数为：元素个数 - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 内层对比循环 次数 = 元素个数 - 排序轮数 - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果第一个数字比第二个数字大，实现交换这两个数字</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>若有四个数字：456、12、342、78<br>1、先进行比较 456 和 12，发现 45612 比 12456 更大，此时交换两个数字的位置：12、456、342、78<br>2、再进行比较 456 和 342，发现 456342 比 342456 更大，再次进行位置的交换：12、342、456、78<br>3、在进行比较 456 和 78，发现 78456 比 45678 更大，无需进行交换；<br>4、最后顺序：12 、342 、456 、78</p>
<p>分析到这其实发现要想连接到一起的数字最大，其实需要排序的是每个数字的第一位，最终每个数字的第一位排序得到： <code>1,3,4,7;</code></p>
<p><strong>综上所述，解题思路：就是在相邻两个正整数连接起来比较大小的基础上再对所有数字冒泡排序，即可完成题目要求</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        arr[i] = scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; num - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//如果 arr[j] 大于 arr[j+1]，则交换，否则，不交换</span></span><br><span class="line">            <span class="keyword">if</span>(compare(arr[j], arr[j+<span class="number">1</span>])) &#123;</span><br><span class="line">                 <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                 arr[j]   = arr[j+<span class="number">1</span>];</span><br><span class="line">                 arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">               <span class="comment">// Collections.swap(list, i, j); //交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        System.out.print(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义排序  num1：:12，num2：456</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nm1</span> <span class="operator">=</span> num1, nm2 = num2;</span><br><span class="line">    <span class="keyword">while</span> (nm1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count1++;   <span class="comment">//用来得到 num1 的位数：2</span></span><br><span class="line">        nm1 /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (nm2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count2++;   <span class="comment">//用来得到 num2 的位数：3</span></span><br><span class="line">        nm2 /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Math.pow(a, b)：求 a 的 b 次方，这里用作将两个数连接起来进行下一步的比较</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> num1 * Math.pow(<span class="number">10.0</span>, count2) + num2; <span class="comment">// 表示组合数：num1 num2：12  * 1000 + 456 = 12456</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> num2 * Math.pow(<span class="number">10.0</span>, count1) + num1; <span class="comment">// 表示组合数：num2 num1：456 * 100  + 12  = 45612</span></span><br><span class="line">    <span class="keyword">return</span> Double.compare(a, b) == <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// true表示组合数(num1 num2)大于组合数(num2 num1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拼数"><a href="#拼数" class="headerlink" title="拼数"></a>拼数</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/problem/16783">牛客网_拼数</a></p>
<blockquote>
<p><strong>描述</strong>：设有n个正整数（n ≤ 20），将它们联接成一排，组成一个最大的多位整数。例如：n=3时，3个整数13，312，343联接成的最大整数为：34331213。又如：n=4时，4个整数7，13，4，246联接成的最大整数为：7424613<br><strong>输入描述</strong>：第一行，一个正整数n。第二行，n个正整数。<br><strong>输出描述</strong>: 一个正整数，表示最大的整数</p>
<p><strong>示例1</strong><br><strong>输入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">13 312 343</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong>34331213</p>
<p><strong>示例2</strong><br><strong>输入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">921650139 925571586 931563581 923960668 870548039 358493469 371229218 737101511 514654859 185379933 19421244 117259400 301947570 48520742 79303948 222979736 153546206 250582036 106394401 198125223</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">931563581925571586923960668921650139870548039793039487371015115146548594852074237122921835849346930194757025058203622297973619812522319421244185379933153546206117259400106394401</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>先把<strong>整数化成字符串</strong>，然后再比较<strong>a+b和b+a</strong>，如果<strong>a+b&gt;b+a，就把a排在b的前面，反之则把a排在b的后面，最后输出排序后的字符串，即可得到最大的整数</strong>（如果求最小的整数，则从小到大排序）。</p>
<p><strong>举例说明：a=‘123’，b=‘71’，a+b=’12371’，b+a=‘71123’，所以a+b&lt;b+a，将b排在前面** 注意：正常的字符串存在比较缺陷，**如：A=’321’，B=’32’，按照标准的字符串比较规则因为A&gt;B，所以A+B &gt; B+A ，而实际上’32132’ &lt; ’32321’。</strong> 具体步骤如下：</p>
<ol>
<li>获取n   </li>
<li>依次获取n个正整数，<strong>将整数转换为字符串</strong>：声明字符串数组a[n]，将获取到的正整数存入数组a中，即可实现正整数到字符串的转换  </li>
<li><strong>自定义排序函数：</strong>若a+b &gt; b+a，则把a排在前面，否则将b排在前面（对字符串a、b，a+b表示连接两个字符串形成一个新串）</li>
<li><strong>从大到小输出排序后的字符串</strong>即可得到最大的整数</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">    sc.nextLine();</span><br><span class="line">    String[] strArray = sc.nextLine().split(<span class="string">&quot; &quot;</span>); <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 自定义排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>; m &lt; n-<span class="number">1</span>-k; m++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!sortStr(strArray[m], strArray[m + <span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> strArray[m];</span><br><span class="line">                strArray[m] = strArray[m + <span class="number">1</span>];</span><br><span class="line">                strArray[m + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">        System.out.print(strArray[i]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序函数实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">sortStr</span><span class="params">(String str1,String str2)</span>&#123;</span><br><span class="line">    <span class="type">char</span>[] char1 = (str1 + str2).toCharArray();</span><br><span class="line">    <span class="type">char</span>[] char2 = (str2 + str1).toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; char1.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(char1[i] &gt; char2[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(char1[i] &lt; char2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找零钱问题"><a href="#找零钱问题" class="headerlink" title="找零钱问题"></a>找零钱问题</h2><p>在贪心算法里面最常见的莫过于找零钱的问题了。</p>
<p><strong>问题描述</strong>：对于人民币的面值有1元 、5元 、10元 、20元 、50元 、100元，下面要求设计一个程序，输入找零的钱，输出找钱方案中最少张数的方案，比如： 123元，最少是 1 张100 的，1 张 20 的，3 张 1 元的，一共5张。</p>
<p><strong>问题解析</strong>：运用的贪心策略是每次选择最大的钱，如果最后超过了，再选择次大的面值，然后次次大的面值，一直到最后与找的钱相等。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> scanner.nextInt();                  <span class="comment">// money：需要的交换的钱数</span></span><br><span class="line">    <span class="type">int</span>[] moneyClass = &#123;<span class="number">100</span>,<span class="number">50</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;          <span class="comment">// 记录钱的面值</span></span><br><span class="line">    <span class="type">int</span>[] moneyNum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];                    <span class="comment">// 记录各种面值的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">moneyCount</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= moneyClass.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (moneyCount + moneyClass[i] &gt; money) &#123;   <span class="comment">// 如果需要的钱数小于最大的面值</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;                               <span class="comment">// 换用更小的面值，继续去判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        moneyCount += moneyClass[i];</span><br><span class="line">        moneyNum[i] ++;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">while</span> (moneyCount == money) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;一共需要：&quot;</span> + count + <span class="string">&quot;张纸钱。&quot;</span> );</span><br><span class="line">    <span class="comment">// 输出张数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (moneyNum[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: System.out.println(<span class="string">&quot;面值为100的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: System.out.println(<span class="string">&quot;面值为50的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: System.out.println(<span class="string">&quot;面值为20的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: System.out.println(<span class="string">&quot;面值为10的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>: System.out.println(<span class="string">&quot;面值为5的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>: System.out.println(<span class="string">&quot;面值为1的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最好时机-二"><a href="#买卖股票的最好时机-二" class="headerlink" title="买卖股票的最好时机(二)"></a>买卖股票的最好时机(二)</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/fbc5dad3e215457fb82a3ae688eb7281?tpld=230&tpld=39768&ru=/exam/oj">牛客网_买卖股票的最好时机(二)</a></p>
<blockquote>
<p><strong>描述</strong>：假设数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益</p>
<ol>
<li>可以多次买卖该只股票，但是再次购买前必须卖出之前的股票</li>
<li>如果不能获取收益，请返回0</li>
<li>假设买入卖出均无手续费</li>
</ol>
<p><strong>输入描述</strong>：<br>第一行输入一个正整数 n ，表示数组 prices 的长度<br>第二行输入 n 个正整数，表示数组中prices的值<br><strong>输出描述</strong>：输出最大收益</p>
<p><strong>示例1</strong><br><strong>输入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">&gt;8 9 2 5 4 7 1</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：7<br><strong>说明</strong>：<br>在第1天(股票价格=8)买入，第2天(股票价格=9)卖出，获利9-8=1<br>在第3天(股票价格=2)买入，第4天(股票价格=5)卖出，获利5-2=3<br>在第5天(股票价格=4)买入，第6天(股票价格=7)卖出，获利7-4=3<br>总获利1+3+3=7，返回7  </p>
<p><strong>示例2</strong><br><strong>输入</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">&gt;5 4 3 2 1</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：0<br><strong>说明</strong>：由于每天股票都在跌，因此不进行任何交易最优。最大收益为0。</p>
<p><strong>示例3</strong><br><strong>输入</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">&gt;1 2 3 4 5</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：4<br><strong>说明</strong>：第一天买进，最后一天卖出最优。中间的当天买进当天卖出不影响最终结果。最大收益为4。</p>
<p><strong>思路</strong>： 只要当天价格比上一天价格大，就累加，然后算出最大利润即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span>[] prices = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        prices[i] = in.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>]) &#123; <span class="comment">// 如果任何一天比前一天价格高，就在前一天买入今天卖</span></span><br><span class="line">            sum += (prices[i]-prices[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &lt; prices[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            total += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组队竞赛"><a href="#组队竞赛" class="headerlink" title="组队竞赛"></a>组队竞赛</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/6736cc3ffd1444a4a0057dee89be789b">牛客网_组队竞赛</a></p>
<blockquote>
<p><strong>描述</strong>：牛牛举办了一次编程比赛，参加比赛的有3*n个选手，每个选手都有一个水平值a_i。现在要将这些选手进行组队，一共组成n个队伍，即每个队伍3人。牛牛发现队伍的水平值等于该队伍队员中第二高水平值。例如:<br>一个队伍三个队员的水平值分别是3，3，3。那么队伍的水平值是3<br>一个队伍三个队员的水平值分别是3，2，3。那么队伍的水平值是3<br>一个队伍三个队员的水平值分别是1，5，2。那么队伍的水平值是2<br>为了让比赛更有看点，牛牛想安排队伍使所有队伍的水平值总和最大。<br>如样例所示：如果牛牛把6个队员划分到两个队伍<br>如果方案为：team1:{1,2,5}, team2:{5,5,8}, 这时候水平值总和为7.<br>而如果方案为：team1:{2,5,8}, team2:{1,5,5}, 这时候水平值总和为10.<br>没有比总和为10更大的方案,所以输出10.<br><strong>输入描述：</strong>输入的第一行为一个正整数n(1 ≤ n ≤ 10^5)。第二行包括3*n个整数a_i(1 ≤ a_i ≤ 10^9),表示每个参赛选手的水平值。<br><strong>输出描述：</strong>输出一个整数表示所有队伍的水平值总和最大值</p>
<p><strong>示例1</strong><br><strong>输入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 2 8 5 1 5</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong>10</p>
<p><strong>思路</strong>：先排序，比如排完序 1 2 3 4 5 6 7 8 9 这九个数；组队思路是这样的，第一个最后两个（1 8 9），剩下 2 3 4 5 6 7，第一个最后两个（2 6 7），剩下3 4 5一组。就是第一个和最后两个，再把已经组队的删掉，然后再循环，第一个最后两个。那么中位数可以看到是 8 6 4，找到中位数在整个排序后的素组和下标的规则是 data[data.length-(2*(i+1))]，再加在一起。最重要的是 result一定要是long，int会越界。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();;</span><br><span class="line">    <span class="type">long</span>[] data = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">3</span> * n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length ; i++) &#123;</span><br><span class="line">        data[i] = scanner.nextLong();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(data); <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result += data[data.length - (<span class="number">2</span> * (i + <span class="number">1</span>))];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">    ArrayList&lt;Long&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Long&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>*n; i++) &#123;</span><br><span class="line">        arr.add(scan.nextLong());</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(arr);</span><br><span class="line">    list = arr.subList(n,<span class="number">3</span>*n);</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            sum += list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/description/">LeetCode_56. 合并区间 </a></p>
<p><strong>贪心策略:</strong></p>
<ul>
<li>先按照区间的「左端点」排序:此时我们会发现，能够合并的区间都是连续的，b.然后从左往后，按照求「并集」的方式，合并区间。</li>
</ul>
<p><strong>如何求并集:</strong> 由于区间已经按照「左端点」排过序了，因此当两个区间「合并」的时候，合并后的区间：</p>
<ol>
<li>左端点就是「前一个区间」的左端点;</li>
<li>右端点就是两者「右端点的最大值」。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));  <span class="comment">// 升序排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &gt;= intervals[i+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">            intervals[i+<span class="number">1</span>][<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            intervals[i+<span class="number">1</span>][<span class="number">1</span>] = Math.max(intervals[i][<span class="number">1</span>], intervals[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.add(intervals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个对比完记得加入result数组中</span></span><br><span class="line">    result.add(intervals[intervals.length - <span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span>[][] reIntervals = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">        reIntervals[i] = result.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reIntervals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非重叠区间"><a href="#非重叠区间" class="headerlink" title="非重叠区间"></a>非重叠区间</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/description/">LeetCode_435. 无重叠区间</a></p>
<p><strong>贪心策略:</strong></p>
<ol>
<li>按照「左端点」排序;</li>
<li>当两个区间「重叠」的时候，为了能够「在移除某个区间后，保留更多的区间」，我们应该把「区间范围较大」的区间移除。</li>
</ol>
<p>如何移除区间范围较大的区间：由于已经按照「左端点」排序了，因此两个区间重叠的时候，应该移除「右端点较大」的区间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">    Arrays.sort(intervals, (a,b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>])); <span class="comment">// 升序排列</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 统计需要移除的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &gt; intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123; <span class="comment">// 代表存在重复</span></span><br><span class="line">            count++;</span><br><span class="line">            intervals[i+<span class="number">1</span>][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>], intervals[i + <span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// 修改下一段区间起点位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重叠区间数量"><a href="#重叠区间数量" class="headerlink" title="重叠区间数量"></a>重叠区间数量</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">LeetCode_452. 用最少数量的箭引爆气球</a></p>
<p><strong>贪心策略:</strong></p>
<ul>
<li>按照左端点排序，我们发现，排序后有这样一个性质:「互相重叠的区间都是连续的」;</li>
<li>这样，我们在射箭的时候，要发挥每一支箭「最大的作用」，应该把「互相重叠的区间」统一引爆。</li>
</ul>
<p><strong>如何求互相重叠区间?</strong></p>
<p>由于我们是按照「左端点」排序的，因此对于两个区间，我们求的是它们的「交集」:</p>
<ol>
<li>左端点为两个区间左端点的「最大值」(但是左端点不会影响我们的合并结果，所以可以忽略)</li>
<li>右端点为两个区间右端点的「最小值」。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以用 合并区间的代码，只需要改三个字母即可，其中要注意安全比较</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> merge(points); <span class="comment">// 返回列表大小即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123; <span class="comment">// 合并区间代码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>])); <span class="comment">// 安全比较</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>],R = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(merged.size() == <span class="number">0</span> || merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L)&#123;</span><br><span class="line">            merged.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L,R&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 注意就是这里，把max换成min即可</span></span><br><span class="line">            merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.min(merged.get(merged.size() -<span class="number">1</span>)[<span class="number">1</span>],R);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间套娃"><a href="#区间套娃" class="headerlink" title="区间套娃"></a>区间套娃</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/russian-doll-envelopes/description/">Leetcode_354. 俄罗斯套娃信封问题</a></p>
<p><strong>思路：重写排序 + 贪心 + 二分</strong></p>
<p>当我们把整个信封按照「下面的规则」排序之后:</p>
<ol>
<li>左端点不同的时候:按照「左端点从小到大」排序;</li>
<li>左端点相同的时候:按照「右端点从大到小」排序</li>
</ol>
<p>此时问题就变成了仅考虑信封的「右端点」，完全变成「最长上升子序列」模型。就可以用「贪心+二分」优化算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先按长排序, 然后按照O(N^2)的最长递增子序列的思想来做</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEnvelopes</span><span class="params">(<span class="type">int</span>[][] envelopes)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> envelopes.length;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    Arrays.sort(envelopes, (a,b) -&gt; (a[<span class="number">0</span>]-b[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(envelopes[i][<span class="number">0</span>] &gt; envelopes[j][<span class="number">0</span>] &amp;&amp; envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>])</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(NlogN)的做法, 按照长度升序, 同长则宽度降序排列, 然后使用O(logN)的最长递增子序列解法(链接在评论中)来做即可. 排序后等于把在二维(长、宽)上的最长递增子序列问题转换成一维(宽)上的最长递增子序列的查找, 因为对于长度来说已经满足递增, 只需要在宽度上也递增即为递增序列, 同长时按宽度降序排列的原因是避免同长时宽度小的也被列入递增序列中, 例如[3,3], [3,4],如果宽度也按升序来排列, [3,3]和[3,4]会形成递增序列, 而实际上不行.</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEnvelopes</span><span class="params">(<span class="type">int</span>[][] envelopes)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[envelopes.length];</span><br><span class="line">    Arrays.sort(envelopes, (a, b) -&gt; (a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] - a[<span class="number">1</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] env : envelopes) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = maxL;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[mid] &lt; env[<span class="number">1</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[lo] = env[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(lo == maxL) maxL++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数问题"><a href="#整数问题" class="headerlink" title="整数问题"></a>整数问题</h2><h3 id="坏了的计算器"><a href="#坏了的计算器" class="headerlink" title="坏了的计算器"></a>坏了的计算器</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/broken-calculator/description/">LeetCode_991. 坏了的计算器 </a></p>
<p><strong>贪心策略：【正难则反】</strong></p>
<p>当「反着」来思考的时候，我们发现</p>
<ol>
<li>当 end&lt;= begin 的时候，只能执行「加法」操作;</li>
<li>当 end &gt; begin 的时候，对于「奇数」来说，只能执行「加法」操作;对于「偶数」来说，最好的方式就是执行「除法」操作</li>
</ol>
<p>这样的话，每次的操作都是「固定唯一」的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">brokenCalc</span><span class="params">(<span class="type">int</span> startValue, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(startValue &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">return</span> startValue - target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + brokenCalc(startValue, target / <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + brokenCalc(startValue, target + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整数替换"><a href="#整数替换" class="headerlink" title="整数替换"></a>整数替换</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-replacement/description/">LeetCode_397. 整数替换</a></p>
<p><strong>贪心策略:</strong>  我们的任何选择，应该让这个数尽可能快的变成1</p>
<p>对于偶数：只能执行除 2操作，没有什么分析的;</p>
<p>对于奇数：    </p>
<ul>
<li>当 n == 1 的时候，不用执行任何操作;</li>
<li>当 n == 3 的时候，变成 1 的最优操作数是 2;</li>
<li>当 n &gt; 1 &amp;&amp; n%4 == 1 的时候，那么它的二进制表示是……01，最优的方式应该选择 -1，这样就可以把末尾的1干掉，接下来执行除法操作，能够更快的变成</li>
<li>当 n &gt; 3 &amp;&amp; n%4 == 3 的时候，那么它的二进制表示是……11，此时最优的策略应该是 +1，这样可以把一堆连续的1转换成 0，更快的变成 1。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerReplacement</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>)func((<span class="type">long</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">func</span><span class="params">(<span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> + func(n / <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>  &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> + Math.min(func(n + <span class="number">1</span>), func(n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可被三整除的最大和"><a href="#可被三整除的最大和" class="headerlink" title="可被三整除的最大和"></a>可被三整除的最大和</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/greatest-sum-divisible-by-three/description/">LeetCode_1262. 可被三整除的最大和</a></p>
<p><strong>思路</strong>：正难则反 + 贪心 + 分类讨论</p>
<p><strong>正难则反：</strong>可以先把所有的数累加在一起，然后根据累加和的结果，贪心的删除一些数。</p>
<p><strong>分类讨论：</strong>设累加和为 sum，用 x 标记 %3 == 1 的数，用 y 标记 %3 == 2 的数。那么根据 sum 的余数，可以分为下面三种情况:</p>
<ol>
<li><p>sum %3 == 0，此时所有元素的和就是满足要求的，那么我们一个也不用删除;，</p>
</li>
<li><p>sum %3 == 1，此时数组中要么存在一个 x，要么存在两个 y。因为我们要的是最大值，所以应该选择 x 中最小的那么数，记为x1，或者是y 中最小以及次小的两个数，记为 y1，y2。    </p>
<p>那么，我们应该选择两种情况下的最大值：max(sum-x1，sum - y1 -y2）；</p>
</li>
<li><p>sum %3 == 2，此时数组中要么存在一个 y，要么存在两个 x。因为我们要的是最大值，所以应该选择 y 中最小的那么数，记为y1，或者是x 中最小以及次小的两个数，记为 x1，x2。    </p>
<p>那么，我们应该选择两种情况下的最大值：max(sum-y1，sum - x1 -x2）；</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumDivThree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>]; <span class="comment">// dp[i][j]表示前i个数，模3=j时的最大值</span></span><br><span class="line">    dp[<span class="number">0</span>][nums[<span class="number">0</span>] % <span class="number">3</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//先将上一个状态转移过来</span></span><br><span class="line">            dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            <span class="comment">//转移每个模3=j的数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j] + nums[i];</span><br><span class="line">            dp[i][sum % <span class="number">3</span>] = Math.max(dp[i][sum % <span class="number">3</span>],sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/submissions/650566325/">LeetCode_738. 单调递增的数字</a></p>
<p><strong>解法(贪心)</strong></p>
<ol>
<li>为了方便处理数中的每一位数字，可以先讲整数转换成字符串</li>
<li>从左往右扫描，找到第一个递减的位置</li>
<li>从这个位置向前推，推到相同区域的最左端</li>
<li>该点的值 -1，后面的所有数统一变成 9</li>
</ol>
<p><strong>思路</strong>：从右向左扫描数字，若发现当前数字比其左边一位（较高位）小， 则把其左边一位数字减1，并将该位及其右边的所有位改成9</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[i] &lt; chars[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            flag = i;</span><br><span class="line">            chars[i - <span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> flag; i &lt; length; i++) &#123;</span><br><span class="line">        chars[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(chars));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><h3 id="排列数字使相邻数字不等"><a href="#排列数字使相邻数字不等" class="headerlink" title="排列数字使相邻数字不等"></a>排列数字使相邻数字不等</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distant-barcodes/description/">LeetCode_1054. 距离相等的条形码 </a></p>
<p><strong>贪心策略:</strong></p>
<ol>
<li>每次处理一批相同的数字，往n个空里面摆放;</li>
<li>每次摆放的时候，隔一个格子摆放一个数;</li>
<li>优先处理出现次数最多的那个数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] rearrangeBarcodes(<span class="type">int</span>[] barcodes) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> barcodes.length,temp;</span><br><span class="line">    <span class="comment">// 从左边开始找到相邻条形码相同，将后一个条形码与后面不同的条形码交换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(barcodes[i] == barcodes[i-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(barcodes[j] != barcodes[i])&#123;</span><br><span class="line">                    swap(barcodes,i,j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右边再来一次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(barcodes[i] == barcodes[i + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(barcodes[j] != barcodes[i])&#123;</span><br><span class="line">                    swap(barcodes,i,j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从左边不能保证[2,1,1]、[2,3,1,1,1]，从右边不能保证[1,1,2]等，但左右都来一次就能保证结果满足      </span></span><br><span class="line">    <span class="keyword">return</span> barcodes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] barcodes, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> barcodes[i];</span><br><span class="line">    barcodes[i] = barcodes[j];</span><br><span class="line">    barcodes[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排列字符串使相邻字符不等"><a href="#排列字符串使相邻字符不等" class="headerlink" title="排列字符串使相邻字符不等"></a>排列字符串使相邻字符不等</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorganize-string/description/">LeetCode_767. 重构字符串</a></p>
<p>Java大根堆，每次取出现频率最多的2个字符组合，重点对于剩1个元素时情况的讨论</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reorganizeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        cnt[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1,o2) -&gt; (o2[<span class="number">1</span>]-o1[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i] != <span class="number">0</span>) pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i,cnt[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> !pq.isEmpty();</span><br><span class="line">    <span class="keyword">if</span> (pq.peek()[<span class="number">1</span>] &gt; n/<span class="number">2</span> + <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span>[] a = pq.poll(), b = pq.poll();</span><br><span class="line">        <span class="keyword">assert</span> b != <span class="literal">null</span>;</span><br><span class="line">        sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span>+a[<span class="number">0</span>]));</span><br><span class="line">        sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span>+b[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">if</span> (--a[<span class="number">1</span>] &gt; <span class="number">0</span>) pq.add(a);</span><br><span class="line">        <span class="keyword">if</span> (--b[<span class="number">1</span>] &gt; <span class="number">0</span>) pq.add(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pq.isEmpty()) <span class="keyword">return</span> sb.toString();</span><br><span class="line">    <span class="keyword">if</span> (pq.peek()[<span class="number">1</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span>+pq.peek()[<span class="number">0</span>])).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="行驶问题"><a href="#行驶问题" class="headerlink" title="行驶问题"></a>行驶问题</h2><h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/description/">LeetCode_134. 加油站 </a></p>
<p><strong>暴力解法:</strong></p>
<ul>
<li>依次枚举所有的起点:</li>
<li>从起点开始，模拟一遍加油的流程</li>
</ul>
<p><strong>贪心优化:</strong></p>
<ul>
<li>当从 i位置出发，走了 step 步之后，如果失败了。那么[i，i+ step]这个区间内任意一个位置作为起点，都不可能环绕一圈。</li>
<li>因此我们枚举的下一个起点，应该是 i + step + 1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 只要sumOfCost &lt;= sumOfGas 就代表者一定是可以到达的</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>, minBalance = <span class="number">0</span>; <span class="comment">// 具体从哪里出发的话就是从欠债最多的那个加油站就可以的</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class="line">       balance += gas[i] - cost[i];</span><br><span class="line">       <span class="keyword">if</span> (balance &lt; minBalance) &#123;</span><br><span class="line">           minBalance = balance;</span><br><span class="line">           minIndex = i + <span class="number">1</span>; <span class="comment">// 这里是问的第几个加油站</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> balance &gt;= <span class="number">0</span> ? minIndex : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列问题"><a href="#序列问题" class="headerlink" title="序列问题"></a>序列问题</h2><h3 id="递增的三元子序列"><a href="#递增的三元子序列" class="headerlink" title="递增的三元子序列"></a>递增的三元子序列</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/increasing-triplet-subsequence/description/">LeetCode_334. 递增的三元子序列</a></p>
<p><strong>贪心策略:</strong></p>
<ul>
<li>最长递增子序列的简化版。</li>
<li>不用一个数组存数据，仅需两个变量即可。也不用二分插入位置，仅需两次比较就可以找到插入位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">increasingTriplet</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2147483647</span>, b = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n: nums) </span><br><span class="line">        <span class="keyword">if</span> (n &lt;= a) a = n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= b) b = n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>题目链接：<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://leetcode.cn/problems/longest-increasing-subsequence/&objectId=2527732&objectType=1&isNewArticle=undefined">LeetCode_300. 最长递增子序列</a></p>
<p><strong>贪心策略:</strong></p>
<ul>
<li>在考虑最长递增子序列的长度的时候，其实并不关心这个序列长什么样子，我们只是关心最后一个元素是谁。</li>
<li>这样新来一个元素之后，我们就可以判断是否可以拼接到它的后面。</li>
<li>因此，我们可以创建一个数组，统计长度为 x的递增子序列中，最后一个元素是谁。</li>
<li>为了尽可能的让这个序列更长，我们仅需统计长度为 x的所有递增序列中最后一个元素的「最小值」。</li>
<li>统计的过程中发现，数组中的数呈现「递增」趋势，因此可以使用「二分」来查找插入位置。</li>
</ul>
<p><strong>思路</strong>：</p>
<p>dp[i]: 所有长度为i+1的递增子序列中, 最小的那个序列尾数。由定义知dp数组必然是一个递增数组, 可以用 maxL 来表示最长递增子序列的长度。对数组进行迭代, 依次判断每个数num将其插入dp数组相应的位置:</p>
<ol>
<li>num &gt; dp[maxL], 表示num比所有已知递增序列的尾数都大, 将num添加入dp数组尾部, 并将最长递增序列长度maxL加1</li>
<li>dp[i - 1] &lt; num &lt;= dp[i], 只更新相应的dp[i]</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;  <span class="comment">// 二分法查找, 也可以调用库函数如binary_search</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = maxL;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid] &lt; num) &#123;</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hi = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[lo] = num;</span><br><span class="line">            <span class="keyword">if</span>(lo == maxL) &#123;</span><br><span class="line">                maxL++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://southernfish.github.io">Southern Fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://southernfish.github.io/2025/08/04/algorithm/greedy-algorithm/">https://southernfish.github.io/2025/08/04/algorithm/greedy-algorithm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://southernfish.github.io" target="_blank">Southern Fish</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/algorithm/">algorithm</a></div><div class="post_share"><div class="social-share" data-image="/img/article/article2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/08/06/algorithm/backtrack-algorithm/"><img class="prev-cover" src="/img/article/article3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">回溯算法</div></div></a></div><div class="next-post pull-right"><a href="/2025/08/02/algorithm/dynamic-programming/"><img class="next-cover" src="/img/article/article5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">动态规划算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/06/22/algorithm/java-algorithm-hard/" title="LeetCode的较难题"><img class="cover" src="/img/article/article5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-22</div><div class="title">LeetCode的较难题</div></div></a></div><div><a href="/2025/06/22/algorithm/java-algorithm-easy/" title="LeetCode的简单题"><img class="cover" src="/img/article/article6.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-22</div><div class="title">LeetCode的简单题</div></div></a></div><div><a href="/2025/06/22/algorithm/java-algorithm-medium/" title="LeetCode的中等难度题"><img class="cover" src="/img/article/article4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-22</div><div class="title">LeetCode的中等难度题</div></div></a></div><div><a href="/2025/08/02/algorithm/dynamic-programming/" title="动态规划算法"><img class="cover" src="/img/article/article5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-02</div><div class="title">动态规划算法</div></div></a></div><div><a href="/2025/08/02/algorithm/sliding-window/" title="滑动窗口算法"><img class="cover" src="/img/article/article2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-02</div><div class="title">滑动窗口算法</div></div></a></div><div><a href="/2025/08/06/algorithm/backtrack-algorithm/" title="回溯算法"><img class="cover" src="/img/article/article3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-06</div><div class="title">回溯算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southern Fish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SouthernFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1002721576@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">天下事岂能尽如吾意，心境须恰适，尽其在我，随遇而安。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">贪心算法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">基本定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%A7%E8%B4%A8"><span class="toc-number">1.2.</span> <span class="toc-text">核心性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">1.3.</span> <span class="toc-text">贪心算法与动态规划的差异</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="toc-number">1.4.</span> <span class="toc-text">算法框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.</span> <span class="toc-text">典型应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.0.0.1.</span> <span class="toc-text">图论问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.0.0.2.</span> <span class="toc-text">组合优化问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.6.</span> <span class="toc-text">经典例题详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E7%A7%8D%E4%B8%8E%E6%8C%91%E6%88%98%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.0.0.1.</span> <span class="toc-text">变种与挑战问题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%8C%83%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">贪心策略的代码实现范式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">关键数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">经典问题实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%EF%BC%88%E6%9C%80%E5%A4%A7%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">区间调度（最大不重叠区间）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%EF%BC%88%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">哈夫曼编码（数据压缩）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E%E4%B8%8E%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">正确性证明与复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">证明方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.3.2.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">2.3.3.</span> <span class="toc-text">适用条件判断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number">3.1.</span> <span class="toc-text">分发糖果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">盛最多水的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.</span> <span class="toc-text">背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AD%E7%89%A9%E6%B8%85%E5%8D%95%EF%BC%88%E5%B8%A6%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">购物清单（带条件的背包问题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E6%97%B6%E9%97%B4%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.</span> <span class="toc-text">活动时间安排问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">最小生成树（克鲁斯卡尔算法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E8%A6%86%E7%9B%96%EF%BC%88Lines-cover%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">线段覆盖（Lines cover）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">3.8.</span> <span class="toc-text">数字组合问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%BC%E6%95%B0"><span class="toc-number">3.9.</span> <span class="toc-text">拼数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E9%9B%B6%E9%92%B1%E9%97%AE%E9%A2%98"><span class="toc-number">3.10.</span> <span class="toc-text">找零钱问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA-%E4%BA%8C"><span class="toc-number">3.11.</span> <span class="toc-text">买卖股票的最好时机(二)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E9%98%9F%E7%AB%9E%E8%B5%9B"><span class="toc-number">3.12.</span> <span class="toc-text">组队竞赛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="toc-number">3.13.</span> <span class="toc-text">区间问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">3.13.1.</span> <span class="toc-text">合并区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-number">3.13.2.</span> <span class="toc-text">非重叠区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E6%95%B0%E9%87%8F"><span class="toc-number">3.13.3.</span> <span class="toc-text">重叠区间数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%A5%97%E5%A8%83"><span class="toc-number">3.13.4.</span> <span class="toc-text">区间套娃</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">3.14.</span> <span class="toc-text">整数问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%8F%E4%BA%86%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">3.14.1.</span> <span class="toc-text">坏了的计算器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%9B%BF%E6%8D%A2"><span class="toc-number">3.14.2.</span> <span class="toc-text">整数替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A2%AB%E4%B8%89%E6%95%B4%E9%99%A4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">3.14.3.</span> <span class="toc-text">可被三整除的最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">3.14.4.</span> <span class="toc-text">单调递增的数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">3.15.</span> <span class="toc-text">排列问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97%E4%BD%BF%E7%9B%B8%E9%82%BB%E6%95%B0%E5%AD%97%E4%B8%8D%E7%AD%89"><span class="toc-number">3.15.1.</span> <span class="toc-text">排列数字使相邻数字不等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6%E4%B8%8D%E7%AD%89"><span class="toc-number">3.15.2.</span> <span class="toc-text">排列字符串使相邻字符不等</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E9%A9%B6%E9%97%AE%E9%A2%98"><span class="toc-number">3.16.</span> <span class="toc-text">行驶问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">3.16.1.</span> <span class="toc-text">加油站</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">3.17.</span> <span class="toc-text">序列问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.17.1.</span> <span class="toc-text">递增的三元子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.17.2.</span> <span class="toc-text">最长递增子序列</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/07/algorithm/simple_algorithm/" title="其他简单算法"><img src="/img/article/article1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="其他简单算法"/></a><div class="content"><a class="title" href="/2025/08/07/algorithm/simple_algorithm/" title="其他简单算法">其他简单算法</a><time datetime="2025-08-07T07:30:36.000Z" title="发表于 2025-08-07 15:30:36">2025-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/06/algorithm/backtrack-algorithm/" title="回溯算法"><img src="/img/article/article3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="回溯算法"/></a><div class="content"><a class="title" href="/2025/08/06/algorithm/backtrack-algorithm/" title="回溯算法">回溯算法</a><time datetime="2025-08-06T10:30:36.000Z" title="发表于 2025-08-06 18:30:36">2025-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/04/algorithm/greedy-algorithm/" title="贪心算法"><img src="/img/article/article2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="贪心算法"/></a><div class="content"><a class="title" href="/2025/08/04/algorithm/greedy-algorithm/" title="贪心算法">贪心算法</a><time datetime="2025-08-04T07:20:36.000Z" title="发表于 2025-08-04 15:20:36">2025-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/02/algorithm/dynamic-programming/" title="动态规划算法"><img src="/img/article/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动态规划算法"/></a><div class="content"><a class="title" href="/2025/08/02/algorithm/dynamic-programming/" title="动态规划算法">动态规划算法</a><time datetime="2025-08-02T06:20:36.000Z" title="发表于 2025-08-02 14:20:36">2025-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/02/algorithm/sliding-window/" title="滑动窗口算法"><img src="/img/article/article2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="滑动窗口算法"/></a><div class="content"><a class="title" href="/2025/08/02/algorithm/sliding-window/" title="滑动窗口算法">滑动窗口算法</a><time datetime="2025-08-02T02:00:36.000Z" title="发表于 2025-08-02 10:00:36">2025-08-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/article/article2.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Southern Fish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>