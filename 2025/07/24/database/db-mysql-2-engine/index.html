<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MySQL数据库-存储引擎和索引 | Southern Fish</title><meta name="keywords" content="MySQL"><meta name="author" content="Southern Fish"><meta name="copyright" content="Southern Fish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="‌数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。数据库软件有着整体性和共享性的特点。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL数据库-存储引擎和索引">
<meta property="og:url" content="https://southernfish.github.io/2025/07/24/database/db-mysql-2-engine/index.html">
<meta property="og:site_name" content="Southern Fish">
<meta property="og:description" content="‌数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。数据库软件有着整体性和共享性的特点。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://southernfish.github.io/img/article/article5.png">
<meta property="article:published_time" content="2025-07-24T04:30:36.000Z">
<meta property="article:modified_time" content="2025-07-27T13:24:06.379Z">
<meta property="article:author" content="Southern Fish">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://southernfish.github.io/img/article/article5.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://southernfish.github.io/2025/07/24/database/db-mysql-2-engine/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL数据库-存储引擎和索引',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-27 21:24:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Southern Fish" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/article/article5.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Southern Fish</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL数据库-存储引擎和索引</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-24T04:30:36.000Z" title="发表于 2025-07-24 12:30:36">2025-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-27T13:24:06.379Z" title="更新于 2025-07-27 21:24:06">2025-07-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Database/">Database</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL数据库-存储引擎和索引"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>MySQL数据库中，数据库引擎(Storage Engine)是用于控制数据存储、检索和操作的底层软件组件。每种存储引擎都提供了不同的数据存储机制、索引策略、锁定级别等特性。MySQL从版本5.5起，默认存储引擎是InnoDB，但在更早的版本中，MVISAM是默认存储引擎。</p>
<blockquote>
<p>参考原文：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/article/details/130308116">MySQL高级篇——存储引擎和索引</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/article/details/130462818">MySQL高级篇——MVCC多版本并发控制</a></p>
</blockquote>
<h1>存储引擎</h1>
<h2 id="查看、设置存储引擎的命令">查看、设置存储引擎的命令</h2>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查看mysql提供什么存储引擎</span><br><span class="line"><span class="keyword">show</span> engines;</span><br><span class="line"># 查看默认的存储引擎，两种方式</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@default</span>_storage_engine;</span><br><span class="line"># 创建表时指定存储引擎</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    建表语句;</span><br><span class="line">) ENGINE <span class="operator">=</span> 存储引擎名称;</span><br><span class="line"># 例如，在创建表时指定使用InnoDB存储引擎</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"># 修改表的存储引擎</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure>
<h2 id="MySQL-的常用引擎">MySQL 的常用引擎</h2>
<p><code>InnoDB 引擎</code>：mysql 5.1 后默认的数据库引擎，提供了对数据库 <strong>acid 事务的支持</strong>，并且还提供了<strong>行级锁和外键的约束</strong>，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在<strong>内存中建立缓冲池，用于缓冲数据和索引</strong>。但该引擎<em>不支持全文搜索，同时启动也比较慢，它不会保存表的行数</em>，所以当进行 <code>select count(*) from table</code> 指令时，需要进行扫描全表。由于锁的粒度小，写操作不会锁定全表,所以<strong>在并发度较高的场景下使用会提升效率</strong>。<br>
<code>MyIASM 引擎</code>：<strong>不提供事务的支持，也不支持行级锁和外键</strong>。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是<strong>保存了表的行数</strong>，于是当进行 <code>select count(*) from table</code> 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p>
<h2 id="InnoDB引擎">InnoDB引擎</h2>
<h3 id="InnoDB-介绍">InnoDB 介绍</h3>
<p>**InnoDB：**支持外键和事务，行锁适合高并发，缓存索引和数据，内存要求高（因为要缓存索引和记录），适合存大数据量，增删改性能更优（行级锁高并发），耗费磁盘（因为有多个非聚簇索引，索引可能比记录空间还大）。</p>
<p><strong>InnoDB</strong>索引文件在数据库中存放的对应表的磁盘文件有<code>*.frm，*.ibd</code>结尾的两个文件；</p>
<ul>
<li>frm文件是存放的表结构，表的定义信息；</li>
<li>*.ibd文件是存放着表中的数据、索引信息；</li>
</ul>
<h3 id="InnoDB-特点">InnoDB 特点</h3>
<ol>
<li>**事务支持：**InnoDB支持ACID事务属性。</li>
<li><strong>崩溃恢复</strong>：InnoDB会<strong>将数据写入到磁盘上的日志文件</strong>中，即使在系统崩溃的情况下，也能通过这些日志文件恢复数据。</li>
<li>**MVCC (多版本并发控制)：**InnoDB使用多版本并发控制，这允许更高的并发性。</li>
<li>**外键约束：**InnoDB支持外键约束，这对于维护数据库的引用完整性非常有用。</li>
<li><strong>行级锁定：<strong>与表级锁定相比，InnoDB</strong>支持行级锁定，提供了更高的并发性能</strong>。</li>
<li><strong>自适应哈希索引：<strong>InnoDB会</strong>自动为频繁访问的热点数据创建哈希索引，以提高查询速度</strong>。</li>
</ol>
<ul>
<li>MySQL从3.23.34a开始就包含InnoDB存储引擎。大于等于5.5之后，<strong>默认采用InnoDB引擎</strong>。</li>
<li>InnoDB是MySQL的默认事务型引擎，它被设计用来<strong>处理大量的短期(short-lived)事务</strong>。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li>
<li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</li>
<li>除非有非常特别的原因需要使用其他的存储引擎，否则应该<strong>优先考虑InnoDB引擎</strong>。</li>
<li>InnoDB是<strong>为处理巨大数据量的最大性能设计</strong>。</li>
<li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。</li>
<li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）；表名.ibd 存储数据和索引</li>
<li>InnoDB增删改性能更优；MyISAM查询性能更优。</li>
<li>MyISAM只缓存索引不缓存真实数据；InnoDB<strong>不仅缓存索引还要缓存真实数据</strong>， 对内存要求高，且<strong>内存大小对性能有决定性影响</strong>。</li>
</ul>
<h3 id="InnoDB-优势">InnoDB 优势</h3>
<p>InnoDB存储引擎在实际应用中拥有诸多优势，比如<strong>操作便利、提高了数据库的性能、维护成本低</strong>等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB<strong>崩溃恢复功能</strong>自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。</p>
<p>InnoDB存储引擎在主内存中维护<strong>缓冲池</strong>，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。</p>
<p>在专用服务器上，物理内存中高达80%的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置<strong>外键</strong>加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃，在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。InnoDB不仅支持当前读写，也会缓冲改变的数据到数据流磁盘。</p>
<p>InnoDB的性能优势不只存在于长时运行查询的<strong>大型表</strong>。在同一列多次被查询时，自适应<strong>哈希索引</strong>会<strong>提高查询的速度</strong>。使用InnoDB可以压缩表和相关的索引，可以在不影响性能和可用性的情况下创建或删除索引。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。通过查询INFORMATION_SCHEMA库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。当处理<strong>大数据量</strong>时，InnoDB兼顾CPU，以达到<strong>最大性能</strong>。</p>
<h3 id="InnoDB-事务的ACID特性">InnoDB 事务的ACID特性</h3>
<blockquote>
<p><strong>原子性</strong>（Atomicity， A）：事务中的所有操作，要么全部成功，要么全部失败<br>
<strong>一致性</strong>（Consistency， C）：要保证数据库内部完整性约束、声明性约束<br>
<strong>隔离性</strong>（Isolation， I）：对同一资源操作的事务不能同时发生，事务之间互相隔离。<br>
<strong>持久性</strong>（Durability， D）：对数据库做的一切修改将永久保存，不管是否出现故障。一旦事务成功，数据一定会落入数据库。</p>
</blockquote>
<p>ACID模型是一系列<strong>数据库设计规则</strong>，这些规则着重<strong>强调可靠性</strong>。MySQL包含类似InnoDB存储引擎的组件，与ACID模型紧密相连，这样出现意外时，数据不会崩溃，结果不会失真。如果依赖ACID模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将MySQL设置调整为只依赖部分ACID特性，以达到更高的性能。</p>
<p>InnoDB存储引擎与ACID模型相同作用的四个方面：</p>
<p><strong>1. 原子方面</strong> ACID的原子方面主要涉及InnoDB事务，与MySQL相关的特性主要包括：</p>
<ul>
<li>自动提交设置。</li>
<li>COMMIT语句。</li>
<li>ROLLBACK语句。</li>
<li>操作<code>INFORMATION_SCHEMA</code>库中的表数据。</li>
</ul>
<p><strong>2. 一致性方面</strong> ACID模型的一致性主要涉及保护数据不崩溃的内部InnoDB处理过程，与MySQL相关的特性主要包括：</p>
<ul>
<li>InnoDB双写缓存。</li>
<li>InnoDB崩溃恢复。</li>
</ul>
<p><strong>3. 隔离方面</strong> 隔离是应用于事务的级别，与MySQL相关的特性主要包括：</p>
<ul>
<li>自动提交设置。</li>
<li><code>SET ISOLATION LEVEL</code>语句。</li>
<li>InnoDB锁的低级别信息。</li>
</ul>
<p><strong>4. 持久性方面</strong> ACID模型的持久性主要涉及与硬件配置相互影响的MySQL软件特性。由于硬件复杂多样化，耐久性方面没有具体的规则可循。与MySQL相关的特性有：</p>
<ul>
<li>InnoDB双写缓存，通过<code>innodb_doublewrite</code>配置项配置。</li>
<li>配置项<code>innodb_flush_log_at_trx_commit</code>。</li>
<li>配置项<code>sync_binlog</code>。</li>
<li>配置项<code>innodb_file_per_table</code>。</li>
<li>存储设备的写入缓存。</li>
<li>存储设备的备用电池缓存。</li>
<li>运行MySQL的操作系统。</li>
<li>持续的电力供应。</li>
<li>备份策略。</li>
<li>对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况。</li>
</ul>
<h3 id="InnoDB-架构">InnoDB 架构</h3>
<ol>
<li>
<p><strong>缓冲池</strong></p>
<p>缓冲池是主内存中的一部分空间，用来<strong>缓存已使用的表和索引数据</strong>。缓冲池使常被使用的数据能直接在内存中获得，从而提高速度。</p>
</li>
<li>
<p><strong>更改缓存</strong></p>
<p>更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分InnoDB缓冲池。在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由<code>innodb_change_buffering</code>配置项管理。</p>
</li>
<li>
<p><strong>自适应哈希索引</strong></p>
<p>自适应哈希索引将负载和足够的内存结合起来，使得InnoDB像内存数据库一样运行，不需要降低事务上的性能或可靠性。这个特性通过<code>innodb_adaptive_hash_index</code>选项配置，或者通过<code>--skip-innodb_adaptive_hash_index</code>命令行在服务启动时关闭。</p>
</li>
<li>
<p><strong>重做日志缓存</strong></p>
<p>重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过<code>innodb_log_buffer_size</code>配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存使得大型事务能够正常运行而不需要写入磁盘。</p>
</li>
<li>
<p><strong>系统表空间</strong></p>
<p>系统表空间包括<strong>InnoDB数据字典、双写缓存、更新缓存和撤销日志</strong>，同时也包括<strong>表和索引数据</strong>。多表共享，系统表空间被视为共享表空间。</p>
</li>
<li>
<p><strong>双写缓存</strong></p>
<p>位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存后，InnoDB才会将数据页写入合适的位置。</p>
</li>
<li>
<p><strong>撤销日志</strong></p>
<p>撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这些片段包含于回滚片段中。</p>
</li>
<li>
<p><strong>每个表一个文件的表空间</strong></p>
<p>每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中，而不是系统表空间中。这个功能通过innodb_file_per_table配置项开启。每个表空间由一个单独的.ibd数据文件代表，该文件默认被创建在数据库目录中。</p>
</li>
<li>
<p><strong>通用表空间</strong></p>
<p>使用<code>CREATE TABLESPACE</code>语法创建共享的InnoDB表空间。通用表空间可以创建在MySQL数据目录之外能够管理多个表并支持所有行格式的表。</p>
</li>
<li>
<p><strong>撤销表空间</strong></p>
<p>撤销表空间<strong>由一个或多个包含撤销日志的文件</strong>组成。撤销表空间的数量由<code>innodb_undo_tablespaces</code>配置项配置。</p>
</li>
<li>
<p><strong>临时表空间</strong></p>
<p>用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。<code>innodb_temp_data_file_path</code>配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在<code>innodb_data_home_dir</code>变量指定的目录下创建一个自动扩展的数据文件。</p>
</li>
<li>
<p><strong>重做日志</strong></p>
<p>重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间，重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自动在初始化期间重新进行。</p>
</li>
</ol>
<h3 id="innoDB-数据存储结构">innoDB 数据存储结构</h3>
<h4 id="页：数据库的基本存储单位">页：数据库的基本存储单位</h4>
<p>页是<strong>磁盘与内存交互基本单位</strong>。</p>
<p>InnoDB 将数据划分为若千个页，InnoDB中页的大小<strong>默认为 16KB</strong>。</p>
<p>以页作为磁盘和内存之间交互的基本单位，也就是<strong>一次最少</strong>从磁盘中读取<strong>16KB的内容</strong>到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，在数据库中，不论读一行，还是读多行，都是将这些<strong>行所在的页进行加载</strong>。</p>
<p>也就是说，<strong>数据库</strong>管理存储空间的<strong>基本单位是页</strong> (Page) ，数据库I/0 操作的最小单位是页。一个页中可以存储多个行记录。</p>
<blockquote>
<p>记录是按照行存储的，但数据库的读取并不以行为单位，否则一次读取(也就是一次 /0 操作)只能处理一行数据，效率会非常低。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725172941737.png" alt="image-20250725172941737"></p>
</blockquote>
<h4 id="数据页的大小">数据页的大小</h4>
<p>MyISAM 的数据页大小是固定的，是 1KB，也就是说，MyISAM 存储引擎的数据都是以 1KB 的块进行管理的。</p>
<p>InnoDB 存储引擎的数据页大小是可调的，默认是 16KB。在 MySQL 5.7 版本之前，InnoDB 的数据页大小默认是 8KB。可以通过参数 innodb_page_size 来设置 InnoDB 的数据页大小，取值范围是 4KB、8KB、16KB 和 32KB。</p>
<h4 id="页结构">页结构</h4>
<p>页a、页b、页c…页n 这些页可以 <strong>不在物理结构上相连</strong>，只要通过<strong>双向表</strong>相关联即可。每个数据页中的<strong>记录</strong>会按照主键值从小到大的顺序组成一个<strong>单向链表</strong> ，每个数据页都会为存储在它里边的记录生成一个<strong>页目录</strong>，在通过主键<strong>查找某条记录</strong>的时候可以在页目录中<strong>使用二分法</strong>（有序表可以用二分法）快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>
<p>不同的数据库管理系统(简称DBMS )的页大小不同。比如在 MySQL 的 nnoDB 存储引擎中，默认页的大小是16KB。<strong>查看页大小:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_page_size%&#x27;</span> </span><br></pre></td></tr></table></figure>
<p><strong>页的内部结构：</strong></p>
<p>页如果按类型划分的话，常见的有 <strong>数据页</strong>(保存 B+ 树节点)、<strong>系统页</strong>、<strong>Undo 页</strong>和 <strong>事务数据页</strong> 等。数据页是我们最常使用的页。</p>
<p>数据页的 <code>16KB</code> 大小的<strong>存储空间</strong>被划分为七个部分，可以把这7个结构分成3个部分：</p>
<p><strong>第1部分</strong>: File Header (文件头部)、 File Trailer(文件尾部)</p>
<p><strong>第2部分</strong>: User Records (用户记录)、最大最小记录(Infimum+supremum) 、Free Space(空闲空间)</p>
<p><strong>第3部分</strong>: Page Directory (页目录)、Page Header(页面头部)</p>
<p>页结构的7个部分作用分别如下表所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用大小</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>File Header</td>
<td>38字节</td>
<td>文件头，描述页的信息</td>
</tr>
<tr>
<td>Page Header</td>
<td>56字节</td>
<td>页头，页的状态信息</td>
</tr>
<tr>
<td>Infimum+Supremum</td>
<td>26字节</td>
<td>最大和最小记录，这是两个虚拟的<strong>行记录</strong></td>
</tr>
<tr>
<td>User Records</td>
<td>不确定</td>
<td>用户记录，存储<strong>行记录</strong>内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>不确定</td>
<td>空闲记录，页中还没有被使用的空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>不确定</td>
<td>页目录，存储用户记录的相对位置</td>
</tr>
<tr>
<td>File Trailer</td>
<td>8字节</td>
<td>文件尾，校验页是否完整</td>
</tr>
</tbody>
</table>
<h4 id="行、页、区、段、表空间的关系">行、页、区、段、表空间的关系</h4>
<p>另外在数据库中，还存在着<strong>区</strong>(Extent)、<strong>段</strong> (Segment) 和<strong>表空间</strong> (Tablespace) 的概念。行、页、区、段、表空间的关系如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725173932924.png" alt="image-20250725173932924"></p>
<p><strong>区</strong>(Extent)是比页大一级的存储结构，在 innoDB 存储引擎中，<strong>一个区会分配 64 个连续的页</strong>。因为nnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB= <strong>1MB</strong>。</p>
<p><strong>段</strong>(Segment)<strong>由一个或多个区组成</strong>，区在文件系统是一个<strong>连续分配的空间</strong>(在innoDB 中是连续的 64 个页)不过在段中不要求区与区之间是相邻的。段是数据库中的<strong>分配单位</strong> ，不同类型的数据库对象以不同的段形式存在。创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p>
<p><strong>表空间</strong>(Tablespace)是一个<strong>逻辑容器</strong>，表空间<strong>存储的对象是段</strong>，在一个表空间中可以有一个或多个段，但是一个段只能属干一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为 <strong>系统表空间、用户表空间、撤销表空间、 临时表空间</strong> 等。</p>
<h4 id="innoDB-四种行格式">innoDB 四种行格式</h4>
<p>我们平时的数据以行为单位来向表中插入数据，这些<strong>记录</strong>在磁盘上的<strong>存放方式</strong>也被称为<strong>行格式</strong>（也叫记录格式）。</p>
<p>InnoDB存储引擎设计了4种不同类型的行格式，分别是<strong>Compact、Redundant、Dynamic、Compressed</strong>行格式。</p>
<p><strong>Compact</strong></p>
<p>在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725174129726.png" alt="image-20250725174129726"></p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725174144140.png" alt="image-20250725174144140"></p>
<p><strong>Dynamic</strong></p>
<p>在MySQL 8.0中，默认行格式就是Dynamic。</p>
<p>Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧：</p>
<ul>
<li>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。</li>
<li>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。</li>
</ul>
<p><strong>Compressed</strong></p>
<p>Compressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725174235355.png" alt="image-20250725174235355"></p>
<p><strong>Redundant</strong></p>
<p>Redundant是MySQL 5.0版本之前InnoDB的行记录存储方式，MySQL 5.0支持Redundant是为了兼容之前版本的页格式。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725174303618.png" alt="image-20250725174303618"></p>
<p>从上图可以看到，不同于Compact行记录格式，Redundant行格式的首部是一个字段长度偏移列表，同样是按照列的顺序逆序放置的。</p>
<h4 id="指定行格式的命令">指定行格式的命令</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看MySQL8的默认行格式</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@innodb</span>_default_row_format;</span><br><span class="line"># 查看具体表使用的行格式</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">like</span> <span class="string">&#x27;表名&#x27;</span>\G</span><br><span class="line"># 在创建或修改表的语句中指定行格式</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT<span class="operator">=</span>行格式名称</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT<span class="operator">=</span>行格式名称</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> record_test_table (</span><br><span class="line">    col1 <span class="type">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    col2 <span class="type">VARCHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    col3 <span class="type">CHAR</span>(<span class="number">8</span>),</span><br><span class="line">    col4 <span class="type">VARCHAR</span>(<span class="number">8</span>)</span><br><span class="line">) CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure>
<h2 id="MyISAM-引擎">MyISAM 引擎</h2>
<h3 id="MyISAM-引擎介绍">MyISAM 引擎介绍</h3>
<p>**MyISAM：**不支持外键和事务，表锁不适合高并发，缓存索引和数据地址，内存要求低（因为不用缓存记录），查询性能更优（因为查询时InnoDB要维护MVCC一致，而且多缓存了记录），节省磁盘（因为磁盘不存完整记录）。</p>
<p>MyISAM索引文件在数据库中存放的对应表的磁盘文件有<code>*.frm，*.MYD，*.MYI</code>结尾的三个文件；</p>
<ul>
<li>frm文件是存放的表结构，表的定义信息；</li>
<li>MYD文件是存放着表中的数据；</li>
<li>MYI文件存放着表的索引信息；</li>
</ul>
<h3 id="MyISAM-特点">MyISAM 特点</h3>
<ul>
<li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM <strong>不支持事务、行级锁、外键</strong>，有一个毫无疑问的缺陷就是<strong>崩溃后无法安全恢复</strong>。</li>
<li>5.5之前默认的存储引擎</li>
<li>优势是<strong>访问的速度快</strong>，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li>
<li>针对<strong>数据统计有额外的常数存储</strong>。故而 count(*) 的查询效率很高</li>
<li>表名.frm 存储表结构；表名.MYD 存储数据 (MYData)；表名.MYI 存储索引 (MYIndex)</li>
<li>应用场景：<strong>只读应用或者以读为主的业务</strong></li>
</ul>
<h3 id="InnoDB-对比-MyISAM">InnoDB 对比 MyISAM</h3>
<p><strong><code>InnoDB</code></strong>：支持外键和事务，行锁适合高并发，缓存索引和数据，内存要求高（因为要缓存索引和记录），适合存大数据量，增删改性能更优（行级锁高并发），耗费磁盘（因为有多个非聚簇索引，索引可能比记录空间还大）。</p>
<p><strong><code>MyISAM</code></strong>：不支持外键和事务，表锁不适合高并发，缓存索引和数据地址，内存要求低（因为不用缓存记录），查询性能更优（因为查询时InnoDB要维护MVCC一致，而且多缓存了记录），节省磁盘（因为磁盘不存完整记录）。</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody>
<tr>
<td>特点</td>
<td>支持外键和事务</td>
<td>不支持外键和事务</td>
</tr>
<tr>
<td>行表锁</td>
<td>行锁，操作时只锁某一行，不对其它行有影响， 适合高并发的操作</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>缓存索引和数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
<td>只缓存索引，不缓存真实数据</td>
</tr>
<tr>
<td>关注点</td>
<td>事务：并发写、事务、更大资源</td>
<td>性能：节省资源、消耗少、简单业务、查询快</td>
</tr>
<tr>
<td>默认使用</td>
<td>5.5及其之后</td>
<td>5.5之前</td>
</tr>
</tbody>
</table>
<h2 id="其他引擎">其他引擎</h2>
<ul>
<li><strong><code>Archive</code> 引擎</strong>：用于数据存档。非常适合存储大量的独立的，作为历史记录的数据，因为它们不经常被读取。它 拥有高效的插入速度，但其对查询的支持相对较差。</li>
<li><strong><code>Blackhole</code> 引擎</strong>：丢弃写操作，读操作会返回空内容</li>
<li><strong><code>CSV</code> 引擎</strong>：存储数据时，以逗号分隔各个数据项</li>
<li><strong><code>Memory</code> 引擎</strong>：置于内存的表。将所有数据存储在 RAM 中，以便在需要快速查找非关键数据的环境中进行快速访问，以前被称为 HEAP 引擎。</li>
<li><strong><code>Federated</code> 引擎</strong>：访问远程表。提供连接单独的 MySQL 服务器，从多个物理服务器创建一个逻辑数据库的能力，非常适合分布式或数据集市环境。</li>
<li><strong><code>Merge</code> 引擎</strong>：管理多个MyISAM表构成的表集合</li>
<li><strong><code>NDB</code> 引擎</strong>：MySQL集群专用存储引擎。高冗余的存储引擎，用多台数据机器联合提供服务以提高整体性能和安全性。适合数据量大，安全和性能要求高的应用。</li>
</ul>
<hr>
<h1>索引</h1>
<h2 id="介绍">介绍</h2>
<p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL<strong>高效获取数据</strong>的数据结构。</p>
<p>索引是一种<strong>用于快速查询的排好序的数据结构</strong>。</p>
<p><strong>索引的本质</strong>：索引是<strong>数据结构</strong>。可简单理解为“<strong>排好序</strong>的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法。</p>
<p>索引是在<strong>存储引擎中实现</strong>的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。<strong>innoDB</strong>存储引擎的索引是<strong>B+树</strong>。同时，存储引擎可以定义每个表的<em>最大索引数和最大索引长度</em>。所有存储引擎<em>支持每个表至少16个索引</em>，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p>
<h2 id="优缺点">优缺点</h2>
<p><strong>优点：</strong></p>
<ol>
<li>类似图书馆建书目索引，<strong>提高数据检索的效率</strong>，降低数据库的IO成本，<strong>减少磁盘I/O次数</strong>，这也是创建索引最主要的原因。</li>
<li>通过创建<strong>唯一索引</strong>，可以保证数据库表中每一行数据的唯一性。</li>
<li>在实现数据的参考完整性方面，可以<strong>加速表和表之间的连接</strong>。即，对于有依赖关系的子表和父表<strong>联合查询</strong>时，可以提高查询速度。</li>
<li>使用<strong>分组和排序</strong>子句查询数据时，可<strong>显著提高查询速度</strong>，因为索引是“排好序的”，减少查询中分组和排序的时间，降低了CPU消耗。</li>
</ol>
<p><strong>缺点</strong></p>
<p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p>
<ol>
<li>创建索引和维护索引要耗费时间，并且随着数据量的增加，所<strong>耗费的时间</strong>也会增加。</li>
<li>索引需要<strong>占磁盘空间</strong>，除了<strong>数据表</strong>占数据空间之外，<strong>每一个索引</strong>还要占一定的物理空间， 存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li>
<li>虽然索引大大提高了查询速度，同时却会<strong>降低更新表的速度</strong>。当对表中的数据进行<strong>增加、删除和修改的时候</strong>，<strong>索引</strong>也要动态地<strong>维护</strong>，这样就降低了数据的维护速度。</li>
</ol>
<h2 id="索引的代价">索引的代价</h2>
<p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p>
<p><strong>空间上的代价</strong></p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB 的存储空间，一棵很大的B+树由<strong>许多数据页</strong>组成，那就是很大的一片<strong>存储空间</strong>。</p>
<p><strong>时间上的代价</strong></p>
<p>每次对表中的数据进行<strong>增、删、改</strong>操作时，都需要去<strong>修改各个B+树索引</strong>。B+树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（即不论是用户记录还是目录项记录）都按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，故存储引擎需要额外的时间进行一些记录移位， 页面分裂、页面回收等操作来维护好节点和记录的排序。若建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
<blockquote>
<p><strong>索引底层数据结构</strong>存在很多种类型，常见的索引结构有： <strong>B+ 树、B 树和Hash结构、红黑树</strong>。</p>
</blockquote>
<h2 id="B-树">B+树</h2>
<h3 id="B-树介绍">B+树介绍</h3>
<p>B+树是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素<strong>自底向上插入</strong>，最底层是0层，这与二叉树恰好相反。</p>
<p><strong>m阶 B+树有如下特征:</strong></p>
<ol>
<li>每个非叶节点关键字个数和孩子个数相等；</li>
<li>根结点关键字个数2到m，非根结点关键字个数⌈m/2⌉到m；</li>
<li>所有叶子在同一层；</li>
</ol>
<p><strong>B+树结构：</strong></p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725125901766.png" alt="image-20250725125901766"></p>
<p>数的层数越低，IO次数越少，查询越快。</p>
<p><strong>InnoDB的B+树索引的注意事项</strong>：</p>
<ol>
<li>根页面位置万年不动</li>
<li>内节点中目录项记录的唯一性</li>
<li>一个页面最少存储2条记录</li>
</ol>
<p>真实一个数据页可以存100条记录， 一个目录页能存1000条数据；4层B+树能存一千万条数据，我们用到的B+树都不会超过4层，每个页内部可以用二分查找更快查找。</p>
<blockquote>
<p><strong>InnoDB非聚簇索引情况</strong>：</p>
<p>InnoDB <strong>页的大小为 16KB</strong>，一般表的<strong>主键</strong>类型为 INT(占用4个字节)或 <strong>BIGINT</strong> (占用<strong>8个字节</strong>)，<strong>指针类型</strong>也一般为4或<strong>8个字节</strong>，也就是说一个页 (B+Tree 中的一个节点)中大概存储<strong>16KB/(8B+8B)=1K个键值</strong> (因为是估值，为方便计算，这里的K取值为 10^3。也就是说一个<strong>深度为3</strong>的B+Tree 索引可以维护 10^3*10^3*10^3= <strong>1 亿条记录</strong>(假定一个数据页也存储10^3条行记录数据了)</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，<strong>B+Tree 的高度一般都在</strong> <strong>2~4 层</strong>。MySQL的lnnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 <strong>1~3 次磁盘IO操作</strong>（根节点被缓存，不算IO次数）。</p>
<p><strong>数据页大小：</strong></p>
<p>MyISAM 的数据页大小是固定的，是 1KB，也就是说，MyISAM 存储引擎的数据都是以 1KB 的块进行管理的。</p>
<p>InnoDB 存储引擎的数据页大小是可调的，默认是 16KB。在 MySQL 5.7 版本之前，InnoDB 的数据页大小默认是 8KB。可以通过参数 <code>innodb_page_size</code> 来设置 InnoDB 的数据页大小，取值范围是 4KB、8KB、16KB 和 32KB。</p>
</blockquote>
<h3 id="innoDB的B-树聚簇索引，存储数据和目录">innoDB的B+树聚簇索引，存储数据和目录</h3>
<blockquote>
<p>每条记录是Compact 行格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line"> c1 <span class="type">INT</span>,</span><br><span class="line"> c2 <span class="type">INT</span>,</span><br><span class="line"> c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line"> ) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725130550720.png" alt="image-20250725130550720"></p>
</blockquote>
<p>**演示：**假设一个数据页只能存三条数据，一个目录页只能存四条数据，下面是存储状态：</p>
<p><strong>单个目录（两层B+树）：</strong></p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725130705253.png" alt="image-20250725130705253"></p>
<p><strong>大目录嵌套多个小目录（3层B+树）：</strong></p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725130742930.png" alt="image-20250725130742930"></p>
<h2 id="Hash结构">Hash结构</h2>
<h3 id="Hash结构介绍">Hash结构介绍</h3>
<p>哈希表+链地址法处理冲突+链表长度大于8时转为红黑树；</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725133628534.png" alt="image-20250725133628534"></p>
<p>Hash 本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。Hash 算法是通过某种确定性的算法(比如 MD5、SHA1、SHA2、SHA3) 将输入转变为输出。相同的输入永远可以得到相同的输出，假设输入内容有微小偏差，输出通常会有不同结果。</p>
<p>**优点：**增删改查时间复杂度O（1），从效率上来看，比B+树快；</p>
<p>**缺点：**范围查找效率差，退化成O（n）；排序效率极慢，数据存储没有顺序；每个节点是联合所有字段计算哈希值，无法对单独一个字段索引；不建议重复值多的情况使用，冲突时要不断比较整理链地址或红黑树耗费时间；</p>
<h3 id="innoDB自适应的哈希索引">innoDB自适应的哈希索引</h3>
<p><strong>innoDB</strong>不支持哈希索引，但支持<strong>自适应的哈希索引</strong>。如果某个数据<strong>经常被访问</strong>，当满足一定条件的时候，就会将这个<strong>数据页的地址存放到Hash 表</strong>中。这样下次查询的时候，就可以<strong>直接找到</strong>这个页面的所在位置。这样让 B+ 树也具备了 Hash 索引的优点。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725133656757.png" alt="image-20250725133656757"></p>
<h3 id="Hash-索引与-B-树索引的区别">Hash 索引与 B+ 树索引的区别</h3>
<ol>
<li>Hash 索引<strong>不能进行范围查询</strong>，而 B+ 树可以。这是因为 Hash 索引指向的数据是<strong>无序的</strong>，而 B+ 的叶子节点是个有序的链表。</li>
<li>Hash 索引 <strong>不支持联合索引的最左侧原则</strong> (即联合索引的部分索引无法使用)，而 B+ 树可以。对于联合索引来说，Hash 索引在计算 Hash 值的时候是将<strong>索引键合并</strong>后再一起<strong>计算 Hash 值</strong>，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</li>
<li>Hash 索<strong>不支持 ORDER BY 排序</strong>，因为 Hash 索引指向的数据是<strong>无序的</strong>，因此无法起到排序优化的作用，而 B+ 树索引数据是有序的，可以起到对该字段 ORDER BY 排序优化的作用。同理，我们也无法用 Hash索引进行 模糊查询，而 B+ 使用LKE 进行模糊查询的时候，LIKE 后面后模糊查询(比如 % 结尾)的话就可</li>
</ol>
<h2 id="B树">B树</h2>
<h3 id="介绍-2">介绍</h3>
<p>B树的英文是 Balance Tree，也就是 <strong>多路平衡查找树</strong>。简写为B-Tree (注意横杠表示这两个单词连起来的意思，不是减号)。它的高度远小于平衡二叉树的高度，毕竟是多叉不是二叉。</p>
<p>B树作为多路平衡查找树，它的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶。每个磁盘块中包括了<strong>关键字和子节点的指针</strong>。如果一个磁盘块中包括了<strong>x 个关键字</strong>，那么<strong>指针数就是x+1</strong>（例如节点有17和35两个关键字，它的三个子节点主键值范围分别是小于17、17~35之间、大于35）。对于一个 100 阶的B 树来说，如果有 3 层的话最多可以存储约 100 万的索引数据。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725133919656.png" alt="image-20250725133919656"></p>
<p>一个M 阶的B树(M&gt;2)有以下的特性：</p>
<p><strong>小结：</strong></p>
<p>1.B树在插入和删除节点的时候如果导致树不平衡，就通过<strong>自动调整节点</strong>的位置来保持树的<strong>自平衡.</strong></p>
<p>2.关键字集合分布在整棵树中,即<strong>叶子节点和非叶子节点都存放数据</strong>。搜索有可能在非叶子节点结束</p>
<p>3.其搜索性能等价于在关键字全集内做一次二分查找。</p>
<h3 id="B-树和-B-树的差异">B+ 树和 B 树的差异</h3>
<ol>
<li>非叶节点的关键字数量：k阶树，B+树非叶节点有k个值、k个孩子，B树非叶节点有k-1个值、k个孩子；</li>
<li>记录存储位置：B+树记录全存在叶节点，B树记录存在所有节点；</li>
<li>非叶节点功能：B+树非叶节点存索引，B树非叶节点存记录；</li>
<li>叶子结点之间关系：B+树所有叶子节点构成一个有序双向链表；B树叶节点之间没指针，只是有序；</li>
</ol>
<blockquote>
<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。但B树和B+树各有应用场景，不能说谁完全比谁好。</p>
</blockquote>
<p><strong>B+树中间结点不直接存储数据，好处：</strong></p>
<p>查询效率更高（比B树矮胖），IO次数也少，更稳定，查询范围也更大。</p>
<p><strong>为了减少IO，索引树会一次性加载吗？</strong></p>
<p>不会，会逐一加载数据页，先加载大目录页、再加载小目录页、再加载记录页。</p>
<ol>
<li>数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，<strong>超过几个G</strong>。</li>
<li>当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是: <strong>逐一加载每一个磁盘页</strong>，因为磁盘页对应着索引树的节点。</li>
</ol>
<p><strong>B+树的存储能力如何? 为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p>
<p><strong>lnnoDB</strong> 存储引擎中<strong>页</strong>的大小为 <strong>16KB</strong>，一般表的主键类型为 INT(占用4个字节)或 <strong>BIGINT (占用8个字节)</strong>，指针类型也一般为4或8个字节，也就是说一个页 (B+Tree 中的一个节点)中大概存储16KB/(8B+8B)=1K个键值 (因为是估值，为方便计算，这里的K取值为 10^3。也就是说一个<strong>深度为3</strong>的B+Tree 索引可以维护 10^3<em>10^3</em>10^3= <strong>1 亿条记录</strong>(这里假定一个数据页也存储10A3条行记录数据了)</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2~4 层。MySQL的lnnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多<strong>只需要 1~3 次磁盘IO操作</strong>（根节点被缓存，不算IO次数）</p>
<h2 id="红黑树">红黑树</h2>
<blockquote>
<p><strong>数据库为什么不用红黑树而用B+树？</strong></p>
<p>因为B+树是多叉，红黑树是二叉，B+树更矮胖，查询性能更高，IO次数更少。</p>
</blockquote>
<p><strong>红黑树：</strong> 近似平衡二叉树**，**左右子树高差有可能大于 1，查找效率略低于平衡二叉树，但增删效率高于平衡二叉树，适合频繁插入删除。</p>
<ul>
<li>结点非黑即红；</li>
<li>根结点是黑色，叶节点是黑色空节点（常省略）；</li>
<li>任何相邻节点不能同时为红色；</li>
<li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点；</li>
<li>查询性能稳定O(logN)，高度最高2log(n+1)；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725134328736.png" alt="image-20250725134328736"></p>
<hr>
<h1>存储引擎索引方案</h1>
<h2 id="innoDB的索引方案">innoDB的索引方案</h2>
<h3 id="聚簇索引">聚簇索引</h3>
<p>聚族索引并不是一种单独的索引类型，而是一种<strong>数据存储方式</strong>(基于主键映射目录和排序的B+树，所有的<strong>用户记录</strong>都存储在了<strong>叶子节点</strong>)，也就是所谓的<strong>索引即数据</strong>（因为<strong>记录</strong>就<strong>存</strong>在B+树<strong>叶节点</strong>），数据即索引。 图像参考前文<code>大目录嵌套多个小目录（3层B+树）</code></p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725130742930.png" alt="image-20250725130742930"></p>
<p><strong>特点：</strong></p>
<ol>
<li>
<p>使用记录<strong>主键值的大小</strong>进行各层之间的映射、层内的排序，这包括三个方面的含义：</p>
<ul>
<li>
<p><strong>页内的记录</strong>是按照主键的大小顺序排成一个<strong>单向链表</strong>。</p>
</li>
<li>
<p>各个存放用户<strong>记录</strong>的<strong>页</strong>也是<strong>根据</strong>页中用户记录的<strong>主键大小</strong>顺序排成一个<strong>双向链表</strong>。</p>
</li>
<li>
<p>存放<strong>目录</strong>项记录的页分为不同的层次，在同一层次中的<strong>页</strong>也是根据页中目录项记录的<strong>主键大小</strong>顺序排成一个<strong>双向链表</strong>。</p>
</li>
</ul>
</li>
<li>
<p>B+树的<strong>叶子节点</strong>存储的是<strong>完整的用户记录</strong>。</p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
<p><strong>优点：</strong></p>
<ul>
<li>
<p><strong>数据访问更</strong>快，因为聚簇索引将索引和数据保存在<strong>同一个B+树</strong>中，</p>
</li>
<li>
<p>因此从聚簇索引中获取数据比非聚簇索引更快</p>
</li>
<li>
<p>聚簇索引对于<strong>主键的排序查找和范围查找</strong>速度非常<strong>快</strong></p>
</li>
<li>
<p>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<strong>节省</strong>了大量的<strong>io</strong>操作。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>插入速度严重依赖于插入顺序</strong>，按照主键的<strong>顺序插入是最快</strong>的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增</strong>的ID列为<strong>主键</strong></li>
<li><strong>更新主键的代价很高</strong>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</li>
</ul>
</li>
</ol>
<h3 id="非聚簇索引（又称辅助索引、二级索引）">非聚簇索引（又称辅助索引、二级索引）</h3>
<p>聚簇索引基于主键映射目录和页内页间排序，查询条件为主键时才有用。想<strong>查第二列</strong>时，就得新创建一个B+树，也就是<strong>非聚簇索引B+树</strong>，它基于非主键列映射目录和排序，叶节点存非主键字段的值和主键字段的值。通过第二列查到了主键值，再<strong>回表</strong>（回到聚簇索引的表）根据主键值查完整记录。</p>
<p>非聚簇索引是一种<strong>数据存储方式</strong>(基于<strong>非主键字段</strong>映射目录和排序的B+树，<strong>叶节点存非主键字段的值和主键字段的值</strong>)。</p>
<blockquote>
<p><strong>注意：innoDB主键建议使用自增策略，从0开始。因为：</strong></p>
<ul>
<li>innoDB的主键不建议过长，因为每个二级索引都要存主键，主键过长会耗费磁盘空间和性能（每个数据页只能16KB，主键空间占多会导致每页存记录个数变少，导致B+树层级变深）；</li>
<li>B+树插入速度严重依赖于插入顺序，非单调主键会使B+树频繁分裂调整为自增顺序，性能变差。</li>
</ul>
</blockquote>
<p>实际中，一个MySQL表会有一个聚簇索引用于查主键或者回表，有多个非聚簇索引（辅助索引、二级索引）用于查非主键字段。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725131610248.png" alt="image-20250725131610248"></p>
<p><strong>为什么非聚簇索引B+树的叶节点不存完整记录，还要回表多此一举呢？</strong></p>
<p>如果表中有100列，那就需要99个非聚簇索引，要是都存完整记录，那就太浪费磁盘空间了。</p>
<h3 id="聚簇索引和非聚簇索引区别">聚簇索引和非聚簇索引区别</h3>
<ol>
<li><strong>叶节点：聚簇索引</strong>的 <strong>叶子节点</strong> 存储的就是我们的 <strong>数据记录</strong>，<strong>非聚簇索引</strong>的<strong>叶子节点</strong>存储的是 <strong>数据位置</strong> 。非聚簇索引不会影响数据表的物理存储顺序。</li>
<li><strong>数量：一个表</strong>只能有<strong>一个聚簇索引</strong>，因为只能有一种排序存储方式，但可有<strong>多个非聚簇索引</strong>，也就是多个索引目录提供数据检索。</li>
<li><strong>效率：<strong>使用</strong>聚簇索引</strong>的时候，数据的<strong>查询效率高</strong> ，但如果对数据进行<strong>插入，删除，更新</strong>等操作，效率会比非聚簇索引<strong>低</strong>。因为聚簇索引存的完整记录，移动起来慢；</li>
</ol>
<h3 id="联合索引">联合索引</h3>
<p>我们也可以同时以多个列的大小作为排序规则，也就是同时为<strong>多个列建立非聚簇索引</strong>。</p>
<p>比方说我们想让B+树按照c2和c3列的大小进行排序，这个包含两层含义：</p>
<ul>
<li>每个目录记录包括c2字段、c3字段、页码，每个用户记录包括c2字段、c3字段、主键；</li>
<li>先把各个记录和页按照<strong>c2列进行排序；</strong></li>
<li>在记录的<strong>c2列相同</strong>的情况下，采用<strong>c3列进行排序</strong></li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<p>以c2和c3列的大小为排序规则建立的B+树称为联合索引，<strong>本质上</strong>也是一个<strong>非聚簇索引</strong>。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li>建立<strong>联合索引</strong>只会建立如上图一样的<strong>1棵B+树</strong>。</li>
<li>为c2和c3列<strong>分别建立索引</strong>会分别以c2和c3列的大小为排序规则建立<strong>2棵B+树</strong>。</li>
</ul>
</blockquote>
<h2 id="MyISAM的索引方案">MyISAM的索引方案</h2>
<p>MyISAM引擎使用B+Tree 作为索引结构，<strong>叶子节点</strong>的data域<strong>存</strong>放的是待查询字段和数据记录的<strong>地址</strong>。</p>
<p>MyISAM引擎没有二级索引，只有聚簇索引。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725132544092.png" alt="image-20250725132544092"></p>
<h2 id="MyISAM-与-InnoDB对比">MyISAM 与 InnoDB对比</h2>
<p>MyISAM的索引方式都是非聚簇的，与InnoDB包含1个聚簇索引是不同的。</p>
<ol>
<li><strong>查找次数：<strong>在</strong>InnoDB</strong>存储引擎中，我们只需要根据主键值对聚簇索引进行<strong>一次查找</strong>就能找到对应的记录，其主键索引的叶子节点存储着行数据，而在<strong>MyISAM</strong> 中却需要进行一次<strong>回表</strong>操作，意味着MyISAM中建立的索引相当于全部都是二级索引，其索引的叶子节点存储的是行数据地址。</li>
<li>**是否索引即数据：**InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录地址。</li>
<li>**叶节点data域存储内容：**InnoDB的非聚簇索引data域存储相应记录主键的值，而MyISAM索引记录的是待查询字段和地址。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</li>
<li><strong>查询速度：MyISAM</strong>的<strong>回表</strong>操作是十分<strong>快速</strong>的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，获取主键之后再回表去聚簇索引里找记录，虽说也不慢，但比不上直接用地址去访问。</li>
<li>**是否必须有主键：**InnoDB要求表必须有主键（ MyISAM可以没有）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725132452862.png" alt="image-20250725132452862"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://southernfish.github.io">Southern Fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://southernfish.github.io/2025/07/24/database/db-mysql-2-engine/">https://southernfish.github.io/2025/07/24/database/db-mysql-2-engine/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://southernfish.github.io" target="_blank">Southern Fish</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="/img/article/article5.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/25/database/db-mysql-3-index/"><img class="prev-cover" src="/img/article/article1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL数据库-索引</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/24/database/db-mysql-1-conception/"><img class="next-cover" src="/img/article/article1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL数据库-概述</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/06/19/database/db-mysql-review/" title="数据库"><img class="cover" src="/img/article/article4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="title">数据库</div></div></a></div><div><a href="/2025/07/26/database/db-mysql-5-sharding/" title="MySQL数据库-表设计优化、读写分离与分库分表"><img class="cover" src="/img/article/article5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="title">MySQL数据库-表设计优化、读写分离与分库分表</div></div></a></div><div><a href="/2025/06/24/database/db-innodb/" title="InnoDB + MVCC"><img class="cover" src="/img/article/article3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-24</div><div class="title">InnoDB + MVCC</div></div></a></div><div><a href="/2025/07/25/database/db-mysql-3-index/" title="MySQL数据库-索引"><img class="cover" src="/img/article/article1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="title">MySQL数据库-索引</div></div></a></div><div><a href="/2025/07/26/database/db-mysql-6-query/" title="MySQL数据库-查询优化"><img class="cover" src="/img/article/article3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="title">MySQL数据库-查询优化</div></div></a></div><div><a href="/2025/07/24/database/db-mysql-1-conception/" title="MySQL数据库-概述"><img class="cover" src="/img/article/article1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-24</div><div class="title">MySQL数据库-概述</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southern Fish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SouthernFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1002721576@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">天下事岂能尽如吾意，心境须恰适，尽其在我，随遇而安。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E3%80%81%E8%AE%BE%E7%BD%AE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.</span> <span class="toc-text">查看、设置存储引擎的命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.2.</span> <span class="toc-text">MySQL 的常用引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.</span> <span class="toc-text">InnoDB引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">InnoDB 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.2.</span> <span class="toc-text">InnoDB 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.3.</span> <span class="toc-text">InnoDB 优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.4.</span> <span class="toc-text">InnoDB 事务的ACID特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.5.</span> <span class="toc-text">InnoDB 架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innoDB-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.6.</span> <span class="toc-text">innoDB 数据存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">页：数据库的基本存储单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">数据页的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">页结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E3%80%81%E9%A1%B5%E3%80%81%E5%8C%BA%E3%80%81%E6%AE%B5%E3%80%81%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">行、页、区、段、表空间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#innoDB-%E5%9B%9B%E7%A7%8D%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.6.5.</span> <span class="toc-text">innoDB 四种行格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.6.6.</span> <span class="toc-text">指定行格式的命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM-%E5%BC%95%E6%93%8E"><span class="toc-number">1.4.</span> <span class="toc-text">MyISAM 引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.1.</span> <span class="toc-text">MyISAM 引擎介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.2.</span> <span class="toc-text">MyISAM 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E5%AF%B9%E6%AF%94-MyISAM"><span class="toc-number">1.4.3.</span> <span class="toc-text">InnoDB 对比 MyISAM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BC%95%E6%93%8E"><span class="toc-number">1.5.</span> <span class="toc-text">其他引擎</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">2.3.</span> <span class="toc-text">索引的代价</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.4.1.</span> <span class="toc-text">B+树介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innoDB%E7%9A%84B-%E6%A0%91%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">2.4.2.</span> <span class="toc-text">innoDB的B+树聚簇索引，存储数据和目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.</span> <span class="toc-text">Hash结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.5.1.</span> <span class="toc-text">Hash结构介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innoDB%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">2.5.2.</span> <span class="toc-text">innoDB自适应的哈希索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-%E7%B4%A2%E5%BC%95%E4%B8%8E-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.3.</span> <span class="toc-text">Hash 索引与 B+ 树索引的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91"><span class="toc-number">2.6.</span> <span class="toc-text">B树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">2.6.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E5%92%8C-B-%E6%A0%91%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">2.6.2.</span> <span class="toc-text">B+ 树和 B 树的差异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.7.</span> <span class="toc-text">红黑树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">存储引擎索引方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#innoDB%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-number">3.1.</span> <span class="toc-text">innoDB的索引方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88%E5%8F%88%E7%A7%B0%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E3%80%81%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">非聚簇索引（又称辅助索引、二级索引）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.3.</span> <span class="toc-text">聚簇索引和非聚簇索引区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">3.1.4.</span> <span class="toc-text">联合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-number">3.2.</span> <span class="toc-text">MyISAM的索引方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM-%E4%B8%8E-InnoDB%E5%AF%B9%E6%AF%94"><span class="toc-number">3.3.</span> <span class="toc-text">MyISAM 与 InnoDB对比</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/27/java/java-coding-guidelines/" title="阿里规约"><img src="/img/article/article6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阿里规约"/></a><div class="content"><a class="title" href="/2025/07/27/java/java-coding-guidelines/" title="阿里规约">阿里规约</a><time datetime="2025-07-27T06:26:36.000Z" title="发表于 2025-07-27 14:26:36">2025-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/26/database/db-mysql-5-sharding/" title="MySQL数据库-表设计优化、读写分离与分库分表"><img src="/img/article/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL数据库-表设计优化、读写分离与分库分表"/></a><div class="content"><a class="title" href="/2025/07/26/database/db-mysql-5-sharding/" title="MySQL数据库-表设计优化、读写分离与分库分表">MySQL数据库-表设计优化、读写分离与分库分表</a><time datetime="2025-07-26T11:30:36.000Z" title="发表于 2025-07-26 19:30:36">2025-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/26/database/db-mysql-6-query/" title="MySQL数据库-查询优化"><img src="/img/article/article3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL数据库-查询优化"/></a><div class="content"><a class="title" href="/2025/07/26/database/db-mysql-6-query/" title="MySQL数据库-查询优化">MySQL数据库-查询优化</a><time datetime="2025-07-26T07:30:36.000Z" title="发表于 2025-07-26 15:30:36">2025-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/26/database/db-mysql-4-optimize/" title="MySQL数据库-优化"><img src="/img/article/article1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL数据库-优化"/></a><div class="content"><a class="title" href="/2025/07/26/database/db-mysql-4-optimize/" title="MySQL数据库-优化">MySQL数据库-优化</a><time datetime="2025-07-26T05:30:36.000Z" title="发表于 2025-07-26 13:30:36">2025-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/26/database/db-redis/" title="Redis"><img src="/img/article/article1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"/></a><div class="content"><a class="title" href="/2025/07/26/database/db-redis/" title="Redis">Redis</a><time datetime="2025-07-26T02:15:36.000Z" title="发表于 2025-07-26 10:15:36">2025-07-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/article/article5.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Southern Fish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>