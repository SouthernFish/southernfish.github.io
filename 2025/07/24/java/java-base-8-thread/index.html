<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>多线程 | Southern Fish</title><meta name="keywords" content="java基础"><meta name="author" content="Southern Fish"><meta name="copyright" content="Southern Fish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程">
<meta property="og:url" content="https://southernfish.github.io/2025/07/24/java/java-base-8-thread/index.html">
<meta property="og:site_name" content="Southern Fish">
<meta property="og:description" content="多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://southernfish.github.io/img/article/article3.png">
<meta property="article:published_time" content="2025-07-24T00:28:36.000Z">
<meta property="article:modified_time" content="2025-07-23T14:13:38.082Z">
<meta property="article:author" content="Southern Fish">
<meta property="article:tag" content="java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://southernfish.github.io/img/article/article3.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://southernfish.github.io/2025/07/24/java/java-base-8-thread/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '多线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-23 22:13:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Southern Fish" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/article/article3.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Southern Fish</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-24T00:28:36.000Z" title="发表于 2025-07-24 08:28:36">2025-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-23T14:13:38.082Z" title="更新于 2025-07-23 22:13:38">2025-07-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="多线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%80%E6%97%B6%E9%97%B4/3618565?fromModule=lemma_inlink">一时间</a>执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA/10375153?fromModule=lemma_inlink">对称多处理机</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%9A%E6%A0%B8%E5%BF%83/1013410?fromModule=lemma_inlink">多核心</a>处理器以及<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%8A%AF%E7%89%87%E7%BA%A7%E5%A4%9A%E5%A4%84%E7%90%86/924724?fromModule=lemma_inlink">芯片级多处理</a>或<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B/22689341?fromModule=lemma_inlink">同时多线程</a>处理器。在一个程序中，这些独立运行的程序片段叫作“<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fromModule=lemma_inlink">线程</a>”（Thread），利用它编程的概念就叫作“多线程处理” 。本文简单记录一些关于线程、多线程的问题。参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46154326/article/details/148100902">多线程下如何保证事务的一致性</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_53157173/article/details/127423286">Spring在多线程环境下如何确保事务一致性</a>、<a target="_blank" rel="noopener" href="https://www.51cto.com/article/768896.html">详解Spring多线程下如何保证事务的一致性</a>、参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/article/details/140324927">https://blog.csdn.net/qq_40991313/article/details/140324927</a></p>
<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><h2 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h2><p>并行：多个处理器或多核处理器同时处理多个任务。<br>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</p>
<h2 id="线程和进程的关系"><a href="#线程和进程的关系" class="headerlink" title="线程和进程的关系"></a>线程和进程的关系</h2><p><strong>进程</strong>：是操作系统分配资源的基本单位，有独立的地址空间（内存空间的一部分，用于存储进程中的代码、数据和堆栈等信息）和内存空间，进程之间不能共享资源，上下文切换慢，并发低，能独立执行（有程序入口、执行序列、出口），更健壮（因为进程崩溃后不会影响其他进程）。</p>
<p><strong>线程</strong>：是操作系统调度的基本单位，没有独立的地址空间和内存空间（只有自己的堆栈和局部变量，只能共享所在进程的内存空间），线程之间可以共享进程内的资源，上下文切换快，并发高，不能独立执行（应用程序控制多线程执行，进程通过管理线程优先级间接控制线程执行），不健壮（因为一个线程崩溃会导致整个进程崩溃）。</p>
<p><strong>关系</strong>：一个程序运行后至少包括一个进程，一个进程至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>
<blockquote>
<p>运行时数据区包括本地方法栈、虚拟机栈、方法区、堆、程序计数器。每个线程都有独自的本地方法栈、虚拟机栈、程序计数器。各线程共享进程的方法区和堆。</p>
<p><strong>JVM运行时数据区参考：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/article/details/134742377?spm=1001.2014.3001.5501">什么是JVM的内存模型？详细阐述Java中局部变量、常量、类名等信息在JVM中的存储位置_jvm中主要用于存储类的元数据(类型信息(类的描述信息 类的元数据))、静态变量、常-CSDN博客</a></p>
</blockquote>
<h2 id="线程状态（state）"><a href="#线程状态（state）" class="headerlink" title="线程状态（state）"></a>线程状态（state）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEW 线程创建但尚未启动</span><br><span class="line">RUNNABLE 就绪或者正在执行中</span><br><span class="line">BLOCKED 阻塞的（被同步锁或者IO锁阻塞），等待获取锁</span><br><span class="line">WAITING 永久等待状态，等待其他线程唤醒（如wait()）</span><br><span class="line">TIMED_WAITING 等待指定的时间重新被唤醒的状态，定时等待（如sleep(long)）</span><br><span class="line">TERMINATED 线程执行完成</span><br></pre></td></tr></table></figure>

<h2 id="守护线程（Daemon-Thread）"><a href="#守护线程（Daemon-Thread）" class="headerlink" title="守护线程（Daemon Thread）"></a>守护线程（Daemon Thread）</h2><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p>
<ul>
<li><strong>作用</strong>：为其他线程提供服务（如垃圾回收线程）</li>
<li><strong>特性</strong>：当所有非守护线程结束时，守护线程自动终止。</li>
<li><strong>设置</strong>：thread.setDaemon(true)必须在start()前调用</li>
</ul>
<h2 id="中断（Interruption）"><a href="#中断（Interruption）" class="headerlink" title="中断（Interruption）"></a>中断（Interruption）</h2><ul>
<li><p><strong>作用</strong>：通知线程应该终止，但线程可选择忽略。</p>
</li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><p><code>thread.interrupt()</code>：中断线程。</p>
</li>
<li><p><code>Thread.interrupted()</code>：检查并清除中断状态。 </p>
</li>
<li><p><code>thread.isInterrupted()</code>：检查中断状态。</p>
</li>
</ul>
</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>一个程序运行后至少包括一个进程，一个进程至少有一个线程，一个进程下有多个线程并发地处理任务，称为多线程。</p>
<p><strong>多线程的好处：</strong>当一个线程进入阻塞或者等待状态时，其他的线程可以获取CPU的执行权，提高了CPU的利用率。</p>
<p><strong>多线程的缺点：</strong></p>
<ul>
<li><strong>死锁</strong>：多个进程或线程相互等待对方释放所持有的资源，从而无法继续执行的情况。若无外力作用，它们都将无法推进下去。死锁用占用CPU、内存等系统资源，导致资源浪费，死锁会导致程序无法正常退出，导致系统性能差。</li>
<li><strong>上下文频繁切换</strong>：频繁的上下文切换可能会造成资源的浪费；</li>
<li><strong>串行</strong>：如果因为资源的限制，多线程串行执行，可能速度会比单线程更慢。</li>
</ul>
<p> <strong>线程的优先级</strong>：java是抢占式调度模型，每一个 Java 线程都有一个优先级，优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p>
<blockquote>
<p><strong>注意</strong>：优先级高的线程只是获取CPU时间片的几率高，但并不能保证先执行。</p>
</blockquote>
<h2 id="ThreadLocal-及使用场景"><a href="#ThreadLocal-及使用场景" class="headerlink" title="ThreadLocal 及使用场景"></a>ThreadLocal 及使用场景</h2><p><code>ThreadLocal</code> 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p>
<p><code>TransactionSynchronizationManager</code>类内部默认提供了下面六个ThreadLocal属性，分别保存当前线程对应的不同事务资源:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存当前事务关联的资源</span></span><br><span class="line"><span class="comment">// 默认只会在新建事务的时候保存当前获取到的DataSource和当前事务对应Connection的映射关系</span></span><br><span class="line"><span class="comment">// 这里Connection被包装为了ConnectionHolder</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Transactional resources&quot;</span>);</span><br><span class="line"><span class="comment">// 事务监听者</span></span><br><span class="line"><span class="comment">// 在事务执行到某个阶段的过程中，会去回调监听者对应的回调接口(典型观察者模式的应用)</span></span><br><span class="line"><span class="comment">// 默认为空集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Transaction synchronizations&quot;</span>);</span><br><span class="line"><span class="comment">// 存放当前事务名字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Current transaction name&quot;</span>);</span><br><span class="line"><span class="comment">// 存放当前事务是否是只读事务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Current transaction read-only status&quot;</span>);</span><br><span class="line"><span class="comment">// 存放当前事务的隔离级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Current transaction isolation level&quot;</span>);</span><br><span class="line"><span class="comment">// 存放当前事务是否处于激活状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Actual transaction active&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="需要多线程的业务场景"><a href="#需要多线程的业务场景" class="headerlink" title="需要多线程的业务场景"></a>需要多线程的业务场景</h2><table>
<thead>
<tr>
<th align="center"></th>
<th>场景</th>
<th>实现</th>
<th>优势或示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">高并发Web服务器</td>
<td>处理大量HTTP请求，每个请求独立处理</td>
<td>使用线程池处理请求，避免频繁创建线程</td>
<td>示例：Tomcat、Netty等服务器的线程模型。</td>
</tr>
<tr>
<td align="center">批处理任务</td>
<td>批量处理大量数据（如ETL作业）</td>
<td>将数据分片，每个线程处理一部分数据</td>
<td><strong>优势</strong>：显著提高处理速度</td>
</tr>
<tr>
<td align="center">异步IO操作</td>
<td>文件读写、网络通信等IO密集型操作</td>
<td>使用异步线程执行IO操作，主线程继续处理其他任务</td>
<td>示例：数据库查询、HTTP请求调用</td>
</tr>
<tr>
<td align="center">定时任务调度</td>
<td>定期执行任务（如数据备份、统计报表生成）</td>
<td>使用<code>ScheduledExecutorService</code>或Spring的<code>@Scheduled</code>注解</td>
<td>示例：每天凌晨执行数据同步任务</td>
</tr>
<tr>
<td align="center">实时数据处理</td>
<td>实时分析数据流（如日志分析、监控数据处理）</td>
<td>使用多线程并行处理数据流</td>
<td>示例：电商平台实时计算商品销量排行</td>
</tr>
<tr>
<td align="center">图形界面应用</td>
<td>保持UI响应性的同时执行耗时操作</td>
<td>将耗时操作放在后台线程执行</td>
<td>示例：文件下载进度显示、复杂计算</td>
</tr>
<tr>
<td align="center">分布式缓存更新</td>
<td>缓存失效时，异步更新缓存数据</td>
<td>使用后台线程重新加载数据到缓存</td>
<td><strong>优势</strong>：避免用户请求等待缓存更新</td>
</tr>
<tr>
<td align="center">消息队列消费者</td>
<td>从消息队列（如Kafka、RabbitMQ）消费消息</td>
<td>多线程并行消费，提高吞吐量</td>
<td>示例：订单处理、日志收集</td>
</tr>
<tr>
<td align="center">搜索引擎索引构建</td>
<td>构建大规模索引（如Elasticsearch索引）</td>
<td>多线程并行处理文档，加速索引构建</td>
<td><strong>优势</strong>：缩短索引构建时间，提高搜索服务可用性</td>
</tr>
<tr>
<td align="center">游戏服务器</td>
<td>处理多个玩家的并发操作</td>
<td>每个玩家会话由独立线程处理</td>
<td>示例：多人在线游戏的服务器端逻辑</td>
</tr>
</tbody></table>
<hr>
<h1 id="创建线程方法"><a href="#创建线程方法" class="headerlink" title="创建线程方法"></a>创建线程方法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>创建线程有4种方式：</p>
<ul>
<li> <strong>继承Thread类：</strong>继承Thread类，重写run()方法；然后创建线程对象调用start()方法开启线程。start()方法里包括了run()方法，用于开启线程。注意如果直接调用run()方法的话，将是普通方法调用，无法起到开启线程的效果</li>
<li><strong>实现Runnable接口：</strong>实现Runnable接口并重写run()方法，将实现类作为构造参数创建Thread对象。推荐，因为Java是单继承，线程类实现接口的同时，还可以继承其他类实现其他接口。</li>
<li><strong>实现Callable：</strong>实现Callable<T>接口，重写带返回值的call()方法；将实现类对象作为构造参数创建FutureTask<T>对象；将FutureTask对象作为构造参数创建Thread对象。所以此方法可以获取线程执行完后的返回值，而前两种方式不能。</li>
<li><strong>ExecutorService的submit或execute方法：</strong>execute和submit都是ExecutorService接口的方法，用于线程池提交任务。所有线程池都直接或间接实现ExecutorService接口。<ul>
<li><strong>execute：</strong>参数只能是Runnable，没有返回值</li>
<li><strong>submit：</strong>参数可以是Runnable、Callable，返回值是FutureTask</li>
</ul>
</li>
</ul>
<h2 id="方法1：继承Thread类"><a href="#方法1：继承Thread类" class="headerlink" title="方法1：继承Thread类"></a>方法1：继承Thread类</h2><p><strong>创建并启动线程的步骤：</strong> </p>
<ol>
<li>创建一个继承了 Thread类的线程类，重写的run()方法是线程执行体。</li>
<li>创建这个类的对象。</li>
<li>调用线程对象的start()方法来启动该线程（之后Java虚拟机会调用该线程run方法）。</li>
</ol>
<p><strong>run()和start()区别：</strong></p>
<ul>
<li><strong>run()：</strong>封装线程执行的代码，直接调用相当于普通方法的调用。</li>
<li><strong>start()：</strong>启动线程，虚拟机<strong>调用</strong>该线程的**run()**方法。</li>
</ul>
<p><strong>构造方法：</strong></p>
<ul>
<li><strong>Thread():</strong> 创建一个新的线程对象。</li>
<li><strong>Thread(String name):</strong> 创建一个新的线程对象并将其名称设置为指定的名称。</li>
<li><strong>Thread(Runnable target):</strong> 创建一个新的线程对象并将其目标设置为指定的 Runnable 对象。主要用于后面通过Runable接口创建线程。</li>
<li><strong>Thread(Runnable target, String name):</strong> 创建一个新的线程对象，将其目标设置为指定的 Runnable 对象，并将其名称设置为指定的名称。</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li><strong>void start():</strong> 使线程开始执行；Java 虚拟机调用此线程的 run 方法。</li>
<li><strong>void run():</strong> 如果此线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，此方法不执行任何操作并返回。</li>
<li>**void join():**等待该线程执行完成。A线程调用B线程的join()方法，A线程将被阻塞，直到B线程执行完。可以用于线程之间的通信。</li>
<li>void join(long millis): 等待该线程终止的时间最长为 millis 毫秒。</li>
<li>void join(long millis, int nanos): 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。</li>
<li><strong>void interrupt():</strong> 中断该线程。</li>
<li>boolean isInterrupted(): 测试当前线程是否已中断。</li>
<li><strong>boolean isAlive():</strong> 测试线程是否处于活动状态。</li>
<li><strong>static void sleep(long millis):</strong> 使当前正在执行的线程休眠（暂停执行）指定的毫秒数。</li>
<li>static void sleep(long millis, int nanos): 使当前正在执行的线程休眠（暂停执行）指定的毫秒数加指定的纳秒数。</li>
</ul>
<p><strong>属性方法：</strong></p>
<ul>
<li><strong>void setName(String name):</strong> 改变线程名称，使之与参数 name 相同。</li>
<li><strong>String getName():</strong> 返回该线程的名称。</li>
<li><strong>void setPriority(int newPriority):</strong> 更改该线程的优先级。</li>
<li><strong>int getPriority():</strong> 返回该线程的优先级。</li>
<li><strong>Thread.State getState():</strong> 返回该线程的状态。</li>
<li><strong>void setDaemon(boolean on):</strong> 将该线程标记为守护线程或用户线程。</li>
<li><strong>boolean isDaemon():</strong> 测试该线程是否为守护线程。用户线程是普通的线程，它们通常是应用程序执行任务的主要线程。守护线程为其他线程提供后台支持。当所有用户线程结束时，JVM 会自动退出，无论守护线程是否仍在运行。</li>
</ul>
<p><strong>代码示例</strong>：<strong>继承 Thread 重写 run 方法：</strong>代码简单，但该类无法集成别的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程执行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码时间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.主线程设置名字并查看</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建并启动线程</span></span><br><span class="line"><span class="comment">// 线程类：打印数字线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNumberThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 打印1-100</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造方法 @param name 线程名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintNumberThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建并启动线程 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNumberThread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumberThread</span> (<span class="string">&quot;a&quot;</span>), b = <span class="keyword">new</span> <span class="title class_">PrintNumberThread</span> (<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 两个线程是随机交替打印的，因为它们获取CPU的调度是随机的</span></span><br></pre></td></tr></table></figure>

<h2 id="方法2：实现-Runnable-接口"><a href="#方法2：实现-Runnable-接口" class="headerlink" title="方法2：实现 Runnable 接口"></a>方法2：实现 Runnable 接口</h2><p><strong>步骤：</strong> </p>
<ol>
<li>定义Runnable接口的实现类，并实现该接口的run()方法，该方法将作为线程执行体。</li>
<li>创建Runnable实现类的实例，并将其作为参数来创建Thread对象，Thread对象为线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ol>
<p><strong>这种办法更好，优点：</strong></p>
<ul>
<li><strong>避免Java 单继承局限性：</strong>Java是单继承，使用这种方法，线程类实现接口的同时，还可以继承其他类、实现其他接口。</li>
<li><strong>逻辑和数据更好分离：</strong>通过实现 Runnable 接口的方法创建多线程更加适合<strong>同一个资源被多段业务逻辑并行处理</strong>的场景。在同一个资源被多个线程逻辑异步、并行处理的场景中，通过实现 Runnable 接口的方式设计多个 target 执行目标类可以更加方便、清晰地将执行逻辑和数据存储分离，更好地体现了面向对象的设计思想。</li>
</ul>
<p><strong>代码示例</strong>：<strong>实现 Runnable 接口：</strong>继承其他类；同一实现该接口的实例可以共享资源。但代码复杂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程执行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码实践</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印数字Runnable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNumberRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方法1：使用普通方式实现Runnable接口</span></span><br><span class="line">        <span class="type">PrintNumberRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumberRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;a&quot;</span>), b = <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// 方法2：使用Lambda表达式实现Runnable接口，无需再创建PrintNumberRunnable类</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        d.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法3：实现-Callable接口"><a href="#方法3：实现-Callable接口" class="headerlink" title="方法3：实现 Callable接口"></a>方法3：实现 Callable接口</h2><p>通过<strong>实现Callable接口</strong>来创建线程的步骤如下</p>
<ul>
<li>实现Callable<T>接口，重写带返回值的call()方法；</li>
<li>将实现类对象作为构造参数创建FutureTask<T>对象；</li>
<li>将FutureTask对象作为构造参数创建Thread对象。</li>
</ul>
<p>相比于前两种方法，此方法可以<strong>获取线程执行完后的返回值</strong>，而前两种方式不能，因为call()方法是有返回值的。 </p>
<p><strong>代码示例</strong>：<strong>实现 Callable 接口：</strong>可以获得异步任务的返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">FutureTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br></pre></td></tr></table></figure>

<p><strong>代码实践</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;执行结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法4：线程池"><a href="#方法4：线程池" class="headerlink" title="方法4：线程池"></a>方法4：线程池</h2><p>线程池（Thread Pool）是一种多线程处理方式，用于减少创建和销毁线程的开销，提高系统资源利用率和处理效率。</p>
<p><strong>线程池作用：</strong> </p>
<ul>
<li><strong>管理线程数量：</strong>它可以管理线程的数量，可以避免无节制的创建线程，导致超出系统负荷直至崩溃。</li>
<li><strong>让线程复用：</strong>它还可以让线程复用，可以大大地减少创建和销毁线程所带来的开销。</li>
</ul>
<p><strong>线程池的两种创建方法：</strong></p>
<ul>
<li>执行器工具类Executors；</li>
<li>自定义线程池ThreadPoolExecutor </li>
</ul>
<p><strong>线程池两种提交任务的方法</strong>：</p>
<p>execute和submit都是ExecutorService接口的方法，用于线程池提交任务。所有线程池都直接或间接实现ExecutorService接口。</p>
<ul>
<li><strong>execute</strong>：参数只能是Runnable，没有返回值</li>
<li><strong>submit</strong>：参数可以是Runnable、Callable，返回值是FutureTask </li>
</ul>
<p><strong>代码示例</strong>：<strong>两种创建线程池的方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池工具类，创建固定大小的线程池：</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程&quot;</span>+Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 自定义线程池:实现自动化装配，易于管理，循环利用资源。</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>( </span><br><span class="line">    <span class="number">5</span>,                                        <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="number">200</span>,                                    <span class="comment">// 最大线程数量，控制资源并发</span></span><br><span class="line">    <span class="number">10</span>,                                        <span class="comment">// 存活时间</span></span><br><span class="line">    TimeUnit.SECONDS,                        <span class="comment">// 时间单位</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(  <span class="number">100000</span>),    <span class="comment">// 任务队列，大小100000个</span></span><br><span class="line">Executors.defaultThreadFactory(),            <span class="comment">// 线程的创建工厂</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());        <span class="comment">// 拒绝策略</span></span><br><span class="line"><span class="comment">// 任务1</span></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--helloWorld_001--&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>参数作用 ：</p>
<ul>
<li><code>corePoolSize</code>：线程池的基本大小，当<strong>提交的任务数小于此值时，直接创建新线程</strong>执行任务。 </li>
<li><code>maximumPoolSize</code>：线程池允许的最大线程数，当<strong>任务队列满且线程数小于此值时，会创建新线程</strong>。 </li>
<li><code>keepAliveTime</code>：当<strong>线程数大于核心线程数</strong>时，多余的<strong>空闲线程在终止前等待新任务的最长时间</strong>。 </li>
<li><code>workQueue</code>：用于<strong>保存等待执行的任务的阻塞队列</strong>，常见类型有： <ul>
<li><code>ArrayBlockingQueue</code>：有界队列</li>
<li><code>LinkedBlockingQueue</code>：无界队列（需注意<code>OOM</code>风险） </li>
<li><code>SynchronousQueue</code>：直接提交队列   </li>
</ul>
</li>
<li><code>threadFactory</code>：创建线程的工厂，可自定义线程名称、优先级等。 </li>
<li><code>handler</code>：当<strong>任务队列和线程池都满时的拒绝策略</strong>，默认有四种： <ul>
<li><code>AbortPolicy</code>：直接抛出异常（默认）</li>
<li><code>CallerRunsPolicy</code>：由调用线程处理任务</li>
<li><code>DiscardPolicy</code>：丢弃最新的任务</li>
<li><code>DiscardOldestPolicy</code>：丢弃最老的任务</li>
</ul>
</li>
</ul>
<hr>
<h1 id="知识加油站"><a href="#知识加油站" class="headerlink" title="知识加油站"></a>知识加油站</h1><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>Java线程在运行的生命周期中,在任意给定的时刻,只能处于下列6种状态之一：</p>
<ul>
<li><strong>NEW ：初始状态</strong>，线程被创建，但是还没有调用start方法。</li>
<li><strong>RUNNABLE：可运行状态</strong>，等待调度或运行。线程正在JVM中执行，但是有可能在等待操作系统的调度。</li>
<li><strong>BLOCKED ：阻塞状态</strong>，线程正在等待获取监视器锁。</li>
<li><strong>WAITING ：等待状态</strong>，线程正在等待其他线程的通知或中断。线程等待状态不占用 CPU 资源，被唤醒后进入可运行状态（等待调度或运行）。</li>
<li><strong>TIMED_WAITING：超时等待状态</strong>，在WAITING的基础上增加了超时时间，即超出时间自动返回。<code>Thread.sleep(1000);</code>让线程超时等待1s。</li>
<li><strong>TERMINATED：终止状态</strong>，线程已经执行完毕。</li>
</ul>
<p><strong>线程的运行过程：</strong></p>
<p>线程在创建之后默认为NEW（初始状态），在调用start方法之后进入RUNNABLE（可运行状态）。</p>
<blockquote>
<p><strong>注意：</strong>可运行状态不代表线程正在运行，它有可能正在等待操作系统的调度。</p>
</blockquote>
<p>WAITING （等待状态）的线程需要其他线程的通知才能返回到可运行状态，而TIMED_WAITING（超时等待状态）相当于在等待状态的基础上增加了超时限制，除了他线程的唤醒，在超时时间到达时也会返回运行状态。</p>
<p>此外，线程在执行同步方法时，在没有获取到锁的情况下，会进入到BLOCKED（阻塞状态）。线程在执行完run方法之后，会进入到TERMINATED（终止状态）。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250723122520457.png" alt="image-20250723122520457"></p>
<blockquote>
<p> <strong>等待状态如何被唤醒</strong></p>
<p> Object类：</p>
<ul>
<li>wait()方法让线程进入等待状态</li>
<li>notify()唤醒该对象上的随机一个线程</li>
<li>notifyAll()唤醒该对象上的所有线程。</li>
</ul>
<p> 这3个方法必须处于<strong>synchronized</strong>代码块或方法中，否则会抛出<code>IllegalMonitorStateException</code>异常。因为调用这三个方法之前必须拿要到当前锁对象的监视器（Monitor对象），synchronized基于对象头和Monitor对象。</p>
<p> 另外，也可以通过<strong>Condition类的 await/signal/signalAll</strong>方法实现线程的等待和唤醒，从而实现线程的通信，令线程之间协作处理任务。这两个方法依赖于Lock对象。</p>
<p> <strong>notify() 和 notifyAll() 的区别</strong></p>
<p> <code>notifyAll()</code>会唤醒所有的线程，<code>notify()</code>之后唤醒一个线程。<br> notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 <code>notify()</code>只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>
<p> <strong>sleep() 和 wait() 的区别</strong></p>
<ul>
<li><strong>类的不同：</strong>sleep() 来自 Thread，wait() 来自 Object。</li>
<li><strong>释放锁：</strong>sleep() 不释放锁；wait() 释放锁。</li>
<li><strong>用法不同：</strong>sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll() 直接唤醒。</li>
</ul>
</blockquote>
<h2 id="线程的通信方式"><a href="#线程的通信方式" class="headerlink" title="线程的通信方式"></a>线程的通信方式</h2><p><strong>线程通信：</strong>用于多个线程之间协作工作，共同完成某个任务<strong>。</strong>多个线程在并发执行的时候，他们在CPU中是随机切换执行的，想多个线程一起来完成一件任务，就需要线程之间的通信。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250723122705785.png" alt="image-20250723122705785"></p>
<p><strong>线程通信方式：</strong> </p>
<ul>
<li><strong>通过 volatile 关键字：</strong>多个线程同时监听一个volatile变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。利用了volatile可见性，即一旦修改变量则立即刷新到共享内存中。</li>
<li><strong>通过Object类的 wait/notify/notifyAll 方法：</strong>当我们使用synchronized同步时就会使用Monitor来实现线程通信，这里的Monitor其实就是锁对象，其利用Object类的wait，notify，notifyAll等方法来实现线程通信。Monitor是Java虚拟机实现锁的一种底层机制，用于控制线程对共享资源的访问。</li>
<li><strong>通过Condition类的 await/signal 方法：</strong>而使用Lock进行同步时就是使用Condition对象来实现线程通信，Condition对象通过Lock的lock.newCondition()方法创建，使用其await，sign或signAll方法实现线程通信。Condition 是一个与锁 Lock 相关联的条件对象，可以让等待线程在某个条件被满足时被唤醒，从而达到线程协作的目的。</li>
<li><strong>通过Semaphore的acquire/release方法：</strong> Semaphore是一个计数信号量，用于控制同时访问某个资源的线程数量。线程可以通过acquire()方法获取许可，release()方法释放许可。</li>
<li><strong>通过Thread类的join()方法：</strong>join() 方法等待该线程执行完成。A线程调用B线程的join()方法，A线程将被阻塞，直到B线程执行完。</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li><p><strong>线程交替打印：</strong>在多线程交替打印A/B、或者交替打印1到100时，需要在锁中使用线程通信。如果不使用lock.notify()和lock.wait()，可能导致当前线程释放锁后立刻又拿回锁（因为多线程是CPU随机切换的），从而达不到交替打印的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个线程，例如打印A</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 1.临界值校验：到临界值唤醒其他线程，防止其他线程永远等待；</span></span><br><span class="line">                    <span class="comment">// 2.打印判断：如果需要打印，则打印、操作原子类。 </span></span><br><span class="line">                        <span class="comment">// 如果用的当前行值原子类，则加1；如果用的总行数原子类，则减1</span></span><br><span class="line">                    <span class="comment">// 4.线程通信：唤醒、等待。</span></span><br><span class="line">                    <span class="comment">// 如果删除下面两行代码，可能导致当前线程释放锁后立刻又拿到锁了，从而达不到交替打印的效果</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span>-<span class="keyword">catch</span>&#123; lock.wait(); &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">).start();</span><br><span class="line"><span class="comment">//另一个线程，例如打印B...</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>为了对多线程进行统一的管理，Java引入了线程池，它通过限制并发线程的数量、将待执行的线程放入队列、销毁空闲线程，来控制资源消耗，使线程更合理地运行，避免系统因为创建过多线程而崩溃。</p>
<p><strong>线程池作用：</strong> </p>
<ul>
<li><strong>管理线程数量：</strong>它可管理线程的数量，可避免无节制的销毁、创建线程，导致额外的性能损耗、或线程数超出系统负荷直至崩溃。</li>
<li><strong>提高性能：</strong>当有新任务到来时，可直接从线程池中取出一个空闲线程来执行任务，而不需要等待创建新线程，从而减少了响应时间。</li>
<li><strong>让线程复用：</strong>它还可以让线程复用，可以大大地减少创建和销毁线程所带来的开销。</li>
<li><strong>合理的拒绝策略</strong>：线程池提供了多种拒绝策略，当线程池队列满了时，可采用不同的策略进行处理，如抛出异常、丢弃任务或调用者运行等。</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>通常线程池的生命周期包含5个状态，对应状态值分别是：-1、0、1、2、3，这些状态只能由小到大迁移，不可逆。</p>
<ol>
<li><strong>RUNNING：运行。</strong>线程池处于正常状态，可以接受新的任务，同时会按照预设的策略来处理已有任务的执行。</li>
<li><strong>SHUTDOWN：关闭。</strong>线程池处于关闭状态，不再接受新的任务，但是会<strong>继续执行</strong>已有任务直到执行完成。执行线程池对象的shutdown()时进入该状态。</li>
<li><strong>STOP：停止。</strong>线程池处于关闭状态，不再接受新的任务，同时会<strong>中断</strong>正在执行的任务，<strong>清空</strong>线程队列。执行shutdownNow()时进入该状态。</li>
<li><strong>TIDYING：整理。</strong>所有任务已经执行完毕，线程池进入该状态会开始进行一些结尾工作，比如及时清理线程池的一些资源。</li>
<li><strong>TERMINATED：终止。</strong>线程池已经完全停止，所有的状态都已经结束了，线程池处于最终的状态。</li>
</ol>
<h3 id="创建线程池的方式1：线程池工具类"><a href="#创建线程池的方式1：线程池工具类" class="headerlink" title="创建线程池的方式1：线程池工具类"></a>创建线程池的方式1：线程池工具类</h3><p><strong>执行器工具类Executors创建线程池：</strong> 底层都是return new ThreadPoolExecutor(…)。一般不使用这种方式，参数配置死了不可控。</p>
<ul>
<li>**newCachedThreadPool()**：缓存线程池（无限大）。一种用来处理大量短时间工作任务的线程池。<ul>
<li><strong>核心线程数是0，最大线程数无限大：</strong>最大线程数<code>Integer.MAX_VALUE</code>。线程数量可以无限扩大，所有线程都是非核心线程。</li>
<li><strong>空闲线程存活时间60s：</strong>keepAliveTime为60S，空闲线程超过60s会被杀死。</li>
<li><strong>同步队列：</strong>因为最大线程数无限大，所以也用不到阻塞队列，所以设为没有存储空间的SynchronousQueue同步队列。它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程。这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。</li>
</ul>
</li>
<li><strong>newFixedThreadPool(int nThreads)：固定大小的线程池。</strong>重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。<ul>
<li><strong>核心线程数：</strong>所有线程都是核心线程（通过构造参数指定），最大线程数=核心线程数。</li>
<li><strong>存活时间0s：</strong>因为所有线程都是核心线程，所以用不到存活时间，线程都会一直存活。<code>keepAliveTime</code>为0S。</li>
<li><strong>链表阻塞队列：</strong>超出的线程会在<code>LinkedBlockingQueue</code>队列中等待空闲线程出现。即若有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads</li>
</ul>
</li>
<li><strong>newScheduledThreadPool(int corePoolSize)：定时任务线程池。</strong>创建定长线程池， 支持定时及周期性任务执行。可指定核心线程数，最大线程数。和 <code>newSingleThreadScheduledExecutor()</code> 类似，创建的是个 <code>ScheduledExecutorService</code>，区别在于单一工作线程还是多个工作线程。</li>
<li><strong>newSingleThreadExecutor()：单线程化的线程池。</strong>核心线程数与最大线程数都只有一个，操作一个无界的工作队列，不回收。后台从<code>LinkedBlockingQueue</code>队列中获取任务。创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务， 保证所有任务按照指定顺序（<code>FIFO, LIFO, 优先级</code>）执行。 </li>
<li><strong>newWorkStealingPool(int parallelism)：</strong>这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li>
<li><strong>ThreadPoolExecutor()：</strong>是最原始的线程池创建，上面的创建方式几乎都是对 ThreadPoolExecutor 的封装。（最核心）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//源码</span></span><br><span class="line">FixedThredPool: <span class="keyword">new</span> <span class="title class_">ThreadExcutor</span>(n, n, <span class="number">0L</span>, ms, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runable&gt;()</span><br><span class="line">SingleThreadExecutor: <span class="keyword">new</span> <span class="title class_">ThreadExcutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, ms, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runable&gt;())</span><br><span class="line">CachedTheadPool: <span class="keyword">new</span> <span class="title class_">ThreadExcutor</span>(<span class="number">0</span>, max_valuem, <span class="number">60L</span>, s, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">ScheduledThreadPoolExcutor: ScheduledThreadPool, SingleThreadScheduledExecutor.</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>： 一般要搭配计数器<code>CountDownLatch，await(时间)</code>让主线程等待，直到任务线程都执行完（计数器减为零），或者到达超时时间，防止无线等待。</p>
</blockquote>
<h3 id="创建线程池的方式2：自定义线程池（推荐）"><a href="#创建线程池的方式2：自定义线程池（推荐）" class="headerlink" title="创建线程池的方式2：自定义线程池（推荐）"></a>创建线程池的方式2：<strong>自定义线程池（推荐）</strong></h3><p><strong>线程池执行器ThreadPoolExecutor创建自定义线程池：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>( </span><br><span class="line">         <span class="number">5</span>,                                        <span class="comment">// 核心线程数</span></span><br><span class="line">         <span class="number">200</span>,                                    <span class="comment">// 最大线程数量，控制资源并发</span></span><br><span class="line">         <span class="number">10</span>,                                    <span class="comment">// 存活时间</span></span><br><span class="line">        TimeUnit.SECONDS,                       <span class="comment">// 时间单位</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(  <span class="number">100000</span>),    <span class="comment">// 任务队列，大小100000个</span></span><br><span class="line">Executors.defaultThreadFactory(),                <span class="comment">// 线程的创建工厂</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());            <span class="comment">// 拒绝策略</span></span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;    <span class="comment">// 开启异步编排，有返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;, threadPoolExecutor).thenApplyAsync(res -&gt; &#123;    <span class="comment">// 串行化，接收参数并有返回值</span></span><br><span class="line">    <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">&#125;, threadPoolExecutor);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> future.get();    <span class="comment">// 获取返回值</span></span><br></pre></td></tr></table></figure>

<p><strong>七个参数：</strong></p>
<ul>
<li><p><strong>corePoolSize：核心线程数</strong>。创建以后，会一直存活到线程池销毁，空闲时也不销毁。</p>
</li>
<li><p><strong>maximumPoolSize：最大线程数量</strong>。阻塞队列满了</p>
</li>
<li><p><strong>keepAliveTime： 存活时间</strong>。释放空闲时间超过“存活时间”的线程，仅留核心线程数量的线程。</p>
</li>
<li><p><strong>TimeUnitunit：时间单位</strong></p>
</li>
<li><p><strong>workQueue： 任务队列。</strong>如果线程数超过核心数量，就把剩余的任务放到队列里。只要有线程空闲，就会去队列取出新的任务执行。new LinkedBlockingDeque()队列大小默认是Integer的最大值，内存不够，所以建议指定队列大小。</p>
<ul>
<li><p>SynchronousQueue是一个同步队列，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。</p>
</li>
<li><p><strong>LinkedBlockingQueue</strong>是一个无界队列，可以缓存无限多的任务。由于其无界特性，因此需要合理地处理好任务的生产速率和线程池中线程的数量，以避免内存溢出等异常问题。无限缓存，拒绝策略就能随意了。</p>
</li>
<li><p><strong>ArrayBlockingQueue</strong>是一个有界（容量固定）队列，只能缓存固定数量的任务。通过固定队列容量，可以避免任务过多导致线程阻塞，保证线程池资源的可控性和稳定性。<strong>推荐</strong>，有界队列能增加系统的稳定性和预警能力。可以根据需要设大一点，比如几千，新任务丢弃后未来重新入队。</p>
</li>
<li><p>PriorityBlockingQueue是一个优先级队列，能够对任务按照优先级进行排序，当任务数量超过队列容量时，会根据元素的Comparable或Comparator排序规则进行丢弃或抛异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>&lt;&gt;((o1, o2) -&gt; o1.length() - o2.length());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>threadFactory：线程的创建工厂</strong>。可以使用默认的线程工厂Executors.defaultThreadFactory()，也可以自定义线程工厂（实现ThreadFactory接口）</p>
</li>
<li><p><strong>RejectedExecutionHandler handler：拒绝策略。</strong>如果任务队列和最大线程数量满了，按照指定的拒绝策略执行任务。</p>
<ul>
<li><strong>Abort（默认）：</strong>直接抛异常（拒绝执行异常RejectedExecutionException）</li>
<li><strong>CallerRuns：</strong>直接同步调用线程run()方法，不创建线程了</li>
<li><strong>DiscardOldest：</strong>丢弃最老任务</li>
<li><strong>Discard：</strong>直接丢弃新任务</li>
<li>实现拒绝执行处理器接口（RejectedExecutionHandler），自定义拒绝策略。</li>
</ul>
</li>
</ul>
<h3 id="如何为线程池设置合适的线程数"><a href="#如何为线程池设置合适的线程数" class="headerlink" title="如何为线程池设置合适的线程数"></a>如何为线程池设置合适的线程数</h3><p>下面的参数只是一个预估值，适合初步设置，具体的线程数需要经过压测确定，压榨（更好的利用）CPU的性能。</p>
<p><strong>CPU核心数为N；</strong></p>
<p><strong>核心线程数：</strong></p>
<ul>
<li>CPU密集型：N+1。数量与CPU核数相近是为了不浪费CPU，并防止频繁的上下文切换，加1是为了有线程被阻塞后还能不浪费CPU的算力。</li>
<li><strong>I/O密集型：</strong>2N，或N/(1-阻塞系数)。I/O密集型任务CPU使用率并不是很高，可以让CPU在等待I/O操作的时去处理别的任务，充分利用CPU，所以数量就比CPU核心数高一倍。</li>
<li>有些公司会考虑阻塞系数，阻塞系数是任务线程被阻塞的比例，一般是0.8~0.9。</li>
<li><strong>实际开发中更适合的公式：</strong>N*((线程等待时间+线程计算时间)/线程计算时间)</li>
</ul>
<p><strong>最大线程数：</strong>设成核心线程数的2-4倍。数量主要由CPU和IO的密集性、处理的数据量等因素决定。</p>
<p><strong>需要增加线程的情况：</strong>jstack打印线程快照，如果发现线程池中大部分线程都等待获取任务、则说明线程够用。如果大部分线程都处于运行状态，可以继续适当调高线程数量。</p>
<p><strong>jstack：</strong>打印指定进程此刻的线程快照。定位线程长时间停顿的原因，例如死锁、等待资源、阻塞。如果有死锁会打印线程的互相占用资源情况。线程快照：该进程内每条线程正在执行的方法堆栈的集合。</p>
<h3 id="多线程实现的四种方式"><a href="#多线程实现的四种方式" class="headerlink" title="多线程实现的四种方式"></a>多线程实现的四种方式</h3><ol>
<li><p>继承Thread类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">ThreadDemo</span> <span class="variable">threadDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">         threadDemo.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">3</span> ; i &lt; <span class="number">100</span> ; i ++) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.sqrt(i) ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRunnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableDemo</span> <span class="variable">runnableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableDemo).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">3</span> ; i &lt; <span class="number">100</span> ; i ++) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.sqrt(i) ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现Callable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallable1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">CallableDemo</span> <span class="variable">callableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableDemo</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callableDemo); </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        List&lt;Integer&gt; lists = (List&lt;Integer&gt;)futureTask.get(); <span class="comment">//获取返回值</span></span><br><span class="line">        <span class="keyword">for</span> (Integer integer : lists) &#123;</span><br><span class="line">            System.out.print(integer + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableDemo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;List&lt;Integer&gt;&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        List&lt;Integer&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">3</span> ; i &lt; <span class="number">100</span> ; i ++) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.sqrt(i) ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                lists.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxj.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        List&lt;Future&lt;List&lt;Integer&gt;&gt;&gt; ints = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            Future&lt;List&lt;Integer&gt;&gt; future = executorService.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">                    List&lt;Integer&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">3</span> ; i &lt; <span class="number">100</span> ; i ++) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.sqrt(i) ; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                                flag = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                            lists.add(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> lists;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ints.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Future&lt;List&lt;Integer&gt;&gt; future : ints) &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="线程池中-submit-和-execute-方法的区别"><a href="#线程池中-submit-和-execute-方法的区别" class="headerlink" title="线程池中 submit() 和 execute() 方法的区别"></a>线程池中 submit() 和 execute() 方法的区别</h3><p><strong>execute()：</strong>只能执行 Runnable 类型的任务。<br><strong>submit()：</strong>可以执行 Runnable 和 Callable 类型的任务。<br>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p>
<h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><ol>
<li><p><strong>手动配置线程池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">createThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">5</span>,                               <span class="comment">// 核心线程数</span></span><br><span class="line">            <span class="number">10</span>,                              <span class="comment">// 最大线程数</span></span><br><span class="line">            <span class="number">60</span>,                              <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),  <span class="comment">// 任务队列大小</span></span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="comment">// 拒绝策略</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Spring Boot自动配置</strong>：在Spring Boot项目中，可通过配置文件设置线程池参数</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">task:</span></span><br><span class="line">    <span class="attr">execution:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">core-size:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-size:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">queue-capacity:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">keep-alive:</span> <span class="string">60s</span></span><br><span class="line">      <span class="attr">thread-name-prefix:</span> <span class="string">my-task-</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Spring Cloud中的线程池配置</strong>：在微服务架构中，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%85%8D%E7%BD%AE&spm=1001.2101.3001.7020">线程池配置</a>需考虑服务间调用的特性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AsyncConfig &#123;</span><br><span class="line">    @Bean(name = &quot;asyncExecutor&quot;)</span><br><span class="line">    public ThreadPoolTaskExecutor asyncExecutor() &#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(10);</span><br><span class="line">        executor.setMaxPoolSize(50);</span><br><span class="line">        executor.setQueueCapacity(200);</span><br><span class="line">        executor.setKeepAliveSeconds(300);</span><br><span class="line">        executor.setThreadNamePrefix(&quot;cloud-async-&quot;);</span><br><span class="line">        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        return executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>@Async</code>注解启用异步方法：<br><code>@Async</code> 是 Spring 框架提供的注解，用于标记一个方法为异步方法。当调用该方法时，Spring 会将其提交到线程池执行，而不是由调用线程同步执行。这在处理耗时操作时非常有用，可以避免阻塞主线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.scheduling.annotation.Async;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class MyService &#123;</span><br><span class="line">    @Async(&quot;asyncExecutor&quot;)</span><br><span class="line">    public CompletableFuture&lt;String&gt; processAsync() &#123;</span><br><span class="line">        // 异步处理逻辑</span><br><span class="line">        return CompletableFuture.completedFuture(&quot;处理完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h3><p><strong>任务加入时判断的顺序：</strong>核心线程数 、阻塞队列、最大线程数、拒绝策略。</p>
<p><strong>线程池执原理：</strong> </p>
<ol>
<li><p>新加入任务，判断corePoolSize是否到最大值；如果没到最大值就创建核心线程执行新任务，如果到最大值就判断是否有空闲的核心线程；</p>
</li>
<li><p>如果有空闲的核心线程，则空闲核心线程执行新任务，如果没空闲的核心线程，则尝试加入FIFO阻塞队列；</p>
</li>
<li><p>若加入成功，则等待空闲核心线程将队头任务取出并执行，若加入失败（如队列满了），则判断maximumPoolSize是否到最大值；</p>
</li>
<li><p>如果没到最大值就创建非核心线程执行新任务，如果到了最大值就执行丢弃策略，默认丢弃新任务；</p>
</li>
<li><p>线程数大于corePoolSize时，空闲线程将在keepAliveTime后回收，直到线程数等于核心线程数。这些核心线程也不会被回收。</p>
</li>
</ol>
<p>实际上线程本身没有核心和非核心的概念，都是靠比较corePoolSize和当前线程数判断一个线程是不是能看作核心线程。</p>
<p>可能某个线程之前被看作是核心线程，等它空闲了，线程池又有corePoolSize个线程在执行任务，这个线程到keepAliveTime后还是会被回收。</p>
<h3 id="练习：多线程交替打印A-B-C，每个打印3次"><a href="#练习：多线程交替打印A-B-C，每个打印3次" class="headerlink" title="练习：多线程交替打印A/B/C，每个打印3次"></a>练习：多线程交替打印A/B/C，每个打印3次</h3><p> <strong>核心逻辑：</strong>创建线程，循环加锁，执行以下逻辑：</p>
<ol>
<li><strong>临界值判断：</strong>到达临界值后唤醒其他线程并结束锁；</li>
<li><strong>打印判断：</strong>如果需要打印，则打印、操作原子类（只有打印后才操作原子类，否则就是不满足条件，需要下一步的唤醒等待后，进入下一轮的循环）；</li>
<li><strong>线程通信：</strong>唤醒、等待。</li>
</ol>
<blockquote>
<p><strong>坑点：</strong></p>
<ul>
<li><strong>临界值判断不能放到while里：</strong>防止最后一个线程无法唤醒其他线程，从而导致死锁（其他线程没人唤醒了）。</li>
<li><strong>必须用线程通信：</strong>防止当前线程释放锁后立刻又拿回锁（因为多线程是CPU随机切换的），从而达不到交替打印的效果</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线交替打印A/B/C</span></span><br><span class="line"><span class="comment">// Object类的wait()和notifyAll()方案、不抽取方法： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>); <span class="comment">// 当前行值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">9</span>; <span class="comment">// 总打印行数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">// 下面创建三个线程可以抽取成一个方法，这里方便理解所以拆开</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// tip：这里条件没必要index.get()&lt;count，因为where不在锁里。</span></span><br><span class="line">            <span class="comment">// 如果临界值判断加到这里，会导致最后一个线程无法唤醒其他线程，从而导致死锁（其他线程没人唤醒了）。</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 1.临界值判断：到达临界值后唤醒其他线程并结束锁；</span></span><br><span class="line">                    <span class="keyword">if</span>(index.get()&gt;=count)&#123;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 2.打印判断：如果需要打印，则打印、操作原子类</span></span><br><span class="line">                    <span class="keyword">if</span> (index.get() % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                        <span class="comment">// 只有打印后才操作原子类，否则就是不满足条件，需要下一步的唤醒等待后，进入下一轮的循环</span></span><br><span class="line">                        index.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 3.线程通信：唤醒、等待</span></span><br><span class="line">                    <span class="comment">// 3.1 唤醒其他线程：不管能不能整除，结束后都唤醒其他线程</span></span><br><span class="line">                    <span class="comment">// notifyAll()唤醒该对象上的所有线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="comment">// 3.2 当前线程等待：Object类的wait()让线程等待，直到其他线程调用notify()或notifyAll()方法唤醒</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程1打印A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(index.get()&gt;=count)&#123;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (index.get() % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                        index.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程2打印B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(index.get()&gt;=count)&#123;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (index.get() % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">                        index.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程3打印C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建和启动线程抽取方法</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>); <span class="comment">// 当前行值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">9</span>; <span class="comment">// 总打印行数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        createAndStartThread(<span class="string">&quot;线程1打印A&quot;</span>, lock, <span class="number">0</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        createAndStartThread(<span class="string">&quot;线程2打印B&quot;</span>, lock, <span class="number">1</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        createAndStartThread(<span class="string">&quot;线程3打印C&quot;</span>, lock, <span class="number">2</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createAndStartThread</span><span class="params">(String threadName, Object lock, <span class="type">int</span> remainder, String output)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (index.get() &gt;= count) &#123;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (index.get() % <span class="number">3</span> == remainder) &#123;</span><br><span class="line">                        System.out.println(output);</span><br><span class="line">                        index.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, threadName).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>其他线程通信方式：</strong></p>
<ul>
<li>Object类的wait()和notifyAll()（采用）</li>
<li><strong>Conditon的await，sign或signAll方法：</strong>创建三个Conditon对象A/B/C，A.await()就是让A线程等待；</li>
<li><strong>Semaphore的acquire和release方法：</strong>使用三个Semaphore对象，分别初始化为1、0、0，表示A、B、C三个线程的初始许可数。每个线程在打印字母之前，需要调用对应的Semaphore对象的acquire方法，获取许可。每个线程在打印字母之后，需要调用下一个Semaphore对象的release方法，释放许可。</li>
</ul>
</blockquote>
<hr>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>当多个线程访问共享资源时，若不采取同步措施，可能导致数据不一致或其他异常。常见的线程安全问题包括： </p>
<ul>
<li><strong>竞态条件</strong>（<code>Race Condition</code>）：多个线程竞争同一资源导致结果不确定。 </li>
<li><strong>内存可见性</strong>：一个线程修改了共享变量，其他线程可能无法立即看到最新值。 </li>
<li><strong>指令重排序</strong>：编译器或处理器为优化性能而重新排序指令，可能影响多线程执行顺序。</li>
</ul>
<p><strong>线程安全：</strong>程序在多线程环境下可以持续进行正确的处理，不会产生数据竞争（例如死锁）和不一致的问题。<strong>解决方案</strong>：原子类、volatile、锁、线程安全的集合 </p>
<p><strong>线程安全的解决方案：</strong>按照资源占用情况由轻到重排列：</p>
<ul>
<li><strong>原子类：</strong>如<code>AtomicInteger</code>、<code>AtomicLong</code>等，具有原子操作特征（化学中原子是最小单位、不可分割）的类，只能保证单个共享变量的线程安全</li>
<li><strong>volatile：</strong>只能保证单个共享变量的线程安全</li>
<li><strong>锁：</strong>可以保证临界区内的多个共享变量线程安全。</li>
</ul>
<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>原子类是具有原子操作特征（化学中原子是最小单位、不可分割）的类，原子是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>在java.util.concurrent.atomic包下，有一系列“Atomic”开头的类，统称为原子类。例如AtomicInteger替代int ，底层采用CAS原子指令实现，内部的存储值使用volatile修饰，因此多线程之间是修改可见的。</p>
<p>以AtomicInteger为例，某线程调用该对象的incrementAndGet()方式自增时采用CAS尝试修改它的值，若此时没有其他线程操作该值便修改成功否则反复执行CAS操作直到修改成功。</p>
<blockquote>
<p><strong>CAS：</strong>不断对变量进行原子性比较和交换，从而解决单个变量的线程安全问题。比较内存中值和预期值，如果相等则交换，如果不相等就代表被其他线程改了则重试。 </p>
</blockquote>
<p><strong>AtomicInteger常用方法：</strong>  </p>
<ul>
<li>构造方法：<ul>
<li>AtomicInteger (): 创建一个初始值为0的 AtomicInteger。</li>
<li>AtomicInteger(int initialValue): 创建一个初始值为 initialValue 的 AtomicInteger。</li>
<li>获取和设置：<ul>
<li>int get(): 获取当前的值。</li>
<li>void set(int newValue): 设置为 newValue。</li>
<li>int getAndSet(int newValue): 获取当前值，并设置为 newValue。 </li>
</ul>
</li>
</ul>
</li>
<li><strong>原子更新：</strong><ul>
<li> boolean compareAndSet(int expect, int update): 如果当前值等于 expect，则更新为 update。</li>
<li>int getAndIncrement(): 以原子方式将当前值加1，返回的是旧值。</li>
<li>int incrementAndGet(): 以原子方式将当前值加1，返回的是新值。</li>
<li>int getAndDecrement(): 以原子方式将当前值减1，返回的是旧值。</li>
<li>int decrementAndGet(): 以原子方式将当前值减1，返回的是新值。</li>
<li>int getAndAdd(int delta): 以原子方式将当前值加上 delta，返回的是旧值。</li>
<li>int addAndGet(int delta): 以原子方式将当前值加上 delta，返回的是新值。</li>
</ul>
</li>
<li><strong>其他方法：</strong> <ul>
<li> int getAndUpdate(IntUnaryOperator updateFunction): 获取当前值，并按更新函数计算新值设置。</li>
<li>int updateAndGet(IntUnaryOperator updateFunction): 按更新函数计算新值设置，并返回新值。</li>
<li>int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction): 获取当前值，并按累加函数计算新值设置。</li>
<li>int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction): 按累加函数计算新值设置，并返回新值。 </li>
</ul>
</li>
</ul>
<p><strong>验证原子类的线程安全：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 创建10个线程，分别对atomicInteger进行操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    atomicInteger.incrementAndGet();</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞主线程1s，保证10个线程执行完毕</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(atomicInteger);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行之后，可以看到原子类正常加到100000，而num没有</span></span><br></pre></td></tr></table></figure>

<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>volatile是一个关键字，被volatile声明的变量存在共享内存中，所有线程要读取、修改这个变量，都是从内存中读取、修改，并且修改操作是原子性的，所以它能保证线程安全。</p>
<p><strong>volatile特性：</strong></p>
<ul>
<li><strong>有序性：</strong>被volatile声明的变量之前的代码一定会比它先执行，而之后的代码一定会比它慢执行。底层是在生成字节码文件时，在指令序列中插入内存屏障防止指令重排序。</li>
<li><strong>可见性：</strong>一旦修改变量则立即刷新到共享内存中，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的工作空间中读取。每个线程自己的工作空间用于存放堆栈（存方法的参数和返回地址）和局部变量。</li>
<li><strong>原子性：</strong>volatile变量不能保证完全的原子性，只能保证单次的读/写操作具有原子性（在同一时刻只能被一个线程访问和修改），自增减、复合操作（+=,/=等）则不具有原子性。这也是和synchronized的区别。</li>
</ul>
<p><strong>读写内存语义：</strong></p>
<ul>
<li><strong>写内存语义：</strong>当写一个volatile变量时，JMM（Java内存模型）会把该线程本地内存中的共享变量的值刷新到主内存中。</li>
<li><strong>读内存语义：</strong>当读一个volatile变量时，JMM会把该线程本地内存置为无效,使其从主内存中读取共享变量。</li>
</ul>
<p><strong>有序性实现机制：</strong></p>
<p>volatile有序性是通过内存屏障来实现的。内存屏障就是在编译器生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p><strong>机器指令：</strong>JVM包括类加载子系统、运行时数据区、执行引擎。 执行引擎负责将字节码指令转为操作系统能识别的本地机器指令。</p>
<p><strong>指令重排序：</strong>处理器为了提高运算速度会对指令重排序，重排序分三种类型：编译器优化重排序、处理器指令级并行重排序、内存系统重排序。 </p>
<ul>
<li><strong>编译器优化的重排序：</strong>编译器在不改变单线程程序的语义前提下，可以重新安排语句的执行顺序。</li>
<li><strong>指令级并行的重排序：</strong>现在处理器采用了指令集并行技术，将多条指令重叠执行。如果不存在依赖性，处理器可以改变语句对应的机器指令的执行顺序。</li>
<li><strong>内存系统的重排序：</strong>由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>加锁的方式有两种，分别是synchronized关键字和Lock接口（在JUC包下）。</p>
<p><strong>synchronized锁</strong>是互斥锁，可以作用于实例方法、静态方法、代码块，能够保证同一个时刻只有一个线程执行该段代码，保证线程安全。 在执行完或者出现异常时自动释放锁。synchronized锁基于对象头和Monitor对象，在1.6之后引入轻量级锁、偏向锁等优化。</p>
<p><strong>lock锁</strong>接口可以通过lock、unlock方法锁住一段代码，Lock实现类都是基于AQS实现的。Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">// ToDo: handle exception	</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System. out.println(“释放锁<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    lock. unlock();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><ol>
<li><strong>Collections工具类：</strong>Collections工具类的synchronizedXxx()方法<strong>，</strong>将ArrayList等集合类包装成线程安全的集合类。</li>
<li><strong>古老api：</strong>java.util包下性能差的古老api，如Vector、Hashtable</li>
<li><strong>降低锁粒度的并发容器：</strong>JUC包下Concurrent开头的、以降低锁粒度来提高并发性能的容器，如ConcurrentHashMap。</li>
<li><strong>复制技术实现的并发容器：</strong>JUC包下以CopyOnWrite开头的、采用写时复制技术实现的并发容器，如CopyOnWriteArrayList。 </li>
</ol>
<h2 id="分布式场景下的线程安全"><a href="#分布式场景下的线程安全" class="headerlink" title="分布式场景下的线程安全"></a>分布式场景下的线程安全</h2><p>在分布式系统中，仅靠JVM级别的同步机制无法保证线程安全，需引入分布式锁：</p>
<ol>
<li><p><strong>Redis分布式锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;distributed_lock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RELEASE_SCRIPT</span> <span class="operator">=</span> </span><br><span class="line">        <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;   return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisLock</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">(String requestId, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(LOCK_KEY, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">releaseLock</span><span class="params">(String requestId)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(RELEASE_SCRIPT, <span class="number">1</span>, LOCK_KEY, requestId);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1L</span>.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>ZooKeeper分布式锁</strong>：使用<code>Apache Curator</code>框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZookeeperLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed_lock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> InterProcessMutex lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZookeeperLock</span><span class="params">(String zkConnectString)</span> &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(</span><br><span class="line">            zkConnectString, </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">        );</span><br><span class="line">        client.start();</span><br><span class="line">        lock = <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, LOCK_PATH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        lock.acquire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>多条语句共享数据时，多线程程序会出现<strong>数据安全问题</strong>。</p>
<p><strong>线程同步：</strong>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态。</p>
<p>Java主要通过加锁的方式实现线程同步,而锁有两类,分别是synchronized关键字和Lock接口（在JUC包下）。具体见<a href="#%E9%94%81">锁</a></p>
<p><strong>对比线程安全和线程同步：</strong>线程同步是实现线程安全的一种手段</p>
<ul>
<li><strong>线程安全：</strong>程序在多线程环境下可以持续进行正确的处理，不会产生数据竞争（例如死锁）和不一致的问题。解决方案：原子类、volatile、锁、线程安全的集合</li>
<li><strong>线程同步：</strong>确保多个线程正确、有序地访问共享资源。解决方案：锁</li>
</ul>
<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>同步代码块作用在代码块上,则需要在关键字后面的小括号里,显式指定锁对象，例如this、Xxx.class。</p>
<p>同步代码块简单来说就是将一段代码用一把锁给锁起来, 只有获得了这把锁的线程才访问, 并且同一时刻, 只有一个线程能持有这把锁, 这样就保证了同一时刻只有一个线程能执行被锁住的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步对象) &#123;</span><br><span class="line">    <span class="comment">//多条语句操作共享数据的代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步代码块的好处：</strong>解决了多线程的数据安全问题</p>
<p><strong>弊端：</strong>线程很多时，每个线程都会去判断锁，这是很耗费资源和时间的。例如，共有100张票，三个窗口卖票，通过加锁防止超卖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTicket</span> <span class="variable">sellTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><ol>
<li><p>作用在静态方法上,则锁是当前类的Class对象。</p>
</li>
<li><p>作用在普通方法上,则锁是当前的实例（this）。</p>
</li>
</ol>
<p><strong>非静态同步方法的锁对象为this</strong>。下面代码是相同功能的同步方法和同步代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁的粒度是当前对象</span></span><br><span class="line"><span class="comment">// 方法1：实例方法，使用this对象锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sellTicket1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：实例方法，使用this对象锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sellTicket2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 锁的粒度是整个类：</span></span><br><span class="line"><span class="comment">// 静态同步方法的锁对象为：类名.class。下面代码是相同功能的同步方法和同步代码块 </span></span><br><span class="line"><span class="comment">// 方法3：静态方法，使用类对象锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sellTicket3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">        tickets--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4：静态方法，使用类对象锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sellTicket4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SellTicket.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="异步执行时保证事务有效性"><a href="#异步执行时保证事务有效性" class="headerlink" title="异步执行时保证事务有效性"></a>异步执行时保证事务有效性</h1><p>Spring的事务管理基于线程绑定的<code>TransactionSynchronizationManager</code>，而异步方法会在独立线程中执行，导致事务上下文丢失。</p>
<h2 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a><strong>问题根源</strong></h2><p>Spring事务依赖于线程上下文传递事务信息。当使用<code>@Async</code>时，方法在新线程中执行，与调用线程不在同一个事务上下文： </p>
<ol>
<li><strong>事务管理器失效</strong>：新线程没有绑定事务上下文。</li>
<li><strong>数据库连接丢失</strong>：每个线程使用独立的数据库连接。 </li>
<li><strong>异常回滚失效</strong>：异步线程的异常无法触发调用线程的事务回滚。</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="独立事务（推荐）"><a href="#独立事务（推荐）" class="headerlink" title="独立事务（推荐）"></a><strong>独立事务</strong>（推荐）</h3><ul>
<li><p>为每个异步方法创建独立的事务，适用于可容忍部分失败的场景（如批量处理）</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>每个异步任务独立提交/回滚</li>
<li>适合批量处理大量数据，部分失败不影响整体</li>
</ul>
</li>
<li><p><strong>配置示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line">    <span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span>  <span class="comment">// 创建新事务</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">processData</span><span class="params">(Long recordId)</span> &#123;</span><br><span class="line">        <span class="comment">// 数据库操作</span></span><br><span class="line">        repository.updateStatus(recordId, <span class="string">&quot;PROCESSING&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务逻辑</span></span><br><span class="line">            complexProcessing(recordId);</span><br><span class="line">            repository.updateStatus(recordId, <span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            repository.updateStatus(recordId, <span class="string">&quot;FAILED&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;处理失败&quot;</span>, e);  <span class="comment">// 触发当前事务回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a><strong>事件驱动架构</strong></h3><ul>
<li><p>将异步操作转为事件，主线程提交事务后再处理事件，确保数据一致性。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>事务提交后才触发异步处理</li>
<li>适合耗时操作不影响主线程事务的场景</li>
</ul>
</li>
<li><p><strong>实现步骤</strong>：</p>
<ul>
<li><p><strong>定义事件</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataProcessEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long recordId;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataProcessEvent</span><span class="params">(Long recordId)</span> &#123; <span class="built_in">this</span>.recordId = recordId; &#125;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>发布事件（在事务内）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createAndProcessData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建记录（事务内）</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">recordId</span> <span class="operator">=</span> repository.save(<span class="keyword">new</span> <span class="title class_">Record</span>()).getId();</span><br><span class="line">        <span class="comment">// 发布事件（事务提交后触发）</span></span><br><span class="line">        eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">DataProcessEvent</span>(recordId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>异步监听事件</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataProcessListener</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDataProcessEvent</span><span class="params">(DataProcessEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 异步处理（无事务）</span></span><br><span class="line">        processData(event.getRecordId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="手动管理事务（高级）"><a href="#手动管理事务（高级）" class="headerlink" title="手动管理事务（高级）"></a><strong>手动管理事务</strong>（高级）</h3><ul>
<li><p>在异步方法中手动获取和管理事务，适用于强一致性要求的场景。 </p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>完全控制事务边界</li>
<li>代码复杂度高，需谨慎处理异常</li>
</ul>
</li>
<li><p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManualTransactionService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionDefinition transactionDefinition;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">processWithManualTx</span><span class="params">(Long recordId)</span> &#123;</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(transactionDefinition);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 数据库操作</span></span><br><span class="line">            repository.updateStatus(recordId, <span class="string">&quot;PROCESSING&quot;</span>);</span><br><span class="line">            complexProcessing(recordId);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 手动提交事务</span></span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 手动回滚事务</span></span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;处理失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="补偿事务（最终一致性）"><a href="#补偿事务（最终一致性）" class="headerlink" title="补偿事务（最终一致性）"></a><strong>补偿事务</strong>（最终一致性）</h3><ul>
<li><p>通过补偿机制保证最终一致性，适用于分布式系统</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>保证最终一致性，而非强一致性</li>
<li>适合跨服务、跨系统的操作</li>
</ul>
</li>
<li><p><strong>实现方案</strong>： </p>
<ul>
<li><strong>记录操作日志</strong>：在主事务中记录所有操作。 </li>
<li><strong>异步执行</strong>：调用外部服务或执行复杂逻辑。 </li>
<li><strong>补偿逻辑</strong>：若异步操作失败，根据日志执行反向操作</li>
</ul>
</li>
<li><p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompensationService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrderWithCompensation</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建订单（主事务）</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">savedOrder</span> <span class="operator">=</span> orderRepository.save(order);</span><br><span class="line">        <span class="comment">// 2. 记录补偿日志（主事务）</span></span><br><span class="line">        compensationLogRepository.save(<span class="keyword">new</span> <span class="title class_">CompensationLog</span>(</span><br><span class="line">            savedOrder.getId(), <span class="string">&quot;CREATE_ORDER&quot;</span>, savedOrder</span><br><span class="line">        ));</span><br><span class="line">        <span class="comment">// 3. 异步处理库存、支付等（无事务）</span></span><br><span class="line">        asyncService.processOrderAsync(savedOrder.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrderAsync</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 扣减库存、调用支付等操作</span></span><br><span class="line">            inventoryService.debitStock(orderId);</span><br><span class="line">            paymentService.processPayment(orderId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 触发补偿逻辑</span></span><br><span class="line">            compensationService.rollbackOrder(orderId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="最佳实践总结"><a href="#最佳实践总结" class="headerlink" title="最佳实践总结"></a>最佳实践总结</h2><ol>
<li><strong>优先使用独立事务</strong>：为每个异步任务创建独立事务，通过状态跟踪失败记录。 </li>
<li><strong>避免长事务</strong>：将耗时操作移出事务，减少锁持有时间。 </li>
<li><strong>使用可靠消息队列</strong>：如<code>RabbitMQ、Kafka</code>，确保事件不丢失。 </li>
<li><strong>实现幂等性</strong>：异步操作需支持重试（如<code>唯一索引、状态校验</code>）。 </li>
<li><strong>监控与告警</strong>：记录异步任务状态，及时发现并处理失败。</li>
</ol>
<h2 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><ol>
<li><p><strong>错误配置传播行为</strong>： </p>
<ul>
<li><p>使用<code>Propagation.REQUIRED</code>（默认）会导致异步方法加入调用者的事务（但实际上无法加入）。</p>
</li>
<li><p>必须使用<code>Propagation.REQUIRES_NEW</code>创建新事务。  </p>
</li>
</ul>
</li>
<li><p><strong>忽略异步异常</strong>： </p>
<ul>
<li>未捕获的异常会导致事务无法回滚。 </li>
<li>确保在异步方法中处理异常或使用<code>CompletableFuture</code>的异常处理。</li>
</ul>
</li>
<li><p><strong>过度依赖同步事务</strong>：</p>
<ul>
<li>在分布式系统中，强一致性难以实现，考虑最终一致性方案</li>
</ul>
</li>
</ol>
<h2 id="多线程如何保证事务一致性"><a href="#多线程如何保证事务一致性" class="headerlink" title="多线程如何保证事务一致性"></a>多线程如何保证事务一致性</h2><p>‌在多线程环境下保证事务一致性主要通过编程式事务管理、线程资源隔离、分布式事务框架及数据库锁机制等方案实现‌，具体选择需根据业务场景和技术架构灵活适配。‌‌</p>
<h3 id="核心实现方案：编程式事务管理‌"><a href="#核心实现方案：编程式事务管理‌" class="headerlink" title="核心实现方案：编程式事务管理‌"></a><strong>核心实现方案</strong>：编程式事务管理‌</h3><ol>
<li><p>通过代码手动控制事务边界，将多个子线程操作纳入统一事务管理框架</p>
</li>
<li><p>使用Spring的<code>TransactionTemplate</code>在子线程中执行数据库操作。 </p>
</li>
<li><p>主线程等待所有子线程执行完成后统一提交或回滚事务。‌‌‌‌</p>
</li>
<li><p><strong>示例代码结构</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Future&lt;?&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">    futures.add(executor.submit(() -&gt;</span><br><span class="line">        transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            <span class="comment">// 事务操作</span></span><br><span class="line">        &#125;);</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查所有子线程结果后决策提交/回滚 (自己判断是提交还是回滚)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="‌关键技术支撑‌"><a href="#‌关键技术支撑‌" class="headerlink" title="‌关键技术支撑‌"></a>‌<strong>关键技术支撑</strong>‌</h3><ul>
<li><p><strong>事务资源隔离机制</strong>‌</p>
<ul>
<li><p>突破默认的<code>ThreadLocal</code>绑定模式，通过自定义<code>TransactionSynchronizationManager</code>实现跨线程Connection共享。‌‌</p>
</li>
<li><p>使用<code>@Transactional(propagation = REQUIRES_NEW)</code>创建独立事务上下文。   </p>
</li>
</ul>
</li>
<li><p><strong>并发控制策略</strong>‌</p>
<ul>
<li><p><strong>数据库锁机制</strong>：结合<code>SELECT ... FOR UPDATE</code>实现行级锁，配合事务隔离级别（如<code>REPEATABLE_READ</code>）防止脏写。‌‌</p>
</li>
<li><p><strong>Java同步工具</strong>：采用<code>CountDownLatch</code>确保所有子线程就绪后统一提交。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> DataSource dataSource ; </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">cdl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>) ;</span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">txRollback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>) ;</span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      person.setAge(<span class="number">1</span>);</span><br><span class="line">      person.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">      transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          result = jdbcTemplate.update( <span class="string">&quot;insert into t_person (age, name) values (?, ?)&quot;</span>, </span><br><span class="line">                                       person.getAge(), person.getName() );</span><br><span class="line">          <span class="comment">// TODO</span></span><br><span class="line">          <span class="comment">// log.info(1 / 0) ;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          txRollback.set(<span class="literal">true</span>); <span class="comment">// 当发生异常后将状态该为 true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cdl.countDown(); <span class="comment">// 计数减一</span></span><br><span class="line">          cdl.await(); <span class="comment">// 继续等待其它线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (txRollback.get()) &#123; <span class="comment">// 如果回滚状态为 true 说明有线程发生了异常，需要事务回滚</span></span><br><span class="line">          status.setRollbackOnly(); <span class="comment">// 标记当前事务回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;%s Insert Operator Result: %d 次%n&quot;</span>, Thread.currentThread().getName(), result);</span><br><span class="line">        <span class="keyword">return</span> result ;</span><br><span class="line">      &#125;) ;</span><br><span class="line">    &#125;) ;</span><br><span class="line">    transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      person.setAge(<span class="number">2</span>);</span><br><span class="line">      person.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        result = jdbcTemplate.update(<span class="string">&quot;insert into t_person (age, name) values (?, ?)&quot;</span>, </span><br><span class="line">                                     person.getAge(), person.getName()) ;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>) ;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        txRollback.set(<span class="literal">true</span>) ; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cdl.countDown() ;</span><br><span class="line">        cdl.await() ;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (txRollback.get()) &#123;</span><br><span class="line">        status.setRollbackOnly(); <span class="comment">// 回滚</span></span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">&quot;%s Insert Operator Result: %d 次%n&quot;</span>, Thread.currentThread().getName(), result);</span><br><span class="line">      <span class="keyword">return</span> result ;</span><br><span class="line">    &#125;) ;</span><br><span class="line">    cdl.await() ;</span><br><span class="line">    log.info(<span class="string">&quot;Operator Complete...&quot;</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>分布式锁</strong>：通过<code>Redis</code>或<code>ZooKeeper</code>实现跨进程锁协调。‌‌</p>
</li>
</ul>
</li>
</ul>
<h3 id="扩展方案选型‌-：分布式事务补偿‌"><a href="#扩展方案选型‌-：分布式事务补偿‌" class="headerlink" title="扩展方案选型‌ ：分布式事务补偿‌"></a>扩展方案选型‌ ：分布式事务补偿‌</h3><ul>
<li><p><strong>Saga模式：</strong>拆分事务为多个可补偿的本地事务。</p>
</li>
<li><p><strong>TCC（Try-Confirm-Cancel）模式：</strong>通过预留资源保证最终一致性。</p>
</li>
<li><p>整合<code>Seata</code>等分布式事务框架实现全局事务管理</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://southernfish.github.io">Southern Fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://southernfish.github.io/2025/07/24/java/java-base-8-thread/">https://southernfish.github.io/2025/07/24/java/java-base-8-thread/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://southernfish.github.io" target="_blank">Southern Fish</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></div><div class="post_share"><div class="social-share" data-image="/img/article/article3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/24/java/java-base-8-thread-impl/"><img class="prev-cover" src="/img/article/article2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">使用多线程解决问题</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/24/java/java-base-7-io/"><img class="next-cover" src="/img/article/article1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JAVA I/O流</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/06/19/java/java-design-patterns/" title="设计模式"><img class="cover" src="/img/article/article3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="title">设计模式</div></div></a></div><div><a href="/2025/06/20/java/java-jvm/" title="JVM"><img class="cover" src="/img/article/article2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-20</div><div class="title">JVM</div></div></a></div><div><a href="/2025/06/19/java/java-network/" title="网络编程"><img class="cover" src="/img/article/article1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="title">网络编程</div></div></a></div><div><a href="/2025/06/19/java/java-object-copy/" title="对象克隆"><img class="cover" src="/img/article/article4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="title">对象克隆</div></div></a></div><div><a href="/2025/06/19/java/java-web/" title="Java Web"><img class="cover" src="/img/article/article1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="title">Java Web</div></div></a></div><div><a href="/2025/06/24/java/java-encription/" title="java的加密方式"><img class="cover" src="/img/article/article3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-24</div><div class="title">java的加密方式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southern Fish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SouthernFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1002721576@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">天下事岂能尽如吾意，心境须恰适，尽其在我，随遇而安。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">基本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">并行和并发的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.</span> <span class="toc-text">线程和进程的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%88state%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">线程状态（state）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%88Daemon-Thread%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">守护线程（Daemon Thread）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%EF%BC%88Interruption%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">中断（Interruption）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal-%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.7.</span> <span class="toc-text">ThreadLocal 及使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF"><span class="toc-number">1.8.</span> <span class="toc-text">需要多线程的业务场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">创建线程方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">方法1：继承Thread类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.</span> <span class="toc-text">方法2：实现 Runnable 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E5%AE%9E%E7%8E%B0-Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.</span> <span class="toc-text">方法3：实现 Callable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%954%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.5.</span> <span class="toc-text">方法4：线程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">3.</span> <span class="toc-text">知识加油站</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.1.</span> <span class="toc-text">线程生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">线程的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.3.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.3.2.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E5%BC%8F1%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">3.3.3.</span> <span class="toc-text">创建线程池的方式1：线程池工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E5%BC%8F2%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">3.3.4.</span> <span class="toc-text">创建线程池的方式2：自定义线程池（推荐）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%BE%E7%BD%AE%E5%90%88%E9%80%82%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-number">3.3.5.</span> <span class="toc-text">如何为线程池设置合适的线程数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.6.</span> <span class="toc-text">多线程实现的四种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD-submit-%E5%92%8C-execute-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.7.</span> <span class="toc-text">线程池中 submit() 和 execute() 方法的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.8.</span> <span class="toc-text">线程池配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.9.</span> <span class="toc-text">线程池的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0A-B-C%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%89%93%E5%8D%B03%E6%AC%A1"><span class="toc-number">3.3.10.</span> <span class="toc-text">练习：多线程交替打印A&#x2F;B&#x2F;C，每个打印3次</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">原子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.3.</span> <span class="toc-text">volatile关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">4.4.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">4.5.</span> <span class="toc-text">线程安全的集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.6.</span> <span class="toc-text">分布式场景下的线程安全</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">5.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">5.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">5.2.</span> <span class="toc-text">同步代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">同步方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E6%97%B6%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E6%9C%89%E6%95%88%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">异步执行时保证事务有效性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%A0%B9%E6%BA%90"><span class="toc-number">6.1.</span> <span class="toc-text">问题根源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">6.2.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E4%BA%8B%E5%8A%A1%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">6.2.1.</span> <span class="toc-text">独立事务（推荐）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84"><span class="toc-number">6.2.2.</span> <span class="toc-text">事件驱动架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89"><span class="toc-number">6.2.3.</span> <span class="toc-text">手动管理事务（高级）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1%EF%BC%88%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%89"><span class="toc-number">6.2.4.</span> <span class="toc-text">补偿事务（最终一致性）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93"><span class="toc-number">6.3.</span> <span class="toc-text">最佳实践总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA"><span class="toc-number">6.4.</span> <span class="toc-text">常见误区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">6.5.</span> <span class="toc-text">多线程如何保证事务一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%EF%BC%9A%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E2%80%8C"><span class="toc-number">6.5.1.</span> <span class="toc-text">核心实现方案：编程式事务管理‌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%8C%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E6%94%AF%E6%92%91%E2%80%8C"><span class="toc-number">6.5.2.</span> <span class="toc-text">‌关键技术支撑‌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%E2%80%8C-%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A1%A5%E5%81%BF%E2%80%8C"><span class="toc-number">6.5.3.</span> <span class="toc-text">扩展方案选型‌ ：分布式事务补偿‌</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/24/java/java-base-10-reflection/" title="反射"><img src="/img/article/article1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="反射"/></a><div class="content"><a class="title" href="/2025/07/24/java/java-base-10-reflection/" title="反射">反射</a><time datetime="2025-07-24T04:08:36.000Z" title="发表于 2025-07-24 12:08:36">2025-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/24/java/java-base-9-lock/" title="锁"><img src="/img/article/article6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="锁"/></a><div class="content"><a class="title" href="/2025/07/24/java/java-base-9-lock/" title="锁">锁</a><time datetime="2025-07-24T02:28:36.000Z" title="发表于 2025-07-24 10:28:36">2025-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/24/java/java-base-8-thread-impl/" title="使用多线程解决问题"><img src="/img/article/article2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用多线程解决问题"/></a><div class="content"><a class="title" href="/2025/07/24/java/java-base-8-thread-impl/" title="使用多线程解决问题">使用多线程解决问题</a><time datetime="2025-07-24T01:25:36.000Z" title="发表于 2025-07-24 09:25:36">2025-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/24/java/java-base-8-thread/" title="多线程"><img src="/img/article/article3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多线程"/></a><div class="content"><a class="title" href="/2025/07/24/java/java-base-8-thread/" title="多线程">多线程</a><time datetime="2025-07-24T00:28:36.000Z" title="发表于 2025-07-24 08:28:36">2025-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/24/java/java-base-7-io/" title="JAVA I/O流"><img src="/img/article/article1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JAVA I/O流"/></a><div class="content"><a class="title" href="/2025/07/24/java/java-base-7-io/" title="JAVA I/O流">JAVA I/O流</a><time datetime="2025-07-24T00:20:36.000Z" title="发表于 2025-07-24 08:20:36">2025-07-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/article/article3.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Southern Fish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>