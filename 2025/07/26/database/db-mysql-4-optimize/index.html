<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MySQL数据库-优化 | Southern Fish</title><meta name="keywords" content="MySQL"><meta name="author" content="Southern Fish"><meta name="copyright" content="Southern Fish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="‌数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，目标是将低效SQL语句转换为高效等效语句。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL数据库-优化">
<meta property="og:url" content="https://southernfish.github.io/2025/07/26/database/db-mysql-4-optimize/index.html">
<meta property="og:site_name" content="Southern Fish">
<meta property="og:description" content="‌数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，目标是将低效SQL语句转换为高效等效语句。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://southernfish.github.io/img/article/article1.png">
<meta property="article:published_time" content="2025-07-26T05:30:36.000Z">
<meta property="article:modified_time" content="2025-08-18T15:22:47.304Z">
<meta property="article:author" content="Southern Fish">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://southernfish.github.io/img/article/article1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://southernfish.github.io/2025/07/26/database/db-mysql-4-optimize/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL数据库-优化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-18 23:22:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Southern Fish" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/article/article1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Southern Fish</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL数据库-优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-26T05:30:36.000Z" title="发表于 2025-07-26 13:30:36">2025-07-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-18T15:22:47.304Z" title="更新于 2025-08-18 23:22:47">2025-08-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Database/">Database</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL数据库-优化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，核心目标是将低效SQL语句转换为高效等效语句。人工智能自动优化技术通过重写SQL语句实现性能提升。优化技术演变历经三代工具：第一代解析执行计划，第二代推荐索引优化，第三代提出语法改进建议。优化策略贯穿数据库生命周期，其中设计阶段优化成本最低且收益最大。</p>
<blockquote>
<p>原文链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/article/details/130355955">MySQL高级篇——性能分析工具</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/article/details/131059110">【MySQL调优】如何进行MySQL调优？一篇文章就够了！</a></p>
</blockquote>
<h1 id="数据库服务器的优化步骤"><a href="#数据库服务器的优化步骤" class="headerlink" title="数据库服务器的优化步骤"></a>数据库服务器的优化步骤</h1><p>在数据库调优中，目标是<strong>响应时间更快，吞吐量更大</strong>。利用宏观的<strong>监控工具</strong>和微观的<strong>日志分析</strong>可以帮我们快速找到调优的思路和方式。 </p>
<p><strong>调优流程：</strong></p>
<ol>
<li><strong>SHOW STATUS</strong>观察服务器状态，是否存在周期性波动；如果存在的话就<strong>缓存优化</strong>；</li>
<li>如果还存在不规则延迟或卡顿的话，就<strong>开启慢查询、explan分析查询语句</strong>；</li>
<li>如果发现sql等待时间长，就<strong>调优服务器参数</strong>；如果发现sql执行时间长，就<strong>索引优化、表优化；</strong></li>
<li>如果还存在不规则延迟或卡顿的话，就<strong>观察</strong>sql查询是否到瓶颈了；是的话就<strong>读写分离、分库分表。</strong></li>
</ol>
<p><strong>三种分析工具（SQL调优三步骤）：</strong>慢查询、EXPLAN、SHOW PROFLING</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726121610266.png" alt="image-20250726121610266"></p>
<p>整个流程划分成了观察（Show status） 和行动（Action） 两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。</p>
<p>优化方式<strong>硬件，系统配置，数据库表结构，SQL及索引</strong>，从左至右效果渐好，从右至左，成本渐高。</p>
<hr>
<h1 id="查看系统性能参数"><a href="#查看系统性能参数" class="headerlink" title="查看系统性能参数"></a>查看系统性能参数</h1><h2 id="SHOW-STATUS-LIKE-‘参数’"><a href="#SHOW-STATUS-LIKE-‘参数’" class="headerlink" title="SHOW STATUS  LIKE ‘参数’"></a>SHOW STATUS  LIKE ‘参数’</h2><p>在MySQL中，可以使用<strong>SHOW STATUS</strong> 语句查询一些MySQL<strong>数据库服务器</strong>的<strong>性能参数</strong>、执行频率。</p>
<p>SHOW STATUS语句语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 中括号代表可省略。</p>
<p>一些常用的性能参数如下：</p>
<ul>
<li><p><strong>Connections：</strong>连接MySQL服务器的次数。</p>
</li>
<li><p><strong>Uptime：</strong>MySQL服务器的上线时间。重启服务器后会重置。</p>
</li>
<li><p><strong>Slow_queries：慢查询的次数</strong>。查询时长超过指定时间，次数越少越好。</p>
</li>
<li><p>Innodb_rows_read：Select查询返回的行数</p>
</li>
<li><p>Innodb_rows_inserted：执行INSERT操作插入的行数</p>
</li>
<li><p>Innodb_rows_updated：执行UPDATE操作更新的行数</p>
</li>
<li><p>Innodb_rows_deleted：执行DELETE操作删除的行数</p>
</li>
<li><p>Com_select：查询操作的次数。</p>
</li>
<li><p>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。</p>
</li>
<li><p>Com_update：更新操作的次数。</p>
</li>
<li><p>Com_delete：删除操作的次数。</p>
</li>
<li><p><strong>last_query_cost</strong>：查询优化器上一个查询的成本，最近一次删除用到数据页数量。</p>
</li>
</ul>
</blockquote>
<h2 id="查看SQL的查询成本"><a href="#查看SQL的查询成本" class="headerlink" title="查看SQL的查询成本"></a>查看SQL的查询成本</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>SQL查询是一个动态的过程，从页加载的角度来看:</p>
<ol>
<li><p><strong>缓冲池查询效率优于从磁盘查</strong></p>
<p>如果页就在数据库<strong>缓冲池</strong>中，那么<strong>效率是最高</strong>的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</p>
<blockquote>
<p>MySQL的缓冲池被分为多个不同的缓存池，其中包括：</p>
<ul>
<li>查询缓存：用来缓存查询结果。</li>
<li>InnoDB缓存池：用来缓存热点表和索引数据页。</li>
<li>MyISAM缓存池：用来缓存表数据块。</li>
</ul>
<p>当缓冲池中已经存储了较多的数据时，MySQL会使用一种叫做缓冲池替换算法的方法，将部分缓存数据替换出去，以腾出空间为新的数据做缓存。</p>
<p><strong>MySQL的缓冲池使用的是LRU（最近最少使用）算法</strong>，它会优先缓存最近使用的数据。当缓冲池的空间不足时，MySQL会将最不常用的数据从缓冲池中替换出去，以腾出空间缓存新的数据。</p>
</blockquote>
</li>
<li><p><strong>批量顺序查询平均下来每页查询更高</strong></p>
<p>如果从磁盘中对单一页进行随机读，那么效率是很低的(差不多10ms)，而采用<strong>顺序读取</strong>的方式，<strong>批量对页进行读取</strong>，<strong>平均一页的读取效率就会提升</strong>很多，甚至要快于单个页面在内存中的随机读取。</p>
<p>首先要考虑数据存放的位置，如果是<strong>经常使用的数据就要尽量放到缓冲池</strong>中，其次可以充分利用磁盘的吞吐能力，一次性<strong>批量读取数据</strong>，这样单个页的读取效率也就得到了提升。 </p>
<blockquote>
<p><strong>测试缓冲池缓存已使用的表和索引到内存中，效率高：</strong>查询900001和 900001~9000100查询成本差很多，查询速度差不多</p>
<p>查询 <strong>id=900001</strong> 的记录，然后看下查询成本，可以直接在聚簇索引上进行查找：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询 id<span class="operator">=</span><span class="number">900001</span> 的记录</span><br><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">900001</span>; </span><br><span class="line"># 运行结果（<span class="number">1</span> 条记录，运行时间为 <span class="number">0.042</span>s ）</span><br><span class="line"># 查询优化器的成本，实际上 只需要检索一个页</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">1.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br></pre></td></tr></table></figure>

<p>查询 id 在 <strong>900001</strong> 到 <strong>9000100</strong> 之间的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询 id 在 <span class="number">900001</span> 到 <span class="number">9000100</span> 之间的记录</span><br><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">900001</span> <span class="keyword">AND</span> <span class="number">900100</span>;</span><br><span class="line"># 运行结果（<span class="number">100</span> 条记录，运行时间为 <span class="number">0.046</span>s ）：</span><br><span class="line"># 查询优化器的成本，这时我们大概需要进行 <span class="number">20</span> 个页的查询。</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">21.134453</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br></pre></td></tr></table></figure>

<p>虽然页的数量是刚才的 20 倍，但<strong>查询的效率没有明显变化</strong>，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了<strong>顺序读取</strong>的方式将页面一次性加载到<strong>缓冲池</strong>中，然后再查找。虽然<strong>页数量</strong>（last_query_cost）<strong>增加了不少</strong>，但是通过缓冲池的机制，并<strong>没有增加多少查询时间。</strong></p>
<p><strong>为什么第二次是直接从缓冲池查</strong></p>
<p>因为 MySQL 缓存淘汰策略 LRU 最近最少使用，会优先缓存最近查询数据，优先淘汰最近最少使用数据。</p>
<p><strong>使用场景</strong>：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="定位执行慢的-SQL：慢查询日志"><a href="#定位执行慢的-SQL：慢查询日志" class="headerlink" title="定位执行慢的 SQL：慢查询日志"></a>定位执行慢的 SQL：慢查询日志</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>MySQL的慢查询日志，用来<strong>记录在MySQL中响应时间超过阀值的语句</strong>，具体指运行时间超过 <code>long-query_time</code> 值的SQL，则会被记录到慢查询日志中。 long_query_time的默认值为 10，意思是运行10秒以上(不含10秒)的语句，认为是超出了最大忍耐时间值。</p>
<p>主要作用是发现执行时间特别长的 SOL 查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，结合explain进行全面分析，以解决问题。</p>
<p>默认情况下，MySQL数据库 没有开启慢查询日志 ，需要我们手动来设置这个参数。<strong>如果不是调优需要的话，一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的<strong>性能影响</strong>。慢查询日志支持将日志记录写入文件 。</p>
<h2 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h2><p>利用监控工具（例如<code>Prometheus+Grafana</code>）监控MySQL，发现查询性能变慢，报警提醒运维人员</p>
<p><strong>常见监控工具：</strong></p>
<ol>
<li><strong>MySQL Enterprise Monitor：</strong>由Oracle提供，它提供实时和历史的MySQL性能监控（查询性能、服务器状态、数据库复制等）。</li>
<li><strong>Percona Monitoring and Management：</strong>由Percona提供的开源工具，提供性能监控、查询分析、数据库配置等功能。</li>
<li><strong>MyTOP：</strong>一个基于命令行的工具，用于实时监控MySQL数据库的性能。</li>
<li><strong>MySQL Performance Schema：</strong>MySQL自带的性能监控工具，可以通过查询Performance Schema表来获取有关数据库性能和资源利用情况的详细信息。</li>
<li><strong>Nagios：</strong>一个通用的网络监控工具，可以使用插件来监控MySQL数据库的各种指标。</li>
<li><strong>Zabbix：</strong>一个通用的网络监控工具，可以使用插件来监控MySQL数据库的各种指标。</li>
<li><strong>Datadog：</strong>一个云端监控服务，提供对MySQL数据库的性能和状态的实时监控。</li>
<li><strong>Prometheus + Grafana：</strong>一组流行的开源工具，通过Prometheus监控MySQL数据库，使用Grafana创建仪表板进行可视化。</li>
</ol>
<h2 id="开启慢查询日志参数"><a href="#开启慢查询日志参数" class="headerlink" title="开启慢查询日志参数"></a>开启慢查询日志参数</h2><ol>
<li><p><strong>慢查询是否开启</strong> </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 慢查询是否开启</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> low_query_log   <span class="operator">|</span> OFF       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>开启慢查询日志slow_query_log</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 开启慢查询日志</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"># 查看下慢查询日志是否开启，以及慢查询日志文件的位置（默认为MySQL的数据目录）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name          <span class="operator">|</span> <span class="keyword">Value</span>     								<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> low_query_log          <span class="operator">|</span> <span class="keyword">ON</span>       								<span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> low_query_log_file   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu01<span class="operator">-</span>slow.log      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------------------------------------+</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>修改慢查询阈值long_query_time</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看慢查询的时间阈值</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"># 查看全局慢查询的时间阈值：</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name     <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> long_query_time   <span class="operator">|</span> <span class="number">10.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-----------+</span></span><br></pre></td></tr></table></figure>

<p><strong>临时修改慢查询的时间阈值</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 当前回话</span><br><span class="line"><span class="keyword">set</span> long_query_time <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line"># 全局</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span>; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于 “global” 选项，是全局级别的配置参数。它可以在 MySQL 服务器启动时或 MySQL 安装时在 MySQL 配置文件中设置，或者通过 SET GLOBAL 命令在运行时更改。全局级别的配置参数对所有的 MySQL 连接都有效。</p>
</blockquote>
<p><strong>永久修改</strong>（重启数据库后依然有效，<strong>不建议永久修改</strong>，仅在优化时候打开，慢查询拖性能） ：修改<code>my.cnf</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log=ON <span class="comment"># 开启慢查询日志的开关</span></span><br><span class="line">slow_query_log_file=/var/lib/mysql/atguigu-slow.log <span class="comment">#慢查询日志的目录和文件名信息</span></span><br><span class="line">long_query_time=3 <span class="comment">#设置慢查询的闽值为3秒，超出此设定值的SQL即被记录到慢查询日志</span></span><br><span class="line">log_output=FILE</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 测试发现：设置<span class="keyword">global</span>的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并执行下述语句</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">1</span>;                        # 设置全局慢查询阈值<span class="number">1</span>s</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;        # 全局<span class="number">1</span>s</span><br><span class="line"><span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;            # 当前会话<span class="number">10</span>s</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h2 id="查看慢查询次数"><a href="#查看慢查询次数" class="headerlink" title="查看慢查询次数"></a>查看慢查询次数</h2><p>查询当前系统中有多少条慢查询记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h2 id="慢查询日志分析工具：mysqldumpslow"><a href="#慢查询日志分析工具：mysqldumpslow" class="headerlink" title="慢查询日志分析工具：mysqldumpslow"></a>慢查询日志分析工具：mysqldumpslow</h2><p><code>mysqldumpslow</code>是用于分析MySQL慢查询日志的命令行工具。通过解析慢查询日志，可以了解到数据库的性能问题，从而进行优化。</p>
<blockquote>
<p><strong>查看mysqldumpslow的帮助信息</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow <span class="comment">--help</span></span><br></pre></td></tr></table></figure>

<p><strong>mysqldumpslow</strong> 命令的具体参数如下：</p>
<ul>
<li>-a: 不将数字抽象成N，字符串抽象成S</li>
<li><strong>-s: 是表示按照何种方式排序：</strong><ul>
<li>c: 访问次数</li>
<li>l: 锁定时间</li>
<li>r: 返回记录</li>
<li><strong>t: 查询时间</strong></li>
<li>al:平均锁定时间</li>
<li>ar:平均返回记录数</li>
<li><strong>at:平均查询时间 （默认方式）</strong></li>
<li>ac:平均查询次数</li>
</ul>
</li>
<li><strong>-t: 即为返回前面多少条的数据；</strong></li>
<li>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</li>
</ul>
</blockquote>
<p><strong>案例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 按照查询时间排序，查看最慢的<span class="number">10</span>个查询，可以使用如下命令</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 如果需要筛选特定的查询，可以使用 `<span class="operator">-</span>g` 参数</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">-</span>g &quot;SELECT * FROM user&quot; <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 解析：该命令表示按照时间排序，显示最慢的<span class="number">10</span>个查询，其中关键字为 &quot;SELECT * FROM user&quot;。</span><br><span class="line"></span><br><span class="line"># 重新返回记录集最多的<span class="number">10</span>个<span class="keyword">SQL</span></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 查询访问次数最多的<span class="number">10</span>个<span class="keyword">SQL</span></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s c <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 查询按照时间排序的前<span class="number">10</span>条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">-</span>g &quot;left join&quot; <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 建议在使用这些命令时结合 <span class="operator">|</span> 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log <span class="operator">|</span> more</span><br></pre></td></tr></table></figure>



<h2 id="关闭慢查询日志"><a href="#关闭慢查询日志" class="headerlink" title="关闭慢查询日志"></a>关闭慢查询日志</h2><p>MySQL服务器停止慢查询日志功能有两种方法：</p>
<p><strong>方式1：永久性方式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">#slow_query_log=OFF</span></span><br></pre></td></tr></table></figure>

<p><strong>mysql默认关闭慢查询日志</strong>，或者，把slow_query_log一项注释掉 或 删除</p>
<p>重启MySQL服务，执行如下语句查询慢日志功能。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>;                 # 查询慢查询日志所在目录</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;     # 查询超时时长</span><br></pre></td></tr></table></figure>

<p><strong>方式2：临时性方式</strong></p>
<p>使用SET语句来设置。停止MySQL慢查询日志功能，具体SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log<span class="operator">=</span>off;                 # golbal全局有效。</span><br><span class="line"># 重启MySQL服务，使用<span class="keyword">SHOW</span>语句查询慢查询日志功能信息，发现慢查询日志已经关闭成功。</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>;                # 发现关闭成功</span><br><span class="line"># 慢查询阈值</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;       # <span class="number">10</span>s。前面改的时候没有加<span class="keyword">global</span>，所以重启服务器后阈值恢复<span class="number">10</span>s。</span><br></pre></td></tr></table></figure>



<h2 id="删除慢查询日志"><a href="#删除慢查询日志" class="headerlink" title="删除慢查询日志"></a>删除慢查询日志</h2><p><strong>手动删除</strong> </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用<span class="keyword">SHOW</span>语句显示慢查询日志信息，会得到慢查询日志的目录，在该目录下 手动删除慢查询日志文件 即可。</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> `slow_query_log<span class="operator">%</span>`;</span><br></pre></td></tr></table></figure>

<p><strong>自动删除</strong> </p>
<p>使用命令 mysqladmin flush-logs 来重新生成查询日志文件，执行完毕会在数据目录下重新生成慢查询日志文件。</p>
<p><strong>重新生成慢查询日志文件（直接删除旧的）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs slow</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>慢查询日志都是使用<code>mysqladmin flush-logs</code>命令来<strong>删除重建</strong>的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p>
</blockquote>
<hr>
<h1 id="定位慢查询语句、查看-SQL-执行成本：show-profile"><a href="#定位慢查询语句、查看-SQL-执行成本：show-profile" class="headerlink" title="定位慢查询语句、查看 SQL 执行成本：show profile"></a>定位慢查询语句、查看 SQL 执行成本：show profile</h1><p>show profile 是 MySQL 提供的可以用来分析<strong>当前会话中</strong> <strong>SQL 都做了什么、执行的资源消耗工具的情况</strong>，可用于 sql 调优的测量。默认情况下处于关闭状态，并保存最近15次的运行结果。</p>
<p><code>SHOW PROFILE</code> 是一个用于查看会话执行的查询的性能分析信息的 MySQL 命令。它可以帮助开发人员和 DBA <strong>分析查询语句执行时的瓶颈</strong>，并找出哪些部分需要优化。 </p>
<blockquote>
<p><strong>SHOW VARIABLES</strong> 显示了 MySQL 服务器的当前配置变量，包括全局配置变量和会话配置变量，以及它们的值。SHOW VARIABLES 用于查看 MySQL 配置系统参数的详细信息并进行系统参数的修改。<br><strong>SHOW STATUS</strong> 显示服务器的性能参数，包括连接、线程、查询等方面的状态信息，以及它们的值。 </p>
</blockquote>
<p><strong>查看配置是否开启profile：</strong> </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br><span class="line"># 开启 <span class="keyword">show</span> profile</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> profiling <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> profiling         <span class="operator">|</span> <span class="keyword">ON</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"># 执行查询语句</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees;</span><br><span class="line"># <span class="keyword">show</span> profiles; 查询当前会话所有查询语句持续时间</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profiles;</span><br><span class="line"># <span class="keyword">show</span> profile;查询当前会话最近<span class="keyword">sql</span>语句的执行成本</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profile;</span><br><span class="line"># 查询指定QueryID的cpu信息</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu <span class="keyword">for</span> <span class="number">2</span>;</span><br><span class="line"># 在<span class="keyword">SHOW</span> PROFILE 中可以查看不同部分的开销，比如 cpu、block.io 等</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu,block io <span class="keyword">for</span> query <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>show profile的常用查询参数：</strong></p>
<ol>
<li><p>ALL：显示所有的开销信息。</p>
</li>
<li><p>BLOCK IO：显示块IO开销。</p>
</li>
<li><p>CONTEXT SWITCHES：上下文切换开销。</p>
</li>
<li><p>CPU：显示CPU开销信息。</p>
</li>
<li><p>IPC：显示发送和接收开销信息。</p>
</li>
<li><p>MEMORY：显示内存开销信 息。</p>
</li>
<li><p>PAGE FAULTS：显示页面错误开销信息。</p>
</li>
<li><p>SOURCE：显示和Source_function，Source_file， Source_line相关的开销信息。</p>
</li>
<li><p>SWAPS：显示交换次数开销信息。</p>
</li>
</ol>
<p><strong>日常开发需注意：</strong></p>
<ol>
<li><p> <strong>converting HEAP to MyISAM</strong>: 查询结果太大，内存不够，数据往磁盘上搬了。</p>
</li>
<li><p><strong>Creating tmp table</strong>：创建临时表。先拷贝数据到临时表，用完后再删除临时表。</p>
</li>
<li><p><strong>Copying to tmp table on disk</strong>：把内存中临时表复制到磁盘上，警惕！</p>
</li>
<li><p><strong>locked</strong>。</p>
</li>
</ol>
<p>如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。</p>
<p><strong>注意：</strong>不过<strong>SHOW PROFILE命令将被弃用</strong>，但可以从 <strong>information_schema 中的 profiling 数据表</strong>进行查看。</p>
</blockquote>
<hr>
<h1 id="执行计划表：EXPLAIN"><a href="#执行计划表：EXPLAIN" class="headerlink" title="执行计划表：EXPLAIN"></a>执行计划表：EXPLAIN</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL的EXPLAIN是一种<strong>分析SQL语句查询性能的工具</strong>。当我们在MySQL中执行SELECT语句时，EXPLAIN可以帮助我们<strong>查看MySQL如何执行这个查询，即执行计划</strong>，包括<strong>使用哪些索引、选择哪些表、以及如何读取数据</strong>等信息。</p>
<p>EXPLAIN的使用方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> my_column <span class="operator">=</span> <span class="string">&#x27;my_value&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>执行以上命令后，MySQL会返回一张查询执行计划表，其中包含了MySQL执行这个查询的详细信息。通过分析查询执行计划表<strong>了解查询的性能瓶颈</strong>，以及如何优化查询语句，从而提高查询性能。  </p>
<p><strong>注意：</strong> </p>
<ul>
<li>EXPLAIN不考虑各种Cache</li>
<li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li>
<li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li>
<li>部分统计信息是估算的，并非精确值</li>
</ul>
<blockquote>
<p><strong>MySQL中有专门负责优化SELECT语句的优化器模块</strong></p>
<p><strong>主要功能</strong>：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供<strong>它认为最优的 执行计划</strong> (他认为最优的数据检索方式，但不见得是DBA（数据库管理员）认为是最优的，这部分最耗费时间)。</p>
</blockquote>
<p><strong>能做什么？</strong></p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<p><strong>官网介绍</strong></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">MySQL :: MySQL 5.7 Reference Manual :: 8.8.2 EXPLAIN Output Format</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">MySQL :: MySQL 8.0 Reference Manual :: 8.8.2 EXPLAIN Output Format</a></p>
<p><strong>版本情况</strong></p>
<ul>
<li><strong>MySQL 5.6.3以前只能 EXPLAIN SELECT</strong> ；<strong>MYSQL 5.6.3以后</strong>就可以 EXPLAIN SELECT，<strong>UPDATE， DELETE</strong></li>
<li>在5.7以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示 filtered 需要使用 explain extended 命令。在5.7版本后，默认explain直接显示partitions和 filtered中的信息。</li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>EXPLAIN 或 DESCRIBE语句的语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br><span class="line"># 一般指定在查询时不使用缓存</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE select_options</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure>

<p>除了以 SELECT 开头的查询语句，其余的 DELETE、INSERT、REPLACE 以及UPDATE 语句等都可以加上EXPLAIN</p>
<h2 id="执行计划表介绍"><a href="#执行计划表介绍" class="headerlink" title="执行计划表介绍"></a>执行计划表介绍</h2><h3 id="执行计划各个列的作用（概述）"><a href="#执行计划各个列的作用（概述）" class="headerlink" title="执行计划各个列的作用（概述）"></a>执行计划各个列的作用（概述）</h3><table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>每个SELECT子句或者join操作都会被分配一个唯一的编号，编号越小优先级越高，id相同的语句可以被认为是一组。id为NULL表示独立的子查询，子查询优先级都比主查询高。</td>
</tr>
<tr>
<td>select_type</td>
<td>查询的类型。主查询(primary)、普通查询(simple)、联合查询、子查询(subquery)、derived(from表临时子查询)、union(union后查询)、union result()</td>
</tr>
<tr>
<td>table</td>
<td>表名。显示当前这行的数据是哪个表的。</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区信息。如果表未分区则为NULL。</td>
</tr>
<tr>
<td><strong>type</strong></td>
<td><strong>访问类型，根据索引、全表扫描等方法来执行查询的优化策略。</strong>all（全表扫描），ref（命中非唯一索引），index(没命中索引，扫描索引树再回表)、const（命中主键/唯一索引）、range(范围索引查询)、index_merge(使用多个索引)、 system(一行记录时,快速查询)。</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引。列出MySQL能够使用哪些索引来查询。如果该列只有一个possible_keys，通常意味着这个查询是高效的。如果这个列有多个possible_keys，并且MySQL只使用了其中一个，则需要考虑是否需要在该列上增加一个联合索引。</td>
</tr>
<tr>
<td><strong>key</strong></td>
<td><strong>实际上使用的索引。</strong>如果没有明确的指定KEY，MySQL会根据查询条件自动选择最优的索引。</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息。常量等值查询const, 表达式/函数使用到时func,关联查询显示关联字段名</td>
</tr>
<tr>
<td><strong>rows</strong></td>
<td>预估的需要读取的记录条数。数值越小越好，表示结果集越小，查询越高效。</td>
</tr>
<tr>
<td>filtered</td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比。这个值越小越好，说明可通过索引直接返回数据。</td>
</tr>
<tr>
<td><strong>Extra</strong></td>
<td>额外信息。看有没有走索引，还是全表扫描了。一般搭配type字段看。Using index(使用到覆盖索引)、Using where(未完全命中索引)、Using temporary(临时表存储结果集.排序/分组会使用)、Using filesort(排序操作未用索引)、Using join buffer(连接条件未用索引)、Impossible where(where约束语句可能有问题导致没有结果集)</td>
</tr>
</tbody></table>
<h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p><strong>select_type：</strong>查询的类型，有以下几种取值：</p>
<ul>
<li>SIMPLE：不使用子查询或UNION，不包含UNION ALL的简单SELECT查询。</li>
<li>PRIMARY：最外层的SELECT查询。</li>
<li>DERIVED：以FROM子句中的子查询方式出现的SELECT语句。</li>
<li>UNION：UNION中的第二个或之后的SELECT查询。</li>
<li>UNION RESULT：从UNION的结果集中获取数据的SELECT查询。</li>
<li>SUBQUERY：不在FROM子句中出现的子查询，通常在SELECT语句中使用。</li>
<li>DEPENDENT SUBQUERY：子查询依赖外层查询的结果集。</li>
</ul>
<h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p><strong>key：</strong>实际上使用的索引。在MySQL中创建索引时使用的是INDEX关键字，但在EXPLAIN执行计划表中，显示的是KEY，这是因为<strong>MySQL允许在创建索引时指定统计信息</strong>，例如最小值、最大值等，这些<strong>统计信息</strong>在索引中被视为<strong>索引键</strong>（Index key），所以在执行计划表中，显示为KEY。</p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p><strong>type：</strong>访问类型，根据索引、全表扫描等方法来执行查询的优化策略。当 type 列的取值不是 Const 时，我们需要重点关注有关索引、缓存的性能调优，对 SQL 语句进行优化，适当修复可能的数据设计问题。</p>
<ul>
<li><p><strong>system：一行记录时,快速查询。</strong>只有一行数据即将被查询。这是最快的查询类型，通常出现在系统表的查询中。</p>
</li>
<li><p><strong>const：命中主键或唯一索引。</strong>使用主键或唯一索引查找单个行时使用，此时查询只能返回一行数据。这是一种非常快的查询类型。</p>
</li>
<li><p>eq_ref：连接使用唯一索引查找符合查询条件的数据时使用，每个连接类型都需要使用唯一索引进行访问，比ref执行速度更快。</p>
</li>
<li><p><strong>ref：命中非唯一索引。</strong>使用非唯一索引查找数据时使用，查询结果比eq_ref大，但仍很快。</p>
</li>
<li><p><strong>range：范围索引查询。</strong>使用索引范围查找数据时，可能会查找一定范围内的数据，如使用 BETWEEN 或 &gt; 或 &gt; &lt; 等操作时的查询。</p>
</li>
<li><p><strong>index：没命中索引，扫描非聚簇索引树再回表。</strong></p>
<ul>
<li><p>直接在某个索引树上做条件判断，并且不需要回表。全表扫描没有好的索引适用时使用，相比于全表扫描速度更快。</p>
</li>
<li><p>index是另外一种形式的全表扫描，扫描已有索引树然后回表取数据。和all相比，他要回表随机取数据，因此index不可能会比all快（取同一个表数据），官方手册说它的效率说的比all好，唯一可能的原因在于，按照索引扫描全表的数据是有序的。这样一来，结果不同，也就没法比效率的问题了。</p>
</li>
<li><p>比如：select t3.key1 from t3 where t3.key2 =6 ;当我们创建了联合索引idx_key1_key2(key1,key2)时，判断条件key2=6时，其虽然不满足索引的最左前缀原则，但是我们可以遍历idx_key1_key2这颗索引树，找到key2=6的记录即可。由于查询结果需要的key1在这个联合索引上，也不需要回表，此时就可以使用index。</p>
</li>
</ul>
</li>
<li><p><strong>all：全表扫描。</strong>扫描整个表以获得需要的数据，速度最慢，必须尽量避免使用。</p>
</li>
<li><p>unique_subquery：在对查询结果进行过滤或使用 IN 操作时，优化器会选择使用此类型的查询，使用了 In 操作符的子查询依赖于外层查询的唯一索引。</p>
</li>
<li><p>index_subquery：使用了 In 操作符但子查询使用的普通索引，而不是唯一索引。</p>
</li>
<li><p>range_check：在使用索引来检查外键参照时使用。</p>
</li>
<li><p>index_merge：使用多个索引。</p>
</li>
</ul>
<h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><ul>
<li><strong>using index：</strong>使用了覆盖索引，即不需要回表。查询的几个列正好都在这个聚簇索引树上。</li>
<li><strong>Using where：</strong>通过where过滤。没完全命中索引，需要回表。如index(a)，查的是where a=2 and b=3，查b=3时就要回表过滤。</li>
<li><strong>Using index condition：</strong>使用了索引下推。</li>
<li>Using temporary：临时表存储结果集.排序/分组会使用</li>
<li>Using filesort：排序操作未用索引</li>
<li>Using join buffer：连接条件未用索引</li>
<li>Impossible where：where约束语句可能有问题导致没有结果集</li>
</ul>
<h2 id="EXPLAIN四种输出格式"><a href="#EXPLAIN四种输出格式" class="headerlink" title="EXPLAIN四种输出格式"></a>EXPLAIN四种输出格式</h2><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式： <code>传统格式</code> ，<code>JSON格式</code> ， <code>TREE格式</code> 以及 <code>可视化输出</code> 。用户可以根据需要选择适用于自己的格式。</p>
<ol>
<li><p>传统格式：传统格式简单明了，输出是一个表格形式，概要说明查询计划。输出中缺少衡量执行好坏的重要属性 —— <code>成本</code>。</p>
</li>
<li><p>JSON格式：四种格式里面输出<code>信息最详尽</code>的格式，里面包含了执行的成本信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> ....</span><br></pre></td></tr></table></figure></li>
<li><p>TREE格式：TREE格式是8.0.16版本之后引入的新格式，主要根据查询的 <code>各个部分之间的关系</code> 和 <code>各部分的执行顺序</code> 来描述如何查询。</p>
</li>
<li><p>可视化输出：通过MySQL Workbench可视化查看执行计划。点击Workbench的放大镜图标，即可生成可视化的查询计划。</p>
<p>从左到右的连接顺序显示表。红色框表示 <code>全表扫描</code> ，而绿色框表示使用 <code>索引查找</code> 。对于每个表， 显示使用的索引。还要注意的是，每个表格的框上方是每个表访问所发现的行数的估计值以及访问该表的成本。 </p>
</li>
</ol>
<h2 id="SHOW-WARNINGS的使用"><a href="#SHOW-WARNINGS的使用" class="headerlink" title="SHOW WARNINGS的使用"></a>SHOW WARNINGS的使用</h2><p>在MySQL中，SHOW WARNINGS是一个可以查看最近一次执行的语句中产生的警告信息的命令。当MySQL执行语句时，如果发现一些不符合预期的情况，会产生一些警告信息，包括非致命性错误，例如某些类型的数据不能隐式转换或某些数据截断等。</p>
<p>执行SHOW WARNINGS命令时，MySQL会返回警告信息的详细列表，包括：</p>
<ul>
<li>Warning：该警告的类型</li>
<li>Level：该警告的级别，通常为Note、Warning或Error</li>
<li>Code：警告的返回代码</li>
<li>Message：警告信息的内容</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 可以使用<span class="keyword">SELECT</span>的方式来查看最近一次操作的警告信息：</span><br><span class="line"><span class="keyword">SHOW</span> WARNINGS;</span><br><span class="line"># 也可以配合使用<span class="keyword">INSERT</span>、<span class="keyword">UPDATE</span>、<span class="keyword">DELETE</span>、<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>等命令，检查某个具体操作产生的警告信息：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_table (name, age) <span class="keyword">VALUES</span> (<span class="string">&#x27;John Doe&#x27;</span>, <span class="number">150</span>);</span><br><span class="line"><span class="keyword">SHOW</span> WARNINGS;</span><br></pre></td></tr></table></figure>

<h2 id="EXPLAIN-ANALYZE命令"><a href="#EXPLAIN-ANALYZE命令" class="headerlink" title="EXPLAIN ANALYZE命令"></a>EXPLAIN ANALYZE命令</h2><p>MySQL 8.0引入了explain analyze命令，相比explain，它提供的是实际的查询计划，而explain提供的是预估查询计划。</p>
<p><strong>explain和explain analyze的区别：</strong></p>
<ul>
<li><strong>explain：</strong>只生成执行计划，不实际执行</li>
<li><strong>explain analyze：</strong>生成执行计划，并实际执行sql</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 分析人员表联查部门表</span><br><span class="line">EXPLAIN ANALYZE</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> personnel p <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> department d <span class="keyword">on</span> p.department<span class="operator">=</span>d.id</span><br><span class="line"># 查询计划结果</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> Nested loop <span class="keyword">left</span> <span class="keyword">join</span>  (cost<span class="operator">=</span><span class="number">915.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1980</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.333</span>.<span class="number">.14</span><span class="number">.500</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2453</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Table</span> scan <span class="keyword">on</span> p  (cost<span class="operator">=</span><span class="number">222.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1980</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.283</span>.<span class="number">.8</span><span class="number">.625</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2453</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Filter</span>: (p.DEPARTMENT <span class="operator">=</span> d.ID)  (cost<span class="operator">=</span><span class="number">0.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.002</span>.<span class="number">.0</span><span class="number">.002</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">2453</span>)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> Single<span class="operator">-</span><span class="type">row</span> index lookup <span class="keyword">on</span> d <span class="keyword">using</span> <span class="keyword">PRIMARY</span> (ID<span class="operator">=</span>p.DEPARTMENT)  (cost<span class="operator">=</span><span class="number">0.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.002</span>.<span class="number">.0</span><span class="number">.002</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">2453</span>)</span><br></pre></td></tr></table></figure>

<p><strong>结果分析</strong>：</p>
<p><strong>第一行：</strong>Nested loop left join  (cost=915.25 rows=1980) (actual time=0.333..14.500 rows=2453 loops=1)</p>
<ul>
<li><strong>Nested loop left join:</strong> 执行的最外层操作，表示使用嵌套循环的左连接。</li>
<li><strong>成本估计</strong>: (cost=915.25 rows=1980)：预计消耗915.25ms并返回1980行。</li>
<li><strong>实际时间</strong>: (actual time=0.333..14.500 rows=2453 loops=1)：实际读取第一行平均花费0.333ms，返回所有行平均花费14.500ms，共循环调用该迭代器1次，返回2453行。</li>
</ul>
<p><strong>第二行：</strong>Table scan on p  (cost=222.25 rows=1980) (actual time=0.283..8.625 rows=2453 loops=1)</p>
<ul>
<li><strong>Table scan on p:</strong> 对人员表的全表扫描。</li>
<li><strong>成本估计</strong>: (cost=222.25 rows=1980)：预计消耗222.25ms并返回1980行。</li>
<li><strong>实际时间</strong>: (actual time=0.283..8.625 rows=2453 loops=1)：实际读取第一行平均花费0.283ms，返回所有行平均花费8.625ms，共循环调用该迭代器1次，返回2453行。</li>
</ul>
<p><strong>第三行：</strong>Filter: (p.DEPARTMENT = d.ID)  (cost=0.25 rows=1) (actual time=0.002..0.002 rows=1 loops=2453)</p>
<ul>
<li><p><strong>Filter: (p.DEPARTMENT = d.ID):</strong> 执行对 md_gams_jc_department 表中 p.DEPARTMENT = d.ID 条件的过滤操作。</p>
</li>
<li><p><strong>成本估计</strong>: (cost=0.25 rows=1)：预计消耗0.25ms并返回1行。</p>
</li>
<li><p><strong>实际时间</strong>: (actual time=0.002..0.002 rows=1 loops=2453)：过滤操作平均花费0.002ms，共循环调用该迭代器2453次，返回1行。</p>
</li>
</ul>
<p><strong>第四行：</strong>Single-row index lookup on d using PRIMARY …… (actual time=0.002..0.002 rows=1 loops=2453)</p>
<ul>
<li><strong>Single-row index lookup on d using PRIMARY (ID=p.DEPARTMENT):</strong> 对部门表使用主键索引进行单行查找，其中 ID=p.DEPARTMENT。</li>
<li><strong>成本估计</strong>: (cost=0.25 rows=1)：预计消耗0.25ms并返回1行。</li>
<li><strong>实际时间</strong>: (actual time=0.002..0.002 rows=1 loops=2453)：查找操作平均花费0.002ms，共循环调用该迭代器2453次，返回1行。</li>
</ul>
<hr>
<h1 id="分析优化器执行计划：trace"><a href="#分析优化器执行计划：trace" class="headerlink" title="分析优化器执行计划：trace"></a>分析优化器执行计划：trace</h1><p>在MySQL中，可以使用trace命令来进行优化器执行计划的跟踪和分析。trace命令可以显示MySQL优化器在生成执行计划时所采取的决策，包括哪些表被处理，以及使用哪些索引、算法等。</p>
<p>使用trace命令需要先启用<code>general_log</code>和<code>performance_schema</code>两个系统变量，其次需要使用SET语句来设置一些参数，例如<code>trace-unique-check、trace-max-protocol、trace-protocol、trace-feature、trace-feature-check</code>等。设置完成后，可以通过<code>SET global trace_format=&#39;json&#39;</code>语句来选择输出结果的格式。</p>
<p>下面是对使用trace命令的一个简单示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>设置参数：</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_feature <span class="operator">=</span> <span class="string">&#x27;qa&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@max</span>_execution_time<span class="operator">=</span><span class="number">50000</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_level <span class="operator">=</span> <span class="string">&#x27;+ddl,+engine&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_feature_check <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_unique_check <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_protocol <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_max_protocol <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"># <span class="number">2.</span>启用general_log和performance_schema：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> performance_schema <span class="operator">=</span> <span class="keyword">on</span>;</span><br><span class="line"># <span class="number">3.</span>执行查询并查看结果：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> my_table</span><br><span class="line"><span class="keyword">WHERE</span> my_column <span class="operator">=</span> <span class="string">&#x27;some_value&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> SESSION STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Last_Query_Plan&#x27;</span>;</span><br><span class="line"># <span class="number">4.</span>关闭general_log和performance_schema：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> general_log <span class="operator">=</span> off;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> performance_schema <span class="operator">=</span> off;</span><br></pre></td></tr></table></figure>

<p>在trace输出中，可以看到优化器在执行计划中使用的索引、执行算法、行数估计等细节信息。通过分析trace结果，可以找到一些性能问题的根源，并进行相应的调整和优化。但要注意，trace命令可能会带来额外的性能消耗和IO开销，不应该在生产环境中长期启用。</p>
<hr>
<h1 id="MySQL监控分析视图-sys-schema"><a href="#MySQL监控分析视图-sys-schema" class="headerlink" title="MySQL监控分析视图-sys schema"></a>MySQL监控分析视图-sys schema</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>MySQL在8.0版本引入了sys schema，该模式包含用于监视和分析MySQL服务器性能的视图和函数。sys schema提供了一组易于使用的视图和函数，可以帮助我们更好地理解和分析MySQL数据库的行为和性能。</p>
<p>以下是sys schema中一些常用的监控分析视图：</p>
<ul>
<li><p>sys.statements_with_sorting: 显示哪些语句使用了排序操作，包括使用哪些排序操作、每个语句排序次数及排序操作的资源消耗。</p>
</li>
<li><p>sys.statements_with_runtimes_in_95th_percentile`: 显示执行时间最长的语句。</p>
</li>
<li><p>sys.io_global_by_file_by_bytes: 显示每个文件的磁盘IO字节数，可以用来检测IO瓶颈。</p>
</li>
<li><p>sys.memory_by_host_by_current_bytes: 显示每个客户端的当前内存使用情况，可以用于检测内存泄漏或内存占用高的情况。</p>
</li>
<li><p>sys.waits_global_by_latency: 显示哪些等待操作最耗费时间，可以帮助我们找到性能问题的瓶颈所在。</p>
</li>
<li><p>sys.processlist: 显示当前正在运行的线程和进程的信息，包括执行的语句、查询ID、用户、主机、线程ID和状态等信息。</p>
</li>
</ul>
<p><strong>sys schema</strong>中的视图和函数提供了更深入的MySQL性能分析和监控功能，可以帮助我们更好地理解MySQL数据库的行为和性能瓶颈。 </p>
<ol>
<li><strong>主机相关</strong>：以host_summary开头，主要汇总了IO延迟的信息。</li>
<li><strong>Innodb相关</strong>：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。</li>
<li><strong>I/o相关</strong>：以io开头，汇总了等待I/O、I/O使用量情况。</li>
<li><strong>内存使用情况</strong>：以memory开头，从主机、线程、事件等角度展示内存的使用情况</li>
<li><strong>连接与会话信息</strong>：processlist和session相关视图，总结了会话相关信息。</li>
<li><strong>表相关</strong>：以schema_table开头的视图，展示了表的统计信息。</li>
<li><strong>索引信息</strong>：统计了索引的使用情况，包含冗余索引和未使用的索引情况。</li>
<li><strong>语句相关</strong>：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。</li>
<li><strong>用户相关</strong>：以user开头的视图，统计了用户使用的文件I/O、执行语句统计信息。</li>
<li><strong>等待事件相关信息</strong>：以wait开头，展示等待事件的延迟情况。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li><p>索引情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查询冗余索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_redundant_indexes;</span><br><span class="line"># <span class="number">2.</span> 查询未使用过的索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_unused_indexes;</span><br><span class="line"># <span class="number">3.</span> 查询索引的使用情况</span><br><span class="line"><span class="keyword">select</span> index_name,rows_selected,rows_inserted,rows_updated,rows_deleted</span><br><span class="line"><span class="keyword">from</span> sys.schema_index_statistics <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>表相关</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查询表的访问量</span><br><span class="line"><span class="keyword">select</span> table_schema,table_name,<span class="built_in">sum</span>(io_read_requests<span class="operator">+</span>io_write_requests) <span class="keyword">as</span> io </span><br><span class="line"><span class="keyword">from</span> sys.schema_table_statistics <span class="keyword">group</span> <span class="keyword">by</span> table_schema,table_name <span class="keyword">order</span> <span class="keyword">by</span> io <span class="keyword">desc</span>;</span><br><span class="line"># <span class="number">2.</span> 查询占用bufferpool较多的表</span><br><span class="line"><span class="keyword">select</span> object_schema,object_name,allocated,data</span><br><span class="line"><span class="keyword">from</span> sys.innodb_buffer_stats_by_table <span class="keyword">order</span> <span class="keyword">by</span> allocated limit <span class="number">10</span>;</span><br><span class="line"># <span class="number">3.</span> 查看表的全表扫描情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.statements_with_full_table_scans <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>语句相关</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 监控<span class="keyword">SQL</span>执行的频率</span><br><span class="line"><span class="keyword">select</span> db,exec_count,query <span class="keyword">from</span> sys.statement_analysis <span class="keyword">order</span> <span class="keyword">by</span> exec_count <span class="keyword">desc</span>;</span><br><span class="line"># <span class="number">2.</span> 监控使用了排序的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,first_seen,last_seen,query <span class="keyword">from</span> sys.statements_with_sorting limit <span class="number">1</span>;</span><br><span class="line"># <span class="number">3.</span> 监控使用了临时表或者磁盘临时表的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line"><span class="keyword">from</span> sys.statement_analysis <span class="keyword">where</span> tmp_tables<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">or</span> tmp_disk_tables <span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (tmp_tables<span class="operator">+</span>tmp_disk_tables) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>I/O相关</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查看消耗磁盘IO的文件</span><br><span class="line"><span class="keyword">select</span> file,avg_read,avg_write,avg_read<span class="operator">+</span>avg_write <span class="keyword">as</span> avg_io</span><br><span class="line"><span class="keyword">from</span> sys.io_global_by_file_by_bytes <span class="keyword">order</span> <span class="keyword">by</span> avg_read limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>Innodb 相关</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 行锁阻塞情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="MySQL调优"><a href="#MySQL调优" class="headerlink" title="MySQL调优"></a>MySQL调优</h1><h2 id="基础优化"><a href="#基础优化" class="headerlink" title="基础优化"></a>基础优化</h2><h3 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h3><ul>
<li><strong>缓冲池优化：</strong>调整缓冲池大小innodb_buffer_pool_size。</li>
<li><strong>引入内存结构数据库：</strong>例如Redis。</li>
</ul>
<p><strong>提示</strong>：InnoDB使用缓冲池缓存记录和索引</p>
<h4 id="缓冲池优化"><a href="#缓冲池优化" class="headerlink" title="缓冲池优化"></a>缓冲池优化</h4><p><strong>缓冲池：</strong>MySQL的缓冲池被分为多个不同的缓存池，其中包括：</p>
<ul>
<li><strong>查询缓存：</strong>用来缓存查询结果。</li>
<li><strong>InnoDB缓存池：</strong>用来缓存热点表和索引数据页。</li>
<li><strong>MyISAM缓存池：</strong>用来缓存表数据块。</li>
</ul>
<p>缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。</p>
<p><strong>缓冲池的淘汰策略：</strong></p>
<p>LRU算法。MySQL的缓冲池默认使用的是LRU（最近最少使用）淘汰策略，它会优先缓存最近使用的数据。当缓冲池的空间不足时，MySQL会将最不常用的数据从缓冲池中替换出去，以腾出空间缓存新的数据。</p>
<blockquote>
<p><strong>lru算法底层原理：</strong></p>
<p>底层是双向链表（因为经常要移动元素），链表首部是最常使用元素，尾部是最少使用元素。</p>
<p>每次刚访问的数据会移动到链表首部，刚添加的数据也会添加到链表首部。超出maxmemory会淘汰链表尾部元素，它也最长时间没有被使用的数据。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726175640829.png" alt="image-20250726175640829"></p>
</blockquote>
<p><strong>缓冲池相关参数：</strong></p>
<ul>
<li><p><strong>MyISAM缓冲池大小：</strong>key_buffer_size：该参数用来设置MyISAM索引的缓存大小。如果应用程序中涉及到大量的索引查询，可以适当提高该值。一般来说，key_buffer_size占用总内存的1/4到1/3比较合适。</p>
</li>
<li><p><strong>InnoDB缓冲池大小：</strong>innodb_buffer_pool_size：该参数用来设置InnoDB缓冲池的大小。<strong>InnoDB</strong>存储引擎使用<strong>缓冲池来缓存数据和索引文件</strong>。如果InnoDB表的读写频次较高，建议将该值设置为物理内存的70%到80%。</p>
</li>
<li><p><strong>排序缓冲区大小：</strong>sort_buffer_size：该参数用来设置排序缓冲区大小。如果查询中涉及到ORDER BY或GROUP BY操作，可以适当提高该值。一般来说，sort_buffer_size占用总内存的1/4到1/3比较合适。</p>
</li>
<li><p><strong>读取缓冲区大小：</strong>read_buffer_size和read_rnd_buffer_size：这两个参数是用来设置读取缓冲区大小的，默认值为128 KB。如果应用程序中经常进行大文件的读取操作，可以适当提高这两个参数。</p>
</li>
<li><p><strong>binlog大小：</strong>binlog_cache_size：该参数是用来设置二进制日志的缓存大小。如果应用程序中需要持久化一些数据，可以开启二进制日志，并适当调整该参数。</p>
</li>
</ul>
<p><strong>参数配置方法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>查看当前缓冲池参数：</span><br><span class="line"><span class="keyword">show</span> VARIABLES  <span class="keyword">like</span> <span class="string">&#x27;key_buffer_size&#x27;</span>;</span><br><span class="line"># <span class="number">2.</span>修改缓冲池参数：</span><br><span class="line"># <span class="number">2.1</span> 在运行中的MySQL实例中临时设置这个值（这不会持久保存，重启后会失效）：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> key_buffer_size <span class="operator">=</span> <span class="number">67108864</span>;  <span class="comment">-- 64MB</span></span><br><span class="line"># 在MySQL配置文件（通常是 my.cnf 或 my.ini）中进行更改，然后重启MySQL服务使更改生效：</span><br><span class="line">[mysqld]</span><br><span class="line">key_buffer_size <span class="operator">=</span> <span class="number">64</span>M</span><br></pre></td></tr></table></figure>



<h4 id="Redis优化"><a href="#Redis优化" class="headerlink" title="Redis优化"></a>Redis优化</h4><p>Redis是一个基于内存的NoSQL数据库，MySQL是一个基于磁盘的关系型数据库。内存的读写速度是远高于磁盘的，所以对于一些多读少写的热点数据，搭配Redis存储数据，可以极大地提高数据的访问速度。</p>
<blockquote>
<p>参考文章：<a href="/2025/07/26/database/db-redis/">Redis</a></p>
</blockquote>
<h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><p>服务器加内存条、升级SSD固态硬盘、把磁盘I/O分散在多个设备、配置多处理器。</p>
<h3 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h3><ol>
<li><p>关闭不必要的服务和日志：调优结束关闭慢查询日志；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 临时关闭慢查询日志，如果想永久关闭，需要修改my.ini或my.cnf配置文件</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="string">&#x27;OFF&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>调整最大连接数：max_connections 。MySQL5.5及之后版本默认最大连接数是151，可根据实际场景压测得出合适的最大连接数。</p>
<ul>
<li><p>MySQL5.5 ～ 5.7：默认的最大连接数都是 151，上限为：100000</p>
</li>
<li><p>MySQL5.0 版本：默认的最大连接数为 100，上限为 16384</p>
</li>
<li><p>MySQL8.0 版本: 默认的最大连接数是 151</p>
</li>
<li><p>修改最大链接数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>查看当前最大连接数：</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"># <span class="number">2.</span>临时修改最大连接数（重启后失效）：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_connections <span class="operator">=</span><span class="number">1000</span></span><br><span class="line"># <span class="number">3.</span>永久修改连接数（重启后有效）：</span><br><span class="line"># 在Linux系统中，配置文件通常是<span class="operator">/</span>etc<span class="operator">/</span>my.cnf或<span class="operator">/</span>etc<span class="operator">/</span>mysql<span class="operator">/</span>my.cnf。</span><br><span class="line"># 在Windows系统中，通常是 [安装目录下]\MySQL Server <span class="number">5.7</span>\my.ini。</span><br><span class="line">[mysqld]</span><br><span class="line">max_connections <span class="operator">=</span> <span class="number">1000</span></span><br><span class="line"># Linux，重启</span><br><span class="line">sudo systemctl restart mysql</span><br><span class="line"># windows，服务重启：服务管理器<span class="operator">-</span>搜索MySQL<span class="operator">-</span>重启服务</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>线程池缓存线程数：thread_cache_size，缓存空闲线程，有连接时直接分配该线程处理连接；</p>
</li>
<li><p>缓冲池大小：innodb_buffer_pool_size 。</p>
</li>
</ol>
<h3 id="定期清理垃圾"><a href="#定期清理垃圾" class="headerlink" title="定期清理垃圾"></a>定期清理垃圾</h3><p>对于不再使用的表、数据、日志、缓存等，应该及时清理，避免占用过多的MySQL资源，从而提高MySQL的性能。</p>
<h4 id="清理不再使用的表"><a href="#清理不再使用的表" class="headerlink" title="清理不再使用的表"></a>清理不再使用的表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除这些表：</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line"># 保留表结构但删除所有数据</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="清理过期数据"><a href="#清理过期数据" class="headerlink" title="清理过期数据"></a>清理过期数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 一些场景下，某个时期之前的数据都不再需要，可以清理这些数据</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> createTime <span class="operator">&lt;</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">30</span> <span class="keyword">DAY</span>;</span><br><span class="line"># 创建一个MySQL事件来定期清理过期数据</span><br><span class="line"><span class="keyword">CREATE</span> EVENT clean_up_event</span><br><span class="line"><span class="keyword">ON</span> SCHEDULE <span class="keyword">EVERY</span> <span class="number">1</span> <span class="keyword">DAY</span></span><br><span class="line">DO</span><br><span class="line">  <span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> created_at <span class="operator">&lt;</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">30</span> <span class="keyword">DAY</span>;</span><br></pre></td></tr></table></figure>

<h4 id="清理日志"><a href="#清理日志" class="headerlink" title="清理日志"></a>清理日志</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 清理<span class="number">2023</span>年之前的日志</span><br><span class="line">PURGE <span class="type">BINARY</span> LOGS BEFORE <span class="string">&#x27;2023-01-01 00:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="清理缓存池"><a href="#清理缓存池" class="headerlink" title="清理缓存池"></a>清理缓存池</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RESET QUERY CACHE;</span><br><span class="line"># 或者修改配置文件，禁用查询缓存以避免潜在的性能问题：</span><br><span class="line">[mysqld]</span><br><span class="line">query_cache_type <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">query_cache_size <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h4 id="优化表：OPTIMIZE-TABLE"><a href="#优化表：OPTIMIZE-TABLE" class="headerlink" title="优化表：OPTIMIZE TABLE"></a>优化表：OPTIMIZE TABLE</h4><p>在 MySQL 数据库中，OPTIMIZE TABLE 是一个重要的命令，用于优化表的性能和空间利用。通过重新组织表的存储结构，去除碎片、重建索引，OPTIMIZE TABLE 可以帮助提高查询性能、减少存储空间占用以及减少数据碎片。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure>

<p><strong>优化原理：</strong></p>
<p>删除delete语句留下来的垃圾碎片。使用delete语句删除数据时，delete语句只会将记录的位置或者数据页标记为”可复用”，但是数据库磁盘文件的大小不会改变，即表空间不会被回收，此时使用该命令可以释放空间，压缩数据文件。</p>
<p><strong>底层原理：</strong>执行OPTIMIZE TABLE命令后，MySQL会进行以下几个步骤</p>
<ol>
<li><strong>创建临时表</strong>：MySQL 首先会创建一个与原表结构相同的临时表。</li>
<li><strong>原表数据复制到临时表</strong>：将原表中的数据复制到临时表中。</li>
<li><strong>临时表去碎片</strong>：在数据复制的过程中，MySQL 会对数据进行整理和重组，去除碎片，提高数据的连续性。</li>
<li><strong>删旧表留新表</strong>：当数据复制完成并且表被优化后，MySQL 会删除原表，然后将临时表重命名为原表的名称。</li>
</ol>
<h4 id="分析表：ANALYZE-TABLE"><a href="#分析表：ANALYZE-TABLE" class="headerlink" title="分析表：ANALYZE TABLE"></a>分析表：ANALYZE TABLE</h4><p>MySQL 的Optimizer（优化元件）在优化SQL语句时，首先需要收集一些相关信息，其中就包括表的cardinality（散列程度），它表示某个索引对应的列包含多少个不同的值——如果cardinality大大少于数据的实际散列程度，那么索引就基本失效了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure>

<p><strong>对不同存储引擎的效果：</strong></p>
<ul>
<li><strong>InnoDB：</strong>对 InnoDB 表执行 ANALYZE TABLE 会重新计算表和索引的统计信息，并更新优化器统计信息。</li>
<li><strong>MyISAM：</strong>对 MyISAM 表执行 ANALYZE TABLE 会分析表的关键字分布，并更新索引统计信息。</li>
<li><strong>其他存储引擎：</strong>对其他存储引擎（如 MEMORY 或 ARCHIVE），效果类似，即更新表和索引的统计信息。</li>
</ul>
<h4 id="计划任务清理数据、日志、优化表"><a href="#计划任务清理数据、日志、优化表" class="headerlink" title="计划任务清理数据、日志、优化表"></a>计划任务清理数据、日志、优化表</h4><p>对于以上的清理垃圾方案，可以写一个定时任务，定期统一清理垃圾数据、优化表的存储空间和索引。</p>
<h5 id="方案一：创建cron作业"><a href="#方案一：创建cron作业" class="headerlink" title="方案一：创建cron作业"></a>方案一：创建cron作业</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.编辑crontab</span></span><br><span class="line"><span class="comment"># 使用crontab命令编辑当前用户的cron作业列表。对于系统级别的作业，可以使用sudo运行crontab。</span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="comment"># 或者，为特定用户编辑cron作业：</span></span><br><span class="line">sudo crontab -u username -e</span><br><span class="line"><span class="comment"># 2. 编写cron作业</span></span><br><span class="line"><span class="comment"># 在打开的编辑器中，添加新的cron作业，每行代表一个作业，执行指定路径下的脚本：</span></span><br><span class="line">0 2 * * * /path/to/cleanup_script.sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cron表达式格式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* * * * * command-to-be-executed</span><br><span class="line">- - - - -</span><br><span class="line">| | | | |</span><br><span class="line">| | | | +----- Day of the week (0 - 7) (Sunday=0 or 7)</span><br><span class="line">| | | +------- Month (1 - 12)</span><br><span class="line">| | +--------- Day of the month (1 - 31)</span><br><span class="line">| +----------- Hour (0 - 23)</span><br><span class="line">+------------- Minute (0 - 59)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>示例清理脚本</strong>：/path/to/cleanup_script.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># MySQL credentials</span></span><br><span class="line">USER=<span class="string">&quot;your_username&quot;</span></span><br><span class="line">PASSWORD=<span class="string">&quot;your_password&quot;</span></span><br><span class="line">DATABASE=<span class="string">&quot;your_database&quot;</span></span><br><span class="line"><span class="comment"># 清理过期数据</span></span><br><span class="line">mysql -u <span class="variable">$USER</span> -p<span class="variable">$PASSWORD</span> -e <span class="string">&quot;DELETE FROM table_name WHERE created_at &lt; NOW() - INTERVAL 30 DAY;&quot;</span> <span class="variable">$DATABASE</span></span><br><span class="line"><span class="comment"># 清理二进制日志</span></span><br><span class="line">mysql -u <span class="variable">$USER</span> -p<span class="variable">$PASSWORD</span> -e <span class="string">&quot;PURGE BINARY LOGS BEFORE NOW() - INTERVAL 7 DAY;&quot;</span></span><br><span class="line"><span class="comment"># 优化表</span></span><br><span class="line">mysql -u <span class="variable">$USER</span> -p<span class="variable">$PASSWORD</span> -e <span class="string">&quot;OPTIMIZE TABLE table_name;&quot;</span> <span class="variable">$DATABASE</span></span><br></pre></td></tr></table></figure>

<h5 id="方案二：使用Spring定时任务"><a href="#方案二：使用Spring定时任务" class="headerlink" title="方案二：使用Spring定时任务"></a>方案二：使用Spring定时任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤①：开启定时任务功能，在引导类上开启定时任务功能的开关，使用注解@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootTaskApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Springboot22TaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 步骤②：在task包下定义Bean，在对应要定时执行的操作上方，使用注解@Scheduled定义执行的时间，执行时间的描述方式还是cron表达式</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 具体清理垃圾的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何想对定时任务进行详细配置，可以通过配置文件进行</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">task:</span></span><br><span class="line">       <span class="attr">scheduling:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">           <span class="attr">size:</span> <span class="number">1</span>							 <span class="comment">#任务调度线程池大小 默认 1</span></span><br><span class="line">      <span class="attr">thread-name-prefix:</span> <span class="string">ssm_</span>           <span class="comment">#调度线程名称前缀 默认 scheduling-      </span></span><br><span class="line">        <span class="attr">shutdown:</span></span><br><span class="line">          <span class="attr">await-termination:</span> <span class="literal">false</span>         <span class="comment">#线程池关闭时等待所有任务完成</span></span><br><span class="line">          <span class="attr">await-termination-period:</span> <span class="string">10s</span>     <span class="comment">#调度线程关闭前最大等待时间，确保最后一定关闭</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结</strong></p>
<ol>
<li>spring task需要使用注解@EnableScheduling开启定时任务功能</li>
<li>为定时执行的的任务设置执行周期，描述方式cron表达式</li>
</ol>
</blockquote>
<h3 id="使用合适的存储引擎"><a href="#使用合适的存储引擎" class="headerlink" title="使用合适的存储引擎"></a>使用合适的存储引擎</h3><p>MyISAM：适合读取频繁，写入较少的场景（因为表级锁、B+树叶存地址）</p>
<p>InnoDB：适合并发写入的场景（因为行级锁、B+树叶存记录）。</p>
<h3 id="读写分离与分库分表"><a href="#读写分离与分库分表" class="headerlink" title="读写分离与分库分表"></a>读写分离与分库分表</h3><blockquote>
<p>参考文章：<a href="/2025/07/26/database/db-mysql-5-sharding/">MySQL数据库-表设计优化、读写分离与分库分表</a></p>
</blockquote>
<p><strong>读写分离</strong>：读写分离能有效提高查询性能。主从同步用到bin log和relay log。</p>
<p><strong>分库分表</strong>：数据量级到达千万级以上后，垂直拆分（分库）、水平拆分（分表）、垂直+水平拆分（分库分表）。</p>
<h2 id="表设计优化"><a href="#表设计优化" class="headerlink" title="表设计优化"></a>表设计优化</h2><blockquote>
<p>参考文章：<a href="/2025/07/26/database/db-mysql-5-sharding/">MySQL数据库-表设计优化、读写分离与分库分表</a></p>
</blockquote>
<ol>
<li>混合业务分表、冷热数据分表</li>
<li>联合查询改为中间关系表</li>
<li>遵循三个范式</li>
<li>字段建议非空约束</li>
<li>反范式：使用冗余字段</li>
<li>数据类型优化</li>
</ol>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="索引优化思路"><a href="#索引优化思路" class="headerlink" title="索引优化思路"></a>索引优化思路</h3><p>都有哪些维度可以进行数据库调优？简言之：</p>
<ul>
<li><p>索引失效、没有充分利用到索引——<strong>建立索引</strong></p>
</li>
<li><p>关联查询太多JOIN（设计缺陷或不得已的需求）——<strong>SQL优化</strong></p>
</li>
<li><p>服务器调优及各个参数设置（关闭慢查询日志、缓冲、线程数等）——<strong>调整my.cnf</strong></p>
</li>
<li><p>数据过多——<strong>分库分表</strong></p>
</li>
<li><p><strong>定期清理垃圾：</strong>对于不再使用的表、数据、日志、缓存等，应该及时清理，避免占用过多的MySQL资源，从而提高MySQL的性能。</p>
</li>
<li><p><strong>使用合适的存储引擎：</strong>MyISAM比较适合读取频繁，写入较少的场景（因为表级锁、B+树叶存地址），而InnoDB比较适合并发写入的场景（因为行级锁、B+树叶存记录）。</p>
</li>
</ul>
<p>关于数据库调优的知识非常分散。不同的DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。</p>
<p>虽然SQL查询优化的技术有很多，但是大方向上完全可以分成<strong>物理查询优化</strong>和<strong>逻辑查询优化</strong>两大块。</p>
<ul>
<li><strong>物理查询优化</strong>：<strong>索引</strong>和<strong>表连接方式</strong>等技术来进行优化，这里重点需要掌握索引的使用。</li>
<li><strong>逻辑查询优化</strong>：通过SQL<strong>等价变换</strong>提升查询效率，即换一种查询写法效率可能更高。</li>
</ul>
<h3 id="索引失效的11种情况"><a href="#索引失效的11种情况" class="headerlink" title="索引失效的11种情况"></a>索引失效的11种情况</h3><p><strong>用不用索引，最终都是优化器说了算：</strong></p>
<p>优化器是基于什么的优化器? 基于 **cost开销(CostBaseOptimizer)**，它不是基于规则(Rule-Basedoptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</p>
<h4 id="查询条件相关"><a href="#查询条件相关" class="headerlink" title="查询条件相关"></a>查询条件相关</h4><ul>
<li><p><strong>隐式类型转换</strong>：当查询条件中的数据类型与索引列的数据类型不匹配时，会触发隐式转换，导致索引失效。例如，索引列是<code>varchar</code>类型，查询时使用了数字类型。</p>
</li>
<li><p><strong>左模糊匹配</strong>：使用<code>like</code>语句进行模糊查询时，如果通配符<code>%</code>在最左边，无法利用索引的有序性，索引失效。如<code>select * from users where name like &#39;%张%&#39;</code>。</p>
</li>
<li><p><strong>索引列参与运算</strong>：对索引列进行运算，如<code>age + 1 &gt; 30</code>，数据库需对每行数据计算后才能比较，无法直接利用索引，索引失效。</p>
</li>
<li><p><strong>函数操作索引字段</strong>：在查询条件中对索引列使用函数，如<code>date_format(created_at, &#39;%y-%m&#39;)</code>，函数转换会破坏索引的有序性，导致索引失效。</p>
</li>
<li><p><strong>最左前缀原则违反</strong>：对于联合索引，必须从左到右连续使用，即最左优先，否则索引失效。</p>
<p><strong>结论</strong>：MySQL可以为多个字段创建索引，一个索引可以包含16个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong>。</p>
<p><strong>例如</strong>：联合索引<code>(country, city, age)</code>，查询条件为<code>city=&#39;北京&#39; and age&gt;25</code>，跳过了第一个字段<code>country</code>字段，索引失效。</p>
</li>
<li><p><strong>范围条件右边的列索引失效</strong>：（a,b,c）联合索引，查询条件a,b,c，如果b使用了范围查询，那么b右边的c索引失效。这里右边看的联合索引的键右边。</p>
<p><strong>解决办法</strong>：新建联合索引（a,c,b）或（c,a,b），把需要范围查询的字段放在最后</p>
<p><strong>范围包括</strong>：(&lt;) (&lt;=) (&gt;) (&gt;=) 和 between。</p>
</li>
<li><p><strong>or连接非索引字段</strong>：<code>or</code>条件要求所有涉及的列都有索引，否则索引失效。如<code>select * from users where age=25 or address=&#39;北京&#39;</code>，<code>address</code>无索引。</p>
</li>
<li><p><strong>使用不等号（!= / &lt;&gt;）</strong>：因为“不等于”不能精准匹配，全表扫描二级索引树再回表效率不如直接全表扫描聚簇索引树。使用不等号进行查询时，如果需要扫描大部分数据，优化器可能会放弃索引。如<code>select * from orders where status != &#39;completed&#39;</code>。</p>
</li>
<li><p><strong>索引选择性过低</strong>：当索引列的值过于重复，区分度低于30%时，优化器可能认为全表扫描更高效，从而放弃使用索引。</p>
</li>
</ul>
<h4 id="查询操作相关"><a href="#查询操作相关" class="headerlink" title="查询操作相关"></a>查询操作相关</h4><ul>
<li><strong>使用not in / not exists</strong>：<code>not in</code>和<code>not exists</code>操作符在某些情况下会导致索引失效，尤其是当查询结果集较大时。如<code>select * from user where id not in (1,2,3)</code>。</li>
<li><strong>使用is null / is not null</strong>：虽然<code>is null</code>或<code>is not null</code>条件可以使用索引，但如果索引列中的数据分布不均匀，查询可能仍然会导致索引失效，特别是在大数据量的情况下。</li>
<li><strong>全表扫描更快的情况</strong>：当查询结果超过表总行数的30%时，MySQL可能会认为全表扫描比索引查询更快，从而选择全表扫描。</li>
<li><strong>使用distinct</strong>：在某些情况下，<code>distinct</code>查询可能会导致MySQL不使用索引，尤其是在查询中涉及多个字段时。</li>
</ul>
<h4 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h4><ul>
<li><p><strong>排序顺序不同</strong>：<code>order by</code>中的字段与<code>where</code>条件中的字段不一致时，可能会导致索引失效。如<code>select id_no,name,email from db_staff where id_no &gt; &#39;110112202409881120&#39; order by create_time</code>。</p>
</li>
<li><p><strong>查询不在索引范围内</strong>：如果查询条件不在索引覆盖范围内，索引失效。如<code>select * from test_001 where user_age = 2500</code>。</p>
</li>
<li><p><strong>不同字符集导致索引失败，建议utf8mb4</strong>：不同的字符集进行比较前需要进行<strong>转换</strong>会造成索引失效。</p>
<p>数据库和表的字符集统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，可以<strong>避免由于字符集转换产生的乱码</strong>。</p>
</li>
<li><p><strong>主键插入顺序尽量自增</strong></p>
<p>对于使用 InnoDB 存储引擎的表来说，在没有显式的创建索引时，表中的数据实际上都是存储在<strong>聚簇索引的叶子节点</strong>的。而记录又是存储在数据页中的，数据页和记录又是按照记录<strong>主键值从小到大</strong>的顺序进行排序。所以如果 插入 的记录的 主键值是依次增大 的话，那每插满一个数据页就换到下一个数据页继续插，而插入的<strong>主键值忽大忽小</strong>的话，假设某个数据页存储的记录已经满了，再插入数据就需要把当前 <strong>页面分裂</strong> 成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着 <strong>性能损耗</strong> ！</p>
<p><strong>建议</strong>：让主键 <strong><code>AUTO_INCREMENT</code></strong> ，插入数据时存储引擎会自动填入自增主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p>
</li>
</ul>
<h3 id="遵循索引设计原则"><a href="#遵循索引设计原则" class="headerlink" title="遵循索引设计原则"></a>遵循索引设计原则</h3><ol>
<li><p>命名：索引的字段个数尽量别超过5个，命名格式“idx_col1_col2”</p>
</li>
<li><p>在频繁查询（特别是分组、范围、排序查询）的列建立索引；</p>
</li>
<li><p>频繁更新的表，不要创建过多索引</p>
</li>
<li><p>唯一特性的字段，适合创建索引；</p>
</li>
<li><p>很长的varchar字段，适合根据区分度和长度创建前缀索引；</p>
</li>
<li><p>多个字段都要创建索引时，联合索引优于单值索引；</p>
</li>
<li><p>避免创建过多索引，避免索引失效；</p>
</li>
<li><p><strong>尽量用有序的字段作为主键索引</strong>：防止乱序时新主键前移到已满的数据页，导致插入后分裂数据页，造成性能损耗； </p>
</li>
</ol>
<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><blockquote>
<p>参考文章：<a href="/2025/07/26/database/db-mysql-6-query/">MySQL数据库-查询优化</a></p>
</blockquote>
<ol>
<li>连接查询优化<ol>
<li>优化方案</li>
<li>左外连接：优先右表创建索引，连接字段类型要一致</li>
<li>内连接：驱动表由数据量和索引决定</li>
<li>join语句原理</li>
</ol>
</li>
<li>子查询优化<ol>
<li>子查询优化成关联查询</li>
<li>多次查询代替子查询</li>
<li>临时表代替子查询</li>
</ol>
</li>
<li>排序优化<ol>
<li>排序优化建议</li>
<li>范围查询时索引字段选择</li>
<li>filesort 算法</li>
</ol>
</li>
<li>分组优化</li>
<li>分页查询优化<ol>
<li>深分页查询优化</li>
<li>带排序的深分页优化</li>
</ol>
</li>
</ol>
<h3 id="尽量覆盖索引"><a href="#尽量覆盖索引" class="headerlink" title="尽量覆盖索引"></a>尽量覆盖索引</h3><blockquote>
<p><strong>详细请参考：</strong><a href="/2025/07/25/database/db-mysql-3-index/">MySQL数据库-索引</a></p>
</blockquote>
<h3 id="字符串前缀索引"><a href="#字符串前缀索引" class="headerlink" title="字符串前缀索引"></a>字符串前缀索引</h3><blockquote>
<p><strong>详细请参考：</strong><a href="/2025/07/25/database/db-mysql-3-index/">MySQL数据库-索引</a></p>
</blockquote>
<h3 id="尽量使用索引下推"><a href="#尽量使用索引下推" class="headerlink" title="尽量使用索引下推"></a>尽量使用索引下推</h3><blockquote>
<p><strong>详细请参考：</strong><a href="/2025/07/25/database/db-mysql-3-index/">MySQL数据库-索引</a></p>
</blockquote>
<p>MySQL5.6支持。一个索引包含了满足查询结果的数据。因为不需要回表，故查询效率高。覆盖索引时<strong>左模糊和不等于</strong>不能让索引失效。</p>
<h3 id="写多读少时尽量用普通索引"><a href="#写多读少时尽量用普通索引" class="headerlink" title="写多读少时尽量用普通索引"></a>写多读少时尽量用普通索引</h3><p>查询时普通索引和唯一索引效率差不多；更新时普通索引效率更高，因为有change buffer（写缓存）将更新后的数据页缓存到内存，下次访问时或后台定期会执行merge操作，将该数据页写入磁盘。change buffer在事务提交时会写入redo log，保证数据持久化。</p>
<p><strong>普通索引</strong>：不加任何限制条件，如create index idx_name on student(name)。</p>
<p><strong>唯一索引</strong>：UNIQUE参数限制索引唯一，如create UNIQUE index idx_name on student(name)。</p>
<blockquote>
<p><strong>详细请参考：</strong><a href="/2025/07/25/database/db-mysql-3-index/">MySQL数据库-索引</a></p>
</blockquote>
<hr>
<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="EXISTS-和-IN-的区分"><a href="#EXISTS-和-IN-的区分" class="headerlink" title="EXISTS 和 IN 的区分"></a>EXISTS 和 IN 的区分</h2><p><strong>问题：</strong>不太理解哪种情况下应该使用 EXISTS，哪种情况应该用 IN。选择的标准是看能否使用表的索引吗？</p>
<p><strong>回答：</strong>索引是个前提，其实选择与否还是要看表的大小。可将选择标准理解为 <strong>小表驱动大表</strong>。在这种方式下效率是最高的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 比如下面这样:</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> CC <span class="keyword">IN</span> (<span class="keyword">SELECT</span> CC <span class="keyword">FROM</span> B);                     # 当B小于A</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> CC <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.CC<span class="operator">=</span>A.CC);     # 当A小于B时</span><br><span class="line"># 当A小于B时，用 <span class="keyword">EXISTS</span>。因为 <span class="keyword">EXISTS</span> 的实现，相当于外表循环，实现的逻辑类似于</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> A</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> B</span><br><span class="line">        if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span></span><br><span class="line"># 当B小于A时，用 <span class="keyword">IN</span>。因为实现的逻辑类似于</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> B</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> A</span><br><span class="line">        if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span></span><br></pre></td></tr></table></figure>

<p>遵循小表驱动大表原则，左边表小就是EXISTS，左边表大就用IN。</p>
<p><strong>小表驱动大表是为了减少连接次数</strong>：连接查询的原理是先查左表，再根据连接字段查右表，然后过滤右表的条件。因为相比普通的查询，连接查询要左表右表都查一次，肯定没有只查一次快，所以连接次数越少越好。</p>
<h2 id="建议COUNT-或COUNT-1"><a href="#建议COUNT-或COUNT-1" class="headerlink" title="建议COUNT(*)或COUNT(1)"></a>建议COUNT(*)或COUNT(1)</h2><p>**统计行数尽量用COUNT(1),COUNT(*)**：这时查询优化器会优先选用有索引的、占用空间最小的二级索引树进行统计，只有找不到非聚簇索引树时采用使用聚簇索引树统计，空间占用大。当然也能COUNT(最小空间二级索引字段)，但麻烦不如交给优化器自动选择。</p>
<p>问：在 MySQL 中统计数据表的行数，可以使用三种方式： SELECT COUNT(*) 、 SELECT COUNT(1) 和 SELECT COUNT(具体字段) ，使用这三者之间的查询效率是怎样的？</p>
<p>答：如果要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。</p>
<ul>
<li><p><strong>count（1）：</strong>统计整个表的记录行数。括号里表示一个固定值，可以是任何固定的数字字符，是个常量。在InnoDB存储引擎中，查询优化器会优先选择占用空间最小的二级索引树进行统计。COUNT(*) 和COUNT(1)都是对所有结果进行COUNT(*)，两者<strong>本质上没有区别</strong>，性能上也没有显著差别，因为优化器会处理为相同的查询计划。。有 WHERE 子句是对所有符合筛选条件的数据行进行统计，没有 WHERE子句，则是对数据表的数据行数进行统计。</p>
</li>
<li><p><strong>count（*）：</strong>统计整个表的记录行数，与count（1）执行结果相同，但是执行会根据目标表的不同进行优化。</p>
</li>
<li><p><strong>count（列名）：</strong>统计某一列的非空记录数。它会统计指定列中不为NULL的行数，忽略NULL值。</p>
</li>
<li><p><strong>count(distinct(列名)) ：</strong>统计某一列的非空去重记录数。其实是 count(列名) + distinct 的结果集，指定列不为NULL，并且在字段值重复的情况下只统计一次</p>
</li>
</ul>
<p><strong>MylSAM 统计只需O(1)：</strong>如果是 <strong>MylSAM 存储引擎，统计数据表的行数只需要 O(1)的复杂度</strong>，因为每张 MyISAM 的数据表都有一个 meta 信息存储了 <strong>row_count 值</strong>，而一致性则由表级锁来保证。 如果是InnoDB 存储引擎，因为<strong>innoDB</strong> 支持事务，采用行级锁和 MVCC机制，无法像 MyISAM 维护1个row_count变量，因此<strong>需要采用扫描全表，是O(n)的复杂度</strong>，进行循环+计数的方式来完成统计。</p>
<p><strong>选择建议：</strong>在ImnoDB中，如果采用<strong>COUNT(具体字段)<strong>来统计数据行数，要</strong>尽量采用二级索引</strong>。因为主键是聚簇索引，聚簇索引叶节点包含整个记录，统计时要加载到内存的数据量更大，性能就差一点。对于COUNT(*)和 COUNT(1)来说，它们不需要查找具体的行，只是统计行数，<strong>系统会自动采用占用空间更小的二级索引来进行统计</strong>。 如果有多个二级索引，会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p>
<h2 id="建议SELECT-字段-而不是SELECT"><a href="#建议SELECT-字段-而不是SELECT" class="headerlink" title="建议SELECT(字段)而不是SELECT(*)"></a>建议SELECT(字段)而不是SELECT(*)</h2><p>在表查询中，建议明确字段，不要使用 <code>*</code> 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。<strong>原因</strong>：</p>
<ol>
<li>MySQL 在解析的过程中，会通过查询数据字典<strong>将<code>*</code>按序转换成所有列名</strong>，会大大耗费资源和时间。</li>
<li>无法使用覆盖索引</li>
</ol>
<blockquote>
<p><strong>数据库引擎的查询流程：</strong>参考文章<a href="/2025/07/26/database/db-mysql-6-query/">MySQL数据库-查询优化</a></p>
</blockquote>
<h2 id="LIMIT-1-对优化的影响"><a href="#LIMIT-1-对优化的影响" class="headerlink" title="LIMIT 1 对优化的影响"></a>LIMIT 1 对优化的影响</h2><p>针对的是<strong>会扫描全表的 SQL 语句</strong>，如果可以<strong>确定结果集只有一条</strong>，加上 LIMIT 1 时，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p>
<p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 LIMIT 1 了。</p>
<h2 id="全表扫描时尽量用“LIMIT”"><a href="#全表扫描时尽量用“LIMIT”" class="headerlink" title="全表扫描时尽量用“LIMIT”"></a>全表扫描时尽量用“LIMIT”</h2><p>当进行全表扫描并且明确时，使用LIMIT可以在达到指定数量后停止扫描，减少不必要的开销。</p>
<p>例如根据学号查询学生，根据身份证号查询人，根据订单号查询订单，当我们明确知道需要精准查询时，用Limit 1 总错不了。</p>
<p>当然如果走了唯一索引，就无需用limit了，查到对应记录会直接返回；如果走了普通索引，并且对应记录重复数据很多的话，用limit也会提高一些性能。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 根据学号（假设学号是按班级隔离的）和班级号精准查询学生</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">where</span> stuno <span class="operator">=</span><span class="number">23</span> <span class="keyword">and</span> classid<span class="operator">=</span><span class="number">1</span> LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="使用limit-N，少用limit-M，N"><a href="#使用limit-N，少用limit-M，N" class="headerlink" title="使用limit N，少用limit M，N"></a>使用limit N，少用limit M，N</h2><p><strong>避免大偏移量的LIMIT</strong>：在大表或M值较大时，LIMIT M, N的性能较差，因为需要扫描并丢弃前M条记录。可以通过记录上次查询的最大ID来优化分页。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> large_table <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> last_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="将长事务拆为多个小事务"><a href="#将长事务拆为多个小事务" class="headerlink" title="将长事务拆为多个小事务"></a>将长事务拆为多个小事务</h2><ul>
<li><p><strong>提交事务可以释放的资源</strong>：回滚段上用于恢复数据的信息、锁、redo / undo log buffer 中的空间。</p>
</li>
<li><p><strong>多使用COMMIT</strong>：长事务会持有锁和占用资源较长时间，拆分为小事务并频繁COMMIT可以释放锁、减少资源占用。</p>
</li>
</ul>
<p>尽量多使用 COMMIT，用编程式事务而不是声明式事务，降低事务粒度。<strong>示例：</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.查询a</span></span><br><span class="line">    <span class="comment">// 2.查询b</span></span><br><span class="line">    <span class="comment">// 3.数据处理</span></span><br><span class="line">    <span class="comment">// 4.保存c表</span></span><br><span class="line">    <span class="comment">// 5.保存b表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.查询a</span></span><br><span class="line">    <span class="comment">// 2.查询b</span></span><br><span class="line">    <span class="comment">// 3.数据处理</span></span><br><span class="line">    <span class="comment">// 4.落库</span></span><br><span class="line">    savaFun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">savaFun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.保存c表</span></span><br><span class="line">    <span class="comment">// 2.保存d表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="先查再删改"><a href="#先查再删改" class="headerlink" title="先查再删改"></a>先查再删改</h2><p>UPDATE、DELETE语句一定要有明确的WHERE条件。</p>
<p><strong>确保WHERE条件明确</strong>：在执行UPDATE或DELETE操作前，先SELECT一下并不会让性能变差，它可以确保有明确的WHERE条件，避免误操作和全表扫描。</p>
<h2 id="尽量UNION-ALL而不是UNION"><a href="#尽量UNION-ALL而不是UNION" class="headerlink" title="尽量UNION ALL而不是UNION"></a>尽量UNION ALL而不是UNION</h2><p><strong>UNION ALL</strong>：UNION ALL 和 UNION 都用于组合两个或多个查询结果集。UNION ALL在组合时，<strong>不进行去重操作</strong>，比UNION更快，适用于不需要去重的场景。</p>
<h2 id="多使用COMMIT"><a href="#多使用COMMIT" class="headerlink" title="多使用COMMIT"></a>多使用COMMIT</h2><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p>
<p>COMMIT 所释放的资源：</p>
<ul>
<li>回滚段上用于恢复数据的信息</li>
<li>被程序语句获得的锁</li>
<li><code>redo / undo log buffer</code> 中的空间</li>
<li>管理上述 3 种资源中的内部花费</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://southernfish.github.io">Southern Fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://southernfish.github.io/2025/07/26/database/db-mysql-4-optimize/">https://southernfish.github.io/2025/07/26/database/db-mysql-4-optimize/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://southernfish.github.io" target="_blank">Southern Fish</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="/img/article/article1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/26/database/db-mysql-6-query/"><img class="prev-cover" src="/img/article/article5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL数据库-查询优化</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/26/database/db-redis/"><img class="next-cover" src="/img/article/article1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/07/26/database/db-mysql-5-sharding/" title="MySQL数据库-表设计优化、读写分离与分库分表"><img class="cover" src="/img/article/article4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="title">MySQL数据库-表设计优化、读写分离与分库分表</div></div></a></div><div><a href="/2025/06/24/database/db-innodb/" title="InnoDB + MVCC"><img class="cover" src="/img/article/article5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-24</div><div class="title">InnoDB + MVCC</div></div></a></div><div><a href="/2025/07/24/database/db-mysql-2-engine/" title="MySQL数据库-存储引擎和索引"><img class="cover" src="/img/article/article2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-24</div><div class="title">MySQL数据库-存储引擎和索引</div></div></a></div><div><a href="/2025/07/25/database/db-mysql-3-index/" title="MySQL数据库-索引"><img class="cover" src="/img/article/article2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="title">MySQL数据库-索引</div></div></a></div><div><a href="/2025/07/26/database/db-mysql-6-query/" title="MySQL数据库-查询优化"><img class="cover" src="/img/article/article5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="title">MySQL数据库-查询优化</div></div></a></div><div><a href="/2025/07/24/database/db-mysql-1-conception/" title="MySQL数据库-概述"><img class="cover" src="/img/article/article4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-24</div><div class="title">MySQL数据库-概述</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southern Fish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SouthernFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1002721576@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">天下事岂能尽如吾意，心境须恰适，尽其在我，随遇而安。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.</span> <span class="toc-text">数据库服务器的优化步骤</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">查看系统性能参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SHOW-STATUS-LIKE-%E2%80%98%E5%8F%82%E6%95%B0%E2%80%99"><span class="toc-number">2.1.</span> <span class="toc-text">SHOW STATUS  LIKE ‘参数’</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BSQL%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%88%90%E6%9C%AC"><span class="toc-number">2.2.</span> <span class="toc-text">查看SQL的查询成本</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E6%89%A7%E8%A1%8C%E6%85%A2%E7%9A%84-SQL%EF%BC%9A%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">3.</span> <span class="toc-text">定位执行慢的 SQL：慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6"><span class="toc-number">3.2.</span> <span class="toc-text">监控报警</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">开启慢查询日志参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%AC%A1%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">查看慢查询次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9Amysqldumpslow"><span class="toc-number">3.5.</span> <span class="toc-text">慢查询日志分析工具：mysqldumpslow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">3.6.</span> <span class="toc-text">关闭慢查询日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">3.7.</span> <span class="toc-text">删除慢查询日志</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E3%80%81%E6%9F%A5%E7%9C%8B-SQL-%E6%89%A7%E8%A1%8C%E6%88%90%E6%9C%AC%EF%BC%9Ashow-profile"><span class="toc-number">4.</span> <span class="toc-text">定位慢查询语句、查看 SQL 执行成本：show profile</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%A1%A8%EF%BC%9AEXPLAIN"><span class="toc-number">5.</span> <span class="toc-text">执行计划表：EXPLAIN</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%A1%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.3.</span> <span class="toc-text">执行计划表介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%90%84%E4%B8%AA%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89"><span class="toc-number">5.3.1.</span> <span class="toc-text">执行计划各个列的作用（概述）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.3.2.</span> <span class="toc-text">详细介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select-type"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">select_type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#key"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#type"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Extra"><span class="toc-number">5.3.2.4.</span> <span class="toc-text">Extra</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXPLAIN%E5%9B%9B%E7%A7%8D%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">EXPLAIN四种输出格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SHOW-WARNINGS%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.5.</span> <span class="toc-text">SHOW WARNINGS的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXPLAIN-ANALYZE%E5%91%BD%E4%BB%A4"><span class="toc-number">5.6.</span> <span class="toc-text">EXPLAIN ANALYZE命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E5%99%A8%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%9Atrace"><span class="toc-number">6.</span> <span class="toc-text">分析优化器执行计划：trace</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E7%9B%91%E6%8E%A7%E5%88%86%E6%9E%90%E8%A7%86%E5%9B%BE-sys-schema"><span class="toc-number">7.</span> <span class="toc-text">MySQL监控分析视图-sys schema</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">7.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E8%B0%83%E4%BC%98"><span class="toc-number">8.</span> <span class="toc-text">MySQL调优</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BC%98%E5%8C%96"><span class="toc-number">8.1.</span> <span class="toc-text">基础优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">8.1.1.</span> <span class="toc-text">缓存优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0%E4%BC%98%E5%8C%96"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">缓冲池优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%BC%98%E5%8C%96"><span class="toc-number">8.1.1.2.</span> <span class="toc-text">Redis优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-number">8.1.2.</span> <span class="toc-text">硬件优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96"><span class="toc-number">8.1.3.</span> <span class="toc-text">参数优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%9C%9F%E6%B8%85%E7%90%86%E5%9E%83%E5%9C%BE"><span class="toc-number">8.1.4.</span> <span class="toc-text">定期清理垃圾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%90%86%E4%B8%8D%E5%86%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A1%A8"><span class="toc-number">8.1.4.1.</span> <span class="toc-text">清理不再使用的表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%90%86%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE"><span class="toc-number">8.1.4.2.</span> <span class="toc-text">清理过期数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%90%86%E6%97%A5%E5%BF%97"><span class="toc-number">8.1.4.3.</span> <span class="toc-text">清理日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-number">8.1.4.4.</span> <span class="toc-text">清理缓存池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E8%A1%A8%EF%BC%9AOPTIMIZE-TABLE"><span class="toc-number">8.1.4.5.</span> <span class="toc-text">优化表：OPTIMIZE TABLE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%A1%A8%EF%BC%9AANALYZE-TABLE"><span class="toc-number">8.1.4.6.</span> <span class="toc-text">分析表：ANALYZE TABLE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E6%B8%85%E7%90%86%E6%95%B0%E6%8D%AE%E3%80%81%E6%97%A5%E5%BF%97%E3%80%81%E4%BC%98%E5%8C%96%E8%A1%A8"><span class="toc-number">8.1.4.7.</span> <span class="toc-text">计划任务清理数据、日志、优化表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E5%88%9B%E5%BB%BAcron%E4%BD%9C%E4%B8%9A"><span class="toc-number">8.1.4.7.1.</span> <span class="toc-text">方案一：创建cron作业</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">8.1.4.7.2.</span> <span class="toc-text">方案二：使用Spring定时任务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">8.1.5.</span> <span class="toc-text">使用合适的存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">8.1.6.</span> <span class="toc-text">读写分离与分库分表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96"><span class="toc-number">8.2.</span> <span class="toc-text">表设计优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">8.3.</span> <span class="toc-text">索引优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-number">8.3.1.</span> <span class="toc-text">索引优化思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%8411%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">8.3.2.</span> <span class="toc-text">索引失效的11种情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E7%9B%B8%E5%85%B3"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">查询条件相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3"><span class="toc-number">8.3.2.2.</span> <span class="toc-text">查询操作相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%83%85%E5%86%B5"><span class="toc-number">8.3.2.3.</span> <span class="toc-text">其他情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%B5%E5%BE%AA%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">8.3.3.</span> <span class="toc-text">遵循索引设计原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">8.4.</span> <span class="toc-text">查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">8.4.1.</span> <span class="toc-text">尽量覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">8.4.2.</span> <span class="toc-text">字符串前缀索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">8.4.3.</span> <span class="toc-text">尽量使用索引下推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%A4%9A%E8%AF%BB%E5%B0%91%E6%97%B6%E5%B0%BD%E9%87%8F%E7%94%A8%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">8.4.4.</span> <span class="toc-text">写多读少时尽量用普通索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EXISTS-%E5%92%8C-IN-%E7%9A%84%E5%8C%BA%E5%88%86"><span class="toc-number">9.1.</span> <span class="toc-text">EXISTS 和 IN 的区分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AECOUNT-%E6%88%96COUNT-1"><span class="toc-number">9.2.</span> <span class="toc-text">建议COUNT(*)或COUNT(1)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AESELECT-%E5%AD%97%E6%AE%B5-%E8%80%8C%E4%B8%8D%E6%98%AFSELECT"><span class="toc-number">9.3.</span> <span class="toc-text">建议SELECT(字段)而不是SELECT(*)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIMIT-1-%E5%AF%B9%E4%BC%98%E5%8C%96%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">9.4.</span> <span class="toc-text">LIMIT 1 对优化的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E6%97%B6%E5%B0%BD%E9%87%8F%E7%94%A8%E2%80%9CLIMIT%E2%80%9D"><span class="toc-number">9.5.</span> <span class="toc-text">全表扫描时尽量用“LIMIT”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8limit-N%EF%BC%8C%E5%B0%91%E7%94%A8limit-M%EF%BC%8CN"><span class="toc-number">9.6.</span> <span class="toc-text">使用limit N，少用limit M，N</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E9%95%BF%E4%BA%8B%E5%8A%A1%E6%8B%86%E4%B8%BA%E5%A4%9A%E4%B8%AA%E5%B0%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">9.7.</span> <span class="toc-text">将长事务拆为多个小事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E6%9F%A5%E5%86%8D%E5%88%A0%E6%94%B9"><span class="toc-number">9.8.</span> <span class="toc-text">先查再删改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BD%E9%87%8FUNION-ALL%E8%80%8C%E4%B8%8D%E6%98%AFUNION"><span class="toc-number">9.9.</span> <span class="toc-text">尽量UNION ALL而不是UNION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%BD%BF%E7%94%A8COMMIT"><span class="toc-number">9.10.</span> <span class="toc-text">多使用COMMIT</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/07/algorithm/simple_algorithm/" title="其他简单算法"><img src="/img/article/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="其他简单算法"/></a><div class="content"><a class="title" href="/2025/08/07/algorithm/simple_algorithm/" title="其他简单算法">其他简单算法</a><time datetime="2025-08-07T07:30:36.000Z" title="发表于 2025-08-07 15:30:36">2025-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/06/algorithm/backtrack-algorithm/" title="回溯算法"><img src="/img/article/article1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="回溯算法"/></a><div class="content"><a class="title" href="/2025/08/06/algorithm/backtrack-algorithm/" title="回溯算法">回溯算法</a><time datetime="2025-08-06T10:30:36.000Z" title="发表于 2025-08-06 18:30:36">2025-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/04/algorithm/greedy-algorithm/" title="贪心算法"><img src="/img/article/article1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="贪心算法"/></a><div class="content"><a class="title" href="/2025/08/04/algorithm/greedy-algorithm/" title="贪心算法">贪心算法</a><time datetime="2025-08-04T07:20:36.000Z" title="发表于 2025-08-04 15:20:36">2025-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/02/algorithm/dynamic-programming/" title="动态规划算法"><img src="/img/article/article6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动态规划算法"/></a><div class="content"><a class="title" href="/2025/08/02/algorithm/dynamic-programming/" title="动态规划算法">动态规划算法</a><time datetime="2025-08-02T06:20:36.000Z" title="发表于 2025-08-02 14:20:36">2025-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/02/algorithm/sliding-window/" title="滑动窗口算法"><img src="/img/article/article6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="滑动窗口算法"/></a><div class="content"><a class="title" href="/2025/08/02/algorithm/sliding-window/" title="滑动窗口算法">滑动窗口算法</a><time datetime="2025-08-02T02:00:36.000Z" title="发表于 2025-08-02 10:00:36">2025-08-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/article/article1.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Southern Fish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>