<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>集合体系 | Southern Fish</title><meta name="keywords" content="java基础"><meta name="author" content="Southern Fish"><meta name="copyright" content="Southern Fish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="集合类是Java数据结构的实现。Java的集合类是java.util包中的重要内容，它允许以各种方式将元素分组，并定义了各种使这些元素更容易操作的方法。Java集合类是Java将一些基本的和使用频率极高的基础类进行封装和增强后再以一个类的形式提供。集合类是可以往里面保存多个对象的类，存放的是对象，不同的集合类有不同的功能和特点，适合不同的场合，用以解决一些实际问题。  原文链接：全网最完整Java">
<meta property="og:type" content="article">
<meta property="og:title" content="集合体系">
<meta property="og:url" content="https://southernfish.github.io/2025/07/23/java/java-base-5-collection/index.html">
<meta property="og:site_name" content="Southern Fish">
<meta property="og:description" content="集合类是Java数据结构的实现。Java的集合类是java.util包中的重要内容，它允许以各种方式将元素分组，并定义了各种使这些元素更容易操作的方法。Java集合类是Java将一些基本的和使用频率极高的基础类进行封装和增强后再以一个类的形式提供。集合类是可以往里面保存多个对象的类，存放的是对象，不同的集合类有不同的功能和特点，适合不同的场合，用以解决一些实际问题。  原文链接：全网最完整Java">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://southernfish.github.io/img/article/article4.png">
<meta property="article:published_time" content="2025-07-23T14:08:36.000Z">
<meta property="article:modified_time" content="2025-07-28T10:51:02.118Z">
<meta property="article:author" content="Southern Fish">
<meta property="article:tag" content="java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://southernfish.github.io/img/article/article4.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://southernfish.github.io/2025/07/23/java/java-base-5-collection/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '集合体系',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-28 18:51:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Southern Fish" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">74</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/article/article4.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Southern Fish</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">集合体系</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-23T14:08:36.000Z" title="发表于 2025-07-23 22:08:36">2025-07-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-28T10:51:02.118Z" title="更新于 2025-07-28 18:51:02">2025-07-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>79分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="集合体系"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>集合类是Java数据结构的实现。Java的集合类是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/java.util/5180624?fromModule=lemma_inlink">java.util</a>包中的重要内容，它允许以各种方式将元素分组，并定义了各种使这些元素更容易操作的方法。Java集合类是Java将一些基本的和使用频率极高的基础类进行封装和增强后再以一个类的形式提供。集合类是可以往里面保存多个对象的类，存放的是对象，不同的集合类有不同的功能和特点，适合不同的场合，用以解决一些实际问题。</p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/article/details/137256095">全网最完整Java学习笔记</a></p>
</blockquote>
<h1 id="集合体系"><a href="#集合体系" class="headerlink" title="集合体系"></a>集合体系</h1><h2 id="集合和映射"><a href="#集合和映射" class="headerlink" title="集合和映射"></a>集合和映射</h2><p>在Java中，集合是一组用于操作和存储数据的接口和类。 它主要包括Collection和Map两种。</p>
<p><strong>集合（Collection）</strong>：一组单独的元素。它通常应用了某种规则，例如 List（列表）必须按特定的顺序容纳元素，而一个Set（集）不可包含任何重复的元素。<br><strong>映射（Map）</strong>：一系列“键－值”对的集合。它的存储内容是一系列键值对，如果知道了键（key），我们可以直接获取到这个键所对应的值（value），时间复杂度是O(1)。散列表是Map的一种较为普遍的展现。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250722172620947.png" alt="image-20250722172620947"></p>
<p>Java中的集合类分为4大类,分别由4个接口来代表,它们是Set、List、Queue、Map。其中,Set、List、Queue接口都继承自Collection接口，Map接口不继承自其他接口。</p>
<p><code>Set</code>代表<strong>无序的、元素不可重复</strong>的集合。</p>
<p><code>List</code>代表<strong>有序的、元素可以重复</strong>的集合。有序说的是元素顺序直接由插入顺序决定。</p>
<p><code>Queue</code>代表<strong>先进先出（FIFO）</strong>的队列。</p>
<p><code>Map</code>代表<strong>具有映射关系（key-value）</strong>的集合。</p>
<p>Java提供了众多集合的实现类，它们都是这些接口的直接或间接的实现类，其中比较常用的有：<code>HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap</code>等。</p>
<h2 id="常见集合的底层和性能对比"><a href="#常见集合的底层和性能对比" class="headerlink" title="常见集合的底层和性能对比"></a>常见集合的底层和性能对比</h2><table>
<thead>
<tr>
<th>集合</th>
<th>使用场景</th>
<th>底层</th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>频繁查询但不经常增删元素</td>
<td>数组，允许存储多个null值</td>
<td>查询（get、contains）操作时间复杂度为O(1)，添加（add）和删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为O(n)</td>
</tr>
<tr>
<td>LinkedList</td>
<td>频繁增删元素但不经常查询</td>
<td>链表，允许存储多个null值</td>
<td>查询很慢（需要从头（或尾）遍历链表，查询操作时间复杂度为O(n) ），增删很快（只需调整链表的指针，插入（add）和删除（remove）操作时间复杂度为O(1)）</td>
</tr>
<tr>
<td>Stack</td>
<td>需要后进先出（LIFO）访问顺序的数据结构，例如递归、回溯算法等。线程安全，因为它是Vector的实现类</td>
<td>数组（因为它是Vector的实现类），允许存储多个 null 值</td>
<td>增删改查都是在栈顶操作，所以时间复杂度都是O(1)</td>
</tr>
<tr>
<td>HashSet</td>
<td>需要高效去重、快速查找、不考虑内存浪费的场景</td>
<td>哈希表（快速查找）和Set（去重）。它自动对元素进行去重（通过 hashCode 和 equals 方法），并且无序（存入后顺序会乱），允许存储一个null值。</td>
<td>底层是哈希表，所以插入、删除和查找操作的时间复杂度都是O(1)，代价是浪费一些空间。</td>
</tr>
<tr>
<td>TreeSet</td>
<td>适用于多读少写、排序的场景</td>
<td>红黑树（快速查找、排序）和Set（去重），不允许存储null值</td>
<td>插入、删除、查找操作的时间复杂度为O(log n)，因为操作需要维护树的平衡，所以适用于多读少写的场景。</td>
</tr>
<tr>
<td>HashMap</td>
<td>适用于多读少写、需要快速读的场景。</td>
<td>哈希表（快速查找）和Map（键值对），可以存储一个null键（key）和多个null值（value）。</td>
<td>底层是哈希表，所以插入、删除和查找操作的时间复杂度都是O(1)，代价是浪费一些空间。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Stack常用方法</strong>：</p>
<ul>
<li>**push(E item)**：将元素压入栈顶</li>
<li>**pop()**：移除并返回栈顶元素</li>
<li>**peek()**：返回栈顶元素但不移除</li>
<li>**isEmpty()**：检查栈是否为空</li>
<li>**search(Object o)**：返回元素在栈中的位置，以 1 为基准</li>
</ul>
<p><strong>红黑树</strong>： </p>
<p>近似平衡二叉树，左右子树高差可能大于 1，查找效率略低于平衡二叉树，但增删效率高于平衡二叉树，适合频繁插入删除。</p>
<ul>
<li><p>结点非黑即红；</p>
</li>
<li><p>根结点是黑色，叶节点是黑色空节点（常省略）；</p>
</li>
<li><p>任何相邻节点不能同时为红色；</p>
</li>
<li><p>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点；</p>
</li>
<li><p>**查询性能稳定O(logN)**，高度最高2log(n+1)；</p>
</li>
</ul>
</blockquote>
<h2 id="知识加油站"><a href="#知识加油站" class="headerlink" title="知识加油站"></a>知识加油站</h2><h2 id="集合的线程安全性"><a href="#集合的线程安全性" class="headerlink" title="集合的线程安全性"></a>集合的线程安全性</h2><p><strong>线程不安全的集合</strong>：</p>
<p>Java提供了众多集合的实现类,它们都是这些接口的直接或间接的实现类，其中比较常用的有：HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap等。这些集合都是线程不安全的。</p>
<p><strong>线程安全的集合</strong>：</p>
<ol>
<li><p><strong>Collections工具类</strong>：Collections工具类的<code>synchronizedXxx()</code>方法，将ArrayList等集合类包装成线程安全的集合类。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br></pre></td></tr></table></figure></li>
<li><p><strong>古老api</strong>：如Vector、Hashtable，在JDK1就出现了，不推荐使用，因为线程安全的方案不成熟，性能差。</p>
</li>
<li><p><strong>降低锁粒度的并发容器（推荐）</strong>：JUC包下<code>Concurrent</code>开头的、以降低锁粒度来提高并发性能的容器，如<code>ConcurrentHashMap</code>。适用于读写操作都很频繁的场景。</p>
</li>
<li><p><strong>复制技术实现的并发容器</strong>：JUC包下以<code>CopyOnWrite</code>开头的、采用写时写入时复制技术实现的并发容器，如<code>CopyOnWriteArrayList</code>。写操作时，先将当前数组进行一次复制，对复制后的数组进行操作，操作完成后再将原来的数组引用指向复制后的数组。避免了并发修改同一数组的线程安全问题。适用于读操作比写操作频繁且数据量不大的场景。适用于读操作远多于写操作的场景。</p>
</li>
</ol>
<h3 id="什么是线程不安全"><a href="#什么是线程不安全" class="headerlink" title="什么是线程不安全"></a>什么是线程不安全</h3><p>线程不安全是指在多线程环境下，当多个线程并发地访问和修改共享数据时，由于缺乏适当的同步机制，可能导致数据的不一致、错误或者程序行为不可预测的现象。</p>
<h2 id="Collection常用API"><a href="#Collection常用API" class="headerlink" title="Collection常用API"></a>Collection常用API</h2><ul>
<li>**add()**：向集合中添加一个元素。</li>
<li><strong>获取元素</strong>：没有直接提供获取指定位置元素的方法，因为它的实现类元素不一定有序。若需访问，需要通过迭代器iterator()</li>
<li>**remove()**：从集合中移除一个指定的元素。</li>
<li>**contains(Object o)**： 检查集合中是否包含指定元素。</li>
<li>**size()**：返回集合中的元素数量。</li>
<li>**isEmpty()**：检查集合是否为空。</li>
<li><strong>clear()</strong>:：移除集合中的所有元素。</li>
</ul>
<h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><p>Java 的集合框架提供了许多有用的工具类，用于简化集合的操作。最常见的工具类是 java.util.Collections 和 java.util.Arrays。这些工具类提供了许多静态方法，可以对集合进行排序、搜索、填充、反转等操作</p>
<h3 id="集合工具类Collections"><a href="#集合工具类Collections" class="headerlink" title="集合工具类Collections"></a>集合工具类Collections</h3><p>Collections工具类常用方法：</p>
<ul>
<li><code>sort(List&lt;T&gt; list)</code>：对指定的列表按自然顺序进行升序排序。</li>
<li>sort(List<T> list, Comparator&lt;? super T&gt; c)：使用指定的比较器对指定的列表进行排序。</li>
<li><code>reverse(List&lt;?&gt; list)</code>：反转指定列表中元素的顺序。</li>
<li><code>max(Collection&lt;? extends T&gt; coll)</code>：返回给定集合的最大元素，按自然顺序比较。</li>
<li>max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)：返回给定集合的最大元素，使用指定的比较器比较。</li>
<li><code>binarySearch(List&lt;? extends T&gt; list, T key)</code>：使用二分法搜索指定列表以查找指定对象。</li>
<li><code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code>：将源列表的所有元素复制到目标列表中。</li>
<li><code>fill(List&lt;? super T&gt; list, T obj)</code>：用指定的元素替换指定列表中的所有元素。</li>
<li><code>frequency(Collection&lt;?&gt; c, Object o)</code>：返回指定集合中等于指定对象的元素数。</li>
<li><code>indexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target)</code>：返回指定源列表中首次出现指定目标列表的起始位置。</li>
<li><code>swap(List&lt;?&gt; list, int i, int j)</code>：交换指定列表中指定位置的元素。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个ArrayList并添加元素</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">5</span>);list.add(<span class="number">3</span>);list.add(<span class="number">8</span>);list.add(<span class="number">1</span>);list.add(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 输出原始列表</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始列表: &quot;</span> + list);</span><br><span class="line">        <span class="comment">// 使用sort方法按自然顺序排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的列表: &quot;</span> + list);</span><br><span class="line">        <span class="comment">// 使用reverse方法反转列表</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;反转后的列表: &quot;</span> + list);</span><br><span class="line">        <span class="comment">// 使用binarySearch方法查找元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Collections.binarySearch(list, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素3的索引: &quot;</span> + index);</span><br><span class="line">        <span class="comment">// 创建一个目标列表并使用copy方法复制元素</span></span><br><span class="line">        List&lt;Integer&gt; destList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Collections.nCopies(list.size(), <span class="number">0</span>));</span><br><span class="line">        Collections.copy(destList, list);</span><br><span class="line">        System.out.println(<span class="string">&quot;复制后的目标列表: &quot;</span> + destList);</span><br><span class="line">        <span class="comment">// 使用fill方法填充列表</span></span><br><span class="line">        Collections.fill(list, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;填充后的列表: &quot;</span> + list);</span><br><span class="line">        <span class="comment">// 使用swap方法交换元素</span></span><br><span class="line">        Collections.swap(destList, <span class="number">0</span>, destList.size() - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;交换后的目标列表: &quot;</span> + destList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.1.3.2 数组工具类Arrays<br>Arrays工具类常用方法：</p>
<ul>
<li><p><code>asList(T... a)</code>：将数组转换为固定大小列表。例如Arrays.asList(1,2,3);则返回有三个元素的数组</p>
<ul>
<li><p><strong>基本类型数组视作单个元素</strong>：如果传入基本类型数组，会将其整个数组视作单个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">Arrays.asList(nums); </span><br><span class="line"><span class="comment">// 返回列表是List&lt;int[]&gt;类型，只有一个数组元素。而传入对象类型（String、包装类等），则会拆开。</span></span><br><span class="line">Integer[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">Arrays.asList(nums);</span><br><span class="line"><span class="comment">// 返回列表是List&lt;Integer&gt;类型。其实主要原因是List&lt;T&gt;，T只能是包装类、数组、对象，不能是基本数据类型。</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>与原数组共享内存</strong>：<code>asList()</code>后，修改列表的元素，变动会同步到原数组。</p>
</li>
<li><p><strong>列表固定大小</strong>：因为返回列表与原数组共享数据，所以列表是固定大小的，不能再增删元素。</p>
</li>
</ul>
</li>
<li><p><code>sort(T[] a)</code>：对指定数组按自然顺序进行升序排序。</p>
</li>
<li><p><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code>：使用指定的比较器对数组进行排序。</p>
</li>
<li><p><code>binarySearch(T[] a, T key)</code>：使用二分法搜索指定数组以查找指定对象。</p>
</li>
<li><p><code>binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)</code>：使用二分法搜索指定数组以查找指定对象，使用指定的比较器。</p>
</li>
<li><p><code>copyOf(T[] original, int newLength)</code>：复制指定的数组，截取或填充 null 以使副本具有指定的长度。</p>
</li>
<li><p><code>copyOfRange(T[] original, int from, int to)</code>：复制指定的数组，从指定的起始位置开始到终止位置结束。</p>
</li>
<li><p><code>equals(Object[] a, Object[] a2)</code>：如果两个指定数组彼此相等，则返回 true。一维数组时比较内容是否一致，多维数组时只比较最外层数组对象的内容。</p>
</li>
<li><p><code>deepEquals(Object[] a1, Object[] a2)</code>：如果两个指定数组彼此深度相等，则返回 true。一维和多维数组比较内容是否一致。</p>
</li>
<li><p><code>fill(T[] a, T val)</code>：用指定的值填充指定数组。</p>
</li>
<li><p><code>toString(T[] a)</code>：返回指定数组内容的字符串表示形式。</p>
</li>
<li><p><code>deepToString(Object[] a)</code>：返回指定数组内容的深层字符串表示形式。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用asList方法将数组转换为列表。列表与原数组共享内存，列表固定大小</span></span><br><span class="line">        String[] stringArray = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; stringList = Arrays.asList(stringArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;数组转换为列表: &quot;</span> + stringList);</span><br><span class="line">        <span class="comment">// 使用sort方法对数组进行排序</span></span><br><span class="line">        <span class="type">int</span>[] intArray = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;原数组（直接打印）: &quot;</span> + intArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;原数组（用Arrays.toString()打印）：&quot;</span> + Arrays.toString(intArray));</span><br><span class="line">        Arrays.sort(intArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组: &quot;</span> + Arrays.toString(intArray));</span><br><span class="line">        <span class="comment">// 使用binarySearch方法查找元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(intArray, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素3的索引: &quot;</span> + index);</span><br><span class="line">        <span class="comment">// 使用copyOf方法复制数组</span></span><br><span class="line">        <span class="type">int</span>[] copiedArray = Arrays.copyOf(intArray, intArray.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;复制后的数组: &quot;</span> + Arrays.toString(copiedArray));</span><br><span class="line">        <span class="comment">// 使用deepEquals方法比较多维数组</span></span><br><span class="line">        Integer[][] deepArray1 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">        Integer[][] deepArray2 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">deepEqual</span> <span class="operator">=</span> Arrays.deepEquals(deepArray1, deepArray2);</span><br><span class="line">        System.out.println(<span class="string">&quot;多维数组是否深度相等: &quot;</span> + deepEqual);</span><br><span class="line">        <span class="comment">// 使用fill方法填充数组</span></span><br><span class="line">        <span class="type">int</span>[] fillArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        Arrays.fill(fillArray, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;填充后的数组: &quot;</span> + Arrays.toString(fillArray));</span><br><span class="line">        <span class="comment">// 使用toString方法将数组转换为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">arrayString</span> <span class="operator">=</span> Arrays.toString(intArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;数组的字符串表示: &quot;</span> + arrayString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul>
<li><strong>基本介绍：</strong>可以动态修改的数组，没有固定大小的限制。</li>
<li><strong>使用场景：</strong>频繁查询但不经常增删元素</li>
<li><strong>底层：</strong>数组 。允许存储多个null值。</li>
<li><strong>性能：</strong>查询（get、contains）操作时间复杂度为O(1)，添加（add）和删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为O(n)。</li>
<li><strong>常用API：</strong><ul>
<li>Collection接口的add()、remove()等方法</li>
<li><strong>get()：</strong>获取一个指定下标的元素</li>
<li><strong>subList(int fromIndex, int toIndex)：</strong>返回从 fromIndex（包括）到 toIndex（不包括）之间的部分列表。</li>
<li><strong>trimToSize()：</strong>将 ArrayList 的容量调整为当前元素的数量，以节省内存。</li>
</ul>
</li>
</ul>
<p><strong>排序方法：</strong></p>
<ul>
<li><strong>Collections工具类的sort()方法：</strong>Collections.sort(list);</li>
<li><strong>stream流：</strong>list.stream().sort();</li>
<li><strong>比较器：</strong>list.sort(new Comparator<Integer>() {})</li>
<li><strong>手写排序：</strong>冒泡排序、选择排序、插入排序、二分法排序、快速排序、堆排序。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 ArrayList</span></span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 使用 add() 方法向集合中添加元素</span></span><br><span class="line">    arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;添加元素后: &quot;</span> + arrayList);</span><br><span class="line">    <span class="comment">// 使用 get() 方法获取指定索引的元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">elementAtIndex2</span> <span class="operator">=</span> arrayList.get(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;索引 2 处的元素: &quot;</span> + elementAtIndex2);</span><br><span class="line">    <span class="comment">// 使用 set() 方法修改指定索引的元素</span></span><br><span class="line">    arrayList.set(<span class="number">2</span>, <span class="number">35</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改索引 2 后: &quot;</span> + arrayList);</span><br><span class="line">    <span class="comment">// 使用 remove() 方法移除指定索引的元素</span></span><br><span class="line">    arrayList.remove(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;移除索引 1 后: &quot;</span> + arrayList);</span><br><span class="line">    <span class="comment">// 使用 size() 方法获取集合的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> arrayList.size();</span><br><span class="line">    System.out.println(<span class="string">&quot;集合的大小: &quot;</span> + size);</span><br><span class="line">    <span class="comment">// 使用 contains() 方法检查集合中是否包含某个元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">contains30</span> <span class="operator">=</span> arrayList.contains(<span class="number">30</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;集合中是否包含 30: &quot;</span> + contains30);</span><br><span class="line">    <span class="comment">// 使用 isEmpty() 方法检查集合是否为空</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> arrayList.isEmpty();</span><br><span class="line">    System.out.println(<span class="string">&quot;集合是否为空: &quot;</span> + isEmpty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="底层源码和扩容机制"><a href="#底层源码和扩容机制" class="headerlink" title="底层源码和扩容机制"></a>底层源码和扩容机制</h2><p><strong>数组实现：</strong></p>
<p>ArrayList是<strong>基于数组实现的</strong>，它的内部封装了一个<strong>Object[]数组</strong>。通过<strong>默认构造器</strong>创建容器时,该数组先被<strong>初始化为空数组</strong>，之后在<strong>首次添加数据</strong>时再将其初始化成<strong>长度为10的数组</strong>。我们也可以使用有参构造器来创建容器，并通过参数来显式指定数组的容量，届时该数组被初始化为指定容量的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制的源码中的一部分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default initial capacity. 初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access 底层数组</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>每次扩容1.5倍：</strong></p>
<p>如果向ArrayList中添加数据会造成超出数组长度限制,则会触发<strong>自动扩容</strong>,然后再添加数据。扩容就是<strong>数组拷贝</strong>,将<strong>旧数组中的数据拷贝到新数组</strong>里,而新数组的长度为原来<strong>长度的1.5倍</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minCapacity 代表着最小扩容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// elementData 是 ArrayList 存储数据的数组，这里是获取当前数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 计算扩容后的数组长度 = 当前数组长度 + (当前数组长度 * 0.5)；也就是扩容到当前的 1.5 倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断新的数组是否满足最小扩容量，如果不满足就将新数组的扩容长度赋值为最小扩容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果扩容后的长度超过了最大数组大小，则将其设置为合适的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity 通常接近于 size，因此这是一个有效的优化</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>手动缩容：</strong></p>
<p>ArrayList支持缩容,但<strong>不会自动缩容</strong>,即便是ArrayList中只剩下少量数据时也不会主动缩容。如果我们希望缩减ArrayList的容量,则需要自己调用它的<strong>trimToSize()方法</strong>,届时数组将按照元素的实际个数进行缩减，底层也是通过创建新数组拷贝实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 增加modCount，modCount是ArrayList的属性，用于记录集合被修改的次数。</span></span><br><span class="line">    <span class="comment">// 除了ArrayList，LinkedList、HashSet、TreeSet、HashMap、TreeMap等集合都有modCount属性</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果当前大小小于数组的长度，则进行缩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        <span class="comment">// 如果 size 为 0，则将 elementData 置为 EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="comment">// 否则将 elementData 缩容到 size 大小</span></span><br><span class="line">        elementData = (size == <span class="number">0</span>) </span><br><span class="line">            ? EMPTY_ELEMENTDATA </span><br><span class="line">            : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程不安全问题和解决方案"><a href="#线程不安全问题和解决方案" class="headerlink" title="线程不安全问题和解决方案"></a>线程不安全问题和解决方案</h2><p>添加元素add()方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.扩容：判断列表的capacity容量是否足够，是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2.添加：真正将元素放在列表的元素数组里面</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.某线程刚扩容后就失去调度</strong></p>
<p>在JVM中，CPU在多个线程中通过程序计数器来回调度，同一时刻一个CPU只能运行一个线程，所以就存在add()时，某个线程在刚刚ensureCapacityInternal()扩容后、还没往数组存元素时被暂停，等待被调度，然后其他线程add()成功把数组存满了，此时原线程恢复运行，执行elementData[size++] = e，因为数组容量已经满了，就会报错数组越界异常ArrayIndexOutOfBoundsException。</p>
<p><strong>例如：</strong></p>
<p>表大小为9，线程A新增一个元素，判断容量是不是足够，同时线程B也新增一个元素，判断容量是不是足够，线程A开始进行设置值操作， elementData[size++] = e 操作。此时size变为10，线程B也开始进行设置值操作，它尝试设置elementData[10] = e，而elementData没有进行过扩容，它的下标最大为9。于是此时会报出一个数组越界的异常ArrayIndexOutOfBoundsException。</p>
<p><strong>2.数组存值时不是原子操作</strong><br>另外第二步 elementData[size++] = e 设置值的操作同样会导致线程不安全。从这儿可以看出，这步操作也不是一个原子操作。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>原子类</p>
</li>
<li><p>volatile</p>
</li>
<li><p>锁</p>
</li>
<li><p><strong>线程安全的集合：</strong></p>
<ul>
<li><p><strong>Collections工具类：</strong>Collections工具类的synchronizedXxx()方法<strong>，</strong>将ArrayList等集合类包装成线程安全的集合类。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure></li>
<li><p><strong>古老api</strong>：java.util包下性能差的古老api，如Vector、Hashtable</p>
</li>
<li><p><strong>降低锁粒度的并发容器</strong>：JUC包下Concurrent开头的、以降低锁粒度来提高并发性能的容器，如ConcurrentHashMap。</p>
</li>
<li><p><strong>复制技术实现的并发容器</strong>：JUC包下以CopyOnWrite开头的、采用写时复制技术实现的并发容器，如CopyOnWriteArrayList。 </p>
</li>
</ul>
</li>
</ul>
<h2 id="六种遍历方法"><a href="#六种遍历方法" class="headerlink" title="六种遍历方法"></a>六种遍历方法</h2><h3 id="常规-for-循环"><a href="#常规-for-循环" class="headerlink" title="常规 for 循环"></a>常规 for 循环</h3><p>普通 for 循环适用于遍历数组和实现了 List 接口的集合。它通过索引访问元素，性能通常较好。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>性能高：</strong>性能通常优于增强 for 循环和迭代器，尤其是对于数组和 ArrayList。</li>
<li><strong>复杂操作：</strong>允许在遍历过程中进行复杂的控制操作。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>可读性差：</strong>代码相对冗长，需要手动管理循环变量。</li>
<li><strong>只能通过索引访问：</strong>仅适用于可以通过索引下标访问元素的集合。</li>
</ul>
<p><strong>通过for循环，用get(下标) 的方法遍历：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 通过arrayList.add(value)增加值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">    System.out.print(arrayList.get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增强-for-循环（只遍历不修改）"><a href="#增强-for-循环（只遍历不修改）" class="headerlink" title="增强 for 循环（只遍历不修改）"></a>增强 for 循环（只遍历不修改）</h3><p>在某些情况下，常规的遍历方式容易显得代码臃肿，增强for可以简化数组和Collection集合的遍历，增强代码的可读性。</p>
<p><strong>增强 for 循环：</strong>一种<strong>简洁</strong>的遍历集合的方法，它适用于遍历数组和实现了 Iterable 接口的所有集合。</p>
<blockquote>
<p><strong>Collection实现类都实现了Iterable 接口：</strong></p>
<p>在标准的 Java Collections Framework 中，所有主要的集合实现类都实现了 Iterable 接口。换句话说，如果一个类实现了 Collection 接口，那么它也会实现 Iterable 接口，因为这是 Collection 接口的一个基本要求。 </p>
<p><strong>tip：</strong>Map集合没有实现Iterable 接口，因为它也没有实现Collection接口。</p>
</blockquote>
<p><strong>IDEA快捷键：</strong>输入iter然后回车</p>
<p><strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据类型：即遍历对象中元素的数据类型。</span></span><br><span class="line"><span class="comment">// 变量名：遍历时声明的变量，每次遍历得到的元素都会赋值给这个变量。</span></span><br><span class="line"><span class="comment">// 数组或者集合对象：需要遍历的对象。</span></span><br><span class="line"><span class="keyword">for</span> (数据类型 变量名 : 数组或者Collection集合对象) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">    System.out.println(变量名);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><strong>简洁易读</strong>：增强 for 循环语法简洁，代码更容易阅读。</li>
<li><strong>避免错误</strong>：相比传统的 for 循环，不需要手动管理循环变量，减少了出错的可能性。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>性能略差：</strong>性能略差于普通for循环，以略微的性能代价，提高了可读性 </li>
<li>不允许修改；</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用增强 for 循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (Integer num : arrayList) &#123;</span><br><span class="line">    System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器-Iterator（遍历并修改）"><a href="#迭代器-Iterator（遍历并修改）" class="headerlink" title="迭代器 Iterator（遍历并修改）"></a>迭代器 Iterator（遍历并修改）</h3><p>迭代器是遍历Collection集合的通用方式，它不需要关注集合和集合内元素的类型，对集合内的元素进行读取、添加、修改操作。  </p>
<p><strong>基本方法：</strong></p>
<ul>
<li><strong>hasNext()：</strong>返回 true 如果还有未遍历的元素。</li>
<li><strong>next()：</strong>返回下一个元素。</li>
<li><strong>remove()：</strong>从集合中移除 next() 返回的最后一个元素。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><strong>各类型集合统一迭代器</strong>：不需要了解集合的内部实现，通过 Iterator 可以统一遍历不同类型的集合。</li>
<li><strong>安全</strong>：在遍历过程中，如果其他线程修改了集合，Iterator 可以抛出 ConcurrentModificationException 以防止不一致性。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>性能略差：</strong>性能略差于普通for循环，以略微的性能代价，提高了可读性 </li>
<li><strong>复杂：</strong>相比增强for，需要next()、hasNext()，麻烦了一些</li>
<li>不能双向遍历</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorRemoveExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 ArrayList 并添加一些元素</span></span><br><span class="line">        List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 获取 ArrayList 的迭代器</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = arrayList.iterator();</span><br><span class="line">        <span class="comment">// 使用迭代器遍历 ArrayList 并移除元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用迭代器遍历 ArrayList 并移除元素:&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">30</span>) &#123;</span><br><span class="line">                iterator.remove(); <span class="comment">// 移除大于 30 的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印修改后的 ArrayList</span></span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的 ArrayList:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer num : arrayList) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器-ListIterator-（双向遍历并修改）"><a href="#迭代器-ListIterator-（双向遍历并修改）" class="headerlink" title="迭代器 ListIterator （双向遍历并修改）"></a>迭代器 ListIterator （双向遍历并修改）</h3><p>Set、List、Queue都是Collection的子接口，它们都继承了父接口的iterator()方法,从而具备了迭代的能力。Map使用迭代器必须通过先entrySet()转为Set，然后再使用迭代器或for遍历。</p>
<p>但相比于另外两个接口，<strong>List</strong>还单独提供了<strong>listIterator()方法</strong>,增强了迭代能力。iterator()方法返回Iterator迭代器，listIterator()方法返回ListIterator迭代器，并且<strong>ListIterator是Iterator的子接口</strong>。</p>
<p>ListIterator在Iterator的基础上，增加了listIterator.previous()向前遍历的支持，增加了listIterator.set()在迭代过程中修改数据的支持。与 Iterator 相比，ListIterator 提供了更多的方法，但只适用于实现了 List 接口的集合（如 ArrayList 和 LinkedList）。</p>
<p><strong>常用方法：</strong></p>
<ul>
<li>hasNext()：如果列表中有下一个元素，则返回 true。</li>
<li><strong>next()：</strong>返回列表中的下一个元素。</li>
<li>hasPrevious()：如果列表中有上一个元素，则返回 true。</li>
<li><strong>previous()：</strong>返回列表中的上一个元素。</li>
<li>nextIndex()：返回下一元素的索引。</li>
<li>previousIndex()：返回上一元素的索引。</li>
<li>remove()：移除上一个通过 next() 或 previous() 返回的元素。</li>
<li>set(E e)：替换上一个通过 next() 或 previous() 返回的元素。</li>
<li>add(E e)：在列表中插入指定元素。 </li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可读性高；</li>
<li><strong>安全：</strong>在遍历过程中，如果其他线程修改了集合，迭代器可以抛出 ConcurrentModificationException 以防止不一致性。</li>
<li>双向遍历；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>只支持List：</strong>只适用于实现了 List 接口的集合（如 ArrayList 和 LinkedList）。</li>
<li><strong>性能略差：</strong>性能略差于普通for循环，以略微的性能代价，提高了可读性 </li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteratorExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 使用 ListIterator 遍历（正向）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 ListIterator 正向遍历:&quot;</span>);</span><br><span class="line">        ListIterator&lt;Integer&gt; listIterator = arrayList.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(listIterator.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 使用 ListIterator 反向遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 ListIterator 反向遍历:&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasPrevious()) &#123;</span><br><span class="line">            System.out.print(listIterator.previous() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forEach-Lambda-表达式（只遍历不修改）"><a href="#forEach-Lambda-表达式（只遍历不修改）" class="headerlink" title="forEach + Lambda 表达式（只遍历不修改）"></a>forEach + Lambda 表达式（只遍历不修改）</h3><p>在 Java 8 及以上版本中，forEach 方法与 Lambda 表达式的结合提供了一种简洁、功能强大的方式来遍历集合。forEach 方法<strong>属于 Iterable 接口</strong>，允许对集合中的每个元素执行指定的操作。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简洁：</strong>相比于传统的 for 循环和迭代器，代码更简洁，减少样板代码。</li>
<li><strong>可读性强：</strong>使用 Lambda 表达式和方法引用，使代码更加易读和表达意图明确。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>性能略差：</strong>性能略差于普通for循环，以略微的性能代价，提高了代码的优雅性可读性 ；同时各个元素之间的遍历是顺序执行的，不像Stream流的forEach是并发执行的，性能略差。</li>
<li><strong>不允许修改元素：</strong>因为 Lambda 表达式的参数是 final 或等效于 final 的，所以不允许修改集合中的元素。想修改的话，只能创建另一个集合，然后在遍历时将处理后的元素add进另一个集合。</li>
<li><strong>版本限制：</strong>只适用JDK8及以上；</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForEachLambdaExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 使用 forEach 方法和 Lambda 表达式遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 forEach 方法和 Lambda 表达式遍历:&quot;</span>);</span><br><span class="line">        arrayList.forEach(num -&gt; System.out.print(num + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stream-API-遍历（推荐，并发遍历并修改）"><a href="#Stream-API-遍历（推荐，并发遍历并修改）" class="headerlink" title="Stream API 遍历（推荐，并发遍历并修改）"></a>Stream API 遍历（推荐，并发遍历并修改）</h3><p>Stream 流是 Java 8 引入的一项新特性，用于对集合进行函数式编程风格的操作。它允许我们以声明性方式对数据进行过滤、加工、遍历、排序等操作，而不是以命令式方式逐个操作元素。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简洁：</strong>相比于传统的 for 循环和迭代器，代码更简洁，减少样板代码。</li>
<li><strong>生成修改后的新集合：</strong>允许通过map()、filter()等方法修改元素，然后收集成一个新集合。</li>
<li><strong>性能高：</strong>因为是并发的，所以性能高。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>版本限制：</strong>只适用JDK8及以上；</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 使用 Stream API 遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 Stream API 遍历:&quot;</span>);</span><br><span class="line">        arrayList.stream().forEach(num -&gt; System.out.print(num + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结：六种遍历方法的适用场景"><a href="#小结：六种遍历方法的适用场景" class="headerlink" title="小结：六种遍历方法的适用场景"></a>小结：六种遍历方法的适用场景</h3><ul>
<li><strong>需要根据索引下标遍历：</strong>普通for</li>
<li><strong>只需要顺序读取元素：</strong>建议增强for，也可以用其他所有遍历方法</li>
<li><strong>需要修改元素：</strong>普通for、迭代器、Stream流</li>
<li><strong>需要双向遍历：</strong>ListIterator </li>
<li><strong>需要过滤、加工、排序等高级操作：</strong>Stream流</li>
</ul>
<hr>
<h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_47980550/article/details/148012216">java基础——java集合list详解</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38322527/article/details/114703142">JUC中的List安全类集合</a></p>
<h2 id="主要实现类"><a href="#主要实现类" class="headerlink" title="主要实现类"></a><strong>主要实现类</strong></h2><p>Collection将集合划分为两大类，即List和Set。</p>
<p>常见的 List 实现类包括 ArrayList、LinkedList、Vector（JDK1的上古集合，虽然线程安全但性能差，已经基本不用） 和 Stack。 </p>
<ol>
<li><p><strong>ArrayList：</strong></p>
<ul>
<li><p><strong>使用场景：</strong>频繁查询但不经常增删元素</p>
</li>
<li><p><strong>底层：</strong>数组 。允许存储多个null值。</p>
</li>
<li><p><strong>性能：</strong>查询（get、contains）操作时间复杂度为O(1)，添加（add）和删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为O(n)。</p>
</li>
</ul>
</li>
<li><p><strong>LinkedList：</strong></p>
<ul>
<li><p><strong>使用场景：</strong>频繁增删元素但不经常查询</p>
</li>
<li><p><strong>底层：</strong>链表 。允许存储多个null值。</p>
</li>
<li><p><strong>性能：</strong> 查询很慢（需要从头（或尾）遍历链表，查询操作时间复杂度为O(n) ），增删很快（只需调整链表的指针，插入（add）和删除（remove）操作时间复杂度为O(1)）。</p>
</li>
</ul>
</li>
<li><p><strong>Vector：</strong></p>
<ul>
<li><p><strong>使用场景：</strong>需要线程安全且频繁查询的场景（JDK1的上古集合，虽然线程安全但性能差，已经基本不用。</p>
</li>
<li><p><strong>线程安全集合：</strong></p>
<ul>
<li><strong>Collections工具类：</strong>Collections工具类的synchronizedXxx()方法<strong>，</strong>将ArrayList等集合类包装成线程安全的集合类。</li>
<li><strong>古老api：</strong>java.util包下性能差的古老api，如Vector、Hashtable</li>
<li>无序列表<strong>降低锁粒度的并发容器：</strong>JUC包下Concurrent开头的、以降低锁粒度来提高并发性能的容器，如ConcurrentHashMap。</li>
<li><strong>复制技术实现的并发容器：</strong>JUC包下以CopyOnWrite开头的、采用写时复制技术实现的并发容器，如CopyOnWriteArrayList。 </li>
</ul>
</li>
<li><p><strong>底层：</strong>数组。允许存储多个 null 值。</p>
<ul>
<li><strong>性能：</strong> 查询（get、contains）操作时间复杂度为O(1)，添加（add）和删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为O(n)。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Stack：</strong></p>
<ul>
<li><p><strong>使用场景：</strong>需要后进先出（LIFO）访问顺序的数据结构，例如递归、回溯算法等。线程安全，因为它是Vector的实现类</p>
</li>
<li><p><strong>底层：</strong>数组（因为它是Vector的实现类）。允许存储多个 null 值。</p>
</li>
<li><p><strong>性能：</strong> 增删改查都是在栈顶操作，所以时间复杂度都是O(1)</p>
</li>
<li><p><strong>常用方法：</strong></p>
<ul>
<li>**push(E item)**：将元素压入栈顶</li>
<li>**pop()**：移除并返回栈顶元素</li>
<li>**peek()**：返回栈顶元素但不移除</li>
<li>**isEmpty()**：检查栈是否为空</li>
<li>**search(Object o)**：返回元素在栈中的位置，以 1 为基准 </li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="ArrayList，LinkedList，Vector-对比"><a href="#ArrayList，LinkedList，Vector-对比" class="headerlink" title="ArrayList，LinkedList，Vector 对比"></a>ArrayList，LinkedList，Vector 对比</h2><table>
<thead>
<tr>
<th></th>
<th>ArrayList</th>
<th>LinkedList</th>
<th>Vector</th>
</tr>
</thead>
<tbody><tr>
<td>底层结构</td>
<td>动态数组</td>
<td>双向链表</td>
<td>动态数组</td>
</tr>
<tr>
<td>线程安全</td>
<td>不安全</td>
<td>不安全</td>
<td>安全，方法都加了<code>Synchronized</code></td>
</tr>
<tr>
<td>是否允许重复元素</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>是否有序</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>随机访问</td>
<td>快O(1)，索引访问</td>
<td>慢O(n)，需遍历链表</td>
<td>快O(1)，但因同步影响性能较低</td>
</tr>
<tr>
<td>插入/删除</td>
<td>慢O(n)，需移动元素</td>
<td>快O(1)，只需修改指针</td>
<td>慢，同步开销大</td>
</tr>
<tr>
<td>扩容机制</td>
<td>默认增长50%</td>
<td>无需扩容，动态添加节点</td>
<td>默认翻倍容量</td>
</tr>
<tr>
<td>加载因子</td>
<td>1</td>
<td>无</td>
<td>1</td>
</tr>
</tbody></table>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>有序【存储有序】</li>
<li>可重复</li>
<li>可以存储 null值</li>
<li>部分子集合线程安全，部分不安全 例如 ArrayList 和 Vector</li>
</ul>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>List接口继承自<code>Collection</code>接口，提供了额外的功能来处理索引位置上的元素。与Set、Map不同，List允许包含重复的元素，并且可以通过索引来访问或修改特定位置的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 核心接口方法 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> <span class="comment">// 添加指定元素到列表末尾。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span><span class="comment">// 在指定索引处插入指定元素。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> <span class="comment">// 在指定索引 index 处插入集合 c 中的所有元素。</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> <span class="comment">// 移除指定索引处的元素。</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> <span class="comment">// 获取指定索引处的元素。</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> <span class="comment">// 替换指定索引处的元素。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 返回列表中的元素数量。</span></span><br><span class="line"><span class="comment">/* 其他常用方法 */</span> </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断列表是否为空。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> <span class="comment">// 检查列表是否包含指定元素。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> <span class="comment">// 返回指定元素首次出现的索引，如果不存在则返回-1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> <span class="comment">// 返回指定元素最后一次出现的索引，如果不存在则返回-1。</span></span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> <span class="comment">// 获取从fromIndex（包括）到toIndex（不包括）之间的子列表</span></span><br></pre></td></tr></table></figure>

<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 ArrayList</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 增加元素</span></span><br><span class="line">    list.add(<span class="string">&quot;元素1&quot;</span>);list.add(<span class="string">&quot;元素2&quot;</span>);list.add(<span class="string">&quot;元素3&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;增加元素后：&quot;</span> + list);</span><br><span class="line">    <span class="comment">// 在指定索引插入元素</span></span><br><span class="line">    list.add(<span class="number">1</span>, <span class="string">&quot;元素4&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;在索引1插入元素4后：&quot;</span> + list);</span><br><span class="line">    <span class="comment">// 删除指定索引的元素</span></span><br><span class="line">    list.remove(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除索引2的元素后：&quot;</span> + list);</span><br><span class="line">    <span class="comment">// 修改指定索引的元素</span></span><br><span class="line">    list.set(<span class="number">1</span>, <span class="string">&quot;元素5&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改索引1的元素为元素5后：&quot;</span> + list);</span><br><span class="line">    <span class="comment">// 获取指定索引的元素</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> list.get(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;获取索引2的元素：&quot;</span> + element);</span><br><span class="line">    <span class="comment">// 获取元素的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(<span class="string">&quot;元素5&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;元素5的索引：&quot;</span> + index);</span><br><span class="line">    <span class="comment">// 获取子列表</span></span><br><span class="line">    List&lt;String&gt; subList = list.subList(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;子列表（从索引1到索引2）： &quot;</span> + subList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><ol>
<li><p><code>for</code>循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：可以灵活控制索引。支持随机访问（适合 ArrayList）。</span></span><br><span class="line"><span class="comment">// 缺点：对于 LinkedList 来说效率较低（因为每次都要从头开始查找元素）。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Index: &quot;</span> + i + <span class="string">&quot;, Value: &quot;</span> + list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：简洁易读。适用于所有实现了 Iterable 接口的集合类。</span></span><br><span class="line"><span class="comment">// 缺点：无法获取索引。不能修改集合结构（如删除元素会抛出异常）。</span></span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Item: &quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>Iterator</code>。可以安全地在遍历时进行删除操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;元素：&quot;</span> + iterator.next());</span><br><span class="line">    <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;B&quot;</span>.equals(item)) &#123;</span><br><span class="line">        iterator.remove();  <span class="comment">// 安全删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="去重方式"><a href="#去重方式" class="headerlink" title="去重方式"></a>去重方式</h2><ol>
<li><p>利用 <code>HashSet</code> 或 <code>LinkedHashSet</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet 不保留顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出顺序可能不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashSet 保留插入顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>Stream.distinct()</code>，Java 8+ 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; uniqueList = list.stream().distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(uniqueList);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="List-与数组的转换"><a href="#List-与数组的转换" class="headerlink" title="List 与数组的转换"></a>List 与数组的转换</h2><ul>
<li><p>List 转数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无类型参数：丢失类型信息</span></span><br><span class="line">Object[] array = list.toArray();</span><br><span class="line"><span class="comment">// 带类型参数：推荐，自动匹配类型</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 函数式写法</span></span><br><span class="line">String[] array = list.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>数组转 List</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(array);（只读）</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));（可修改）</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="List-的元素判断机制"><a href="#List-的元素判断机制" class="headerlink" title="List 的元素判断机制"></a>List 的元素判断机制</h2><p>List的 <code>contains(Object o)</code> 和 <code>indexOf(Object o)</code> 方法通过 <code>equals()</code>而非 <code>==</code> 判断元素是否相等。</p>
<h2 id="List的安全类"><a href="#List的安全类" class="headerlink" title="List的安全类"></a>List的安全类</h2><p>在单线程应用中，通常采取<code>new ArrayList()</code>，指定一个List集合，用于存放可重复的数据。但<code>ArrayList</code>是不安全的集合。多线程操作同一集合对象信息，往往会出现<code>java.util.ConcurrentModificationException</code>异常报错信息。</p>
<h3 id="Java的安全类Vector"><a href="#Java的安全类Vector" class="headerlink" title="Java的安全类Vector"></a>Java的安全类Vector</h3><p>java提供了<code>java.util.Vector</code>类，多线程下不会出现<code>java.util.ConcurrentModificationException</code>报错信息。因为采取了 <code>synchronized</code> 针对方法执行调用者加锁，保证add操作的多线程安全性！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建lists集合</span></span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JUC下的安全List集合"><a href="#JUC下的安全List集合" class="headerlink" title="JUC下的安全List集合"></a>JUC下的安全List集合</h3><ol>
<li><code>Collections.synchronizedList(new ArrayList&lt;&gt;());</code>。该方法返回具有同步包装器的List，保证了对List的操作是安全的。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">( <span class="meta">@NotNull</span> List&lt;T&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(list <span class="keyword">instanceof</span> RandomAccess ? </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list) : </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">synchronizedList</span>&lt;&gt;(list));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断传入的 list 集合类型，判断类型是否为 java.util.RandomAccess，如果是则采取java.util.Collections.SynchronizedRandomAccessList构造集合，如果不是则采取java.util.Collections.SynchronizedList构造集合。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码中对应的add操作逻辑如下所示。采取synchronized同步代码块的方式，对数据的add操作实现加锁！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>&#123; </span><br><span class="line">    synchron1zed (mutex) &#123;</span><br><span class="line">        list.add(index, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>new CopyOnWriteArrayList();</code>。该类中所有修改操作都在一个独立的副本上进行，不会影响原始数据，保证了线程安全。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&quot;</span>+lists);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates an empty list</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyonWriteArrayList</span><span class="params">()</span>&#123; setArray(<span class="keyword">new</span> <span class="title class_">object</span>[<span class="number">0</span>]); &#125;</span><br><span class="line"><span class="comment">// add 逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[]elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copy0f(elements, len +<span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong><code>add</code>逻辑如下所示</strong><br>  1、调用add方法后，拿到<code>java.util.concurrent.locks.ReentrantLock</code>对象信息。<br>  2、调用 <code>lock.lock()</code> 拿到锁！<br>  3、将原数组对象<code>copy</code>操作，并创建<code>原数组大小+1</code>的新数组。<br>  4、将新数据放入新数组中。<br>  5、任何操作<code>finally</code>，都进行锁的释放</p>
<h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p>面向接口编程（<code>Programming to an Interface</code>）是一种编程原则，它强调使用接口（Interface）而不是具体实现类（Concrete Class）来编写代码。</p>
<p>具体的使用方法是，声明一个接口的变量（接口的引用）可以指向一个实现类（实现该接口的类）的实例。</p>
<p><strong>注意：</strong>因为是接口的引用，所以该引用的变量不能使用实现类中有、但接口中没有的方法（实现类中没有重写的方法，自添加的方法）。</p>
<blockquote>
<p><strong>以面向接口编程为原则，以多态的形式创建集合对象：</strong></p>
<p>以下两种方法都可以创建ArrayList，但是更推荐第一种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐，面向接口编程，多态形式，对象实例指向接口引用</span></span><br><span class="line">List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 不推荐，常规创建对象形式</span></span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>因为前者符合设计模式中的依赖倒置原则。即程序要尽量依赖于抽象，不依赖于具体。</p>
<p>在Java语法中，这种方式符合Java三大特性中的多态，即使用接口引用指向具体实现。<br>依赖倒转的好处是，后期扩展方便。比如，你若希望用LinkedList的实现来替代ArrayList的话，只需改动一行即可，其他的所有的都不需要改动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()；</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>优点：</strong></p>
<ul>
<li><strong>解耦合</strong>：声明的变量与具体实现类解耦。变量只依赖于接口，而不是具体实现，这样可以很容易地替换具体实现类，而不需要修改客户端代码。</li>
<li><strong>可扩展性</strong>：当需要添加新功能时，只需实现新的接口，让原引用指向新的实现类，而不需要修改现有代码。例如SpringBoot项目中，我们经常用XxxService接口和XxxServiceImpl1、XxxServiceImpl2等业务实现类，在使用时，通常将这个接口引用通过@Autowired等注解注入XxxService，然后通过@Primary、@Qualifier等注解指定具体注入XxxServiceImpl1还是XxxServiceImpl2，方便扩展。</li>
<li><strong>可测试性</strong>：在单元测试中，可以轻松地使用接口的模拟实现来替换真实的实现，从而进行隔离测试。</li>
</ul>
<p><strong>符合设计原则：</strong></p>
<ul>
<li><strong>开闭原则OCP(Open－Close Principle)：</strong> 对拓展开放、对修改关闭。</li>
<li><strong>依赖倒置原则DIP(Dependency Inversion Principle)：</strong> 抽象不应该依赖于细节、细节应该依赖于抽象。例如我们开发中要用Service接口和ServiceImpl实现类，而不是直接一个ServiceImpl类中写业务。</li>
</ul>
<blockquote>
<p><strong>设计原则详细参考：</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/article/details/130403757?spm=1001.2014.3001.5502">设计模式——设计模式简介和七大原则_理解设计模式的核心思想和基本理念是什么-CSDN博客</a></p>
</blockquote>
<hr>
<h1 id="LinkedList接口"><a href="#LinkedList接口" class="headerlink" title="LinkedList接口"></a>LinkedList接口</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>LinkedList：</strong></p>
<ul>
<li><strong>使用场景：</strong>频繁增删元素但不经常查询</li>
<li><strong>底层：</strong>链表 。允许存储多个null值。</li>
<li><strong>性能：</strong> 查询很慢（需要从头（或尾）遍历链表，查询操作时间复杂度为O(n) ），增删很快（只需调整链表的指针，插入（add）和删除（remove）操作时间复杂度为O(1)）。</li>
</ul>
<h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public void add(int index, E element)</td>
<td>向指定位置插入元素</td>
</tr>
<tr>
<td>public void addFirst(E e)</td>
<td>元素添加到头部</td>
</tr>
<tr>
<td>public void addLast(E e)</td>
<td>元素添加到尾部</td>
</tr>
<tr>
<td>public void clear()</td>
<td>清空链表</td>
</tr>
<tr>
<td>public E remove(int index)</td>
<td>删除指定位置的元素</td>
</tr>
<tr>
<td>public E removeFirst()</td>
<td>删除并返回第一个元素</td>
</tr>
<tr>
<td>public E removeLast()</td>
<td>删除并返回最后一个元素</td>
</tr>
<tr>
<td>public boolean contains(Object o)</td>
<td>判断是否含有某一元素</td>
</tr>
<tr>
<td>public E getFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>public E getLast()</td>
<td>返回最后一个元素</td>
</tr>
</tbody></table>
<h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedList&lt;String&gt; link=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">    link.addLast(<span class="string">&quot;hello&quot;</span>);link.addLast(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s:link) System.out.println(s);</span><br><span class="line">    System.out.println(link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>ArrayList</strong></th>
<th><strong>LinkedList</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>使用场景</strong></td>
<td>频繁查询但不经常增删元素</td>
<td>频繁增删元素但不经常查询</td>
</tr>
<tr>
<td><strong>底层</strong></td>
<td>数组</td>
<td>链表</td>
</tr>
<tr>
<td><strong>允许存储 null 值</strong></td>
<td>是。允许存储多个null值</td>
<td>是。允许存储多个null值</td>
</tr>
<tr>
<td><strong>查询性能</strong></td>
<td>快。根据索引查询（get、contains）操作时间复杂度为 O(1)</td>
<td>慢。根据索引查询很慢（需要从头（或尾）遍历链表，查询操作时间复杂度为 O(n)）</td>
</tr>
<tr>
<td><strong>添加性能</strong></td>
<td>慢。添加（add）元素时，可能需要移动数组中的元素，导致时间复杂度为 O(n)</td>
<td>快。插入（add）操作时间复杂度为 O(1)，插入后不需要移动元素</td>
</tr>
<tr>
<td><strong>删除性能</strong></td>
<td>慢。删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为 O(n)</td>
<td>快。删除（remove）操作时间复杂度为 O(1)，删除后不需要移动元素</td>
</tr>
</tbody></table>
<hr>
<h1 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h1><p>列表迭代器允许沿任一方向遍历列表</p>
<h2 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h2><table>
<thead>
<tr>
<th align="left">Modifier and Type</th>
<th align="left">Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void</code></td>
<td align="left"><code>add(E e)</code></td>
<td>将指定的元素插入列表（可选操作）</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>hasNext()</code></td>
<td>返回 <code>true</code>如果遍历正向列表，列表迭代器有多个元素</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>hasPrevious()</code></td>
<td>返回 <code>true</code>如果遍历反向列表，列表迭代器有多个元素</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>next()</code></td>
<td>返回列表中的下一个元素，并且前进光标位置</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>nextIndex()</code></td>
<td>返回随后调用 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#next--"><code>next()</code></a>返回的元素的索引</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>previous()</code></td>
<td>返回列表中的上一个元素，并向后移动光标位置</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>previousIndex()</code></td>
<td>返回由后续调用 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#previous--"><code>previous()</code></a>返回的元素的索引</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>remove()</code></td>
<td>从列表中删除由 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#next--"><code>next()</code></a>或 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#previous--"><code>previous()</code></a>返回的最后一个元素（可选操作）</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>set(E e)</code></td>
<td>用 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#next--">指定的</a>元素替换由 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#next--"><code>next()</code></a>或 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#previous--"><code>previous()</code></a>返回的最后一个元素（可选操作）</td>
</tr>
</tbody></table>
<h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;String&gt; it=sites.listIterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) System.out.println(it.next());</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/FAQEW/article/details/146542959">HashMap底层原理</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/winterPassing/article/details/148248794">HashMap安全性问题</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42077317/article/details/138009817">Java中的ConcurrentHashMap原理详解</a></p>
<p>HashMap是基于哈希表实现的键值对存储结构，提供高效的插入和查询操作（平均时间复杂度O(1)），允许null键/值，非线程安全，且不保证元素顺序。其核心实现包括数组+链表（JDK1.7及之前）或数组+链表+红黑树（JDK1.8及之后），通过哈希冲突解决机制（链地址法）和动态扩容优化性能。</p>
<h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>使用场景</strong>: 适用于需要基于键值对快速查找数据的场景。“键”可以理解为钥匙，通过这个钥匙，可以找到它唯一对应的“值”。</p>
<p><strong>底层</strong>: 哈希表（数组+链表/红黑树）。</p>
<p><strong>性能</strong>:</p>
<ul>
<li><strong>查询性能</strong>: 快，时间复杂度为 O(1)。</li>
<li><strong>添加性能</strong>: 快，时间复杂度为 O(1)。</li>
<li><strong>删除性能</strong>: 快，时间复杂度为 O(1)。</li>
</ul>
<p><strong>是否允许 null</strong>:</p>
<ul>
<li>键可以为 null（但最多一个键为 null）。</li>
<li>值可以为 null。</li>
</ul>
<h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><strong>put()：</strong>向映射中添加一个键值对。如果键已经存在，则更新其对应的值<ol>
<li>计算键的哈希值并定位桶索引。</li>
<li>桶为空：直接插入新节点。</li>
<li>桶非空：遍历链表或红黑树，若存在相同键（通过<code>equals</code>判断），则更新值；否则追加节点。</li>
<li>触发扩容：插入后检查元素总数是否超过阈值</li>
</ol>
</li>
<li><strong>get()：</strong>根据键获取对应的值。根据哈希值定位桶，遍历链表或红黑树，通过<code>equals</code>匹配键</li>
<li><strong>getOrDefault()：</strong>获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值</li>
<li><strong>keySet()：</strong>返回所有key的Set集合</li>
<li><strong>remove(Object key):</strong> 根据键移除键值对</li>
<li><strong>containsKey(Object key):</strong> 检查是否包含指定键</li>
<li><strong>containsValue(Object value):</strong> 检查是否包含指定值</li>
<li><strong>size():</strong> 返回映射中的键值对数量</li>
<li><strong>isEmpty():</strong> 检查映射是否为空</li>
<li><strong>clear():</strong> 移除映射中的所有键值对</li>
</ul>
<h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 HashMap</span></span><br><span class="line">        Map&lt;String, String&gt; fruitColor = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 使用 put() 方法向映射中添加键值对</span></span><br><span class="line">        fruitColor.put(<span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;红色&quot;</span>);fruitColor.put(<span class="string">&quot;香蕉&quot;</span>, <span class="string">&quot;黄色&quot;</span>);fruitColor.put(<span class="string">&quot;樱桃&quot;</span>, <span class="string">&quot;红色&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;添加键值对后: &quot;</span> + fruitColor);</span><br><span class="line">        <span class="comment">// 使用 get() 方法根据键获取对应的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> fruitColor.get(<span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;键 &#x27;香蕉&#x27; 对应的值: &quot;</span> + value);</span><br><span class="line">        <span class="comment">// 遍历 keySet</span></span><br><span class="line">        Set&lt;String&gt; keys = fruitColor.keySet();</span><br><span class="line">        System.out.println(<span class="string">&quot;遍历 keySet:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;水果: &quot;</span> + key + <span class="string">&quot; 颜色: &quot;</span> + fruitColor.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 containsKey() 方法检查是否包含指定键</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">containsKeyBanana</span> <span class="operator">=</span> fruitColor.containsKey(<span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;包含键 &#x27;香蕉&#x27;: &quot;</span> + containsKeyBanana);</span><br><span class="line">        <span class="comment">// 使用 containsValue() 方法检查是否包含指定值</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">containsValueYellow</span> <span class="operator">=</span> fruitColor.containsValue(<span class="string">&quot;黄色&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;包含值 &#x27;黄色&#x27;: &quot;</span> + containsValueYellow);</span><br><span class="line">        <span class="comment">// 使用 size() 方法返回映射中的键值对数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> fruitColor.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;映射的大小: &quot;</span> + size);</span><br><span class="line">        <span class="comment">// 使用 isEmpty() 方法检查映射是否为空</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> fruitColor.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">&quot;映射是否为空: &quot;</span> + isEmpty);</span><br><span class="line">        <span class="comment">// 使用 remove() 方法根据键移除键值对</span></span><br><span class="line">        fruitColor.remove(<span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;移除键 &#x27;香蕉&#x27; 后: &quot;</span> + fruitColor);</span><br><span class="line">        <span class="comment">// 再次使用 size() 方法返回映射中的键值对数量</span></span><br><span class="line">        size = fruitColor.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;移除后映射的大小: &quot;</span> + size);</span><br><span class="line">        <span class="comment">// 使用 clear() 方法移除映射中的所有键值对</span></span><br><span class="line">        fruitColor.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空映射后: &quot;</span> + fruitColor);</span><br><span class="line">        <span class="comment">// 使用 isEmpty() 方法检查映射是否为空</span></span><br><span class="line">        isEmpty = fruitColor.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空后映射是否为空: &quot;</span> + isEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><code>HashMap</code>是基于哈希表实现的键值对存储结构，HashMap的核心实现结合了<code>数组</code>、<code>链表</code>和<code>红黑树</code>。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>数组</code>：默认初始容量为16，数组的每个位置称为一个桶(<code>Bucket</code>)。容量始终为<strong>2的幂次方</strong>(如16、32)，便于通过位运算快速定位索引。<br><code>链表</code>：当多个键的哈希值冲突时，这些键值对以链表形式存储在同一个桶中（链地址法）。<br><code>红黑树</code>：当链表长度超过阈值（默认8）且数组容量≥64时，链表会转换为<code>红黑树</code>，以提高查找效率（从<code>O(n)</code>优化为<code>O(log n)</code>）。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250727210620835.png" alt="image-20250727210620835"></p>
<h3 id="哈希函数与索引定位"><a href="#哈希函数与索引定位" class="headerlink" title="哈希函数与索引定位"></a>哈希函数与索引定位</h3><p>HashMap通过哈希函数将键映射到数组的索引位置。具体步骤如下：</p>
<ol>
<li><p>调用键的<code>hashCode()</code>方法获取哈希值。</p>
</li>
<li><p><strong>扰动处理：</strong>将高16位与低16位异或<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，减少哈希碰撞概率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过<code>(n-1) &amp; hash</code>计算桶位置，等价于<code>hash % n</code>，但性能更高‌。</p>
</li>
</ol>
<h3 id="冲突处理机制"><a href="#冲突处理机制" class="headerlink" title="冲突处理机制"></a>冲突处理机制</h3><ol>
<li><p><strong>链地址法：</strong>冲突的键值对以链表形式链接。在JDK 8之前采用头插法，JDK 8之后采用尾插法以避免多线程下的死循环问题‌</p>
</li>
<li><p><strong>红黑树转换：</strong></p>
<ol>
<li><p>当链表长度≥8且数组容量≥64时，链表会转换为红黑树‌。</p>
</li>
<li><p>红黑树节点数≤6时，退化为链表</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250623125725272.png" alt="image-20250623125725272"></p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p><strong>红黑树：</strong> 近似平衡二叉树，左右子树高差有可能大于 1，查找效率略低于平衡二叉树，但增删效率高于平衡二叉树，适合频繁插入删除。</p>
<ul>
<li>结点非黑即红；</li>
<li>根结点是黑色，叶节点是黑色空节点（常省略）；</li>
<li>任何相邻节点不能同时为红色；</li>
<li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点；</li>
<li>查询性能稳定O(logN)，高度最高2log(n+1)；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250727210703513.png" alt="image-20250727210703513"></p>
</blockquote>
<h3 id="动态扩容机制"><a href="#动态扩容机制" class="headerlink" title="动态扩容机制"></a>动态扩容机制</h3><p>HashMap的扩容机制基于负载因子（默认值为0.75）。当元素数量超过<code>容量乘以负载因子</code>时，比如<strong>当数组添加到16*0.75=12时</strong>，HashMap会自动触发扩容，扩容为自身的两倍：16*2=32。扩容步骤如下：</p>
<ol>
<li>创建一个新的数组，<code>容量为原容量的两倍</code>（保持2的幂次方）。采用2的指数进行扩容，是为了利用位运算，提高扩容运算的效率。</li>
<li>重新计算所有元素的位置并放入新数组的对应位置，利用高位快速判断元素是否需要移动（如原索引为<code>oldIndex</code>，新索引可能为<code>oldIndex</code>或<code>oldIndex + oldCapacity</code>）。</li>
<li>数组每个元素存的是链表头结点地址，链地址法处理冲突，若链表的长度达到了8，红黑树代替链表。扩容后，链表或红黑树可能会被拆分到不同的桶中‌。</li>
</ol>
<h3 id="HashMap如何计算key"><a href="#HashMap如何计算key" class="headerlink" title="HashMap如何计算key"></a>HashMap如何计算key</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key=value&amp;(2^n-1) <span class="comment"># 结果相当于value%(2^n)，使用位运算只要是为了提高计算速度。</span></span><br></pre></td></tr></table></figure>

<p>例如当前数组容量是16，我们要存取18，那么就可以用18&amp;15==2。相当于18%16==2。</p>
<blockquote>
<p> put()里，计算key的部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// 此处省略了代码</span></span><br><span class="line">    <span class="comment">// i = (n - 1) &amp; hash]</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 省略了代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="HashMap容量为什么是2的n次方"><a href="#HashMap容量为什么是2的n次方" class="headerlink" title="HashMap容量为什么是2的n次方"></a>HashMap容量为什么是2的n次方</h3><p>计算value对应key的Hash运算：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key=value&amp;(2^n-1）<span class="comment">#结果相当于value%(2^n)。例如18&amp;15和18%16值是相等的</span></span><br></pre></td></tr></table></figure>

<p>2^n-1和2^(n+1)-1的二进制除了第一位，后几位都相同。这样<em>使得添加的元素均匀分布在HashMap的每个位置上，防止哈希碰撞</em>。</p>
<p><strong>例如</strong>15的二进制为1111，31的二进制为11111，63的二进制为111111，127的二进制为1111111。</p>
<p><strong>扩容均匀散列演示：从2^4扩容成2^5</strong></p>
<p>0&amp;(2^4-1)=0；0&amp;(2^5-1)=0</p>
<p>16&amp;(2^4-1)=0；16&amp;(2^5-1)=16。所以扩容后，key为0的一部分value位置没变，一部分value迁移到扩容后的新位置。</p>
<p>1&amp;(2^4-1)=1；1&amp;(2^5-1)=1</p>
<p>17&amp;(2^4-1)=1；17&amp;(2^5-1)=17。所以扩容后，key为1的一部分value位置没变，一部分value迁移到扩容后的新位置。</p>
<h3 id="put-流程"><a href="#put-流程" class="headerlink" title="put()流程"></a>put()流程</h3><ol>
<li>计算key存取位置，与运算hash&amp;(2^n-1），实际就是哈希值取余，位运算效率更高。</li>
<li>判断数组，若发现数组为空，则进行首次扩容为初始容量16。</li>
<li>判断数组存取位置的头节点，若发现头节点为空，则新建链表节点，存入数组。</li>
<li>判断数组存取位置的头节点，若发现头节点非空，则看情况将元素覆盖或插入链表（JDK7头插法，JDK8尾插法）、红黑树。</li>
<li>插入元素后，判断元素的个数，若发现超过阈值则以2的指数再次扩容。</li>
</ol>
<p>其中，第3步又可以细分为如下三个小步骤：</p>
<ol>
<li><p>若元素的key与头节点的key一致，则直接覆盖头节点。</p>
</li>
<li><p>若元素为树型节点，则将元素追加到树中。</p>
</li>
<li><p> 若元素为链表节点，则将元素追加到链表中。追加后，需要判断链表长度以决定是否转为红黑树。若链表长度达到8、数组容量未达到64，则扩容。若链表长度达到8、数组容量达到64，则转为红黑树。</p>
</li>
</ol>
<p><strong>哈希表处理冲突：</strong>开放地址法（线性探测、二次探测、再哈希法）、链地址法</p>
<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><ul>
<li><p><strong>遍历EntrySet（键值对）</strong>：支持通过<code>iterator.remove()</code>安全删除元素(优点)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;K, V&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>遍历KeySet（仅键）</strong>：性能低于<code>EntrySet</code>遍历，需多次调用<code>get()</code>（缺点）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;K&gt; keyIterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key); <span class="comment">// 需要额外查询值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for-each循环"></a>for-each循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历EntrySet</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历键</span></span><br><span class="line"><span class="keyword">for</span> (K key : map.keySet()) &#123; ... &#125;</span><br><span class="line"><span class="comment">// 遍历值</span></span><br><span class="line"><span class="keyword">for</span> (V value : map.values()) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式遍历（Java-8-）"><a href="#Lambda表达式遍历（Java-8-）" class="headerlink" title="Lambda表达式遍历（Java 8+）"></a>Lambda表达式遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach( (key, value) -&gt; System.out.println(key + <span class="string">&quot; : &quot;</span> + value) );</span><br></pre></td></tr></table></figure>

<h3 id="Stream-API遍历（Java-8-）"><a href="#Stream-API遍历（Java-8-）" class="headerlink" title="Stream API遍历（Java 8+）"></a>Stream API遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单线程遍历</span></span><br><span class="line">map.entrySet().stream().forEach(entry -&gt; ...);</span><br><span class="line"><span class="comment">// 多线程遍历</span></span><br><span class="line">map.entrySet().parallelStream().forEach(entry -&gt; ...);</span><br></pre></td></tr></table></figure>

<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><table>
<thead>
<tr>
<th><strong>遍历方式</strong></th>
<th><strong>时间复杂度</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>线程安全</strong></th>
</tr>
</thead>
<tbody><tr>
<td>EntrySet迭代器</td>
<td>O(n)</td>
<td>需要删除元素</td>
<td>需手动同步</td>
</tr>
<tr>
<td>EntrySet for-each</td>
<td>O(n)</td>
<td>常规遍历</td>
<td>需手动同步</td>
</tr>
<tr>
<td>KeySet遍历</td>
<td>O(n)（性能较低）</td>
<td>仅需键</td>
<td>需手动同步</td>
</tr>
<tr>
<td>Lambda表达式</td>
<td>O(n)</td>
<td>代码简洁性优先</td>
<td>需手动同步</td>
</tr>
<tr>
<td>Stream API</td>
<td>O(n)</td>
<td>大数据量处理或并行计算</td>
<td>需手动同步</td>
</tr>
</tbody></table>
<p><strong>推荐选择</strong>：</p>
<ul>
<li><strong>需键值对</strong>：优先使用<code>entrySet()</code>（迭代器或for-each）。</li>
<li><strong>仅需键或值</strong>：直接遍历<code>keySet()</code>或<code>values()</code>。</li>
<li><strong>代码简洁性</strong>：Java 8+环境下推荐Lambda表达式。</li>
<li><strong>线程安全</strong>：改用<code>ConcurrentHashMap</code>或使用同步包装类。</li>
</ul>
<h2 id="HashMap和HashSet区别"><a href="#HashMap和HashSet区别" class="headerlink" title="HashMap和HashSet区别"></a>HashMap和HashSet区别</h2><p><strong>相同点：</strong></p>
<ul>
<li><p>他们的前缀的是HashXxx，代表他们底层都是哈希表，用hashCode()判断元素是否重复。</p>
<p>哈希表增删改查的时间复杂度是O(1)，缺点是可能出现冲突。</p>
<p>HashXxx都使用哈希算法来确定元素的存储位置，因此插入元素的速度通常比较快。哈希表插入时主要看是否发生冲突，如果key通过哈希算法计算后的值所处位置已有元素，则需要根据链地址法或开放地址法处理冲突。</p>
</li>
</ul>
<p><strong>不同点：</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">HashMap</th>
<th align="left">HashSet</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>接口</strong></td>
<td align="left">实现了 Map 接口</td>
<td align="left">实现了 Set 接口</td>
</tr>
<tr>
<td align="left"><strong>存储结构</strong></td>
<td align="left">存储<strong>键值对</strong>（Key-Value pairs）</td>
<td align="left">仅存储<strong>对象</strong>（Unique elements）</td>
</tr>
<tr>
<td align="left"><strong>存储方式</strong></td>
<td align="left">使用 put() 方法将元素放入 Map 中</td>
<td align="left">使用 add() 方法将元素放入 Set 中</td>
</tr>
<tr>
<td align="left"><strong>底层实现</strong></td>
<td align="left">基于哈希表，使用数组+链表+红黑树</td>
<td align="left">基于 <strong>HashMap</strong> 实现<strong>HashMap 的key是每个元素</strong>value是一个私有常量对象PRESENT，仅用于占位。</td>
</tr>
<tr>
<td align="left"><strong>存储内容</strong></td>
<td align="left">键和值都可以为 null，键最多只能有一个 null</td>
<td align="left">仅允许一个 null 元素因为它底层是HashMap的key，键只允许一个null</td>
</tr>
<tr>
<td align="left"><strong>是否允许重复</strong></td>
<td align="left">键不允许重复，值可以重复</td>
<td align="left">不允许重复元素</td>
</tr>
<tr>
<td align="left"><strong>时间复杂度</strong></td>
<td align="left">插入、删除、查找的平均时间复杂度为 O(1)</td>
<td align="left">插入、删除、查找的平均时间复杂度为 O(1)，但 contains() 时间复杂度可能更高</td>
</tr>
<tr>
<td align="left"><strong>插入速度</strong></td>
<td align="left">比较快，因为底层是哈希表</td>
<td align="left">比较快，因为底层是哈希表</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">需要键值对映射的场景</td>
<td align="left">需要存储唯一元素、自动去重的场景</td>
</tr>
</tbody></table>
<h2 id="HashMap安全"><a href="#HashMap安全" class="headerlink" title="HashMap安全"></a>HashMap安全</h2><p>HashMap是线程不安全的，多线程环境下建议使用Collections工具类和JUC包的ConcurrentHashMap。</p>
<blockquote>
<ul>
<li><strong>线程安全：</strong>程序在多线程环境下可以持续进行正确的处理，不会产生数据竞争（例如死锁）和不一致的问题。</li>
</ul>
</blockquote>
<h3 id="HashMap线程不安全的表现"><a href="#HashMap线程不安全的表现" class="headerlink" title="HashMap线程不安全的表现"></a>HashMap线程不安全的表现</h3><ol>
<li><p><strong>JDK8 put时数据覆盖（丢失）</strong><br><strong>场景：</strong>多线程同时调用 <code>put()</code> 方法插入数据。<br><strong>原因：</strong>两个线程同时计算哈希值并定位到同一个桶(bucket)时，若该位置为空，可能发生数据覆盖。<strong>无锁导致复合操作非原子性</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设线程A和线程B同时执行以下代码</span></span><br><span class="line"><span class="keyword">if</span> (table[bucket] == <span class="literal">null</span>) &#123;</span><br><span class="line"> table[bucket] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value); <span class="comment">// 可能被覆盖</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK 1.8 的数据覆盖问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapUnsafeDemo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">             map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">             map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     t1.start();</span><br><span class="line">     t2.start();</span><br><span class="line">     t1.join();</span><br><span class="line">     t2.join();</span><br><span class="line">     System.out.println(<span class="string">&quot;Map size: &quot;</span> + map.size()); <span class="comment">// 结果可能小于 1000</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 底层源码</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)     <span class="comment">// 如果没有 hash 碰撞，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>链表成环</strong>（JDK7 的经典问题）<br><strong>场景：</strong>多线程同时触发 <code>resize()</code>（扩容）。<br><strong>原因：</strong>JDK7 的 HashMap 使用<strong>头插法</strong>迁移链表，<strong>并发扩容时可能导致链表成环</strong>，后续的 <code>get()</code>操作触发死循环。</p>
<p><strong>单线程扩容流程</strong>：JDK7中，HashMap链地址法处理冲突时采用头插法，在扩容时依然头插法，所以链表里结点顺序会反过来。</p>
<p>假如有T1、T2两个线程同时对某链表扩容，他们都标记头结点和第二个结点，此时T2阻塞，T1执行完扩容后链表结点顺序反过来，此时T2恢复运行再进行翻转就会产生环形链表，即B.next=A; A.next=B，从而死循环。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250724151230023.png" alt="image-20250724151230023"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.7 的扩容代码（简化）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">     <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">         Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程A执行到这里挂起</span></span><br><span class="line">         e.next = newTable[bucket]; <span class="comment">// 线程B先执行，导致链表成环</span></span><br><span class="line">         newTable[bucket] = e;</span><br><span class="line">         e = next;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK8 尾插法：</strong>JDK8中，HashMap采用尾插法，扩容时链表节点位置不会翻转，解决了扩容死循环问题，但是性能差了一点，因为要遍历链表再查到尾部。 例如A——&gt;B——&gt;C要迁移，迁移时先移动头结点A，再移动B并插入A的尾部，再移动C插入尾部，这样结果还是A——&gt;B——&gt;C。顺序没变，扩容线程。</p>
</li>
<li><p><strong>size 不准确</strong><br><strong>场景：</strong>多线程同时调用 <code>put()</code> 或 <code>remove()</code>。<br><strong>原因：</strong>size 变量是非原子操作（如 size++），并发修改可能导致最终值错误。<strong>非原子操作 + 无可见性保证</strong>。</p>
</li>
<li><h5 id="modCount非原子性自增问题"><a href="#modCount非原子性自增问题" class="headerlink" title="modCount非原子性自增问题"></a><strong>modCount非原子性自增问题</strong></h5><p>modCount： HashMap的成员变量，用于记录HashMap被修改次数</p>
<p>put会执行modCount++操作（modCount是HashMap的成员变量，用于记录HashMap被修改次数），这步操作分为读取、增加、保存，不是一个原子性操作，也会出现线程安全问题。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// put会执行modCount++操作，这步操作分为读取、增加、保存，不是一个原子性操作，也会出现线程安全问题。 </span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="HashMap线程不安全的根本原因"><a href="#HashMap线程不安全的根本原因" class="headerlink" title="HashMap线程不安全的根本原因"></a>HashMap线程不安全的根本原因</h3><ol>
<li><strong>无同步机制</strong><br>HashMap 的设计目标是单线程高性能，未对多线程操作进行同步（如 <code>synchronized</code> 或 <code>CAS</code>）。<br>关键操作（<code>put()、get()、resize()</code>）没有锁保护。</li>
<li><strong>可见性问题</strong><br>多线程修改共享变量（如 <code>table、size</code>）时，未使用 <code>volatile</code> 关键字，可能导致一个线程的修改对其他线程不可见。</li>
<li><strong>复合操作非原子性</strong><br>例如 <code>put()</code> 操作包含多个步骤（计算哈希、定位桶、插入节点），多线程交叉执行时可能破坏内部结构。</li>
</ol>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>原子类、volatile、锁、线程安全的集合 </p>
<ol>
<li>使用线程安全的替代类<pre><code>`Collections.synchronizedMap()`：通过包装类对所有方法加锁（性能较差）。
`ConcurrentHashMap`：分段锁（JDK 1.7）或 CAS + synchronized（JDK 1.8），高并发性能更好。
</code></pre>
</li>
<li>避免多线程直接操作 HashMap<br>限制为单线程使用，或通过副本、消息队列等方式隔离并发访问。</li>
</ol>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>在<code>jdk1.7</code>版本<ul>
<li>ConcurrentHashMap的数据结构是由一个<code>Segment</code>数组和多个<code>HashEntry</code>组成。</li>
<li>主要实现原理是实现了<strong>锁分离</strong>的思路，采用<strong>分段锁的机制</strong>，实现并发的更新操作。</li>
<li>底层采用<strong>数组+链表</strong>的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。</li>
<li>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到 的锁分离技术。每一个Segment元素存储的是HashEntry 数组+链表（若干个桶），这个和HashMap的数据存储结构一样。</li>
<li>HashEntry用来封装映射表的键值对，每个桶是由若干个HashEntry对象链接起来的链表。</li>
</ul>
</li>
<li>在<code>jdk1.8</code>后<ul>
<li>取消了Segment类，直接用table数组存储键值对。采用<code>Node + CAS + Synchronized</code>来保证并发安全。</li>
<li>Node数据结构比较简单，就是一个链表，但是只允许对数据进行查找，不允许进行修改。</li>
<li>当HashEntry对象组成的链表长度超过8时，或数组长度小于64 就会扩容，则链表转换为红黑树，提升性能。底层变更为<strong>数组＋链表＋红黑树</strong>。</li>
</ul>
</li>
</ul>
<h4 id="底层原理（jdk1-8）"><a href="#底层原理（jdk1-8）" class="headerlink" title="底层原理（jdk1.8）"></a>底层原理（jdk1.8）</h4><ol>
<li><p>Node节点数字用的是<code>volatile</code>修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap使用volatile修饰节点数组，保证其可见性，禁止指令重排。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li>
<li><p>ConcurrentHashMap的<code>put()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put()方法直接调用putVal()方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以直接看putVal()方法。</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            tab = initTable();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;                  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put方法并未用synchronized修饰。<strong>put过程如下：</strong><br>（1）根据 key 计算出 hashcode，然后开始遍历 table；<br>（2）判断是否需要初始化；<br>（3）f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。<br>（4）如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。<br>（5）如果都不满足，则利用 synchronized 锁写入数据。<br>（6）如果数量大于 TREEIFY_THRESHOLD ，则要转换为红黑树。</p>
</li>
<li><p>ConcurrentHashMap的<code>get()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap的get()方法是不加锁的，方法内部也没加锁。</span></span><br><span class="line"><span class="comment">// 因为table有`volatile`关键字修饰，保证每次获取值都是最新的。</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span></span><br></pre></td></tr></table></figure>

<p>get方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头节点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果头节点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get过程如下：</strong><br>（1）首先根据key计算出来的 hashcode 寻址，如果就在桶上那么直接返回值，<br>（2）如果是红黑树那就按照树的方式获取值，<br>（3）都不满足那就按照链表的方式遍历获取值。</p>
</li>
</ol>
<hr>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37741420/article/details/112407684">Java集合（四）Set的常用实现类</a></p>
<p>List是有序集合的根接口，Set是无序集合的根接口，无序也就意味着元素不重复。更严格地说，Set集合不包含一对元素e1和e2 ，使得e1.equals(e2) ，并且最多一个空元素。<br>使用Set存储的特点与List相反：<strong>元素无序、不可重复</strong>。常用的实现方式：HashSet、LinkedHashSet和TreeSet。</p>
<table>
<thead>
<tr>
<th>具体实现</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>HashSet</td>
<td>底层数据结构是哈希表，可以存储null元素，效率高</td>
<td>线程不安全，需要重写hashCode()和equals()来保证元素唯一性</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>底层数据结构是链表和哈希表(链表保证了元素的顺序与存储顺序一致，哈希表保证了元素的唯一性)，效率高</td>
<td>线程不安全</td>
</tr>
<tr>
<td>TreeSet</td>
<td>底层数据结构是二叉树，元素唯一且已经排好序</td>
<td>需要重写hashCode和equals()来保证元素唯一性</td>
</tr>
</tbody></table>
<p>当向HashSet结合中存入一个元素时，HashSet会调用该对象的<code>hashCode()</code>方法来得到该对象的hashCode值，然后根据hashCode值来决定该对象在HashSet中存储位置。简单的说，<strong>HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等</strong>。<br>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p>
<p>在使用Set存储数据时，为保障元素唯一性，常常要重写hashCode。重写hashCode方法时，尽量遵循以下原则：</p>
<ul>
<li>相同的对象返回相同的hashCode值。</li>
<li>不同的对象返回不同的hashCode值，否则，就会增加冲突的概率。</li>
<li>尽量的让hashCode值散列开（用异或运算可使结果的范围更广）。</li>
</ul>
<h2 id="Hashset"><a href="#Hashset" class="headerlink" title="Hashset"></a>Hashset</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>HashSet是一个无序集合，其底层结构是HashMap，简单来说，HashSet是value是固定值（<code>Object PRESENT = new Object()</code>）的HashMap。HashSet的特点(<strong>底层是HashMap/元素无序且不能重复/线程不安全</strong>)：</p>
<ul>
<li><p><strong>使用场景：</strong>需要高效去重、快速查找、不考虑内存浪费的场景</p>
</li>
<li><p>HashSet的<strong>底层实现是HashMap</strong>（HashSet的值存放于HashMap的key上，HashMap的value是一个统一的值）。</p>
</li>
<li><p><strong>底层：</strong>哈希表（快速查找）和Set（去重）。它自动对元素进行去重（通过 hashCode 和 equals 方法），并且无序（存入后顺序会乱），允许存储一个null值。</p>
</li>
<li><p><strong>性能：</strong>底层是哈希表，所以插入、删除和查找操作的时间复杂度都是O(1)，代价是浪费一些空间。</p>
</li>
<li><p><strong>线程不安全</strong>。如果要保证线程安全，其中一种方法是将其改造成线程安全的类，示例：    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>(...));</span><br></pre></td></tr></table></figure></li>
</ul>
<p>哈希表是元素为链表的数组，默认容量16，负载因子0.75，处理冲突方法是链地址法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet&lt;String &gt; h = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        h.add(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">        h.add(s1);</span><br><span class="line">        System.out.println(s1 == <span class="string">&quot;nihao&quot;</span>);        <span class="comment">//false</span></span><br><span class="line">        <span class="keyword">for</span>(String s:h) System.out.println(s);     <span class="comment">//不含重复元素 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果Hashset里的元素是对象，若想将成员变量相同视为对象相同，要重写hashCode()：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    <span class="comment">//输出23</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>);</span><br><span class="line">        HashSet&lt;Dog&gt; h = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Dog&gt;();</span><br><span class="line">        h.add(dog1);h.add(dog2);</span><br><span class="line">        <span class="keyword">for</span>(Dog dog:h)&#123;</span><br><span class="line">            System.out.println(dog.weight); </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//         System.out.println(&quot;doggouzaao&quot;);</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> weight)</span>&#123;</span><br><span class="line">         <span class="built_in">this</span>.weight=weight;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;dogname&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// alt+insert生成equals()和hashCode()方法。这里只需重写hashCode方法就能保证自动去重，equals方法用于元素间的比较</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) o;</span><br><span class="line">        <span class="keyword">return</span> weight == dog.weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h3><p><strong>HashSet自动去重的原理：</strong>hashCode值。</p>
<p>所有Java的类或接口都直接或间接继承了Object类，Object类是一切类的根类。Object类有<code>clone()，HashCode()，equals()，toString()，wait()，notify()</code>等基本方法，可以重写这些方法，对类的特性进行设置。</p>
<p>例如给测试类新加一个hashCode()方法，而不加@Override注解（用于声明一个方法为重写的方法），编译器将进行警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译器将进行警告：hashCode()&#x27;缺少&#x27;@Override&#x27;注解</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，哈希值是根据对象的地址计算出的一个整数值，故同一对象的哈希值一定相同（因为地址是同一地址），不同对象的哈希值默认不同（因为地址不同）。</p>
<p>把对象加入HashSet时，HashSet会<strong>先计算对象的hashcode值来判断对象加入的位置</strong>，同时也会与Set中其他元素的hashcode值作比较，如果没有相同的hashcode，HashSet会假设对象没有重复出现。如果发现有相同hashcode值的对象，这时会调用<code>equals</code>方法来检查<strong>hashcode相等的对象是否真的相同</strong>。如果两者相同，HashSet就不再存储该元素。<code>hashCode()</code>与 <code>equals()</code>的相关规定：</p>
<ul>
<li>如果两个对象相等，则hashcode一定也是相同的；</li>
<li>两个对象相等，对两个equals方法返回true；</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的；</li>
<li>如果equals方法被覆盖过，则hashCode方法也必须被覆盖；</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该 class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ul>
<p>重写hashCode()后哈希值可以相同，例如给Student类重写hashCode()，返回学生的学号，那么学号相同的学生，哈希值就一定相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 hashCode() 方法，返回学号作为哈希值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 equals() 方法，判断学号是否相同</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) obj;</span><br><span class="line">        <span class="keyword">return</span> id == student.id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 toString() 方法，返回学生姓名和学号</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, id=&quot;</span> + id + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 根据重写的 equals() 方法输出</span></span><br><span class="line">        System.out.println(student1.equals(student2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(student1.hashCode()); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(student2.hashCode()); <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// 根据重写的 toString() 方法输出</span></span><br><span class="line">        System.out.println(student1.toString()); <span class="comment">// Student&#123;name=&#x27;Tom&#x27;, id=1&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> <span class="comment">// 默认初始容量为16，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> <span class="comment">// 指定初始容量，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> <span class="comment">// 指定初始容量和负载因子</span></span><br><span class="line"><span class="comment">/* 增、删、包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断Set是否为空    </span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> <span class="comment">//获取迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 返回此集合中的元素数        </span></span><br></pre></td></tr></table></figure>

<h3 id="知识加油站-1"><a href="#知识加油站-1" class="headerlink" title="知识加油站"></a>知识加油站</h3><h4 id="equals-和hashcode-的关系"><a href="#equals-和hashcode-的关系" class="headerlink" title="equals()和hashcode()的关系"></a>equals()和hashcode()的关系</h4><p><strong>两者在用途上的区别：</strong></p>
<ul>
<li>hashCode()方法的主要用途是获取哈希码；</li>
<li>equals()主要用来比较两个对象是否相等。</li>
</ul>
<h4 id="为什么重写equals-就要重写hashcode"><a href="#为什么重写equals-就要重写hashcode" class="headerlink" title="为什么重写equals()就要重写hashcode()"></a><strong>为什么重写equals()就要重写hashcode()</strong></h4><p>因为二者之间有两个约定，<strong>相等对象的哈希码也要相等</strong>。所以equals()方法重写时，通常也要将hashCode()进行重写，使得这两个方法始终满足相关的约定。 例如HashSet排序机制底层就是通过计算哈希码进行排序的，如果只重写equals()将达不到根据哈希码排序的效果。</p>
<p>如果两个对象相等，它们必须有相同的哈希码；但如果两个对象的哈希码相同，他们却不一定相等。</p>
<h4 id="与equals-的区别"><a href="#与equals-的区别" class="headerlink" title="==与equals()的区别"></a><code>==</code>与equals()的区别</h4><ul>
<li><p><strong><code>==</code></strong> 比较基本数据类型时，比较的是两个数值是否相等； 比较引用类型是，比较的是对象的内存地址是否相等。  </p>
</li>
<li><p><strong><code>equals()</code></strong> 未重写时，Object类默认以<code>==</code>来实现，即比较两个对象的内存地址是否相等； 重写以后，按照重写的逻辑进行比较。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(0bject obj)</span> &#123; <span class="keyword">return</span>(<span class="built_in">this</span> == obj); &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>LinkedHashSet是有序集合，其底层是通过LinkedHashMap来实现的，LinkedHashMap其实也就是value是固定值的LinkedHashMap。因此LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。LinkedHashSet继承了HashSet。LinkedHashSet的特点(<strong>底层是LinkedHashMap/线程不安全/元素有序</strong>)：</p>
<ul>
<li><p>底层是用LinkedHashMap来实现的。</p>
</li>
<li><p>线程不安全 。</p>
</li>
<li><p>元素有序，是按照插入的顺序排序的。</p>
</li>
<li><p>最多只能存一个null。</p>
</li>
<li><p>不支持按访问顺序对元素排序</p>
<p>LinkedHashSet所有的构造方法都是调用HashSet的同一个构造方法：（accessOrder = false）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li><p><strong>使用场景：</strong>适用于多读少写、排序的场景。</p>
</li>
<li><p><strong>底层：</strong>红黑树（快速查找、排序）和Set（去重）。<strong>不允许存储null值</strong></p>
</li>
<li><p><strong>性能：</strong>插入、删除、查找操作的时间复杂度为O(log n)，因为操作需要维护树的平衡，所以适用于多读少写的场景。</p>
</li>
</ul>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>TreeSet是一个有序集合，基于TreeMap实现。TreeSet特点(<strong>支持元素排序/线程不安全/去重复</strong>):</p>
<ul>
<li><p>TreeSet的基本操作（增删）的时间复杂度是log(n) 。</p>
</li>
<li><p>TreeSet是非线程安全的。</p>
</li>
<li><p>TreeSet的迭代器是fail-fast策略的。</p>
</li>
<li><p>TreeSet中元素不允许为null，不允许重复值。</p>
</li>
<li><p>TreeSet有序（自然顺序或自定义排序器）。支持元素自然排序和按照在创建时指定Comparator比较器(外比较器)进行排序：</p>
<ul>
<li>TreeSet使用二叉树原理对新增对象按照指定顺序排序，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li>
</ul>
</li>
</ul>
<pre><code>- TreeSet中存储自定义类的对象时， 自定义的类必须实现Comparable接口，并且覆写相应`compareTo()`函数。


- **元素为基本类型时自然有序：**new TreeSet&lt;int&gt;()。如果TreeSet内元素是**基本数据类型**，它会自动去重有序。Integer和String对象都可以进行默认的TreeSet排序。


- **元素为类时自然或比较器排序：**new TreeSet&lt;类&gt;(Comperable c)。如果TreeSet内元素是类，要实现去重有序，有两种方法。

  - **自然排序：**类要实现Comparable&lt;&gt;接口，并重写compareTo（T）方法；

  - **比较器排序：**以比较器作为构造参数，创建TreeSet对象。如果即实现了Comparable&lt;&gt;接口，又指定了比较器，则使用比较器排序。

  - 在重写compareTo()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。示例：

    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>  <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(student s)</span> &#123;</span><br><span class="line">        <span class="comment">// 主要条件：按照年龄从小到大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="built_in">this</span>.age - s.age;</span><br><span class="line">        <span class="comment">//次要条件：年龄相同时，按照姓名的字母顺序排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num == <span class="number">0</span> ? <span class="built_in">this</span>.name.compareTo(s.name) : num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comparabledemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;student&gt; tree = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;student&gt;();</span><br><span class="line">        <span class="type">student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;wuer&quot;</span>,<span class="number">27</span>);</span><br><span class="line">        <span class="type">student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;weuers&quot;</span>,<span class="number">250</span>);</span><br><span class="line">        tree.add(s1);</span><br><span class="line">        tree.add(s2);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="方法一：自然排序"><a href="#方法一：自然排序" class="headerlink" title="方法一：自然排序"></a>方法一：自然排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗类：按自然排序时要实现Comperable&lt;&gt;并重写compareTo()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span>  <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt;&#123;        </span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    String name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> weight, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123; weight=&quot;</span> + weight + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog dog)</span>&#123;    <span class="comment">// 实参是上一只狗，本狗与上狗做比较</span></span><br><span class="line">        <span class="comment">// 返回正数，即本狗比上只狗大，按存取顺序排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// return -1; 存储逆序排序</span></span><br><span class="line">        <span class="comment">// return 0; 视为相等，后插入的重复元素会被删除。</span></span><br><span class="line">        <span class="comment">// return this.weight-dog.weight; 按体重从小到大排序，后狗-前狗。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建两个小狗对象，让他们按自己compareTo()逻辑排序，即按存取顺序排序</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">45</span>,<span class="string">&quot;abc&quot;</span>); <span class="type">Dog</span> <span class="variable">dog3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">45</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        TreeSet&lt;Dog&gt; dogs = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        dogs.add(dog1);dogs.add(dog2);dogs.add(dog3);</span><br><span class="line">        <span class="comment">// 因为第三只狗和第二只狗存取顺序不同，所以他们被认为是两只狗</span></span><br><span class="line">        <span class="comment">// [Dog&#123;weight=23, name=&#x27;abc&#x27;&#125;, Dog&#123;weight=45, name=&#x27;abc&#x27;&#125;, Dog&#123;weight=45, name=&#x27;abc&#x27;&#125;]</span></span><br><span class="line">        System.out.println(dogs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：比较器排序"><a href="#方法二：比较器排序" class="headerlink" title="方法二：比较器排序"></a>方法二：比较器排序</h3><p>无需Dog类再实现Comparable接口，直接TreeSet类带参构造方式创建对象即可，参数为比较器Comparator&lt;&gt;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗类：按比较器排序时不需要再实现Comperable&lt;&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> weight, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123; weight=&quot;</span> + weight + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) o;</span><br><span class="line">        <span class="keyword">return</span> weight == dog.weight &amp;&amp; Objects.equals(name, dog.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(weight, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//下面比较器也可以用Lambda表达式形式，即TreeSet&lt;&gt;((a,b)-&gt;&#123;..&#125;)</span></span><br><span class="line">        TreeSet&lt;Dog&gt; dogs=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Dog&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Dog a, Dog b)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a.weight!=b.weight) &#123;</span><br><span class="line">                    <span class="keyword">return</span> a.weight-b.weight;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> a.name.compareTo(b.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">34</span>,<span class="string">&quot;abc&quot;</span>)); dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">26</span>,<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">26</span>,<span class="string">&quot;abcd&quot;</span>)); dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">26</span>,<span class="string">&quot;abcd&quot;</span>));</span><br><span class="line">        <span class="comment">// 可以看见，前三只狗按体重、名称排序，第四只狗被去重了</span></span><br><span class="line">        <span class="comment">// [Dog&#123;weight=26, name=&#x27;abc&#x27;&#125;, Dog&#123;weight=26, name=&#x27;abcd&#x27;&#125;, Dog&#123;weight=34, name=&#x27;abc&#x27;&#125;]</span></span><br><span class="line">        System.out.println(dogs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> <span class="comment">// 创建一个空的 TreeSet，使用自然排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> <span class="comment">// 指定比较器，如果比较器是 null 将使用自然排序</span></span><br><span class="line"><span class="comment">/* 增 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> <span class="comment">// 添加一个元素</span></span><br><span class="line"><span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> <span class="comment">// 添加集合中的元素</span></span><br><span class="line"><span class="comment">/* 删 */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> <span class="comment">// 检索和删除最小（第一个）元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> <span class="comment">// 检索和删除最大（最后）元素</span></span><br><span class="line"><span class="comment">/* 包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 获取特殊元素 */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">last</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">first</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">floor</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中小于或者等于给定元素的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">ceiling</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中大于或者等于给定元素的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">higher</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中大于某个元素的最小的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">lower</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中小于某个元素的最大的元素   </span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 获取TreeSet元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断TreeSet是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空TreeSet</span></span><br></pre></td></tr></table></figure>

<h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><p><strong>相同点：</strong>元素都可以自动去重</p>
<p><strong>不同点：</strong></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">HashSet</th>
<th><strong>TreeSet</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>实现</strong></td>
<td align="left">基于哈希表 实现</td>
<td>基于红黑树 (Red-Black Tree) 实现</td>
</tr>
<tr>
<td align="left"><strong>排序</strong></td>
<td align="left">不保证顺序</td>
<td>按自然顺序或指定的比较器排序</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">插入、删除和查找操作的时间复杂度为 O(1)</td>
<td>插入、删除和查找操作的时间复杂度为 O(log n)</td>
</tr>
<tr>
<td align="left"><strong>是否允许 null 元素</strong></td>
<td align="left">允许存储一个 null 元素</td>
<td>不允许存储 null 元素</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">适用于对顺序无要求、自动去重、快速查找和插入的场景</td>
<td>适用于需要自动有序、去重存储的场景</td>
</tr>
<tr>
<td align="left"><strong>去重原理</strong></td>
<td align="left">通过复写hashCode()方法和equals()方法来保证</td>
<td>Treeset通过Compareable接口的compareto来保证。</td>
</tr>
</tbody></table>
<hr>
<h1 id="ArrayDeque：双端队列"><a href="#ArrayDeque：双端队列" class="headerlink" title="ArrayDeque：双端队列"></a>ArrayDeque：双端队列</h1><p>ArrayDeque 是 Java 中基于动态数组实现的双端队列（<code>Double-Ended Queue</code>），同时支持栈（Stack）和队列（Queue）的操作。在刷力扣等算法题时经常使用这个集合。</p>
<h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul>
<li>双端操作：可以在队列的头部和尾部高效地插入/删除元素（时间复杂度 O(1)）。</li>
<li>动态扩容：底层是循环数组，容量不足时自动扩容（默认初始容量为 16）。</li>
<li>非线程安全：需手动处理并发问题。</li>
<li>性能高：对比 LinkedList（基于链表），数组结构对 CPU 缓存更友好，随机访问更快。</li>
</ul>
<h2 id="作为栈（先进后出）的核心方法"><a href="#作为栈（先进后出）的核心方法" class="headerlink" title="作为栈（先进后出）的核心方法"></a>作为栈（先进后出）的核心方法</h2><table>
<thead>
<tr>
<th>操作类型</th>
<th>方法名</th>
<th>功能描述</th>
<th>返回值/异常</th>
</tr>
</thead>
<tbody><tr>
<td><strong>增</strong></td>
<td><strong><code>push(E element)</code></strong></td>
<td>压栈（元素添加到头部）</td>
<td>无返回值，队列满时自动扩容</td>
</tr>
<tr>
<td></td>
<td><code>addFirst(E element)</code></td>
<td>同 <code>push</code></td>
<td>队列满时抛出 <code>IllegalStateException</code>（但 <code>ArrayDeque</code> 动态扩容，一般不会）</td>
</tr>
<tr>
<td><strong>删</strong></td>
<td><strong><code>pop()</code></strong></td>
<td>弹栈（移除并返回头部元素）</td>
<td>返回头部元素；栈为空时抛出 <code>NoSuchElementException</code></td>
</tr>
<tr>
<td></td>
<td><code>removeFirst()</code></td>
<td>同 <code>pop()</code></td>
<td>同上</td>
</tr>
<tr>
<td><strong>查</strong></td>
<td><strong><code>peek()/peekFirst()</code></strong></td>
<td>查看栈顶元素（不删除）</td>
<td>返回头部元素；栈为空时返回 <code>null</code></td>
</tr>
<tr>
<td></td>
<td><strong>peekLast()</strong></td>
<td><strong>查看栈尾元素</strong>（不删除）</td>
<td>返回尾部元素；栈为空时返回 <code>null</code></td>
</tr>
</tbody></table>
<h2 id="作为队列（先进先出）的核心方法"><a href="#作为队列（先进先出）的核心方法" class="headerlink" title="作为队列（先进先出）的核心方法"></a>作为队列（先进先出）的核心方法</h2><table>
<thead>
<tr>
<th>操作类型</th>
<th>方法名</th>
<th>功能描述</th>
<th>返回值/异常</th>
</tr>
</thead>
<tbody><tr>
<td><strong>增</strong></td>
<td><strong><code>offer(E element)</code></strong></td>
<td>入队（元素添加到尾部）</td>
<td>成功返回 <code>true</code>，队列满时返回 <code>false</code>（但 <code>ArrayDeque</code> 动态扩容，总是成功）</td>
</tr>
<tr>
<td></td>
<td><code>addLast(E element)</code></td>
<td>同 <code>offer</code></td>
<td>队列满时抛出 <code>IllegalStateException</code>（理论上不会触发）</td>
</tr>
<tr>
<td><strong>删</strong></td>
<td><strong><code>poll()</code></strong></td>
<td>出队（移除并返回头部元素）</td>
<td>返回头部元素；队列为空时返回 <code>null</code></td>
</tr>
<tr>
<td></td>
<td><code>removeFirst()</code></td>
<td>同 <code>poll()</code></td>
<td>队列为空时抛出 <code>NoSuchElementException</code></td>
</tr>
<tr>
<td><strong>查</strong></td>
<td><strong><code>peek()/peekFirst()</code></strong></td>
<td>查看队首元素（不删除）</td>
<td>返回头部元素；队列为空时返回 <code>null</code></td>
</tr>
<tr>
<td></td>
<td><strong>peekLast()</strong></td>
<td><strong>查看队尾元素</strong>（不删除）</td>
<td>返回尾部元素；队列为空时返回 <code>null</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈</span></span><br><span class="line">ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 压栈</span></span><br><span class="line">stack.push(<span class="number">1</span>); stack.push(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 查看栈顶</span></span><br><span class="line">System.out.println(stack.peek()); <span class="comment">// 输出 2</span></span><br><span class="line"><span class="comment">// 弹栈</span></span><br><span class="line"><span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop(); <span class="comment">// 返回 2，栈中剩余 [1]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line">ArrayDeque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line">queue.offer(<span class="number">1</span>); queue.offer(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 查看队首</span></span><br><span class="line">System.out.println(queue.peek()); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 返回 1，队列中剩余 [2]</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://southernfish.github.io">Southern Fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://southernfish.github.io/2025/07/23/java/java-base-5-collection/">https://southernfish.github.io/2025/07/23/java/java-base-5-collection/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://southernfish.github.io" target="_blank">Southern Fish</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></div><div class="post_share"><div class="social-share" data-image="/img/article/article4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/23/java/java-base-6-generics/"><img class="prev-cover" src="/img/article/article1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java中的泛型</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/23/java/java-base-4-exceptions/"><img class="next-cover" src="/img/article/article2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JAVA 异常</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/06/20/java/java-jvm/" title="JVM"><img class="cover" src="/img/article/article6.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-20</div><div class="title">JVM</div></div></a></div><div><a href="/2025/06/19/java/java-network/" title="网络编程"><img class="cover" src="/img/article/article2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="title">网络编程</div></div></a></div><div><a href="/2025/06/19/java/java-object-copy/" title="对象克隆"><img class="cover" src="/img/article/article4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="title">对象克隆</div></div></a></div><div><a href="/2025/06/19/java/java-web/" title="Java Web"><img class="cover" src="/img/article/article1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="title">Java Web</div></div></a></div><div><a href="/2025/06/24/java/java-encription/" title="java的加密方式"><img class="cover" src="/img/article/article3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-24</div><div class="title">java的加密方式</div></div></a></div><div><a href="/2025/07/23/java/java-base-4-exceptions/" title="JAVA 异常"><img class="cover" src="/img/article/article2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-23</div><div class="title">JAVA 异常</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southern Fish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">74</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SouthernFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1002721576@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">天下事岂能尽如吾意，心境须恰适，尽其在我，随遇而安。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB"><span class="toc-number">1.</span> <span class="toc-text">集合体系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%92%8C%E6%98%A0%E5%B0%84"><span class="toc-number">1.1.</span> <span class="toc-text">集合和映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%92%8C%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.</span> <span class="toc-text">常见集合的底层和性能对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">1.3.</span> <span class="toc-text">知识加油站</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">集合的线程安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">什么是线程不安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E5%B8%B8%E7%94%A8API"><span class="toc-number">1.5.</span> <span class="toc-text">Collection常用API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.6.</span> <span class="toc-text">常用工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BBCollections"><span class="toc-number">1.6.1.</span> <span class="toc-text">集合工具类Collections</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayList"><span class="toc-number">2.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%92%8C%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">底层源码和扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.</span> <span class="toc-text">线程不安全问题和解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">六种遍历方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84-for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.4.1.</span> <span class="toc-text">常规 for 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA-for-%E5%BE%AA%E7%8E%AF%EF%BC%88%E5%8F%AA%E9%81%8D%E5%8E%86%E4%B8%8D%E4%BF%AE%E6%94%B9%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">增强 for 循环（只遍历不修改）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator%EF%BC%88%E9%81%8D%E5%8E%86%E5%B9%B6%E4%BF%AE%E6%94%B9%EF%BC%89"><span class="toc-number">2.4.3.</span> <span class="toc-text">迭代器 Iterator（遍历并修改）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-ListIterator-%EF%BC%88%E5%8F%8C%E5%90%91%E9%81%8D%E5%8E%86%E5%B9%B6%E4%BF%AE%E6%94%B9%EF%BC%89"><span class="toc-number">2.4.4.</span> <span class="toc-text">迭代器 ListIterator （双向遍历并修改）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%8F%AA%E9%81%8D%E5%8E%86%E4%B8%8D%E4%BF%AE%E6%94%B9%EF%BC%89"><span class="toc-number">2.4.5.</span> <span class="toc-text">forEach + Lambda 表达式（只遍历不修改）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream-API-%E9%81%8D%E5%8E%86%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%8C%E5%B9%B6%E5%8F%91%E9%81%8D%E5%8E%86%E5%B9%B6%E4%BF%AE%E6%94%B9%EF%BC%89"><span class="toc-number">2.4.6.</span> <span class="toc-text">Stream API 遍历（推荐，并发遍历并修改）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A%E5%85%AD%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.4.7.</span> <span class="toc-text">小结：六种遍历方法的适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">主要实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%EF%BC%8CLinkedList%EF%BC%8CVector-%E5%AF%B9%E6%AF%94"><span class="toc-number">3.2.</span> <span class="toc-text">ArrayList，LinkedList，Vector 对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.5.</span> <span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">遍历方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">去重方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.8.</span> <span class="toc-text">List 与数组的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-%E7%9A%84%E5%85%83%E7%B4%A0%E5%88%A4%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">3.9.</span> <span class="toc-text">List 的元素判断机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E7%9A%84%E5%AE%89%E5%85%A8%E7%B1%BB"><span class="toc-number">3.10.</span> <span class="toc-text">List的安全类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%9A%84%E5%AE%89%E5%85%A8%E7%B1%BBVector"><span class="toc-number">3.10.1.</span> <span class="toc-text">Java的安全类Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JUC%E4%B8%8B%E7%9A%84%E5%AE%89%E5%85%A8List%E9%9B%86%E5%90%88"><span class="toc-number">3.10.2.</span> <span class="toc-text">JUC下的安全List集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B"><span class="toc-number">3.11.</span> <span class="toc-text">面向接口编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LinkedList%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.</span> <span class="toc-text">LinkedList接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">4.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">4.3.</span> <span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.</span> <span class="toc-text">ArrayList和LinkedList的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ListIterator"><span class="toc-number">5.</span> <span class="toc-text">ListIterator</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">5.1.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">5.2.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap"><span class="toc-number">6.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">6.1.</span> <span class="toc-text">基本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-3"><span class="toc-number">6.1.1.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">6.1.2.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%AE%9A%E4%BD%8D"><span class="toc-number">6.2.2.</span> <span class="toc-text">哈希函数与索引定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.3.</span> <span class="toc-text">冲突处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.4.</span> <span class="toc-text">动态扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97key"><span class="toc-number">6.2.5.</span> <span class="toc-text">HashMap如何计算key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%AE%B9%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84n%E6%AC%A1%E6%96%B9"><span class="toc-number">6.2.6.</span> <span class="toc-text">HashMap容量为什么是2的n次方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put-%E6%B5%81%E7%A8%8B"><span class="toc-number">6.2.7.</span> <span class="toc-text">put()流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">遍历方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.1.</span> <span class="toc-text">迭代器遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-each%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.3.2.</span> <span class="toc-text">for-each循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%81%8D%E5%8E%86%EF%BC%88Java-8-%EF%BC%89"><span class="toc-number">6.3.3.</span> <span class="toc-text">Lambda表达式遍历（Java 8+）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream-API%E9%81%8D%E5%8E%86%EF%BC%88Java-8-%EF%BC%89"><span class="toc-number">6.3.4.</span> <span class="toc-text">Stream API遍历（Java 8+）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">6.3.5.</span> <span class="toc-text">性能对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E5%92%8CHashSet%E5%8C%BA%E5%88%AB"><span class="toc-number">6.4.</span> <span class="toc-text">HashMap和HashSet区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E5%AE%89%E5%85%A8"><span class="toc-number">6.5.</span> <span class="toc-text">HashMap安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E8%A1%A8%E7%8E%B0"><span class="toc-number">6.5.1.</span> <span class="toc-text">HashMap线程不安全的表现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#modCount%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%80%A7%E8%87%AA%E5%A2%9E%E9%97%AE%E9%A2%98"><span class="toc-number">6.5.1.0.1.</span> <span class="toc-text">modCount非原子性自增问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0"><span class="toc-number">6.5.2.</span> <span class="toc-text">HashMap线程不安全的根本原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">6.5.3.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">6.5.4.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">6.5.4.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88jdk1-8%EF%BC%89"><span class="toc-number">6.5.4.2.</span> <span class="toc-text">底层原理（jdk1.8）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Set"><span class="toc-number">7.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hashset"><span class="toc-number">7.1.</span> <span class="toc-text">Hashset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">7.1.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D"><span class="toc-number">7.1.2.</span> <span class="toc-text">HashSet如何检查重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-4"><span class="toc-number">7.1.3.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%8A%A0%E6%B2%B9%E7%AB%99-1"><span class="toc-number">7.1.4.</span> <span class="toc-text">知识加油站</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#equals-%E5%92%8Chashcode-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.1.4.1.</span> <span class="toc-text">equals()和hashcode()的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals-%E5%B0%B1%E8%A6%81%E9%87%8D%E5%86%99hashcode"><span class="toc-number">7.1.4.2.</span> <span class="toc-text">为什么重写equals()就要重写hashcode()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8Eequals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.4.3.</span> <span class="toc-text">&#x3D;&#x3D;与equals()的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">7.2.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeSet"><span class="toc-number">7.3.</span> <span class="toc-text">TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">7.3.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">7.3.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.3.</span> <span class="toc-text">方法一：自然排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%AF%94%E8%BE%83%E5%99%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.4.</span> <span class="toc-text">方法二：比较器排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-5"><span class="toc-number">7.3.5.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E5%92%8CTreeSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.3.6.</span> <span class="toc-text">HashSet和TreeSet的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayDeque%EF%BC%9A%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">ArrayDeque：双端队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">8.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E6%A0%88%EF%BC%88%E5%85%88%E8%BF%9B%E5%90%8E%E5%87%BA%EF%BC%89%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">作为栈（先进后出）的核心方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E9%98%9F%E5%88%97%EF%BC%88%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%89%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">作为队列（先进先出）的核心方法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/28/java/java-design-pattern-behavioral/" title="设计模式-行为型模式"><img src="/img/article/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式-行为型模式"/></a><div class="content"><a class="title" href="/2025/07/28/java/java-design-pattern-behavioral/" title="设计模式-行为型模式">设计模式-行为型模式</a><time datetime="2025-07-28T12:00:00.000Z" title="发表于 2025-07-28 20:00:00">2025-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/28/java/java-design-pattern-structural/" title="设计模式-结构型模式"><img src="/img/article/article6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式-结构型模式"/></a><div class="content"><a class="title" href="/2025/07/28/java/java-design-pattern-structural/" title="设计模式-结构型模式">设计模式-结构型模式</a><time datetime="2025-07-28T07:56:36.000Z" title="发表于 2025-07-28 15:56:36">2025-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/28/java/java-design-pattern-creational/" title="设计模式-创建型模式"><img src="/img/article/article4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式-创建型模式"/></a><div class="content"><a class="title" href="/2025/07/28/java/java-design-pattern-creational/" title="设计模式-创建型模式">设计模式-创建型模式</a><time datetime="2025-07-28T06:10:36.000Z" title="发表于 2025-07-28 14:10:36">2025-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/28/java/java-design-pattern-principle/" title="设计模式七大原则"><img src="/img/article/article3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式七大原则"/></a><div class="content"><a class="title" href="/2025/07/28/java/java-design-pattern-principle/" title="设计模式七大原则">设计模式七大原则</a><time datetime="2025-07-28T02:20:36.000Z" title="发表于 2025-07-28 10:20:36">2025-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/28/java/java-design-pattern/" title="设计模式介绍及简单实现"><img src="/img/article/article2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式介绍及简单实现"/></a><div class="content"><a class="title" href="/2025/07/28/java/java-design-pattern/" title="设计模式介绍及简单实现">设计模式介绍及简单实现</a><time datetime="2025-07-28T01:26:36.000Z" title="发表于 2025-07-28 09:26:36">2025-07-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/article/article4.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Southern Fish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>