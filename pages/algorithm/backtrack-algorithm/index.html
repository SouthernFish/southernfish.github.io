<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>回溯算法 | Southern Fish</title><meta name="keywords" content="algorithm"><meta name="author" content="Southern Fish"><meta name="copyright" content="Southern Fish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="回溯算法是一种通过系统性试探和回退策略搜索问题解的通用方法，适用于组合优化、约束满足等复杂问题，其核心特征是“能进则进，不进则退”的深度优先搜索机制。  参考文章： 回溯算法详解 什么是回溯算法 图论基础及深度优先遍历（DFS）、广度优先遍历（BFS）  回溯算法详解概念回溯算法，又称为“试探法”。是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标">
<meta property="og:type" content="article">
<meta property="og:title" content="回溯算法">
<meta property="og:url" content="https://southernfish.github.io/pages/algorithm/backtrack-algorithm/index.html">
<meta property="og:site_name" content="Southern Fish">
<meta property="og:description" content="回溯算法是一种通过系统性试探和回退策略搜索问题解的通用方法，适用于组合优化、约束满足等复杂问题，其核心特征是“能进则进，不进则退”的深度优先搜索机制。  参考文章： 回溯算法详解 什么是回溯算法 图论基础及深度优先遍历（DFS）、广度优先遍历（BFS）  回溯算法详解概念回溯算法，又称为“试探法”。是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://southernfish.github.io/img/article/article1.png">
<meta property="article:published_time" content="2025-08-06T10:30:36.000Z">
<meta property="article:modified_time" content="2025-09-19T03:11:09.127Z">
<meta property="article:author" content="Southern Fish">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://southernfish.github.io/img/article/article1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://southernfish.github.io/pages/algorithm/backtrack-algorithm/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '回溯算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-19 11:11:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Southern Fish" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">96</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/article/article1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Southern Fish</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">回溯算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-06T10:30:36.000Z" title="发表于 2025-08-06 18:30:36">2025-08-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-19T03:11:09.127Z" title="更新于 2025-09-19 11:11:09">2025-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/algorithm/">algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="回溯算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>回溯算法是一种通过系统性试探和回退策略搜索问题解的通用方法，适用于组合优化、约束满足等复杂问题，其核心特征是“能进则进，不进则退”的深度优先搜索机制。</p>
<blockquote>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2477018">回溯算法详解</a></p>
<p><a target="_blank" rel="noopener" href="https://c.biancheng.net/view/9lsh1qb.html">什么是回溯算法</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2410719">图论基础及深度优先遍历（DFS）、广度优先遍历（BFS）</a></p>
</blockquote>
<h1 id="回溯算法详解"><a href="#回溯算法详解" class="headerlink" title="回溯算法详解"></a>回溯算法详解</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>回溯算法，又称为“试探法”。是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>基本思想：从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p>
<p><strong>八皇后问题</strong>就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。<strong>回溯算法说白了就是穷举法</strong>。不过回溯算法使用<strong>剪枝函数</strong>，<strong>剪去一些不可能到达 <code>最终状态（即答案状态）</code>的节点，从而减少状态空间树节点的生成</strong>。</p>
<p>回溯算法求解问题时，按深度优先搜索策略对解空间树进行搜索，在搜索至解空间树中的任一结点时，先判断该结点是否包含问题的解：</p>
<ul>
<li>若包含问题的解，则沿着该分支继续进行深度优先搜索遍历；</li>
<li>否则，跳过该结点的分支沿着该结点向上一个结点回溯。</li>
</ul>
<p>回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而<strong>回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束</strong>。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。</p>
<h2 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h2><p>深度优先遍历算法采用了回溯思想，从起始节点开始，沿着一条路径尽可能深入地访问节点，直到无法继续前进时为止，然后回溯到上一个未访问的节点，继续深入搜索，直到完成整个搜索过程。</p>
<p>因为遍历到的节点顺序符合「先进后出」的特点，所以深度优先搜索遍历可以通过「栈/递归」来实现。</p>
<p><strong>特点</strong>：一路到底，逐层回退。</p>
<p><strong>用途</strong>：解决找到所有解问题（找到起始–终点的所有路径，此时 DFS 空间占用少）。</p>
<p>例题参见 <a href="#%E7%AE%97%E6%B3%95%E9%A2%98%E4%BA%8C%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89">算法题二（二叉树）</a></p>
<h2 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h2><p>广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外扩张。以此类推，直到完成整个搜索过程。</p>
<p>因为遍历到的节点顺序符合「先进先出」的特点，所以广度优先遍历可以通过「队列」来实现。</p>
<p><strong>特点</strong>：全面扩散，逐层递进。</p>
<p><strong>用途</strong>：解决找到最优解的问题（找到的第一个起始–终点路径，即是最短路径）。</p>
<p>例题参见 <a href="#%E7%AE%97%E6%B3%95%E9%A2%98%E4%B8%89">算法题三</a></p>
<h2 id="回溯VS递归"><a href="#回溯VS递归" class="headerlink" title="回溯VS递归"></a>回溯VS递归</h2><p>在回溯法中可以看到有递归的身影，但两者有区别。  回溯法从问题本身出发，寻找可能实现的所有情况。和穷举法的思想相近，不同在于穷举法是将所有的情况都列举出来以后再一一筛选，而回溯法在列举过程如果发现当前情况根本不可能存在，就停止后续的所有工作，返回上一步进行新的尝试。</p>
<p><strong>递归</strong>是从问题的结果出发，例如求 n！，要想知道 n！的结果，就需要知道 n*(n-1)! 的结果，而要想知道 (n-1)! 结果，就需要提前知道 (n-1)*(n-2)!。这样不断地向自己提问，不断地调用自己的思想就是递归。 </p>
<p> 回溯和递归唯一的联系就是，<strong>回溯法可以用递归思想实现。</strong></p>
<h2 id="回溯算法的实现过程"><a href="#回溯算法的实现过程" class="headerlink" title="回溯算法的实现过程"></a>回溯算法的实现过程</h2><p>使用回溯法解决问题的过程，实际上是建立一棵“状态树”的过程。例如，在解决列举集合{1,2,3}所有子集的问题中，对于每个元素，都有两种状态，取还是舍，所以构建的状态树为：</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807143329560.png" alt="image-20250807143329560"></p>
<p>回溯算法的求解过程实质上是先序遍历“状态树”的过程。树中每一个叶子结点，都有可能是问题的答案。图中的状态树是满二叉树，得到的叶子结点全部都是问题的解。  </p>
<p>在某些情况下，回溯算法解决问题的过程中创建的状态树并不都是满二叉树，因为在试探的过程中，有时会发现此种情况下，再往下进行没有意义，所以会放弃这条死路，回溯到上一步。在树中的体现，就是在树的最后一层不是满的，即不是满二叉树，需要自己判断哪些叶子结点代表的是正确的结果。</p>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>用回溯算法解决问题的一般步骤：</p>
<ol>
<li>针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。</li>
<li>确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。</li>
<li>以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</li>
</ol>
<h3 id="问题的解空间"><a href="#问题的解空间" class="headerlink" title="问题的解空间"></a>问题的解空间</h3><p>问题的解空间至少包含一个最优解。例如，对于装载问题，若有 n 个集装箱要装上一艘载重量为 c 的轮船，其中集装箱 i 的重量为 wi，要求在不超过轮船载重量的前提下，将尽可能多的集装箱装上轮船。</p>
<p>当 n=3 时，解空间是由长度为 3 的向量组成的，每个向量的元素取值为 0 或 1，解空间为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;(0,0,0),(0,0,1),(0,1,0),(1,0,0),(0,1,1),(1,0,1),(1,1,0),(1,1,1)&#125;</span><br></pre></td></tr></table></figure>

<p>其中，0 表示不装入轮船，1 表示装入轮船。若 c=50，W={18, 25, 25}，则解空间可用一棵二叉树表示，左分支用 1 表示，右分支用 0 表示，如下图所示。其中，解向量 (1,1,1) 表示将重量为 18、25、25 的集装箱都装入轮船，总重量为 68。解向量 (0,1,1) 表示将重量为 25 和 25 的集装箱装入轮船，总重量为 50。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807144158991.png" alt="image-20250807144158991"></p>
<p>解空间树一般分为两种：<strong>子集树和排列树</strong>。当所给的问题是从 n 个元素的集合 S 中找出满足某种性质的子集时，相应的解空间树称为子集树。当所给问题是确定 n 个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有 n! 个叶子结点。因此，遍历排列树需要 O(n!) 的计算时间。</p>
<h3 id="算法的基本思想"><a href="#算法的基本思想" class="headerlink" title="算法的基本思想"></a>算法的基本思想</h3><p>在构造好解空间树之后，可以利用回溯算法对解空间树进行搜索，通过搜索求出问题的最优解。从解空间树的根结点出发，对解空间进行深度优先搜索遍历：</p>
<ul>
<li>初始时，根结点成为活结点，并成为当前的扩展结点，沿着扩展结点向纵深方向搜索，达到一个新的结点后，新的结点就成为活结点，并成为当前的扩展结点。</li>
<li>若当前的扩展结点不能继续向前搜索，则当前的扩展结点成为死结点，这时就会回溯到最近的活结点位置。</li>
<li>重复按以上方式搜索整个解空间树，直到程序结束。</li>
</ul>
<p>若已经生成一个结点或多个结点，而它的所有孩子结点还没有全部生成，则该结点称为活结点；扩展结点指的是当前正在生成孩子结点的活结点；死结点指的是不再继续扩展的结点或其孩子结点已经全部生成的结点。</p>
<h2 id="贪心算法实际应用"><a href="#贪心算法实际应用" class="headerlink" title="贪心算法实际应用"></a>贪心算法实际应用</h2><h3 id="解决装载问题"><a href="#解决装载问题" class="headerlink" title="解决装载问题"></a>解决装载问题</h3><p>已知有 n 个集装箱（重量分别为 w1,w2,…,wn）和 1 艘轮船，轮船的载重量为 c，要求在不超过轮船载重量的前提下，将尽可能多的集装箱装入轮船。其中，第 i 个集装箱的重量为 wi。</p>
<p>当 c=50、W={18, 25, 25} 时，装载问题的搜索过程可以表示成一棵子集树，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807144722069.png" alt="image-20250807144722069"></p>
<ol>
<li><p>初始时，根结点是唯一的活结点，也是当前的扩展结点，此时轮船的剩余容量为 cr=50，还未有集装箱装入轮船。</p>
</li>
<li><p>从根结点 A 出发对左分支结点 B 进行扩展，若将第 1 个集装箱装入轮船，则有 cr=50-18=32，此时结点 B 为当前的扩展结点，结点 A 和结点 B 为活结点。</p>
</li>
<li><p>从当前的扩展结点 B 继续沿深度方向扩展，若将第 2 个集装箱装入轮船，则有 cr=32-25=7，此时结点 D 为当前的扩展结点，结点 A、结点 B 和结点 D 为活结点。</p>
</li>
<li><p>从当前的扩展结点 D 沿着左分支继续扩展，由于 cr&lt;25，因此无法将第 3 个集装箱放入轮船，这是一个不可行的解，回溯到结点 D。</p>
</li>
<li><p>结点 D 成为活结点，并成为当前的扩展结点，从结点 D 沿着右分支进行扩展，扩展到结点 I，即不将第 3 个集装箱装入轮船，此时有第 1 个和第 2 个集装箱装入轮船，得到一个可行解，解向量为 {1,1,0}，装入轮船的集装箱总重量为 43。</p>
</li>
<li><p>结点 I 不能再扩展，成为死结点，回溯到结点 D，结点 D 已无可扩展结点，成为死结点，回溯到结点 B。</p>
</li>
<li><p>结点 B 成为当前的扩展结点，沿着结点 B 向右分支结点扩展，到达结点 E，结点 E 成为活结点，并成为当前的扩展结点，第 2 个集装箱不装入轮船，此时轮船上只有第 1 个集装箱，cr=32。</p>
</li>
<li><p>沿着结点 E 往左分支扩展，结点 J 成为活结点，并成为当前的扩展结点，将第 3 个集装箱装入轮船，此时有 cr=32-25=7，第 1 个和第 3 个集装箱装入轮船，解向量为 {1,0,1}，装入轮船的总重量为 43。</p>
</li>
<li><p>结点 J 不可扩展，成为死结点，回溯到结点 E，结点 E 成为当前的扩展结点，沿着结点 E 向右分支扩展，到达结点 K，结点 K 为活结点，即第 3 个集装箱不装入轮船，此时 cr=32，只有第 1 个集装箱装入轮船，解向量为 {1,0,0}，装入轮船的总重量为 18。<br>按照以上方式继续在解空间树上搜索，搜索完毕后，即可得到装载问题的最优解，最优解为 {0,1,1}。</p>
</li>
</ol>
<h3 id="解决旅行商问题"><a href="#解决旅行商问题" class="headerlink" title="解决旅行商问题"></a>解决旅行商问题</h3><p>旅行商问题（Traveling Salesman Problem，TSP）又称为旅行推销员问题、货郎担问题，是数学领域的著名问题之一。</p>
<p>一个旅行商要从 n 个城市的某一城市出发去往其他城市，每个城市经过且只经过一次，最后回到原来出发的城市。求在去往任何一个城市的所有路径中路径长度最短的一条。</p>
<p>为了方便描述该问题，可采用带权图表示 n 个城市之间的关系，顶点表示城市，顶点之间的权值表示城市之间的距离。例如，n=4 时的旅行商问题可用下图表示。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807144956840.png" alt="image-20250807144956840"></p>
<p>图中的回路有 (1,2,3,4,1)、(1,2,4,3,1)、(1,3,2,4,1)、(1,4,2,3,1)、(1,3,4,2,1) 等，其中 (1,3,4,2,1) 的路径长度最短，其路径长度为 29。旅行商人所走过的可能路线其实是所有路径的排列组合，这些方案可绘制成一棵排列树，也是该问题的解空间树，如下图所示。该树的深度为 5，两个结点之间的路径表示旅行商经过的城市。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807145028236.png" alt="image-20250807145028236"></p>
<hr>
<h1 id="算法题一"><a href="#算法题一" class="headerlink" title="算法题一"></a>算法题一</h1><h2 id="N-皇后"><a href="#N-皇后" class="headerlink" title="N 皇后"></a>N 皇后</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">LeetCode_51. N 皇后</a></p>
<blockquote>
<p><strong>问题描述：</strong><br>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。<br>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p>
<p><strong>示例 1</strong><br><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807145358766.png" alt="image-20250807145358766"><br><strong>输入</strong>：n = 4<br><strong>输出</strong>：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br><strong>解释</strong>：如上图所示，4 皇后问题存在两个不同的解法。</p>
<p><strong>示例 2：</strong><br><strong>输入</strong>：n = 1<br><strong>输出</strong>：[[“Q”]]</p>
<p><strong>提示：</strong><code>1 &lt;= n &lt;= 9</code></p>
<p><strong>解释</strong>：n皇后和数独有异曲同工的方法。数独是每个横竖宫只有一个相同数字，皇后是横竖斜只有一个皇后。所以N*N矩阵皇后每行每列只有一个皇后。<br><strong>判断皇后位置正确</strong>：判断某位置是否可以放下皇后时，由于是从左往右从上往下的遍历顺序，因此只需要检索当前点的上方，左上方，右上方即可。此外，由于回溯内部的for循环是从左往右遍历的，所以可以肯定遍历到当前节点的时候，当前节点的左边肯定没有皇后， 因此可以不对左边节点进行检索</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 结果集</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储一个结果子集</span></span><br><span class="line">    <span class="type">char</span> arr[][] = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 初始化全为空</span></span><br><span class="line">            arr[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(<span class="keyword">new</span> <span class="title class_">String</span>(arr[i])); <span class="comment">// 初始化结果子集</span></span><br><span class="line">    &#125;</span><br><span class="line">    dfs(n, path, <span class="number">0</span>); <span class="comment">// 深度优先搜索 </span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先搜索 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, List&lt;String&gt; q, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">    <span class="comment">// 遍历到底部，退出循环</span></span><br><span class="line">    <span class="keyword">if</span> (start == n)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(q));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRight(q, n, start, i)) &#123; <span class="comment">// 判断 [start][i] 位置是否可以放皇后</span></span><br><span class="line">            <span class="type">char</span>[] rows = q.get(start).toCharArray(); <span class="comment">// 第 start+1行</span></span><br><span class="line">            rows[i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            q.set(start, <span class="keyword">new</span> <span class="title class_">String</span>(rows)); <span class="comment">// 放置皇后</span></span><br><span class="line">            </span><br><span class="line">            dfs(n, q, start + <span class="number">1</span>); <span class="comment">// 深度优先搜索 开始横坐标 start+1 </span></span><br><span class="line">            rows = q.get(start).toCharArray();</span><br><span class="line">            rows[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            q.set(start, <span class="keyword">new</span> <span class="title class_">String</span>(rows));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断该位置是否可以放下,检索横竖斜</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRight</span><span class="params">(List&lt;String&gt; q, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="comment">// 检测当前节点上方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.get(i).charAt(y) == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测左上方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x - <span class="number">1</span>, j = y - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.get(i).charAt(j) == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测右上方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x - <span class="number">1</span>, j = y + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.get(i).charAt(j) == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">LeetCode_17. 电话号码的字母组合</a></p>
<blockquote>
<p><strong>问题描述：</strong></p>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。给出数字到字母的映射与电话按键相同。注意 1 不对应任何字母。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= digits.length &lt;= 4</code></li>
<li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; re = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 结果集</span></span><br><span class="line">String corr[] = &#123;<span class="string">&quot;_&quot;</span>,<span class="string">&quot;!@#&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;; <span class="comment">// 0 - 9 对应的字符</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(digits.length() == <span class="number">0</span> || digits.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    re = findCombination(re, corr, digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归 获取字符串组合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findCombination</span><span class="params">(String digits, <span class="type">int</span> index, String s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == digits.length())&#123;</span><br><span class="line">        re.add(s); <span class="comment">// 添加字符串</span></span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> digits.charAt(index); <span class="comment">// 当前字符数字</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> corr[c- <span class="string">&#x27;0&#x27;</span>]; <span class="comment">// 当前数字对应的字母集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; letters.length(); i++)&#123; <span class="comment">// 2-9 每个数字都对应了多个字符</span></span><br><span class="line">        findCombination(digits, index + <span class="number">1</span>,  s + letters.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="算法题二（二叉树）"><a href="#算法题二（二叉树）" class="headerlink" title="算法题二（二叉树）"></a>算法题二（二叉树）</h1><h2 id="树节点定义"><a href="#树节点定义" class="headerlink" title="树节点定义"></a>树节点定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; </span><br><span class="line">        <span class="built_in">this</span>.val = val; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">char</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历  父 左 右</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);  <span class="comment">// 访问根节点</span></span><br><span class="line">    preOrder(root.left);               <span class="comment">// 递归左子树</span></span><br><span class="line">    preOrder(root.right);              <span class="comment">// 递归右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历 左 父 右</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历 左 右 父</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 创建一个队列，加入根节点</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 取出队首元素</span></span><br><span class="line">        System.out.print(cur.val + <span class="string">&quot;&quot;</span>);  <span class="comment">// 访问</span></span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left); <span class="comment">// 左节点入队</span></span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right); <span class="comment">// 右节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树还原"><a href="#二叉树还原" class="headerlink" title="二叉树还原"></a>二叉树还原</h2><p>公共代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> in.nextLine().trim();</span><br><span class="line">    String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] charsEnd = arr[<span class="number">0</span>].trim().toCharArray();</span><br><span class="line">    <span class="type">char</span>[] charsMid = arr[<span class="number">1</span>].trim().toCharArray();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> buildTree(charsMid, charsEnd); <span class="comment">// 构建树</span></span><br><span class="line">    List&lt;Character&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 层次遍历结果</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 根出队</span></span><br><span class="line">        res.add(node.val);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">        System.out.print(res.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="已知：后序-中序"><a href="#已知：后序-中序" class="headerlink" title="已知：后序 + 中序"></a>已知：后序 + 中序</h3><blockquote>
<p><strong>案例</strong>：<br>后序  ： C B E F D A<br>中序  ： C B A E D F</p>
<ol>
<li>后序 最后一个元素 A 为根节点</li>
<li>在中序中左子树在根节点左侧：拿着根节点 A 在中序中找</li>
<li>对照着后序：CB 为左子树的后序，EFD 为右子树的后序</li>
<li>还原 A 的左子树<pre><code>后序   CB      确定 B 为左子树的根节点，拿着 B 去中序中找，C 是 B 的左子树，B 的右子树为空
中序   CB
</code></pre>
</li>
<li>还原 A 的右子树<pre><code>后序   EFD    D 为右子树的根
中序   EDF    D 的左子树是 E 右子树为 F 
</code></pre>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">char</span>[] charsMid, <span class="type">char</span>[] charsEnd)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (charsMid.length == <span class="number">0</span> ||  charsEnd.length == <span class="number">0</span> || charsEnd.length != charsMid.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character, Integer&gt; mapMid = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charsMid.length; i++) &#123;</span><br><span class="line">        mapMid.put(charsMid[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildTreeHelpPostMid(charsMid, <span class="number">0</span>, charsMid.length - <span class="number">1</span>, charsEnd, <span class="number">0</span>, charsEnd.length - <span class="number">1</span>, mapMid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTreeHelperPostMid</span><span class="params">(<span class="type">char</span>[] charsMid, <span class="type">int</span> minS, <span class="type">int</span> midE,</span></span><br><span class="line"><span class="params">                                     <span class="type">char</span>[] charsEnd, <span class="type">int</span> endS, <span class="type">int</span> endE, Map&lt;Character, Integer&gt; midMap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(endS &gt; endE || minS &gt; midE) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">rootVal</span> <span class="operator">=</span> charsEnd[endE];</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">midRootIndex</span> <span class="operator">=</span> midMap.get(rootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numsLeft</span> <span class="operator">=</span>  midRootIndex - minS; <span class="comment">// 左子树长度</span></span><br><span class="line">    <span class="comment">// 还原左子树</span></span><br><span class="line">    root.left = buildTreeHelperPostMid(charsMid, minS, midE - <span class="number">1</span>,</span><br><span class="line">                              charsEnd, endS, endS + numsLeft - <span class="number">1</span>, midMap);</span><br><span class="line">    <span class="comment">// 还原右子树</span></span><br><span class="line">    root.right = buildTreeHelperPostMid(charsMid, midRootIndex + <span class="number">1</span>, midE,</span><br><span class="line">                               charsEnd, endS + numsLeft, endE - <span class="number">1</span>, midMap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="已知：先序-中序"><a href="#已知：先序-中序" class="headerlink" title="已知：先序 + 中序"></a>已知：先序 + 中序</h3><blockquote>
<p><strong>案例</strong>：<br>先序  ： E F H I G J K<br>中序  ： H F I E J K G</p>
<ol>
<li>先序 第一个元素 E 为根节点</li>
<li>在中序中左子树在根节点左侧：拿着根节点 E 在中序中找</li>
<li>对照着先序：FHI 为左子树的先序，GJK 为右子树的先序</li>
<li>还原 E 的左子树<pre><code>先序  FHI      确定 F 为左子树的根节点，拿着 F 去中序中找，H 是 F 的左子树，I 为 F 的右子树
中序  HFI
</code></pre>
</li>
<li>还原 E 的右子树<pre><code>先序   GJK    G 为右子树的根
中序   JKG    G 的左子树是 JK 右子树为空
</code></pre>
</li>
<li>还原G的左子树<pre><code>先序   JK       J 为 G 的左子树的根
中序   JK       J 为 G 的左子树的右子树
</code></pre>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">char</span>[] charsMid, <span class="type">char</span>[] charsPre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (charsMid.length == <span class="number">0</span> || charsPre.length == <span class="number">0</span> || charsPre.length != charsMid.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character, Integer&gt; mapMid = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charsMid.length; i++) &#123;</span><br><span class="line">        mapMid.put(charsMid[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildTreeHelpPreMid(charsMid, <span class="number">0</span>, charsMid.length - <span class="number">1</span>, charsPre, <span class="number">0</span>, charsPre.length - <span class="number">1</span>, mapMid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTreeHelpPreMid</span><span class="params">(<span class="type">char</span>[] charsMid, <span class="type">int</span> midS, <span class="type">int</span> midE,</span></span><br><span class="line"><span class="params">                                     <span class="type">char</span>[] charsPre, <span class="type">int</span> preS, <span class="type">int</span> preE, Map&lt;Character, Integer&gt; midMap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(preS &gt; preE || midS &gt; midE) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">rootVal</span> <span class="operator">=</span> charsPre[preS];</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">midRootIndex</span> <span class="operator">=</span> midMap.get(rootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numsLeft</span> <span class="operator">=</span>  midRootIndex - midS; <span class="comment">// 左子树长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原左子树</span></span><br><span class="line">    root.left = buildTreeHelpPreMid(charsMid, midS, midE - <span class="number">1</span>,</span><br><span class="line">            charsPre, preS + <span class="number">1</span>, preS + numsLeft, midMap);</span><br><span class="line">    <span class="comment">// 还原右子树</span></span><br><span class="line">    root.right = buildTreeHelpPreMid(charsMid, midRootIndex + <span class="number">1</span>, midE,</span><br><span class="line">            charsPre, preS + numsLeft + <span class="number">1</span>, preE, midMap);</span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">LeetCode_543. 二叉树的直径</a></p>
<blockquote>
<p><strong>问题描述：</strong><br>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[1, 10^4]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 全局变量 最长路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> (root.left == <span class="literal">null</span>) ? <span class="number">0</span>: dfs(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightSize</span> <span class="operator">=</span> (root.right == <span class="literal">null</span>) ? <span class="number">0</span>: dfs(root.right) + <span class="number">1</span>;</span><br><span class="line">    max = Math.max(max, leftSize + rightSize);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftSize, rightSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">LeetCode_124. 二叉树中的最大路径和</a></p>
<blockquote>
<p><strong>问题描述：</strong><br>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong>节点，且不一定经过根节点。 <strong>路径和</strong>是路径中各节点值的总和。给出二叉树的根节点 <code>root</code> ，返回其<strong>最大路径和</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 3 * 104]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE; <span class="comment">// 全局变量 最大路径和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先搜索</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Math.max(dfs(root.left), <span class="number">0</span>); <span class="comment">// 左子树最大路径和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Math.max(dfs(root.right), <span class="number">0</span>); <span class="comment">// 右子树最大路径和</span></span><br><span class="line">    res = Math.max(res, l + r + root.val); <span class="comment">// 左右子树最大路径和+根节点值</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(l, r) + root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相邻字符不同的最长路径"><a href="#相邻字符不同的最长路径" class="headerlink" title="相邻字符不同的最长路径"></a>相邻字符不同的最长路径</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/">LeetCode_2246. 相邻字符不同的最长路径</a></p>
<blockquote>
<p><strong>问题描述：</strong><br>给你一棵 <strong>树</strong>（即一个连通、无向、无环图），根节点是节点 <code>0</code> ，这棵树由编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点组成。用下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>parent</code> 来表示这棵树，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点，由于节点 <code>0</code> 是根节点，所以 <code>parent[0] == -1</code> 。<br>另给你一个字符串 <code>s</code> ，长度也是 <code>n</code> ，其中 <code>s[i]</code> 表示分配给节点 <code>i</code> 的字符。<br>请你找出路径上任意一对相邻节点都没有分配到相同字符的 <strong>最长路径</strong> ，并返回该路径的长度。<br><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：parent = [-1,0,0,1,1,2], s = &quot;abacbe&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：任意一对相邻节点字符都不同的最长路径是：0 -&gt; 1 -&gt; 3 。该路径的长度是 3 ，所以返回 3 。</span><br><span class="line">可以证明不存在满足上述条件且比 3 更长的路径。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：parent = [-1,0,0,0], s = &quot;aabc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：任意一对相邻节点字符都不同的最长路径是：2 -&gt; 0 -&gt; 3 。该路径的长度为 3 ，所以返回 3 。</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807160857199.png" alt="image-20250807160857199"></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == parent.length == s.length</code></li>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li>对所有 <code>i &gt;= 1</code> ，<code>0 &lt;= parent[i] &lt;= n - 1</code> 均成立</li>
<li><code>parent[0] == -1</code></li>
<li><code>parent</code> 表示一棵有效的树</li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPath</span><span class="params">(<span class="type">int</span>[] parent, String s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">        adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 构建类似多叉树：父节点包含多个子节点</span></span><br><span class="line">        adj.get(parent[i]).add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s, <span class="number">0</span>); <span class="comment">// 深度优先</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(String s, <span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj.get(root).isEmpty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> next : adj.get(root)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> dfs(s, next);</span><br><span class="line">        ans = Math.max(ans, now);</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(root) != s.charAt(next)) &#123;</span><br><span class="line">            q.offer(now);</span><br><span class="line">            <span class="comment">// 一个父节点在路径中最多保留两条子路径的和</span></span><br><span class="line">            <span class="keyword">if</span> (q.size() &gt; <span class="number">2</span>) q.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> q.isEmpty() ? <span class="number">0</span> : q.poll(), b = q.isEmpty() ? <span class="number">0</span> : q.poll();</span><br><span class="line">    ans = Math.max(ans, a + b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(a, b) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长同值路径"><a href="#最长同值路径" class="headerlink" title="最长同值路径"></a>最长同值路径</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-univalue-path/">LeetCode_687. 最长同值路径</a></p>
<blockquote>
<p><strong>问题描述：</strong><br>给定一个二叉树的 <code>root</code> ，返回 <em>最长的路径的长度</em> ，这个路径中的 <em>每个节点具有相同值</em> 。 这条路径可以经过也可以不经过根节点。<strong>两个节点之间的路径长度</strong> 由它们之间的边数表示。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,5,1,1,5]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,4,5,4,4,5]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>树的节点数的范围是 <code>[0, 10^4]</code> </li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li>树的深度将不超过 <code>1000</code> </li>
</ul>
<p><strong>思路：</strong>对于任意一个节点, 如果最长同值路径包含该节点, 那么只可能是两种情况：</p>
<pre><code>1. 其左右子树中加上该节点后所构成的同值路径中较长的那个继续向父节点回溯构成最长同值路径
2. 左右子树加上该节点都在最长同值路径中, 构成了最终的最长同值路径
</code></pre>
<p>需要注意因为要求同值, 所以在判断左右子树能构成的同值路径时要加入当前节点的值作为判断依据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    getMaxL(root, root.val);</span><br><span class="line">    <span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxL</span><span class="params">(TreeNode r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getMaxL(r.left, r.val);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getMaxL(r.right, r.val);</span><br><span class="line">    maxL = Math.max(maxL, left+right); <span class="comment">// 路径长度为节点数减1所以此处不加1</span></span><br><span class="line">    <span class="keyword">if</span>(r.val == val) &#123; <span class="comment">// 和父节点值相同才返回以当前节点所能构成的最长通知路径长度, 否则返回0</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="算法题三"><a href="#算法题三" class="headerlink" title="算法题三"></a>算法题三</h1><h2 id="流浪地球"><a href="#流浪地球" class="headerlink" title="流浪地球"></a>流浪地球</h2><blockquote>
<p><strong>问题描述：</strong><br>流浪地球计划在赤道上均匀部署了N个转向发动机，按位置顺序编号为0~N。</p>
<ol>
<li>初始状态下所有的发动机都是未启动状态;</li>
<li>发动机启动的方式分为”手动启动”和”关联启动”两种方式;</li>
<li>如果在时刻1一个发动机被启动，下一个时刻2与之相邻的两个发动机就会被”关联启动”;</li>
<li>如果准备启动某个发动机时，它已经被启动了，则什么都不用做</li>
</ol>
<p>发动机0与发动机N-1是相邻的。地球联合政府准备挑选某些发动机在某些时刻进行“手动启动”。当然最终所有的发动机都会被启动。<br>哪些发动机最晚被启动呢?</p>
<p><strong>输入描述：</strong>第一行两个数字N和E，中间有空格，N代表部署发动机的总个数，E代表计划手动启动的发动机总个数 1&lt;N&lt;=1000,1&lt;=E&lt;=1000,E&lt;=N。接下来共E行，每行都是两个数字T和P，中间有空格 T 代表发动机的手动启动时刻，P代表此发动机的位置编号。 0&lt;=T&lt;=N.0&lt;=P&lt;N<br><strong>输出描述：</strong>第一行一个数字N，以回车结束 N代表最后被启动的发动机个数；第二行N个数字，中间有空格，以回车结束 每个数字代表发动机的位置编号，从小到大排序</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">8 2</span><br><span class="line">0 2</span><br><span class="line">0 6</span><br><span class="line">输出</span><br><span class="line">2</span><br><span class="line">0 4</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8个发动机;</span><br><span class="line">时刻0启动(2,6);</span><br><span class="line">时刻1启动(1,3.5,7)(其中1,3被2关联启动，5，7被6关联启动);</span><br><span class="line">时刻2启动(0,4)(其中0被1,7关联启动，4被3,5关联启动);</span><br><span class="line">至此所有发动机都被启动，最后被启动的有2个，分别是0和4。</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：模拟。枚举每一秒时间，用一个队列维护当前启动了哪些发动机。之后每一秒先遍历队列中的所有发动机，尝试向左右两侧扩展一次，如果扩展到没有启动的发动机就更新其启动时间，同时把发动机放入队列。之后再遍历所有手动启动的发动机，如果某个发动机没启动并且会在这一秒启动，就把他放入队列同时更新启动时间这样就能更新出所有发动机的最早启动时间，找出最大值并输出所有最晚启动的即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">problem28</span><span class="params">(<span class="type">int</span> n, List&lt;<span class="type">int</span>[]&gt; a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 存每个发动机最早启动时间</span></span><br><span class="line">    Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">// 用一个队列维护当前启动了哪些发动机</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t &lt;= <span class="number">5000</span>; ++t)&#123; <span class="comment">// 枚举每一秒时间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size(); <span class="comment">// 当前队列大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; sz; ++j)&#123; <span class="comment">// 循环队列大小次</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> q.poll(); <span class="comment">// 出队</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (f - <span class="number">1</span> + n) % n; <span class="comment">// 左侧相邻发动机</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (f + <span class="number">1</span>) % n; <span class="comment">// 右侧相邻发动机</span></span><br><span class="line">            <span class="keyword">if</span>(ans[x] == -<span class="number">1</span>)&#123; <span class="comment">// 未启动则启动并放入队列</span></span><br><span class="line">                q.add(x);</span><br><span class="line">                ans[x] = ans[f] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans[y] == -<span class="number">1</span>)&#123; <span class="comment">// 未启动则启动并放入队列</span></span><br><span class="line">                q.add(y);</span><br><span class="line">                ans[y] = ans[f] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.size(); ++i)&#123; <span class="comment">// 遍历所有手动启动的发动机</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> a.get(i)[<span class="number">0</span>]; <span class="comment">// 时间</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">P</span> <span class="operator">=</span> a.get(i)[<span class="number">1</span>]; <span class="comment">// 编号</span></span><br><span class="line">            <span class="keyword">if</span>(T == t &amp;&amp; ans[P] == -<span class="number">1</span>)&#123; <span class="comment">// 如果某个发动机没启动并且会在这一秒启动，就把他放入队列同时更新启动时间</span></span><br><span class="line">                q.add(P);</span><br><span class="line">                ans[P] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        max = Math.max(max, ans[i]); <span class="comment">// 找最晚时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max == ans[i])&#123; <span class="comment">// 找符合最晚时间的个数</span></span><br><span class="line">            c += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(c); <span class="comment">// 输出个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == max) &#123;<span class="comment">// 输出具体序号</span></span><br><span class="line">            <span class="keyword">if</span> (f != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Boss的收入"><a href="#Boss的收入" class="headerlink" title="Boss的收入"></a>Boss的收入</h2><blockquote>
<p><strong>问题描述：</strong><br>一个XX产品行销总公司，只有一个boss，其有若干一级分销，一级分销又有若干二级分销，每个分销只有唯一的上级分销。规定每个月，下级分销需要将自己的总收入(自己的+下级上交的)每满100元上交15元给自己的上级。现给出一组分销的关系，和每个分销的收入，请找出 boss并计算出这 boss 的收入。<br>比如：收入100元上交15元,收入199元(9元不够100)上交15元，收入200元，上交30元。<br>分销关系和收入:分销id 上级分销的id 收入；分销ID范围0…65535 ；收入范围:0…65535,单位元<br><strong>提示</strong>：输入的数据只存在1个 boss，不存在环路<br><strong>输入描述：</strong>第1行输入关系的总数量N；第2行开始，输入关系信息，格式：分销ID 上级分销ID 收入<br><strong>输出描述：</strong>boss的ID 总收入<br><strong>补充说明：</strong>给定的输入数据都是合法的，不存在重复</p>
<p><strong>示例 1</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">5</span><br><span class="line">1 0 100</span><br><span class="line">2 0 200</span><br><span class="line">3 0 300</span><br><span class="line">4 0 200</span><br><span class="line">5 0 200</span><br><span class="line">输出 0 150</span><br></pre></td></tr></table></figure>

<p><strong>示例 2</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">3</span><br><span class="line">1 0 223</span><br><span class="line">2 0 323</span><br><span class="line">3 2 1203</span><br><span class="line">输出 0 105</span><br><span class="line">说明：2的最终收入等于323+1203/100*15=323+180；0的最终收入等于(323+180+223)/100*15=105</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：使用一个队列进行广度优先搜索（BFS）。从队列中取出当前分销IDx，获取其上级分销IDy，更新收入并更新上级分销的下级计数器in。如果某个上级分销没有下级分销了，将其加入队列。重复此过程直至队列为空。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关系的总数量N, 关系信息列表（分销ID 上级分销ID 收入）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">problem63</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] arr)</span> &#123;</span><br><span class="line">    <span class="type">long</span>[] fa = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">100010</span>];  <span class="comment">// 记录每个分销的上级分销ID</span></span><br><span class="line">    <span class="type">long</span>[] mon = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">100010</span>];  <span class="comment">// 记录每个分销的收入</span></span><br><span class="line">    Arrays.fill(fa, -<span class="number">1</span>);  <span class="comment">// 初始化fa数组，全部设置为-1，表示未知上级</span></span><br><span class="line">    List&lt;Integer&gt; in = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Collections.nCopies(<span class="number">100010</span>, <span class="number">0</span>));  <span class="comment">// 记录每个分销被定义为上级的次数</span></span><br><span class="line">    Set&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();  <span class="comment">// 用于存储所有出现的分销ID</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[i][<span class="number">0</span>], y = arr[i][<span class="number">1</span>], z = arr[i][<span class="number">2</span>];</span><br><span class="line">        st.add(x);  <span class="comment">// 将分销ID x 加入集合</span></span><br><span class="line">        st.add(y);  <span class="comment">// 将上级分销ID y 加入集合</span></span><br><span class="line">        in.set(y, in.get(y) + <span class="number">1</span>);  <span class="comment">// 记录上级分销ID y 被定义为上级的次数</span></span><br><span class="line">        fa[x] = y;  <span class="comment">// 设置分销 x 的上级分销ID 为 y</span></span><br><span class="line">        mon[x] = z;  <span class="comment">// 设置分销 x 的收入为 z</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个队列用于处理没有下级的分销</span></span><br><span class="line">    Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : st) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in.get(x) == <span class="number">0</span>) &#123;</span><br><span class="line">            que.offer(x);  <span class="comment">// 如果某分销ID没有下级分销，将其加入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 最终输出的 boss 收入</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 最终输出的 boss ID</span></span><br><span class="line">    <span class="comment">// 广度优先</span></span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        x = que.poll();  <span class="comment">// 获取队列中的第一个元素</span></span><br><span class="line">        ans = mon[x];  <span class="comment">// 收入设置为当前的收入（会随程序运行最后是 boss 的收入）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) fa[x];  <span class="comment">// 获取分销 x 的上级分销ID</span></span><br><span class="line">        <span class="keyword">if</span> (y == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 如果上级分销ID是-1，跳过此次循环（可能是根节点）</span></span><br><span class="line">        &#125;</span><br><span class="line">        in.set(y, in.get(y) - <span class="number">1</span>);  <span class="comment">// 上级分销 y 的下级数量减1</span></span><br><span class="line">        <span class="keyword">if</span> (in.get(y) == <span class="number">0</span>) &#123;</span><br><span class="line">            que.offer(y);  <span class="comment">// 如果上级分销 y 没有下级分销了，将其加入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算并累加上级分销 y 的收入：当前收入的15%上交给上级</span></span><br><span class="line">        mon[y] += mon[x] / <span class="number">100</span> * <span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出最终的 boss ID 和 boss 的总收入</span></span><br><span class="line">    System.out.println(x + <span class="string">&quot; &quot;</span> + ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://southernfish.github.io">Southern Fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://southernfish.github.io/pages/algorithm/backtrack-algorithm/">https://southernfish.github.io/pages/algorithm/backtrack-algorithm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://southernfish.github.io" target="_blank">Southern Fish</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/algorithm/">algorithm</a></div><div class="post_share"><div class="social-share" data-image="/img/article/article1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/pages/algorithm/simple_algorithm/"><img class="prev-cover" src="/img/article/article2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">其他简单算法</div></div></a></div><div class="next-post pull-right"><a href="/pages/algorithm/greedy-algorithm/"><img class="next-cover" src="/img/article/article5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">贪心算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/pages/algorithm/java-algorithm-hard/" title="LeetCode的较难题"><img class="cover" src="/img/article/article5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-22</div><div class="title">LeetCode的较难题</div></div></a></div><div><a href="/pages/algorithm/java-algorithm-easy/" title="LeetCode的简单题"><img class="cover" src="/img/article/article6.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-22</div><div class="title">LeetCode的简单题</div></div></a></div><div><a href="/pages/algorithm/java-algorithm-medium/" title="LeetCode的中等难度题"><img class="cover" src="/img/article/article1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-22</div><div class="title">LeetCode的中等难度题</div></div></a></div><div><a href="/pages/algorithm/dynamic-programming/" title="动态规划算法"><img class="cover" src="/img/article/article6.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-02</div><div class="title">动态规划算法</div></div></a></div><div><a href="/pages/algorithm/sliding-window/" title="滑动窗口算法"><img class="cover" src="/img/article/article1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-02</div><div class="title">滑动窗口算法</div></div></a></div><div><a href="/pages/algorithm/simple_algorithm/" title="其他简单算法"><img class="cover" src="/img/article/article2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-07</div><div class="title">其他简单算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southern Fish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">96</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SouthernFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1002721576@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">天下事岂能尽如吾意，心境须恰适，尽其在我，随遇而安。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">回溯算法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">1.2.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88DFS%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">深度优先遍历（DFS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88BFS%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">广度优先遍历（BFS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AFVS%E9%80%92%E5%BD%92"><span class="toc-number">1.5.</span> <span class="toc-text">回溯VS递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">回溯算法的实现过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-number">1.7.</span> <span class="toc-text">算法思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%A9%BA%E9%97%B4"><span class="toc-number">1.7.1.</span> <span class="toc-text">问题的解空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">1.7.2.</span> <span class="toc-text">算法的基本思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.</span> <span class="toc-text">贪心算法实际应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.1.</span> <span class="toc-text">解决装载问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.2.</span> <span class="toc-text">解决旅行商问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%A2%98%E4%B8%80"><span class="toc-number">2.</span> <span class="toc-text">算法题一</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#N-%E7%9A%87%E5%90%8E"><span class="toc-number">2.1.</span> <span class="toc-text">N 皇后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">2.2.</span> <span class="toc-text">电话号码的字母组合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%A2%98%E4%BA%8C%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">算法题二（二叉树）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">树节点定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.</span> <span class="toc-text">二叉树遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%98%E5%8E%9F"><span class="toc-number">3.3.</span> <span class="toc-text">二叉树还原</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%EF%BC%9A%E5%90%8E%E5%BA%8F-%E4%B8%AD%E5%BA%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">已知：后序 + 中序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%EF%BC%9A%E5%85%88%E5%BA%8F-%E4%B8%AD%E5%BA%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">已知：先序 + 中序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-number">3.4.</span> <span class="toc-text">二叉树的直径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">3.5.</span> <span class="toc-text">二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84"><span class="toc-number">3.6.</span> <span class="toc-text">相邻字符不同的最长路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84"><span class="toc-number">3.7.</span> <span class="toc-text">最长同值路径</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%A2%98%E4%B8%89"><span class="toc-number">4.</span> <span class="toc-text">算法题三</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83"><span class="toc-number">4.1.</span> <span class="toc-text">流浪地球</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boss%E7%9A%84%E6%94%B6%E5%85%A5"><span class="toc-number">4.2.</span> <span class="toc-text">Boss的收入</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/pages/high-availability/server-limit-stream/" title="服务限流"><img src="/img/article/article2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="服务限流"/></a><div class="content"><a class="title" href="/pages/high-availability/server-limit-stream/" title="服务限流">服务限流</a><time datetime="2025-09-18T09:02:36.000Z" title="发表于 2025-09-18 17:02:36">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/db-redis-persistence/" title="Redis的持久化机制"><img src="/img/article/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis的持久化机制"/></a><div class="content"><a class="title" href="/pages/database/db-redis-persistence/" title="Redis的持久化机制">Redis的持久化机制</a><time datetime="2025-09-18T01:15:36.000Z" title="发表于 2025-09-18 09:15:36">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/cache-read-write-strategies/" title="三大缓存读写策略"><img src="/img/article/article3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="三大缓存读写策略"/></a><div class="content"><a class="title" href="/pages/database/cache-read-write-strategies/" title="三大缓存读写策略">三大缓存读写策略</a><time datetime="2025-09-17T13:15:36.000Z" title="发表于 2025-09-17 21:15:36">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/db-redis-cache-read-write/" title="三大缓存读写策略"><img src="/img/article/article1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="三大缓存读写策略"/></a><div class="content"><a class="title" href="/pages/database/db-redis-cache-read-write/" title="三大缓存读写策略">三大缓存读写策略</a><time datetime="2025-09-17T13:15:36.000Z" title="发表于 2025-09-17 21:15:36">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/db-redis-consistency/" title="Redis缓存与数据库的一致性"><img src="/img/article/article1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis缓存与数据库的一致性"/></a><div class="content"><a class="title" href="/pages/database/db-redis-consistency/" title="Redis缓存与数据库的一致性">Redis缓存与数据库的一致性</a><time datetime="2025-09-17T13:15:36.000Z" title="发表于 2025-09-17 21:15:36">2025-09-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/article/article1.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Southern Fish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>