<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MySQL数据库-索引 | Southern Fish</title><meta name="keywords" content="MySQL"><meta name="author" content="Southern Fish"><meta name="copyright" content="Southern Fish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="‌数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。数据库软件有着整体性和共享性的特点。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL数据库-索引">
<meta property="og:url" content="https://southernfish.github.io/pages/database/db-mysql-3-index/index.html">
<meta property="og:site_name" content="Southern Fish">
<meta property="og:description" content="‌数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。数据库软件有着整体性和共享性的特点。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://southernfish.github.io/img/article/article3.png">
<meta property="article:published_time" content="2025-07-25T02:30:36.000Z">
<meta property="article:modified_time" content="2025-09-26T07:19:35.034Z">
<meta property="article:author" content="Southern Fish">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://southernfish.github.io/img/article/article3.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://southernfish.github.io/pages/database/db-mysql-3-index/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL数据库-索引',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-26 15:19:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Southern Fish" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">98</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/article/article3.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Southern Fish</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL数据库-索引</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-25T02:30:36.000Z" title="发表于 2025-07-25 10:30:36">2025-07-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-26T07:19:35.034Z" title="更新于 2025-09-26 15:19:35">2025-09-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Database/">Database</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL数据库-索引"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>索引是数据库中用来提高数据检索效率的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>。它类似于书籍的目录，可以帮助用户快速找到所需的数据，而不必扫描整个数据集。在数据库系统中，索引可以显著提高查询性能。</p>
<blockquote>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/article/details/130355955">MySQL高级篇——性能分析工具</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/article/details/130804019">MySQL高级篇——覆盖索引、前缀索引、索引下推、SQL优化、主键设计</a></p>
</blockquote>
<h1 id="索引的分类与使用"><a href="#索引的分类与使用" class="headerlink" title="索引的分类与使用"></a>索引的分类与使用</h1><p>索引是<strong>满足某种特定查找算法的数据结构</strong>，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 <strong><code>B+ 树</code><strong>实现的，</strong><code>B+ 树</code>的搜索效率，可到达二分法的性能</strong>，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p>
<ol>
<li>从<strong>功能逻辑</strong>上说，索引主要有 4 种，分别是<strong>普通索引、唯一索引、主键索引、全文索引</strong>。</li>
<li>按照<strong>物理实现方式</strong>，索引可以分为 2 种：<strong>聚簇索引和非聚簇索引</strong>。</li>
<li>按照作用<strong>字段个数</strong>进行划分，分成<strong>单列索引和联合索引</strong>。</li>
</ol>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>在创建普通索引时，<strong>不附加任何限制条件</strong>，只是用于提高查询效率。这类索引可以创建在<strong>任何数据类型</strong>中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>使用UNIQUE参数可以设置索引为唯一性索引，在创建唯一性索引时，限制该<strong>索引的值</strong>必须是<strong>唯一</strong>的，但<strong>允许有多个空值</strong>。在一张数据表里可以有多个唯一索引。</p>
<p><strong>唯一约束和唯一索引的区别：</strong></p>
<ul>
<li>唯一约束和唯一索引，都可以实现列数据的唯一，列值可以有null。</li>
<li><strong>唯一约束自动创建不独立的唯一索引：</strong>创建唯一约束，会自动创建一个同名的唯一索引，该索引<strong>不能单独删除</strong>，删除约束会自动删除索引。唯一约束是通过唯一索引来实现数据的唯一。</li>
<li>创建一个唯一索引，这个索引就是独立，可以单独删除。</li>
<li>如果一个列上想有约束和索引，且两者可以单独的删除。可以先建唯一索引，再建同名的唯一约束。</li>
<li><strong>外键必须是唯一约束：</strong>如果表的一个字段，要作为另外一个表的外键，这个字段必须有唯一约束（或是主键），如果只是有唯一索引，就会报错。</li>
</ul>
<h3 id="主键索引（唯一非空）"><a href="#主键索引（唯一非空）" class="headerlink" title="主键索引（唯一非空）"></a>主键索引（唯一非空）</h3><p>主键索引就是一种特殊的唯一性索引，在<strong>唯一</strong>索引的基础上增加了<strong>不为空</strong>的约束，也就是NOTNULL+UNIQUE，<strong>一张表最多只有一个主键索引</strong>。这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p>
<h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>在表中的<strong>单个字段</strong>上创建<strong>索引</strong>。单列索引<strong>只根据该字段</strong>进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p>
<h3 id="多列-组合、联合-索引"><a href="#多列-组合、联合-索引" class="headerlink" title="多列(组合、联合)索引"></a>多列(组合、联合)索引</h3><p>多列索引是在表的<strong>多个字段组合</strong>上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但只有查询条件中使用了这些字段中的第一个字段时才会被使用。使用组合索引时<strong>遵循最左前缀集合</strong>。</p>
<blockquote>
<p><strong>最左前缀集合：</strong>指的是由多个列组成的联合索引，在查询时只会使用最左边的几个列进行索引查询。具体来说，如果一个联合索引包含了列A、B和C三列，那么MySQL只能使用A、A+B或者A+B+C这三种方式进行查询。而不能仅仅使用B或者C列进行查询。</p>
</blockquote>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。它能够利用**[分词术]<strong>等多种算法智能</strong>分析<strong>出文本文字中</strong>关键词的频率和重要性<strong>，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常</strong>适合大型数据集**，对于小的数据集，它的用处比较小。</p>
<p>使用<strong>参数FULLTEXT</strong>可以设置索引为全文索引。在定义索引的列上支持值的全文查找，<strong>允许</strong>在这些索引列中插入<strong>重复值和空值</strong>。全文索引只能创建在CHAR、VARCHAR或TEXT类型及其系列类型的字段上，查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，表student的字段information是TEXT类型该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</p>
<p>全文索引典型的有两种类型：<strong>自然语言的全文索引和布尔全文索引</strong></p>
<p>自然语言搜索引擎将计算每一个文档对象和查询的<strong>相关度</strong>。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中<strong>出现次数越少</strong>的词语，匹配时的<strong>相关度就越高</strong>。相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</p>
<p>MySQL数据库从3.23.23版开始支持全文索引，但MySQL5.6.4以前只有Myisam支持，5.6.4版本以后innodb才支持，但是官方版本不支持中文分词，需要第三方分词插件。在<strong>5.7.6版本</strong>，MySQL内置了<strong>ngram全文解析器</strong>，用来<strong>支持亚洲语种的分词</strong>。试或使用全文索引时，要先看一下自己的MySQL版本、存储引擎和数据类型是否支持全文索引。</p>
<p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被solrElasticSearch等专门的搜索引擎所替代。</p>
<h3 id="空间索引（不常用）"><a href="#空间索引（不常用）" class="headerlink" title="空间索引（不常用）"></a>空间索引（不常用）</h3><p>使用<strong>参数SPATIAL</strong>可以设置索引为空间索引。空间索引只能建立在<strong>空间数据类型</strong>上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括GEOMETRY、POINT、LINESTRING和POLYGON等。</p>
<p>目前<strong>只有MyISAM存储引擎支持空间检索</strong>，而且<strong>索引的字段不能为空值</strong>。对于初学者来说，这类索引<strong>很少会用到</strong>。</p>
<p><strong>小结：不同的存储引擎支持的索引类型也不一样</strong></p>
<ul>
<li><strong>InnoDB</strong>：支持B-tree、Full-text等索引，不支持Hash索引</li>
<li><strong>MyISAM</strong>：支持B-tree、Full-text等索引，不支持Hash索引</li>
<li><strong>Memory</strong>：支持B-tree、Hash等索引，不支持Full-text索引</li>
<li><strong>NDB</strong>：支持Hash索引，不支持B-tree、Full-text等索引</li>
<li><strong>Archive</strong>：不支持B-tree、Hash、Full-text等索引</li>
</ul>
<h2 id="建表时创建索引"><a href="#建表时创建索引" class="headerlink" title="建表时创建索引"></a>建表时创建索引</h2><p>MySQL支持多种方法在单个或多个列上创建索引： 在<strong>创建表</strong>的定义语句 <strong>CREATE TABLE</strong> 中指定索引列，使用<strong>ALTER TABLE</strong>语句在<strong>存在的表上创建索引</strong>，或者使用<strong>CREATE INDEX</strong>语句在已<strong>存在的表上添加索引</strong>。</p>
<h3 id="约束字段会隐式自动创建索引"><a href="#约束字段会隐式自动创建索引" class="headerlink" title="约束字段会隐式自动创建索引"></a>约束字段会隐式自动创建索引</h3><p>使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义<strong>主键约束、外键约束或者唯一性约束</strong>而不论创建哪种约束，在定义<strong>约束的同时相当于</strong>在指定列上<strong>创建</strong>了一个<strong>索引</strong>。</p>
<p>例如下面部门员工表的主键、唯一字段都<strong>隐式的</strong>创建了索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">    dept_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,        # 主键会自动创建主键索引</span><br><span class="line">    dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">    emp_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    emp_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>,                # 唯一约束会自动创建唯一索引</span><br><span class="line">    dept_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> emp_dept_id_fk <span class="keyword">FOREIGN</span> KEY(dept_id) <span class="keyword">REFERENCES</span> dept(dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="显式、创建表的时候创建索引"><a href="#显式、创建表的时候创建索引" class="headerlink" title="显式、创建表的时候创建索引"></a>显式、创建表的时候创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 [字段名 字段类型]</span><br><span class="line">[<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY] [索引名] (字段名 [length]) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><strong>UNIQUE 、FULLTEXT 和SPATIAL 为可选参数</strong>，分别表示唯一索引、全文索引和空间索引；</li>
<li><strong>INDEX 与KEY 为同义词</strong>，两者的作用相同，用来指定创建索引；</li>
<li>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</li>
<li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li>
<li><strong>length</strong> 为可选参数，表示<strong>索引的长度</strong>，只有字符串类型的字段才能指定索引长度；</li>
<li><strong>ASC 或DESC</strong> 指定<strong>升序或者降序的索引值存储</strong>。</li>
</ul>
</blockquote>
<p><strong>常见索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#  <span class="number">1.</span>创建普通索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    ...</span><br><span class="line">    year_publication <span class="keyword">YEAR</span>,            # 被索引的字段</span><br><span class="line">    INDEX(year_publication)         # 普通索引，不附加任何限制条件；不指定索引名，那么默认字段名为索引名；</span><br><span class="line">);</span><br><span class="line"># <span class="number">2.</span>创建唯一索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                # 被索引的字段</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX uk_idx_id(id)        # 索引的值必须是唯一的，但允许有空值。</span><br><span class="line">);</span><br><span class="line"># <span class="number">3.</span>主键索引</span><br><span class="line"># <span class="number">3.1</span> 设定为主键后数据库会自动建立索引，innodb为聚簇索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED AUTO_INCREMENT ,    # 被索引字段</span><br><span class="line">    ...</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id)                            # 主键索引，唯一不为空</span><br><span class="line">);</span><br><span class="line"># <span class="number">3.2</span> 删除主键索引，修改主键索引：必须先删除掉(<span class="keyword">drop</span>)原索引，再新建(<span class="keyword">add</span>)索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> example</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY ;</span><br><span class="line"># <span class="number">4.</span>创建单列索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    INDEX single_idx_name(name(<span class="number">20</span>))</span><br><span class="line">);</span><br><span class="line"># <span class="number">5.</span>创建组合索引：在表中的id、name和age字段上建立组合索引 </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    INDEX multi_idx(id,name,age)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>全文索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">6.</span>创建全文索引</span><br><span class="line"># <span class="number">6.1</span> 在表中的info字段上建立全文索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    ...</span><br><span class="line">    info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;    # 在MySQL5<span class="number">.7</span>及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。</span><br><span class="line"># <span class="number">6.2</span> 给title和body字段添加全文索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    title <span class="type">VARCHAR</span> (<span class="number">200</span>),</span><br><span class="line">    body TEXT,</span><br><span class="line">    FULLTEXT index (title, body)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB ;</span><br><span class="line"># 全文索引用<span class="keyword">match</span><span class="operator">+</span>against方式查询</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title,body) AGAINST (‘查询字符串’);</span><br><span class="line"># <span class="keyword">like</span>方式的的查询</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> body <span class="keyword">LIKE</span> ‘<span class="operator">%</span>查询字符串<span class="operator">%</span>’;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<ol>
<li>使用全文索引前，搞清楚版本支持情况；</li>
<li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li>
<li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</li>
</ol>
</blockquote>
<h3 id="在已存在的表上创建索引"><a href="#在已存在的表上创建索引" class="headerlink" title="在已存在的表上创建索引"></a>在已存在的表上创建索引</h3><p>在已经存在的表中创建索引可以使用<strong>ALTER TABLE</strong>语句或者<strong>CREATE INDEX</strong>语句。</p>
<p><strong>方法一：</strong> 使用<strong>ALTER TABLE</strong>语句创建索引 ALTER TABLE语句创建索引的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY]</span><br><span class="line">[index_name] (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<p><strong>方法二（推荐）：</strong>使用<strong>CREATE INDEX</strong>创建索引 CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中，CREATE INDEX<strong>被映射到一个ALTER TABLE语句上</strong>，基本语法结构为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong>在学生表上，给年纪、班级字段创建联合索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid <span class="keyword">ON</span> student(age,classId);</span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>使用<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>删除索引 <span class="keyword">ALTER</span> <span class="keyword">TABLE</span>删除索引的基本语法格式如下：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br><span class="line"># <span class="number">2.</span> 使用<span class="keyword">DROP</span> INDEX语句删除索引 <span class="keyword">DROP</span> INDEX删除索引的基本语法格式如下：</span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>删除表中的列时，若待删除列为索引的组成部分，则该列也会从索引中删除。当组成索引的所有列都被删除，则整个索引将被删除。</p>
</blockquote>
<h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建联合索引并查看</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age,classId,name);</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h1><h2 id="适合创建索引的情况"><a href="#适合创建索引的情况" class="headerlink" title="适合创建索引的情况"></a>适合创建索引的情况</h2><ol>
<li><p><strong>唯一特性的字段，适合创建索引</strong></p>
<p>业务上具有唯一特性（例如唯一约束、主键约束）的字段，<strong>即使是组合字段</strong>，也必须建成唯一索引。</p>
</li>
<li><p><strong>频繁作为where条件的字段，适合创建索引</strong></p>
<p>某字段在SELECT语句的 <strong>WHERE 条件</strong>中经常被使用到，那么就需要给这个字段创建索引了。尤其是在<strong>数据量大</strong>的情况下，创建普通索引就可以<strong>大幅提升</strong>数据查询的<strong>效率</strong>。</p>
</li>
<li><p><strong>经常分组或排序查询的字段，适合创建索引</strong></p>
<p>本身索引就已经排好序了，而且B+树叶节点一起组成双向链表，很适合范围查询。很适合建立索引。</p>
<p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 <strong>GROUP BY</strong> 对数据进行分组查询，或者使用 <strong>ORDER BY</strong> 对数据进行排序的时候，就需要对分组或者排序的字段进行索引。如果待<strong>排序的列有多个</strong>，可以在这些列上建立<strong>联合索引</strong>。</p>
</li>
<li><p><strong>增改语句的查询条件字段，适合创建索引</strong></p>
<p>UPDATE、DELETE 的 WHERE 条件列。对数据按照某个条件进行<strong>查询后</strong>再进行 <strong>UPDATE 或 DELETE</strong> 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。</p>
<p><strong>原理</strong>：因为需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</p>
</li>
<li><p><strong>DISTINCT字段，适合创建索引</strong></p>
<p>有时候我们需要对某个字段进行<strong>去重</strong>，使用 <strong>DISTINCT</strong>，那么对这个字段创建索引，也会提升查询效率。因为索引会对数据按照某种顺序进行排序，<strong>排序后再去重</strong>会快很多。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>多表连接时，连接表数量别超过3张，where字段和连接字段，适合创建索引</strong></p>
<ul>
<li><p><strong>连接表的数量</strong>尽量别超过 3 张，因为每增一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询效率。</p>
</li>
<li><p>对 <strong>WHERE 条件创建索引</strong>，因为 WHERE 才是对数据条件的过滤。数据量非常大时，没有 WHERE 条件过滤是非常可怕的。</p>
</li>
<li><p>对用于<strong>连接的字段创建索引</strong>，并且该字段在多张表中的类型必须一致。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p>
</li>
</ul>
</li>
<li><p><strong>数据范围越小的字段，越适合创建索引</strong></p>
<p>这里说的类型大小指的就是该类型表示的<strong>数据范围的大小</strong>。</p>
<p>在定义表结构的时候要显式的指定列的类型，以整数类型为例，有<code>TINYINT、MEDIUMINT、INT、BIGINT</code>等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，<strong>尽量让索引列使用较小的类型</strong>，比如<strong>能使用INT就不要使用BIGINT</strong>，能使用MEDIUMINT就不要使用INT。因为:</p>
<p><strong><code>数据类型越小，在查询时进行的比较操作越快</code><strong>。数据类型越小，索引占用的</strong>存储空间就越少</strong>，在一个数据页内就可以放下更多的记录，从而<strong>减少磁盘I/0</strong>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</p>
<p>该建议对于表的<strong>主键</strong>来说<strong>更加适用</strong>，因为不仅是聚簇索引中会存储主键值，其他所有的<strong>二级索引</strong>的节点处都会<strong>存储一份记录的主键值</strong>，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/0。</p>
</li>
<li><p><strong>很长的varchar字段，适合创建前缀索引</strong></p>
<p>假设<strong>字符串很长</strong>，那存储一个<strong>字符串</strong>就需要<strong>占用</strong>很大的<strong>存储空间</strong>。在需要为这个字符串列建立索引时意味着在对应的B+树中有这么两个问题:</p>
<p>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大；</p>
<p>如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。我们可以通过<strong>截取字符串区分度高的前缀子串建立索引</strong>，这个就叫<strong>前缀索引</strong>。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既节约空间，又减少了符串的比较时间，还大体能解决排序的问题。</p>
<p><strong>计算区分度度：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(列名, 索引长度))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>);  # <span class="keyword">left</span>()函数用于取字符串前缀</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>案例</strong>：创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shop(address <span class="type">varchar</span>(<span class="number">120</span>) <span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> shop <span class="keyword">add</span> index(address(<span class="number">12</span>));</span><br></pre></td></tr></table></figure>

<p><strong>问题是截取多少</strong>：截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。</p>
<p><strong>计算不同的长度的区分性，通过区分度判断</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 完整字段在全部数据中的选择度</span><br><span class="line">select count(distinct address) / count(*) from shop;</span><br><span class="line"># 通过不同长度去计算，与全表的选择性对比</span><br><span class="line">count(distinct left(列名, 索引长度))/count(*)</span><br></pre></td></tr></table></figure>

<p><strong>索引列前缀对排序的影响</strong>：Alibaba《Java开发手册》</p>
<p>【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，<strong>根据实际文本区分度决定索引长度</strong>。</p>
<p><strong>说明</strong>：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90% 以上，可以使用 <code>count(distinct left(列名, 索引长度))/count(*)</code>的区分度来确定。</p>
</blockquote>
</li>
<li><p><strong>区分度高的字段，适合作为索引</strong></p>
</li>
<li><p><strong>联合索引，将频繁查询的列放到左侧</strong></p>
</li>
</ol>
<p>   这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。</p>
<ol start="11">
<li><p><strong>多个字段都要创建索引时，联合索引优于单值索引</strong></p>
</li>
<li><p><strong>单张表索引数建议别超过6个</strong></p>
<ul>
<li>每个索引都需要<strong>占用磁盘空间</strong>，索引越多，需要的磁盘空间就越大</li>
<li>索引会<strong>影响INSERT、DELETE、UPDATE等语句的性能</strong>，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li>
<li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会<strong>增加MySQL优化器生成执行计划时间</strong>，降低查询性能。</li>
</ul>
</li>
</ol>
<h2 id="不适合创建索引的情况"><a href="#不适合创建索引的情况" class="headerlink" title="不适合创建索引的情况"></a>不适合创建索引的情况</h2><ol>
<li><p> <strong>在where中使用不到的字段，不要设置索引</strong></p>
</li>
<li><p><strong>数据量小的表，不要设置索引</strong></p>
<p>在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。</p>
</li>
<li><p> <strong>有大量重复数据的列上，不要设置索引</strong></p>
</li>
</ol>
<p>   当数据重复度大，比如<strong>高于 10%</strong> 的时候，也不需要对这个字段使用索引。 </p>
<p>   例如100万数据量的学生表，只有10个男生，其他都是女生，性别字段就别设置索引。 </p>
<ol start="4">
<li><p><strong>经常更新的表，不要创建过多索引</strong></p>
<ul>
<li><p><strong>频繁更新的字段</strong>不一定要创建索引。因为<strong>更新数据</strong>的时候，也<strong>需要更新索引</strong>，如果索引太多，在更新索引的时候也会造成<strong>负担</strong>，从而影响效率。</p>
</li>
<li><p>避免对<strong>经常更新的表</strong>创建过多索引，并且索引中的列尽可能少。此时虽然提高了查询速度，同时却会<strong>降低更新表的速度</strong>。 </p>
</li>
</ul>
</li>
<li><p><strong>不建议用无序的值作为索引</strong></p>
<p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p>
</li>
<li><p><strong>删除很少使用的索引</strong></p>
<p>表中的数据被大量更新，或者数据的使用方式被改变后，原有的<strong>一些索引</strong>可能<strong>不再需要</strong>。数据库管理员应当定期找出这些索引，将它们<strong>删除</strong>，从而<strong>减少索引对更新操作的影响</strong>。</p>
</li>
<li><p><strong><code>不要定义</code>冗余或重复的索引</strong></p>
<p><strong>冗余索引示例</strong>：个人信息表，<strong>联合索引最左边字段不需再创建索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    birthday <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phone_number <span class="type">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    country <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(<span class="number">10</span>), birthday, phone_number),</span><br><span class="line">    KEY idx_name (name(<span class="number">10</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>通过idx_name_birthday_phone_number <strong>联合索引</strong>就可以对<strong>name 列进行快速搜索</strong>，再创建一个<strong>专门针对name 列的索引就算是一个冗余索引</strong>，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p>
<p><strong>重复索引示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> repeat_index_demo (</span><br><span class="line">    col1 <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    col2 <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> uk_idx_c1 (col1),</span><br><span class="line">    INDEX idx_c1 (col1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是<strong>主键本身就会生成聚簇索引</strong>，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p>
</li>
</ol>
<h2 id="创建索引的一些建议"><a href="#创建索引的一些建议" class="headerlink" title="创建索引的一些建议"></a>创建索引的一些建议</h2><p><strong>一般性建议</strong></p>
<ul>
<li>对于单列索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择能够当前query中where子句中更多的索引。</li>
<li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</li>
</ul>
<p><strong>总之，书写SQL语句时，尽量避免造成索引失效的情况</strong></p>
<hr>
<h1 id="MySQL8-0索引新特性"><a href="#MySQL8-0索引新特性" class="headerlink" title="MySQL8.0索引新特性"></a>MySQL8.0索引新特性</h1><h2 id="支持降序索引"><a href="#支持降序索引" class="headerlink" title="支持降序索引"></a>支持降序索引</h2><p>创建降序的外键索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts1(a <span class="type">int</span>,b <span class="type">int</span>,index idx_a_b(a,b <span class="keyword">desc</span>));</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> ts1\G</span><br><span class="line"># 在MySQL <span class="number">8.0</span>版本中查看数据表ts1的结构，可以发现是降序</span><br><span class="line"># 在MySQL <span class="number">5.7</span>版本中查看数据表ts1的结构，索引仍然是默认的升序，</span><br></pre></td></tr></table></figure>

<h2 id="隐藏索引"><a href="#隐藏索引" class="headerlink" title="隐藏索引"></a>隐藏索引</h2><p>在<strong>MySQL 5.7版本及之前</strong>，只能通过<strong>显式</strong>的方式<strong>删除索引</strong>。此时，如果发现<strong>删除索引后出现错误</strong>，又<strong>只能</strong>通过<strong>显式创建索引</strong>的方式<strong>将删除的索引创建回来</strong>。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p>
<p>将待删除的索引设置为隐藏索引，mysql确认删除索引后不会出错后再彻底删除索引。</p>
<p>从MySQL 8.x开始支持<strong>隐藏索引</strong>（invisible indexes） ，只需要将<strong>待删除的索引设置为隐藏索引</strong>，使<strong>查询优化器不再使用这个索引</strong>（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何影响，就可以<strong>彻底删除索引</strong>。这种通过<strong>先将索引设置为隐藏索引，再删除索引</strong>的方式就是软删除。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name INVISIBLE;     # 切换成隐藏索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name VISIBLE;         # 切换成非隐藏索引</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><h2 id="什么是覆盖索引"><a href="#什么是覆盖索引" class="headerlink" title="什么是覆盖索引"></a>什么是覆盖索引</h2><p><strong>覆盖索引：</strong>一个索引包含了满足查询结果的数据就叫做覆盖索引，不需要回表等操作。</p>
<p>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。</p>
<p>覆盖索引是<strong>非聚簇索引</strong>的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列 （即建索引的字段正好是覆盖查询条件中所涉及的字段）。简单说就是， <strong>索引列+主键</strong> 包含 <strong>SELECT 到 FROM之间查询的列</strong> 。</p>
<h2 id="覆盖索引情况下，“不等于”索引生效"><a href="#覆盖索引情况下，“不等于”索引生效" class="headerlink" title="覆盖索引情况下，“不等于”索引生效"></a>覆盖索引情况下，“不等于”索引生效</h2><p><strong>没覆盖索引情况下，“不等于”索引失效：</strong></p>
<p>没覆盖索引的情况下，使用“不等于”导致索引失效。因为如果使用索引，则需要依次遍历非聚簇索引B+树里所有叶节点，时间复杂度O(n)，找到记录后还要回表，加在一起效率不如全表扫描，所以查询优化器就选择全表扫描了。</p>
<p><strong>覆盖索引情况下，“不等于”索引生效：</strong></p>
<p>覆盖索引，查的两个字段被联合索引给覆盖了，性能更高。虽然还是需要依次遍历非聚簇索引B+树里所有叶节点，时间复杂度O(n)，但是不需要回表了，整体效率比不用索引更高，查询优化器就又使用索引了。</p>
<h2 id="覆盖索引情况下，左模糊查询索引生效"><a href="#覆盖索引情况下，左模糊查询索引生效" class="headerlink" title="覆盖索引情况下，左模糊查询索引生效"></a>覆盖索引情况下，左模糊查询索引生效</h2><p><strong>没覆盖索引的情况下，左模糊查询导致索引失效</strong></p>
<p>原因同 <code>没覆盖索引情况下，“不等于”索引失效</code></p>
<p><strong>覆盖索引情况下，左模糊查询索引生效</strong></p>
<p>主要原因也是因为走非聚簇索引B+树遍历叶节点，不回表，效率会比全表扫描时高，查询优化器选择效率高的方案。</p>
<h2 id="覆盖索引的利弊"><a href="#覆盖索引的利弊" class="headerlink" title="覆盖索引的利弊"></a>覆盖索引的利弊</h2><p><strong>好处：</strong></p>
<ol>
<li><p><strong>避免回表（Innodb表进行索引的二次查询）</strong></p>
<p>Innodb是以聚簇索引的顺序来存储的，对lnnodb来说，二级索引在叶子节点中所保存的是行的主键信息，若是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取我们真实所需要的数据。</p>
<p>在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。</p>
</li>
<li><p><strong>可以把随机IO变成顺序IO加快查询效率</strong></p>
<p>由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据I0要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO 转变成索引查找的 顺序IO。</p>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
</li>
</ol>
<p><strong>弊端：</strong>索引字段的维护总是有代价的。在建立冗余索引来支持覆盖索引时需要权衡考虑。这是业务DBA，即业务数据架构师的工作。</p>
<hr>
<h1 id="给字符串添加索引"><a href="#给字符串添加索引" class="headerlink" title="给字符串添加索引"></a>给字符串添加索引</h1><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>MySQL是支持前缀索引的。默认地，如果你<strong>创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建一张教师表，表定义如下：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> teacher(</span><br><span class="line">ID <span class="type">bigint</span> unsigned <span class="keyword">primary</span> key,</span><br><span class="line">email <span class="type">varchar</span>(<span class="number">64</span>),</span><br><span class="line">...</span><br><span class="line">)engine<span class="operator">=</span>innodb;</span><br><span class="line"># 给email这个字段添加索引</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> index index1(email);</span><br><span class="line"># 或</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p><strong>使用index1</strong>（索引包含整个字符串），执行顺序如下：</p>
<ol>
<li>从index1索引树找到满足索引值是’ <a href="mailto:&#122;&#x68;&#97;&#110;&#x67;&#115;&#115;&#120;&#x79;&#122;&#x40;&#x78;&#120;&#120;&#x2e;&#x63;&#x6f;&#109;">&#122;&#x68;&#97;&#110;&#x67;&#115;&#115;&#120;&#x79;&#122;&#x40;&#x78;&#120;&#120;&#x2e;&#x63;&#x6f;&#109;</a>’的这条记录，取得ID2的值；</li>
<li><strong>回表</strong>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</li>
<li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=’ <a href="mailto:&#122;&#104;&#97;&#x6e;&#x67;&#x73;&#x73;&#x78;&#x79;&#x7a;&#64;&#x78;&#x78;&#120;&#46;&#99;&#x6f;&#109;">&#122;&#104;&#97;&#x6e;&#x67;&#x73;&#x73;&#x78;&#x79;&#x7a;&#64;&#x78;&#x78;&#120;&#46;&#99;&#x6f;&#109;</a> ’的 条件了，循环结束。</li>
</ol>
<p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p>
<p><strong>使用index2</strong>（索引包含字符串前缀email(6)），执行顺序如下：</p>
<ol>
<li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</li>
<li><strong>回表</strong>到主键上查到主键值是ID1的行，判断出email的值不是’ <a href="mailto:&#122;&#x68;&#x61;&#x6e;&#x67;&#115;&#115;&#120;&#x79;&#122;&#64;&#120;&#120;&#120;&#46;&#99;&#x6f;&#x6d;">&#122;&#x68;&#x61;&#x6e;&#x67;&#115;&#115;&#120;&#x79;&#122;&#64;&#120;&#120;&#120;&#46;&#99;&#x6f;&#x6d;</a> ’，这行记录丢弃；</li>
<li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到<strong>回表到</strong>ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li>
<li>重复上一步，<strong>直到在index2上取到的值不是’zhangs’时</strong>，循环结束。</li>
</ol>
<p>使用前缀索引，定义好长度，<strong>就可以做到既节省空间，又不用额外增加太多的查询成本。</strong>注意：区分度越高，意味着重复的键值越少。</p>
<h2 id="前缀索引不能用覆盖索引"><a href="#前缀索引不能用覆盖索引" class="headerlink" title="前缀索引不能用覆盖索引"></a>前缀索引不能用覆盖索引</h2><p>因为非聚簇索引树查到的数据是前缀和id，前缀不是完整数据，必须要回表到聚簇索引树。</p>
<p>所以使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p>
<hr>
<h1 id="索引下推（ICP）"><a href="#索引下推（ICP）" class="headerlink" title="索引下推（ICP）"></a>索引下推（ICP）</h1><p><strong>索引下推</strong>(ICP，<code>Index Condition Pushdown</code>)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。</p>
<ul>
<li><p><strong>如果没有ICP</strong>：联合索引某字段是模糊查询（非左模糊）时，该字段进行条件判断后，后面几个字段不能用来直接条件判断，必须回表后再判断。</p>
</li>
<li><p><strong>启用ICP 后</strong>：联合索引某字段是模糊查询（非左模糊）时，该字段进行条件判断后，后面几个字段可以直接条件判断，判断过滤后再回表对不包含在联合索引内的字段条件进行判断。主要优化点是在回表之前过滤，减少回表次数。</p>
<p><strong>主要应用</strong>：模糊查询（非左模糊）导致索引里该字段后面的字段无序，必须要回表判断，而使用了索引下推，就不需要回表，直接在联合索引树里判断。</p>
</li>
</ul>
<p><strong>举例：</strong></p>
<p><strong>不支持索引下推的联合索引：</strong>例如索引(name,age)，查询name like ‘z%’ and age=？，模糊查询导致age无序。在联合索引树查询时只会查name，后面的age乱序不能直接进行条件判断，必须回表后再判断age。</p>
<p><strong>而支持索引下推的联合索引：</strong>例如索引(name,age)，查询name like ‘z%’ and age and address，在联合索引树查询时不止查name，还会判断后面的age，过滤后再回表判断address。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_age <span class="keyword">ON</span> student(name,age);</span><br><span class="line">#索引失败；非覆盖索引时，左模糊导致索引失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="keyword">like</span> <span class="string">&#x27;%bc%&#x27;</span> <span class="keyword">AND</span> age<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">#索引成功；MySQL5<span class="number">.6</span>引入索引下推，<span class="keyword">where</span>后面的name和age都在联合索引里，可以又过滤又索引，不用回表，索引生效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> `name` <span class="keyword">like</span> <span class="string">&#x27;bc%&#x27;</span> <span class="keyword">AND</span> age<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">#索引成功；name走索引，age用到索引下推过滤，classid不在联合索引里，需要回表。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> `name` <span class="keyword">like</span> <span class="string">&#x27;bc%&#x27;</span> <span class="keyword">AND</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classid<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>好处:</strong> 某些场景下ICP可以大大<strong>减少回表次数</strong>，提高性能。ICP可以减少存储引擎必须访问基表的次数和MySQL服务器必须访问存储引擎的次数。但是，ICP的 加速效果 取决于<strong>在存储引擎内通过 ICP筛选</strong> 的数据的比例。</p>
<h2 id="ICP的使用条件"><a href="#ICP的使用条件" class="headerlink" title="ICP的使用条件"></a>ICP的使用条件</h2><ul>
<li>表的访问类型为 range 、 ref 、 eq_ref 或者 ref_or_null 。</li>
<li><strong>存储引擎：</strong>ICP可以用于InnDB和MyISAM存储引擎</li>
<li><strong>必须二级索引：</strong>对于InnoDB表，ICP仅用于二级索引。ICP的目标是减少全行读取次数，从而减少I/O操作。</li>
<li><strong>必须不是覆盖索引：</strong>当SQL使用覆盖索引时，不支持ICP优化方法。因为这种情况下使用ICP不会减少I/O。</li>
<li>相关子查询的条件不能使用ICP</li>
<li><strong>必须5.6版本及以上：</strong>MySQL 5.6版本引入并默认开启，之前版本不支持索引下推。</li>
<li><strong>必须where字段在索引列中：</strong>并非全部where条件都可以用ICP筛选，如果where条件的字段不在索引列中，还是要读取整表的记录到server端做where过滤。</li>
</ul>
<h2 id="ICP的开启-关闭"><a href="#ICP的开启-关闭" class="headerlink" title="ICP的开启/关闭"></a>ICP的开启/关闭</h2><ul>
<li><p>默认情况下启动索引条件下推。可以通过设置系统变量<strong>optimizer_switch</strong>控制：<strong>index_condition_pushdown</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 打开索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=on&#x27;</span>;</span><br><span class="line"># 关闭索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>当使用索引条件下推是，<strong>EXPLAIN</strong>语句输出结果中<strong>Extra</strong>列内容显示为<strong>Using index condition</strong>。</p>
</li>
</ul>
<h2 id="开启和关闭ICP性能对比"><a href="#开启和关闭ICP性能对比" class="headerlink" title="开启和关闭ICP性能对比"></a>开启和关闭ICP性能对比</h2><p>使用 ICP 优化的查询效率会好一些。数据量大的情况下效果更明显。</p>
<hr>
<h1 id="普通索引-vs-唯一索引"><a href="#普通索引-vs-唯一索引" class="headerlink" title="普通索引 vs 唯一索引"></a>普通索引 vs 唯一索引</h1><p>有一个主键列为ID的表，表中有字段k，并且在k上有索引，假设字段 k 上的值都不重复。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    k <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    index (k)</span><br><span class="line">)engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<h2 id="查询性能近似"><a href="#查询性能近似" class="headerlink" title="查询性能近似"></a>查询性能近似</h2><p>假设，执行查询的语句是 select id from test where k=5。</p>
<ul>
<li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</li>
<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。所以唯一索引查询性能略高，特别是重复记录很多的时候。</li>
</ul>
<p>整体来说，二者性能差距很小，因为 InnoDB 是以页为单位读写的，所以可能对于普通索引的扫描过程来说就是在内存中进行，除非是需要跨页查询了，那还要继续读取下一页数据。</p>
<h2 id="普通索引更新性能更高"><a href="#普通索引更新性能更高" class="headerlink" title="普通索引更新性能更高"></a>普通索引更新性能更高</h2><ul>
<li><p>普通索引更新性能更高，特别是目标页不在内存中场景。</p>
</li>
<li><p>因为普通索引有change buffer（写缓存）将更新后的数据页缓存到内存，下次访问时或后台定期会执行merge操作，将该数据页写入磁盘。（change buffer在事务提交时会写入redo log，保证数据持久化）而唯一索引不支持写缓存，而且插入前要判断唯一性，这部分会影响性能。</p>
</li>
</ul>
<p><strong>写缓存（change buffer）：</strong></p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话， 在不影响数据一致性的前提下， <strong>InooDB会将这些更新操作缓存在change buffer中</strong> ，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p><strong>merge ：</strong>将change buffer中的操作应用到原数据页，得到最新结果的过程称为 merge 。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge 操作。</p>
<p>如果能够将更新操作先记录在change buffer， <strong>减少读磁盘</strong> ，语句的执行速度会得到明显的提升。而且， 数据读入内存是需要占用 buffer pool 的，所以这种方式还能够 <strong>避免占用内存</strong>，提高内存利用率。</p>
<p><strong>唯一索引的更新就不能使用change buffer</strong> ，实际上也只有普通索引可以使用。</p>
<blockquote>
<p><strong>做好区分：</strong></p>
<ul>
<li>读数据用的是<strong>缓冲池buffer pool</strong>；</li>
<li>重做日志有个<strong>redo log buffer</strong>，是将缓冲池里更新的数据写入redo log buffer，事务提交时根据刷盘策略，将redo log buffer刷盘到redo log file或page cache。</li>
</ul>
</blockquote>
<h2 id="change-buffer-使用场景"><a href="#change-buffer-使用场景" class="headerlink" title="change buffer 使用场景"></a>change buffer 使用场景</h2><ul>
<li>普通索引和唯一索引应该怎么选择？其实，这两类索引在<strong>查询能力上是没差别的</strong>，主要考虑的是<strong>对更新性能的影响</strong>。所以，建议你<strong>尽量选择普通索引</strong> 。</li>
<li>在实际使用中会发现， 普通索引 和 change buffer 的配合使用，对于 <strong>数据量大</strong> 的表的更新优化 还是很明显的。</li>
<li><strong>不适合change buffer情况：</strong>如果所有的更新后面，都马上伴随着对这个记录的查询 ，那么你应该关闭change buffer 。而在其他情况下，change buffer都能提升更新性能。</li>
<li>事务提交的时候，change buffer 的操作也会记录到<strong>redo log中</strong>，所以崩溃恢复时，change buffer 也可以找回来。</li>
<li>由于唯一索引用不上change buffer的优化机制，因此如果业务可以接受 ，从性能角度出发建议优先考虑非唯一索引。但是如果”业务可能无法确保”的情况下，怎么处理：<ul>
<li><strong>首先</strong>， 业务正确性优先 。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能 问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。 这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一 个排查思路。</li>
<li><strong>然后</strong>，在一些“ 归档库 ”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年， 然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率， 可以考虑把表里面的唯一索引改成普通索引。</li>
</ul>
</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><p><strong>数据唯一、多读少写：</strong>使用唯一索引，因为它查询性能高，写性能差。</p>
</li>
<li><p><strong>数据唯一、少读多写</strong>：使用普通索引+代码逻辑保持唯一。</p>
<ul>
<li><strong>更新之后需要立刻查询</strong>：关闭 change buffer。不然要经历<code>更新操作存入change buffer → 加载数据页到内存（缓冲池）→ 更新 → change buffer删除对应更新操作 → 查询</code>的过程，影响性能。关闭后流程是<code>加载数据页到内存（缓冲池）→ 更新 → 查询</code>。</li>
<li><strong>更新之后不需要立刻查询：</strong>保持change buffer打开。</li>
</ul>
</li>
<li><p><strong>数据不唯一：</strong>使用普通索引，不能使用唯一索引。</p>
</li>
</ul>
<hr>
<h1 id="主键设计思路"><a href="#主键设计思路" class="headerlink" title="主键设计思路"></a>主键设计思路</h1><p>聊一个实际问题：淘宝的数据库，主键是如何设计的？</p>
<p>某些错的离谱的答案还在网上年复一年的流传着，甚至还成为了所谓的MySQL军规。其中，一个最明显的错误就是关于MySQL的主键设计。</p>
<h2 id="自增主键的缺点"><a href="#自增主键的缺点" class="headerlink" title="自增主键的缺点"></a>自增主键的缺点</h2><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单，其他都是缺点，总体来看存在以下几方面的问题：</p>
<ul>
<li><p><strong>可靠性不高</strong></p>
<p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。</p>
</li>
<li><p><strong>安全性不高</strong></p>
<p><strong>回溯问题：</strong>例如，在一个新表中插入三条主键为1、2、3的数据行，这时候用<code>SHOW CREATE TABLE</code>命令查看该表的<code>AUTO_INCREMENT</code>的值是4，这是没问题的。</p>
<p>然后把ID=3的数据行删掉，再次查询<code>AUTO_INCREMENT</code>的值，依然是4，这也是没问题的。</p>
<p>但如果<strong>重启</strong>一下MySQL，这个<strong>值就会变回3</strong>，而不是4，发生了回溯。</p>
</li>
<li><p><strong>性能差</strong></p>
<p>自增ID的性能较差，需要在数据库服务器端生成。</p>
</li>
<li><p><strong>需要额外执行函数得知自增值，影响性能</strong></p>
<p>业务还需要额外执行一次类似 <strong>last_insert_id() 的函数</strong>才能知道刚才插入的自增值，这需要多一次网络交互。在海量并发的系统中，多1条SQL，就多一次<strong>性能上的开销</strong>。</p>
</li>
<li><p><strong>全局不唯一，高并发时自增锁竞争影响性能</strong></p>
<p>自增ID是局部唯一，只在当前数据库实例中唯一，而非全局唯一，在任意服务器间都是唯一的。不适用于分布式系统。</p>
</li>
<li><p><strong>分库分表、数据迁移时，自增不再适用。</strong></p>
</li>
</ul>
<h2 id="业务字段尽量不要做主键"><a href="#业务字段尽量不要做主键" class="headerlink" title="业务字段尽量不要做主键"></a>业务字段尽量不要做主键</h2><p>建议<strong>尽量不要用跟业务有关的字段做主键</strong>。毕竟，作为项目设计的技术人员，谁也无法预测 在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。</p>
<blockquote>
<p><strong>经验：</strong> 刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业务需求，但实际情况往往出乎意料，而<strong>更改主键设置的成本非常高。</strong></p>
</blockquote>
<h2 id="淘宝订单号的主键设计"><a href="#淘宝订单号的主键设计" class="headerlink" title="淘宝订单号的主键设计"></a>淘宝订单号的主键设计</h2><p>在淘宝的电商业务中，订单服务是一个核心业务。列举几个淘宝订单号信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1550672064762308113</span><br><span class="line">1481195847180308113</span><br><span class="line">1431156171142308113</span><br></pre></td></tr></table></figure>

<p>订单号是19位的长度，且订单的最后5位都是一样的，都是08113。且订单号的前面14位部分是单调递增的。</p>
<p>大胆猜测，<strong>淘宝的订单ID设计应该是：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">订单ID <span class="operator">=</span> 时间 <span class="operator">+</span> 去重字段 <span class="operator">+</span> 用户ID后<span class="number">6</span>位尾号</span><br></pre></td></tr></table></figure>

<p>这样的设计能做到全局唯一，且对分布式系统查询及其友好。</p>
<h2 id="推荐的主键设计"><a href="#推荐的主键设计" class="headerlink" title="推荐的主键设计"></a>推荐的主键设计</h2><h3 id="核心与非核心业务主键策略选择"><a href="#核心与非核心业务主键策略选择" class="headerlink" title="核心与非核心业务主键策略选择"></a>核心与非核心业务主键策略选择</h3><p><strong>非核心业务</strong> ：对应表的主键自增ID，如告警、日志、监控等信息。</p>
<p><strong>核心业务</strong> ：主键设计至少应该是全局唯一且是单调递增。全局唯一保证在各系统之间都是唯一的，单调 递增是希望插入时不影响数据库性能。推荐使用MySQL8.0 改造为<strong>有序UUID</strong>，具体通过函数uuid_to_bin(@uuid,true)将UUID转化为有序UUID。</p>
<h3 id="UUID的特点"><a href="#UUID的特点" class="headerlink" title="UUID的特点"></a>UUID的特点</h3><p><strong>全局唯一</strong>，占用36字节，数据无序，插入性能差。</p>
<p><strong>认识UUID：</strong></p>
<p>MySQL数据库的UUID组成如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID <span class="operator">=</span> 时间<span class="operator">+</span>UUID版本（<span class="number">16</span>字节）<span class="operator">-</span> 时钟序列（<span class="number">4</span>字节） <span class="operator">-</span> MAC地址（<span class="number">12</span>字节）</span><br></pre></td></tr></table></figure>

<p>以UUID值e0ea12d4-6473-11eb-943c-00155dbaa39d举例</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726152443274.png" alt="image-20250726152443274"></p>
<p><strong>为什么UUID是全局唯一的？</strong> </p>
<p>在UUID中<strong>时间部分占用60位</strong>，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00 到现在的100ns的计数。可以看到UUID存储的<strong>时间精度</strong>比TIMESTAMPE更高，<strong>时间维度发生重复的概率降低到1/100ns</strong>。</p>
<p><strong>时钟序列</strong>是为了<strong>避免</strong>时钟被回拨导致产生<strong>时间重复</strong>的可能性。<strong>MAC地址用于全局唯一</strong>。</p>
<p><strong>为什么UUID占用36个字节？</strong></p>
<p>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36个字节。</p>
<p><strong>为什么UUID是随机无序的呢？</strong></p>
<p>因为UUID的设计中，将<strong>时间低位放在最前面</strong>，而这部分的数据是一直在变化的，并且是无序。</p>
<h3 id="MySQL-8-0主键方案：有序UUID"><a href="#MySQL-8-0主键方案：有序UUID" class="headerlink" title="MySQL 8.0主键方案：有序UUID"></a>MySQL 8.0<strong>主键方案：有序UUID</strong></h3><p><strong>改造为有序：</strong>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。<strong>MySQL 8.0</strong>可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p>
<p><strong>优化空间占用：</strong>MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p>
<p>可以通过MySQL8.0提供的<strong>uuid_to_bin函数</strong>实现上述功能，同样的，MySQL也提供了<code>bin_to_uuid</code>函数进行转化：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@uuid</span> <span class="operator">=</span> UUID();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@uuid</span>,uuid_to_bin(<span class="variable">@uuid</span>),uuid_to_bin(<span class="variable">@uuid</span>,<span class="literal">TRUE</span>);</span><br></pre></td></tr></table></figure>

<p>通过函数uuid_to_bin(@uuid,true)<strong>将UUID转化为有序UUID</strong>了。<strong>全局唯一 + 单调递增</strong>，</p>
<p><strong>有序UUID性能测试：</strong></p>
<p>16字节的有序UUID，相比之前8字节的自增ID，性能和存储空间对比究竟如何呢？</p>
<p>插入1亿条数据，每条数据占用500字节，含有3个二级索引，最终的结果如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>时间(秒)</th>
<th>表大小(G)</th>
</tr>
</thead>
<tbody><tr>
<td>自增ID</td>
<td>2712</td>
<td>240</td>
</tr>
<tr>
<td>UUID</td>
<td>3396</td>
<td>250</td>
</tr>
<tr>
<td>有序UUID</td>
<td>2624</td>
<td>243</td>
</tr>
</tbody></table>
<p>插入1亿条数据有序UUID是最快的，而且在实际业务使用中有序UUID在 <strong>业务端就可以生成</strong> 。还可以进一步减少SQL的交互次数。</p>
<p>另外，虽然有序UUID相比自增ID多了8个字节，但实际只增大了3G的存储空间，还可以接受。</p>
<blockquote>
<p>在当今的互联网环境中，非常不推荐自增ID作为主键的数据库设计。更推荐类似有序UUID的全局 唯一的实现。</p>
<p>另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样 的主键设计就更为考验架构师的水平了。</p>
</blockquote>
<h3 id="MySQL8-0之前主键方案：手动赋值"><a href="#MySQL8-0之前主键方案：手动赋值" class="headerlink" title="MySQL8.0之前主键方案：手动赋值"></a>MySQL8.0之前主键方案：手动赋值</h3><p>设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。</p>
<p>可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。</p>
<p>门店在添加会员的时候，先到总部 MySQL 数据库中获取这个最大值，在这个基础上加 1，然后用这个值作为新会员的“id”，同时，更新总部 MySQL 数据库管理信息表中的当前会员编号的最大值。</p>
<p>这样一来，各个门店添加会员的时候，都对同一个总部 MySQL 数据库中的数据表字段进行操作，就解决了各门店添加会员时会员编号冲突的问题。</p>
<h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><p>有序的id。Long数据类型的64bit大小的整数：由1bit的<strong>符号位</strong>、41bit的<strong>时间戳</strong>、10bit的<strong>工作机器id</strong>、12bit的<strong>序列号</strong>组成。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>有序：</strong>所有生成的id按时间趋势递增</li>
<li><strong>分布式不重复：</strong>整个分布式系统内不会产重复id。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>依赖机器时钟：</strong>依赖机器时钟，如果机器时钟回拨，会导致有重复id生成。</li>
<li><strong>分布式时钟不同步导致递增失效：</strong>在单机上递增，但是如果在分布式环境下，每台机器时钟未必同步，可能出现不是全局递增情况。</li>
<li><strong>精度丢失：</strong>64位的二进制数，化为10进制存储一般为19位，但是前端js只能保证前16位的精度，前端拿到这条数据时，会对后三位进行四舍五入的处理，丢失了精度。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://southernfish.github.io">Southern Fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://southernfish.github.io/pages/database/db-mysql-3-index/">https://southernfish.github.io/pages/database/db-mysql-3-index/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://southernfish.github.io" target="_blank">Southern Fish</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="/img/article/article3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/pages/database/db-redis/"><img class="prev-cover" src="/img/article/article4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis</div></div></a></div><div class="next-post pull-right"><a href="/pages/database/db-mysql-2-engine/"><img class="next-cover" src="/img/article/article6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL数据库-存储引擎和索引结构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/pages/database/db-mysql-5-sharding/" title="MySQL数据库-表设计优化、读写分离与分库分表"><img class="cover" src="/img/article/article4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="title">MySQL数据库-表设计优化、读写分离与分库分表</div></div></a></div><div><a href="/pages/database/db-innodb-mvcc/" title="InnoDB 的 MVCC 实现"><img class="cover" src="/img/article/article1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-24</div><div class="title">InnoDB 的 MVCC 实现</div></div></a></div><div><a href="/pages/database/db-mysql-2-engine/" title="MySQL数据库-存储引擎和索引结构"><img class="cover" src="/img/article/article6.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-24</div><div class="title">MySQL数据库-存储引擎和索引结构</div></div></a></div><div><a href="/pages/database/db-mysql-6-query/" title="MySQL数据库-查询优化"><img class="cover" src="/img/article/article6.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="title">MySQL数据库-查询优化</div></div></a></div><div><a href="/pages/database/db-mysql-1-conception/" title="MySQL数据库-概述"><img class="cover" src="/img/article/article6.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-24</div><div class="title">MySQL数据库-概述</div></div></a></div><div><a href="/pages/database/db-mysql-4-optimize/" title="MySQL数据库-优化"><img class="cover" src="/img/article/article2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="title">MySQL数据库-优化</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southern Fish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">98</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SouthernFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1002721576@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">天下事岂能尽如吾意，心境须恰适，尽其在我，随遇而安。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">索引的分类与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">索引的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">普通索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">唯一索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%EF%BC%88%E5%94%AF%E4%B8%80%E9%9D%9E%E7%A9%BA%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">主键索引（唯一非空）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">单列索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%88%97-%E7%BB%84%E5%90%88%E3%80%81%E8%81%94%E5%90%88-%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.5.</span> <span class="toc-text">多列(组合、联合)索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.6.</span> <span class="toc-text">全文索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8D%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">1.1.7.</span> <span class="toc-text">空间索引（不常用）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E8%A1%A8%E6%97%B6%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.</span> <span class="toc-text">建表时创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E5%AD%97%E6%AE%B5%E4%BC%9A%E9%9A%90%E5%BC%8F%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">约束字段会隐式自动创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E3%80%81%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">显式、创建表的时候创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E8%A1%A8%E4%B8%8A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">在已存在的表上创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">删除索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.5.</span> <span class="toc-text">查看索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.</span> <span class="toc-text">索引的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.1.</span> <span class="toc-text">适合创建索引的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.2.</span> <span class="toc-text">不适合创建索引的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.3.</span> <span class="toc-text">创建索引的一些建议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL8-0%E7%B4%A2%E5%BC%95%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">MySQL8.0索引新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">3.1.</span> <span class="toc-text">支持降序索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.</span> <span class="toc-text">隐藏索引</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">4.</span> <span class="toc-text">覆盖索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">4.1.</span> <span class="toc-text">什么是覆盖索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E2%80%9C%E4%B8%8D%E7%AD%89%E4%BA%8E%E2%80%9D%E7%B4%A2%E5%BC%95%E7%94%9F%E6%95%88"><span class="toc-number">4.2.</span> <span class="toc-text">覆盖索引情况下，“不等于”索引生效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%B7%A6%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95%E7%94%9F%E6%95%88"><span class="toc-number">4.3.</span> <span class="toc-text">覆盖索引情况下，左模糊查询索引生效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%A9%E5%BC%8A"><span class="toc-number">4.4.</span> <span class="toc-text">覆盖索引的利弊</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">5.</span> <span class="toc-text">给字符串添加索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">5.1.</span> <span class="toc-text">前缀索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E4%B8%8D%E8%83%BD%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">5.2.</span> <span class="toc-text">前缀索引不能用覆盖索引</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%EF%BC%88ICP%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">索引下推（ICP）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ICP%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.1.</span> <span class="toc-text">ICP的使用条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ICP%E7%9A%84%E5%BC%80%E5%90%AF-%E5%85%B3%E9%97%AD"><span class="toc-number">6.2.</span> <span class="toc-text">ICP的开启&#x2F;关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%ADICP%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">6.3.</span> <span class="toc-text">开启和关闭ICP性能对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95-vs-%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-number">7.</span> <span class="toc-text">普通索引 vs 唯一索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E8%BF%91%E4%BC%BC"><span class="toc-number">7.1.</span> <span class="toc-text">查询性能近似</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E6%9B%B4%E6%96%B0%E6%80%A7%E8%83%BD%E6%9B%B4%E9%AB%98"><span class="toc-number">7.2.</span> <span class="toc-text">普通索引更新性能更高</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#change-buffer-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.3.</span> <span class="toc-text">change buffer 使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.4.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">8.</span> <span class="toc-text">主键设计思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">8.1.</span> <span class="toc-text">自增主键的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%AD%97%E6%AE%B5%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E5%81%9A%E4%B8%BB%E9%94%AE"><span class="toc-number">8.2.</span> <span class="toc-text">业务字段尽量不要做主键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%98%E5%AE%9D%E8%AE%A2%E5%8D%95%E5%8F%B7%E7%9A%84%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.3.</span> <span class="toc-text">淘宝订单号的主键设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.4.</span> <span class="toc-text">推荐的主键设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%B8%8E%E9%9D%9E%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E4%B8%BB%E9%94%AE%E7%AD%96%E7%95%A5%E9%80%89%E6%8B%A9"><span class="toc-number">8.4.1.</span> <span class="toc-text">核心与非核心业务主键策略选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UUID%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.4.2.</span> <span class="toc-text">UUID的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-8-0%E4%B8%BB%E9%94%AE%E6%96%B9%E6%A1%88%EF%BC%9A%E6%9C%89%E5%BA%8FUUID"><span class="toc-number">8.4.3.</span> <span class="toc-text">MySQL 8.0主键方案：有序UUID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL8-0%E4%B9%8B%E5%89%8D%E4%B8%BB%E9%94%AE%E6%96%B9%E6%A1%88%EF%BC%9A%E6%89%8B%E5%8A%A8%E8%B5%8B%E5%80%BC"><span class="toc-number">8.4.4.</span> <span class="toc-text">MySQL8.0之前主键方案：手动赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.5.</span> <span class="toc-text">雪花算法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/pages/high-availability/server-limit-stream/" title="服务限流"><img src="/img/article/article2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="服务限流"/></a><div class="content"><a class="title" href="/pages/high-availability/server-limit-stream/" title="服务限流">服务限流</a><time datetime="2025-09-18T09:02:36.000Z" title="发表于 2025-09-18 17:02:36">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/db-redis-persistence/" title="Redis的持久化机制"><img src="/img/article/article3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis的持久化机制"/></a><div class="content"><a class="title" href="/pages/database/db-redis-persistence/" title="Redis的持久化机制">Redis的持久化机制</a><time datetime="2025-09-18T01:15:36.000Z" title="发表于 2025-09-18 09:15:36">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/cache-read-write-strategies/" title="三大缓存读写策略"><img src="/img/article/article1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="三大缓存读写策略"/></a><div class="content"><a class="title" href="/pages/database/cache-read-write-strategies/" title="三大缓存读写策略">三大缓存读写策略</a><time datetime="2025-09-17T13:15:36.000Z" title="发表于 2025-09-17 21:15:36">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/db-redis-consistency/" title="Redis缓存与数据库的一致性"><img src="/img/article/article3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis缓存与数据库的一致性"/></a><div class="content"><a class="title" href="/pages/database/db-redis-consistency/" title="Redis缓存与数据库的一致性">Redis缓存与数据库的一致性</a><time datetime="2025-09-17T13:15:36.000Z" title="发表于 2025-09-17 21:15:36">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/db-redis-produce-problem/" title="Redis的缓存穿透、缓存击穿、缓存雪崩"><img src="/img/article/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis的缓存穿透、缓存击穿、缓存雪崩"/></a><div class="content"><a class="title" href="/pages/database/db-redis-produce-problem/" title="Redis的缓存穿透、缓存击穿、缓存雪崩">Redis的缓存穿透、缓存击穿、缓存雪崩</a><time datetime="2025-09-17T13:15:36.000Z" title="发表于 2025-09-17 21:15:36">2025-09-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/article/article3.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Southern Fish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>