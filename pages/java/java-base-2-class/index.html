<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JAVA的常用类 | Southern Fish</title><meta name="keywords" content="java基础"><meta name="author" content="Southern Fish"><meta name="copyright" content="Southern Fish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA的常用类">
<meta property="og:url" content="https://southernfish.github.io/pages/java/java-base-2-class/index.html">
<meta property="og:site_name" content="Southern Fish">
<meta property="og:description" content="Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://southernfish.github.io/img/article/article5.png">
<meta property="article:published_time" content="2025-07-23T12:39:36.000Z">
<meta property="article:modified_time" content="2025-09-26T06:31:52.069Z">
<meta property="article:author" content="Southern Fish">
<meta property="article:tag" content="java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://southernfish.github.io/img/article/article5.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://southernfish.github.io/pages/java/java-base-2-class/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JAVA的常用类',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-26 14:31:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Southern Fish" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">98</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/article/article5.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Southern Fish</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JAVA的常用类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-23T12:39:36.000Z" title="发表于 2025-07-23 20:39:36">2025-07-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-26T06:31:52.069Z" title="更新于 2025-09-26 14:31:52">2025-09-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JAVA的常用类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Java是一门面向对象的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131?fromModule=lemma_inlink">编程语言</a>，不仅吸收了<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/C%2B%2B/99272?fromModule=lemma_inlink">C++</a>语言的各种优点，还摒弃了C++里难以理解的多<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%A7%E6%89%BF/20267560?fromModule=lemma_inlink">继承</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304?fromModule=lemma_inlink">指针</a>等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。Java具有简单性、面向对象、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F/19276232?fromModule=lemma_inlink">分布式</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%81%A5%E5%A3%AE%E6%80%A7/4430133?fromModule=lemma_inlink">健壮性</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E6%80%A7/7664678?fromModule=lemma_inlink">安全性</a>、平台独立与可移植性、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fromModule=lemma_inlink">多线程</a>、动态性等特点。 Java可以编写<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/2331979?fromModule=lemma_inlink">桌面应用程序</a>、Web应用程序、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336?fromModule=lemma_inlink">分布式系统</a>和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/186978?fromModule=lemma_inlink">嵌入式系统</a>应用程序等。</p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/article/details/134564921">全网最完整Java学习笔记</a></p>
</blockquote>
<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>String是一个类，用于存储字符串，内部封装了一系列用于操作字符串的方法，底层是<code>final</code>修饰的char数组。</p>
<p>JDK9开始，为了节省内存，进而减少垃圾回收次数，String底层由<code>char</code>数组改成了<code>byte[]</code>。</p>
<blockquote>
<p><strong>Java的String和c++的string区别：</strong></p>
<ul>
<li>java中字符串一个汉字长度是1；</li>
<li>c++中字符串，一个汉字长度是2. </li>
</ul>
</blockquote>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建字符串有两种方式，一种是使用字符串直接量，另一种是使用new+构造器。采用new的方式会多创建出一个对象来，占用了更多的内存 ，所以建议采用直接量的方式来创建字符串。</p>
<p><strong>字符串直接量创建</strong>：JVM会使用常量池来管理这个字符串；<br><strong>new创建</strong>：JVM会先使用常量池来管理字符串直接量（若已有此字符串则直接返回引用，若没有则实例化后再返回引用），再调用String类的构造器来创建一个新的String对象，新创建的String对象会被保存在堆内存中。字符串常量池源码用到了享元设计模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 直接创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Runoob&quot;</span>;       </span><br><span class="line"><span class="comment">// String 对象创建       </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Runoob&quot;</span>);   </span><br><span class="line"><span class="comment">// 引用赋值的方法创建字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1;                   </span><br></pre></td></tr></table></figure>

<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><blockquote>
<p><strong>自带方法访问</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过索引访问字符：charAt()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;First Character: &quot;</span> + firstChar);</span><br><span class="line"><span class="comment">// 访问子串：substring()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;0123456789ABCDEFG&quot;</span>;</span><br><span class="line"><span class="comment">// 提取索引 7 到 11 的子串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> str.substring(<span class="number">7</span>, <span class="number">12</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Substring: &quot;</span> + substring);</span><br></pre></td></tr></table></figure>

<p><strong>遍历字符串每个字母</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用for循环遍历字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用增强for循环遍历字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用while循环遍历字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; str.length()) &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Iterator遍历字符串</span></span><br><span class="line">Iterator&lt;Character&gt; iterator = str.chars().mapToObj(c -&gt; (<span class="type">char</span>) c).iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a><strong>连接</strong></h3><p>字符串可以通过“+”号拼接，拼接过程中可以将数字型转为字符串。字符串拼接数字，数字会转成字符串。</p>
<p><strong>字符串连接字符数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s = s + <span class="string">&quot;, World!&quot;</span>;</span><br><span class="line"><span class="comment">// 连接字符数组</span></span><br><span class="line"><span class="type">char</span>[] greeting = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span>[] suffix = &#123;<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span>[] result = <span class="keyword">new</span> <span class="title class_">char</span>[greeting.length + suffix.length];</span><br><span class="line">System.arraycopy(greeting, <span class="number">0</span>, result, <span class="number">0</span>, greeting.length);</span><br><span class="line">System.arraycopy(suffix, <span class="number">0</span>, result, greeting.length, suffix.length);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><p>在 Java 中，可以使用 <code>substring()</code> 方法获取字符串的子串： </p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// substring(int beginIndex)： 返回从指定索引开始到字符串末尾的子串。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">originalString</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> originalString.substring(<span class="number">7</span>);          <span class="comment">// 从索引 7 开始到字符串末尾的子串</span></span><br><span class="line">System.out.println(substring);                          <span class="comment">// 输出结果为 &quot;World!&quot;</span></span><br><span class="line"><span class="comment">// substring(int beginIndex, int endIndex)： 返回从指定索引开始到指定索引结束的子串（不包括 endIndex 处的字符）。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">originalString</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> originalString.substring(<span class="number">7</span>, <span class="number">12</span>);      <span class="comment">// 从索引 7 开始到索引 12 结束的子串</span></span><br><span class="line">System.out.println(substring);                          <span class="comment">// 输出结果为 &quot;World&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>因为String是不可变的，对字符串的任何操作都会返回一个新的字符串。所以substring 方法其实是创建了一个字符子串，而不是修改了原始字符串。</p>
</blockquote>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>Java中字符串没有直接根据索引删除的方法，所以删除字符串中指定索引的字母时，可以通过子串substring()删除。</p>
<p><strong>示例：</strong>删除字符串中下标是6的字母</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, <span class="number">5</span>) + str.substring(<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Modified String: &quot;</span> + newStr);</span><br></pre></td></tr></table></figure>

<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>在Java中， 可以使用replaceAll()方法替换字符中的字符：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// replaceAll(String regex, String replacement)：使用给定的替换字符串替换输入字符串中所有匹配正则表达式的部分。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">originalString</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">replacedString</span> <span class="operator">=</span> originalString.replaceAll(<span class="string">&quot;o&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">System.out.println(replacedString);                  <span class="comment">// 输出结果为 &quot;Hell0, W0rld!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// replaceAll(String regex, Function&lt;MatchResult, String&gt; replacer)：使用给定的 Function 替换输入字符串中所有匹配正则表达式的部分。该方法允许更加灵活的替换逻辑，并且可以基于匹配的结果进行自定义的替换。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">originalString</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">replacedString</span> <span class="operator">=</span> originalString.replaceAll(<span class="string">&quot;o&quot;</span>, match -&gt; match.group().toUpperCase());</span><br><span class="line">System.out.println(replacedString);                  <span class="comment">// 输出结果为 &quot;HellO, WOrld!&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a><strong>获取长度</strong></h3><p>可以通过length()方法获取字符串的长度。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Java Programming&quot;</span>;</span><br><span class="line">        <span class="comment">// 返回字符串的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> text.length();</span><br><span class="line">        System.out.println(length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>字符串内容的互相比较一般用equals()方法。Java中所有类都直接或间接继承了 Object 类，在 Object 类中，equals() 方法是 Java 中用于比较两个对象的引用是否相等（即内存地址是否相同）。</p>
<p>在 String 类中，equals() 方法被重写，用于比较两个字符串的内容是否相等。</p>
<blockquote>
<p><strong>注意：</strong>尽量不要用<code>==</code>进行比较，<code>==</code>比较的是地址。</p>
<p>String底层是常量池，使用享元设计模式，新创建的字符串会维护在常量池，下次再创建这个字符串，就直接从常量池取。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.比较地址</span></span><br><span class="line">        <span class="comment">// 只要new，就在堆内存开辟空间。直接赋值字符串在常量池里。</span></span><br><span class="line">        <span class="comment">// 常量池里无“hello”对象，创建“hello”对象，str1指向常量池“hello”对象。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">// 先检查字符串常量池中有没有&quot;hello&quot;</span></span><br><span class="line">            <span class="comment">//  如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，</span></span><br><span class="line">            <span class="comment">//     如果有，则直接将 str1 指向&quot;hello&quot;；</span></span><br><span class="line">        <span class="comment">// 常量池里有“hello”对象，str2直接指向常量池“hello”对象。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">// 堆中new创建了一个对象。假如“hello”在常量池中不存在，Jvm还会常量池中创建这个对象“hello”。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 下面输出true，因为str1和str2指向的是常量池中的同一个内存地址</span></span><br><span class="line">        System.out.println(str1 == str2);</span><br><span class="line">        <span class="comment">// 下面输出false，str1常量池旧地址，str3是new出的新对象，指向一个全新的地址</span></span><br><span class="line">        System.out.println(str1 == str3);</span><br><span class="line">        <span class="comment">// 下面输出false，因为它们引用不同</span></span><br><span class="line">        System.out.println(str4 == str3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.比较内容</span></span><br><span class="line">        <span class="comment">// 下面输出true，因为String类的equals方法重写过，比较的是字符串值</span></span><br><span class="line">        System.out.println(str4.equals(str3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与equals-的区别"><a href="#与equals-的区别" class="headerlink" title="==与equals()的区别"></a><code>==</code>与equals()的区别</h3><p><code>==</code> 比较基本数据类型时，比较的是两个数值是否相等； 比较引用类型是，比较的是对象的内存地址是否相等。<br>equals() 没有重写时，Object默认以<code>==</code>来实现，即比较两个对象的内存地址是否相等； 重写以后，按照重写的逻辑进行比较。<br>示例：String源码中重写的equals()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public final class String</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (anObject <span class="keyword">instanceof</span> String aString)</span><br><span class="line">            &amp;&amp; (!COMPACT_STRINGS || <span class="built_in">this</span>.coder == aString.coder)</span><br><span class="line">            &amp;&amp; StringLatin1.equals(value, aString.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final class stringLatin1</span></span><br><span class="line"><span class="meta">@IntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="type">byte</span>[] value, <span class="type">byte</span>[] other)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length == other.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value[i] != other[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果地址一样，则一定相等；</li>
<li>如果对比的元素不是String类型，则一定不相等；</li>
<li>遍历String底层的数组，逐个对比字符是否相等；</li>
</ul>
<h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>split() 方法是 Java 中 String 类的一个方法，用于将字符串分割成字符串数组，根据给定的正则表达式作为分隔符。该方法有两个重载的版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.split(String regex)： 使用给定的正则表达式作为分隔符，将字符串分割为字符串数组。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> <span class="string">&quot;Hello, World! How are you?&quot;</span>;</span><br><span class="line">String[] words = sentence.split(<span class="string">&quot; &quot;</span>);          <span class="comment">// 使用空格作为分隔符</span></span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">    System.out.println(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.split(String regex, int limit)： 使用给定的正则表达式作为分隔符，将字符串分割为字符串数组，限制分割的次数。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> <span class="string">&quot;apple,orange,banana,grape&quot;</span>;</span><br><span class="line">String[] fruits = sentence.split(<span class="string">&quot;,&quot;</span>, <span class="number">2</span>);      <span class="comment">// 使用逗号作为分隔符，限制分割次数为 2</span></span><br><span class="line"><span class="keyword">for</span> (String fruit : fruits) &#123;</span><br><span class="line">    System.out.println(fruit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// apple</span></span><br><span class="line"><span class="comment">// orange,banana,grape</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：split() 方法的参数是正则表达式，因此在传入正则表达式时，可能需要注意转义字符的使用。例如，如果要以点号 . 作为分隔符，由于点号在正则表达式中有特殊含义，需要使用双反斜杠 \ 进行转义。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> <span class="string">&quot;one.two.three&quot;</span>;</span><br><span class="line">String[] parts = sentence.split(<span class="string">&quot;\\.&quot;</span>);  <span class="comment">// 使用点号作为分隔符，需要转义</span></span><br><span class="line"><span class="keyword">for</span> (String part : parts) &#123;</span><br><span class="line">    System.out.println(part);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Java Programming&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">lowerCase</span> <span class="operator">=</span> text.toLowerCase();</span><br><span class="line"><span class="type">String</span> <span class="variable">upperCase</span> <span class="operator">=</span> text.toUpperCase();</span><br></pre></td></tr></table></figure>

<h3 id="字符串和数字的互相转换"><a href="#字符串和数字的互相转换" class="headerlink" title="字符串和数字的互相转换"></a>字符串和数字的互相转换</h3><p><strong>1. 字符串转整数：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">strNumber</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">// 使用 Integer.parseInt() 方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> Integer.parseInt(strNumber);</span><br><span class="line">System.out.println(<span class="string">&quot;Parsed Integer: &quot;</span> + intValue);</span><br><span class="line"><span class="comment">// 使用 Integer.valueOf() 方法</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integerValue</span> <span class="operator">=</span> Integer.valueOf(strNumber);</span><br><span class="line">System.out.println(<span class="string">&quot;Integer Value: &quot;</span> + integerValue);</span><br></pre></td></tr></table></figure>

<p><strong>2. 整数转字符串：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="comment">// 使用 String.valueOf() 方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strNumber</span> <span class="operator">=</span> String.valueOf(intValue);</span><br><span class="line">System.out.println(<span class="string">&quot;String Value: &quot;</span> + strNumber);</span><br><span class="line"><span class="comment">// 使用 Integer.toString() 方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strNumber</span> <span class="operator">=</span> Integer.toString(intValue);</span><br><span class="line">System.out.println(<span class="string">&quot;String Value: &quot;</span> + strNumber);</span><br></pre></td></tr></table></figure>

<h3 id="数组和字符串的互相转换"><a href="#数组和字符串的互相转换" class="headerlink" title="数组和字符串的互相转换"></a><strong>数组和字符串的互相转换</strong></h3><ol>
<li><strong>数组转List</strong>：List<T> arrayToList(T[] array)</li>
<li><strong>List转数组</strong>：T[] listToArray(List<T> list, Class<T> elementType)</li>
<li><strong>数组转Set</strong>：Set<T> arrayToSet(T[] array)</li>
<li><strong>Set转数组：</strong>T[] setToArray(Set<T> set, Class<T> elementType)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 数组转List</span></span><br><span class="line">String[] array = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; listFromArray = Arrays.asList(array);</span><br><span class="line">System.out.println(<span class="string">&quot;List from Array: &quot;</span> + listFromArray);</span><br><span class="line"><span class="comment">// 2. List转数组</span></span><br><span class="line">List&lt;String&gt; fruitList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">String[] arrayFromList = fruitList.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;Array from List: &quot;</span> + Arrays.toString(arrayFromList));</span><br><span class="line"><span class="comment">// 3. List转Set</span></span><br><span class="line">Set&lt;String&gt; setFromList = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(fruitList);</span><br><span class="line">System.out.println(<span class="string">&quot;Set from List: &quot;</span> + setFromList);</span><br><span class="line"><span class="comment">// 4. Set转List</span></span><br><span class="line">Set&lt;String&gt; fruitSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Set.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">List&lt;String&gt; listFromSet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(fruitSet);</span><br><span class="line">System.out.println(<span class="string">&quot;List from Set: &quot;</span> + listFromSet);</span><br><span class="line"><span class="comment">// 5. Set转数组</span></span><br><span class="line">String[] arrayFromSet = fruitSet.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;Array from Set: &quot;</span> + Arrays.toString(arrayFromSet));</span><br><span class="line"><span class="comment">// 6. 数组转Set</span></span><br><span class="line">Set&lt;String&gt; setFromArray = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(array));</span><br><span class="line">System.out.println(<span class="string">&quot;Set from Array: &quot;</span> + setFromArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为集合后，可以通过集合的api操作各元素。例如：判断数组是否包含某个元素：</span></span><br><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEle</span> <span class="operator">=</span> Arrays.asList(array).contains(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(isEle);</span><br></pre></td></tr></table></figure>

<h3 id="格式化数字为字符串"><a href="#格式化数字为字符串" class="headerlink" title="格式化数字为字符串"></a>格式化数字为字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">123.456789</span>;</span><br><span class="line"><span class="comment">// 格式化浮点数为字符串，保留两位小数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">formattedString</span> <span class="operator">=</span> String.format(<span class="string">&quot;%.2f&quot;</span>, number);</span><br><span class="line">System.out.println(formattedString);</span><br></pre></td></tr></table></figure>

<h2 id="知识加油站"><a href="#知识加油站" class="headerlink" title="知识加油站"></a>知识加油站</h2><h3 id="字符串和字符数组的区别"><a href="#字符串和字符数组的区别" class="headerlink" title="字符串和字符数组的区别"></a>字符串和字符数组的区别</h3><ul>
<li><strong>可变性</strong>：字符串是不可变的。一旦创建，字符串的内容就不能被修改。任何对字符串的修改底层都会创建一个新的字符串对象。而字符数组是可变的。你可以直接修改字符数组的元素。</li>
<li><strong>方法数量</strong>：String类提供了许多用于处理字符串的方法，如拼接、比较、截取、转换大小写等。而字符数组只有toString()、equals()等简单的数组通用方法。</li>
<li><strong>性质</strong>：String是类（底层是字节数组），字符数组是数组。</li>
<li><strong>创建方式</strong>：String str = “Hello”;char[] charArray = {‘H’, ‘e’, ‘l’, ‘l’, ‘o’};</li>
<li><strong>连接</strong>：字符串通过“+”连接，字符数组通过System.arraycopy()连接。</li>
<li><strong>使用场景</strong>：String不可变，所以适用于不需要频繁修改字符串内容的情况。字符数组适用于需要频繁修改字符内容的情况</li>
</ul>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>常量池</strong>：Java虚拟机有一个常量池机制，它会直接把字符串常量放入常量池中，从而实现复用。</p>
<p><strong>Java字符串存储原理</strong>： </p>
<p>创建字符串常量时，JVM会通过equals()检查字符串常量池中是否存在这个字符串；<br>若字符串常量池中存在该字符串，则直接返回引用实例；<br>若不存在，先实例化该字符串，并且将该字符串的引用放入字符串常量池中，以便于下次使用时，直接取用，达到缓存快速使用的效果。</p>
<h3 id="String不可被继承、不可变的原因"><a href="#String不可被继承、不可变的原因" class="headerlink" title="String不可被继承、不可变的原因"></a>String不可被继承、不可变的原因</h3><p><strong>String为什么不可被继承？</strong></p>
<p>因为String类底层的数组是由final修饰的，所以String类不可被继承。</p>
<p><strong>String字符串为什么不可被变？</strong></p>
<p>因为String底层char类型的value数组是private final修饰的。</p>
<ul>
<li><strong>final修饰</strong>：导致value不能指向新数组（但无法保证value这个引用变量指向的真实数组不可变）；</li>
<li><strong>private修饰，且没对外暴露任何修改value的方法</strong>：导致value这个引用变量指向的底层数组不可变；</li>
</ul>
<p><strong>不可变的优点</strong>：因为压根不会被改，所以线程安全、节省空间、效率高。 </p>
<h3 id="new-String-“abc”-创建的字符串对象数量"><a href="#new-String-“abc”-创建的字符串对象数量" class="headerlink" title="new String(“abc”)创建的字符串对象数量"></a>new String(“abc”)创建的字符串对象数量</h3><p>一个或两个。<strong>原因如下</strong>：</p>
<ul>
<li><p>首先，new string 这边由于 new 关键字，所以这边肯定会在堆中直接创建一个字符串对象。</p>
</li>
<li><p>其次，如果字符串常量池中不存在 “abc”（通过equals比较）这个字符串的引用，则会在字符串常量池中创建一个字符串对象。如果已存在则不创建。注意这边说的在字符串常量池创建对象，最终对象还是在堆中创建，字符串常量池只放引用。</p>
</li>
</ul>
<hr>
<h1 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>String拼接字符串后原字符串还存在于内存中，浪费内存。</p>
<p>StringBuffer 类的对象能够被多次的修改，并且不产生新的未使用对象，所以涉及到字符串拼接，优先用StringBuffer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>); </span><br><span class="line"><span class="comment">// String转StringBuilder</span></span><br><span class="line">sb.append(<span class="string">&quot;d&quot;</span>).append(<span class="string">&quot;e&quot;</span>).append(<span class="string">&quot;f&quot;</span>); </span><br><span class="line"><span class="comment">// StringBuilder转String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line"><span class="comment">// 反转</span></span><br><span class="line">sb.reverse();</span><br></pre></td></tr></table></figure>

<h2 id="String、StringBuffer、Stringbuilder的区别"><a href="#String、StringBuffer、Stringbuilder的区别" class="headerlink" title="String、StringBuffer、Stringbuilder的区别"></a>String、StringBuffer、Stringbuilder的区别</h2><p><strong>String</strong>：不可变字符序列，效率低，但是复用率高、线程安全。</p>
<p>不可变是指String对象创建之后，直到这个对象销毁为止，对象中的字符序列都不能被改变。</p>
<p>复用率高是指String类型对象创建出来后归常量池管，可以随时从常量池调用同一个String对象。<code>StringBuffer</code>和<code>StringBuider</code>在创建对象后一般要转化成String对象才调用。</p>
<p><code>StringBuffer</code>和<code>StringBuilder</code>都是字符序列可变的字符串，方法也一样，有共同的父类<code>AbstractStringBuilder</code>。 </p>
<ul>
<li><code>StringBuffer</code>：可变字符序列、效率较高(增删)、线程安全</li>
<li><code>StringBuilder</code>：可变字符序列、效率最高、线程不安全</li>
</ul>
<hr>
<h1 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h1><p>该类用于从各种输入源（如控制台）中获取基本数据类型和字符串，如 int、double、String 等。常用于从控制台、文件等读取数据。</p>
<p><strong>构造方法</strong>：</p>
<ul>
<li><code>Scanner(InputStream source)</code>： 构造一个新的 Scanner，生成的扫描器从指定的输入流读取数据。一般用System.in，即标准输入流，用于读取用户在控制台输入的数据。</li>
<li><code>Scanner(File source)</code>： 构造一个新的 Scanner，生成的扫描器从指定的文件读取数据。</li>
<li><code>Scanner(String source)</code>：构造一个新的 Scanner，生成的扫描器从指定的字符串读取数据。</li>
</ul>
<p><strong>常用方法</strong>：</p>
<ul>
<li><code>nextInt()、nextDouble()、next()</code>：获取输入的整数、浮点数、字符串（不包括空格）等。</li>
<li><code>nextLine()</code>：获取一行输入（包括空格）。</li>
<li><code>hasNextInt()、hasNextDouble()、hasNext()</code>： 判断下一个输入是否为整数、浮点数、字符串。</li>
<li><code>useDelimiter(String pattern)</code>： 设置分隔符模式，用于指定不同类型数据之间的分隔符，默认为空白字符。</li>
<li><code>close()</code>：关闭扫描器。</li>
</ul>
<p><strong>示例：</strong>从控制台输入整数、浮点数、字符串，并在控制台打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象，关联 System.in（标准输入流）</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 从控制台读取整数</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter an integer: &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;You entered: &quot;</span> + intValue);</span><br><span class="line">        <span class="comment">// 从控制台读取浮点数</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter a double: &quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;You entered: &quot;</span> + doubleValue);</span><br><span class="line">        <span class="comment">// 从控制台读取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringValue</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;You entered: &quot;</span> + stringValue);</span><br><span class="line">        <span class="comment">// 关闭 Scanner 对象</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// Enter an integer: 1</span></span><br><span class="line"><span class="comment">// You entered: 1</span></span><br><span class="line"><span class="comment">// Enter a double: 2</span></span><br><span class="line"><span class="comment">// You entered: 2.0</span></span><br><span class="line"><span class="comment">// Enter a string: 4</span></span><br><span class="line"><span class="comment">// You entered: 4</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>在 Java 中，Object 类是所有类的根类，所有其他类都直接或间接地继承自 Object 类。</p>
<p>Object 类定义了一些基本的方法，这些方法可以被所有对象继承和使用：</p>
<ol>
<li><p><strong>toString() 方法：</strong> 返回对象的字符串表示。再不重写的情况下，toString() 返回的是对象的类名和散列码的十六进制表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义转字符串逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyClass&#123;&quot;</span> +</span><br><span class="line">               <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用 toString() 方法</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// toString将根据自己重新的逻辑返回字符串，而不是返回对象的类名和散列码的十六进制表示</span></span><br><span class="line">System.out.println(obj.toString());  <span class="comment">// 输出结果为 &quot;MyClass&#123;value=42&#125;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>equals(Object obj) 方法：</strong> 比较对象是否相等。默认情况下，equals() 方法比较的是对象的引用（即内存地址），重写后可以自定义比较逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// ... 其他代码 ...</span></span><br><span class="line">    <span class="comment">// 自定义比较逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="3">
<li><p><strong>hashCode() 方法：</strong> 返回对象的散列码。hashCode() 方法的默认实现返回对象的内存地址的散列码。通常情况下，如果 equals() 方法被覆盖，那么也应该同时覆盖 hashCode() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li>
<li><p><strong>getClass() 方法：</strong> 返回对象的类。该方法基于反射，返回类的 Class 对象，该对象包含有关对象的类的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="number">42</span>);</span><br><span class="line">Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line">System.out.println(clazz.getName());  <span class="comment">// 输出结果为 &quot;MyClass&quot;   </span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>clone() 方法：</strong> 创建并返回对象的拷贝。要实现 clone() 方法，类必须实现 Cloneable 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneableClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneableClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li>
<li><p><strong>finalize() 方法：</strong> 在对象被垃圾收集器回收之前调用。通常不推荐使用 finalize() 方法，因为它的行为是不确定的，并且可能导致一些问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 执行清理工作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">super</span>.finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="JVM垃圾回收的可达性分析算法"><a href="#JVM垃圾回收的可达性分析算法" class="headerlink" title="JVM垃圾回收的可达性分析算法"></a>JVM垃圾回收的可达性分析算法</h2><p>JVM垃圾回收的可达性分析算法有用到Object类的finalize() 方法。</p>
<p><strong>可达性分析算法</strong>：</p>
<p>以根对象集合(GC Roots)的每个跟对象为起始点，根据引用关系向下搜索，将所有与GC Roots直接或间接有引用关系的对象在对象头的Mark Word里标记为可达对象，即不需要回收的有引用关系对象。搜索过程所走过的路径称为“引用链” 。</p>
<p>**<code>GC Roots</code>**：即GC根节点集合，是一组必须活跃的引用。可作为GC Roots的对象：</p>
<ul>
<li><strong>栈引用的对象</strong>：Java方法栈、本地方法栈中的参数引用、局部变量引用、临时变量引用等。临时变量是方法里的中间操作结果。</li>
<li>方法区中常量、静态变量引用的对象；</li>
<li>所有被同步锁持有的对象；</li>
<li>所有线程对象；</li>
<li>所有跨代引用对象；</li>
<li><strong>JVM内部的引用</strong>：如基本数据类型对应的Class对象，常驻的异常对象，以及应用程序类类加载器； </li>
</ul>
<p><strong>非可达对象被回收需要两次标记</strong>：</p>
<ol>
<li><strong>第一次标记后筛选非可达对象</strong>：第一次被标记后，会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，也就是是否有机会自救。假如对象没有覆盖或者已被JVM调用过finalize()方法，也就是说不想自救或已自救过，那么此对象需要被回收；假如对象覆盖并没被JVM调用过finalize()方法，该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</li>
<li><strong>第二次标记<code>F-Queue</code>里的未自救对象</strong>：稍后，收集器将对F-Queue中的对象进行第二次小规模的标记。如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this）赋值给某个引用类型的类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的F-Queue。如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</li>
</ol>
<p><strong><code>finalize()</code>方法</strong>： </p>
<p>finalize()方法是对象逃脱死亡命运的最后一次机会，需要注意的是，任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。</p>
<p>另外，finalize()方法的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。</p>
<h2 id="hashCode-和equals-的区别"><a href="#hashCode-和equals-的区别" class="headerlink" title="hashCode()和equals()的区别"></a>hashCode()和equals()的区别</h2><p><strong>用途：</strong></p>
<ul>
<li><code>hashCode()</code>方法的主要用途是获取哈希码；</li>
<li><code>equals()</code>主要用来比较两个对象是否相等。</li>
</ul>
<p><strong>为什么重写equals()就要重写hashcode()？</strong> </p>
<p>因为二者之间有两个约定，相等对象的哈希码也要相等。</p>
<p>所以equals()方法重写时，通常也要将<code>hashCode()</code>进行重写，使得这两个方法始终满足相关的约定。 例如<code>HashSet</code>排序机制底层就是通过计算哈希码进行排序的，如果只重写<code>equals()</code>将达不到根据哈希码排序的效果。</p>
<p>如果两个对象相等,它们必须有相同的哈希码；但如果两个对象的哈希码相同,他们却不一定相等。</p>
<p><strong>哈希碰撞</strong>：由于哈希码是一个有限的整数，因此有可能会出现不同的对象计算出相同的哈希码的情况。 例如某类里有两个int型成员变量，重写后equals()比较两个变量是否相等，hashcode()是两个变量的和，A对象变量是2和3，B对象变量是1和4，加起来都是5，它们哈希码相等而不equal。</p>
<hr>
<h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><p>System 类是 Java 标准库中的一个工具类，提供了与系统相关的一些操作。</p>
<p>它包含一些静态方法和字段，用于访问系统属性、标准输入输出、垃圾回收等。</p>
<p>常用方法和字段：</p>
<blockquote>
<p>PrintStream、PrintStream等IO流详细看后文的I/O流。</p>
</blockquote>
<ol>
<li><p><strong><code>out</code> 字段</strong>： 是 PrintStream 类的一个实例，用于标准输出。可以使用 System.out.println() 来向标准输出打印信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);  <span class="comment">// 将 &quot;Hello, World!&quot; 输出到标准输出</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>err</code> 字段</strong>： 是 PrintStream 类的一个实例，用于标准错误输出。可以使用 System.err.println() 来向标准错误输出打印错误信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.err.println(<span class="string">&quot;This is an error message.&quot;</span>);  <span class="comment">// 将错误信息输出到标准错误输出</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>in</code> 字段</strong>： 是 InputStream 类的一个实例，用于标准输入。可用 Scanner 或 BufferedReader 等类从标准输入读取用户输入信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;Enter your name: &quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine();</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>currentTimeMillis() </code>方法</strong>： 返回当前时间与1970年1月1日午夜之间的毫秒数。通常用于测量代码的执行时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 执行一些操作</span></span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> endTime - startTime;</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code> 方法</strong>： 用于复制数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] sourceArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] destinationArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">System.arraycopy(sourceArray, <span class="number">0</span>, destinationArray, <span class="number">0</span>, sourceArray.length);</span><br><span class="line"><span class="comment">// 现在 destinationArray 中包含了 sourceArray 的内容</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>getProperty(String key)</code> 方法</strong>： 获取系统属性。可以用于获取一些系统相关的信息，比如操作系统类型、Java 版本等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Operating System: &quot;</span> + osName);</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>exit(int status) </code>方法</strong>： 终止当前运行的 Java 虚拟机。status 参数是一个整数，通常用于指示程序的退出状态。非零值通常表示发生了错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.exit(<span class="number">0</span>);  <span class="comment">// 正常退出程序</span></span><br><span class="line">System.exit(<span class="number">1</span>);  <span class="comment">// 异常退出程序</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>gc()</code> 方法</strong>： 强制调用垃圾回收器。虽然 Java 具有自动垃圾回收机制，但可以使用 System.gc() 来显式地触发垃圾回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.gc();  <span class="comment">// 强制调用垃圾回收器</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h1><h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Integer类是 Java 中用于表示整数的包装类，它提供了许多方法来对整数进行操作和转换。</p>
<p>相比于基本数据类型，包装类的优势：可以有更多的方法操作改数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装箱：基本数据类型转为包装类</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">32</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"><span class="comment">// 拆箱：包装类转为基本数据类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a.intValue();</span><br><span class="line"><span class="comment">// 数字转String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(<span class="number">12</span>);</span><br><span class="line"><span class="comment">// String转数字</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line"><span class="comment">// String转Integer转数字</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> Integer.valueOf(s).intValue();</span><br></pre></td></tr></table></figure>

<h2 id="包装类的自动拆装箱与自动装箱"><a href="#包装类的自动拆装箱与自动装箱" class="headerlink" title="包装类的自动拆装箱与自动装箱"></a>包装类的自动拆装箱与自动装箱</h2><p><strong>包装类</strong>：包装类的主要作用是用于便于操作基本数据类型，将基本数据类型转换为对象，让基本数据类型拥有对象的特征，例如封装方法、泛型（基本数据类型不能作为泛型参数）、反射。 </p>
<p>自动装箱是指把一个基本类型的数据直接赋值给对应的包装类型；</p>
<p>自动拆箱是指把一个包装类型的对象直接赋值给对应的基本类型；</p>
<p><strong>向上转型</strong>：布尔型外的基本数据类型在互相比较或运算时会向上转型：byte,short,char → int → long → float → double。原理是将低字节数的数据类型转换为高字节数的数据类型，可以保证数据精度不丢失。c语言转型顺序：char→short→int→long→float→double </p>
<h2 id="什么情况下用包装类？什么情况下用基本数据类型？"><a href="#什么情况下用包装类？什么情况下用基本数据类型？" class="headerlink" title="什么情况下用包装类？什么情况下用基本数据类型？"></a>什么情况下用包装类？什么情况下用基本数据类型？</h2><p><strong>包装类适用场景</strong>： </p>
<ul>
<li><strong>实体类属性必须使用包装类</strong>：《阿里规约》规定，所有的 POJO 类属性必须使用包装数据类型，而不是基本数据类型。因为数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险（NullPointerException空指针异常）。</li>
<li><strong>RPC方法的返回值和参数必须使用包装类</strong>：《阿里规约》规定，RPC 方法的返回值和参数必须使用包装数据类型。因为相比基本数据类型，包装类的null值能展示额外的信息。例如远程调用获取商品价格，如果用包装类，null表示获取失败，0表示价格是0；而如果用基本数据类型，即使获取失败返回值也是0，你就没法知道是价格0还是获取失败了。</li>
</ul>
<p><strong>基本数据类型适用场景</strong>： </p>
<ul>
<li><strong>局部变量尽量使用基本数据类型</strong>：《阿里规约》建议，所有的局部变量使用基本数据类型。因为包装类对象是引用类型，JVM中，基本数据类型存储在方法栈中，引用数据类型存储堆内存实际对象的地址值，如果局部变量定义为引用数据类型还得根据这个地址值去找值，性能差（每次要new），而且耗费空间，毕竟它的作用域只是方法内。</li>
</ul>
<h2 id="包装类和基本数据类型直接如何互相比较？（浮点数等号比较精度丢失问题）"><a href="#包装类和基本数据类型直接如何互相比较？（浮点数等号比较精度丢失问题）" class="headerlink" title="包装类和基本数据类型直接如何互相比较？（浮点数等号比较精度丢失问题）"></a>包装类和基本数据类型直接如何互相比较？（浮点数等号比较精度丢失问题）</h2><p>包装类和基本数据类型：直接通过==比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line"><span class="comment">// true，相等</span></span><br><span class="line">System.out.println(b == integer);</span><br></pre></td></tr></table></figure>

<p><strong>整型</strong>： </p>
<ul>
<li>相同整型包装类必须通过equals()比较。虽然两个通过自动装箱创建的、数值在缓存范围的相同整型包装类可以通过<code>==</code>比较（例如Integer a=1,b=1，则a<code>==</code>b），但《阿里规约》规定整型包装类必须通过equals()比较。包装类和各类型基本类型可以通过<code>==</code>比较。</li>
<li>不同整型包装类必须转成相同类再通过<code>equals()</code>比较。</li>
<li>整型基本数据类型用<code>==</code>比较。</li>
</ul>
<p><strong>浮点型</strong>：</p>
<ul>
<li><p>浮点包装类先都转为<code>BigDecimal</code>，再进行运算、比较。</p>
</li>
<li><p>浮点基本类型直接比较，要声明误差，两浮点数差值在此范围内，认为是相等的。 </p>
</li>
</ul>
<p><strong>浮点数正确比较方法</strong>：</p>
<p><strong>基本数据类型</strong>： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">1e-6f</span>;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(a - b) &lt; diff) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a、b相等&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>包装类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了保证高精度</span></span><br><span class="line"><span class="comment">// BigDecimal推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法</span></span><br><span class="line"><span class="comment">// valueOf方法内部其实执行了Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.9</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x.equals(y)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a、b相等&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Integer-a1-127-Integer-a2-127-a1-a2原因"><a href="#Integer-a1-127-Integer-a2-127-a1-a2原因" class="headerlink" title="Integer a1=127;Integer a2=127;a1==a2原因"></a>Integer a1=127;Integer a2=127;a1==a2原因</h2><p><strong>享元模式</strong>： </p>
<p>Integer 内部有享元模式设计，【-128,127】范围内的数字会被缓存，使用自动装箱方式赋值时，Java默认通过<code>valueOf()</code>方法对127这个数字进行装箱操作，触发缓存机制，使a1和a2指向同一个内存地址。</p>
<ul>
<li>Byte、Short、Integer、Long 缓存区间【-128,127】。</li>
<li>Character 包装类型缓存区间[0,127]。</li>
<li>浮点型和布尔型没用享元模式，没有缓存区间。</li>
</ul>
<hr>
<h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p><code>Arrays</code> 类包含了一系列用于操作数组的静态方法。可以对数组排序、搜索、比较、转换、填充等。以下是 <code>Arrays</code> 类的一些常用方法：</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort(T[] a)：对数组进行升序排序</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Arrays.sort(numbers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort(T[] a, Comparator&lt;? super T&gt; c)： 使用指定的比较器对数组进行排序</span></span><br><span class="line">String[] names = &#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Eve&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(names, Comparator.reverseOrder());</span><br></pre></td></tr></table></figure>

<h2 id="查找和判断"><a href="#查找和判断" class="headerlink" title="查找和判断"></a>查找和判断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binarySearch(T[] a, T key)： 在已排序的数组中使用二分查找算法查找指定元素的索引</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// equals(T[] a, T[] a2)： 比较两个数组是否相等</span></span><br><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> Arrays.equals(arr1, arr2);</span><br></pre></td></tr></table></figure>

<h2 id="批量填充"><a href="#批量填充" class="headerlink" title="批量填充"></a>批量填充</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fill(T[] a, T val)： 使用指定的值填充数组的所有元素</span></span><br><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(numbers, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<h2 id="转换字符串、链表"><a href="#转换字符串、链表" class="headerlink" title="转换字符串、链表"></a>转换字符串、链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toString(T[] a)： 返回包含数组元素的字符串</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">arrayString</span> <span class="operator">=</span> Arrays.toString(numbers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// asList(T... a)： 将数组转换为固定大小的列表</span></span><br><span class="line">String[] names = &#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; nameList = Arrays.asList(names);</span><br></pre></td></tr></table></figure>

<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copyOf(T[] original, int newLength)： 复制指定长度的数组</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] copiedNumbers = Arrays.copyOf(numbers, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h1><p>Date 类是 Java 中用于表示日期和时间的类，位于 java.util 包中。在 Java 8 及之前的版本中，Date 类是主要的日期时间处理类，但在 Java 8 引入了 java.time 包，推荐使用新的日期时间 API（java.time 包中的 LocalDate、LocalTime、LocalDateTime 等类）。尽管如此，我们仍然可以了解 Date 类的基本使用。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><code>getTime()</code>： 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来的毫秒数。<br><code>toString()</code>： 返回日期对象的字符串表示。<br><code>after(Date when)</code>： 判断某个日期是否在指定日期之后<br><code>before(Date when)</code>：判断某个日期是否在指定日期之前<br><code>a.compareTo(b)</code>：对两个日期进行比较 如果a时间在b之后，则返回1 如果a时间在b之前，则返回-1 如果a==b，则返回0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建当前日期和时间的 Date 对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">currentDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">// 输出当前日期和时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Current Date and Time: &quot;</span> + currentDate);</span><br><span class="line">        <span class="comment">// 获取毫秒表示的时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> currentDate.getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;Timestamp: &quot;</span> + timestamp);</span><br><span class="line">        <span class="comment">// 通过时间戳创建 Date 对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">newDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(timestamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;New Date: &quot;</span> + newDate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// Current Date and Time: Tue Jul 22 16:18:49 GMT+08:00 2025</span></span><br><span class="line"><span class="comment">// Timestamp: 1753172329875</span></span><br><span class="line"><span class="comment">// New Date: Tue Jul 22 16:18:49 GMT+08:00 2025</span></span><br></pre></td></tr></table></figure>

<h2 id="Date类的线程安全问题"><a href="#Date类的线程安全问题" class="headerlink" title="Date类的线程安全问题"></a>Date类的线程安全问题</h2><p><strong>Date类的缺点</strong>：</p>
<ul>
<li><p><strong>线程不安全</strong>：Date类可变，在多线程环境中使用时需要额外的同步措施。<strong>解决方案</strong>：</p>
<ul>
<li><strong>使用局部变量</strong>：局部变量不会被多个线程同时访问到。</li>
<li><strong>加锁</strong>：通过synchronized锁或者lock锁，保证线程同步。</li>
<li><strong>ThreadLocal</strong>：<code>ThreadLocal</code> 可确保每个线程都能得到单独的一个 SimpleDateFormat 的对象，自然也就不存在竞争问题了</li>
<li><strong>DateTimeFormatter</strong>：如果是Java8应用，可以使用DateTimeFormatter代替SimpleDateFormat，这是一个线程安全的格式化工具类</li>
</ul>
</li>
<li><p><strong>获取时间不方便</strong>：Date类的年份是从 1900 年开始的，月份从 0 开始。</p>
</li>
<li><p><strong>没时区</strong>：Date类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。</p>
</li>
<li><p><strong>需要格式化</strong>：需要搭配<code>SimpleDateformat</code>类格式化时间，而且SimpleDateformat类也是线程不安全的，如果使用线程安全的DateTimeFormatter类格式化时间，则需要JDK版本在1.8及以上。</p>
</li>
</ul>
<h2 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h2><h3 id="SimpleDateformat类：线程不安全"><a href="#SimpleDateformat类：线程不安全" class="headerlink" title="SimpleDateformat类：线程不安全"></a>SimpleDateformat类：线程不安全</h3><p>SimpleDateformat类用于格式化和解析日期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// throws只是把异常抛出，延迟处理。用trycatch处理比较好</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;    </span><br><span class="line">    <span class="comment">// Date转String</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sdf.format(d);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="comment">// String转Date</span></span><br><span class="line">    d = sdf.parse(str);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>日期格式模式：</p>
<p>SimpleDateFormat 使用一组模式字母来定义日期时间格式。以下是一些常见的模式字母：</p>
<ul>
<li><p>y： 年份（如 “yy” 表示年份的后两位，”yyyy” 表示完整的年份）。</p>
</li>
<li><p>M： 月份（1-12，”MM” 表示两位数字，”MMM” 表示缩写，”MMMM” 表示全名）。</p>
</li>
<li><p>d： 日期（1-31，”dd” 表示两位数字）。</p>
</li>
<li><p>H： 小时（0-23，”HH” 表示两位数字）。</p>
</li>
<li><p>m： 分钟（0-59，”mm” 表示两位数字）。</p>
</li>
<li><p>s： 秒钟（0-59，”ss” 表示两位数字）。</p>
</li>
</ul>
</blockquote>
<h3 id="DateTimeFormatter类：线程安全"><a href="#DateTimeFormatter类：线程安全" class="headerlink" title="DateTimeFormatter类：线程安全"></a>DateTimeFormatter类：线程安全</h3><p>DateTimeFormatter 类是 Java 8 引入的日期时间 API（java.time 包）的一部分，用于格式化和解析日期时间对象。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><p>不可变且线程安全</p>
</li>
<li><p>支持新的日期时间类</p>
</li>
<li><p>适用于 Java 8 及以上版本。</p>
</li>
<li><p>异常处理：在解析字符串时，如果字符串的格式与指定的模式不匹配，会抛出 DateTimeParseException 异常，因此需要异常处理。</p>
</li>
</ul>
<p><strong>常用方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.格式化日期时间：format(TemporalAccessor temporal)： 格式化指定的日期时间对象。</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDateTime</span> <span class="operator">=</span> formatter.format(dateTime);</span><br><span class="line"><span class="comment">// 2.解析字符串为日期时间：parse(CharSequence text)： 解析输入的文本，返回一个解析后的日期时间对象。</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateString</span> <span class="operator">=</span> <span class="string">&quot;2023-12-01 15:30:00&quot;</span>;</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">parsedDateTime</span> <span class="operator">=</span> formatter.parse(dateString, LocalDateTime::from);</span><br><span class="line"><span class="comment">// 3.获取格式化/解析模式：toString()： 获取当前格式化/解析器的模式字符串。</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> formatter.toString(); <span class="comment">// 返回 &quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line"><span class="comment">// 4.将当前时间格式化为字符串</span></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 DateTimeFormatter 对象，指定日期时间格式模式</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取当前日期时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">currentDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 格式化日期时间为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedDateTime</span> <span class="operator">=</span> currentDateTime.format(formatter);</span><br><span class="line">        System.out.println(<span class="string">&quot;Formatted Date and Time: &quot;</span> + formattedDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><p>Math 类是数学工具类，提供了一系列用于执行基本数学运算的静态方法。</p>
<p><strong>基本使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 基本数学运算</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">absoluteValue</span> <span class="operator">=</span> Math.abs(-<span class="number">5.5</span>);  <span class="comment">// 返回绝对值，结果为 5.5</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">ceilValue</span> <span class="operator">=</span> Math.ceil(<span class="number">4.3</span>);      <span class="comment">// 返回不小于参数的最小整数值，结果为 5.0</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">floorValue</span> <span class="operator">=</span> Math.floor(<span class="number">4.9</span>);    <span class="comment">// 返回不大于参数的最大整数值，结果为 4.0</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">maxValue</span> <span class="operator">=</span> Math.max(<span class="number">10.2</span>, <span class="number">5.8</span>);   <span class="comment">// 返回两个参数中的最大值，结果为 10.2</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">minValue</span> <span class="operator">=</span> Math.min(<span class="number">3.5</span>, <span class="number">7.1</span>);    <span class="comment">// 返回两个参数中的最小值，结果为 3.5</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">roundValue</span> <span class="operator">=</span> Math.round(<span class="number">3.8</span>);       <span class="comment">// 返回最接近参数的整数值，四舍五入，结果为 4</span></span><br><span class="line">        <span class="comment">// 指数运算</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">expValue</span> <span class="operator">=</span> Math.exp(<span class="number">2.0</span>);         <span class="comment">// 返回 e 的指数值，结果为 7.3890560989306495</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">logValue</span> <span class="operator">=</span> Math.log(<span class="number">10.0</span>);        <span class="comment">// 返回以 e 为底的对数值，结果为 2.302585092994046</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">powValue</span> <span class="operator">=</span> Math.pow(<span class="number">2.0</span>, <span class="number">3.0</span>);    <span class="comment">// 返回 2 的 3 次方，结果为 8.0</span></span><br><span class="line">        <span class="comment">// 平方根和立方根</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">sqrtValue</span> <span class="operator">=</span> Math.sqrt(<span class="number">25.0</span>);      <span class="comment">// 返回参数的平方根，结果为 5.0</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">cbrtValue</span> <span class="operator">=</span> Math.cbrt(<span class="number">27.0</span>);      <span class="comment">// 返回参数的立方根，结果为 3.0</span></span><br><span class="line">        <span class="comment">// 三角函数</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">sinValue</span> <span class="operator">=</span> Math.sin(Math.PI / <span class="number">6</span>);     <span class="comment">// 返回参数的正弦值，结果为 0.5</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">cosValue</span> <span class="operator">=</span> Math.cos(Math.PI / <span class="number">3</span>);     <span class="comment">// 返回参数的余弦值，结果为 0.5</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">tanValue</span> <span class="operator">=</span> Math.tan(Math.PI / <span class="number">4</span>);     <span class="comment">// 返回参数的正切值，结果为 1.0</span></span><br><span class="line">        <span class="comment">// 角度和弧度转换</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">degreesValue</span> <span class="operator">=</span> Math.toDegrees(Math.PI / <span class="number">2</span>);  <span class="comment">// 将弧度转换为角度，结果为 90.0</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">radiansValue</span> <span class="operator">=</span> Math.toRadians(<span class="number">180.0</span>);        <span class="comment">// 将角度转换为弧度，结果为 π</span></span><br><span class="line">        <span class="comment">// 随机数生成</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">randomValue</span> <span class="operator">=</span> Math.random();  <span class="comment">// 返回一个大于等于 0.0 且小于 1.0 的随机浮点数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h1><h2 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>java.util.Random类：</strong>主要用于生成伪随机数。</p>
<p><strong>伪随机：</strong>Random类产生的数字是伪随机的，在相同种子数（seed）下的相同次数产生的随机数是相同的。</p>
<h2 id="代码示例-不指定种子"><a href="#代码示例-不指定种子" class="headerlink" title="代码示例 不指定种子"></a>代码示例 不指定种子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Random 对象</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成 0 到 10（不包括10）之间的随机整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//生成 -1 到 10（不包括10）之间的随机整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>) - <span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;生成 0 到 10（不包括10）之间的随机整数：&quot;</span>+num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机浮点数：生成一个介于 0（包含）和 1（不包含）之间的浮点数</span></span><br><span class="line"><span class="type">double</span> <span class="variable">randomDouble</span> <span class="operator">=</span> random.nextDouble();</span><br><span class="line">System.out.println(<span class="string">&quot;Random Double: &quot;</span> + randomDouble);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机布尔值</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">randomBoolean</span> <span class="operator">=</span> random.nextBoolean();</span><br><span class="line">System.out.println(<span class="string">&quot;Random Boolean: &quot;</span> + randomBoolean);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机字节数组</span></span><br><span class="line"><span class="type">byte</span>[] randomBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">random.nextBytes(randomBytes);</span><br><span class="line">System.out.println(<span class="string">&quot;Random Bytes: &quot;</span> + Arrays.toString(randomBytes));</span><br></pre></td></tr></table></figure>

<h2 id="代码示例-指定种子"><a href="#代码示例-指定种子" class="headerlink" title="代码示例 指定种子"></a>代码示例 指定种子</h2><blockquote>
<p>相同种子数（seed）下的相同次数，产生的随机数是相同的。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定种子为42</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">randomWithSeed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(seed);</span><br><span class="line">        <span class="comment">// 生成随机整数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNumber1</span> <span class="operator">=</span> randomWithSeed.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Random Number 1: &quot;</span> + randomNumber1);</span><br><span class="line">        <span class="comment">// 再次生成随机整数，因为种子相同，结果应该相同</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNumber2</span> <span class="operator">=</span> randomWithSeed.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Random Number 2: &quot;</span> + randomNumber2);</span><br><span class="line">        <span class="comment">// 创建另一个 Random 对象，没有指定种子</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">randomWithoutSeed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">// 生成随机整数，因为没有指定种子，结果不受前面的影响</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNumber3</span> <span class="operator">=</span> randomWithoutSeed.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Random Number 3: &quot;</span> + randomNumber3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://southernfish.github.io">Southern Fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://southernfish.github.io/pages/java/java-base-2-class/">https://southernfish.github.io/pages/java/java-base-2-class/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://southernfish.github.io" target="_blank">Southern Fish</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></div><div class="post_share"><div class="social-share" data-image="/img/article/article5.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/pages/java/java-base-3-oop/"><img class="prev-cover" src="/img/article/article2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面向对象编程（OOP）</div></div></a></div><div class="next-post pull-right"><a href="/pages/java/java-base-1-conception/"><img class="next-cover" src="/img/article/article4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java基本概念和语法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/pages/java/java-jvm/" title="JVM"><img class="cover" src="/img/article/article2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-20</div><div class="title">JVM</div></div></a></div><div><a href="/pages/java/java-network/" title="网络编程"><img class="cover" src="/img/article/article2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="title">网络编程</div></div></a></div><div><a href="/pages/java/java-object-copy/" title="对象克隆"><img class="cover" src="/img/article/article4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="title">对象克隆</div></div></a></div><div><a href="/pages/java/java-web/" title="Java Web"><img class="cover" src="/img/article/article1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="title">Java Web</div></div></a></div><div><a href="/pages/java/java-encription/" title="java的加密方式"><img class="cover" src="/img/article/article5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-24</div><div class="title">java的加密方式</div></div></a></div><div><a href="/pages/java/java-base-4-exceptions/" title="JAVA 异常"><img class="cover" src="/img/article/article5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-23</div><div class="title">JAVA 异常</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southern Fish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">98</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SouthernFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1002721576@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">天下事岂能尽如吾意，心境须恰适，尽其在我，随遇而安。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.3.</span> <span class="toc-text">连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E4%B8%B2"><span class="toc-number">1.2.4.</span> <span class="toc-text">子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">1.2.5.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.2.6.</span> <span class="toc-text">替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%95%BF%E5%BA%A6"><span class="toc-number">1.2.7.</span> <span class="toc-text">获取长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.8.</span> <span class="toc-text">比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Eequals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.9.</span> <span class="toc-text">&#x3D;&#x3D;与equals()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2"><span class="toc-number">1.2.10.</span> <span class="toc-text">分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="toc-number">1.2.11.</span> <span class="toc-text">转换大小写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.12.</span> <span class="toc-text">字符串和数字的互相转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.13.</span> <span class="toc-text">数组和字符串的互相转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E5%AD%97%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.14.</span> <span class="toc-text">格式化数字为字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">1.3.</span> <span class="toc-text">知识加油站</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.1.</span> <span class="toc-text">字符串和字符数组的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.3.2.</span> <span class="toc-text">字符串常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E4%B8%8D%E5%8F%AF%E8%A2%AB%E7%BB%A7%E6%89%BF%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.3.3.</span> <span class="toc-text">String不可被继承、不可变的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-String-%E2%80%9Cabc%E2%80%9D-%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%87%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">new String(“abc”)创建的字符串对象数量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StringBuilder-%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">StringBuilder 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">2.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81Stringbuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">String、StringBuffer、Stringbuilder的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Scanner%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">Scanner类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">JVM垃圾回收的可达性分析算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashCode-%E5%92%8Cequals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">hashCode()和equals()的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#System%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">System类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Integer%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">Integer类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">6.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="toc-number">6.2.</span> <span class="toc-text">包装类的自动拆装箱与自动装箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">什么情况下用包装类？什么情况下用基本数据类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9B%B4%E6%8E%A5%E5%A6%82%E4%BD%95%E4%BA%92%E7%9B%B8%E6%AF%94%E8%BE%83%EF%BC%9F%EF%BC%88%E6%B5%AE%E7%82%B9%E6%95%B0%E7%AD%89%E5%8F%B7%E6%AF%94%E8%BE%83%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">包装类和基本数据类型直接如何互相比较？（浮点数等号比较精度丢失问题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer-a1-127-Integer-a2-127-a1-a2%E5%8E%9F%E5%9B%A0"><span class="toc-number">6.5.</span> <span class="toc-text">Integer a1&#x3D;127;Integer a2&#x3D;127;a1&#x3D;&#x3D;a2原因</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">Arrays类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%92%8C%E5%88%A4%E6%96%AD"><span class="toc-number">7.2.</span> <span class="toc-text">查找和判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E5%A1%AB%E5%85%85"><span class="toc-number">7.3.</span> <span class="toc-text">批量填充</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">7.4.</span> <span class="toc-text">转换字符串、链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D"><span class="toc-number">7.5.</span> <span class="toc-text">拷贝</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Date%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">Date类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date%E7%B1%BB%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.</span> <span class="toc-text">Date类的线程安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F"><span class="toc-number">8.3.</span> <span class="toc-text">格式化日期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SimpleDateformat%E7%B1%BB%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">8.3.1.</span> <span class="toc-text">SimpleDateformat类：线程不安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DateTimeFormatter%E7%B1%BB%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">8.3.2.</span> <span class="toc-text">DateTimeFormatter类：线程安全</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Math%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">Math类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Random"><span class="toc-number">10.</span> <span class="toc-text">Random</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">10.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%A7%8D%E5%AD%90"><span class="toc-number">10.2.</span> <span class="toc-text">代码示例 不指定种子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-%E6%8C%87%E5%AE%9A%E7%A7%8D%E5%AD%90"><span class="toc-number">10.3.</span> <span class="toc-text">代码示例 指定种子</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/pages/high-availability/server-limit-stream/" title="服务限流"><img src="/img/article/article1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="服务限流"/></a><div class="content"><a class="title" href="/pages/high-availability/server-limit-stream/" title="服务限流">服务限流</a><time datetime="2025-09-18T09:02:36.000Z" title="发表于 2025-09-18 17:02:36">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/db-redis-persistence/" title="Redis的持久化机制"><img src="/img/article/article6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis的持久化机制"/></a><div class="content"><a class="title" href="/pages/database/db-redis-persistence/" title="Redis的持久化机制">Redis的持久化机制</a><time datetime="2025-09-18T01:15:36.000Z" title="发表于 2025-09-18 09:15:36">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/cache-read-write-strategies/" title="三大缓存读写策略"><img src="/img/article/article6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="三大缓存读写策略"/></a><div class="content"><a class="title" href="/pages/database/cache-read-write-strategies/" title="三大缓存读写策略">三大缓存读写策略</a><time datetime="2025-09-17T13:15:36.000Z" title="发表于 2025-09-17 21:15:36">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/db-redis-consistency/" title="Redis缓存与数据库的一致性"><img src="/img/article/article2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis缓存与数据库的一致性"/></a><div class="content"><a class="title" href="/pages/database/db-redis-consistency/" title="Redis缓存与数据库的一致性">Redis缓存与数据库的一致性</a><time datetime="2025-09-17T13:15:36.000Z" title="发表于 2025-09-17 21:15:36">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/db-redis-produce-problem/" title="Redis的缓存穿透、缓存击穿、缓存雪崩"><img src="/img/article/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis的缓存穿透、缓存击穿、缓存雪崩"/></a><div class="content"><a class="title" href="/pages/database/db-redis-produce-problem/" title="Redis的缓存穿透、缓存击穿、缓存雪崩">Redis的缓存穿透、缓存击穿、缓存雪崩</a><time datetime="2025-09-17T13:15:36.000Z" title="发表于 2025-09-17 21:15:36">2025-09-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/article/article5.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Southern Fish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>