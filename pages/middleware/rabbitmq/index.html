<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>RabbitMQ | Southern Fish</title><meta name="keywords" content="RabbitMQ"><meta name="author" content="Southern Fish"><meta name="copyright" content="Southern Fish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而集群和故障转移是构建在开放电信平台框架上的，支持高并发处理和分布式部署。所有主要的编程语言均有与代理接口通讯的客户端库。RabbitMQ本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，更适合于企业级的开发。它还实现了Broker架构，核">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ">
<meta property="og:url" content="https://southernfish.github.io/pages/middleware/rabbitmq/index.html">
<meta property="og:site_name" content="Southern Fish">
<meta property="og:description" content="RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而集群和故障转移是构建在开放电信平台框架上的，支持高并发处理和分布式部署。所有主要的编程语言均有与代理接口通讯的客户端库。RabbitMQ本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，更适合于企业级的开发。它还实现了Broker架构，核">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://southernfish.github.io/img/article/article1.png">
<meta property="article:published_time" content="2025-07-29T08:15:36.000Z">
<meta property="article:modified_time" content="2025-09-19T03:17:16.880Z">
<meta property="article:author" content="Southern Fish">
<meta property="article:tag" content="RabbitMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://southernfish.github.io/img/article/article1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://southernfish.github.io/pages/middleware/rabbitmq/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RabbitMQ',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-19 11:17:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Southern Fish" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/article/article1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Southern Fish</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RabbitMQ</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-29T08:15:36.000Z" title="发表于 2025-07-29 16:15:36">2025-07-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-19T03:17:16.880Z" title="更新于 2025-09-19 11:17:16">2025-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Middleware/">Middleware</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Middleware/MQ/">MQ</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RabbitMQ"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>RabbitMQ</strong>是实现了高级<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4751675?fromModule=lemma_inlink">消息队列</a>协议（<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/AMQP/8354716?fromModule=lemma_inlink">AMQP</a>）的开源消息代理软件（亦称面向消息的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240?fromModule=lemma_inlink">中间件</a>）。RabbitMQ服务器是用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Erlang/0?fromModule=lemma_inlink">Erlang</a>语言编写的，而集群和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/14768924?fromModule=lemma_inlink">故障转移</a>是构建在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0/15696499?fromModule=lemma_inlink">开放电信平台</a>框架上的，支持高并发处理和分布式部署。所有主要的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131?fromModule=lemma_inlink">编程语言</a>均有与代理接口通讯的客户端库。RabbitMQ本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，更适合于企业级的开发。它还实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队，通过队列机制实现应用程序间的异步通信与数据传输，常用于流量削峰、系统解耦及异步处理场景。对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。多用于进行企业级的ESB整合。</p>
<blockquote>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qidaii/articles/17282475.html">RabbitMQ</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_64940494/article/details/126134203">RabbitMQ安装Erlang安装 windows</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42262444/article/details/121701485">【超级详细】RabbitMQ安装教程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42262444/article/details/121854422">【详细步骤】Springboot整合RabbitMQ</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011488477/article/details/146038326">4.RabbitMQ工作模型</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011488477/article/details/146038909">6.RabbitMQ死信队列</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011488477/article/details/146042812">10.RabbitMQ集群</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CYK_byte/article/details/133135103">RabbitMQ 集群 - 普通集群、镜像集群、仲裁队列</a></p>
</blockquote>
<h1 id="RabbitMQ-介绍"><a href="#RabbitMQ-介绍" class="headerlink" title="RabbitMQ 介绍"></a>RabbitMQ 介绍</h1><p>2007 年发布，是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。<br>RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue 高级消息队列协议 ）的开源实现，由于erlang 语言的高并发特性，性能较好，本质是个队列，FIFO 先入先出，里面存放的内容是message<br>RabbitMQ 是一个消息中间件：它接收消息并且转发，就类似于一个快递站，卖家把快递通过快递站，送到我们的手上，MQ也是这样，接收并存储消息，再转发。</p>
<h2 id="RabbitMQ的特点"><a href="#RabbitMQ的特点" class="headerlink" title="RabbitMQ的特点"></a>RabbitMQ的特点</h2><p>AMQP：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言灯条件的限制。</p>
<ul>
<li><code>可靠性(Reliablity)：</code>使用了一些机制来保证可靠性，比如持久化、传输确认、发布确认。</li>
<li><code>灵活的路由(Flexible Routing)：</code>在消息进入队列之前，通过Exchange来路由消息。对于典型的路由功能，Rabbit已经提供了一些内置的Exchange来实现。针对更复杂的路由功能，可以将多个Exchange绑定在一起，也通过插件机制实现自己的Exchange。</li>
<li><code>消息集群(Clustering)：</code>多个RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li>
<li><code>高可用(Highly Avaliable Queues)</code>：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li>
<li><code>多种协议(Multi-protocol)：</code>支持多种消息队列协议，如STOMP、MQTT等。</li>
<li><code>多种语言客户端(Many Clients)：</code>几乎支持所有常用语言，比如Java、.NET、Ruby等。</li>
<li><code>管理界面(Management UI)</code>：提供了易用的用户界面，使得用户可以监控和管理消息Broker的许多方面。</li>
<li><code>跟踪机制(Tracing)</code>：如果消息异常，RabbitMQ提供了消息的跟踪机制，使用者可以找出发生了什么。</li>
<li><code>插件机制(Plugin System)</code>：提供了许多插件，来从多方面进行扩展，也可以编辑自己的插件。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>抢购活动，削峰填谷，防止系统崩塌</strong>。<br><strong>延迟信息处理</strong>，比如 10 分钟之后给下单未付款的用户<strong>发送邮件提醒</strong>。<br><strong>解耦系统</strong>，对于<strong>新增的功能可以单独写模块扩展</strong>，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p>
<h3 id="流量消峰"><a href="#流量消峰" class="headerlink" title="流量消峰"></a>流量消峰</h3><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但比不能下单的体验要好。<br>简单来说： 就是在访问量剧增的情况下，但是应用仍然不能停，比如“双十一”下单的人多，但淘宝这个应用仍然要运行，所以就可以使用消息中间件采用队列的形式减少突然访问的压力</p>
<h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中间用户感受不到物流系统的故障，提升系统的可用性。</p>
<p>如图，把支付，库存，物流都交给MQ</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729152629973.png" alt="image-20250729152629973"></p>
<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。<br><strong>这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题</strong>，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729153106900.png" alt="image-20250729153106900"></p>
<ul>
<li><p>同步是阻塞的(会造成等待)</p>
<p>采用同步方式，用户从注册到响应成功，需要先保存注册信息，再发送邮件通知，邮件发送成功后再发送短信通知，短信发送成功后才通知用户成功，用户体验不好</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729191446438.png" alt="image-20250729191446438"></p>
</li>
<li><p>异步是非阻塞的(不会等待)</p>
<p>采用异步方式，保存用户信息后，短信通知和邮件通知消息写入MQ(耗时极短)，极大的缩短了响应时间</p>
</li>
</ul>
<p>大流量高并发请求、批量数据传递,就可以采用异步处理,提升系统吞吐量；</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729191621315.png" alt="image-20250729191621315"></p>
<h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><p>主要是用kafka这个服务器来做；日志处理是指将消息队列用于在日志处理中</p>
<ul>
<li><p>Kafka解决大量日志传输的问题</p>
</li>
<li><p>loger.info(…)</p>
</li>
<li><p>ELK 日志处理解决方案</p>
</li>
</ul>
<p>loger.error(…)  → logstash收集消息 → 发送消息的kafka → elastic search(es) → Kibana ELK日志处理平台</p>
<h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><h3 id="RabbitMQ-的重要角色"><a href="#RabbitMQ-的重要角色" class="headerlink" title="RabbitMQ 的重要角色"></a>RabbitMQ 的重要角色</h3><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p>
<ul>
<li><strong>生产者：</strong>消息的创建者，负责<strong>创建和推送数据</strong>到消息服务器；</li>
<li><strong>消费者：</strong>消息的接收方，用于<strong>处理数据和确认消息</strong>；</li>
<li><strong>代理(broker)：</strong>就是 <strong><code>RabbitMQ</code> 本身</strong>，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li>
</ul>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>产生数据发送消息的程序是生产者</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个由交换机类型决定。交换机类型：</p>
<ol>
<li><code>direct Exchange</code>(直接交换机)：匹配路由键，只有完全匹配消息才会被转发</li>
<li><code>Fanout Excange</code>(扇出交换机)：将消息发送至所有的队列</li>
<li><code>Topic Exchange</code>(主题交换机)：将路由按模式匹配，此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.” 只会匹配到“abc.def”。</li>
<li><code>Header Exchange</code>：在绑定Exchange和Queue的时候指定一组键值对，header为键，根据请求消息中携带的header进行路由</li>
</ol>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。</p>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729153839738.png" alt="image-20250729153839738"></p>
<h3 id="RabbitMQ-的重要组件"><a href="#RabbitMQ-的重要组件" class="headerlink" title="RabbitMQ 的重要组件"></a>RabbitMQ 的重要组件</h3><ol>
<li><p><code>Producer</code>（生产者）：发送消息的应用；它将消息发送到 RabbitMQ 的交换器中</p>
</li>
<li><p><code>Consumer</code>（消费者）消费者是消息的接收方,它从 RabbitMQ 的队列中获取消息并进行处理</p>
</li>
<li><p><code>Broker</code>：标识消息队列服务器实体。接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p>
<ul>
<li><p>Broker = VHost1+Vhost2+Vhost3+…</p>
</li>
<li><p>Virtual Host = Exchange + Queue +Binding</p>
</li>
</ul>
</li>
<li><p><code>Message</code>（消息）：消息是不具名的，它是由消息头和消息体组成。消息体是不透明的，而消息头则是由一系列的可选属性组成。消息可以是任何数据(字符串、user对象，json串等)</p>
<ul>
<li><p>消息=消息头+消息体，根据routekey发送到指定的交换机 Exchange</p>
</li>
<li><p>消息头：含各种属性 routing-key(路由键)、priority(优先级)、delivery-mode(指出该消息可能需要持久性存储[路由模式])等。</p>
</li>
</ul>
</li>
<li><p><code>Connection</code>（网络连接）：publisher／consumer 和 broker 之间的 TCP 连接。</p>
<p>断开连接的操作只会在client端进行，Broker不会断开连接，除非出现网络故障或broker服务出现问题。</p>
</li>
<li><p><code>ConnectionFactory</code>（连接管理器）：<strong>应用程序与Rabbit之间建立连接的管理器</strong>，程序代码中使用。</p>
</li>
<li><p><code>Channel</code>（信道）：<strong>消息推送使用的通道</strong>，是多路复用连接中的一条独立的双向数据流通道。</p>
<ul>
<li>如果每次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。</li>
<li>Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，</li>
<li>AMQP method 包含了 channel id 帮助客户端和 message broker 识channel，所以 channel 之间是完全隔离的。</li>
<li>Channel 作为轻量级的Connection 极大减少了操作系统建立 TCP connection 的开销。</li>
</ul>
</li>
<li><p><code>Virtual host</code>（虚拟主机）：逻辑分组机制，类似nacos中的命名空间的概念(在代码中就是一个字符串)。出于多租户和安全因素设计，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同用户使用同一个RabbitMQ server提供的服务时，可划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等。</p>
<ul>
<li>Virtual 即 VHost</li>
<li>默认目录 /</li>
</ul>
</li>
<li><p><code>vHost</code>（虚拟主机）：每个 RabbitMQ 都能创建很多 <code>vhost</code>，每个虚拟主机其实都是 <strong>mini 版的RabbitMQ</strong>，它拥有自己的 “交换机exchange、绑定Binding、队列Queue”，更重要的是每一个vhost拥有独立的权限机制，这样就能安全地使用一个RabbitMQ服务器来服务多个应用程序，其中每个vhost服务一个应用程序。</p>
</li>
<li><p><code>Exchange</code>（交换机）：用于<strong>接受、分配消息</strong>。message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：<code>direct (point-to-point)</code>, <code>topic (publish-subscribe)</code> and <code>fanout (multicast)</code>。</p>
</li>
<li><p><code>Routing Key</code>（路由键）：用于把生成者的数据<strong>分配到交换器</strong>上。生产者将消息发送到交换机时会携带一个key，来指定路由规则。</p>
</li>
<li><p><code>Binding</code>（绑定）：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。在绑定Exchange和Queue时，会指定一个BindingKey，生产者发送消息携带的RoutingKey会和bindingKey对比，若一致就将消息分发至这个队列。</p>
</li>
<li><p><code>BindingKey</code>（绑定键）用于<strong>把交换器的消息绑定到队列</strong>上。</p>
</li>
<li><p><code>Queue</code>（队列）：用于<strong>存储</strong>生产者的消息。消息最终被送到这里等待 consumer 取走。一个message可被同时拷贝到多个queue。</p>
</li>
</ol>
<h3 id="RabbitMQ-的消息是怎么发送的"><a href="#RabbitMQ-的消息是怎么发送的" class="headerlink" title="RabbitMQ 的消息是怎么发送的"></a>RabbitMQ 的消息是怎么发送的</h3><p>首先客户端必须<strong>连接到 <code>RabbitMQ</code> 服务器</strong>才能发布和消费消息，<strong>客户端和 <code>rabbit server</code> 之间会创建一个 <code>tcp 连接</code><strong>，一旦 <strong><code>tcp</code> 打开并通过了认证</strong>（认证就是你发送给 rabbit 服务器的用户名和密码），你的</strong>客户端和 <code>RabbitMQ</code> 就创建了一条 <code>amqp 信道</code>（channel）</strong>，信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p>
<h2 id="工作模式（七种）"><a href="#工作模式（七种）" class="headerlink" title="工作模式（七种）"></a>工作模式（七种）</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180401408.png" alt="image-20250729180401408"></p>
<h3 id="simple-简单模式"><a href="#simple-简单模式" class="headerlink" title="simple (简单模式)"></a>simple (简单模式)</h3><p>一个消费者消费一个生产者生产的信息，消息只能被消费⼀次<br>RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。<br>RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。</p>
<h3 id="Work-queues-工作模式"><a href="#Work-queues-工作模式" class="headerlink" title="Work queues(工作模式)"></a>Work queues(工作模式)</h3><p>或者竞争消费者模式。工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多工人时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。<br><strong>总之</strong>：让多个消费者绑定到一个队列，共同消费队列中的消息。队列中的消息一旦消费，就会消失，消息不会重复分配给不同的消费者。</p>
<p><strong>适⽤场景</strong>：集群环境中做异步处理</p>
<h3 id="Publish-Subscribe（发布订阅模式）"><a href="#Publish-Subscribe（发布订阅模式）" class="headerlink" title="Publish/Subscribe（发布订阅模式）"></a>Publish/Subscribe（发布订阅模式）</h3><p>生产者首先投递消息到交换机，订阅了这个交换机的队列就会收到生产者投递的消息</p>
<p><strong>特点</strong>：</p>
<ul>
<li><p>Exchange(交换机)</p>
<p>只负责转发消息，不具备存储消息的能力，因此若没有任何队列与Exchange绑定，或者没有符合路由规则的队列，消息就会丢失</p>
</li>
<li><p>RoutingKey(路由键)</p>
<p>⽣产者将消息发给交换器时，指定的⼀个字符串，⽤来告诉交换机应该如何处理这个消息</p>
</li>
<li><p>Binding Key(绑定)</p>
<p>RabbitMQ中通过Binding(绑定)将交换器与队列关联起来，在绑定的时候⼀般会指定⼀个Binding Key，这样RabbitMQ就知道如何正确地将消息路由到队列了</p>
</li>
</ul>
<p><strong>适合场景</strong>：消息需要被多个消费者同时接收的场景(如: 实时通知或者⼴播消息)</p>
<h3 id="Routing（路由模式）"><a href="#Routing（路由模式）" class="headerlink" title="Routing（路由模式）"></a>Routing（路由模式）</h3><p>生产者生产消息投递到direct交换机中，扇出交换机会根据消息携带的routing Key匹配相应的队列</p>
<p>路由模式是发布订阅模式的变种，在发布订阅基础上，增加路由key。Exchange根据RoutingKey的规则，将数据筛选后发给对应的消费者队列。</p>
<p><strong>适合场景</strong>：需要根据特定规则分发消息的场景</p>
<p>比如系统打印日志(⽇志等级分为error, warning, info,debug)就可以通过该模式把不同⽇志发送到不同的队列, 最终输出到不同的⽂件</p>
<h3 id="Topics（主题模式）"><a href="#Topics（主题模式）" class="headerlink" title="Topics（主题模式）"></a>Topics（主题模式）</h3><p>生产者生产消息投递到topic交换机中，上面是完全匹配路由键，而主题模式是模糊匹配，只要有合适规则的路由就会投递给消费者。</p>
<p>路由模式的升级版，在routingKey的基础上，增加了通配符的功能，使之更加灵活。也称<strong>通配符模式</strong>。</p>
<p>Topics和Routing的基本原理相同，即⽣产者将消息发给交换机，交换机根据RoutingKey将消息转发给与RoutingKey匹配的队列，类似于正则表达式的⽅式来定义Routingkey的模式</p>
<p><strong>适合场景</strong>：需要灵活匹配和过滤消息的场景。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729160102405.png" alt="image-20250729160102405"></p>
<h3 id="RPC模式"><a href="#RPC模式" class="headerlink" title="RPC模式"></a>RPC模式</h3><p>在RPC通信的过程中, 没有⽣产者和消费者, ⽐较像咱们RPC远程调⽤, ⼤概就是通过两个队列实现了⼀个可回调的过程。</p>
<ul>
<li><p><strong>客户端：</strong></p>
<ol>
<li><p>发送请求（携带replyTo，correlationId）</p>
</li>
<li><p>接收响应（验证correlationId）</p>
</li>
</ol>
</li>
<li><p><strong>服务器：</strong></p>
<ol>
<li><p>接收请求 进行响应</p>
</li>
<li><p>发送响应（按客户端指定的replyTo，设置correlationId）</p>
</li>
</ol>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729194101402.png" alt="image-20250729194101402"></p>
<h3 id="发布确认模式"><a href="#发布确认模式" class="headerlink" title="发布确认模式"></a>发布确认模式</h3><p>消息丢失其中一种情况是⽣产者问题：因为应⽤程序故障、⽹络抖动等各种原因, ⽣产者没有成功向broker发送消息，可以采⽤发布确认(Publisher Confirms)机制实现。发送方确认机制好处在于它是异步的，⽣产者可以同时发布消息和等待信道返回确认消息。当消息最终得到确认之后，⽣产者可以通过回调⽅法来处理该确认消息。<br>如果RabbitMQ因自身内部错误导致消息丢失，就会发送⼀条nack(Basic.Nack)命令，⽣产者同样<strong>可以在回调方法中处理该nack命令</strong>使用发送确认机制必须要信道设置成confirm(确认)模式。发布确认有<strong>3种策略</strong>：</p>
<ul>
<li><p>单独确认</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Individually</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(Constants.HOST);</span><br><span class="line">        connectionFactory.setPort(Constants.PORT);                     <span class="comment">// 需要提前开放端口号</span></span><br><span class="line">        connectionFactory.setUsername(Constants.USER_NAME);            <span class="comment">// 账号</span></span><br><span class="line">        connectionFactory.setPassword(Constants.PASSWORD);          <span class="comment">// 密码</span></span><br><span class="line">        connectionFactory.setVirtualHost(Constants.VIRTUAL_HOST);     <span class="comment">// 虚拟主机</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">// 1.开启信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 2. 设置信道为confirm模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">// 3.声明队列</span></span><br><span class="line">        channel.queueDeclare(Constants.PUBLISHER_CONFIRMS_QUEUE1, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 4.发送消息，并等待确认</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Constants.MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello publisher confirms&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, Constants.PUBLISHER_CONFIRMS_QUEUE1, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">            <span class="comment">// 等待确认</span></span><br><span class="line">            channel.waitForConfirmsOrDie(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.printf(<span class="string">&quot;单独确认策略, 消息条数: %d, 耗时: %d ms \n&quot;</span>, </span><br><span class="line">                          Constants.MESSAGE_COUNT, end - start);</span><br><span class="line">        <span class="comment">// 5.关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>批量确认</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Batches</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 发送消息, 并进行确认</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">outstandingMessageCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Constants.MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello publisher confirms&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, Constants.PUBLISHER_CONFIRMS_QUEUE2, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">            outstandingMessageCount++;</span><br><span class="line">            <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">                channel.waitForConfirmsOrDie(<span class="number">5000</span>);</span><br><span class="line">                outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            channel.waitForConfirmsOrDie(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>异步确认</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Asynchronously</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 4. 监听confirm</span></span><br><span class="line">        <span class="comment">// 集合中存储的是未确认的消息ID</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        SortedSet&lt;Long&gt; confirmSeqNo = Collections.synchronizedSortedSet(<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;());</span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> <span class="title class_">ConfirmListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                    confirmSeqNo.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    confirmSeqNo.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                    confirmSeqNo.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    confirmSeqNo.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 业务需要根据实际场景进行处理, 比如重发, 此处代码省略</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Constants.MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello publisher confirms&quot;</span> + i;</span><br><span class="line">            <span class="type">long</span> <span class="variable">seqNo</span> <span class="operator">=</span> channel.getNextPublishSeqNo();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, Constants.PUBLISHER_CONFIRMS_QUEUE3, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">            confirmSeqNo.add(seqNo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!confirmSeqNo.isEmpty()) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="RabbitMQ-保证消息的稳定性"><a href="#RabbitMQ-保证消息的稳定性" class="headerlink" title="RabbitMQ 保证消息的稳定性"></a>RabbitMQ 保证消息的稳定性</h1><p>提供了<strong>事务</strong>的功能。通过<strong>将 <code>channel</code> 设置为 <code>confirm</code>（确认）模式</strong>。</p>
<p><strong>RabbitMQ 怎么避免消息丢失</strong></p>
<ul>
<li><strong>把消息持久化磁盘</strong>，保证服务器重启消息不丢失。</li>
<li><strong>每个集群中至少有一个物理磁盘，保证消息落入磁盘</strong>。</li>
</ul>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>RabbitMQ的消息默认存在内存中的，一旦服务器意外挂掉，消息就会丢失。消息持久化需做到三点：</p>
<blockquote>
<p>1.Exchange设置持久化：消息<strong>已经到达持久化交换器</strong>。<br>2.Queue设置持久化：<strong>声明队列</strong>必须<strong>设置持久化 <code>durable</code> 设置为 <code>true</code><strong>。消息</strong>已经到达持久化队列</strong>。<br>3.Message持久化发送：发送消息设置发送模式deliveryMode=2，代表持久化消息</p>
</blockquote>
<p><strong>RabbitMQ 持久化的缺点</strong></p>
<p><strong>降低了服务器的吞吐量</strong>，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可**尽量使用 <code>ssd 硬盘</code>**来缓解吞吐量的问题。</p>
<h2 id="ACK确认机制"><a href="#ACK确认机制" class="headerlink" title="ACK确认机制"></a>ACK确认机制</h2><p>多个消费者同时收取消息，收取消息到一半，突然某个消费者挂掉，要保证此条消息不丢失，就需要<code>acknowledgement</code>机制，就是消费者消费完成要通知服务端，服务端才将数据删除</p>
<p>这样就解决了，即使一个消费者出了问题，没有同步消息给服务端，还有其他的消费端去消费，保证了消息不丢的case。</p>
<h2 id="设置集群镜像模式"><a href="#设置集群镜像模式" class="headerlink" title="设置集群镜像模式"></a>设置集群镜像模式</h2><p>我们先来介绍下RabbitMQ三种部署模式：</p>
<blockquote>
<p>1.单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。</p>
<p>2.普通模式：默认的集群模式，某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。</p>
<p>3.镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案</p>
</blockquote>
<p>为什么设置镜像模式集群，因为队列的内容仅仅存在某一个节点上面，不会存在所有节点上面，所有节点仅仅存放消息结构和元数据。</p>
<h2 id="消息补偿机制"><a href="#消息补偿机制" class="headerlink" title="消息补偿机制"></a>消息补偿机制</h2><p><strong>持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？</strong></p>
<blockquote>
<p>产线网络环境太复杂，故未知数太多，消息补偿机制需要建立在消息要写入DB日志，发送日志，接受日志，两者的状态必须记录。</p>
<p>然后根据DB日志记录check 消息发送消费是否成功，不成功，进行消息补偿措施，重新发送消息处理。</p>
</blockquote>
<h1 id="RabbitMQ-如何实现延迟队列"><a href="#RabbitMQ-如何实现延迟队列" class="headerlink" title="RabbitMQ 如何实现延迟队列"></a>RabbitMQ 如何实现延迟队列</h1><p>RabbitMQ本身没有延迟队列，需要靠TTL和DLX模拟出延迟的效果。延迟队列的实现有两种方式：</p>
<ul>
<li>通过<strong>消息过期后进入死信交换器，再由交换器转发到延迟消费队列</strong>，实现延迟功能；</li>
<li>使用 <code>RabbitMQ-delayed-message-exchange</code> 插件实现延迟功能。</li>
</ul>
<h2 id="过期消息-TTL（Time-To-Live）"><a href="#过期消息-TTL（Time-To-Live）" class="headerlink" title="过期消息 TTL（Time To Live）"></a>过期消息 TTL（Time To Live）</h2><p>RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter</p>
<p>RabbitMQ针对队列中的消息过期时间有两种方法可以设置。</p>
<blockquote>
<ol>
<li><p>通过队列属性设置，队列中所有消息都有相同的过期时间。决定了在没有任何消费者的情况下，队列中的消息可以存活多久。</p>
</li>
<li><p>对消息进行单独设置，每条消息TTL可以不同。决定了在没有任何消费者消费时，消息可以存活多久。</p>
</li>
<li><p>如果消息和对列都设置过期时间，则消息的TTL以两者之间较小的那个数值为准。</p>
</li>
</ol>
</blockquote>
<h2 id="死信队列-DLX-Dead-Letter-Exchange"><a href="#死信队列-DLX-Dead-Letter-Exchange" class="headerlink" title="死信队列 DLX (Dead-Letter-Exchange)"></a>死信队列 DLX (Dead-Letter-Exchange)</h2><p>RabbitMQ的Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，如果队列内出现了dead letter，则按照这两个参数重新路由。</p>
<blockquote>
<ol>
<li><p>x-dead-letter-exchange：出现dead letter之后将dead letter重新发送到指定exchange</p>
</li>
<li><p>x-dead-letter-routing-key：指定routing-key发送</p>
</li>
</ol>
</blockquote>
<p>队列出现dead letter的情况有：</p>
<blockquote>
<p>1.消息或者队列的TTL过期。消息积压太多消费不过来；没有对应的消费者</p>
<p>2.队列达到最大长度，先到达的消息仍没有被消费</p>
<p>3.消息被消费端拒绝（basic.reject or basic.nack）并且requeue=false，没有让消息重新入队</p>
</blockquote>
<p>利用DLX，当消息在一个队列中变成死信后，它能被重新publish到另一个Exchange。这时候消息就可以重新被消费。</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729195949777.png" alt="image-20250729195949777"></p>
<hr>
<h1 id="RabbitMQ实战（SpringBoot）"><a href="#RabbitMQ实战（SpringBoot）" class="headerlink" title="RabbitMQ实战（SpringBoot）"></a>RabbitMQ实战（SpringBoot）</h1><h2 id="Windows-环境安装"><a href="#Windows-环境安装" class="headerlink" title="Windows 环境安装"></a>Windows 环境安装</h2><p>首先可以进入rabbitMQ官网上查看 <a target="_blank" rel="noopener" href="https://www.rabbitmq.com/which-erlang.html">RabbitMQ 版本要求</a> 。定位到<code>RabbitMQ and Erlang/OTP Compatibility Matrix</code>，发现当前RabbitMQ的最新版本是4.1.2，要求Erlang版本最低是26.2，最高是27.0。安装最新版RabbitMQ也就是4.1.2。</p>
<p>因为RabbitMQ 用Erlang 语音开发的，所以先安装Erlang 。</p>
<p><strong>下载安装Erlang</strong></p>
<ol>
<li><p>安装<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Erlang&spm=1001.2101.3001.7020">Erlang</a> （因为RabbitMQ 用Erlang 语音开发的，所已我们先安装Erlang ）。进入到Erlang官网下载 <a target="_blank" rel="noopener" href="https://www.erlang.org/downloads">Erlang下载地址</a> 。选择Erlang27.0 windows 64位的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AE%89%E8%A3%85%E5%8C%85&spm=1001.2101.3001.7020">安装包</a>，点击下载。</p>
</li>
<li><p>找到下载的Erlang安装包，右键以管理员身份运行。按照步骤next , 安装路径D:\IDEA\tools下，注意这里的路径<strong>不能包含中文</strong>。</p>
</li>
<li><p>安装完成后配置环境变量</p>
<blockquote>
<p>新建系统变量ERLANG_HOME，变量值为D:\IDEA\tools\Erlang OTP。</p>
<p>path中添加环境变量 %ERLANG_HOME%\bin 。</p>
</blockquote>
</li>
<li><p>验证Erlang是否安装成功，打开cmd 输入 erl 。出现版本信息则说明安装成功</p>
</li>
</ol>
<p><strong>安装RabbitMQ</strong></p>
<ol>
<li><p>进入到RabbitMQ官网下载安装包，<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v4.1.2/rabbitmq-server-4.1.2.exe">RabbitMQ下载地址</a> ，或者GitHUb下载：<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-server/releases">GitHub</a>。</p>
</li>
<li><p>找到下载的安装包右键以管理员身份运行。按照步骤next , 安装路径D:\IDEA\tools下</p>
</li>
<li><p>安装完成后，在win菜单下找到 RabbitMQ command prompt。</p>
</li>
<li><p>输入命令，激活rabbitmq的ui界面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins.bat <span class="built_in">enable</span> rabbitmq_management </span><br></pre></td></tr></table></figure></li>
<li><p>激活完成后，重启rabbitmq。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop RabbitMQ</span><br><span class="line">net start RabbitMQ</span><br></pre></td></tr></table></figure></li>
<li><p>重启完成后，验证是否成功，登录到 localhost:15672,出现如下图登录页面即安装成功。</p>
</li>
<li><p>RabbitMQ默认的登录用户和密码为 guest guest 。</p>
</li>
<li><p>登录成功后进入到页面，RabbitMQ的安装就算完成。</p>
</li>
</ol>
<h2 id="Linux-环境安装"><a href="#Linux-环境安装" class="headerlink" title="Linux 环境安装"></a>Linux 环境安装</h2><ol>
<li><p>进入到RabbitMQ官网下载安装包，<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v4.1.2/rabbitmq-server-4.1.2-1.el8.noarch.rpm">RabbitMQ下载地址</a> 。</p>
</li>
<li><p>进入<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/erlang-rpm/releases">GitHub|rabbitmq|erlang-rpm</a>选择RabbitMQ支持的版本下载，或者进入到Erlang官网下载 <a target="_blank" rel="noopener" href="https://www.erlang.org/downloads">Erlang下载地址</a> 。</p>
</li>
<li><p><strong>将下载好的安装文件 上传到服务器</strong>，上传在/root目录下</p>
</li>
<li><p>安装Erlang</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum -y install esl-erlang_23.0.2-1_centos_7_amd64.rpm </span><br><span class="line"><span class="comment"># 验证是否安装成功</span></span><br><span class="line">erl</span><br></pre></td></tr></table></figure></li>
<li><p>安装RabbitMQ</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum -y install rabbitmq-server-3.8.5-1.el7.noarch.rpm </span><br><span class="line"><span class="comment"># 安装RabbitMQ 可视化管理控制台 它是以插件的形式存在的。查看所有的插件列表</span></span><br><span class="line">rabbitmq-plugins list</span><br><span class="line"><span class="comment"># [ ] rabbitmq_management x.x.x 为管理系统的插件，安装命令如下</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure></li>
<li><p>启动RabbitMQ</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动RabbitMQ</span></span><br><span class="line">systemctl start rabbitmq-server.service</span><br><span class="line"><span class="comment"># 确认是否启动成功</span></span><br><span class="line">systemctl status rabbitmq-server.service</span><br></pre></td></tr></table></figure></li>
<li><p>访问RabbitMQ</p>
<p>端口为：15672，默认的用户名：guest 密码：guset。访问地址是：自己的服务器的ip+端口（如 <a href="http://192.168.10.11:15672）">http://192.168.10.11:15672）</a></p>
<p>如果不是在localhost本机登录会提示错误：User can only log in via localhost。<strong>解决办法： 让它可以进行远程登录，需要回到安装RabbitMQ的服务器</strong>进行如下操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /etc/rabbitmq/</span></span><br><span class="line">[root@localhost rabbitmq]<span class="comment"># ll</span></span><br><span class="line"><span class="comment"># 发现只有一个文件 enabled_plugins</span></span><br><span class="line"><span class="comment"># 编辑rabbitmq.config 添加[&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].</span></span><br><span class="line">[root@localhost rabbitmq]<span class="comment"># vi rabbitmq.config</span></span><br><span class="line"><span class="comment"># 添加[&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].后保存并退出，然后重启RabbitMQ</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl restart rabbitmq-server.service</span></span><br></pre></td></tr></table></figure>

<p>这时候再访问并登录就可以了</p>
</li>
</ol>
<h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><h2 id="RabiitMQ-依赖引入"><a href="#RabiitMQ-依赖引入" class="headerlink" title="RabiitMQ 依赖引入"></a>RabiitMQ 依赖引入</h2><p>首先在已经搭建好的SpringBoot项目的pom.xml 中引入RabiitMQ的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- AMQO 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="RabbitMQ-配置"><a href="#RabbitMQ-配置" class="headerlink" title="RabbitMQ 配置"></a>RabbitMQ 配置</h2><ol>
<li><p>在application.yml配置文件中进行<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=RabbitMQ&spm=1001.2101.3001.7020">RabbitMQ</a>的配置</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment">#  服务器</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span></span><br><span class="line">    <span class="comment">#  用户名</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment">#  密码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment">#  虚拟主机</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="comment">#  端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="comment">#  监听相关配置</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="comment">#  消费者的最小数量</span></span><br><span class="line">        <span class="attr">concurrency:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment">#  消费者的最大数量</span></span><br><span class="line">        <span class="attr">max-concurrency:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment">#  限制消费者 每次只处理一条消息，处理完毕后再处理下一条消息</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#  启动时是否默认启动容器 默认true</span></span><br><span class="line">        <span class="attr">auto-startup:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">#  当消息被拒绝时，是否重新进入队列</span></span><br><span class="line">        <span class="attr">default-requeue-rejected:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">#  模板相关配置</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="comment">#  开启重试  默认false</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">#  重试时间 默认1000ms</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span></span><br><span class="line">        <span class="comment">#  重试的次数  默认是3</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span></span><br><span class="line">        <span class="comment">#  重试时间的最大间隔时间 默认10000ms</span></span><br><span class="line">        <span class="attr">max-interval:</span> <span class="string">10000ms</span></span><br><span class="line">        <span class="comment">#  重试的间隔乘数  比如配2.0 第一次就间隔10s 第二次 间隔20s 第三次间隔40s ****</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建配置类 RabbitMQConfig</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;queue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>封装发送消息和接收消息的类：对消息的发送和消息的接受我们都分别进行封装</p>
<p>MqSender：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqSender</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;发送消息&quot;</span>+msg);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;queue&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MqReceiver：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqReceiver</span>&#123;</span><br><span class="line">    <span class="comment">//监听配置的队列</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(Object msg)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收消息：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="RabbitMQ-测试"><a href="#RabbitMQ-测试" class="headerlink" title="RabbitMQ 测试"></a>RabbitMQ 测试</h2><ol>
<li><p>随便在一个Contoller类中写一个测试方法。此处在TUserController中添加一个测试方法如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TUserController</span> &#123;</span><br><span class="line">      <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MqSender mqSender;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/mq&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mq</span><span class="params">()</span>&#123;</span><br><span class="line">        mqSender.send(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动项目进行测试</p>
<p>测试路径为 <a target="_blank" rel="noopener" href="http://localhost:8080/user/mq%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0IEAR%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BC%9A%E8%BE%93%E5%87%BA%E6%88%91%E4%BB%AC%E7%9A%84%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%A6%82%E4%B8%8B">http://localhost:8080/user/mq，可以看到IEAR控制台会输出我们的测试数据如下</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... com.xxxxx.seckilldemo.rabbitmq.MqSender  : 发送消息Hello</span><br><span class="line">... com.xxxxx.seckilldemo.rabbitmq.MqReceiver  : 接收消息：(Body:<span class="string">&#x27;Hello&#x27;</span> MessageProperties [headers=&#123;&#125;, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=<span class="literal">false</span>, receivedExchange=, receivedRoutingKey=queue, deliveryTag=1, consumerTag=amq.ctag-IrqC4b7RL3mg1rMy8NefPQ, consumerQueue=queue])</span><br></pre></td></tr></table></figure>

<p>项目启动后RabiitMQ的控制台会显示有一个连接如下图</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180214185.png" alt="image-20250729180214185"></p>
</li>
</ol>
<hr>
<h1 id="RabbitMQ-集群"><a href="#RabbitMQ-集群" class="headerlink" title="RabbitMQ 集群"></a>RabbitMQ 集群</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RabbitMQ 的集群分两种模式，一种是默认集群模式，一种是镜像集群模式；</p>
<p>在RabbitMQ集群中所有的节点(一个节点就是一个RabbitMQ的broker服务器) 被归为两类：一类是磁盘节点,一类是内存节点； </p>
<p>磁盘节点会把集群的所有信息(比如交换机、绑定、队列等信息)持久化到磁盘中，而内存节点只会将这些信息保存到内存中，如果该节点宕机或重启，内存节点的数据会全部丢失，而磁盘节点的数据不会丢失；</p>
<p><strong>RabbitMQ 集群主要有以下两个用途：</strong></p>
<ul>
<li><strong>高可用：</strong>某个服务器出现问题，整个 <code>RabbitMQ</code> 还可以继续使用；</li>
<li><strong>高容量：</strong>集群可以承载更多的消息量。</li>
</ul>
<p><strong>RabbitMQ 集群搭建需要注意的问题</strong></p>
<p>各<strong>节点之间使用<code>“–link”</code>连接</strong>，此属性不能忽略。<br>各节点使用的 <strong><code>erlang cookie</code> 值必须相同</strong>，此值相当于“秘钥”的功能，<strong>用于各节点的认证</strong>。<br><strong>整个集群中必须包含一个磁盘节点</strong>。</p>
<h2 id="默认集群模式"><a href="#默认集群模式" class="headerlink" title="默认集群模式"></a>默认集群模式</h2><h3 id="默认集群简介"><a href="#默认集群简介" class="headerlink" title="默认集群简介"></a>默认集群简介</h3><p>默认集群模式也叫 <strong>普通集群模式</strong>、或者 <strong>内置集群模式</strong>；普通集群，也叫做标准集群（classic cluster）</p>
<p><strong>元数据</strong></p>
<p><strong>队列元数据</strong>：队列名称和属性(是否可持久化,是否自动删除)</p>
<p><strong>交换器元数据</strong>：交换器名称、类型和属性</p>
<p><strong>绑定元数据</strong>：交换器和队列的绑定列表</p>
<p><strong>vhost元数据</strong>：vhost内的相关属性，如安全属性等;</p>
<p>当用户访问其中任何一个RabbitMQ节点时，查询到的<code>queue／user／exchange/vhost</code>等信息都是相同的；</p>
<p><strong>数据同步特点</strong></p>
<p>RabbitMQ默认集群模式只会把交换机、队列、虚拟主机等元数据信息在各个节点同步，而具体队列中的消息内容不会在各个节点中同步，队列的具体信息数据只在队列的拥有者节点保存，其他节点只知道队列的元数据和指向该节点的指针，所以其他节点接收到不属于该节点队列的消息时会将该消息传递给该队列的拥有者节点上；</p>
<p>集群不复制队列内容和状态到所有节点的原因</p>
<ul>
<li><p>节省存储空间；</p>
</li>
<li><p>提升性能；</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180016020.png" alt="image-20250729180016020"></p>
<p>若消息需要复制到集群中每个节点，网络开销不可避免，持久化消息还需要写磁盘，占用磁盘空间。</p>
<p><strong>数据访问过程</strong></p>
<p>若有一个消息生产者或者消息消费者通过<code>amqp-client</code>的客户端连接到节点1进行消息的发送或接收，那么此时集群中的消息收发只与节点1相关，这个没有任何问题；</p>
<p>若消息生产者所连接的是节点2或者节点3，此时队列1的完整数据不在该两个节点上，那么在发送消息过程中这两个节点主要起了一个路由转发作用，根据这两个节点上的元数据（也就是<code>指向queue</code>的<code>owner node</code>的指针）转发至节点1上，最终发送的消息还是会存储至节点1的队列1上；</p>
<p>同样，若消息消费者所连接的节点2或者节点3，那这两节点也会作为路由节点起转发作用，将会从节点1的队列1中获取消息进行消费；</p>
<h3 id="默认集群特征"><a href="#默认集群特征" class="headerlink" title="默认集群特征"></a>默认集群特征</h3><ol>
<li><p>集群中的各个节点是可以共享数据的，比如交换机信息、队列元信息，但不包含队列中的消息。</p>
<p>什么是元信息？ 元信息，就是指队列的描述信息，队列名、队列在哪一个节点中，但是不包括消息本身。</p>
<p>不包括消息本身是什么意思？ 假设我现在两个节点 mq1 和 mq2，然后有一个消费者订阅了 mq2 中的一个队列，但该消费者在访问时，不想小心访问到了 mq1，不过由于在 mq1 上持有 mq2 的元信息，所以他知道 mq2 在哪，因此就可以通过这个元数据找到 mq2 这个节点，然后拿到我们想要的数据（这就类似于 mq1 上有 指向 mq2 的指针，通过指针就可以找到 mq2）。</p>
</li>
<li><p>基于第一个特点的元信息，可以在访问集群中的某个节点时，发现队列不在该节点，就可以通过要访问数据的所在节点的元信息，进一步的拿到这个节点的所有数据。</p>
</li>
<li><p>如果队列所在节点宕机，那么消息就会丢失。</p>
<p> 这里有点类似于 redis 集群中的分片处理，每一个集群上存储全集队列的一部分队列，因此这个节点挂了，消息必然会丢失.</p>
</li>
</ol>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>安装三台RabbitMQ机器：先安装一台MQ，然后克隆两台就行</p>
</li>
<li><p>设置IP地址：启动并设置三台机器的IP</p>
<p><strong>修改配置文件方式</strong></p>
</li>
<li><h5 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hostnamectl set-hostname rabbit11</span><br></pre></td></tr></table></figure></li>
<li><h5 id="修改-etc-hosts-文件"><a href="#修改-etc-hosts-文件" class="headerlink" title="修改/etc/hosts 文件"></a>修改/etc/hosts 文件</h5><p>首先需要配置一下hosts文件，因为RabbitMQ集群节点名称是读取hosts文件得到的；注意三台机机器都需要配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line">192.168.1.11 rabbit11</span><br><span class="line">192.168.1.12 rabbit12</span><br><span class="line">192.168.1.13 rabbit13</span><br></pre></td></tr></table></figure></li>
<li><h5 id="重启网络"><a href="#重启网络" class="headerlink" title="重启网络"></a>重启网络</h5><p>三台机器均重启网络,使节点名生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart NetworkManager</span><br><span class="line"><span class="comment"># 低版本CentOS使用如下命令</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure></li>
<li><h5 id="重新连接xshell"><a href="#重新连接xshell" class="headerlink" title="重新连接xshell"></a>重新连接xshell</h5><p>重启后三台机器的xshell均退出，然后再重新连接，这样才能刷新主机的名字</p>
</li>
<li><h5 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h5><p>三台机器均需关闭</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld  <span class="comment">##关闭防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld  <span class="comment">##开机不启动防火墙</span></span><br><span class="line">systemctl status firewalld    <span class="comment">##查看防火墙状态</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="修改-erlang-cookie文件"><a href="#修改-erlang-cookie文件" class="headerlink" title="修改.erlang.cookie文件"></a>修改.erlang.cookie文件</h5><p>三台机器 .erlang.cookie文件保持一致。<strong>由于是clone出的三台机器，所以肯定是一样的</strong></p>
<ul>
<li><p>如果使用解压缩方式安装的RabbitMQ，那么该文件会在用户名目录下，也就是{用户名}/.erlang.cookie；</p>
</li>
<li><p>如果使用rpm安装包方式进行安装,那么这个文件会在/var/lib/rabbitmq目录下；</p>
</li>
<li><p><strong>注意 .erlang.cookie的权限为400，目前已经是400</strong></p>
</li>
</ul>
</li>
<li><h5 id="启动MQ"><a href="#启动MQ" class="headerlink" title="启动MQ"></a>启动MQ</h5><p>分别启动三台机器上的rabbitmq</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure></li>
<li><h5 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h5><ul>
<li><p><strong>查看rabbitmq状态</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl status</span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">Status of node rabbit@rabbit11...</span><br><span class="line">[]</span><br><span class="line">Runtime</span><br></pre></td></tr></table></figure></li>
<li><p><strong>查看集群状态</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br><span class="line"><span class="comment"># 输出如下： rabbit@rabbit11集群节点名称，Disk Nodes节点类型是磁盘节点</span></span><br><span class="line">Cluster status of node rabbit@rabbit11</span><br><span class="line">Basics</span><br><span class="line">rabbitarabbit11Cluster name:Total CPU cores available cluster-wide: 4</span><br><span class="line">Cluster Tags</span><br><span class="line">(none)</span><br><span class="line">Disk Nodes</span><br><span class="line">rabbitarabbit11</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="构建集群"><a href="#构建集群" class="headerlink" title="构建集群"></a>构建集群</h5><ul>
<li><p>加入节点1</p>
<p>在rabbitmq12机器上执行命令，让12的rabbitmq加入集群</p>
<p>注意：一定要先停止节点，将节点重置之后才能加入集群，否则数据同步会出现混乱</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先停止rabbitmq</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="comment"># 重置rabbitmq</span></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"><span class="comment"># 节点加入集群:rabbit@rabbit11是主节点的节点名,在集群状态中可以查看到节点名称</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@rabbit11 --ram</span><br><span class="line"><span class="comment"># 启动节点</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></li>
<li><p>添加节点2</p>
<p>在rabbit13节点上也<strong>执行同样的命令</strong>，使rabbit13节点也加入到集群中。当然也可以让rabbit13作为一个磁盘节点</p>
</li>
</ul>
</li>
<li><h5 id="添加用户和权限"><a href="#添加用户和权限" class="headerlink" title="添加用户和权限"></a>添加用户和权限</h5><p>操作一个节点，添加用户和权限等</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出用户</span></span><br><span class="line">rabbitmqctl list_users</span><br><span class="line"><span class="comment"># 添加用户</span></span><br><span class="line">rabbitmqctl add_user admin 123456</span><br><span class="line"><span class="comment"># 查看权限</span></span><br><span class="line">rabbitmqctl list_permissions</span><br><span class="line"><span class="comment"># 设置权限</span></span><br><span class="line">rabbitmqctl set_permissions admin <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span><br><span class="line"><span class="comment"># 设置角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure></li>
<li><h5 id="启动web控制台"><a href="#启动web控制台" class="headerlink" title="启动web控制台"></a>启动web控制台</h5><p>启动web控制台插件。注意：三台机器都要启动，因为插件不属于元数据，因此需要分别启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入插件目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/rabbitmq_server-4.0.7/plugins/</span><br><span class="line"><span class="comment"># 启动web端插件</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management </span><br></pre></td></tr></table></figure></li>
<li><h5 id="创建虚拟主机"><a href="#创建虚拟主机" class="headerlink" title="创建虚拟主机"></a>创建虚拟主机</h5><p>使用web浏览器添加一个虚拟主机：longdidi</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180621236.png" alt="image-20250729180621236"></p>
</li>
<li><h5 id="再次查看集群状态"><a href="#再次查看集群状态" class="headerlink" title="再次查看集群状态"></a>再次查看集群状态</h5><p>当执行完操作以后在浏览器访问web管控台来看看效果；随便在哪个节点打开web管控台都能看到集群环境各节点的信息；也可以使用”rabbitmqctl cluster_status”查看集群状态；</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180657444.png" alt="image-20250729180657444"></p>
</li>
<li><h5 id="验证集群"><a href="#验证集群" class="headerlink" title="验证集群"></a>验证集群</h5><ol>
<li><p>创建队列</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180728567.png" alt="image-20250729180728567"></p>
</li>
<li><p>创建交换机</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180804318.png" alt="image-20250729180804318"></p>
</li>
<li><p>绑定交换机与队列</p>
<ul>
<li><p>进入交换机</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181126120.png" alt="image-20250729181126120"></p>
</li>
<li><p>绑定交换机与队列</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181204097.png" alt="image-20250729181204097"></p>
</li>
</ul>
</li>
<li><p>发布消息</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181229138.png" alt="image-20250729181229138"></p>
</li>
<li><p>查看消息</p>
<p>在任意节点查看消息</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181259889.png" alt="image-20250729181259889"></p>
</li>
<li><p>停止主节点rabbit@rabbit11节点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poweroff</span><br><span class="line"><span class="comment"># Connection Closing...socket close.</span></span><br><span class="line"><span class="comment"># Connection closed by foreign host.</span></span><br></pre></td></tr></table></figure></li>
<li><p>再在其它节点查看消息</p>
<p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181458290.png" alt="image-20250729181458290"></p>
</li>
</ol>
</li>
<li><h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmgctl stop_app</span><br><span class="line">rabbitmgctl reset</span><br><span class="line">rabbitmgctl start_app</span><br><span class="line">rabbitmgctl cluster_status</span><br><span class="line">rabbitmgctl forget_cluster_node rabbit@node2 <span class="comment"># (node1节点上执行)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="节点原理"><a href="#节点原理" class="headerlink" title="节点原理"></a>节点原理</h3><p>RabbitMQ底层是通过Erlang架构来实现的，所以rabbitmqctl会启动Erlang节点，并基于Erlang节点来使用Erlang系统连接RabbitMQ节点，在连接过程中需要正确的Erlang Cookie和节点名称，Erlang节点通过交换Erlang Cookie以获得认证。</p>
<h2 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h2><h3 id="镜像集群模式简介"><a href="#镜像集群模式简介" class="headerlink" title="镜像集群模式简介"></a>镜像集群模式简介</h3><p>镜像模式是基于默认集群模式加上一定的配置得来的；在默认模式下的RabbitMQ集群，它会把所有节点的交换机、绑定、队列的元数据进行复制确保所有节点都有一份相同的元数据信息，但是队列数据分为两种：</p>
<ul>
<li><p>一种是队列的元数据信息(比如队列的最大容量,队列的名称等配置信息)</p>
</li>
<li><p>一种是队列里面的消息</p>
</li>
</ul>
<p>镜像模式则是把所有的队列数据完全同步，包括元数据信息和消息数据信息，当然这对性能肯定会有一定影响，当对数据可靠性要求较高时，可以使用镜像模式。</p>
<h3 id="镜像集群模式特征"><a href="#镜像集群模式特征" class="headerlink" title="镜像集群模式特征"></a>镜像集群模式特征</h3><p>镜像集群，本质上就是主从模式。主要有以下几个特性：</p>
<ol>
<li><p><strong>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份</strong></p>
<p>这里就和之前的普通交换机不一样了，不仅仅是交换机可以共享，队列中的消息大家也可以共享了。</p>
</li>
<li><p><strong>创建队列的节点被称为该队列的主节点，备份到的其它节点叫做该队列的镜像节点</strong></p>
<p>比如现在有三个节点，现在我再 mq1 上创建了一个队列 q1，因此 mq1 就是主节点，那么还可以给他挑一个镜像节点，比如我再 mq2 上做一个镜像，那么 mq2 就会去找 mq1 同步 q1 的所有数据。</p>
</li>
<li><p><strong>一个队列的主节点可能是另一个队列的镜像节点</strong></p>
<p>也就是说，主节点和镜像节点是可以相互备份的。比如 q1 在 mq1 上，给 mq2 备份了一份，q2 实在 mq2 上，给 mq3 备份了一份，q3 在 mq3 上的，给 mq1 备份了一份，那么这个时候，mq1 就是 q1 的主节点，同时也是 q3 的镜像节点。</p>
</li>
<li><p><strong>所有操作都是主节点完成，然后同步给镜像节点 。</strong></p>
</li>
<li><p>主节点宕机后，镜像节点会替代成新的主节点</p>
</li>
</ol>
<h3 id="镜像模式配置-3-X版本"><a href="#镜像模式配置-3-X版本" class="headerlink" title="镜像模式配置 3.X版本"></a>镜像模式配置 3.X版本</h3><p>在默认集群模式的基础上执行如下命令就可以把一个默认的集群模式变成镜像集群模式。镜像队列配置语法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>rabbitmqctl set_policy：固定写法</p>
</li>
<li><p>-p Vhost：可选参数,设置虚拟主机的名字(针对指定vhost下的queue进行设置)</p>
</li>
<li><p>Name:：设置策略的名称(自己取个名字就可以)</p>
</li>
<li><p>Pattern:：queue的匹配模式(正则表达式)；^表示所有的队列都是镜像队列</p>
</li>
<li><p>Definition：镜像定义(json格式)，包括三个部分ha-mode、ha-params、ha-sync-mode</p>
<ul>
<li><p>ha-mode：指明镜像队列的模式，有效值为 all/exactly/nodes</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all：表示在集群中所有的节点上进行镜像</span><br><span class="line">exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span><br><span class="line">nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</span><br></pre></td></tr></table></figure></li>
<li><p>ha-params：ha-mode模式需要用到的参数</p>
</li>
<li><p>ha-sync-mode：队列中消息的同步方式,有效值为automatic(自动向master同步数据)和manual(手动向master同步数据)</p>
</li>
</ul>
</li>
<li><p>priority：可选参数，指的是policy策略的优先级；</p>
</li>
</ul>
<p>示例：比如想配置所有名字开头为policy_的队列进行镜像，镜像数量为2，那么命令如下(在任意节点执行如下命令)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy -p longdidi my_policy <span class="string">&quot;^policy_&quot;</span>  <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span>  </span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>同步所有数据</strong></p>
<p>所有节点、所有虚拟主机、所有队列 都进行镜像。如果要在所有节点所有队列上进行镜像则在任意节点执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy my-all <span class="string">&quot;^&quot;</span>  <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span>   </span><br></pre></td></tr></table></figure></li>
<li><p><strong>同步指定数据</strong></p>
<p>针对某个虚拟主机进行镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy -p longdidi my-all <span class="string">&quot;^&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;: &quot;exactly&quot;, &quot;ha-params&quot;: 2, &quot;ha-sync-mode&quot;: &quot;automatic&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="镜像模式配置-4-X版本"><a href="#镜像模式配置-4-X版本" class="headerlink" title="镜像模式配置 4.X版本"></a>镜像模式配置 4.X版本</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729182945585.png" alt="image-20250729182945585"></p>
<h2 id="仲裁队列"><a href="#仲裁队列" class="headerlink" title="仲裁队列"></a>仲裁队列</h2><p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p>
<ol>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于Raft协议，强一致</li>
</ol>
<p>在 SpringAMQP 中创建仲裁队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">quorumQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;quorum.queue&quot;</span>)     <span class="comment">// 持久化 </span></span><br><span class="line">            .quorum()                     <span class="comment">// 仲裁队列</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringAMQP连接集群，只需要在yaml中配置即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8071,</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8072,</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8073</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">1111</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>



<h2 id="SpringBoot集成集群"><a href="#SpringBoot集成集群" class="headerlink" title="SpringBoot集成集群"></a>SpringBoot集成集群</h2><h3 id="重点连接配置"><a href="#重点连接配置" class="headerlink" title="重点连接配置"></a>重点连接配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment"># 连接单台rabbitmq 服务器的地址</span></span><br><span class="line">    <span class="comment"># host: 192.168.1.101</span></span><br><span class="line">    <span class="comment"># 连接单台rabbitmq 服务器的端口</span></span><br><span class="line">    <span class="comment"># port: 5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启生产者的确认模式,设置关联模式</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#开启return模式</span></span><br><span class="line">    <span class="comment"># 开启消费者手动确认</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span><span class="string">:5672,192.168.1.12:5672,192.1.13:5672</span></span><br></pre></td></tr></table></figure>

<p>测试模块:rabbitmq-10-cluster-01</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置MQ"><a href="#配置MQ" class="headerlink" title="配置MQ"></a>配置MQ</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cluster-learn01</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment"># 连接单台rabbitmq 服务器的地址</span></span><br><span class="line">    <span class="comment"># host: 192.168.1.101</span></span><br><span class="line">    <span class="comment"># 连接单台rabbitmq 服务器的端口</span></span><br><span class="line">    <span class="comment"># port: 5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启生产者的确认模式,设置关联模式</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#开启return模式</span></span><br><span class="line">    <span class="comment"># 开启消费者手动确认</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span><span class="string">:5672,192.168.1.12:5672,192.1.13:5672</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.4</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="comment">#password: 123456</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># 0号数据库</span></span><br></pre></td></tr></table></figure>

<h3 id="定义MQ队列"><a href="#定义MQ队列" class="headerlink" title="定义MQ队列"></a>定义MQ队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.longdidi.constants.RabbitMQConstant;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机,使用durable()方法设置持久化</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列,durable()方法就是持久化</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, @Nullable Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常交换机和正常队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建生产者、消费者"><a href="#创建生产者、消费者" class="headerlink" title="创建生产者、消费者"></a>创建生产者、消费者</h3><p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.longdidi.constants.RabbitMQConstant;</span><br><span class="line"><span class="keyword">import</span> com.longdidi.vo.Orders;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageDeliveryMode;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 这个对象可以进行序列化和反序列化(json格式)</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法执行后自动执行</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 开启生产者的确定模式</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(</span><br><span class="line">                (correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;消息没有到达交换机,原因为:&#123;&#125;&quot;</span>, cause);</span><br><span class="line">                        <span class="comment">// TODO 重发消息或者记录错误日志</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">                returnedMessage -&gt; &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;消息没有从交换机正确的投递(路由)到队列,原因为:&#123;&#125;&quot;</span>, returnedMessage.getReplyText());</span><br><span class="line">                    <span class="comment">// TODO 记录错误日志,给程序员发短信或者或者邮件</span></span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建订单</span></span><br><span class="line">            <span class="type">Orders</span> <span class="variable">orders1</span> <span class="operator">=</span> Orders.builder()</span><br><span class="line">                    .orderId(<span class="string">&quot;order_12345&quot;</span>).orderName(<span class="string">&quot;买的手机&quot;</span>)</span><br><span class="line">                    .orderMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">2356</span>)).orderTime(<span class="keyword">new</span> <span class="title class_">Date</span>()).build();</span><br><span class="line">            <span class="comment">//转成json</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">strOrders1</span> <span class="operator">=</span> objectMapper.writeValueAsString(orders1);</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            <span class="comment">//设置单条消息的持久化,默认就是持久化</span></span><br><span class="line">            messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(strOrders1.getBytes())</span><br><span class="line">                    .andProperties(messageProperties).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Orders</span> <span class="variable">orders2</span> <span class="operator">=</span> Orders.builder() .orderId(<span class="string">&quot;order_12345&quot;</span>).orderName(<span class="string">&quot;买的手机&quot;</span>)</span><br><span class="line">                    .orderMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">2356</span>)).orderTime(<span class="keyword">new</span> <span class="title class_">Date</span>()).build();</span><br><span class="line">            <span class="type">String</span> <span class="variable">strOrders2</span> <span class="operator">=</span> objectMapper.writeValueAsString(orders2);</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            <span class="comment">//设置单条消息的持久化,默认就是持久化</span></span><br><span class="line">            messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(strOrders2.getBytes())</span><br><span class="line">                    .andProperties(messageProperties).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.longdidi.constants.RabbitMQConstant;</span><br><span class="line"><span class="keyword">import</span> com.longdidi.vo.Orders;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME1&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取消息的唯一标识</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="comment">// 使用objectmapper把字节数组反序列化成对象</span></span><br><span class="line">        <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> objectMapper.readValue(message.getBody(), Orders.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;&quot;</span>, orders.toString());</span><br><span class="line">            <span class="comment">// 如果不存在就在redis中存储</span></span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">setResult</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(<span class="string">&quot;idempotent:&quot;</span> + orders.getOrderId(), orders.getOrderId());</span><br><span class="line">            <span class="keyword">if</span> (setResult) &#123;</span><br><span class="line">                <span class="comment">// TODO 向数据库插入订单等</span></span><br><span class="line">                log.info(<span class="string">&quot;向数据库插入订单&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 手动确认</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息处理出现问题&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义常量、实体类"><a href="#定义常量、实体类" class="headerlink" title="定义常量、实体类"></a>定义常量、实体类</h3><p><strong>定义常量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.idempotent.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME1</span> <span class="operator">=</span> <span class="string">&quot;queue.idempotent.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME1</span> <span class="operator">=</span> <span class="string">&quot;key.idempotent.normal.1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义实体类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal orderMoney;</span><br><span class="line">    <span class="keyword">private</span> Date orderTime; <span class="comment">// 下单时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong>发送消息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.longdidi.service.SendMessageService;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rabbitmq10Cluster01Application</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Rabbitmq10Cluster01Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SendMessageService sendMessageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序一启动就会运行该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sendMessageService.sendMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Tue Jul 29 18:41:22 GMT+08:00 2025</span><br><span class="line">接收到的消息为:0rders(orderId=order_12345,orderName=买的手机,orderMoney=2356....</span><br><span class="line">接收到的消息为:0rders(orderId=order_12345,orderName=买的手机,orderMoney=2356....</span><br></pre></td></tr></table></figure>



<h2 id="RabbitMQ-节点的类型"><a href="#RabbitMQ-节点的类型" class="headerlink" title="RabbitMQ 节点的类型"></a>RabbitMQ 节点的类型</h2><p><strong>磁盘节点：</strong>消息会存储到磁盘。<br><strong>内存节点：</strong>消息都存储在内存中，<strong>重启服务器消息丢失，性能高于磁盘类型</strong>。</p>
<h2 id="RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h2><p>不是，原因有以下两个：</p>
<ul>
<li><strong>存储空间的考虑：</strong>若每个节点都拥有所有队列的完全拷贝，新增节点不但没有新增存储空间，反而<strong>增加了冗余数据</strong>；</li>
<li><strong>性能的考虑：</strong>若每条消息都需要完整拷贝到每一个集群节点，那新增节点并<strong>没有提升处理消息的能力</strong>，最多是保持和单节点相同的性能<strong>甚至是更糟</strong>。</li>
</ul>
<h2 id="RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么"><a href="#RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么" class="headerlink" title="RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么"></a>RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么</h2><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p>
<ul>
<li>不能创建队列</li>
<li>不能创建交换器</li>
<li>不能创建绑定</li>
<li>不能添加用户</li>
<li>不能更改权限</li>
<li>不能添加和删除集群节点</li>
</ul>
<p>唯一磁盘节点崩溃了，<strong>集群可以保持运行，但不能更改任何东西</strong></p>
<h2 id="RabbitMQ-对集群节点停止顺序有要求吗"><a href="#RabbitMQ-对集群节点停止顺序有要求吗" class="headerlink" title="RabbitMQ 对集群节点停止顺序有要求吗"></a>RabbitMQ 对集群节点停止顺序有要求吗</h2><p><code>RabbitMQ</code> 对集群的停止顺序是有要求的，应该<strong>先关闭内存节点，最后再关闭磁盘节点。若顺序恰好相反的话，可能会造成消息的丢失</strong>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://southernfish.github.io">Southern Fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://southernfish.github.io/pages/middleware/rabbitmq/">https://southernfish.github.io/pages/middleware/rabbitmq/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://southernfish.github.io" target="_blank">Southern Fish</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RabbitMQ/">RabbitMQ</a></div><div class="post_share"><div class="social-share" data-image="/img/article/article1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/pages/middleware/rabbitmq-component/"><img class="prev-cover" src="/img/article/article4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RabbitMQ 组件</div></div></a></div><div class="next-post pull-right"><a href="/pages/framwork/mybatis/"><img class="next-cover" src="/img/article/article3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MyBatis</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/pages/middleware/rabbitmq-component/" title="RabbitMQ 组件"><img class="cover" src="/img/article/article4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-30</div><div class="title">RabbitMQ 组件</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southern Fish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SouthernFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1002721576@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">天下事岂能尽如吾意，心境须恰适，尽其在我，随遇而安。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">RabbitMQ 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">RabbitMQ的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%B6%88%E5%B3%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">流量消峰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">应用解耦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">异步处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86"><span class="toc-number">1.2.4.</span> <span class="toc-text">日志处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.</span> <span class="toc-text">四大核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E7%9A%84%E9%87%8D%E8%A6%81%E8%A7%92%E8%89%B2"><span class="toc-number">1.3.1.</span> <span class="toc-text">RabbitMQ 的重要角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">1.3.2.</span> <span class="toc-text">生产者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.3.3.</span> <span class="toc-text">交换机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.3.4.</span> <span class="toc-text">队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.4.</span> <span class="toc-text">消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E7%9A%84%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="toc-number">1.5.1.</span> <span class="toc-text">RabbitMQ 的重要组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E7%9A%84%E6%B6%88%E6%81%AF%E6%98%AF%E6%80%8E%E4%B9%88%E5%8F%91%E9%80%81%E7%9A%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">RabbitMQ 的消息是怎么发送的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%83%E7%A7%8D%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">工作模式（七种）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#simple-%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">simple (简单模式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Work-queues-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">Work queues(工作模式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Publish-Subscribe%EF%BC%88%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">Publish&#x2F;Subscribe（发布订阅模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Routing%EF%BC%88%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">Routing（路由模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topics%EF%BC%88%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">1.6.5.</span> <span class="toc-text">Topics（主题模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.6.</span> <span class="toc-text">RPC模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.7.</span> <span class="toc-text">发布确认模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ-%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">RabbitMQ 保证消息的稳定性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">消息持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACK%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">ACK确认机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%9B%86%E7%BE%A4%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">设置集群镜像模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">消息补偿机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">RabbitMQ 如何实现延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E6%B6%88%E6%81%AF-TTL%EF%BC%88Time-To-Live%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">过期消息 TTL（Time To Live）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97-DLX-Dead-Letter-Exchange"><span class="toc-number">3.2.</span> <span class="toc-text">死信队列 DLX (Dead-Letter-Exchange)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E5%AE%9E%E6%88%98%EF%BC%88SpringBoot%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">RabbitMQ实战（SpringBoot）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85"><span class="toc-number">4.1.</span> <span class="toc-text">Windows 环境安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85"><span class="toc-number">4.2.</span> <span class="toc-text">Linux 环境安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98"><span class="toc-number">4.3.</span> <span class="toc-text">项目实战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabiitMQ-%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5"><span class="toc-number">4.4.</span> <span class="toc-text">RabiitMQ 依赖引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E9%85%8D%E7%BD%AE"><span class="toc-number">4.5.</span> <span class="toc-text">RabbitMQ 配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E6%B5%8B%E8%AF%95"><span class="toc-number">4.6.</span> <span class="toc-text">RabbitMQ 测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ-%E9%9B%86%E7%BE%A4"><span class="toc-number">5.</span> <span class="toc-text">RabbitMQ 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">默认集群模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E9%9B%86%E7%BE%A4%E7%AE%80%E4%BB%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">默认集群简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E9%9B%86%E7%BE%A4%E7%89%B9%E5%BE%81"><span class="toc-number">5.2.2.</span> <span class="toc-text">默认集群特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">5.2.3.</span> <span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D"><span class="toc-number">5.2.3.0.1.</span> <span class="toc-text">修改主机名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-etc-hosts-%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.3.0.2.</span> <span class="toc-text">修改&#x2F;etc&#x2F;hosts 文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E7%BD%91%E7%BB%9C"><span class="toc-number">5.2.3.0.3.</span> <span class="toc-text">重启网络</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%BF%9E%E6%8E%A5xshell"><span class="toc-number">5.2.3.0.4.</span> <span class="toc-text">重新连接xshell</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99"><span class="toc-number">5.2.3.0.5.</span> <span class="toc-text">关闭防火墙</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-erlang-cookie%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.3.0.6.</span> <span class="toc-text">修改.erlang.cookie文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8MQ"><span class="toc-number">5.2.3.0.7.</span> <span class="toc-text">启动MQ</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81"><span class="toc-number">5.2.3.0.8.</span> <span class="toc-text">查看集群状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%9B%86%E7%BE%A4"><span class="toc-number">5.2.3.0.9.</span> <span class="toc-text">构建集群</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90"><span class="toc-number">5.2.3.0.10.</span> <span class="toc-text">添加用户和权限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8web%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">5.2.3.0.11.</span> <span class="toc-text">启动web控制台</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA"><span class="toc-number">5.2.3.0.12.</span> <span class="toc-text">创建虚拟主机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%8D%E6%AC%A1%E6%9F%A5%E7%9C%8B%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81"><span class="toc-number">5.2.3.0.13.</span> <span class="toc-text">再次查看集群状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E9%9B%86%E7%BE%A4"><span class="toc-number">5.2.3.0.14.</span> <span class="toc-text">验证集群</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">5.2.3.0.15.</span> <span class="toc-text">删除节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.4.</span> <span class="toc-text">节点原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">镜像集群模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">镜像集群模式简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E7%89%B9%E5%BE%81"><span class="toc-number">5.3.2.</span> <span class="toc-text">镜像集群模式特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE-3-X%E7%89%88%E6%9C%AC"><span class="toc-number">5.3.3.</span> <span class="toc-text">镜像模式配置 3.X版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE-4-X%E7%89%88%E6%9C%AC"><span class="toc-number">5.3.4.</span> <span class="toc-text">镜像模式配置 4.X版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97"><span class="toc-number">5.4.</span> <span class="toc-text">仲裁队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E9%9B%86%E6%88%90%E9%9B%86%E7%BE%A4"><span class="toc-number">5.5.</span> <span class="toc-text">SpringBoot集成集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE"><span class="toc-number">5.5.1.</span> <span class="toc-text">重点连接配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">5.5.2.</span> <span class="toc-text">引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEMQ"><span class="toc-number">5.5.3.</span> <span class="toc-text">配置MQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89MQ%E9%98%9F%E5%88%97"><span class="toc-number">5.5.4.</span> <span class="toc-text">定义MQ队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">5.5.5.</span> <span class="toc-text">创建生产者、消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E3%80%81%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">5.5.6.</span> <span class="toc-text">定义常量、实体类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">5.5.7.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E8%8A%82%E7%82%B9%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.6.</span> <span class="toc-text">RabbitMQ 节点的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E6%98%AF%E5%85%B6%E4%BB%96%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8B%B7%E8%B4%9D%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.7.</span> <span class="toc-text">RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E9%9B%86%E7%BE%A4%E4%B8%AD%E5%94%AF%E4%B8%80%E4%B8%80%E4%B8%AA%E7%A3%81%E7%9B%98%E8%8A%82%E7%82%B9%E5%B4%A9%E6%BA%83%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">5.8.</span> <span class="toc-text">RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E5%AF%B9%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%81%9C%E6%AD%A2%E9%A1%BA%E5%BA%8F%E6%9C%89%E8%A6%81%E6%B1%82%E5%90%97"><span class="toc-number">5.9.</span> <span class="toc-text">RabbitMQ 对集群节点停止顺序有要求吗</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/pages/high-availability/server-limit-stream/" title="服务限流"><img src="/img/article/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="服务限流"/></a><div class="content"><a class="title" href="/pages/high-availability/server-limit-stream/" title="服务限流">服务限流</a><time datetime="2025-09-18T09:02:36.000Z" title="发表于 2025-09-18 17:02:36">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/db-redis-persistence/" title="Redis的持久化机制"><img src="/img/article/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis的持久化机制"/></a><div class="content"><a class="title" href="/pages/database/db-redis-persistence/" title="Redis的持久化机制">Redis的持久化机制</a><time datetime="2025-09-18T01:15:36.000Z" title="发表于 2025-09-18 09:15:36">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/cache-read-write-strategies/" title="三大缓存读写策略"><img src="/img/article/article6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="三大缓存读写策略"/></a><div class="content"><a class="title" href="/pages/database/cache-read-write-strategies/" title="三大缓存读写策略">三大缓存读写策略</a><time datetime="2025-09-17T13:15:36.000Z" title="发表于 2025-09-17 21:15:36">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/db-redis-consistency/" title="Redis缓存与数据库的一致性"><img src="/img/article/article4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis缓存与数据库的一致性"/></a><div class="content"><a class="title" href="/pages/database/db-redis-consistency/" title="Redis缓存与数据库的一致性">Redis缓存与数据库的一致性</a><time datetime="2025-09-17T13:15:36.000Z" title="发表于 2025-09-17 21:15:36">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pages/database/db-redis-produce-problem/" title="Redis的缓存穿透、缓存击穿、缓存雪崩"><img src="/img/article/article3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis的缓存穿透、缓存击穿、缓存雪崩"/></a><div class="content"><a class="title" href="/pages/database/db-redis-produce-problem/" title="Redis的缓存穿透、缓存击穿、缓存雪崩">Redis的缓存穿透、缓存击穿、缓存雪崩</a><time datetime="2025-09-17T13:15:36.000Z" title="发表于 2025-09-17 21:15:36">2025-09-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/article/article1.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Southern Fish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>