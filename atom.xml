<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Southern Fish</title>
  
  
  <link href="https://southernfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://southernfish.github.io/"/>
  <updated>2025-06-19T13:36:26.089Z</updated>
  <id>https://southernfish.github.io/</id>
  
  <author>
    <name>Southern Fish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络</title>
    <link href="https://southernfish.github.io/2025/06/19/java-network/"/>
    <id>https://southernfish.github.io/2025/06/19/java-network/</id>
    <published>2025-06-19T13:36:26.089Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些Java中关于网络相关的一些问题</p><h2 id="http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="http 响应码 301 和 302 代表的是什么？有什么区别？"></a>http 响应码 301 和 302 代表的是什么？有什么区别？</h2><p><strong>301：</strong>永久重定向。<br><strong>302：</strong>暂时重定向。<br>区别在于<strong>301 对搜索引擎优化（SEO）更加有利，302 有被提示为网络拦截的风险</strong>。</p><h2 id="forward-和-redirect-的区别？"><a href="#forward-和-redirect-的区别？" class="headerlink" title="forward 和 redirect 的区别？"></a>forward 和 redirect 的区别？</h2><p>forward 是转发 和 redirect 是重定向。</p><ul><li><strong>地址栏 url 显示：</strong>foward url 不会发生改变，redirect url 会发生改变；</li><li><strong>数据共享：</strong>forward 可以共享 request 里的数据，redirect 不能共享；</li><li><strong>效率：</strong>forward 比 redirect 效率高。</li></ul><h2 id="简述-tcp-和-udp的区别？"><a href="#简述-tcp-和-udp的区别？" class="headerlink" title="简述 tcp 和 udp的区别？"></a>简述 tcp 和 udp的区别？</h2><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。<br>tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。两者的区别如下：</p><ul><li><strong>tcp 面向连接</strong>，udp 面向<strong>非连接即发送数据前不需要建立链接</strong>；</li><li>tcp 提供<strong>可靠的服务</strong>（数据传输），udp 无法保证；</li><li><strong>tcp 面向字节流</strong>，udp 面向报文；</li><li>tcp 数据传输<strong>慢</strong>，udp 数据传输快；</li></ul><h2 id="tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="tcp 为什么要三次握手，两次不行吗？为什么？"></a>tcp 为什么要三次握手，两次不行吗？为什么？</h2><p>若采用两次握手，那么<strong>只要服务器发出确认数据包就会建立连接</strong>，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直等待客户端，这样服务器端就白白浪费了资源。<br>若采用三次握手，<strong>服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求</strong>，就不会浪费服务器的资源。</p><h2 id="tcp-粘包是怎么产生的？"><a href="#tcp-粘包是怎么产生的？" class="headerlink" title="tcp 粘包是怎么产生的？"></a>tcp 粘包是怎么产生的？</h2><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：<br><strong>发送端粘包：</strong>发送端需要<strong>等缓冲区满才发送出去</strong>，造成粘包；<br><strong>接收方粘包：</strong>接收方<strong>不及时接收缓冲区的包，造成多个包接收</strong>。</p><h2 id="OSI-的七层模型都有哪些？"><a href="#OSI-的七层模型都有哪些？" class="headerlink" title="OSI 的七层模型都有哪些？"></a>OSI 的七层模型都有哪些？</h2><p><strong>物理层：</strong>利用传输介质<em>为数据链路层提供物理连接，实现比特流的透明传输</em>。<br><strong>数据链路层：</strong>负责<em>建立和管理节点间的链路</em>。<br><strong>网络层：</strong>通过路由选择算法，<em>为报文或分组通过通信子网选择最适当的路径</em>。<br><strong>传输层：</strong>向用户<em>提供可靠的端到端的差错和流量控制</em>，保证报文的正确传输。<br><strong>会话层：</strong>向两个实体的表示层<em>提供建立和使用连接的方法</em>。<br><strong>表示层：</strong>处理<em>用户信息的表示问题</em>，如编码、数据格式转换和加密解密等。<br><strong>应用层：</strong>直接<em>向用户提供服务</em>，完成用户希望在网络上完成的各种工作。</p><h2 id="get-和-post-请求有哪些区别？"><a href="#get-和-post-请求有哪些区别？" class="headerlink" title="get 和 post 请求有哪些区别？"></a>get 和 post 请求有哪些区别？</h2><p><strong>get 请求会被浏览器主动缓存</strong>，而 post 不会。<br><strong>get 传递参数有大小限制</strong>，而 post 没有。<br><strong>post 参数传输更安全</strong>，get 的参数会明文限制在 url 上，post 不会。</p><h2 id="如何实现跨域？"><a href="#如何实现跨域？" class="headerlink" title="如何实现跨域？"></a>如何实现跨域？</h2><p><strong>原因：</strong>浏览器安全机制，请求访问的域名与ajax请求的域名不一致，导致无法返回结果。</p><p>实现跨域的方案：</p><ul><li><strong>使用 jsonp 跨域：</strong>只支持 GET 请求，不支持 POST</li><li><strong>服务器端运行跨域：</strong>设置 CORS 等于 *</li><li>CORS（跨域资源分享）<ul><li><strong>普通跨域请求：</strong>只需服务器端设置 Access-Control-Allow-Origin</li><li><strong>带 cookie 跨域请求：</strong>前后端都需要进行设置；</li></ul></li><li><strong>在单个接口使用注解：</strong> @CrossOrigin </li><li><strong>nginx 代理跨域：</strong>实质和 CORS 跨域原理一样，通过配置文件设置请求响应头 Access-Control-Allow-Origin 等字段</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue配置</span><br><span class="line">this.$http.jsonp(&#x27;http://www.domain2.com:8080/login&#x27;, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: &#x27;handleCallback&#x27;</span><br><span class="line">&#125;).then((res) =&gt; &#123;</span><br><span class="line">    console.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="JSONP-实现原理？"><a href="#JSONP-实现原理？" class="headerlink" title="JSONP 实现原理？"></a>JSONP 实现原理？</h2><p><strong>Jsonp：</strong>JSON with Padding，它是<strong>利用 script 标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行</strong>的。</p>]]></content>
    
    
    <summary type="html">网络相关</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="网络" scheme="https://southernfish.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Kafka and Zookeeper</title>
    <link href="https://southernfish.github.io/2025/06/19/kafka-zookeeper/"/>
    <id>https://southernfish.github.io/2025/06/19/kafka-zookeeper/</id>
    <published>2025-06-19T11:55:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka 和 ZooKeeper 在分布式系统中扮演着不同的角色，并且它们之间有着紧密的合作关系。</p><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h1 id="Kafka是什么？"><a href="#Kafka是什么？" class="headerlink" title="Kafka是什么？"></a>Kafka是什么？</h1><p>‌<strong>Kafka</strong>‌是一个<strong>分布式流处理平台</strong>，最初由<code>LinkedIn</code>开发，后成为<code>Apache</code>开源项目。<code>Kafka</code>主要用于<strong>构建实时数据管道和流应用</strong>，具有高吞吐量、低延迟和可扩展性等特点‌。Kafka的<strong>核心功能</strong>包括：</p><ul><li>‌<strong>消息发布与订阅</strong>‌：Kafka允许应用程序发布和订阅消息流。</li><li>‌<strong>分布式日志</strong>‌：Kafka将数据持久化到磁盘，支持高吞吐量的数据收集。</li><li>‌<strong>流处理</strong>‌：支持复杂的流处理操作，如转换、过滤和聚合</li></ul><h1 id="kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>kafka 可以脱离 zookeeper 单独使用吗？为什么？</h1><p><code>kafka</code> 不能脱离 <code>zookeeper</code> 单独使用，因为 <strong>kafka 使用 zookeeper 管理和协调 kafka 的节点服务器</strong>。</p><h2 id="kafka-有几种数据保留的策略？"><a href="#kafka-有几种数据保留的策略？" class="headerlink" title="kafka 有几种数据保留的策略？"></a>kafka 有几种数据保留的策略？</h2><p>kafka 有<strong>两种</strong>数据保存策略：<strong>按照过期时间保留</strong>、<strong>按照存储的消息大小保留</strong>。</p><h2 id="kafka-设置了-7-天和-10G-清除数据，第五天消息达-10G，kafka-如何处理？"><a href="#kafka-设置了-7-天和-10G-清除数据，第五天消息达-10G，kafka-如何处理？" class="headerlink" title="kafka 设置了 7 天和 10G 清除数据，第五天消息达 10G，kafka 如何处理？"></a>kafka 设置了 7 天和 10G 清除数据，第五天消息达 10G，kafka 如何处理？</h2><p>这个时候 kafka 会执行数据清除工作，<strong>时间和大小不论那个满足条件，都会清空数据</strong>。</p><h2 id="什么情况会导致-kafka-运行变慢？"><a href="#什么情况会导致-kafka-运行变慢？" class="headerlink" title="什么情况会导致 kafka 运行变慢？"></a>什么情况会导致 kafka 运行变慢？</h2><p>cpu 性能瓶颈<br>磁盘读写瓶颈<br>网络瓶颈</p><h2 id="使用-kafka-集群需要注意什么？"><a href="#使用-kafka-集群需要注意什么？" class="headerlink" title="使用 kafka 集群需要注意什么？"></a>使用 kafka 集群需要注意什么？</h2><p>集群的数量不是越多越好，<strong>最好不要超过 7 个</strong>，因为<strong>节点越多</strong>，消息复制需要的时间就越长，<strong>整个群组的吞吐量就越低</strong>。<br>集群数量最好是<strong>单数</strong>，因为<strong>超过一半故障集群就不能用了，设置为单数容错率更高</strong>。</p><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="zookeeper-是什么？"><a href="#zookeeper-是什么？" class="headerlink" title="zookeeper 是什么？"></a>zookeeper 是什么？</h2><p>‌<strong>ZooKeeper</strong>‌是一个开源的<strong>分布式协调服务</strong>，由<code>Apache</code>开发。它主要用于<strong>解决分布式系统中的一致性问题</strong>，如配置管理、节点选举和分布式锁等‌。<code>ZooKeeper</code>的<strong>主要功能</strong>包括：</p><ul><li>‌<strong>配置管理</strong>‌：集中管理分布式系统中的配置信息。</li><li>‌<strong>命名服务</strong>‌：提供唯一的命名服务，帮助分布式系统中的服务发现，客户端能根据指定名字获取资源或服务的地址，提供者等信息。</li><li>‌<strong>分布式锁</strong>‌：实现分布式环境中的锁机制。<code>zookeeper</code> 提供两种锁：<strong>独占锁、共享锁</strong>。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可有多个线程同时读同一个资源，若要使用写锁也只能有一个线程使用。</li><li>‌<strong>集群管理</strong>‌：管理集群中的节点，<strong>确保数据的一致性和系统的可靠性</strong>。监控节点存活状态、运行请求等。</li><li><strong>主节点选举：</strong>主节点挂掉了之后可以从备用的节点开始<strong>新一轮选主</strong>，使用 zookeeper 可以协助完成这个过程。</li></ul><h2 id="zookeeper-有几种部署模式？-三种"><a href="#zookeeper-有几种部署模式？-三种" class="headerlink" title="zookeeper 有几种部署模式？(三种)"></a>zookeeper 有几种部署模式？(三种)</h2><p><strong>单机部署：</strong>一台集群上运行；<br><strong>集群部署：</strong>多台集群运行；<br><strong>伪集群部署：</strong>一台集群启动多个 zookeeper 实例运行。</p><h2 id="zookeeper-怎么保证主从节点的状态同步？"><a href="#zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="zookeeper 怎么保证主从节点的状态同步？"></a>zookeeper 怎么保证主从节点的状态同步？</h2><p><code>zookeeper</code> 的核心是<strong>原子广播</strong>，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。<code>zab 协议</code>有两种模式，分别是<strong>恢复模式（选主）和广播模式（同步）</strong>。<em>当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了</em>。状态同步保证了 <code>leader</code> 和 <code>server</code> 具有相同的系统状态。</p><h2 id="集群中为什么要有主节点？"><a href="#集群中为什么要有主节点？" class="headerlink" title="集群中为什么要有主节点？"></a>集群中为什么要有主节点？</h2><p>在分布式环境中，<strong>有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果</strong>，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p><h2 id="集群中有-3-台服务器，一个节点宕机了，zookeeper-还可以用吗？"><a href="#集群中有-3-台服务器，一个节点宕机了，zookeeper-还可以用吗？" class="headerlink" title="集群中有 3 台服务器，一个节点宕机了，zookeeper 还可以用吗？"></a>集群中有 3 台服务器，一个节点宕机了，zookeeper 还可以用吗？</h2><p>可以继续使用，<strong>单数服务器只要没超过一半的服务器宕机就可以继续使用</strong>。</p><h2 id="zookeeper-的通知机制？"><a href="#zookeeper-的通知机制？" class="headerlink" title="zookeeper 的通知机制？"></a>zookeeper 的通知机制？</h2><p><strong>客户端会对某个 <code>znode</code> 建立一个 <code>watcher</code> 事件</strong>，当该 <code>znode</code> 发生变化时，这些客户端会<strong>收到 zookeeper 的通知</strong>，然后客户端可以<strong>根据 znode 变化来做出业务上的改变</strong>。</p><h2 id="Kafka与ZooKeeper的关系"><a href="#Kafka与ZooKeeper的关系" class="headerlink" title="Kafka与ZooKeeper的关系"></a>Kafka与ZooKeeper的关系</h2><p><code>Kafka</code>依赖<code> ZooKeeper</code>来管理集群元数据、控制器选举和消费者组协调等任务。ZooKeeper 为 Kafka 提供了选主（<code>leader election</code>）、集群成员管理等核心功能，<strong>确保Kafka能够在多个节点之间进行有效的通信和管理‌</strong>。随着 Kafka 的发展，其对 ZooKeeper的依赖也带来了一些问题：</p><ul><li>‌<strong>复杂性增加</strong>‌：ZooKeeper 是一个独立的外部组件，增加了运维的复杂度。</li><li>‌<strong>性能瓶颈</strong>‌：在高负载情况下，ZooKeeper 可能成为系统的瓶颈，限制Kafka的扩展能力。</li><li>‌<strong>一致性问题</strong>‌：Kafka内部的一致性模型与 ZooKeeper 的一致性模型有所不同，可能导致状态不一致，影响系统的稳定性和消息传递的可靠性‌。</li></ul>]]></content>
    
    
    <summary type="html">‌Kafka 和 ZooKeeper 在分布式系统中扮演着不同的角色，并且它们之间有着紧密的合作关`</summary>
    
    
    
    <category term="中间件" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="分布式" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Kafka" scheme="https://southernfish.github.io/tags/Kafka/"/>
    
    <category term="Zookeeper" scheme="https://southernfish.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="https://southernfish.github.io/2025/06/19/database-sql/"/>
    <id>https://southernfish.github.io/2025/06/19/database-sql/</id>
    <published>2025-06-19T11:55:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。数据库软件有着整体性和共享性的特点。</p><h2 id="数据库的三范式是什么？"><a href="#数据库的三范式是什么？" class="headerlink" title="数据库的三范式是什么？"></a>数据库的三范式是什么？</h2><p><strong>第一范式：</strong>强调的是<strong>列的原子性</strong>，即数据库表的每一列都是不可分割的原子数据项。<br><strong>第二范式：</strong>要求实体的属性<strong>完全依赖于主关键字</strong>。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。<br><strong>第三范式：</strong>任何<strong>非主属性不依赖于其它非主属性</strong>。</p><h2 id="一自增表共-7-条数据，删了最后-2-条，重启-MySQL后插入一条，此时-id-？"><a href="#一自增表共-7-条数据，删了最后-2-条，重启-MySQL后插入一条，此时-id-？" class="headerlink" title="一自增表共 7 条数据，删了最后 2 条，重启 MySQL后插入一条，此时 id ？"></a>一自增表共 7 条数据，删了最后 2 条，重启 MySQL后插入一条，此时 id ？</h2><p>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p><h2 id="char-和-varchar-的区别是什么？"><a href="#char-和-varchar-的区别是什么？" class="headerlink" title="char 和 varchar 的区别是什么？"></a>char 和 varchar 的区别是什么？</h2><p><strong>char(n) ：</strong>固定长度类型，如 char(10)，当输入”abc”三个字符时，它们占的空间还是 10 个字节，其他 7 个是空字节。</p><ul><li><strong>优点：</strong>效率高；</li><li><strong>缺点：</strong>占用空间；</li><li><strong>适用场景：</strong>存储密码的 md5 值，固定长度的，使用 char 非常合适。</li></ul><p><strong>varchar(n) ：</strong>可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p><ul><li>从<strong>空间</strong>上考虑 varcahr 比较合适；</li><li>从<strong>效率</strong>上考虑 char 比较合适，二者使用需要权衡。</li></ul><h2 id="如何获取当前数据库版本？"><a href="#如何获取当前数据库版本？" class="headerlink" title="如何获取当前数据库版本？"></a>如何获取当前数据库版本？</h2><p>使用 select version() 获取当前 MySQL 数据库版本。</p><h2 id="float-和-double-的区别是什么？"><a href="#float-和-double-的区别是什么？" class="headerlink" title="float 和 double 的区别是什么？"></a>float 和 double 的区别是什么？</h2><p><strong><code>float</code></strong> 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br><strong><code>double</code></strong> 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p><h2 id="MySQL-的内连接、左连接、右连接有什么区别？"><a href="#MySQL-的内连接、左连接、右连接有什么区别？" class="headerlink" title="MySQL 的内连接、左连接、右连接有什么区别？"></a>MySQL 的内连接、左连接、右连接有什么区别？</h2><p>内连接：<code>inner join</code>；左连接：<code>left join</code>；右连接：<code>right join</code>。<br>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h2 id="怎么验证-MySQL-的索引是否满足需求？"><a href="#怎么验证-MySQL-的索引是否满足需求？" class="headerlink" title="怎么验证 MySQL 的索引是否满足需求？"></a>怎么验证 MySQL 的索引是否满足需求？</h2><p>使用 <code>explain</code> 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。<br><strong>explain 语法：</strong><code>explain select * from table where type=1</code>。</p><h2 id="数据库的事务隔离？"><a href="#数据库的事务隔离？" class="headerlink" title="数据库的事务隔离？"></a>数据库的事务隔离？</h2><p>MySQL 的事务隔离是在 <code>MySQL. ini</code> 配置文件里添加的，在文件的最后添加：<br>    transaction-isolation = REPEATABLE-READ<br><strong>可用的配置值：</strong><code>READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE</code>。</p><ul><li><code>READ-UNCOMMITTED</code>：<strong>读未提交</strong>，事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li><li><code>READ-COMMITTED</code>：<strong>读提交</strong>，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li><li><code>REPEATABLE-READ</code>：<strong>可重复读</strong>，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</li><li><code>SERIALIZABLE</code>：<strong>序列化</strong>，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><p><strong>脏读：</strong>表示一个事务能够读取另一个事务中还未提交的数据。<br><strong>不可重复读：</strong>是指在一个事务内，多次读同一数据。<br><strong>幻读：</strong>指同一个事务内多次查询返回的结果集不一样。发生<strong>幻读的原因</strong>是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所以数据行的记录就变多或者变少了。</p><ul><li><em>MySQL默认使用的是“可重复读”隔离级别，SQL标准的默认隔离级别是“读提交”</em>。</li><li>MySQL在“可重复读”级别下通过<strong>多版本并发控制（MVCC）机制避免幻读</strong>的问题。</li></ul><h2 id="MySQL-常用的引擎？"><a href="#MySQL-常用的引擎？" class="headerlink" title="MySQL 常用的引擎？"></a>MySQL 常用的引擎？</h2><p><code>InnoDB 引擎</code>：mysql 5.1 后默认的数据库引擎，提供了对数据库 <strong>acid 事务的支持</strong>，并且还提供了<strong>行级锁和外键的约束</strong>，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在<strong>内存中建立缓冲池，用于缓冲数据和索引</strong>。但该引擎<em>不支持全文搜索，同时启动也比较慢，它不会保存表的行数</em>，所以当进行 <code>select count(*) from table</code> 指令时，需要进行扫描全表。由于锁的粒度小，写操作不会锁定全表,所以<strong>在并发度较高的场景下使用会提升效率</strong>。<br><code>MyIASM 引擎</code>：<strong>不提供事务的支持，也不支持行级锁和外键</strong>。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是<strong>保存了表的行数</strong>，于是当进行 <code>select count(*) from table</code> 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p><h2 id="MySQL-的行锁和表锁？"><a href="#MySQL-的行锁和表锁？" class="headerlink" title="MySQL 的行锁和表锁？"></a>MySQL 的行锁和表锁？</h2><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。<br><strong>表级锁：</strong>开销小，加锁快，不会出现死锁。锁粒度大，发生锁冲突的概率最高，并发量最低。<br><strong>行级锁：</strong>开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高。</p><h2 id="乐观锁和悲观锁？"><a href="#乐观锁和悲观锁？" class="headerlink" title="乐观锁和悲观锁？"></a>乐观锁和悲观锁？</h2><p><strong>乐观锁：</strong>每次拿数据时都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br><strong>悲观锁：</strong>每次拿数据时都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。采用数据库自身的<code>for update</code>能力，对数据库表或者行增加锁<br><em>数据库的乐观锁需要自己实现</em>，在表里面<strong>添加一个 <code>version</code> 字段，每次修改成功值加 1</strong>，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><h2 id="MySQL-问题排查都有哪些手段？"><a href="#MySQL-问题排查都有哪些手段？" class="headerlink" title="MySQL 问题排查都有哪些手段？"></a>MySQL 问题排查都有哪些手段？</h2><p>使用 <code>show processlist</code> 命令查看当前所有连接信息。<br>使用 <code>explain</code> 命令查询 SQL 语句执行计划。<br>开启<strong>慢查询日志</strong>，查看慢查询的 SQL。</p><h2 id="如何做-SQL-优化？"><a href="#如何做-SQL-优化？" class="headerlink" title="如何做 SQL 优化？"></a>如何做 SQL 优化？</h2><p><strong>一、避免不走索引的场景</strong></p><ul><li>尽量<strong>避免在字段开头模糊查询</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>尽量**避免使用<code>not in</code>**，会导致引擎走全表扫描。</li><li>尽量<strong>避免使用 or</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>尽量<strong>避免进行null值的判断</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>尽量<strong>避免在where条件中等号的左侧进行表达式、函数操作</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>数据量大时，**避免使用<code>where 1 = 1</code>**。通常为方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引做全表扫描。</li><li>查询条件<strong>不能用 &lt;&gt; 或者 !=</strong></li><li>隐式类型转换造成不使用索引</li><li><strong><code>order by</code> 条件要与<code>where</code>中条件一致</strong>，否则order by不会利用索引进行排序</li><li><strong>正确使用<code>hint</code>优化语句</strong></li></ul><p><strong>二、SELECT语句其他优化</strong></p><ul><li><strong>避免出现select</strong></li><li><strong>避免出现不确定结果的函数</strong></li><li>多表关联查询时，<strong>小表在前，大表在后</strong>。</li><li>使用<strong>表的别名</strong></li><li>尽可能<strong>用<code>where</code>子句替换<code>HAVING</code>子句中的条件</strong></li></ul><h2 id="MySQL数据中有很多换行符和回车符怎么办？"><a href="#MySQL数据中有很多换行符和回车符怎么办？" class="headerlink" title="MySQL数据中有很多换行符和回车符怎么办？"></a>MySQL数据中有很多换行符和回车符怎么办？</h2><p><strong>换行符：</strong>CHAR(10) = “\n”<br><strong>回车符：</strong> CHAR(13) = “\r”<br>在MySQL中，回车符、换行符都属于char类型，放到varchar中时，在navcat等插件上是不显示的，需要在mysql终端和navcat对比才能看出来。</p><p><strong>如何去掉换行符、回车符</strong>。如果条件允许，建议<strong>直接通过语句清除掉换行符和回车符</strong>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 去除&quot;hero title&quot;列中所有换行符 (通过以下两种方式都可以)</span><br><span class="line">update &#x27;LOL&#x27; set hero_title = REPLACE(hero_title, &#x27;\n&#x27;, &#x27;&#x27;);</span><br><span class="line">update &#x27;LOL&#x27; set hero_title = REPLACE(hero_title, char(10), &#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">// 去除&quot;hero title&quot;列中所有回车符</span><br><span class="line">update &#x27;LOL&#x27; set hero_title = REPLACE(hero_title, &#x27;\r&#x27;, &#x27;&#x27;);</span><br><span class="line">update &#x27;LOL&#x27; set hero_title = REPLACE(hero_title, char(13),&#x27;&#x27;);</span><br></pre></td></tr></table></figure><p><strong>如何忽略”换行符、回车符”进行SELECT查询</strong>。条件不允许，不能动库里的数据。可以通过修改SQL来<strong>过滤掉换行符、回车符，但一定程度上会影响查询效率</strong>，而且要改很多代码，你懂得。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 忽略掉换行符查询</span><br><span class="line">SELECT * from &#x27;LOL&#x27; where REPLACE(hero_title, char(10), &#x27;&#x27;) = &#x27;换行符换行符换行符’; </span><br><span class="line">// 忽略掉回车符查询</span><br><span class="line">SELECT * from &#x27;LOL&#x27; where REPLACE(hero_title, char(13), &#x27;&#x27;) =&#x27;回车符回车符回车符’;</span><br><span class="line">// 忽略掉换行符 &amp; 回车符查询</span><br><span class="line">SELECT * from &#x27;LOL&#x27; where REPLACE(REPLACE(hero_title, char(13), &#x27;&#x27;), char(18),&#x27;&#x27;) = &#x27;回车符回车符回车符’;</span><br></pre></td></tr></table></figure><h2 id="int-20-中20的涵义"><a href="#int-20-中20的涵义" class="headerlink" title="int(20)中20的涵义"></a>int(20)中20的涵义</h2><p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；<br>不影响内部存储，只是<strong>影响带 zerofill 定义的 int 时，前面补多少个 0</strong>，易于报表展示</p><h2 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h2><ul><li>数据定义语言DDL（<code>Data Definition Language</code>）CREATE，DROP，ALTER<ul><li>对<strong>逻辑结构</strong>等有操作的，其中包括表结构，视图和索引。</li></ul></li><li>数据查询语言DQL（<code>Data Query Language</code>）SELEC<ul><li>即<strong>查询</strong>操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</li></ul></li><li>数据操纵语言DML（<code>Data Manipulation Language</code>）INSERT，UPDATE，DELETE<ul><li>对<strong>数据</strong>进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。</li></ul></li><li>数据控制功能DCL（<code>Data Control Languag</code>e）GRANT，REVOKE，COMMIT，ROLLBACK<ul><li>对<strong>数据库安全性完整性</strong>等有操作的，可以简单的理解为<strong>权限控制</strong>等。</li></ul></li></ul><h2 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a>SQL 约束有哪几种？</h2><p><code>NOT NULL</code>：用于控制字段的内容一定不能为空（NULL）。<br><code>UNIQUE</code>：控件<strong>字段内容不能重复</strong>，一个表<strong>允许有多个 Unique 约束</strong>。<br><code>PRIMARY KEY</code>：控件<strong>字段内容不能重复</strong>，但它在一个表只允许出现一个。<br><code>FOREIGN KEY</code>：用于<strong>预防破坏表之间连接的动作，也能防止非法数据插入外键列</strong>，因为它必须是它指向表中的值之一。<br><code>CHECK</code>：用于<strong>控制字段的值范围</strong>。</p><h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><p>在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p><table><thead><tr><th></th><th><strong>delete</strong></th><th><strong>truncate</strong></th><th><strong>drop</strong></th></tr></thead><tbody><tr><td>类型</td><td>DML</td><td>DDL</td><td>DDL</td></tr><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除表的全部或者一部分数据行，不释放空间，不重置自增列</td><td>表结构还在，删除表方全部数据，重置自增列，释放空间</td><td>删除表结构、数据、索引、约束等全部内容，释放空间，表不复存在</td></tr></tbody></table><h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><h2 id="ACID-是什么？"><a href="#ACID-是什么？" class="headerlink" title="ACID 是什么？"></a>ACID 是什么？</h2><p><strong><code>Atomicity</code>（原子性）：</strong>一个事务（<code>transaction</code>）中的所有操作，<strong>或全部完成，或全部不完成</strong>，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（<code>Rollback</code>）到事务开始前的状态，就像这个事务从来没有执行过一样。即<strong>事务不可分割、不可约简</strong>。<br><strong><code>Consistency</code>（一致性）：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示<strong>写入的资料必须完全符合所有的预设约束、触发器、级联回滚</strong>等。<br><strong><code>Isolation</code>（隔离性）：</strong>数据库<strong>允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致</strong>。事务隔离分为不同级别，包括读未提交（<code>Read uncommitted</code>）、读提交（<code>read committed</code>）、可重复读（<code>repeatable read</code>）和串行化（<code>Serializable</code>）。<br><strong><code>Durability</code>（持久性）：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</p><h2 id="ACID-原子性：MySQL通过使用日志文件来实现事务的原子性？"><a href="#ACID-原子性：MySQL通过使用日志文件来实现事务的原子性？" class="headerlink" title="ACID-原子性：MySQL通过使用日志文件来实现事务的原子性？"></a>ACID-原子性：MySQL通过使用日志文件来实现事务的原子性？</h2><p><strong>日志刷盘</strong><br>当一个事务开始时，InnoDB会为该事务分配一个<strong>唯一事务ID</strong>，并开始<strong>记录重做日志和回滚日志</strong>。随着事务的执行，所有的数据修改都会<strong>先写入到重做日志缓冲区</strong>中，然后在适当时机，<strong>这些修改会被刷新到磁盘上的重做日志文件中</strong>。如果系统崩溃，重做日志将被用来重做事务，确保事务的修改被应用到数据库中。<br><strong>Redo Log</strong><br>事务执行过程中发生错误或系统故障时，如果数据修改已经写入重做日志缓冲区中，在适当的时机（系统恢复时），这些修改会被刷新到磁盘上的重做日志文件中。<br><strong>Undo Log</strong><br>在事务执行过程中发生错误或系统故障，且无法通过**<code>Redo Log</code>** 保证数据一致性和完整性，MySQL将<strong>利用日志来回滚事务中的所有操作</strong>，保证数据库的原子性不被破坏。</p><h2 id="ACID-一致性：MySQL通过几种机制来保证数据的一致性？"><a href="#ACID-一致性：MySQL通过几种机制来保证数据的一致性？" class="headerlink" title="ACID-一致性：MySQL通过几种机制来保证数据的一致性？"></a>ACID-一致性：MySQL通过几种机制来保证数据的一致性？</h2><p><strong>约束（<code>Constraints</code>）：</strong>MySQL允许定义各种约束（如<strong>主键约束、外键约束、唯一约束</strong>等），这些约束直接作用于数据表上，确保数据的完整性和一致性。<br><strong>事务隔离级别（<code>Transaction Isolation Levels</code>）：</strong>通过合理选择事务隔离级别，可以在并发环境下有效地维护数据的一致性。读未提交（<code>Read Uncommitted</code>）、读提交（<code>Read Committed</code>）、可重复读（<code>Repeatable Read</code>）、串行化（<code>Serializable</code>）<br><strong>锁定机制（<code>Locking Mechanisms</code>）：</strong>MySQL使用锁定机制来<strong>控制对数据的并发访问</strong>，包括<em>行级锁（<code>Row-Level Locks</code>）、表级锁（<code>Table Locks</code>）</em>等，以确保在并发事务中数据的一致性和完整性。<br><strong>原子性操作（<code>Atomic Operations</code>）：</strong>MySQL通过原子性操作确保事务中的所有操作<strong>要么全部成功，要么全部失败</strong>，从而保持数据的一致性。</p><h2 id="ACID-持久性：MySQL中保证数据持久性的技术？"><a href="#ACID-持久性：MySQL中保证数据持久性的技术？" class="headerlink" title="ACID-持久性：MySQL中保证数据持久性的技术？"></a>ACID-持久性：MySQL中保证数据持久性的技术？</h2><ul><li>日志文件<ul><li><strong>重做日志（<code>Redo Log</code>）：</strong>InnoDB存储引擎使用重做日志来保证事务的持久性。事务提交时，事务所做的所有<strong>修改都会被记录到重做日志</strong>中。即使数据库发生崩溃，重做日志也可以在重启后被用来重放这些修改，确保数据的持久性。</li><li><strong>二进制日志（<code>Binary Log</code>）：</strong>MySQL服务器使用<strong>二进制日志记录所有修改数据库数据的操作</strong>，如<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>等。二进制日志不仅对数据恢复至关重要，也是复制和增量备份的基础。</li></ul></li><li>备份策略<ul><li><strong>全量备份：</strong>定期对整个数据库进行完整备份，以确保数据的持久性和可恢复性。</li><li><strong>增量备份：仅备份自上次备份以来发生变化的数据</strong>。与全量备份结合使用，可以有效减少数据恢复时间和存储需求。</li><li><strong>点对点恢复（<code>Point-in-Time Recovery, PITR</code>）：</strong>使用二进制日志实现，可以<strong>将数据库恢复到特定时间点的状态</strong>，非常适合处理操作错误或数据损坏的情况。</li></ul></li></ul><h2 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h2><p>有三种格式，statement，row和mixed。</p><ul><li><strong><code>statement</code>模式</strong>下，每一条会<strong>修改数据的sql都会记录在<code>binlog</code>中</strong>。不需要记录每一行的变化，<strong>减少了binlog日志量，节约了IO，提高性能</strong>。由于sql的执行是有上下文的，因此在<strong>保存的时候需要保存相关的信息</strong>，同时还有一些使用了函数之类的语句无法被记录复制。</li><li><strong><code>row</code>级别</strong>下，不记录sql语句上下文相关信息，仅<strong>保存哪条记录被修改。记录单元为每一行的改动</strong>，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件<strong>保存的信息太多，日志量太大</strong>。</li><li><strong><code>mixed</code><strong>，一种折中的方案，</strong>普通操作使用statement记录，当无法使用statement的时候使用row</strong>。</li></ul><p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="MySQL-索引是怎么实现的？"><a href="#MySQL-索引是怎么实现的？" class="headerlink" title="MySQL 索引是怎么实现的？"></a>MySQL 索引是怎么实现的？</h2><p>索引是<strong>满足某种特定查找算法的数据结构</strong>，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 <strong><code>B+ 树</code><strong>实现的，</strong><code>B+ 树</code>的搜索效率，可到达二分法的性能</strong>，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p><h2 id="创建索引的原则有哪些？"><a href="#创建索引的原则有哪些？" class="headerlink" title="创建索引的原则有哪些？"></a>创建索引的原则有哪些？</h2><ul><li><strong>最左前缀匹配原则</strong>，组合索引非常重要的原则，mysql会一直**向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配**，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li><strong>较频繁作为查询条件的字段</strong>才去创建索引</li><li>更新频繁字段不适合创建索引</li><li><strong>不能有效区分数据的列不适合做索引列</strong>(如性别，男女未知，最多也就三种，区分度实在太低)</li><li>尽量的<strong>扩展索引，不要新建索引</strong>。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li><li><strong>定义有外键的数据列</strong>一定要建立索引。</li><li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li><li>对于定义为text、image和bit的数据类型的列不要建立索引。</li></ul><h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><h1 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h1><p><strong><code>InnoDB</code>索引是聚簇索引</strong>，MyISAM索引是非聚簇索引。<br><code>InnoDB</code>的<strong>主键索引的叶子节点存储着行数据</strong>，因此主键索引非常高效。<br><strong><code>MyISAM</code>索引的叶子节点存储的是行数据地址</strong>，需要再寻址一次才能得到数据。<br><strong>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据</strong>，因此查询时做到覆盖索引会非常高效。</p><h2 id="mysql-innodb存储引擎的特点"><a href="#mysql-innodb存储引擎的特点" class="headerlink" title="mysql innodb存储引擎的特点"></a>mysql innodb存储引擎的特点</h2><p><strong>事务支持：</strong>InnoDB支持ACID事务属性。<br><strong>崩溃恢复</strong>：InnoDB会<strong>将数据写入到磁盘上的日志文件</strong>中，即使在系统崩溃的情况下，也能通过这些日志文件恢复数据。<br><strong>MVCC (多版本并发控制)：</strong>InnoDB使用多版本并发控制，这允许更高的并发性。<br><strong>外键约束：</strong>InnoDB支持外键约束，这对于维护数据库的引用完整性非常有用。<br><strong>行级锁定：</strong>与表级锁定相比，InnoDB<strong>支持行级锁定，提供了更高的并发性能</strong>。<br><strong>自适应哈希索引：</strong>InnoDB会<strong>自动为频繁访问的热点数据创建哈希索引，以提高查询速度</strong>。</p><h2 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h2><p>推荐使用自增ID，不要使用UUID。<br>在InnoDB存储引擎中，主键索引是作为<strong>聚簇索引</strong>存在的，主键索引的<code>B+树</code>叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，只需要不断向后排列即可，如果是*<code>UUID</code>，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降*。<br>总之，在数据量大一些的情况下，用自增主键性能会好一些。<br>主键是聚簇索引，若没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个<strong>隐式的主键</strong>。</p><h2 id="如何使用InnoDB？"><a href="#如何使用InnoDB？" class="headerlink" title="如何使用InnoDB？"></a>如何使用InnoDB？</h2><p>在创建表时指定使用InnoDB存储引擎，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE example (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h2 id="优化InnoDB性能的技巧"><a href="#优化InnoDB性能的技巧" class="headerlink" title="优化InnoDB性能的技巧"></a>优化InnoDB性能的技巧</h2><p><strong>配置<code>innodb_buffer_pool_size</code>：控制InnoDB缓存数据和索引的内存大小</strong>。通常设置为系统内存的50%-80%。<br><strong>调整<code>innodb_log_file_size</code>：增加日志文件的大小可以减少日志磁盘写入次数</strong>，但需要确保磁盘I/O足够快。<br><strong>使用合适的索引：</strong>确保对查询进行优化的索引。<br><strong>监控和调整<code>innodb_io_capacity</code>：</strong>这个参数<strong>控制后台I/O操作的速率</strong>，需要根据实际的磁盘I/O性能进行调整。<br><strong>批量操作：</strong>大量插入、更新或删除操作时，尽量使用<strong>事务批量处理，减少对数据库的冲击</strong>。</p><h2 id="InnoDB常见问题及解决方案？"><a href="#InnoDB常见问题及解决方案？" class="headerlink" title="InnoDB常见问题及解决方案？"></a>InnoDB常见问题及解决方案？</h2><p><strong>性能问题：</strong>若发现InnoDB性能不佳，<strong>先检查是否有足够的内存分配给<code>innodb_buffer_pool_size</code>，以及磁盘I/O是否成为瓶颈</strong>。<br><strong>锁等待：</strong>高并发下，锁等待可能导致性能下降。可<strong>通过<code>SHOW ENGINE INNODB STATUS</code>查看锁等待情况</strong>，并考虑优化查询或增加索引。<br><strong>死锁：</strong>死锁是多个事务相互等待对方释放资源的情况。MySQL会检测到死锁并自动回滚其中一个事务以解除死锁。可以<strong>通过<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>表来诊断死锁</strong>。</p><h1 id="业务相关"><a href="#业务相关" class="headerlink" title="业务相关"></a>业务相关</h1><h2 id="导入数据后数据库数据重复原因及解决？"><a href="#导入数据后数据库数据重复原因及解决？" class="headerlink" title="导入数据后数据库数据重复原因及解决？"></a>导入数据后数据库数据重复原因及解决？</h2><p><strong>表象原因：</strong>如<em>网络延迟、用户连点、并发</em>等<br><strong>本质原因：</strong>在<em>数据库设计、及代码逻辑的严谨性</em>出了问题。</p><p><strong>前端解决方案（不可靠，推荐）</strong><br>    <em>用户点击按钮后，让按钮点击失效或者禁用</em>，待后端响应完成后，按钮可用<br><strong>数据库解决方案(可靠，推荐，适合高并发场景)</strong></p><ul><li>幂等主要手段就是通过表中的<strong>唯一约束</strong>实现。</li><li>添加表的<strong>唯一约束或唯一索引</strong>进行约束处理，是最有效的防治重复提交的方法</li><li>MySql 避免”重复插入记录”的方法：<code>INSERT ignore into，Replace into，ON DUPLICATE KEY UPDATE</code></li><li>使用 <code>ignore</code> 关键字，若用主键 <code>primary</code>或唯一索引 <code>unique</code> 区分了记录的唯一性，避免重复插入记录可以使用</li></ul><p><strong>悲观锁解决方案(可靠，推荐，适合高并发场景)</strong></p><ul><li><strong>悲观锁：</strong>以一种预防的姿态在<strong>修改数据之前把数据锁住</strong>，再对数据进行读写，<strong>释放锁之前任何人都不能对其数据进行操作</strong>，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，才可以对数据进行操作，一般数据库本身锁的机制都基于悲观锁;</li><li><strong>特点：</strong>可以完全<strong>保证数据的独占性和正确性</strong>，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</li></ul><p><strong>幂等：</strong>其任意多次执行所产生的影响均与一次执行的影响相同<br><strong>需要幂等的场景:</strong></p><ul><li><strong>核心业务数据新增</strong>，如订单系统中新增订单、用户信息系统中新增用户；</li><li><strong>审批流系统多人审批同一数据</strong>时，可能导致审批多次。</li><li><strong>定时任务触发</strong>数据生成时可能重复触发，导致数据生成多次。</li></ul>]]></content>
    
    
    <summary type="html">‌数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。数据库软件有着整体性和共享性的特点。</summary>
    
    
    
    <category term="中间件" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="Database" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件</title>
    <link href="https://southernfish.github.io/2025/06/19/message-queue-middleware/"/>
    <id>https://southernfish.github.io/2025/06/19/message-queue-middleware/</id>
    <published>2025-06-19T10:15:36.000Z</published>
    <updated>2025-06-19T13:36:26.090Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于RabbitMQ的问题</p><h2 id="RabbitMQ-的使用场景有哪些？"><a href="#RabbitMQ-的使用场景有哪些？" class="headerlink" title="RabbitMQ 的使用场景有哪些？"></a>RabbitMQ 的使用场景有哪些？</h2><p><strong>抢购活动，削峰填谷，防止系统崩塌</strong>。<br><strong>延迟信息处理</strong>，比如 10 分钟之后给下单未付款的用户<strong>发送邮件提醒</strong>。<br><strong>解耦系统</strong>，对于<strong>新增的功能可以单独写模块扩展</strong>，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p><h2 id="RabbitMQ-有哪些重要的角色？"><a href="#RabbitMQ-有哪些重要的角色？" class="headerlink" title="RabbitMQ 有哪些重要的角色？"></a>RabbitMQ 有哪些重要的角色？</h2><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p><ul><li><strong>生产者：</strong>消息的创建者，负责<strong>创建和推送数据</strong>到消息服务器；</li><li><strong>消费者：</strong>消息的接收方，用于<strong>处理数据和确认消息</strong>；</li><li><strong>代理：</strong>就是 <strong><code>RabbitMQ</code> 本身</strong>，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li></ul><h2 id="RabbitMQ-有哪些重要的组件？"><a href="#RabbitMQ-有哪些重要的组件？" class="headerlink" title="RabbitMQ 有哪些重要的组件？"></a>RabbitMQ 有哪些重要的组件？</h2><p><code>ConnectionFactory</code>（连接管理器）：<strong>应用程序与Rabbit之间建立连接的管理器</strong>，程序代码中使用。<br><code>Channel</code>（信道）：<strong>消息推送使用的通道</strong>。<br><code>Exchange</code>（交换器）：用于<strong>接受、分配消息</strong>。<br><code>Queue</code>（队列）：用于<strong>存储</strong>生产者的消息。<br><code>RoutingKey</code>（路由键）：用于把生成者的数据<strong>分配到交换器</strong>上。<br><code>BindingKey</code>（绑定键）：用于<strong>把交换器的消息绑定到队列</strong>上。</p><h2 id="RabbitMQ-中-vhost-的作用是什么？"><a href="#RabbitMQ-中-vhost-的作用是什么？" class="headerlink" title="RabbitMQ 中 vhost 的作用是什么？"></a>RabbitMQ 中 vhost 的作用是什么？</h2><p><strong>vhost：</strong>每个 RabbitMQ 都能创建很多 <code>vhost</code>，我们称之为<strong>虚拟主机</strong>，每个虚拟主机其实都是 <strong>mini 版的RabbitMQ</strong>，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p><h2 id="RabbitMQ-的消息是怎么发送的？"><a href="#RabbitMQ-的消息是怎么发送的？" class="headerlink" title="RabbitMQ 的消息是怎么发送的？"></a>RabbitMQ 的消息是怎么发送的？</h2><p>首先客户端必须<strong>连接到 <code>RabbitMQ</code> 服务器</strong>才能发布和消费消息，<strong>客户端和 <code>rabbit server</code> 之间会创建一个 <code>tcp 连接</code><strong>，一旦 <strong><code>tcp</code> 打开并通过了认证</strong>（认证就是你发送给 rabbit 服务器的用户名和密码），你的</strong>客户端和 <code>RabbitMQ</code> 就创建了一条 <code>amqp 信道</code>（channel）</strong>，信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p><h2 id="RabbitMQ-怎么保证消息的稳定性？"><a href="#RabbitMQ-怎么保证消息的稳定性？" class="headerlink" title="RabbitMQ 怎么保证消息的稳定性？"></a>RabbitMQ 怎么保证消息的稳定性？</h2><p>提供了<strong>事务</strong>的功能。<br>通过<strong>将 <code>channel</code> 设置为 <code>confirm</code>（确认）模式</strong>。</p><h2 id="RabbitMQ-怎么避免消息丢失？"><a href="#RabbitMQ-怎么避免消息丢失？" class="headerlink" title="RabbitMQ 怎么避免消息丢失？"></a>RabbitMQ 怎么避免消息丢失？</h2><ul><li><strong>把消息持久化磁盘</strong>，保证服务器重启消息不丢失。</li><li><strong>每个集群中至少有一个物理磁盘，保证消息落入磁盘</strong>。</li></ul><h2 id="要保证消息持久化成功的条件有哪些？"><a href="#要保证消息持久化成功的条件有哪些？" class="headerlink" title="要保证消息持久化成功的条件有哪些？"></a>要保证消息持久化成功的条件有哪些？</h2><p><strong>声明队列</strong>必须<strong>设置持久化 <code>durable</code> 设置为 <code>true</code><strong>。<br><strong>消息推送投递模式</strong>必须设置持久化，</strong><code>deliveryMode</code> 设置为 2（持久）</strong>。<br>消息<strong>已经到达持久化交换器</strong>。<br>消息<strong>已经到达持久化队列</strong>。<br>以上四个条件都满足才能保证消息持久化成功。</p><h2 id="RabbitMQ-持久化有什么缺点？"><a href="#RabbitMQ-持久化有什么缺点？" class="headerlink" title="RabbitMQ 持久化有什么缺点？"></a>RabbitMQ 持久化有什么缺点？</h2><p>持久化的缺点就是<strong>降低了服务器的吞吐量</strong>，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可**尽量使用 <code>ssd 硬盘</code>**来缓解吞吐量的问题。</p><h2 id="RabbitMQ-有几种广播类型？"><a href="#RabbitMQ-有几种广播类型？" class="headerlink" title="RabbitMQ 有几种广播类型？"></a>RabbitMQ 有几种广播类型？</h2><p><code>direct</code>（默认方式）：最基础最简单的模式，<strong>发送方把消息发送给订阅方</strong>，针对多个订阅者，<strong>默认采取轮询方式进行消息发送</strong>。<br><code>headers</code>：与 <code>direct</code> 类似，只是性能很差，此类型几乎用不到。<br><code>fanout</code>：<strong>分发模式</strong>，把消息<strong>分发给所有订阅者</strong>。<br><code>topic</code>：<strong>匹配订阅模式</strong>，使用<strong>正则匹配</strong>到消息队列，能匹配到的都能接收到。</p><h2 id="RabbitMQ-怎么实现延迟消息队列？"><a href="#RabbitMQ-怎么实现延迟消息队列？" class="headerlink" title="RabbitMQ 怎么实现延迟消息队列？"></a>RabbitMQ 怎么实现延迟消息队列？</h2><p>延迟队列的实现有两种方式：</p><ul><li>通过<strong>消息过期后进入死信交换器，再由交换器转发到延迟消费队列</strong>，实现延迟功能；</li><li>使用 <code>RabbitMQ-delayed-message-exchange</code> 插件实现延迟功能。</li></ul><h2 id="RabbitMQ-集群有什么用？"><a href="#RabbitMQ-集群有什么用？" class="headerlink" title="RabbitMQ 集群有什么用？"></a>RabbitMQ 集群有什么用？</h2><p>集群主要有以下两个用途：</p><ul><li><strong>高可用：</strong>某个服务器出现问题，整个 <code>RabbitMQ</code> 还可以继续使用；</li><li><strong>高容量：</strong>集群可以承载更多的消息量。</li></ul><h2 id="RabbitMQ-节点的类型有哪些？"><a href="#RabbitMQ-节点的类型有哪些？" class="headerlink" title="RabbitMQ 节点的类型有哪些？"></a>RabbitMQ 节点的类型有哪些？</h2><p><strong>磁盘节点：</strong>消息会存储到磁盘。<br><strong>内存节点：</strong>消息都存储在内存中，<strong>重启服务器消息丢失，性能高于磁盘类型</strong>。</p><h2 id="RabbitMQ-集群搭建需要注意哪些问题？"><a href="#RabbitMQ-集群搭建需要注意哪些问题？" class="headerlink" title="RabbitMQ 集群搭建需要注意哪些问题？"></a>RabbitMQ 集群搭建需要注意哪些问题？</h2><p>各<strong>节点之间使用<code>“–link”</code>连接</strong>，此属性不能忽略。<br>各节点使用的 <strong><code>erlang cookie</code> 值必须相同</strong>，此值相当于“秘钥”的功能，<strong>用于各节点的认证</strong>。<br><strong>整个集群中必须包含一个磁盘节点</strong>。</p><h2 id="RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h2><p>不是，原因有以下两个：</p><ul><li><strong>存储空间的考虑：</strong>若每个节点都拥有所有队列的完全拷贝，新增节点不但没有新增存储空间，反而<strong>增加了冗余数据</strong>；</li><li><strong>性能的考虑：</strong>若每条消息都需要完整拷贝到每一个集群节点，那新增节点并<strong>没有提升处理消息的能力</strong>，最多是保持和单节点相同的性能<strong>甚至是更糟</strong>。</li></ul><h2 id="RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h2><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p><ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li></ul><p>唯一磁盘节点崩溃了，<strong>集群可以保持运行，但不能更改任何东西</strong></p><h2 id="RabbitMQ-对集群节点停止顺序有要求吗？"><a href="#RabbitMQ-对集群节点停止顺序有要求吗？" class="headerlink" title="RabbitMQ 对集群节点停止顺序有要求吗？"></a>RabbitMQ 对集群节点停止顺序有要求吗？</h2><p><code>RabbitMQ</code> 对集群的停止顺序是有要求的，应该<strong>先关闭内存节点，最后再关闭磁盘节点。若顺序恰好相反的话，可能会造成消息的丢失</strong>。</p>]]></content>
    
    
    <summary type="html">简单记录一些关于消息中间件的问题</summary>
    
    
    
    <category term="中间件" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="MQ" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/"/>
    
    
    <category term="RabbitMQ" scheme="https://southernfish.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="https://southernfish.github.io/2025/06/19/mybatis/"/>
    <id>https://southernfish.github.io/2025/06/19/mybatis/</id>
    <published>2025-06-19T09:25:36.000Z</published>
    <updated>2025-06-19T13:36:26.090Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于MyBatis的问题</p><h2 id="MyBatis-中-和-的区别是什么？"><a href="#MyBatis-中-和-的区别是什么？" class="headerlink" title="MyBatis 中 #{}和 ${}的区别是什么？"></a>MyBatis 中 #{}和 ${}的区别是什么？</h2><p><code>\#&#123;&#125;</code>是预编译处理，<code>$&#123;&#125;</code>是字符替换。在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 <code>PreparedStatement</code> 的 set 方法赋值，这样可以有效防止 SQL 注入，保证程序的运行安全。</p><h2 id="MyBatis-有几种分页方式？"><a href="#MyBatis-有几种分页方式？" class="headerlink" title="MyBatis 有几种分页方式？"></a>MyBatis 有几种分页方式？</h2><p><strong>分页方式：</strong>逻辑分页和物理分页。</p><ul><li><strong>逻辑分页：</strong>使用 <code>MyBatis</code> 自带的 <code>RowBounds</code> 进行分页，它是<strong>一次性查询很多数据，然后在数据中再进行检索</strong>。</li><li><strong>物理分页：</strong>手写 SQL 分页或使用分页插件 <code>PageHelper</code>，去数据库<strong>查询指定条数的分页数据</strong>的形式。</li></ul><h2 id="MyBatis-逻辑分页和物理分页的区别是什么？"><a href="#MyBatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="MyBatis 逻辑分页和物理分页的区别是什么？"></a>MyBatis 逻辑分页和物理分页的区别是什么？</h2><p><strong>逻辑分页</strong>是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是<strong>需要消耗大量的内存、有内存溢出的风险、对数据库压力较大</strong>。<br><strong>物理分页</strong>是从数据库<strong>查询指定条数的数据</strong>，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</p><h2 id="RowBounds-是一次性查询全部结果吗？为什么？"><a href="#RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="RowBounds 是一次性查询全部结果吗？为什么？"></a>RowBounds 是一次性查询全部结果吗？为什么？</h2><p><code>RowBounds</code> 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 <em>MyBatis 是对 jdbc 的封装</em>，<strong>在 jdbc 驱动中有一个 <code>Fetch Size</code> 的配置，它规定了每次最多从数据库查询多少条数据</strong>，假如你要查询更多数据，它会在你<strong>执行 next()的时候，去查询更多的数据</strong>。<br>就好比去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()时会自动完成查询工作。这样做的好处可以<strong>有效防止内存溢出</strong>。</p><h2 id="MyBatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#MyBatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="MyBatis 是否支持延迟加载？延迟加载的原理是什么？"></a>MyBatis 是否支持延迟加载？延迟加载的原理是什么？</h2><p><code>MyBatis</code> 支持延迟加载，设置 <code>lazyLoadingEnabled=true</code> 。<br><strong>延迟加载的原理</strong>是<strong>调用的时候触发加载</strong>，而不是在初始化的时候就加载信息。<br>比如调用 <code>a. getB(). getName()</code>，这个时候发现 <code>a. getB()</code> 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 <code>a. setB(b)</code>，而这时候再调用 <code>a. getB(). getName()</code> 就有值了，这就是延迟加载的基本原理。</p><h2 id="MyBatis-的一级缓存和二级缓存？"><a href="#MyBatis-的一级缓存和二级缓存？" class="headerlink" title="MyBatis 的一级缓存和二级缓存？"></a>MyBatis 的一级缓存和二级缓存？</h2><p><strong>一级缓存：基于 <code>PerpetualCache</code> 的 <code>HashMap</code> 本地缓存</strong>，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，<strong>可能会出现脏数据</strong>。<strong>当 <code>Session flush 或 close</code> 之后，该 Session 中的所有 Cache 就将清空</strong>，默认一级缓存是开启的。<br><strong>二级缓存：</strong>也是<strong>基于 <code>PerpetualCache</code> 的 <code>HashMap</code> 本地缓存</strong>，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，**要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)**。<br><strong>开启二级缓存数据查询流程：</strong><code>二级缓存 -&gt; 一级缓存 -&gt; 数据库</code>。<br><strong>缓存更新机制：</strong>当某一个作用域(一级缓存 Session/二级缓存 Mapper)<strong>进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear</strong>。</p><h2 id="MyBatis-和-hibernate-的区别有哪些？"><a href="#MyBatis-和-hibernate-的区别有哪些？" class="headerlink" title="MyBatis 和 hibernate 的区别有哪些？"></a>MyBatis 和 hibernate 的区别有哪些？</h2><p><strong>灵活性：</strong>MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。<br><strong>可移植性：</strong><code>MyBatis</code> 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以<strong>可移植性比较差</strong>。<br><strong>学习和使用门槛：</strong>MyBatis 入门比较简单，使用门槛也更低。<br><strong>二级缓存：</strong><code>hibernate 拥有更好的二级缓存，可以自行更换为第三方的二级缓存</code>。</p><h2 id="MyBatis-有哪些执行器（Executor）？"><a href="#MyBatis-有哪些执行器（Executor）？" class="headerlink" title="MyBatis 有哪些执行器（Executor）？"></a>MyBatis 有哪些执行器（Executor）？</h2><p>MyBatis 有<strong>三种</strong>基本的Executor执行器：<br><strong><code>SimpleExecutor：</code><strong>每执行一次 <code>update 或 select</code> 就开启一个 <code>Statement</code> 对象，</strong>用完立刻关闭</strong> Statement 对象；<br><strong><code>ReuseExecutor：</code><strong>执行 <code>update 或 select</code>，</strong>以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建</strong>，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是<strong>重复使用 Statement 对象</strong>；<br>**<code>BatchExecutor：</code>*<em>执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（<code>addBatch()</code>），等待统一执行（<code>executeBatch()</code>），它</em>缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理*，与 jdbc 批处理相同。</p><h2 id="MyBatis-分页插件的实现原理是什么？"><a href="#MyBatis-分页插件的实现原理是什么？" class="headerlink" title="MyBatis 分页插件的实现原理是什么？"></a>MyBatis 分页插件的实现原理是什么？</h2><p>分页插件的基本原理是使用 <code>MyBatis</code> 提供的插件接口，实现自定义插件，<strong>在插件的拦截方法内拦截待执行的 SQL</strong>，然后重写 SQL，根据 <code>dialect</code> 方言，<strong>添加对应的物理分页语句和物理分页参数</strong>。</p><h2 id="MyBatis-如何编写一个自定义插件？"><a href="#MyBatis-如何编写一个自定义插件？" class="headerlink" title="MyBatis 如何编写一个自定义插件？"></a>MyBatis 如何编写一个自定义插件？</h2><h3 id="自定义插件实现原理"><a href="#自定义插件实现原理" class="headerlink" title="自定义插件实现原理"></a>自定义插件实现原理</h3><p>MyBatis 自定义插件针对 MyBatis 四大对象(<code>Executor</code>、<code>StatementHandler</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>)进行拦截：<br><strong>Executor：</strong>拦截<strong>内部执行器</strong>，它负责<strong>调用 <code>StatementHandler</code> 操作数据库，并把结果集通过 <code>ResultSetHandler</code> 进行自动映射，另外它还处理了二级缓存的操作</strong>；<br><strong>StatementHandler：</strong>拦截 <strong>SQL 语法构建的处理</strong>，它是 MyBatis 直接和数据库执行 <code>SQL 脚本</code>的对象，另外它也<strong>实现了 MyBatis 的一级缓存</strong>；<br><strong>ParameterHandler：</strong>拦截<strong>参数的处理</strong>；<br><strong>ResultSetHandler：</strong>拦截<strong>结果集的处理</strong>。</p><h3 id="自定义插件实现关键"><a href="#自定义插件实现关键" class="headerlink" title="自定义插件实现关键"></a>自定义插件实现关键</h3><p><code>MyBatis插件</code>要实现 <code>Interceptor</code> 接口，接口包含的方法，如下代码所示：<br><strong><code>setProperties</code> 方法：</strong>在 MyBatis 进行配置插件的时候可配置自定义相关属性，即：<strong>接口实现对象的参数配置</strong>；<br><strong><code>plugin</code> 方法：</strong>插件用于<strong>封装目标对象</strong>的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：<code>return Plugin. wrap(target, this)</code>；<br><strong><code>intercept</code> 方法：</strong>是要<strong>进行拦截的时候要执行的方法</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interfaceInterceptor&#123;</span><br><span class="line">  object intercept(Invocation invocation) throws Throwable;</span><br><span class="line">  object plugin(object target);</span><br><span class="line">  voidsetProperties(Properties properties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Intercepts(&#123;@signature(type = Executor.class, method = &quot;query&quot;, </span><br><span class="line">    args = &#123;Mappedstatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span><br><span class="line">publicclassTestInterceptorimplementsInterceptor &#123;</span><br><span class="line">  public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    Object target = invocation.getTarget(); //被代理对象</span><br><span class="line">    Method method = invocation.getMethod();//代理方法</span><br><span class="line">    Object[] args = invocation.getArgs() // 方法参数</span><br><span class="line">    // do something ...... 方法拦截前执行代码块</span><br><span class="line">    Object result =invocation.proceed():</span><br><span class="line">    // do something ...... 方法拦截后执行代码块</span><br><span class="line">    return result:</span><br><span class="line">  &#125;</span><br><span class="line">  public object plugin(object target)&#123;</span><br><span class="line">    return Plugin.wrap(target, this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">MyBatis</summary>
    
    
    
    <category term="框架" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="MyBatis" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/MyBatis/"/>
    
    
    <category term="MyBatis" scheme="https://southernfish.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate</title>
    <link href="https://southernfish.github.io/2025/06/19/hibernate/"/>
    <id>https://southernfish.github.io/2025/06/19/hibernate/</id>
    <published>2025-06-19T08:45:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于Hibernate的问题</p><h2 id="为什么要使用-hibernate？"><a href="#为什么要使用-hibernate？" class="headerlink" title="为什么要使用 hibernate？"></a>为什么要使用 hibernate？</h2><p><code>hibernate</code> 是<strong>对 jdbc 的封装</strong>，大大简化了数据访问层的繁琐的重复性代码。<br>hibernate 是一个优秀的 ORM 实现，很大程度上<strong>简化了 DAO 层的编码功能</strong>。<br>可以很<strong>方便的进行数据库的移植工作</strong>。<br><strong>提供了缓存机制</strong>，使程序执行更改的高效。</p><h2 id="什么是-ORM-框架？"><a href="#什么是-ORM-框架？" class="headerlink" title="什么是 ORM 框架？"></a>什么是 ORM 框架？</h2><p><code>ORM（Object Relation Mapping）</code>对象关系映射，是<strong>把数据库中的关系数据映射成为程序中的对象</strong>。<br><strong>使用 ORM 的优点：</strong>提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p><h2 id="hibernate-中如何在控制台查看打印的-SQL-语句？"><a href="#hibernate-中如何在控制台查看打印的-SQL-语句？" class="headerlink" title="hibernate 中如何在控制台查看打印的 SQL 语句？"></a>hibernate 中如何在控制台查看打印的 SQL 语句？</h2><p>在 <code>Config</code> 里面<strong>把 <code>hibernate. show_SQL</code> 设置为 <code>true</code></strong> 就可以。但不建议开启，<em>开启之后会降低程序的运行效率</em></p><h2 id="hibernate-有几种查询方式？"><a href="#hibernate-有几种查询方式？" class="headerlink" title="hibernate 有几种查询方式？"></a>hibernate 有几种查询方式？</h2><p><strong>三种：</strong><code>hql</code>、<code>原生 SQL</code>、<code>条件查询 Criteria</code></p><h2 id="hibernate-实体类可以被定义为-final-吗？"><a href="#hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="hibernate 实体类可以被定义为 final 吗？"></a>hibernate 实体类可以被定义为 final 吗？</h2><p>实体类可以定义为 final 类，但这样就<strong>不能使用 <code>hibernate 代理模式</code>下的延迟关联提供性能</strong>了，所以不建议定义实体类为 final。</p><h2 id="在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h2><p><code>Integer</code> 类型为对象，它的值允许为 null，而 <code>int</code> 属于基础数据类型，值不能为 null。</p><h2 id="hibernate-是如何工作的？"><a href="#hibernate-是如何工作的？" class="headerlink" title="hibernate 是如何工作的？"></a>hibernate 是如何工作的？</h2><p>读取并解析配置文件 → 读取并解析映射文件，创建 <code>SessionFactory</code> → 打开 <code>Session</code> → 创建事务 → 进行持久化操作 → 提交事务 → 关闭 <code>Session</code> → 关闭 <code>SessionFactory</code></p><h2 id="get-和-load-的区别？"><a href="#get-和-load-的区别？" class="headerlink" title="get()和 load()的区别？"></a>get()和 load()的区别？</h2><p>数据查询时，<strong>没有 <code>OID</code> 指定的对象，<code>get()</code> 返回 null；<code>load()</code> 返回一个代理对象</strong>。<br><strong><code>load()</code>支持延迟加载</strong>；<code>get()</code> 不支持延迟加载。</p><h2 id="hibernate-的缓存机制？"><a href="#hibernate-的缓存机制？" class="headerlink" title="hibernate 的缓存机制？"></a>hibernate 的缓存机制？</h2><p><strong>一级缓存：</strong>也叫 ·Session 缓存·，<strong>只在 Session 作用范围内有效</strong>，不需要用户干涉，由 hibernate 自身维护，<em>缓存清除方式</em>：</p><ul><li><code>evict(object)</code>清除 object 的缓存；</li><li><code>clear()</code>清除一级缓存中的所有缓存；</li><li><code>flush()</code>刷出缓存；</li></ul><p><strong>二级缓存：</strong>应用级别的缓存，<strong>在所有 Session 中都有效，支持配置第三方的缓存</strong>，如：EhCache。</p><h2 id="hibernate-对象有哪些状态？"><a href="#hibernate-对象有哪些状态？" class="headerlink" title="hibernate 对象有哪些状态？"></a>hibernate 对象有哪些状态？</h2><p><strong>临时/瞬时状态：直接new 出来的对象</strong>，该对象还没被持久化（没保存在数据库中），不受 Session 管理。<br><strong>持久化状态：</strong>调用 Session 的 <code>save/saveOrupdate/get/load/list</code> 等方法时，对象就是持久化状态。<br>**游离状态：<code>**Session</code> <strong>关闭之后</strong>对象就是游离状态。</p><h2 id="在-hibernate-中-getCurrentSession-和-openSession-的区别？"><a href="#在-hibernate-中-getCurrentSession-和-openSession-的区别？" class="headerlink" title="在 hibernate 中 getCurrentSession 和 openSession 的区别？"></a>在 hibernate 中 getCurrentSession 和 openSession 的区别？</h2><p><strong><code>getCurrentSession</code> 会绑定当前线程</strong>，而 openSession 则不会。<br><code>getCurrentSession</code> 事务是 Spring 控制的，并且不需要手动关闭，而 <strong><code>openSession</code> 需要手动开启和提交事务</strong>。</p><h2 id="hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="hibernate 实体类必须要有无参构造函数吗？为什么？"></a>hibernate 实体类必须要有无参构造函数吗？为什么？</h2><p><code>hibernate</code> 中每个实体类<strong>必须提供一个无参构造函数</strong>，因为 hibernate 框架<strong>要使用 <code>reflection api</code>，通过调用 <code>ClassnewInstance()</code> 来创建实体类的实例</strong>，如果没有无参的构造函数就会抛出异常。</p>]]></content>
    
    
    <summary type="html">Hibernate</summary>
    
    
    
    <category term="框架" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Hibernate" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/Hibernate/"/>
    
    
    <category term="Hibernate" scheme="https://southernfish.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud</title>
    <link href="https://southernfish.github.io/2025/06/19/SpringCloud/"/>
    <id>https://southernfish.github.io/2025/06/19/SpringCloud/</id>
    <published>2025-06-19T08:30:36.000Z</published>
    <updated>2025-06-19T13:36:26.088Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录关于Spring Cloud的相关问题</p><h2 id="什么是-spring-cloud？"><a href="#什么是-spring-cloud？" class="headerlink" title="什么是 spring cloud？"></a>什么是 spring cloud？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring cloud 是一系列框架的有序集合。</span><br><span class="line">利用 spring boot 的开发便利性简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>spring cloud</code> 是<strong>一系列框架的有序集合</strong>。<br>利用 <code>spring boot 的开发便利性</code>简化了分布式系统基础设施的开发，如<strong>服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控</strong>等，都可以用 spring boot 的开发风格做到一键启动和部署。</p><h2 id="spring-cloud-断路器的作用是什么？Hystrix"><a href="#spring-cloud-断路器的作用是什么？Hystrix" class="headerlink" title="spring cloud 断路器的作用是什么？Hystrix"></a>spring cloud 断路器的作用是什么？Hystrix</h2><p>在分布式架构中，断路器模式的作用也是类似的，当<em>某个服务单元发生故障</em>（类似用电器发生短路）之后，<em>通过断路器的故障监控</em>（类似熔断保险丝），<em>向调用方返回一个错误响应，而不是长时间的等待</em>。这样就不会使得线程因调用故障服务被长时间占用不释放，<strong>避免故障在分布式系统中的蔓延</strong>。</p><h2 id="spring-cloud-的核心组件有哪些？-Netflix"><a href="#spring-cloud-的核心组件有哪些？-Netflix" class="headerlink" title="spring cloud 的核心组件有哪些？(Netflix)"></a>spring cloud 的核心组件有哪些？(Netflix)</h2><table><thead><tr><th><strong>组件</strong></th><th><strong>作用</strong></th><th><strong>解决了什么问题</strong></th></tr></thead><tbody><tr><td>Eureka</td><td>服务注册与发现</td><td>硬编码服务提供者地址的方式有不少问题。要想解决这些问题，服务消费者需要一个强大的服务发现机制，服务消费者使用这种机制获取服务提供者的网络信息。不仅如此，即使<strong>服务提供者的网络地址发生变化，服务消费者也无须修改配置文件</strong>。</td></tr><tr><td>Ribbon</td><td>客户端侧负载均衡</td><td><code>Ribbon</code> 的作用是负载均衡，<strong>会帮你在每次请求时选择一台服务器，均匀的把请求分发到各个服务器上</strong>。</td></tr><tr><td>Feign</td><td>REST调用</td><td>基于<strong>动态代理机制</strong>，<code>Feign Client</code> 会根据注解，跟你指定的服务<strong>建立连接、构造请求、发起请求、获取响应、解析响应等</strong>。</td></tr><tr><td>Hystrix</td><td>容错处理</td><td>服务链上，因某个微服务的异常，而导致雪崩效应，整条服务链宕机的问题；Hystrix会去捕获这个异常，利用Hystrix接口处理这类异常。提供线程池，不同的服务走不同的线程池，实现了<strong>不同服务调用的隔离，避免了服务雪崩的问题</strong></td></tr><tr><td>Zuul</td><td>微服务网关</td><td>由 <code>Zuul</code> 网关转发请求给对应的服务，<strong>负责网络路由，可以做统一的降级、限流、认证授权、安全等</strong>。</td></tr></tbody></table><h2 id="分布式、微服务系统常见的问题？"><a href="#分布式、微服务系统常见的问题？" class="headerlink" title="分布式、微服务系统常见的问题？"></a>分布式、微服务系统常见的问题？</h2><p><strong>服务雪崩</strong><br>多个微服务之间调用时，假设<em>微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它微服务</em>，这就是**<code>“扇出”</code><strong>。若扇出链路上<em>某个微服务调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源</em>，进而引起系统崩溃，这就是所谓的</strong><code>“雪崩效应”</code><strong>。<br>对于高流量的应用来说，<em>单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和</em>。比失败更糟糕的是，这些应用程序还可能<em>导致服务之间的延迟增加，线程和其他系统资源紧张，导致整个系统发生更多的级联故障</em>。<br>这些都表示</strong>需要对故障和延迟进行隔离和管理<strong>，以便单个依赖关系的失败，不能取消整个应用程序或系统。<br>通常一个模块下的某个实例失败后，这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。<br><strong>解决方法</strong><br><code>Hystrix</code>是一个用于</strong>处理分布式系统的延迟和容错的开源库<strong>，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，<code>Hystrix</code>能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。<br><code>“断路器”</code>本身是一种开关装置，当某个服务单元发生故障后，通过断路器的故障监控（类似熔断保险丝），</strong>向调用方返回一个符合预期的、可处理的备选响应（<code>FallBack</code>），而非长时间等待或抛出调用方无法处理的异常**，保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>]]></content>
    
    
    <summary type="html">Spring Cloud</summary>
    
    
    
    <category term="框架" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="spring" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
    <category term="Spring Cloud" scheme="https://southernfish.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot</title>
    <link href="https://southernfish.github.io/2025/06/19/SpringBoot/"/>
    <id>https://southernfish.github.io/2025/06/19/SpringBoot/</id>
    <published>2025-06-19T07:52:36.000Z</published>
    <updated>2025-06-19T13:36:26.088Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录关于Spring Boot的相关问题</p><h2 id="什么是-spring-boot？"><a href="#什么是-spring-boot？" class="headerlink" title="什么是 spring boot？"></a>什么是 spring boot？</h2><p><code>spring boot</code> 是为 spring 服务的，是用来<strong>简化新 spring 应用的初始搭建以及开发过程</strong>的。</p><h2 id="为什么要用-spring-boot？"><a href="#为什么要用-spring-boot？" class="headerlink" title="为什么要用 spring boot？"></a>为什么要用 spring boot？</h2><p><em>配置简单、独立运行、自动装配、无代码生成和 xml 配置、提供应用监控、易上手、提升开发效率</em></p><ol><li>配置简单，不需要编写太多的xml配置文件；</li><li>内置tomcat服务器，不需要打包成war包，可以直接放到tomcat中运行；</li><li><strong>独立运行：</strong><code>SpringBoot</code>可以创建独立运行的应用而不需要依赖于容器；</li><li><strong>提供应用监控</strong>，提供<code>maven</code>极简配置，以及可视化的相关监控功能，比如性能监控，应用的健康程度等；</li></ol><h2 id="spring-boot-核心配置文件是什么？"><a href="#spring-boot-核心配置文件是什么？" class="headerlink" title="spring boot 核心配置文件是什么？"></a>spring boot 核心配置文件是什么？</h2><p>spring boot 核心的两个配置文件：</p><ul><li><code>bootstrap (. yml 或者 . properties)</code>：<code>boostrap</code> 由父 <code>ApplicationContext</code> 加载，比 <code>applicaton</code> 优先加载，且 boostrap 里面的属性不能被覆盖；</li><li><code>application (. yml 或者 . properties)</code>：用于 spring boot 项目的自动化配置。</li></ul><h2 id="spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="spring boot 配置文件有哪几种类型？它们有什么区别？"></a>spring boot 配置文件有哪几种类型？它们有什么区别？</h2><p>配置文件有 <code>. properties</code> 格式和 <code>. yml</code> 格式，它们主要的区别是<strong>书写风格不同</strong>。<br>yml 格式不支持 <code>@PropertySource</code> 注解导入。</p><h2 id="spring-boot-有哪些方式可以实现热部署？"><a href="#spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="spring boot 有哪些方式可以实现热部署？"></a>spring boot 有哪些方式可以实现热部署？</h2><p>使用 <code>devtools</code> 启动热部署，添加 <code>devtools库</code>，在配置文件中把 <code>spring.devtools.restart.enabled</code> 设置为 <code>true</code>；<br>使用 <code>Intellij Idea</code> 编辑器，勾上自动编译或手动重新编译。</p><h2 id="jpa-和-hibernate-有什么区别？"><a href="#jpa-和-hibernate-有什么区别？" class="headerlink" title="jpa 和 hibernate 有什么区别？"></a>jpa 和 hibernate 有什么区别？</h2><p><code>jpa</code> 全称 <code>Java Persistence API</code>，<strong>是 Java 持久化接口规范，<code>hibernate</code> 属于 jpa 的具体实现</strong>。</p><h2 id="springboot-的常见注解"><a href="#springboot-的常见注解" class="headerlink" title="springboot 的常见注解"></a>springboot 的常见注解</h2><table><thead><tr><th>注解</th><th>解释</th></tr></thead><tbody><tr><td>@SpringBootApplication</td><td>这个注解是Spring Boot最核心的注解，用在 <code>Spring Boot的主类</code>上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。它是<code>@Configuration,@EnableAutoConfiguration,@ComponentScan</code>三个注解的组合。</td></tr><tr><td>@EnableAutoConfiguration</td><td>允许 Spring Boot 自动配置注解，开启这个注解后，Spring Boot 根据当前类路径下的包或者类来配置 Spring Bean。</td></tr><tr><td>@SpringBootConfiguration</td><td><code>@Configuration</code> 注解的变体，仅用来<code>修饰Spring Boot 配置</code>，或者可利于 Spring Boot 后续的扩展。</td></tr><tr><td>@ConditionalOnBean</td><td><code>@ConditionalOnBean(A.class)</code>仅仅在当前上下文中存在A对象时，才实例化一个Bean。</td></tr><tr><td>@ConditionalOnMissingBean</td><td>组合@Conditional注解，和@ConditionalOnBean注解相反，仅在当前上下文中不存在A对象时，才实例化一个Bean。</td></tr><tr><td>@ConditionalOnClass</td><td>组合 @Conditional 注解，仅当某些类存在于<code>classpath</code>上时候才创建某个Bean。</td></tr><tr><td>@ConditionalOnMissingClass</td><td>组合@Conditional注解，和@ConditionalOnMissingClass注解相反，当<code>classpath</code>中没有指定的 Class才开启配置。</td></tr><tr><td>@ConditionalOnWebApplication</td><td>组合@Conditional 注解，当前<strong>项目类型是 WEB 项目</strong>才开启配置。<br />当前项目有以下 3 种类型：<br /><code>ANY</code>(任何Web项目都匹配)<br /><code>SERVLET</code>（仅Servelet项目才会匹配）<br /><code>REACTIVE</code>（只有基于响应的web应用程序才匹配）</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>组合@Conditional注解，当前<strong>项目类型不是 WEB 项目</strong>才开启配置。</td></tr><tr><td>@ConditionalOnProperty</td><td>组合 @Conditional 注解，当<strong>指定的属性有指定的值</strong>时才开启配置。</td></tr><tr><td>@ConditionalOnExpression</td><td>组合 @Conditional 注解，当 <strong>SpEL 表达式为 true 时</strong>才开启配置。<br />@Conditional <br />@ConditionalOnExpression(“${enabled:false}”)</td></tr><tr><td>@ConditionalOnJava</td><td>组合@Conditional 注解，当<strong>运行的 <code>Java JVM</code> 在指定的版本范围时</strong>才开启配置。</td></tr><tr><td>@ConditionalOnResource</td><td>组合 @Conditional 注解，当<strong>类路径下有指定的资源</strong>才开启配置。<br />@Bean<br />@ConditionalOnResource(resources=”classpath:shiro.ini”)</td></tr><tr><td>@ConditionalOnJndi</td><td>组合 @Conditional 注解，当<strong>指定的 JNDI 存在时</strong>才开启配置。</td></tr><tr><td>@ConditionalOnCloudPlatform</td><td>组合 @Conditional 注解，当<strong>指定的云平台激活时</strong>才开启配置。</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>组合 @Conditional 注解，当<strong>指定的 class 在容器中只有一个 Bean，或者同时有多个但为首选时</strong>才开启配置。</td></tr><tr><td>@ConfigurationProperties</td><td><code>Spring Boot</code>可<em>使用注解的方式将自定义的properties文件映射到实体bean中，比如config.properties文件</em>。<br />@Data<br />@ConfigurationProperties(“rocketmq.consumer”)</td></tr><tr><td>@EnableConfigurationProperties</td><td>当<code>@EnableConfigurationProperties</code>注解应用到你的@Configuration时，任何被@ConfigurationProperties注解的beans将自动被<code>Environment属性</code>配置。 这种风格的配置<strong>适合与SpringApplication的外部YAML配置进行配合使用</strong>。<br />@Configuration<br />@EnableConfigurationProperties({RocketMQProducerProperties.class, RocketMQConsumerProperties.class,})</td></tr><tr><td>@AutoConfigureAfter</td><td>用在自动配置类上面，表示该自动配置类需要<strong>在另外指定的自动配置类配置完之后</strong>。</td></tr><tr><td>@AutoConfigureBefore</td><td>用在自动配置类上面，表示该自动配置类需要<strong>在另外指定的自动配置类配置之前</strong>。</td></tr><tr><td>@AutoConfigureOrder</td><td>Spring Boot 1.3.0中有一个新的注解<code>@AutoConfigureOrder</code>，用于<strong>确定配置加载的优先级顺序</strong>。<br />@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) // 自动配置里面的最高优先级@Configuration@ConditionalOnWebApplication // 仅限于web应用@Import(BeanPostProcessorsRegistrar.class) // 导入内置容器的设置</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Spring Boot</summary>
    
    
    
    <category term="框架" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="spring" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
    <category term="Spring Boot" scheme="https://southernfish.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC</title>
    <link href="https://southernfish.github.io/2025/06/19/SpringMvc/"/>
    <id>https://southernfish.github.io/2025/06/19/SpringMvc/</id>
    <published>2025-06-19T07:12:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些有关 Spring MVC 的问题</p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="为什么要使用-spring？"><a href="#为什么要使用-spring？" class="headerlink" title="为什么要使用 spring？"></a>为什么要使用 spring？</h2><p>spring <strong>提供 ioc 技术</strong>，容器会帮你管理依赖的对象，而无需自己创建和管理依赖对象，<strong>轻松实现程序的解耦</strong>。<br>spring <strong>提供了事务支持</strong>，使得<strong>事务操作更加方便</strong>。<br>spring <strong>提供了面向切面编程</strong>，这样可以<strong>更方便的处理某一类的问题</strong>。<br><strong>更方便的框架集成</strong>，<code>spring</code> 可以很方便的集成其他框架，比如 <code>MyBatis</code>、<code>hibernate</code> 等。</p><h2 id="什么是-aop？"><a href="#什么是-aop？" class="headerlink" title="什么是 aop？"></a>什么是 aop？</h2><p><code>aop</code> 是<strong>面向切面编程</strong>，<strong>通过预编译方式和运行期动态代理实现程序功能的统一维护</strong>的一种技术。<br>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理<strong>日志、异常</strong>等。</p><h2 id="什么是-ioc？"><a href="#什么是-ioc？" class="headerlink" title="什么是 ioc？"></a>什么是 ioc？</h2><p><strong>ioc：</strong><code>Inversionof Control</code>（中文：<strong>控制反转</strong>）是 spring 的核心，对于 spring 框架来说，就是<strong>由 spring 来负责控制对象的生命周期和对象间的关系</strong>。<br>简单来说，控制指的是<strong>当前对象对内部成员的控制权</strong>；控制反转指的是，这种控制权不由当前对象管理了，由其他（类，第三方容器）来管理。</p><h2 id="spring-有哪些主要模块？"><a href="#spring-有哪些主要模块？" class="headerlink" title="spring 有哪些主要模块？"></a>spring 有哪些主要模块？</h2><p><strong>spring core：</strong>框架的最基础部分，<strong>提供 ioc 和依赖注入特性</strong>。<br><strong>spring context：</strong>构建于 <code>core</code> 封装包基础上的 <code>context</code> 封装包，<strong>提供了一种框架式的对象访问方法</strong>。<br><strong>spring dao：</strong><code>Data Access Object</code> <strong>提供了JDBC的抽象层</strong>。<br><strong>spring aop：</strong>提供了<strong>面向切面的编程</strong>实现，可<strong>自定义拦截器、切点</strong>等。<br><strong>spring Web：</strong>提供了针对<code> Web</code> 开发的集成特性，如文件上传，利用 <code>servlet listeners</code> 进行 ioc 容器初始化和针对 <code>Web</code> 的 <code>ApplicationContext</code>。<br><strong>spring Web mvc：</strong><code>spring</code> 中的 <code>mvc</code> 封装包提供了<code> Web</code> 应用的 <code>Model-View-Controller（MVC）</code>的实现。</p><h2 id="spring-常用的注入方式有哪些？"><a href="#spring-常用的注入方式有哪些？" class="headerlink" title="spring 常用的注入方式有哪些？"></a>spring 常用的注入方式有哪些？</h2><ul><li>setter 属性注入</li><li>构造方法注入</li><li>注解方式注入</li></ul><h2 id="spring-中的-bean-是线程安全的吗？"><a href="#spring-中的-bean-是线程安全的吗？" class="headerlink" title="spring 中的 bean 是线程安全的吗？"></a>spring 中的 bean 是线程安全的吗？</h2><p><code>spring</code> 中的 <code>bean</code> <strong>默认是单例模式</strong>，spring 框架并没有对单例 bean 进行多线程的封装处理。<br>实际上<strong>大部分时候 <code>spring bean</code> 是无状态</strong>的（比如 <code>dao</code> 类），所以某种程度上来说 bean 也是安全的，但<em>如果 bea有状态的话（比如<code>view model</code> 对象），那就要开发者自己去保证线程安全了</em>，最简单的就是**改变 bean 的作用域，把<code>singleton</code>变更为<code>prototype</code>**，这样请求 bean 相当于 <code>new Bean()</code>了，所以就可以保证线程安全了。</p><ul><li>有状态就是有数据存储功能。</li><li>无状态就是不会保存数据。</li></ul><h2 id="spring-支持几种-bean-的作用域？"><a href="#spring-支持几种-bean-的作用域？" class="headerlink" title="spring 支持几种 bean 的作用域？"></a>spring 支持几种 bean 的作用域？</h2><p>spring 支持 5 种作用域，如下：<br><strong>singleton：</strong><code>spring ioc</code> 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；<br><strong>prototype：</strong>每次从容器调用 bean 时都会创建一个新的示例，即每次 <code>getBean()</code>相当于执行 <code>new Bean()</code>操作；<br>Web 环境下的作用域：</p><ul><li><strong>request：</strong>每次 http 请求都会创建一个 bean；</li><li><strong>session：</strong>同一个 <code>http session</code> 共享一个 bean 实例；</li><li><strong>global-session：</strong>用于 <code>portlet</code> 容器，因为每个 <code>portlet</code> 有单独的 <code>session</code>，<code>globalsession</code> 提供一个全局性的 <code>http session</code>。</li></ul><p><strong>注意：</strong> 使用 <code>prototype</code> 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p><h2 id="spring-自动装配-bean-有哪些方式？"><a href="#spring-自动装配-bean-有哪些方式？" class="headerlink" title="spring 自动装配 bean 有哪些方式？"></a>spring 自动装配 bean 有哪些方式？</h2><p><strong>no：</strong>默认值，表示<strong>没有自动装配</strong>，应使用显式 bean 引用进行装配。<br><strong>byName：</strong>它<strong>根据 bean 的名称注入对象依赖项</strong>。<br><strong>byType：</strong>它<strong>根据类型</strong>注入对象依赖项。<br><strong>构造函数：</strong>它<strong>通过构造函数</strong>来注入依赖项，需要设置大量的参数。<br><strong>autodetect：</strong>容器首先通过构造函数使用 <code>autowire</code> 装配，如果不能，则通过 <code>byType</code> 自动装配。</p><h2 id="spring-事务实现方式有哪些？"><a href="#spring-事务实现方式有哪些？" class="headerlink" title="spring 事务实现方式有哪些？"></a>spring 事务实现方式有哪些？</h2><p><strong>声明式事务：</strong>声明式事务也有两种实现方式，<strong>基于 xml 配置文件的方式和注解方式</strong>（ @Transaction ）。<br><strong>编码方式：</strong>提供<strong>编码的形式管理和维护事务</strong>。</p><h2 id="spring-的事务隔离？"><a href="#spring-的事务隔离？" class="headerlink" title="spring 的事务隔离？"></a>spring 的事务隔离？</h2><p>spring 有五大隔离级别，默认值为 <code>ISOLATION_DEFAULT</code>（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><ul><li><strong>ISOLATION_DEFAULT：</strong>用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li><li><strong>ISOLATIONREADUNCOMMITTED：</strong><code>读未提交</code>，最低隔离级别、事务未提交前，就可被其他事务读取（会出现脏读、不可重复读、幻读）；</li><li><strong>ISOLATIONREADCOMMITTED：</strong><code>读提交</code>，一个事务提交后才能被其他事务读取到（会造成不可重复读、幻读），<code>SQL server</code> 的默认级别；</li><li><strong>ISOLATIONREPEATABLEREAD：</strong><code>可重复读</code>，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），<code>MySQL</code> 的默认级别；</li><li><strong>ISOLATION_SERIALIZABLE：</strong><code>序列化</code>，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><p><strong>脏读：</strong>表示一个事务能够读取另一个事务中还未提交的数据。<br><strong>不可重复读：</strong>是指在一个事务内，多次读同一数据。<br><strong>幻读：</strong>指同一个事务内多次查询返回的结果集不一样。<strong>发生幻读的原因</strong>是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="spring-mvc-运行流程？"><a href="#spring-mvc-运行流程？" class="headerlink" title="spring mvc 运行流程？"></a>spring mvc 运行流程？</h2><p><code>spring mvc</code> 先<strong>将请求发送给 <code>DispatcherServlet</code><strong>。<br><code>DispatcherServlet</code> 查询一个或多个 <code>HandlerMapping</code>，</strong>找到处理请求的 <code>Controller</code><strong>。<br><code>DispatcherServlet</code> 再</strong>把请求提交到对应的 <code>Controller</code><strong>。<br><code>Controller</code> 进行业务逻辑处理后，会</strong>返回一个<code>ModelAndView</code><strong>。<br><code>Dispathcher</code> 查询一个或多个<code>ViewResolver</code> 视图解析器，</strong>找到 <code>ModelAndView</code> 对象指定的视图对象</strong>。<br>视图对象负责<strong>渲染返回给客户端</strong>。</p><h2 id="spring-mvc-有哪些组件？"><a href="#spring-mvc-有哪些组件？" class="headerlink" title="spring mvc 有哪些组件？"></a>spring mvc 有哪些组件？</h2><p>前置控制器 DispatcherServlet<br>映射控制器 HandlerMapping<br>处理器 Controller<br>模型和视图 ModelAndView<br>视图解析器 ViewResolver</p><h2 id="RequestMapping-的作用是什么？"><a href="#RequestMapping-的作用是什么？" class="headerlink" title="@RequestMapping 的作用是什么？"></a>@RequestMapping 的作用是什么？</h2><p>将 http 请求映射到相应的类/方法上。</p><h2 id="Autowired-的作用是什么？"><a href="#Autowired-的作用是什么？" class="headerlink" title="@Autowired 的作用是什么？"></a>@Autowired 的作用是什么？</h2><p><code>@Autowired</code> 可<strong>对类成员变量、方法及构造函数进行标注，完成自动装配工作</strong>。<br>通过<code>@Autowired</code> 的使用来<strong>消除 <code>set/get</code> 方法</strong>。</p><h2 id="Controller和-RestController的区别？"><a href="#Controller和-RestController的区别？" class="headerlink" title="@Controller和@RestController的区别？"></a>@Controller和@RestController的区别？</h2><p><strong>功能定位：</strong></p><ul><li><strong>@Controller：</strong>主要用于处理HTTP请求并返回视图（如<code>JSP</code>、<code>Thymeleaf</code>页面），或通过<code>@ResponseBody</code>注解返回数据对象。</li><li><strong>@RestController：</strong><code>@Controller</code>与<code>@ResponseBody</code>的组合注解，专门用于构建RESTful API，直接返回数据（如<code>JSON</code>、<code>XML</code>），不涉及视图渲染。</li></ul><p><strong>返回值类型：</strong></p><ul><li><strong>@Controller：</strong>可返回<code>String</code>（视图名称）、<code>ModelAndView</code>对象或通过<code>@ResponseBody</code>返回实体对象。</li><li><strong>@RestController：</strong>默认返回实体对象（如自定义类），自动序列化为<code>JSON/XML</code>等格式。</li></ul><p><strong>使用场景：</strong></p><ul><li><p><strong>@Controller：</strong>适用于需要渲染视图的传统Web应用场景，例如用户登录后跳转页面或展示表单。</p></li><li><p><strong>@RestController：</strong>适用于开发<code>RESTful API</code>接口，直接返回数据供前端或第三方系统调用。</p></li></ul><p><strong>注解组合关系：</strong><br><code>@RestController</code>本质上是<code>@Controller + @ResponseBody</code>的组合，所有方法默认带有<code>@ResponseBody</code>属性，无需显式标注。<br>若需在<code>@RestController</code>中跳转页面，需通过<code>ModelAndView</code>封装返回值。</p>]]></content>
    
    
    <summary type="html">hello word</summary>
    
    
    
    <category term="框架" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="spring" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
    <category term="Spring MVC" scheme="https://southernfish.github.io/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="https://southernfish.github.io/2025/06/19/java-exceptions/"/>
    <id>https://southernfish.github.io/2025/06/19/java-exceptions/</id>
    <published>2025-06-19T06:58:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于 Java异常的问题</p><h1 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h1><h2 id="throw-和-throws-的区别？"><a href="#throw-和-throws-的区别？" class="headerlink" title="throw 和 throws 的区别？"></a>throw 和 throws 的区别？</h2><p><strong>throw：</strong>是真实抛出一个异常。<br><strong>throws：</strong>是声明可能会抛出一个异常。</p><h2 id="final、finally、finalize-有什么区别？"><a href="#final、finally、finalize-有什么区别？" class="headerlink" title="final、finally、finalize 有什么区别？"></a>final、finally、finalize 有什么区别？</h2><p><strong>final：</strong>是<strong>修饰符</strong>，如果修饰类，此类<strong>不能被继承</strong>；如果修饰方法和变量，此方法和此变量<strong>不能再被改变</strong>，只能使用。<br><strong>finally：</strong>是 try{} catch{} finally{} 最后一部分，表示<strong>不论发生任何情况都会执行</strong>，finally 部分可以省略，但若 finally 部分存在，则一定会执行 finally 里面的代码。<br><strong>finalize：</strong>是 Object 类的一个方法，在<strong>垃圾收集器执行的时候会调用被回收对象的此方法</strong>。</p><h2 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h2><p>try-catch-finally 其中 <strong>catch 和 finally 都可以被省略，但不能同时省略</strong>，也就是说有 try 时，必须后面跟一个 catch 或 finally。</p><h2 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><p><strong>finally 一定会执行</strong>，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常机制？"><a href="#异常机制？" class="headerlink" title="异常机制？"></a>异常机制？</h2><p><strong>异常机制：</strong>当<em>程序出现异常，程序安全的退出、处理完后继续执行的机制</em><br>Java是采用面向对象的方式来处理异常的。<strong>处理过程：</strong></p><ul><li><strong>抛出异常：</strong>在执行一个方法时，如果发生异常，则这个方法<strong>生成代表该异常的一个对象</strong>，停止当前执行路径，并<strong>把异常对象提交给JRE</strong>。</li><li><strong>捕获异常：</strong>JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，<strong>从生成异常的方法开始回溯，直到找到相应的异常处理代码为止</strong></li></ul><h2 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h2><p>可以使用 try-with-resources 语句来自动管理资源，如自动关闭实现了 AutoCloseable 或 Closeable 接口的资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以使用 try-with-resources 语句来自动管理资源，如自动关闭实现了 AutoCloseable 或 Closeable 接口的资源。</span><br><span class="line">try (Resource resource = new Resource()) &#123;</span><br><span class="line">    // 使用资源</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // 处理异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见的异常类有哪些？"><a href="#常见的异常类有哪些？" class="headerlink" title="常见的异常类有哪些？"></a>常见的异常类有哪些？</h2><ul><li>NullPointerException 空指针异常 （RuntimeException 无需编译器处理，增加逻辑处理来避免这些异常）</li><li>ClassNotFoundException 指定类不存在（CheckedException 需要编译器处理，使用 try-catch 结构）</li><li>NumberFormatException 字符串转换为数字异常（RuntimeException ）</li><li>IndexOutOfBoundsException 数组下标越界异常</li><li>ClassCastException 数据类型转换异常</li><li>FileNotFoundException 文件未找到异常</li><li>NoSuchMethodException 方法不存在异常</li><li>IOException IO 异常</li><li>SocketException Socket 异常</li></ul><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>所有异常的<strong>根类为 java.lang.Throwable</strong>。若内置的异常类不能够满足需要，还可以创建自己的异常类。<br>Throwable 派生了两个子类：Error 和 Exception。<br><strong>Error</strong> 是程序无法处理的错误。大多错误与代码编写者执行的操作无关，而表示代码运行时 JVM 出现的问题。<br><strong>Exception</strong> 是程序本身能够处理的异常。分为 RuntimeException 运行时异常，CheckedException 已检查异常。<strong>RuntimeException 无需编译器处理，增加逻辑处理</strong>来避免这些异常；<strong>CheckedException 需要编译器处理，使用 try-catch 结构</strong>。</p>]]></content>
    
    
    <summary type="html">java 异常</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Exceptions" scheme="https://southernfish.github.io/tags/Exceptions/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程</title>
    <link href="https://southernfish.github.io/2025/06/19/java-oop/"/>
    <id>https://southernfish.github.io/2025/06/19/java-oop/</id>
    <published>2025-06-19T06:55:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于面向对象编程的问题</p><h2 id="Java-中面向对象编程的三大特性"><a href="#Java-中面向对象编程的三大特性" class="headerlink" title="Java 中面向对象编程的三大特性"></a>Java 中面向对象编程的三大特性</h2><p><strong>封装、继承、多态。</strong>分别实现了<strong>数据的隐藏与保护、代码的复用扩展以及行为的灵活适配</strong>。‌</p><p><strong>封装</strong>是对数据和行为进行集中管理的过程‌，其核心在于隐藏内部实现细节，仅通过接口与外界交互。主要作用包括：‌</p><ul><li><em>数据保护‌：</em>通过访问权限控制，如 private、protected 限制外部直接修改属性；‌‌‌‌‌</li><li><em>接口标准化‌：</em>提供统一的方法调用入口，如 getter、setter 控制属性访问；‌‌‌</li><li><em>模块化设计‌：</em>将同一类功能封装到同一对象中。</li></ul><p><strong>继承</strong>通过父子类关系实现代码复用和扩展‌，其特点包括：‌</p><ul><li><em>子类复用父类功能‌：</em>子类可直接使用父类的公共属性和方法；‌‌‌‌‌</li><li><em>层级扩展能力‌：</em>子类可新增特性或重写父类方法，如子类用 extends 继承父类并添加特有属性；‌‌‌</li><li><em>访问规则约束‌：</em>父类私有成员（private）不可被子类继承，保证封装性。‌‌‌</li></ul><p><strong>多态</strong>通过统一的接口实现不同类型的差异化行为‌，具体表现为：‌</p><ul><li><em>动态绑定‌：</em>父类引用指向子类对象；‌‌‌</li><li><em>方法重写与重载‌：</em>子类覆写父类方法（重写）或同一类中同名不同参方法（重载）；‌‌‌‌‌</li><li><em>灵活性增强‌：</em>同一方法在不同子类中表现不同。‌</li></ul><h2 id="什么是泛型？为什么要使用泛型？"><a href="#什么是泛型？为什么要使用泛型？" class="headerlink" title="什么是泛型？为什么要使用泛型？"></a>什么是泛型？为什么要使用泛型？</h2><p>泛型，即<strong>“参数化类型”</strong>。泛型的出现是为了<em>统一集合当中的数据类型</em>。可<em>在编译阶段约束操作的数据类型，并进行检查</em><br><strong>参数化类型：</strong>在方法定义时，<em>将方法签名中的形参数据类型设置为参数</em>（可称之为类型参数：尖括号 &lt;&gt; 中的泛型标识，用于指代任何数据类型），调用该方法时再从外部传入一个具体的数据类型和变量。<br><strong>泛型的本质：</strong><em>将类型参数化</em>。泛型使用过程中，数据类型被设置为一个参数，<strong>使用时从外部传入一个数据类型</strong>；而一旦传入了具体的数据类型后，<strong>传入变量（实参）的数据类型若不匹配，编译器就会直接报错</strong>。这种参数化类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p><strong>细节：</strong>不能写基本数据类型；指定泛型具体类型后，传递数据时可传该类型和其子类类型；若不写泛型，默认是Object<br><strong>泛型标识：</strong>是任意设置的，Java 常见泛型标识及其代表含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T ：代表一般的任何类。</span><br><span class="line">E ：代表 Element 元素的意思，或者 Exception 异常的意思。</span><br><span class="line">K ：代表 Key 的意思。</span><br><span class="line">V ：代表 Value 的意思，通常与 K 一起配合使用。</span><br><span class="line">S ：代表 Subtype 的意思。</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong>定义类、方法、接口的时候，若类型不确定，可定义泛型；<em>若类型不确定，但知道继承体系，可用泛型通配符 ？</em><br><strong>泛型不具备继承性，但是数据具备继承性</strong></p>]]></content>
    
    
    <summary type="html">面向对象编程</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="OOP" scheme="https://southernfish.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>对象拷贝</title>
    <link href="https://southernfish.github.io/2025/06/19/java-object-copy/"/>
    <id>https://southernfish.github.io/2025/06/19/java-object-copy/</id>
    <published>2025-06-19T06:30:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录关于Java中对象拷贝的问题</p><h2 id="为什么要使用克隆？"><a href="#为什么要使用克隆？" class="headerlink" title="为什么要使用克隆？"></a>为什么要使用克隆？</h2><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以<strong>当需要一个新的对象来保存当前对象的“状态”</strong>就靠克隆方法了。</p><h2 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h2><p>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。<br>实现 Serializable 接口，通过<strong>对象的序列化和反序列化实现克隆</strong>，可以实现真正的深度克隆。</p><h2 id="深拷贝和浅拷贝区别是什么？"><a href="#深拷贝和浅拷贝区别是什么？" class="headerlink" title="深拷贝和浅拷贝区别是什么？"></a>深拷贝和浅拷贝区别是什么？</h2><p><strong>浅克隆：</strong>当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。<br><strong>深克隆：</strong>除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p>]]></content>
    
    
    <summary type="html">对象拷贝</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Object" scheme="https://southernfish.github.io/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://southernfish.github.io/2025/06/19/java-design-patterns/"/>
    <id>https://southernfish.github.io/2025/06/19/java-design-patterns/</id>
    <published>2025-06-19T06:26:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些关于Java中设计模式相关问题</p><h2 id="熟悉的设计模式？"><a href="#熟悉的设计模式？" class="headerlink" title="熟悉的设计模式？"></a>熟悉的设计模式？</h2><ul><li><strong>单例模式：</strong>确保类仅有一个实例（如数据库连接池）‌‌。</li><li><strong>工厂模式（简单工厂、抽象工厂）：</strong>解耦代码。<ul><li>简单工厂<strong>将对象创建延迟到子类</strong>（如不同图形工厂生成不同形状）‌</li><li>抽象工厂<strong>创建相关对象族</strong>（如跨平台UI组件库）</li></ul></li><li><strong>观察者模式：</strong>定义了<strong>对象之间的一对多的依赖</strong>，当一个对象改变时，它的所有依赖者都会收到通知并自动更新。<ul><li>建立一个主题和多个观察者之间的<strong>订阅关系</strong>，实现状态变化的<strong>动态通知</strong>，如气象站通知多个显示设备</li></ul></li><li><strong>外观模式：</strong>提供一个<strong>统一的接口，用来访问子系统</strong>中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li><li><strong>模版方法模式：</strong>定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得<strong>子类可在不改变算法结构的情况下，重新定义算法的步骤</strong>。</li><li><strong>状态模式：</strong>允许<strong>对象在内部状态改变时改变它的行为</strong>，对象看起来好像修改了它的类。</li></ul><h2 id="简单工厂和抽象工厂有什么区别？"><a href="#简单工厂和抽象工厂有什么区别？" class="headerlink" title="简单工厂和抽象工厂有什么区别？"></a>简单工厂和抽象工厂有什么区别？</h2><p><strong>简单工厂：</strong>用来<strong>生产同一等级结构中的任意产品</strong>，对于增加新的产品，无能为力。<br><strong>工厂方法：</strong>用来<strong>生产同一等级结构中的固定产品</strong>，支持增加任意产品。<br><strong>抽象工厂：</strong>用来<strong>生产不同产品族的全部产品</strong>，对于增加新的产品，无能为力；<em>支持增加产品族</em>。</p><h2 id="设计模式遵循的原则？"><a href="#设计模式遵循的原则？" class="headerlink" title="设计模式遵循的原则？"></a>设计模式遵循的原则？</h2><ol><li><p><strong>开闭原则（Open Close Principle）</strong></p><p><em>对扩展开放，对修改关闭</em>。</p></li><li><p><strong>里氏代换原则（Liskov Substitution Principle）</strong></p><p>只有当衍生类可替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p></li><li><p><strong>依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个是开闭原则的基础，<em>对接口编程，依赖于抽象而不依赖于具体</em>。</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle）</strong></p><p>使用多个隔离的接口来降低耦合度。</p></li><li><p><strong>迪米特法则（最少知道原则）（Demeter Principle）</strong></p><p>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p><strong>合成复用原则（Composite Reuse Principle）</strong></p><p>原则是<em>尽量使用合成/聚合的方式，而不是使用继承</em>。</p><p><em>继承实际上破坏了类的封装性</em>，超类的方法可能会被子类修改。</p></li></ol>]]></content>
    
    
    <summary type="html">设计模式相关</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="设计模式" scheme="https://southernfish.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java Web</title>
    <link href="https://southernfish.github.io/2025/06/19/java-web/"/>
    <id>https://southernfish.github.io/2025/06/19/java-web/</id>
    <published>2025-06-19T05:15:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于Java Web的相关问题</p><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="JSP-和-servlet-有什么区别？"><a href="#JSP-和-servlet-有什么区别？" class="headerlink" title="JSP 和 servlet 有什么区别？"></a>JSP 和 servlet 有什么区别？</h2><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。</p><p><strong>JSP 侧重于视图，servlet 主要用于控制逻辑。</strong></p><h2 id="JSP-有哪些内置对象？作用分别是什么？"><a href="#JSP-有哪些内置对象？作用分别是什么？" class="headerlink" title="JSP 有哪些内置对象？作用分别是什么？"></a>JSP 有哪些内置对象？作用分别是什么？</h2><p>JSP 有 <strong>9</strong> 大内置对象：</p><ul><li><strong>request：</strong>封装客户端的请求，其中包含来自 get 或 post 请求的参数；</li><li><strong>response：</strong>封装服务器对客户端的响应；</li><li><strong>pageContext：</strong>通过该对象可以获取其他对象；</li><li><strong>session：</strong>封装用户会话的对象；</li><li><strong>application：</strong>封装服务器运行环境的对象；</li><li><strong>out：</strong>输出服务器响应的输出流对象；</li><li><strong>config：</strong>Web 应用的配置对象；</li><li><strong>page：</strong>JSP 页面本身（相当于 Java 程序中的 this）；</li><li><strong>exception：</strong>封装页面抛出异常的对象。</li></ul><h2 id="JSP-的-4-种作用域？"><a href="#JSP-的-4-种作用域？" class="headerlink" title="JSP 的 4 种作用域？"></a>JSP 的 4 种作用域？</h2><p><strong>page：</strong>与一个页面相关的对象和属性。<br><strong>request：</strong>与客户端发出的一个请求相关的对象和属性。<br>    一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。<br><strong>session：</strong>与某个用户与服务器建立的一次会话相关的对象和属性。<br>    跟某个用户相关的数据应放在用户自己的 session 中。<br><strong>application：</strong>与整个 Web 应用程序相关的对象和属性。<br>    实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</p><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><h2 id="session-和-cookie-有什么区别？"><a href="#session-和-cookie-有什么区别？" class="headerlink" title="session 和 cookie 有什么区别？"></a>session 和 cookie 有什么区别？</h2><p><strong>存储位置不同：</strong>session 存储在服务器端；cookie 存储在浏览器端。<br><strong>安全性不同：</strong>cookie 安全性一般，在浏览器存储，可被伪造和修改。<br><strong>容量和个数限制：</strong>cookie 有容量限制，每个站点下的 cookie 也有个数限制。<br><strong>存储的多样性：</strong>session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</p><h2 id="session-的工作原理？"><a href="#session-的工作原理？" class="headerlink" title="session 的工作原理？"></a>session 的工作原理？</h2><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p><h2 id="如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="如果客户端禁止 cookie 能实现 session 还能用吗？"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h2><p>可以用，session 只是依赖 cookie 存储 sessionid，若 cookie 被禁用了，可用 url 中添加 sessionid 的方式保证 session 能正常使用。</p><h2 id="Spring-mvc-和-struts-的区别是什么？"><a href="#Spring-mvc-和-struts-的区别是什么？" class="headerlink" title="Spring mvc 和 struts 的区别是什么？"></a>Spring mvc 和 struts 的区别是什么？</h2><p><strong>拦截级别：</strong>struts2 是类级别的拦截；spring mvc 是方法级别的拦截。<br><strong>数据独立性：</strong>spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。<br><strong>拦截机制：</strong>struts2 有自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。<br><strong>对 ajax 的支持：</strong>spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="如何避免-SQL-注入？"><a href="#如何避免-SQL-注入？" class="headerlink" title="如何避免 SQL 注入？"></a>如何避免 SQL 注入？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**防御手段如下：**</span><br><span class="line">验证请求来源地址；</span><br><span class="line">关键操作添加验证码；</span><br><span class="line">在请求地址添加 token 并验证。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<strong>预处理</strong> PreparedStatement。<br>使用<strong>正则表达式过滤</strong>掉字符中的特殊字符。</p><h2 id="什么是-XSS-攻击，如何避免？"><a href="#什么是-XSS-攻击，如何避免？" class="headerlink" title="什么是 XSS 攻击，如何避免？"></a>什么是 XSS 攻击，如何避免？</h2><p><strong>XSS 攻击：</strong>即<em>跨站脚本攻击</em>，它是 Web 程序中常见的漏洞。<br>原理是攻击者往 Web 页面里<strong>插入恶意的脚本代码（css 代码、Javascript 代码等）</strong>，当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的。<br><strong>比如：</strong>盗取用户 cookie、破坏页面结构、重定向到其他网站等。<br><strong>预防 XSS 的核心</strong>：必须对输入的数据做过滤处理。</p><h2 id="什么是-CSRF-攻击，如何避免？"><a href="#什么是-CSRF-攻击，如何避免？" class="headerlink" title="什么是 CSRF 攻击，如何避免？"></a>什么是 CSRF 攻击，如何避免？</h2><p><strong>CSRF：</strong>Cross-Site Request Forgery（<em>跨站请求伪造</em>），可理解为攻击者盗用你的身份发送恶意请求。<br><strong>比如：</strong>以你名义发送邮件、发消息、购买商品，虚拟货币转账等。<br><strong>防御手段如下：</strong></p><ul><li>验证请求来源地址；</li><li>关键操作添加验证码；</li><li>在请求地址添加 token 并验证。</li></ul>]]></content>
    
    
    <summary type="html">Java Web</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="web" scheme="https://southernfish.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>业务相关问题</title>
    <link href="https://southernfish.github.io/2025/06/19/java-business/"/>
    <id>https://southernfish.github.io/2025/06/19/java-business/</id>
    <published>2025-06-19T03:51:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>关于 java 中大批量数据处理的一些记录</p><h1 id="大批量数据导入"><a href="#大批量数据导入" class="headerlink" title="大批量数据导入"></a>大批量数据导入</h1><h2 id="前端大批量数据导入数据库"><a href="#前端大批量数据导入数据库" class="headerlink" title="前端大批量数据导入数据库"></a>前端大批量数据导入数据库</h2><p><strong>前端处理：</strong>用 element plus 的 el-upload 组件来完成文件上传的前端开发。<br><strong>后端处理：</strong>用 springboot 完成文件上传的后台处理逻辑（接收文件、读取文件、文件入库等），从这几个环节考虑提升入库效率，如多线程处理。<br>在 <code>application.properties</code> 中<strong>修改默认限制：</strong><code>spring.servlet.multipart.max-file-size</code> 设置单个文件上传的大小限制，<code>spring.servlet.multipart.max-request-size</code> 设置整个请求（包括所有文件和表单数据）的大小限制。<br><strong>方案</strong></p><ul><li>1、每读取一行数据就插入到数据库，每次都要和数据库通信，非常耗时</li><li>2、考虑批量插入来提高效率，使用 script 来实现数据的批量插入。</li><li>3、在 controller 中使用多线程来将数据批量插入数据库。</li></ul><p>首先要考虑锁和并发的问题。加锁会降低并发性，故<strong>使用生产者/消费者模式，读取文件作为生产，多线程进行消费</strong>。<br>两种技术选型，一个是并发队列 ConcurrentLinkedQueue，一个是 disruptor。这两种队列内部都是基于 CAS + voilatile 实现的。性能上 disruptor 略优于 ConcurrentLinkedQueue，但 disruptor 代码量多一些，以 ConcurrentLinkedQueue 为例。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentLinkedQueue String, queue = new concurrentLinkedQueue();</span><br><span class="line">boolean[] isComplete = &#123;true&#125;;</span><br><span class="line">int[] count = &#123;0&#125;;</span><br><span class="line">CountDownLatch countDownLatch = new CountDownLatch(6);</span><br><span class="line">AtomicInteger atomicSize = new AtomicInteger(0);</span><br><span class="line">while((line = br.readLine())!= null)&#123;</span><br><span class="line">  queue.add(line);</span><br><span class="line">  count[0]= ++count[0];</span><br><span class="line">  if(count[o]== 500)&#123;</span><br><span class="line">    for(int i=0;i&lt;6; i++)&#123;</span><br><span class="line">      new Thread(new Runnable()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run()&#123;</span><br><span class="line">          int num = 0;</span><br><span class="line">          List&lt;Test&gt; list = new ArrayList();</span><br><span class="line">          while(iscompletel0l== true &amp;&amp;count[0] &#123;</span><br><span class="line">            atomicSize.getString line = queue.poll();</span><br><span class="line">            if (line != null)&#123;</span><br><span class="line">              string[l lines = line.split(&quot;,&quot;);</span><br><span class="line">              Test test = new Test(lines[ol, lines[1l, lines[2], lines[3]);</span><br><span class="line">              atomicSize.incrementAndGet();</span><br><span class="line">              list.add(test);</span><br><span class="line">              numt+;</span><br><span class="line">            &#125;</span><br><span class="line">            if(num % 100 == 0)&#123;</span><br><span class="line">              fileUploadservice.insertBatch(list);</span><br><span class="line">              list.clear();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">isCompletelo]= true;</span><br><span class="line">countDownLatch.await();</span><br></pre></td></tr></table></figure><h2 id="前端大批量（百万级）数据导入数据库"><a href="#前端大批量（百万级）数据导入数据库" class="headerlink" title="前端大批量（百万级）数据导入数据库"></a>前端大批量（百万级）数据导入数据库</h2><p><strong>性能瓶颈分析：</strong>一般大数据量 excel 入库场景中，耗时大概在如下几点：<br><strong>耗时1：</strong>读取，字段数量，sheet 页个数，文件体积；选择分片读取及合适的集合存储<br><strong>耗时2：</strong>数据校验，逐行分字段校验；耗时会随字段个数逐渐增加<br><strong>耗时3：</strong>写入，如 Mybatis-plus 的分批插入，采用多线程处理等</p><h3 id="针对耗时1进行优化"><a href="#针对耗时1进行优化" class="headerlink" title="针对耗时1进行优化"></a>针对耗时1进行优化</h3><p>针对百万级数据的读取，要选择分片读取，分片处理，<br>实现 EasyExcel 的 ReadListener 页面读取监听器，<br>实现 invoke 方法，增加 BATCH_COUNT（单次读取条数）配置。单批次BATCH COUNT改为10万<br>读取完后，选择合适的集合容器（ ArrayList）存放临时数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@slf4j</span><br><span class="line">@service</span><br><span class="line">public class EasyExcelImportHandler implements ReadListener&lt;User&gt;&#123;</span><br><span class="line">  /*成功数据*/</span><br><span class="line">  // private final copyOnWriteArrayList&lt;User&gt;successList =new CopyOnWriteArrayList&lt;&gt;();private final List&lt;User&gt;successList= new Arraylist&lt;&gt;();</span><br><span class="line">  /*单次处理条数，有原来2万变为10万*/</span><br><span class="line">  private final static int BATCH COUNT= 100800;</span><br><span class="line"></span><br><span class="line">  @Resource</span><br><span class="line">  private ThreadPoolExecutor threadPoolExecutor；</span><br><span class="line">  @Resource</span><br><span class="line">  private UserMapper userMapper；</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void invoke(User user, AnalysisContext analysisContext)&#123;</span><br><span class="line">    if(stringutils.isNotBlank(user.getName()))&#123;</span><br><span class="line">      successList.add(user);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    //size是否为100000条:这里其实就是分批.当数据等于10w的时候执行一次插入</span><br><span class="line">    if(successList.size()&gt;= BATCH COUNT)&#123;</span><br><span class="line">      log.info(&quot;读取数据:&#123;&#125;&quot;，successList.size());</span><br><span class="line">      saveData();</span><br><span class="line">      //清理集合便于GC回收</span><br><span class="line">      successList.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="针对耗时3进行优化：JDBC分批插入-手动事务控制"><a href="#针对耗时3进行优化：JDBC分批插入-手动事务控制" class="headerlink" title="针对耗时3进行优化：JDBC分批插入+手动事务控制"></a>针对耗时3进行优化：JDBC分批插入+手动事务控制</h3><p>通过 PreparedStatement 的 addBatch() 和 executeBatch() 实现JDBC分批插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// jdbc+事务处理</span><br><span class="line">public void import4]dbc()&#123;</span><br><span class="line">  Connection conn = null; //分批读取+1DBC分批插入+手动事务控制</span><br><span class="line">  Preparedstatement ps = null; // JDBC存储过程</span><br><span class="line">  try &#123;</span><br><span class="line">    conn = JdbcconnectUtil.getconnect(); // 建立jdbc数据库连接</span><br><span class="line">    conn.setAutocommit(false): // 关闭事务默认提交</span><br><span class="line">    String sql =&quot;insert into user (id,name, phone_num, address)values&quot;;sq1 +=&quot;(?,?,?,?)&quot;;</span><br><span class="line">    ps = conn.preparestatement(sql);</span><br><span class="line">    for(int i=0;i&lt;successList.size(); i++)&#123;</span><br><span class="line">      User user = new User();</span><br><span class="line">      ps.setInt(1,successList.get(i).getId());</span><br><span class="line">      ps.setstring(2,successList.get(i).getName());</span><br><span class="line">      ps.setstring(3,successList.get(i).getPhoneNum());</span><br><span class="line">      ps.setstring(4,successlist.get(i).getAddress())</span><br><span class="line">      ps.addBatch(); // 将一组数据添加到此 Preparedstatement对象的批处理命令中。</span><br><span class="line">    &#125;</span><br><span class="line">    ps.executeBatch(); //执行批处理</span><br><span class="line">    conn.commit(); //手动提交争务 </span><br><span class="line">  &#125; catch(Exception e)&#123;</span><br><span class="line">    e.printstackTrace();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">  JdbcconnectUtil.close(conn,ps); // 记得关闭连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="针对耗时3进行优化：多线程-Mybatis-Plus批量插入"><a href="#针对耗时3进行优化：多线程-Mybatis-Plus批量插入" class="headerlink" title="针对耗时3进行优化：多线程+Mybatis-Plus批量插入"></a>针对耗时3进行优化：多线程+Mybatis-Plus批量插入</h3><p>Mybatis-Plus 的 IService 提供了 saveBatch 方法，但其仍是循环调用 INSERT INTO<br><strong>要实现真正批量插入：</strong>用 Mybatis-Plus 注入器增强批量插入、手写 xml 拼接 SQL。<br>建议用注入器（自定义 SQL 注入器实现 DefaultSqlInjector，添加 InsertBatchSomeColumn 方法批量插入。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 采用多线程读取数据</span><br><span class="line">private void saveData() &#123;</span><br><span class="line">  List&lt;List&lt;User&gt;&gt; lists = listUtil.split(successlist, 1000);</span><br><span class="line">  CountDownLatch countDownLatch = new CountDownLatch(lists.size());</span><br><span class="line">  for(list&lt;User&gt;list :lists)&#123;</span><br><span class="line">    threadPoolExecutor.execute(()-&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        userMapper.insertselective(list.stream().map(o-&gt;&#123;</span><br><span class="line">          User user = new User();</span><br><span class="line">          user.setName(o.getName());</span><br><span class="line">          user.setId(o.getId());</span><br><span class="line">          user.setPhoneNum(o.getPhoneNum());</span><br><span class="line">          user.setAddress(o.getAddress());</span><br><span class="line">          return user;</span><br><span class="line">        &#125;).collect(collectors.toList()));</span><br><span class="line">      &#125; catch(Exception e)&#123;</span><br><span class="line">        log.error(&quot;启动线程失败,e:&#123;&#125;&quot;，e.getMessage()，e);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        //执行完一个线程减1,直到执行完</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  //等待所有线程执行完</span><br><span class="line">  try &#123;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">  &#125; catch(Exception e)&#123;</span><br><span class="line">    1og.error(&quot;等待所有线程执行完异常,e:&#123;&#125;&quot;，e.getMessage()，e);</span><br><span class="line">  &#125;</span><br><span class="line">  // 提前将不再使用的集合清空，释放资源</span><br><span class="line">  successList.clear();</span><br><span class="line">  lists.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于 java 中大批量数据处理的一些记录</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="大批量数据处理" scheme="https://southernfish.github.io/tags/%E5%A4%A7%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="https://southernfish.github.io/2025/06/19/java-reflection/"/>
    <id>https://southernfish.github.io/2025/06/19/java-reflection/</id>
    <published>2025-06-19T03:14:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>简单整理了一些关于反射的相关问题。</p><h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><p>反射是在运行状态中，<em>对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性</em>；这种<strong>动态获取信息以及动态调用对象的方法</strong>的功能称为 Java 语言的反射机制。</p><h2 id="什么是-Java-序列化？什么情况下需要序列化？"><a href="#什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="什么是 Java 序列化？什么情况下需要序列化？"></a>什么是 Java 序列化？什么情况下需要序列化？</h2><p>Java 序列化是<strong>为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来</strong>。<br>以下情况需要使用 Java 序列化：</p><ul><li>想把内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>想用套接字在网络上传送对象的时候；</li><li>想通过RMI（远程方法调用）传输对象的时候。</li></ul><h2 id="动态代理是什么？有哪些应用？实现原理？"><a href="#动态代理是什么？有哪些应用？实现原理？" class="headerlink" title="动态代理是什么？有哪些应用？实现原理？"></a><strong>动态代理是什么？有哪些应用？实现原理？</strong></h2><p><strong>动态代理：</strong>运行时动态创建代理对象的技术，通过反射机制生成代理类，无需手动编写代理代码即可实现对目标对象的间接访问和控制。</p><p><strong>动态代理应用：</strong>实现<em>AOP、日志记录、权限校验、hibernate 数据查询、测试框架的后端 mock、rpc</em>等功能</p><p><strong>实现原理：</strong>包括<strong>JDK动态代理（基于接口）和CGLIB动态代理（基于类继承）</strong>。</p><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h2 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h2><p><strong>Remote Procedure Call：</strong>远程过程调用。像调用本地的函数一样去调远程函数，屏蔽远程调用的复杂性。<br><strong>完整的RPC框架：</strong>服务发现、负载、容错、网络传输、序列化等组件</p><h2 id="一个RPC的核心功能由哪5部分组成？"><a href="#一个RPC的核心功能由哪5部分组成？" class="headerlink" title="一个RPC的核心功能由哪5部分组成？"></a>一个RPC的核心功能由哪5部分组成？</h2><p>主要有 5 个部分组成，分别是：<em>客户端、客户端 Stub、网络传输模块、服务端 Stub、服务端</em>等。<br><strong>客户端(Client)：</strong>服务调用方。<br><strong>客户端存根(Client Stub)：</strong>存放服务端地址信息，将客户端请求参数数据信息打包成网络消息，通过网络传输发送给服务端。<br><strong>服务端存根(Server Stub)：</strong>接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。<br><strong>服务端(Server)：</strong>服务的真正提供者。<br><strong>Network Service：</strong>底层传输，可以是 TCP 或 HTTP。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250619112443294.png" alt="image-20250619112443294"></p><h2 id="为什么需要RPC？"><a href="#为什么需要RPC？" class="headerlink" title="为什么需要RPC？"></a>为什么需要RPC？</h2><p>微服务、分布式应用的开发越来越常见，RPC可以<strong>解决各个节点之间的服务调用以及通信问题</strong>。<br><strong>治理功能</strong>，比如连接管理、健康检测、负载均衡、优雅启停机、异常重试、业务分组以及熔断限流等等</p><h2 id="RPC-调用流程？"><a href="#RPC-调用流程？" class="headerlink" title="RPC 调用流程？"></a>RPC 调用流程？</h2><ol><li><strong>服务消费者(Client 客户端)<strong>通过本地调用的方式</strong>调用服务</strong>。</li><li>**客户端存根(Client Stub)<strong>接收到调用请求后负责将方法、入参等</strong>信息序列化(组装)**成能够进行网络传输的消息体。</li><li><strong>客户端存根(Client Stub)<strong>找到远程的服务地址，并且将消息通过网络</strong>发送给服务端</strong>。</li><li>**服务端存根(Server Stub)<strong>收到消息后进行</strong>解码(反序列化)**。</li><li>**服务端存根(Server Stub)**根据解码结果调用本地的服务进行相关处理</li><li><strong>服务端(Server)<strong>本地服务</strong>业务处理</strong>。并将处理结果返回给服务端存根(Server Stub)。</li><li>**服务端存根(Server Stub)**序列化结果。</li><li><strong>服务端存根(Server Stub)<strong>将结果通过网络</strong>发送至消费方</strong>。</li><li>**客户端存根(Client Stub)<strong>接收到消息，并进行</strong>解码(反序列化)**。</li><li><strong>服务消费者(Client 客户端)<strong>服务消费方得到</strong>最终结果</strong>。</li></ol><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250619112546216.png" alt="image-20250619112546216"></p>]]></content>
    
    
    <summary type="html">简单整理了一些关于反射的相关问题。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="反射" scheme="https://southernfish.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="https://southernfish.github.io/2025/06/18/java-thread/"/>
    <id>https://southernfish.github.io/2025/06/18/java-thread/</id>
    <published>2025-06-18T13:19:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于线程、多线程的问题</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h2><p>并行：多个处理器或多核处理器同时处理多个任务。<br>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</p><h2 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h2><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><h2 id="守护线程是什么？"><a href="#守护线程是什么？" class="headerlink" title="守护线程是什么？"></a>守护线程是什么？</h2><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><h2 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h2><p>创建线程列举了<strong>四种方式</strong>：</p><ul><li><strong>继承 Thread 重写 run 方法：</strong>代码简单，但该类无法集成别的类</li><li><strong>实现 Runnable 接口：</strong>继承其他类；同一实现该接口的实例可以共享资源。但代码复杂。</li><li><strong>实现 Callable 接口：</strong>可以获得异步任务的返回值</li><li><strong>线程池方式：</strong>实现自动化装配，易于管理，循环利用资源。</li></ul><h2 id="runnable-和-callable-有什么区别？"><a href="#runnable-和-callable-有什么区别？" class="headerlink" title="runnable 和 callable 有什么区别？"></a>runnable 和 callable 有什么区别？</h2><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p><h2 id="线程有哪些状态？"><a href="#线程有哪些状态？" class="headerlink" title="线程有哪些状态？"></a>线程有哪些状态？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEW 尚未启动</span><br><span class="line">RUNNABLE 正在执行中</span><br><span class="line">BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</span><br><span class="line">WAITING 永久等待状态</span><br><span class="line">TIMED_WAITING 等待指定的时间重新被唤醒的状态</span><br><span class="line">TERMINATED 执行完成</span><br></pre></td></tr></table></figure><h2 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h2><ul><li><strong>类的不同：</strong>sleep() 来自 Thread，wait() 来自 Object。</li><li><strong>释放锁：</strong>sleep() 不释放锁；wait() 释放锁。</li><li><strong>用法不同：</strong>sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll() 直接唤醒。</li></ul><h2 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify()和 notifyAll()有什么区别？"></a>notify()和 notifyAll()有什么区别？</h2><p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。<br>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。<br>而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><h2 id="线程的-run-和-start-有什么区别？"><a href="#线程的-run-和-start-有什么区别？" class="headerlink" title="线程的 run() 和 start() 有什么区别？"></a>线程的 run() 和 start() 有什么区别？</h2><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="创建线程池有哪几种方式？"><a href="#创建线程池有哪几种方式？" class="headerlink" title="创建线程池有哪几种方式？"></a>创建线程池有哪几种方式？</h2><ul><li><strong>newSingleThreadExecutor()：</strong>它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可避免其改变线程数目；</li><li><strong>newCachedThreadPool()：</strong>它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：<ul><li>它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；</li><li>如果线程闲置的时间超过 60 秒，则被终止并移出缓存；</li><li>长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li></ul></li><li><strong>newFixedThreadPool(int nThreads)：</strong>重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。<em>这意味着：</em><ul><li>如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；</li><li>如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li></ul></li><li><strong>newSingleThreadScheduledExecutor()：</strong>创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li><li><strong>newScheduledThreadPool(int corePoolSize)：</strong>和 newSingleThreadScheduledExecutor() 类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li><li><strong>newWorkStealingPool(int parallelism)：</strong>这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li><li><strong>ThreadPoolExecutor()：</strong>是最原始的线程池创建，上面的创建方式几乎都是对 ThreadPoolExecutor 的封装。（最核心）</li></ul><h2 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</span><br><span class="line">SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</span><br><span class="line">STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</span><br><span class="line">TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</span><br><span class="line">TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</span><br></pre></td></tr></table></figure><h2 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h2><p><strong>execute()：</strong>只能执行 Runnable 类型的任务。<br><strong>submit()：</strong>可以执行 Runnable 和 Callable 类型的任务。<br>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p><h2 id="在-Java-程序中怎么保证多线程的运行安全？"><a href="#在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全？"></a>在 Java 程序中怎么保证多线程的运行安全？</h2><p>方法一：使用安全类，比如 Java. util. concurrent 下的类。<br>方法二：使用自动锁 synchronized。<br>方法三：使用手动锁 Lock。（如下代码所示）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock =new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;获得锁&quot;);</span><br><span class="line">&#125; catch(Exception e)&#123;</span><br><span class="line">    // ToDo: handle exception</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    System. out.println(“释放锁&quot;);</span><br><span class="line">    lock. unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程中-synchronized-锁升级的原理是什么？"><a href="#多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么？"></a>多线程中 synchronized 锁升级的原理是什么？</h2><p><strong>synchronized 锁升级原理：</strong>在锁对象的对象头里面有一个 <strong>threadid</strong> 字段，在第一次访问的时候 <strong>threadid 为空，jvm 让其持有偏向锁</strong>，并将 threadid 设置为其线程 id，再次进入的时候会先<strong>判断 threadid 是否与其线程 id 一致</strong>，如果一致则可以直接使用此对象，如果<strong>不一致，则升级偏向锁为轻量级锁</strong>，通过<strong>自旋循环</strong>一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁<strong>从轻量级升级为重量级锁</strong>，此过程就构成了 synchronized 锁的升级。<br><strong>锁的升级的目的：</strong>锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h2 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h2><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><h2 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a>怎么防止死锁？</h2><ul><li>尽量使用 tryLock(long timeout, TimeUnit unit) 的方法 (ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li><li>尽量<strong>使用 Java. util. concurrent 并发类</strong>代替自己手写锁。</li><li>尽量<strong>降低锁的使用粒度</strong>，尽量不要几个功能用同一把锁。</li><li>尽量<strong>减少同步的代码块</strong>。</li></ul><h2 id="ThreadLocal-是什么？有哪些使用场景？"><a href="#ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="ThreadLocal 是什么？有哪些使用场景？"></a>ThreadLocal 是什么？有哪些使用场景？</h2><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><h2 id="synchronized-底层实现原理？"><a href="#synchronized-底层实现原理？" class="headerlink" title="synchronized 底层实现原理？"></a>synchronized 底层实现原理？</h2><p>synchronized 由<strong>一对 monitorenter/monitorexit 指令实现，monitor 对象是同步的基本实现单元</strong>。<br>在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的<strong>互斥锁</strong>，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。<br>在 Java 6 的时候，Java 虚拟机提供了三种 monitor 实现：<strong>偏向锁（Biased Locking）、轻量级锁和重量级锁</strong>，改进了性能。</p><h2 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h2><p>volatile 是<strong>变量修饰符</strong>；synchronized 是<strong>修饰类、方法、代码段</strong>。<br>volatile 仅能实现<strong>变量的修改可见性但不能保证原子性</strong>；而 synchronized 则可以<strong>保证变量的修改可见性和原子性</strong>。<br>volatile 不会造成线程的阻塞；synchronized 可能<strong>会造成线程的阻塞</strong>。</p><h2 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h2><p>synchronized 可以给类、方法、代码块加锁；而 <strong>lock 只能给代码块加锁</strong>。<br>synchronized 不需要手动获取锁和释放锁，发生异常会<strong>自动释放锁</strong>，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。<br>通过 <strong>Lock 可以知道有没有成功获取锁</strong>，而 synchronized 却无法办到。</p><h2 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h2><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但在 Java 6 中对 synchronized 进行了非常多的改进。主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰类、方法、代码块等。</li></ul><h2 id="atomic-的原理？"><a href="#atomic-的原理？" class="headerlink" title="atomic 的原理？"></a>atomic 的原理？</h2><p>atomic 主要利用 CAS (Compare And Wap) 、 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>]]></content>
    
    
    <summary type="html">简单记录一些关于线程、多线程的问题。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="多线程" scheme="https://southernfish.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 基础</title>
    <link href="https://southernfish.github.io/2025/06/18/java-base/"/>
    <id>https://southernfish.github.io/2025/06/18/java-base/</id>
    <published>2025-06-18T10:28:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>关于 java 的一些简单问题</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="JVM-、JDK-和-JRE-有什么区别"><a href="#JVM-、JDK-和-JRE-有什么区别" class="headerlink" title="JVM 、JDK 和 JRE 有什么区别"></a>JVM 、JDK 和 JRE 有什么区别</h2><ul><li><strong>JVM ：</strong><code>(Java Virtual Machine)，Java虚拟机</code>。只认<code>xxx.class</code>文件，能识别<code>class</code> 文件中的字节码指令并调用操作系统向上的 API 完成动作。<code>jvm</code> 是 <code>Java</code> 能够跨平台的核心。</li><li><strong>JRE：</strong><code>(Java Runtime Environment)，Java 运行环境</code>。为 Java 的运行提供了所需环境。主要包含 jvm 的标准实现和 Java 的一些基本类库，相对于 jvm 来说，多出来的是一部分的 Java 类库。</li><li><strong>JDK：</strong><code>(Java Development Kit)，Java 开发工具包</code>。提供了 Java 的开发环境和运行环境。jdk 是整个 Java 开发的核心，集成了 jre 和一些好用 Java 程序调试和分析的小工具。如：<code>javac.exe</code>，<code>java.exe</code>，<code>jar.exe</code> 等</li></ul><h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals 的区别"></a>== 和 equals 的区别</h2><ul><li><p><strong>== 解读</strong>：</p><p><em>基本类型：</em>比较的是值是否相同；                          <em>引用类型：</em>比较的是引用是否相同； </p><p>若指向同一个引用，== 为 true，而 <code>new String()</code> 方法重新开辟了内存空间， == 结果为 false，而 equals 比较的是值，结果为 true</p></li><li><p><strong>equals 解读</strong>：equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较</p></li><li><p><strong>总结</strong>： == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，String、Integer 等类重写了equals，把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p></li></ul><h2 id="两个对象的-hashCode-相同，则-equals-也一定为-true，对吗"><a href="#两个对象的-hashCode-相同，则-equals-也一定为-true，对吗" class="headerlink" title="两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗"></a>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗</h2><p>不对，两个对象的 <code>hashCode()</code> 相同，equals() 不一定 true。代码解读：显然“通话”和“重地”的 hashCode() 相同，然而 equals()为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = “通话”;</span><br><span class="line">String str2 = &quot;重地”;</span><br><span class="line">System. out.printIn(string. format(&quot;str1:%d|str2:%d&quot;, str1. hashcode(),str2. hashcode()));</span><br><span class="line">System. out.println(str1. equals(str2));</span><br><span class="line"></span><br><span class="line"># 打印结果</span><br><span class="line">str1:1179395 | str2:1179395</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h2 id="Java-中的-Math-round-1-5-等于多少"><a href="#Java-中的-Math-round-1-5-等于多少" class="headerlink" title="Java 中的 Math. round(-1. 5) 等于多少"></a>Java 中的 Math. round(-1. 5) 等于多少</h2><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p><h2 id="final-在-Java-中有什么作用"><a href="#final-在-Java-中有什么作用" class="headerlink" title="final 在 Java 中有什么作用"></a>final 在 Java 中有什么作用</h2><ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><h2 id="基础的数据类型"><a href="#基础的数据类型" class="headerlink" title="基础的数据类型"></a>基础的数据类型</h2><p>基础类型有 8 种：<code>byte</code>、<code>boolean</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code></p><p> <code>String</code> 不属于基础类型， String 属于对象</p><h2 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Files. exists()：检测文件路径是否存在。</span><br><span class="line">Files. createFile()：创建文件。</span><br><span class="line">Files. createDirectory()：创建文件夹。</span><br><span class="line">Files. delete()：删除一个文件或目录。</span><br><span class="line">Files. copy()：复制文件。</span><br><span class="line">Files. move()：移动文件。</span><br><span class="line">Files. size()：查看文件个数。</span><br><span class="line">Files. read()：读取文件。</span><br><span class="line">Files. write()：写入文件。</span><br></pre></td></tr></table></figure><h1 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h1><h2 id="Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>Java 中操作字符串都有哪些类？它们之间有什么区别？</h2><p>操作字符串的类有：<code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code>。</p><p>String 和 StringBuffer、StringBuilder 的区别在于 <strong><code>String</code> 声明的是不可变的对象，每次操作都会生成新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象</strong>，而 <code>StringBuffer</code>、<code>StringBuilder</code> 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p><p>StringBuffer 和 StringBuilder 最大的区别在于，**<code>StringBuffer 线程安全，而 StringBuilder</code> 非线程安全**，但 <code>StringBuilder</code> 性能高于 <code>StringBuffer</code>，所以在单线程环境下推荐使用 <code>StringBuilder</code>，多线程环境下推荐使用 <code>StringBuffer</code>。</p><h2 id="String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="String str=”i”与 String str=new String(“i”)一样吗？"></a>String str=”i”与 String str=new String(“i”)一样吗？</h2><p>不一样，因为内存的分配方式不一样。</p><p><code>String str = ”i”</code> 的方式，Java 虚拟机会将其分配到常量池中；</p><p><code>String str = new String(“i”) </code>则会被分到堆内存中。</p><h2 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="如何将字符串反转？"></a>如何将字符串反转？</h2><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// stringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer = new stringBuffer();</span><br><span class="line">stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuffer. reverse()); // gfedcba</span><br><span class="line">// stringBuilder reverse</span><br><span class="line">stringBuilder stringBuilder =new stringBuilder();</span><br><span class="line">stringBuilder. append(&quot;abcdefg&quot;);System. out. println(stringBuilder. reverse()); // gfedcba</span><br></pre></td></tr></table></figure><h2 id="String-类的常用方法"><a href="#String-类的常用方法" class="headerlink" title="String 类的常用方法"></a>String 类的常用方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">indexOf()：返回指定字符的索引。</span><br><span class="line">charAt()：返回指定索引处的字符。</span><br><span class="line">replace()：字符串替换。</span><br><span class="line">trim()：去除字符串两端空白。</span><br><span class="line">split()：分割字符串，返回一个分割后的字符串数组。</span><br><span class="line">getBytes()：返回字符串的 byte 类型数组。</span><br><span class="line">length()：返回字符串长度。</span><br><span class="line">toLowerCase()：将字符串转成小写字母。</span><br><span class="line">toUpperCase()：将字符串转成大写字符。</span><br><span class="line">substring()：截取字符串。</span><br><span class="line">equals()：字符串比较。</span><br></pre></td></tr></table></figure><h1 id="抽象类问题"><a href="#抽象类问题" class="headerlink" title="抽象类问题"></a>抽象类问题</h1><h2 id="抽象类必须要有抽象方法吗"><a href="#抽象类必须要有抽象方法吗" class="headerlink" title="抽象类必须要有抽象方法吗?"></a>抽象类必须要有抽象方法吗?</h2><p>不需要，抽象类不一定非要有抽象方法。</p><h2 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h2><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。抽象类不能直接实例化，普通类可以直接实例化。</p><h2 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h2><p>不能，定义抽象类就是让其他类继承的，定义为 <code>final</code>的类不能被继承，所以 final 不能修饰抽象类，编辑器也会提示错误信息：<code>illegal combination of modifiers: &#39;abstract&#39; and &#39;final</code></p><h2 id="接口和抽象类有什么区别？"><a href="#接口和抽象类有什么区别？" class="headerlink" title="接口和抽象类有什么区别？"></a>接口和抽象类有什么区别？</h2><ul><li><strong>实现：</strong>抽象类的子类使用 <code>extends</code> 来继承；接口必须使用 <code>implements</code> 来实现接口。</li><li><strong>构造函数：</strong>抽象类可以有构造函数；接口不能有。</li><li><strong>实现数量：</strong>类可以实现很多个接口；但是只能继承一个抽象类。</li><li><strong>访问修饰符：</strong>接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li></ul><h1 id="Java中的IO"><a href="#Java中的IO" class="headerlink" title="Java中的IO"></a>Java中的IO</h1><h2 id="Java-中-IO-流分为几种？"><a href="#Java-中-IO-流分为几种？" class="headerlink" title="Java 中 IO 流分为几种？"></a>Java 中 IO 流分为几种？</h2><ul><li><strong>按功能来分：</strong>输入流（input）、输出流（output）。</li><li><strong>按类型来分：</strong>字节流和字符流。字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</li></ul><h2 id="BIO、NIO、AIO-有什么区别？"><a href="#BIO、NIO、AIO-有什么区别？" class="headerlink" title="BIO、NIO、AIO 有什么区别？"></a>BIO、NIO、AIO 有什么区别？</h2><ul><li><strong>BIO：</strong><code>Block IO</code>，同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li><strong>NIO：</strong><code>Non IO</code>，同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 <code>Channel</code>（通道）通讯，实现了多路复用。</li><li><strong>AIO：</strong><code>Asynchronous IO</code>，是 NIO 的升级，也叫 <code>NIO2</code>，<strong>实现了异步非堵塞 IO</strong> ，异步 IO 的操作基于事件和回调机制。</li></ul><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="Lambda表达式的语法"><a href="#Lambda表达式的语法" class="headerlink" title="Lambda表达式的语法"></a>Lambda表达式的语法</h2><p><strong>基本语法：</strong> <code>(parameters) -&gt; expression</code> 或<code> (parameters) -&gt;&#123; statements; &#125;</code></p><p><strong>Lambda表达式由三部分组成：</strong></p><ul><li><strong>paramaters：</strong>类似方法中的形参列表，这里的参数是函数式接口里的参数。这里的参数类型可以明确的声明也可不声明而由JVM隐含的推断。另外当只有一个推断类型时可以省略掉圆括号。</li><li><strong>-&gt;：</strong>可理解为“被用于”的意思</li><li><strong>方法体：</strong>可以是表达式也可以代码块，是函数式接口里方法的实现。代码块可返回一个值或者什么都不反回，这里的代码块块等同于方法的方法体。如果是表达式，也可以返回一个值或者什么都不反回。</li></ul><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong>代码简洁，开发迅速、方便函数式编程、容易进行并行计算、Java 引入 Lambda，改善了集合操作</li><li><strong>缺点：</strong>代码可读性变差、在非并行计算中，很多计算未必有传统的 for 性能要高、不易调试</li></ul><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(s -&gt; s.length() &gt; 3).forEach(System.out::println);</span><br><span class="line">list.stream().map(StuffEntity::getCode).collect(Collectors.toList());</span><br><span class="line">list.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(</span><br><span class="line">                () -&gt; new TreeSet&lt;&gt;(Comparator.comparing(obj -&gt; obj.getDealerPlan() ))), ArrayList::new));</span><br><span class="line">Map&lt;String, List&lt;VpEntity&gt;&gt; map = stuffVp.stream().collect(Collectors.groupingBy(obj -&gt; obj.getDealerPlan() ));</span><br></pre></td></tr></table></figure><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="Java-容器都有哪些？"><a href="#Java-容器都有哪些？" class="headerlink" title="Java 容器都有哪些？"></a>Java 容器都有哪些？</h2><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collection</span><br><span class="line">    List</span><br><span class="line">        ArrayList</span><br><span class="line">        LinkedList</span><br><span class="line">        Vector</span><br><span class="line">        Stack</span><br><span class="line">    Set</span><br><span class="line">        HashSet</span><br><span class="line">        LinkedHashSet</span><br><span class="line">        TreeSet</span><br><span class="line">Map</span><br><span class="line">    HashMap </span><br><span class="line">        LinkedHashMap</span><br><span class="line">    TreeMap</span><br><span class="line">    ConcurrentHashMap</span><br><span class="line">    Hashtable</span><br></pre></td></tr></table></figure><h2 id="Collection-和-Collections-有什么区别"><a href="#Collection-和-Collections-有什么区别" class="headerlink" title="Collection 和 Collections 有什么区别"></a>Collection 和 Collections 有什么区别</h2><p><code>Collection</code> 是一个<strong>集合接口，它提供了对集合对象进行基本操作的通用接口方法</strong>，所有集合都是它的子类，比如 List、Set 等。<code>Collections</code> 是一个<strong>包装类，包含了很多静态方法，不能被实例化，就像一个工具类</strong>，比如提供的排序方法：<code>Collections. sort(list)</code>。</p><h2 id="List、Set、Map-之间的区别是什么？"><a href="#List、Set、Map-之间的区别是什么？" class="headerlink" title="List、Set、Map 之间的区别是什么？"></a>List、Set、Map 之间的区别是什么？</h2><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。三者之间的区别，如下表：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/20250618204117.png"></p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="HashMap-和-Hashtable-有什么区别？"><a href="#HashMap-和-Hashtable-有什么区别？" class="headerlink" title="HashMap 和 Hashtable 有什么区别？"></a>HashMap 和 Hashtable 有什么区别？</h2><ul><li><strong>存储：</strong><code>HashMap</code> 允许 key 和 value 为 null，而 <code>Hashtable</code> 不允许。</li><li><strong>线程安全：</strong><code>Hashtable</code> 是线程安全的，而 <code>HashMap</code> 是非线程安全的。</li><li><strong>推荐使用：</strong>在 <code>Hashtable</code> 的类注释可以看到，<code>Hashtable</code> 是保留类不建议使用，推荐在单线程环境下使用 <code>HashMap</code> 替代，如果需要多线程使用则用 <code>ConcurrentHashMap</code> 替代。</li></ul><h2 id="HashMap-的实现原理？"><a href="#HashMap-的实现原理？" class="headerlink" title="HashMap 的实现原理？"></a>HashMap 的实现原理？</h2><p>HashMap 基于 <strong>Hash 算法</strong>实现的，我们通过 <strong><code>put(key,value)</code>存储，<code>get(key)</code>来获取</strong>。当传入 key 时，HashMap 会根据 key. <code>hashCode()</code> 计算出 hash 值，根据 hash 值将 value 保存在 <code>bucket</code> 里。当<strong>计算出的 hash 值相同时，我们称为 hash 冲突</strong>，HashMap 的做法是<strong>用链表和红黑树存储相同 hash 值的 value</strong>。当 <code>hash 冲突</code>的个数比较少时，使用链表否则使用红黑树。</p><h2 id="HashMap为什么线程不安全？"><a href="#HashMap为什么线程不安全？" class="headerlink" title="HashMap为什么线程不安全？"></a>HashMap为什么线程不安全？</h2><p>主要原因在于其<strong>内部结构的非原子性操作和缺乏同步机制</strong>，导致<strong>多线程并发操作时可能引发数据不一致、死循环、数据覆盖</strong>等问题‌。</p><h2 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h2><p>对于在 Map 中<strong>插入、删除、定位</strong>一个元素这类操作，<code>HashMap</code> 是最好的选择，因为相对而言 HashMap 的插入会更快，但是如果你要对一个 key 集合进行<strong>有序的遍历</strong>，那 <code>TreeMap</code> 是更好的选择。</p><h2 id="HashSet-的实现原理？"><a href="#HashSet-的实现原理？" class="headerlink" title="HashSet 的实现原理？"></a>HashSet 的实现原理？</h2><p><code>HashSet</code> 是基于 <code>HashMap</code> 实现的，HashSet 不允许重复的值。<br>HashSet 保证元素不重复是利用 HashMap 的 <code>put</code> 方法实现的，在<strong>存储之前先根据 key 的 <code>hashCode 和 equals </code>判断是否已存在，如果存在就不在重复插入了</strong>，这样就保证了元素的不重复。</p><h2 id="HashMap-和-ConcurrentHashMap-有什么区别？"><a href="#HashMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 有什么区别？"></a>HashMap 和 ConcurrentHashMap 有什么区别？</h2><p><code>ConcurrentHashMap</code>的线程安全实现</p><ul><li><strong>Java7：</strong>分段锁(Segment)。将数据分成多个段，每段独立加锁，不同段的操作可并发。</li><li><strong>Java 8+：</strong><code>CAS(无锁算法)+ synchronized(锁单个桶的头节点)</code>。锁粒度更细，并发度更高。插入时，如果桶为空，用 CAS 添加;否则锁住头节点再操作。<code>CAS（Compare And Swap(比较与交换)）</code>。读操作通常无锁(依赖 volatile 保证可见性)。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/20250618205242.png"></p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h2><ul><li><strong>数据结构实现：</strong><code>ArrayList</code> 是动态数组的数据结构实现，而 <code>LinkedList</code> 是双向链表的数据结构实现。</li><li><strong>随机访问效率：</strong><code>ArrayList</code> 比 <code>LinkedList </code>在随机访问的时候效率要高，因为 <code>LinkedList</code> 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li><strong>增加和删除效率：</strong>在非首尾的增加和删除操作，<code>LinkedList</code> 要比 <code>ArrayList</code> 效率要高，因为 <code>ArrayList</code> 增删操作要影响数组内的其他数据的下标。</li></ul><h2 id="如何实现数组和-List-之间的转换？"><a href="#如何实现数组和-List-之间的转换？" class="headerlink" title="如何实现数组和 List 之间的转换？"></a>如何实现数组和 List 之间的转换？</h2><ul><li>数组转 List：使用 <code>Arrays. asList(array)</code> 进行转换。</li><li>List 转数组：使用 List 自带的 <code>toArray()</code> 方法。</li></ul><h2 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h2><ul><li><strong>线程安全：</strong><code>Vector</code> 使用了 <code>Synchronized</code> 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>**性能：<code>**ArrayList</code> 在性能方面要优于 <code>Vector</code>。</li><li><strong>扩容：</strong><code>ArrayList 和 Vector</code> 都会根据实际需要动态调整容量，不过 <code>Vector 扩容每次会增加 1 倍</code>，而 <code>ArrayList 增加 50%</code>。</li></ul><h2 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h2><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 <code>addAll、removeAll、iteration</code> 等方法只有 ArrayList 有。</p><h1 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h1><h2 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h2><p><strong>Iterator 接口提供遍历任何 Collection 的接口</strong>。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，<strong>迭代器允许调用者在迭代过程中移除元素</strong>。</p><h2 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h2><p>Iterator 使用代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;string&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;string&gt;it = list.iterator();</span><br><span class="line">while(it.hasNext()*)&#123;</span><br><span class="line">    String obj = it.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改时，就会抛出 ConcurrentModificationException 异常。</p><h2 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h2><p><code>Iterator</code> 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br><code>Iterator</code> 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。<br><code>ListIterator</code> 从 Iterator 接口继承，添加了一些额外功能，如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p><h1 id="其他相关问题"><a href="#其他相关问题" class="headerlink" title="其他相关问题"></a>其他相关问题</h1><h2 id="在-Queue-中-poll-和-remove-有什么区别？"><a href="#在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="在 Queue 中 poll()和 remove()有什么区别？"></a>在 Queue 中 poll()和 remove()有什么区别？</h2><p><strong>相同点：</strong>都是返回第一个元素，并在队列中删除返回的对象。<br><strong>不同点：</strong>如果没有元素 <code>poll()</code> 会返回 null，而 <code>remove()</code>会直接抛出 <code>NoSuchElementException</code> 异常。</p><h2 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h2><p><code>Vector、Hashtable、Stack</code> 都是线程安全的，而像 HashMap 则是非线程安全的，JDK 1.5 之后随着 <code>Java. util. concurrent</code> 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 <code>ConcurrentHashMap</code>。</p><h2 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h2><p>使用 <code>Collections. unmodifiableCollection(Collection c) </code>方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。<br>示例代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;string&gt; list = new ArrayList&lt;&gt;();list. add(&quot;x”);</span><br><span class="line">Collection&lt;string&gt;clist = collections.unmodifiablecollection(list),clist. add(&quot;y”);// 运行时此行报错</span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于 java 的一些简单问题</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://southernfish.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个人博客搭建</title>
    <link href="https://southernfish.github.io/2025/06/18/hexo-blog-build/"/>
    <id>https://southernfish.github.io/2025/06/18/hexo-blog-build/</id>
    <published>2025-06-18T06:47:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 是一个简单、轻量、基于Node的静态博客<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020">框架</a>，可以方便的生成静态网页托管于GitHub和Heroku。本文以 Hexo + GitHub Pages + Typora + PicGo 为例。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p><strong>1、<a href="https://nodejs.org/en/download/">下载node</a>并安装。</strong>安装好node，会默认一起安装好 npm 包管理器，可通过（Ctrl+R）打开 cmd 终端，使用以下命令查看安装版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v </span><br><span class="line">npm -version</span><br></pre></td></tr></table></figure><p><strong>2、安装 git，配置个人信息。</strong>官网下载，选择自己操作系统的版本，根据提示一直 next 就装好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;xxxxxx@qq.com&quot;</span><br></pre></td></tr></table></figure><p><strong>生成密钥。</strong>一般是在 <strong>~/.ssh</strong> 路径下，其中 id_rsa 存储私钥（<strong>不要共享私钥</strong>），id_rsa.pub 存储公钥。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxxxxx@qq.com&quot;</span><br></pre></td></tr></table></figure><p>GitHub公钥配置步骤：登录 GitHub → Settings → SSH and GPG keys → New SSH key → 填写相关信息(如下) →  Add SSH key<br>填写信息如下：</p><p><strong>Title：</strong>标识密钥用途Key；</p><p><strong>type：</strong>保持默认 Authentication Key；</p><p><strong>Key：</strong>公钥内容</p><p><strong>3、测试 SSH 连接，</strong>出现如下则配置成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">Hi username! You&#x27;ve successfully authenticated...</span><br></pre></td></tr></table></figure><p>配置完 SSH 后，之后使用远程仓库的方式更新为 SSH 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:username/repo.git</span><br><span class="line">git remote -v</span><br><span class="line"># 显示 ssh 地址（git@github.com:...）则生效</span><br></pre></td></tr></table></figure><p>克隆新仓库地址也使用 SSH。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 克隆新仓库</span><br><span class="line">git clone git@github.com:username/repo.git</span><br></pre></td></tr></table></figure><p><strong>4、安装 hexo 及相关依赖 。</strong>在 git 终端执行安装 hexo 相关命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo --save</span><br><span class="line">npm install hexo-deployer-git --save # 用于部署发布</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h1 id="Hexo项目构建"><a href="#Hexo项目构建" class="headerlink" title="Hexo项目构建"></a>Hexo项目构建</h1><p><strong>1、开始搭建Hexo项目。</strong>自定义一个文件夹（我的路径是：<code>E://WorkSpace/fishblog</code>），在命令行窗口进入目录，或直接从本机进入文件夹，右键打开 Git Bash Here，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">hexo g </span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><code>hexo g </code>是 <code>hexo generate</code> 的简便写法；<code>hexo s</code> 是 <code>hexo server</code> 的简便写法。<code>hexo s</code>启动本地服务器，在浏览器打开localhost:4000即可看到效果。关闭本地服务：Ctrl + C 。部署的命令也可以并列的写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s -- 本地</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d -- 远程部署（发布到github）</span><br></pre></td></tr></table></figure><p><strong>2、新建博客文件。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;article title&quot;</span><br></pre></td></tr></table></figure><p>项目中 <code>/source/_posts </code>将会看到<code> article title.md</code> 文件。编辑之后运行生成、部署命令便可发布。我使用 Typora 编辑，后续会讲到 Typora 相关配置。之后也可以直接在该路径下新建md文件，上传到 GitHub，后续会讲到如何自动化部署发布。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g   # 生成</span><br><span class="line">hexo d   # 部署</span><br><span class="line">hexo d -g # 在部署前先生成</span><br></pre></td></tr></table></figure><p><strong>3、个性化设置。</strong>主题替换、卡通人物、数字统计等。渲染md文件还需执行如下命令安装依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-renderer-markdown-it --save # 需要安装这个渲染插件</span><br></pre></td></tr></table></figure><p>卡通人物。选自己喜欢的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line">npm install live2d-widget-model-haruto</span><br></pre></td></tr></table></figure><p>主题替换。挑一个喜欢 blog theme，此处以 <code>butterfly</code> 为例，点进去（多数是贡献者的博客网站）找到当前主题的 GitHub 仓库入口（通常情况在博客的正下方），进入 GitHub 克隆当前仓库，放在 Hexo 所在目录的 themes 文件夹下（原目录下有一个默认的 landscape 主题，新主题目录和它同级）。修改 Hexo 根目录下的 <code>_config.yml</code> 文件，找到 theme 配置项，修改为克隆的主题名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/jerryc127/hexo-theme-butterfly.git</span><br></pre></td></tr></table></figure><p>统计数字、数学公式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save # 统计数字</span><br><span class="line">npm install @neilsustc/markdown-it-katex --save # 渲染数学公式</span><br></pre></td></tr></table></figure><p><strong>4、新建分类、目录、标签 。</strong>修改对应的 md 文件便可自定义属于自己的分类、标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about      # 根目录/source/about/index.md</span><br><span class="line">hexo new page categories # 根目录/source/categories/index.md</span><br><span class="line">hexo new page tags       # 根目录/source/tags/index.md</span><br></pre></td></tr></table></figure><p>编辑md文件时，注意多个分类写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分级c2是c1的子类</span><br><span class="line">categories:</span><br><span class="line">- c1</span><br><span class="line">- c2</span><br><span class="line">同级多类</span><br><span class="line">categories:</span><br><span class="line">- [c1]</span><br><span class="line">- [c2]</span><br></pre></td></tr></table></figure><p>相应的配置 <code>_config.yml</code> 文件设置。其他更多配置可参考<a href="https://segmentfault.com/a/1190000042212798?utm_source=sf-similar-article">文章</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 右下角的卡通人物</span><br><span class="line">## https://github.com/xiazeyu/live2d-widget-models/tree/master/packages</span><br><span class="line">lived2:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptForm: local</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-haruto # model name select</span><br><span class="line">  display: # model position size</span><br><span class="line">    position: left</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br><span class="line"></span><br><span class="line"># 主题配置，更换主题需要将主题放在landscape同级文件夹下，名字就是文件夹名   </span><br><span class="line">theme: butterfly </span><br><span class="line"></span><br><span class="line"># 数学 katex</span><br><span class="line">markdown:</span><br><span class="line">  plugins:</span><br><span class="line">    - plugin:</span><br><span class="line">      name: &#x27;@neilsustc/markdown-it-katex&#x27;</span><br><span class="line">      options:</span><br><span class="line">        strict: false</span><br></pre></td></tr></table></figure><h1 id="将Hexo与GitHub-Page-关联起来"><a href="#将Hexo与GitHub-Page-关联起来" class="headerlink" title="将Hexo与GitHub Page 关联起来"></a>将Hexo与GitHub Page 关联起来</h1><p>此处使用私有库 fishBlog 存储 hexo 项目，也就是你自己新建的项目，公共库 <code>username.github.io</code> 存储编译后的静态文件以便访问。<br><strong>1、上传 hexo 项目，并完成相关配置。</strong>上传之前，需要更新一下 <code>.gitignore</code> 文件。默认情况下 <code>public/</code> 不会被上传(也不该被上传)，确保 <code>.gitignore</code> 文件中包含一行 <code>public/</code>。</p><p>上传完成之后，将该项目设置为<strong>私有</strong>，配置 Repository secrets 。进入该项目 →  Settings → Secrets and variables → Actions → New repository secret 。新建<code> HEXO_DEPLOY_PRI</code>（配置deploy.yml会用到）,  <code>GIT_PASSWORD</code></p><p><strong>2、创建一个公共库 <code>username.github.io</code>。</strong>设置为 public 并初始化，用同样的方法新建<code> HEXO_DEPLOY_PRI</code>。</p><p>开启 pages 功能：进入该公共库 →  Settings → 左侧Pages → Build and deployment → 选择 <code>main</code> 分支， <code>/root</code>  →  save</p><p>站点配置文件_config.yml 中配置 url 和 deploy 配置项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url: https://southernfish.github.io/</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:username/username.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p><strong>3、创建GitHub Actions工作流。</strong>在你的私有库中，创建一个新的目录<code>.github/workflows/</code>，并在其中创建<code>deploy.yml</code>文件。该文件将包含自动部署的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"># Action的名字</span><br><span class="line">name: Deploy Hexo Action Name</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main</span><br><span class="line"></span><br><span class="line">#这里放环境变量,需要替换成自己的</span><br><span class="line">env:</span><br><span class="line">  # Hexo编译后使用此 git用户部署到github仓库</span><br><span class="line">  GIT_USER: username</span><br><span class="line">  # Hexo 编译后使用此 git邮箱部署到github仓库</span><br><span class="line">  GIT_EMAIL: xxxxxx@qq.com</span><br><span class="line">  # Hexo编译后要部署的github仓库</span><br><span class="line">  GIT_DEPLOY_REPO: username/username.github.io</span><br><span class="line">  # Hexo编译后要部署到的分支</span><br><span class="line">  GIT_DEPLOY_BRANCH: main</span><br><span class="line"># 工作流</span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    name: Build on node</span><br><span class="line">    runs-on: ubuntu-latest # 使用 Ubuntu 最新版</span><br><span class="line">    if: github.event.repository.owner.id == github.event.sender.id</span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        os: [ubuntu-latest]</span><br><span class="line">        node_version: [12.x] # 使用 Node.js 12.x 版本</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - name: Checkout code</span><br><span class="line">        uses: actions/checkout@v2 # 检出代码到 runner</span><br><span class="line"></span><br><span class="line">      - name: Checkout deploy repo</span><br><span class="line">        uses: actions/checkout@v2</span><br><span class="line">        with:</span><br><span class="line">          repository: $&#123;&#123; env.GIT_DEPLOY_REPO &#125;&#125;</span><br><span class="line">          ref: $&#123;&#123; env.GIT_DEPLOY_BRANCH &#125;&#125;</span><br><span class="line">          path: .deploy_git</span><br><span class="line"></span><br><span class="line">      - name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125; # 设置 Node.js 环境</span><br><span class="line">        uses: actions/setup-node@v1</span><br><span class="line">        with:</span><br><span class="line">          node-version: $&#123;&#123; matrix.node_version &#125;&#125; # 使用 Node.js 的版本，根据需要调整</span><br><span class="line"></span><br><span class="line">      - name: Configuration environment # 设置密钥、设置Git信息</span><br><span class="line">        env:</span><br><span class="line">          HEXO_DEPLOY_PRI: $&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span><br><span class="line">        run: |</span><br><span class="line">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br><span class="line">          mkdir -p ~/.ssh/</span><br><span class="line">          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span><br><span class="line">          chmod 600 ~/.ssh/id_rsa</span><br><span class="line">          ssh-keyscan -t rsa github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="line">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br><span class="line">          git config --global user.name $GIT_USER</span><br><span class="line">          git config --global user.email $GIT_EMAIL</span><br><span class="line"></span><br><span class="line">      - name: Install dependencies # 安装hexo和其他依赖</span><br><span class="line">        run: |</span><br><span class="line">          npm install hexo-cli -g</span><br><span class="line">          npm install --save</span><br><span class="line"></span><br><span class="line">      - name: Deploy hexo # 包含了clean、generate、deploy</span><br><span class="line">        run: |</span><br><span class="line">          npm run deploy</span><br></pre></td></tr></table></figure><p><strong>4、参考链接</strong></p><ul><li><a href="https://docs.github.com/zh/pages">GitHub Pages</a></li><li><a href="https://docs.github.com/zh/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#publishing-with-a-custom-github-actions-workflow">使用自定义 GitHub Actions 工作流进行发布</a></li><li><a href="https://github.com/marketplace/actions/deploy-github-pages-site">actions/deploy-github-pages-site</a></li></ul><h1 id="PicGo安装"><a href="#PicGo安装" class="headerlink" title="PicGo安装"></a>PicGo安装</h1><p>1、下载安装。直接根据提示安装，路径可自己指定。</p><p>2、PicGo<code>预置的有四种链接格式：</code>Markdown<code>、</code>HTML<code>、</code>URL<code>、</code>UBB`，其得到的上传文件链接分别为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Makdown: ![](https://i.loli.net/2021/09/14/KB3LimF5SGtI6vf.png)</span><br><span class="line">HTML: &lt;img src=&quot;https://i.loli.net/2021/09/14/KB3LimF5SGtI6vf.png&quot;/&gt;</span><br><span class="line">URL: https://i.loli.net/2021/09/14/KB3LimF5SGtI6vf.png</span><br><span class="line">UBB: [IMG]https://i.loli.net/2021/09/14/KB3LimF5SGtI6vf.png[/IMG]</span><br></pre></td></tr></table></figure><p>3、自定义链接格式<code>Custom</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Custom:  &lt;center&gt;&lt;img src=&quot;$url&quot; alt=&quot;$fileName&quot;/&gt;&lt;/center&gt;</span><br></pre></td></tr></table></figure><p>4、PicGo设置中可以配置如日志、代理等设置，一定要注意要打开该自动复制URL的设置<strong>上传后自动复制URL：开</strong></p><p>5、图床设置，此处使用GitHub图床。首先需要在 GitHub 中初始化一个 公共库 ImageHostServer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设定仓库名: username/ImageHostServer</span><br><span class="line">设定分支名: main</span><br><span class="line">设定Token: xxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">指定存储路径: /hexo</span><br><span class="line">设定自定义域名：此处我没用到，便不做设置</span><br></pre></td></tr></table></figure><p>Token 设置方式：Settings → Developer Settings → personal access tokens → Fine-grained → Generate new token → 设置名字为ImageHostServerToken → 找到Repository access → 选择 Only select repositories，并选择库 ImageHostServer → 找到 Repository permissions 的 contens  → 点击右侧下拉按钮设置为 Read and write → Generate token → 复制Token值并保存下来，picGo配置需要</p><h1 id="Typora-安装"><a href="#Typora-安装" class="headerlink" title="Typora 安装"></a>Typora 安装</h1><p>1、安装可参考<a href="https://www.cnblogs.com/fengyanqiblog/p/18928611">Typora安装及破解</a></p><p>2、配置。打开 Typora 的偏好设置，选择图像，把插入图片设置为上传图片；上传服务设置为 PicGo(app) ，PicGo路径设置为PicGo的安装路径（D:\HexoBlog\Typora\Typora.exe），配置完成之后，点击验证上传，提示成功上传图片并获得新的URL则说明成功了。如若不成功检测一下 PicGo设置的server设置端口是否一致，不一致的话需要改成一致。</p>]]></content>
    
    
    <summary type="html">本文以 Hexo + GitHub Pages + Typora + PicGo 为例介绍搭建一个 Hexo 博客日志。</summary>
    
    
    
    <category term="hexo" scheme="https://southernfish.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://southernfish.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://southernfish.github.io/2022/08/10/hello-world/"/>
    <id>https://southernfish.github.io/2022/08/10/hello-world/</id>
    <published>2022-08-10T01:15:36.000Z</published>
    <updated>2025-06-19T13:36:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">hello word</summary>
    
    
    
    <category term="hexo" scheme="https://southernfish.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://southernfish.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
