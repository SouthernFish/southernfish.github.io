<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Southern Fish</title>
  
  
  <link href="https://southernfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://southernfish.github.io/"/>
  <updated>2025-06-19T06:57:23.572Z</updated>
  <id>https://southernfish.github.io/</id>
  
  <author>
    <name>Southern Fish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络</title>
    <link href="https://southernfish.github.io/2025/06/19/java-network/"/>
    <id>https://southernfish.github.io/2025/06/19/java-network/</id>
    <published>2025-06-19T06:57:23.572Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些Java中关于网络相关的一些问题</p><h2 id="http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="http 响应码 301 和 302 代表的是什么？有什么区别？"></a>http 响应码 301 和 302 代表的是什么？有什么区别？</h2><p><strong>301：</strong>永久重定向。<br><strong>302：</strong>暂时重定向。<br>区别在于<strong>301 对搜索引擎优化（SEO）更加有利，302 有被提示为网络拦截的风险</strong>。</p><h2 id="forward-和-redirect-的区别？"><a href="#forward-和-redirect-的区别？" class="headerlink" title="forward 和 redirect 的区别？"></a>forward 和 redirect 的区别？</h2><p>forward 是转发 和 redirect 是重定向。</p><ul><li><strong>地址栏 url 显示：</strong>foward url 不会发生改变，redirect url 会发生改变；</li><li><strong>数据共享：</strong>forward 可以共享 request 里的数据，redirect 不能共享；</li><li><strong>效率：</strong>forward 比 redirect 效率高。</li></ul><h2 id="简述-tcp-和-udp的区别？"><a href="#简述-tcp-和-udp的区别？" class="headerlink" title="简述 tcp 和 udp的区别？"></a>简述 tcp 和 udp的区别？</h2><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。<br>tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。两者的区别如下：</p><ul><li><strong>tcp 面向连接</strong>，udp 面向<strong>非连接即发送数据前不需要建立链接</strong>；</li><li>tcp 提供<strong>可靠的服务</strong>（数据传输），udp 无法保证；</li><li><strong>tcp 面向字节流</strong>，udp 面向报文；</li><li>tcp 数据传输<strong>慢</strong>，udp 数据传输快；</li></ul><h2 id="tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="tcp 为什么要三次握手，两次不行吗？为什么？"></a>tcp 为什么要三次握手，两次不行吗？为什么？</h2><p>若采用两次握手，那么<strong>只要服务器发出确认数据包就会建立连接</strong>，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直等待客户端，这样服务器端就白白浪费了资源。<br>若采用三次握手，<strong>服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求</strong>，就不会浪费服务器的资源。</p><h2 id="tcp-粘包是怎么产生的？"><a href="#tcp-粘包是怎么产生的？" class="headerlink" title="tcp 粘包是怎么产生的？"></a>tcp 粘包是怎么产生的？</h2><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：<br><strong>发送端粘包：</strong>发送端需要<strong>等缓冲区满才发送出去</strong>，造成粘包；<br><strong>接收方粘包：</strong>接收方<strong>不及时接收缓冲区的包，造成多个包接收</strong>。</p><h2 id="OSI-的七层模型都有哪些？"><a href="#OSI-的七层模型都有哪些？" class="headerlink" title="OSI 的七层模型都有哪些？"></a>OSI 的七层模型都有哪些？</h2><p><strong>物理层：</strong>利用传输介质<em>为数据链路层提供物理连接，实现比特流的透明传输</em>。<br><strong>数据链路层：</strong>负责<em>建立和管理节点间的链路</em>。<br><strong>网络层：</strong>通过路由选择算法，<em>为报文或分组通过通信子网选择最适当的路径</em>。<br><strong>传输层：</strong>向用户<em>提供可靠的端到端的差错和流量控制</em>，保证报文的正确传输。<br><strong>会话层：</strong>向两个实体的表示层<em>提供建立和使用连接的方法</em>。<br><strong>表示层：</strong>处理<em>用户信息的表示问题</em>，如编码、数据格式转换和加密解密等。<br><strong>应用层：</strong>直接<em>向用户提供服务</em>，完成用户希望在网络上完成的各种工作。</p><h2 id="get-和-post-请求有哪些区别？"><a href="#get-和-post-请求有哪些区别？" class="headerlink" title="get 和 post 请求有哪些区别？"></a>get 和 post 请求有哪些区别？</h2><p><strong>get 请求会被浏览器主动缓存</strong>，而 post 不会。<br><strong>get 传递参数有大小限制</strong>，而 post 没有。<br><strong>post 参数传输更安全</strong>，get 的参数会明文限制在 url 上，post 不会。</p><h2 id="如何实现跨域？"><a href="#如何实现跨域？" class="headerlink" title="如何实现跨域？"></a>如何实现跨域？</h2><p><strong>原因：</strong>浏览器安全机制，请求访问的域名与ajax请求的域名不一致，导致无法返回结果。</p><p>实现跨域的方案：</p><ul><li><strong>使用 jsonp 跨域：</strong>只支持 GET 请求，不支持 POST</li><li><strong>服务器端运行跨域：</strong>设置 CORS 等于 *</li><li>CORS（跨域资源分享）<ul><li><strong>普通跨域请求：</strong>只需服务器端设置 Access-Control-Allow-Origin</li><li><strong>带 cookie 跨域请求：</strong>前后端都需要进行设置；</li></ul></li><li><strong>在单个接口使用注解：</strong> @CrossOrigin </li><li><strong>nginx 代理跨域：</strong>实质和 CORS 跨域原理一样，通过配置文件设置请求响应头 Access-Control-Allow-Origin 等字段</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue配置</span><br><span class="line">this.$http.jsonp(&#x27;http://www.domain2.com:8080/login&#x27;, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: &#x27;handleCallback&#x27;</span><br><span class="line">&#125;).then((res) =&gt; &#123;</span><br><span class="line">    console.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="JSONP-实现原理？"><a href="#JSONP-实现原理？" class="headerlink" title="JSONP 实现原理？"></a>JSONP 实现原理？</h2><p><strong>Jsonp：</strong>JSON with Padding，它是<strong>利用 script 标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行</strong>的。</p>]]></content>
    
    
    <summary type="html">网络相关</summary>
    
    
    
    <category term="Java" scheme="https://southernfish.github.io/categories/Java/"/>
    
    
    <category term="网络" scheme="https://southernfish.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程</title>
    <link href="https://southernfish.github.io/2025/06/19/java-oop/"/>
    <id>https://southernfish.github.io/2025/06/19/java-oop/</id>
    <published>2025-06-19T06:55:36.000Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于面向对象编程的问题</p><h2 id="Java-中面向对象编程的三大特性"><a href="#Java-中面向对象编程的三大特性" class="headerlink" title="Java 中面向对象编程的三大特性"></a>Java 中面向对象编程的三大特性</h2><p><strong>封装、继承、多态。</strong>分别实现了<strong>数据的隐藏与保护、代码的复用扩展以及行为的灵活适配</strong>。‌</p><p><strong>封装</strong>是对数据和行为进行集中管理的过程‌，其核心在于隐藏内部实现细节，仅通过接口与外界交互。主要作用包括：‌</p><ul><li><em>数据保护‌：</em>通过访问权限控制，如 private、protected 限制外部直接修改属性；‌‌‌‌‌</li><li><em>接口标准化‌：</em>提供统一的方法调用入口，如 getter、setter 控制属性访问；‌‌‌</li><li><em>模块化设计‌：</em>将同一类功能封装到同一对象中。</li></ul><p><strong>继承</strong>通过父子类关系实现代码复用和扩展‌，其特点包括：‌</p><ul><li><em>子类复用父类功能‌：</em>子类可直接使用父类的公共属性和方法；‌‌‌‌‌</li><li><em>层级扩展能力‌：</em>子类可新增特性或重写父类方法，如子类用 extends 继承父类并添加特有属性；‌‌‌</li><li><em>访问规则约束‌：</em>父类私有成员（private）不可被子类继承，保证封装性。‌‌‌</li></ul><p><strong>多态</strong>通过统一的接口实现不同类型的差异化行为‌，具体表现为：‌</p><ul><li><em>动态绑定‌：</em>父类引用指向子类对象；‌‌‌</li><li><em>方法重写与重载‌：</em>子类覆写父类方法（重写）或同一类中同名不同参方法（重载）；‌‌‌‌‌</li><li><em>灵活性增强‌：</em>同一方法在不同子类中表现不同。‌</li></ul><h2 id="什么是泛型？为什么要使用泛型？"><a href="#什么是泛型？为什么要使用泛型？" class="headerlink" title="什么是泛型？为什么要使用泛型？"></a>什么是泛型？为什么要使用泛型？</h2><p>泛型，即<strong>“参数化类型”</strong>。泛型的出现是为了<em>统一集合当中的数据类型</em>。可<em>在编译阶段约束操作的数据类型，并进行检查</em><br><strong>参数化类型：</strong>在方法定义时，<em>将方法签名中的形参数据类型设置为参数</em>（可称之为类型参数：尖括号 &lt;&gt; 中的泛型标识，用于指代任何数据类型），调用该方法时再从外部传入一个具体的数据类型和变量。<br><strong>泛型的本质：</strong><em>将类型参数化</em>。泛型使用过程中，数据类型被设置为一个参数，<strong>使用时从外部传入一个数据类型</strong>；而一旦传入了具体的数据类型后，<strong>传入变量（实参）的数据类型若不匹配，编译器就会直接报错</strong>。这种参数化类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p><strong>细节：</strong>不能写基本数据类型；指定泛型具体类型后，传递数据时可传该类型和其子类类型；若不写泛型，默认是Object<br><strong>泛型标识：</strong>是任意设置的，Java 常见泛型标识及其代表含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T ：代表一般的任何类。</span><br><span class="line">E ：代表 Element 元素的意思，或者 Exception 异常的意思。</span><br><span class="line">K ：代表 Key 的意思。</span><br><span class="line">V ：代表 Value 的意思，通常与 K 一起配合使用。</span><br><span class="line">S ：代表 Subtype 的意思。</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong>定义类、方法、接口的时候，若类型不确定，可定义泛型；<em>若类型不确定，但知道继承体系，可用泛型通配符 ？</em><br><strong>泛型不具备继承性，但是数据具备继承性</strong></p>]]></content>
    
    
    <summary type="html">面向对象编程</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="OOP" scheme="https://southernfish.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://southernfish.github.io/2025/06/19/java-design-patterns/"/>
    <id>https://southernfish.github.io/2025/06/19/java-design-patterns/</id>
    <published>2025-06-19T06:26:36.000Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些关于Java中设计模式相关问题</p><h2 id="熟悉的设计模式？"><a href="#熟悉的设计模式？" class="headerlink" title="熟悉的设计模式？"></a>熟悉的设计模式？</h2><ul><li><strong>单例模式：</strong>确保类仅有一个实例（如数据库连接池）‌‌。</li><li><strong>工厂模式（简单工厂、抽象工厂）：</strong>解耦代码。<ul><li>简单工厂<strong>将对象创建延迟到子类</strong>（如不同图形工厂生成不同形状）‌</li><li>抽象工厂<strong>创建相关对象族</strong>（如跨平台UI组件库）</li></ul></li><li><strong>观察者模式：</strong>定义了<strong>对象之间的一对多的依赖</strong>，当一个对象改变时，它的所有依赖者都会收到通知并自动更新。<ul><li>建立一个主题和多个观察者之间的<strong>订阅关系</strong>，实现状态变化的<strong>动态通知</strong>，如气象站通知多个显示设备</li></ul></li><li><strong>外观模式：</strong>提供一个<strong>统一的接口，用来访问子系统</strong>中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li><li><strong>模版方法模式：</strong>定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得<strong>子类可在不改变算法结构的情况下，重新定义算法的步骤</strong>。</li><li><strong>状态模式：</strong>允许<strong>对象在内部状态改变时改变它的行为</strong>，对象看起来好像修改了它的类。</li></ul><h2 id="简单工厂和抽象工厂有什么区别？"><a href="#简单工厂和抽象工厂有什么区别？" class="headerlink" title="简单工厂和抽象工厂有什么区别？"></a>简单工厂和抽象工厂有什么区别？</h2><p><strong>简单工厂：</strong>用来<strong>生产同一等级结构中的任意产品</strong>，对于增加新的产品，无能为力。<br><strong>工厂方法：</strong>用来<strong>生产同一等级结构中的固定产品</strong>，支持增加任意产品。<br><strong>抽象工厂：</strong>用来<strong>生产不同产品族的全部产品</strong>，对于增加新的产品，无能为力；<em>支持增加产品族</em>。</p><h2 id="设计模式遵循的原则？"><a href="#设计模式遵循的原则？" class="headerlink" title="设计模式遵循的原则？"></a>设计模式遵循的原则？</h2><ol><li><p><strong>开闭原则（Open Close Principle）</strong></p><p><em>对扩展开放，对修改关闭</em>。</p></li><li><p><strong>里氏代换原则（Liskov Substitution Principle）</strong></p><p>只有当衍生类可替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p></li><li><p><strong>依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个是开闭原则的基础，<em>对接口编程，依赖于抽象而不依赖于具体</em>。</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle）</strong></p><p>使用多个隔离的接口来降低耦合度。</p></li><li><p><strong>迪米特法则（最少知道原则）（Demeter Principle）</strong></p><p>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p><strong>合成复用原则（Composite Reuse Principle）</strong></p><p>原则是<em>尽量使用合成/聚合的方式，而不是使用继承</em>。</p><p><em>继承实际上破坏了类的封装性</em>，超类的方法可能会被子类修改。</p></li></ol>]]></content>
    
    
    <summary type="html">设计模式相关</summary>
    
    
    
    <category term="Java" scheme="https://southernfish.github.io/categories/Java/"/>
    
    
    <category term="设计模式" scheme="https://southernfish.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java Web</title>
    <link href="https://southernfish.github.io/2025/06/19/java-web/"/>
    <id>https://southernfish.github.io/2025/06/19/java-web/</id>
    <published>2025-06-19T05:15:36.000Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于Java Web的相关问题</p><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="JSP-和-servlet-有什么区别？"><a href="#JSP-和-servlet-有什么区别？" class="headerlink" title="JSP 和 servlet 有什么区别？"></a>JSP 和 servlet 有什么区别？</h2><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。</p><p><strong>JSP 侧重于视图，servlet 主要用于控制逻辑。</strong></p><h2 id="JSP-有哪些内置对象？作用分别是什么？"><a href="#JSP-有哪些内置对象？作用分别是什么？" class="headerlink" title="JSP 有哪些内置对象？作用分别是什么？"></a>JSP 有哪些内置对象？作用分别是什么？</h2><p>JSP 有 <strong>9</strong> 大内置对象：</p><ul><li><strong>request：</strong>封装客户端的请求，其中包含来自 get 或 post 请求的参数；</li><li><strong>response：</strong>封装服务器对客户端的响应；</li><li><strong>pageContext：</strong>通过该对象可以获取其他对象；</li><li><strong>session：</strong>封装用户会话的对象；</li><li><strong>application：</strong>封装服务器运行环境的对象；</li><li><strong>out：</strong>输出服务器响应的输出流对象；</li><li><strong>config：</strong>Web 应用的配置对象；</li><li><strong>page：</strong>JSP 页面本身（相当于 Java 程序中的 this）；</li><li><strong>exception：</strong>封装页面抛出异常的对象。</li></ul><h2 id="JSP-的-4-种作用域？"><a href="#JSP-的-4-种作用域？" class="headerlink" title="JSP 的 4 种作用域？"></a>JSP 的 4 种作用域？</h2><p><strong>page：</strong>与一个页面相关的对象和属性。<br><strong>request：</strong>与客户端发出的一个请求相关的对象和属性。<br>    一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。<br><strong>session：</strong>与某个用户与服务器建立的一次会话相关的对象和属性。<br>    跟某个用户相关的数据应放在用户自己的 session 中。<br><strong>application：</strong>与整个 Web 应用程序相关的对象和属性。<br>    实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</p><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><h2 id="session-和-cookie-有什么区别？"><a href="#session-和-cookie-有什么区别？" class="headerlink" title="session 和 cookie 有什么区别？"></a>session 和 cookie 有什么区别？</h2><p><strong>存储位置不同：</strong>session 存储在服务器端；cookie 存储在浏览器端。<br><strong>安全性不同：</strong>cookie 安全性一般，在浏览器存储，可被伪造和修改。<br><strong>容量和个数限制：</strong>cookie 有容量限制，每个站点下的 cookie 也有个数限制。<br><strong>存储的多样性：</strong>session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</p><h2 id="session-的工作原理？"><a href="#session-的工作原理？" class="headerlink" title="session 的工作原理？"></a>session 的工作原理？</h2><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p><h2 id="如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="如果客户端禁止 cookie 能实现 session 还能用吗？"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h2><p>可以用，session 只是依赖 cookie 存储 sessionid，若 cookie 被禁用了，可用 url 中添加 sessionid 的方式保证 session 能正常使用。</p><h2 id="Spring-mvc-和-struts-的区别是什么？"><a href="#Spring-mvc-和-struts-的区别是什么？" class="headerlink" title="Spring mvc 和 struts 的区别是什么？"></a>Spring mvc 和 struts 的区别是什么？</h2><p><strong>拦截级别：</strong>struts2 是类级别的拦截；spring mvc 是方法级别的拦截。<br><strong>数据独立性：</strong>spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。<br><strong>拦截机制：</strong>struts2 有自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。<br><strong>对 ajax 的支持：</strong>spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="如何避免-SQL-注入？"><a href="#如何避免-SQL-注入？" class="headerlink" title="如何避免 SQL 注入？"></a>如何避免 SQL 注入？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**防御手段如下：**</span><br><span class="line">验证请求来源地址；</span><br><span class="line">关键操作添加验证码；</span><br><span class="line">在请求地址添加 token 并验证。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<strong>预处理</strong> PreparedStatement。<br>使用<strong>正则表达式过滤</strong>掉字符中的特殊字符。</p><h2 id="什么是-XSS-攻击，如何避免？"><a href="#什么是-XSS-攻击，如何避免？" class="headerlink" title="什么是 XSS 攻击，如何避免？"></a>什么是 XSS 攻击，如何避免？</h2><p><strong>XSS 攻击：</strong>即<em>跨站脚本攻击</em>，它是 Web 程序中常见的漏洞。<br>原理是攻击者往 Web 页面里<strong>插入恶意的脚本代码（css 代码、Javascript 代码等）</strong>，当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的。<br><strong>比如：</strong>盗取用户 cookie、破坏页面结构、重定向到其他网站等。<br><strong>预防 XSS 的核心</strong>：必须对输入的数据做过滤处理。</p><h2 id="什么是-CSRF-攻击，如何避免？"><a href="#什么是-CSRF-攻击，如何避免？" class="headerlink" title="什么是 CSRF 攻击，如何避免？"></a>什么是 CSRF 攻击，如何避免？</h2><p><strong>CSRF：</strong>Cross-Site Request Forgery（<em>跨站请求伪造</em>），可理解为攻击者盗用你的身份发送恶意请求。<br><strong>比如：</strong>以你名义发送邮件、发消息、购买商品，虚拟货币转账等。<br><strong>防御手段如下：</strong></p><ul><li>验证请求来源地址；</li><li>关键操作添加验证码；</li><li>在请求地址添加 token 并验证。</li></ul>]]></content>
    
    
    <summary type="html">Java Web</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="web" scheme="https://southernfish.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>业务相关问题</title>
    <link href="https://southernfish.github.io/2025/06/19/java-business/"/>
    <id>https://southernfish.github.io/2025/06/19/java-business/</id>
    <published>2025-06-19T03:51:36.000Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<p>关于 java 中大批量数据处理的一些记录</p><h1 id="大批量数据导入"><a href="#大批量数据导入" class="headerlink" title="大批量数据导入"></a>大批量数据导入</h1><h2 id="前端大批量数据导入数据库"><a href="#前端大批量数据导入数据库" class="headerlink" title="前端大批量数据导入数据库"></a>前端大批量数据导入数据库</h2><p><strong>前端处理：</strong>用 element plus 的 el-upload 组件来完成文件上传的前端开发。<br><strong>后端处理：</strong>用 springboot 完成文件上传的后台处理逻辑（接收文件、读取文件、文件入库等），从这几个环节考虑提升入库效率，如多线程处理。<br>在 <code>application.properties</code> 中<strong>修改默认限制：</strong><code>spring.servlet.multipart.max-file-size</code> 设置单个文件上传的大小限制，<code>spring.servlet.multipart.max-request-size</code> 设置整个请求（包括所有文件和表单数据）的大小限制。<br><strong>方案</strong></p><ul><li>1、每读取一行数据就插入到数据库，每次都要和数据库通信，非常耗时</li><li>2、考虑批量插入来提高效率，使用 script 来实现数据的批量插入。</li><li>3、在 controller 中使用多线程来将数据批量插入数据库。</li></ul><p>首先要考虑锁和并发的问题。加锁会降低并发性，故<strong>使用生产者/消费者模式，读取文件作为生产，多线程进行消费</strong>。<br>两种技术选型，一个是并发队列 ConcurrentLinkedQueue，一个是 disruptor。这两种队列内部都是基于 CAS + voilatile 实现的。性能上 disruptor 略优于 ConcurrentLinkedQueue，但 disruptor 代码量多一些，以 ConcurrentLinkedQueue 为例。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentLinkedQueue String, queue = new concurrentLinkedQueue();</span><br><span class="line">boolean[] isComplete = &#123;true&#125;;</span><br><span class="line">int[] count = &#123;0&#125;;</span><br><span class="line">CountDownLatch countDownLatch = new CountDownLatch(6);</span><br><span class="line">AtomicInteger atomicSize = new AtomicInteger(0);</span><br><span class="line">while((line = br.readLine())!= null)&#123;</span><br><span class="line">  queue.add(line);</span><br><span class="line">  count[0]= ++count[0];</span><br><span class="line">  if(count[o]== 500)&#123;</span><br><span class="line">    for(int i=0;i&lt;6; i++)&#123;</span><br><span class="line">      new Thread(new Runnable()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run()&#123;</span><br><span class="line">          int num = 0;</span><br><span class="line">          List&lt;Test&gt; list = new ArrayList();</span><br><span class="line">          while(iscompletel0l== true &amp;&amp;count[0] &#123;</span><br><span class="line">            atomicSize.getString line = queue.poll();</span><br><span class="line">            if (line != null)&#123;</span><br><span class="line">              string[l lines = line.split(&quot;,&quot;);</span><br><span class="line">              Test test = new Test(lines[ol, lines[1l, lines[2], lines[3]);</span><br><span class="line">              atomicSize.incrementAndGet();</span><br><span class="line">              list.add(test);</span><br><span class="line">              numt+;</span><br><span class="line">            &#125;</span><br><span class="line">            if(num % 100 == 0)&#123;</span><br><span class="line">              fileUploadservice.insertBatch(list);</span><br><span class="line">              list.clear();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">isCompletelo]= true;</span><br><span class="line">countDownLatch.await();</span><br></pre></td></tr></table></figure><h2 id="前端大批量（百万级）数据导入数据库"><a href="#前端大批量（百万级）数据导入数据库" class="headerlink" title="前端大批量（百万级）数据导入数据库"></a>前端大批量（百万级）数据导入数据库</h2><p><strong>性能瓶颈分析：</strong>一般大数据量 excel 入库场景中，耗时大概在如下几点：<br><strong>耗时1：</strong>读取，字段数量，sheet 页个数，文件体积；选择分片读取及合适的集合存储<br><strong>耗时2：</strong>数据校验，逐行分字段校验；耗时会随字段个数逐渐增加<br><strong>耗时3：</strong>写入，如 Mybatis-plus 的分批插入，采用多线程处理等</p><h3 id="针对耗时1进行优化"><a href="#针对耗时1进行优化" class="headerlink" title="针对耗时1进行优化"></a>针对耗时1进行优化</h3><p>针对百万级数据的读取，要选择分片读取，分片处理，<br>实现 EasyExcel 的 ReadListener 页面读取监听器，<br>实现 invoke 方法，增加 BATCH_COUNT（单次读取条数）配置。单批次BATCH COUNT改为10万<br>读取完后，选择合适的集合容器（ ArrayList）存放临时数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@slf4j</span><br><span class="line">@service</span><br><span class="line">public class EasyExcelImportHandler implements ReadListener&lt;User&gt;&#123;</span><br><span class="line">  /*成功数据*/</span><br><span class="line">  // private final copyOnWriteArrayList&lt;User&gt;successList =new CopyOnWriteArrayList&lt;&gt;();private final List&lt;User&gt;successList= new Arraylist&lt;&gt;();</span><br><span class="line">  /*单次处理条数，有原来2万变为10万*/</span><br><span class="line">  private final static int BATCH COUNT= 100800;</span><br><span class="line"></span><br><span class="line">  @Resource</span><br><span class="line">  private ThreadPoolExecutor threadPoolExecutor；</span><br><span class="line">  @Resource</span><br><span class="line">  private UserMapper userMapper；</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void invoke(User user, AnalysisContext analysisContext)&#123;</span><br><span class="line">    if(stringutils.isNotBlank(user.getName()))&#123;</span><br><span class="line">      successList.add(user);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    //size是否为100000条:这里其实就是分批.当数据等于10w的时候执行一次插入</span><br><span class="line">    if(successList.size()&gt;= BATCH COUNT)&#123;</span><br><span class="line">      log.info(&quot;读取数据:&#123;&#125;&quot;，successList.size());</span><br><span class="line">      saveData();</span><br><span class="line">      //清理集合便于GC回收</span><br><span class="line">      successList.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="针对耗时3进行优化：JDBC分批插入-手动事务控制"><a href="#针对耗时3进行优化：JDBC分批插入-手动事务控制" class="headerlink" title="针对耗时3进行优化：JDBC分批插入+手动事务控制"></a>针对耗时3进行优化：JDBC分批插入+手动事务控制</h3><p>通过 PreparedStatement 的 addBatch() 和 executeBatch() 实现JDBC分批插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// jdbc+事务处理</span><br><span class="line">public void import4]dbc()&#123;</span><br><span class="line">  Connection conn = null; //分批读取+1DBC分批插入+手动事务控制</span><br><span class="line">  Preparedstatement ps = null; // JDBC存储过程</span><br><span class="line">  try &#123;</span><br><span class="line">    conn = JdbcconnectUtil.getconnect(); // 建立jdbc数据库连接</span><br><span class="line">    conn.setAutocommit(false): // 关闭事务默认提交</span><br><span class="line">    String sql =&quot;insert into user (id,name, phone_num, address)values&quot;;sq1 +=&quot;(?,?,?,?)&quot;;</span><br><span class="line">    ps = conn.preparestatement(sql);</span><br><span class="line">    for(int i=0;i&lt;successList.size(); i++)&#123;</span><br><span class="line">      User user = new User();</span><br><span class="line">      ps.setInt(1,successList.get(i).getId());</span><br><span class="line">      ps.setstring(2,successList.get(i).getName());</span><br><span class="line">      ps.setstring(3,successList.get(i).getPhoneNum());</span><br><span class="line">      ps.setstring(4,successlist.get(i).getAddress())</span><br><span class="line">      ps.addBatch(); // 将一组数据添加到此 Preparedstatement对象的批处理命令中。</span><br><span class="line">    &#125;</span><br><span class="line">    ps.executeBatch(); //执行批处理</span><br><span class="line">    conn.commit(); //手动提交争务 </span><br><span class="line">  &#125; catch(Exception e)&#123;</span><br><span class="line">    e.printstackTrace();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">  JdbcconnectUtil.close(conn,ps); // 记得关闭连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="针对耗时3进行优化：多线程-Mybatis-Plus批量插入"><a href="#针对耗时3进行优化：多线程-Mybatis-Plus批量插入" class="headerlink" title="针对耗时3进行优化：多线程+Mybatis-Plus批量插入"></a>针对耗时3进行优化：多线程+Mybatis-Plus批量插入</h3><p>Mybatis-Plus 的 IService 提供了 saveBatch 方法，但其仍是循环调用 INSERT INTO<br><strong>要实现真正批量插入：</strong>用 Mybatis-Plus 注入器增强批量插入、手写 xml 拼接 SQL。<br>建议用注入器（自定义 SQL 注入器实现 DefaultSqlInjector，添加 InsertBatchSomeColumn 方法批量插入。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 采用多线程读取数据</span><br><span class="line">private void saveData() &#123;</span><br><span class="line">  List&lt;List&lt;User&gt;&gt; lists = listUtil.split(successlist, 1000);</span><br><span class="line">  CountDownLatch countDownLatch = new CountDownLatch(lists.size());</span><br><span class="line">  for(list&lt;User&gt;list :lists)&#123;</span><br><span class="line">    threadPoolExecutor.execute(()-&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        userMapper.insertselective(list.stream().map(o-&gt;&#123;</span><br><span class="line">          User user = new User();</span><br><span class="line">          user.setName(o.getName());</span><br><span class="line">          user.setId(o.getId());</span><br><span class="line">          user.setPhoneNum(o.getPhoneNum());</span><br><span class="line">          user.setAddress(o.getAddress());</span><br><span class="line">          return user;</span><br><span class="line">        &#125;).collect(collectors.toList()));</span><br><span class="line">      &#125; catch(Exception e)&#123;</span><br><span class="line">        log.error(&quot;启动线程失败,e:&#123;&#125;&quot;，e.getMessage()，e);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        //执行完一个线程减1,直到执行完</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  //等待所有线程执行完</span><br><span class="line">  try &#123;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">  &#125; catch(Exception e)&#123;</span><br><span class="line">    1og.error(&quot;等待所有线程执行完异常,e:&#123;&#125;&quot;，e.getMessage()，e);</span><br><span class="line">  &#125;</span><br><span class="line">  // 提前将不再使用的集合清空，释放资源</span><br><span class="line">  successList.clear();</span><br><span class="line">  lists.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于 java 中大批量数据处理的一些记录</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="大批量数据处理" scheme="https://southernfish.github.io/tags/%E5%A4%A7%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="https://southernfish.github.io/2025/06/19/java-reflection/"/>
    <id>https://southernfish.github.io/2025/06/19/java-reflection/</id>
    <published>2025-06-19T03:14:36.000Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<p>简单整理了一些关于反射的相关问题。</p><h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><p>反射是在运行状态中，<em>对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性</em>；这种<strong>动态获取信息以及动态调用对象的方法</strong>的功能称为 Java 语言的反射机制。</p><h2 id="什么是-Java-序列化？什么情况下需要序列化？"><a href="#什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="什么是 Java 序列化？什么情况下需要序列化？"></a>什么是 Java 序列化？什么情况下需要序列化？</h2><p>Java 序列化是<strong>为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来</strong>。<br>以下情况需要使用 Java 序列化：</p><ul><li>想把内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>想用套接字在网络上传送对象的时候；</li><li>想通过RMI（远程方法调用）传输对象的时候。</li></ul><h2 id="动态代理是什么？有哪些应用？实现原理？"><a href="#动态代理是什么？有哪些应用？实现原理？" class="headerlink" title="动态代理是什么？有哪些应用？实现原理？"></a><strong>动态代理是什么？有哪些应用？实现原理？</strong></h2><p><strong>动态代理：</strong>运行时动态创建代理对象的技术，通过反射机制生成代理类，无需手动编写代理代码即可实现对目标对象的间接访问和控制。</p><p><strong>动态代理应用：</strong>实现<em>AOP、日志记录、权限校验、hibernate 数据查询、测试框架的后端 mock、rpc</em>等功能</p><p><strong>实现原理：</strong>包括<strong>JDK动态代理（基于接口）和CGLIB动态代理（基于类继承）</strong>。</p><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h2 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h2><p><strong>Remote Procedure Call：</strong>远程过程调用。像调用本地的函数一样去调远程函数，屏蔽远程调用的复杂性。<br><strong>完整的RPC框架：</strong>服务发现、负载、容错、网络传输、序列化等组件</p><h2 id="一个RPC的核心功能由哪5部分组成？"><a href="#一个RPC的核心功能由哪5部分组成？" class="headerlink" title="一个RPC的核心功能由哪5部分组成？"></a>一个RPC的核心功能由哪5部分组成？</h2><p>主要有 5 个部分组成，分别是：<em>客户端、客户端 Stub、网络传输模块、服务端 Stub、服务端</em>等。<br><strong>客户端(Client)：</strong>服务调用方。<br><strong>客户端存根(Client Stub)：</strong>存放服务端地址信息，将客户端请求参数数据信息打包成网络消息，通过网络传输发送给服务端。<br><strong>服务端存根(Server Stub)：</strong>接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。<br><strong>服务端(Server)：</strong>服务的真正提供者。<br><strong>Network Service：</strong>底层传输，可以是 TCP 或 HTTP。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250619112443294.png" alt="image-20250619112443294"></p><h2 id="为什么需要RPC？"><a href="#为什么需要RPC？" class="headerlink" title="为什么需要RPC？"></a>为什么需要RPC？</h2><p>微服务、分布式应用的开发越来越常见，RPC可以<strong>解决各个节点之间的服务调用以及通信问题</strong>。<br><strong>治理功能</strong>，比如连接管理、健康检测、负载均衡、优雅启停机、异常重试、业务分组以及熔断限流等等</p><h2 id="RPC-调用流程？"><a href="#RPC-调用流程？" class="headerlink" title="RPC 调用流程？"></a>RPC 调用流程？</h2><ol><li><strong>服务消费者(Client 客户端)<strong>通过本地调用的方式</strong>调用服务</strong>。</li><li>**客户端存根(Client Stub)<strong>接收到调用请求后负责将方法、入参等</strong>信息序列化(组装)**成能够进行网络传输的消息体。</li><li><strong>客户端存根(Client Stub)<strong>找到远程的服务地址，并且将消息通过网络</strong>发送给服务端</strong>。</li><li>**服务端存根(Server Stub)<strong>收到消息后进行</strong>解码(反序列化)**。</li><li>**服务端存根(Server Stub)**根据解码结果调用本地的服务进行相关处理</li><li><strong>服务端(Server)<strong>本地服务</strong>业务处理</strong>。并将处理结果返回给服务端存根(Server Stub)。</li><li>**服务端存根(Server Stub)**序列化结果。</li><li><strong>服务端存根(Server Stub)<strong>将结果通过网络</strong>发送至消费方</strong>。</li><li>**客户端存根(Client Stub)<strong>接收到消息，并进行</strong>解码(反序列化)**。</li><li><strong>服务消费者(Client 客户端)<strong>服务消费方得到</strong>最终结果</strong>。</li></ol><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250619112546216.png" alt="image-20250619112546216"></p>]]></content>
    
    
    <summary type="html">简单整理了一些关于反射的相关问题。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="反射" scheme="https://southernfish.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="https://southernfish.github.io/2025/06/18/java-thread/"/>
    <id>https://southernfish.github.io/2025/06/18/java-thread/</id>
    <published>2025-06-18T13:19:36.000Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于线程、多线程的问题</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h2><p>并行：多个处理器或多核处理器同时处理多个任务。<br>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</p><h2 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h2><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><h2 id="守护线程是什么？"><a href="#守护线程是什么？" class="headerlink" title="守护线程是什么？"></a>守护线程是什么？</h2><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><h2 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h2><p>创建线程列举了<strong>四种方式</strong>：</p><ul><li><strong>继承 Thread 重写 run 方法：</strong>代码简单，但该类无法集成别的类</li><li><strong>实现 Runnable 接口：</strong>继承其他类；同一实现该接口的实例可以共享资源。但代码复杂。</li><li><strong>实现 Callable 接口：</strong>可以获得异步任务的返回值</li><li><strong>线程池方式：</strong>实现自动化装配，易于管理，循环利用资源。</li></ul><h2 id="runnable-和-callable-有什么区别？"><a href="#runnable-和-callable-有什么区别？" class="headerlink" title="runnable 和 callable 有什么区别？"></a>runnable 和 callable 有什么区别？</h2><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p><h2 id="线程有哪些状态？"><a href="#线程有哪些状态？" class="headerlink" title="线程有哪些状态？"></a>线程有哪些状态？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEW 尚未启动</span><br><span class="line">RUNNABLE 正在执行中</span><br><span class="line">BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</span><br><span class="line">WAITING 永久等待状态</span><br><span class="line">TIMED_WAITING 等待指定的时间重新被唤醒的状态</span><br><span class="line">TERMINATED 执行完成</span><br></pre></td></tr></table></figure><h2 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h2><ul><li><strong>类的不同：</strong>sleep() 来自 Thread，wait() 来自 Object。</li><li><strong>释放锁：</strong>sleep() 不释放锁；wait() 释放锁。</li><li><strong>用法不同：</strong>sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll() 直接唤醒。</li></ul><h2 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify()和 notifyAll()有什么区别？"></a>notify()和 notifyAll()有什么区别？</h2><p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。<br>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。<br>而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><h2 id="线程的-run-和-start-有什么区别？"><a href="#线程的-run-和-start-有什么区别？" class="headerlink" title="线程的 run() 和 start() 有什么区别？"></a>线程的 run() 和 start() 有什么区别？</h2><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="创建线程池有哪几种方式？"><a href="#创建线程池有哪几种方式？" class="headerlink" title="创建线程池有哪几种方式？"></a>创建线程池有哪几种方式？</h2><ul><li><strong>newSingleThreadExecutor()：</strong>它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可避免其改变线程数目；</li><li><strong>newCachedThreadPool()：</strong>它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：<ul><li>它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；</li><li>如果线程闲置的时间超过 60 秒，则被终止并移出缓存；</li><li>长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li></ul></li><li><strong>newFixedThreadPool(int nThreads)：</strong>重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。<em>这意味着：</em><ul><li>如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；</li><li>如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li></ul></li><li><strong>newSingleThreadScheduledExecutor()：</strong>创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li><li><strong>newScheduledThreadPool(int corePoolSize)：</strong>和 newSingleThreadScheduledExecutor() 类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li><li><strong>newWorkStealingPool(int parallelism)：</strong>这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li><li><strong>ThreadPoolExecutor()：</strong>是最原始的线程池创建，上面的创建方式几乎都是对 ThreadPoolExecutor 的封装。（最核心）</li></ul><h2 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</span><br><span class="line">SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</span><br><span class="line">STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</span><br><span class="line">TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</span><br><span class="line">TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</span><br></pre></td></tr></table></figure><h2 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h2><p><strong>execute()：</strong>只能执行 Runnable 类型的任务。<br><strong>submit()：</strong>可以执行 Runnable 和 Callable 类型的任务。<br>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p><h2 id="在-Java-程序中怎么保证多线程的运行安全？"><a href="#在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全？"></a>在 Java 程序中怎么保证多线程的运行安全？</h2><p>方法一：使用安全类，比如 Java. util. concurrent 下的类。<br>方法二：使用自动锁 synchronized。<br>方法三：使用手动锁 Lock。（如下代码所示）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock =new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;获得锁&quot;);</span><br><span class="line">&#125; catch(Exception e)&#123;</span><br><span class="line">    // ToDo: handle exception</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    System. out.println(“释放锁&quot;);</span><br><span class="line">    lock. unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程中-synchronized-锁升级的原理是什么？"><a href="#多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么？"></a>多线程中 synchronized 锁升级的原理是什么？</h2><p><strong>synchronized 锁升级原理：</strong>在锁对象的对象头里面有一个 <strong>threadid</strong> 字段，在第一次访问的时候 <strong>threadid 为空，jvm 让其持有偏向锁</strong>，并将 threadid 设置为其线程 id，再次进入的时候会先<strong>判断 threadid 是否与其线程 id 一致</strong>，如果一致则可以直接使用此对象，如果<strong>不一致，则升级偏向锁为轻量级锁</strong>，通过<strong>自旋循环</strong>一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁<strong>从轻量级升级为重量级锁</strong>，此过程就构成了 synchronized 锁的升级。<br><strong>锁的升级的目的：</strong>锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h2 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h2><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><h2 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a>怎么防止死锁？</h2><ul><li>尽量使用 tryLock(long timeout, TimeUnit unit) 的方法 (ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li><li>尽量<strong>使用 Java. util. concurrent 并发类</strong>代替自己手写锁。</li><li>尽量<strong>降低锁的使用粒度</strong>，尽量不要几个功能用同一把锁。</li><li>尽量<strong>减少同步的代码块</strong>。</li></ul><h2 id="ThreadLocal-是什么？有哪些使用场景？"><a href="#ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="ThreadLocal 是什么？有哪些使用场景？"></a>ThreadLocal 是什么？有哪些使用场景？</h2><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><h2 id="synchronized-底层实现原理？"><a href="#synchronized-底层实现原理？" class="headerlink" title="synchronized 底层实现原理？"></a>synchronized 底层实现原理？</h2><p>synchronized 由<strong>一对 monitorenter/monitorexit 指令实现，monitor 对象是同步的基本实现单元</strong>。<br>在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的<strong>互斥锁</strong>，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。<br>在 Java 6 的时候，Java 虚拟机提供了三种 monitor 实现：<strong>偏向锁（Biased Locking）、轻量级锁和重量级锁</strong>，改进了性能。</p><h2 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h2><p>volatile 是<strong>变量修饰符</strong>；synchronized 是<strong>修饰类、方法、代码段</strong>。<br>volatile 仅能实现<strong>变量的修改可见性但不能保证原子性</strong>；而 synchronized 则可以<strong>保证变量的修改可见性和原子性</strong>。<br>volatile 不会造成线程的阻塞；synchronized 可能<strong>会造成线程的阻塞</strong>。</p><h2 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h2><p>synchronized 可以给类、方法、代码块加锁；而 <strong>lock 只能给代码块加锁</strong>。<br>synchronized 不需要手动获取锁和释放锁，发生异常会<strong>自动释放锁</strong>，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。<br>通过 <strong>Lock 可以知道有没有成功获取锁</strong>，而 synchronized 却无法办到。</p><h2 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h2><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但在 Java 6 中对 synchronized 进行了非常多的改进。主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰类、方法、代码块等。</li></ul><h2 id="atomic-的原理？"><a href="#atomic-的原理？" class="headerlink" title="atomic 的原理？"></a>atomic 的原理？</h2><p>atomic 主要利用 CAS (Compare And Wap) 、 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>]]></content>
    
    
    <summary type="html">简单记录一些关于线程、多线程的问题。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="多线程" scheme="https://southernfish.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 基础</title>
    <link href="https://southernfish.github.io/2025/06/18/java-base/"/>
    <id>https://southernfish.github.io/2025/06/18/java-base/</id>
    <published>2025-06-18T10:28:36.000Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<p>关于 java 的一些简单问题</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="JVM-、JDK-和-JRE-有什么区别"><a href="#JVM-、JDK-和-JRE-有什么区别" class="headerlink" title="JVM 、JDK 和 JRE 有什么区别"></a>JVM 、JDK 和 JRE 有什么区别</h2><ul><li><strong>JVM ：</strong><code>(Java Virtual Machine)，Java虚拟机</code>。只认<code>xxx.class</code>文件，能识别<code>class</code> 文件中的字节码指令并调用操作系统向上的 API 完成动作。<code>jvm</code> 是 <code>Java</code> 能够跨平台的核心。</li><li><strong>JRE：</strong><code>(Java Runtime Environment)，Java 运行环境</code>。为 Java 的运行提供了所需环境。主要包含 jvm 的标准实现和 Java 的一些基本类库，相对于 jvm 来说，多出来的是一部分的 Java 类库。</li><li><strong>JDK：</strong><code>(Java Development Kit)，Java 开发工具包</code>。提供了 Java 的开发环境和运行环境。jdk 是整个 Java 开发的核心，集成了 jre 和一些好用 Java 程序调试和分析的小工具。如：<code>javac.exe</code>，<code>java.exe</code>，<code>jar.exe</code> 等</li></ul><h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals 的区别"></a>== 和 equals 的区别</h2><ul><li><p><strong>== 解读</strong>：</p><p><em>基本类型：</em>比较的是值是否相同；                          <em>引用类型：</em>比较的是引用是否相同； </p><p>若指向同一个引用，== 为 true，而 new String() 方法重新开辟了内存空间， == 结果为 false，而 equals 比较的是值，结果为 true</p></li><li><p><strong>equals 解读</strong>：equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较</p></li><li><p><strong>总结</strong>： == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，String、Integer 等类重写了equals，把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p></li></ul><h2 id="两个对象的-hashCode-相同，则-equals-也一定为-true，对吗"><a href="#两个对象的-hashCode-相同，则-equals-也一定为-true，对吗" class="headerlink" title="两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗"></a>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗</h2><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。代码解读：显然“通话”和“重地”的 hashCode() 相同，然而 equals()为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = “通话”;</span><br><span class="line">String str2 = &quot;重地”;</span><br><span class="line">System. out.printIn(string. format(&quot;str1:%d|str2:%d&quot;, str1. hashcode(),str2. hashcode()));</span><br><span class="line">System. out.println(str1. equals(str2));</span><br><span class="line"></span><br><span class="line"># 打印结果</span><br><span class="line">str1:1179395 | str2:1179395</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h2 id="Java-中的-Math-round-1-5-等于多少"><a href="#Java-中的-Math-round-1-5-等于多少" class="headerlink" title="Java 中的 Math. round(-1. 5) 等于多少"></a>Java 中的 Math. round(-1. 5) 等于多少</h2><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p><h2 id="final-在-Java-中有什么作用"><a href="#final-在-Java-中有什么作用" class="headerlink" title="final 在 Java 中有什么作用"></a>final 在 Java 中有什么作用</h2><ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><h2 id="基础的数据类型"><a href="#基础的数据类型" class="headerlink" title="基础的数据类型"></a>基础的数据类型</h2><p>基础类型有 8 种：<code>byte</code>、<code>boolean</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code></p><p> <code>String</code> 不属于基础类型， <code>String</code> 属于对象</p><h2 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Files. exists()：检测文件路径是否存在。</span><br><span class="line">Files. createFile()：创建文件。</span><br><span class="line">Files. createDirectory()：创建文件夹。</span><br><span class="line">Files. delete()：删除一个文件或目录。</span><br><span class="line">Files. copy()：复制文件。</span><br><span class="line">Files. move()：移动文件。</span><br><span class="line">Files. size()：查看文件个数。</span><br><span class="line">Files. read()：读取文件。</span><br><span class="line">Files. write()：写入文件。</span><br></pre></td></tr></table></figure><h1 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h1><h2 id="Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>Java 中操作字符串都有哪些类？它们之间有什么区别？</h2><p>操作字符串的类有：<code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code>。</p><p><code>String</code> 和 <code>StringBuffer</code>、<code>StringBuilder</code> 的区别在于 <strong><code>String</code> 声明的是不可变的对象，每次操作都会生成新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象</strong>，而 <code>StringBuffer</code>、<code>StringBuilder</code> 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 <code>String</code>。</p><p><code>StringBuffer</code> 和 <code>StringBuilder</code> 最大的区别在于，**<code>StringBuffer</code> 线程安全，而 <code>StringBuilder</code> 非线程安全**，但 <code>StringBuilder</code> 性能高于 <code>StringBuffer</code>，所以在单线程环境下推荐使用 <code>StringBuilder</code>，多线程环境下推荐使用 <code>StringBuffer</code>。</p><h2 id="String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="String str=”i”与 String str=new String(“i”)一样吗？"></a>String str=”i”与 String str=new String(“i”)一样吗？</h2><p>不一样，因为内存的分配方式不一样。</p><p>String str = ”i” 的方式，Java 虚拟机会将其分配到常量池中；</p><p>String str = new String(“i”) 则会被分到堆内存中。</p><h2 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="如何将字符串反转？"></a>如何将字符串反转？</h2><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// stringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer = new stringBuffer();</span><br><span class="line">stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuffer. reverse()); // gfedcba</span><br><span class="line">// stringBuilder reverse</span><br><span class="line">stringBuilder stringBuilder =new stringBuilder();</span><br><span class="line">stringBuilder. append(&quot;abcdefg&quot;);System. out. println(stringBuilder. reverse()); // gfedcba</span><br></pre></td></tr></table></figure><h2 id="String-类的常用方法"><a href="#String-类的常用方法" class="headerlink" title="String 类的常用方法"></a>String 类的常用方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">indexOf()：返回指定字符的索引。</span><br><span class="line">charAt()：返回指定索引处的字符。</span><br><span class="line">replace()：字符串替换。</span><br><span class="line">trim()：去除字符串两端空白。</span><br><span class="line">split()：分割字符串，返回一个分割后的字符串数组。</span><br><span class="line">getBytes()：返回字符串的 byte 类型数组。</span><br><span class="line">length()：返回字符串长度。</span><br><span class="line">toLowerCase()：将字符串转成小写字母。</span><br><span class="line">toUpperCase()：将字符串转成大写字符。</span><br><span class="line">substring()：截取字符串。</span><br><span class="line">equals()：字符串比较。</span><br></pre></td></tr></table></figure><h1 id="抽象类问题"><a href="#抽象类问题" class="headerlink" title="抽象类问题"></a>抽象类问题</h1><h2 id="抽象类必须要有抽象方法吗"><a href="#抽象类必须要有抽象方法吗" class="headerlink" title="抽象类必须要有抽象方法吗?"></a>抽象类必须要有抽象方法吗?</h2><p>不需要，抽象类不一定非要有抽象方法。</p><h2 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h2><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。抽象类不能直接实例化，普通类可以直接实例化。</p><h2 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h2><p>不能，定义抽象类就是让其他类继承的，定义为 final的类不能被继承，所以 final 不能修饰抽象类，编辑器也会提示错误信息：illegal combination of modifiers: ‘abstract’ and ‘final</p><h2 id="接口和抽象类有什么区别？"><a href="#接口和抽象类有什么区别？" class="headerlink" title="接口和抽象类有什么区别？"></a>接口和抽象类有什么区别？</h2><ul><li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li></ul><h1 id="Java中的IO"><a href="#Java中的IO" class="headerlink" title="Java中的IO"></a>Java中的IO</h1><h2 id="Java-中-IO-流分为几种？"><a href="#Java-中-IO-流分为几种？" class="headerlink" title="Java 中 IO 流分为几种？"></a>Java 中 IO 流分为几种？</h2><ul><li><strong>按功能来分：</strong>输入流（input）、输出流（output）。</li><li><strong>按类型来分：</strong>字节流和字符流。字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</li></ul><h2 id="BIO、NIO、AIO-有什么区别？"><a href="#BIO、NIO、AIO-有什么区别？" class="headerlink" title="BIO、NIO、AIO 有什么区别？"></a>BIO、NIO、AIO 有什么区别？</h2><ul><li>BIO：Block IO，同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：Non IO，同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO，是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="Lambda表达式的语法"><a href="#Lambda表达式的语法" class="headerlink" title="Lambda表达式的语法"></a>Lambda表达式的语法</h2><p><strong>基本语法：</strong> (parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }</p><p><strong>Lambda表达式由三部分组成：</strong></p><ul><li><strong>paramaters：</strong>类似方法中的形参列表，这里的参数是函数式接口里的参数。这里的参数类型可以明确的声明也可不声明而由JVM隐含的推断。另外当只有一个推断类型时可以省略掉圆括号。</li><li><strong>-&gt;：</strong>可理解为“被用于”的意思</li><li><strong>方法体：</strong>可以是表达式也可以代码块，是函数式接口里方法的实现。代码块可返回一个值或者什么都不反回，这里的代码块块等同于方法的方法体。如果是表达式，也可以返回一个值或者什么都不反回。</li></ul><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong>代码简洁，开发迅速、方便函数式编程、容易进行并行计算、Java 引入 Lambda，改善了集合操作</li><li><strong>缺点：</strong>代码可读性变差、在非并行计算中，很多计算未必有传统的 for 性能要高、不易调试</li></ul><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(s -&gt; s.length() &gt; 3).forEach(System.out::println);</span><br><span class="line">list.stream().map(StuffEntity::getCode).collect(Collectors.toList());</span><br><span class="line">list.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(</span><br><span class="line">                () -&gt; new TreeSet&lt;&gt;(Comparator.comparing(obj -&gt; obj.getDealerPlan() ))), ArrayList::new));</span><br><span class="line">Map&lt;String, List&lt;VpEntity&gt;&gt; map = stuffVp.stream().collect(Collectors.groupingBy(obj -&gt; obj.getDealerPlan() ));</span><br></pre></td></tr></table></figure><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="Java-容器都有哪些？"><a href="#Java-容器都有哪些？" class="headerlink" title="Java 容器都有哪些？"></a>Java 容器都有哪些？</h2><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collection</span><br><span class="line">    List</span><br><span class="line">        ArrayList</span><br><span class="line">        LinkedList</span><br><span class="line">        Vector</span><br><span class="line">        Stack</span><br><span class="line">    Set</span><br><span class="line">        HashSet</span><br><span class="line">        LinkedHashSet</span><br><span class="line">        TreeSet</span><br><span class="line">Map</span><br><span class="line">    HashMap </span><br><span class="line">        LinkedHashMap</span><br><span class="line">    TreeMap</span><br><span class="line">    ConcurrentHashMap</span><br><span class="line">    Hashtable</span><br></pre></td></tr></table></figure><h2 id="Collection-和-Collections-有什么区别"><a href="#Collection-和-Collections-有什么区别" class="headerlink" title="Collection 和 Collections 有什么区别"></a>Collection 和 Collections 有什么区别</h2><p>Collection 是一个<strong>集合接口，它提供了对集合对象进行基本操作的通用接口方法</strong>，所有集合都是它的子类，比如 List、Set 等。Collections 是一个<strong>包装类，包含了很多静态方法，不能被实例化，就像一个工具类</strong>，比如提供的排序方法：Collections. sort(list)。</p><h2 id="List、Set、Map-之间的区别是什么？"><a href="#List、Set、Map-之间的区别是什么？" class="headerlink" title="List、Set、Map 之间的区别是什么？"></a>List、Set、Map 之间的区别是什么？</h2><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。三者之间的区别，如下表：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/20250618204117.png"></p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="HashMap-和-Hashtable-有什么区别？"><a href="#HashMap-和-Hashtable-有什么区别？" class="headerlink" title="HashMap 和 Hashtable 有什么区别？"></a>HashMap 和 Hashtable 有什么区别？</h2><ul><li>存储：HashMap 允许 key 和 value 为 null，而 Hashtable 不允许。</li><li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，    如果需要多线程使用则用 ConcurrentHashMap 替代。</li></ul><h2 id="HashMap-的实现原理？"><a href="#HashMap-的实现原理？" class="headerlink" title="HashMap 的实现原理？"></a>HashMap 的实现原理？</h2><p>HashMap 基于 <strong>Hash 算法</strong>实现的，我们通过 <strong>put(key,value)存储，get(key)来获取</strong>。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当<strong>计算出的 hash 值相同时，我们称为 hash 冲突</strong>，HashMap 的做法是<strong>用链表和红黑树存储相同 hash 值的 value</strong>。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p><h2 id="HashMap为什么线程不安全？"><a href="#HashMap为什么线程不安全？" class="headerlink" title="HashMap为什么线程不安全？"></a>HashMap为什么线程不安全？</h2><p>主要原因在于其<strong>内部结构的非原子性操作和缺乏同步机制</strong>，导致<strong>多线程并发操作时可能引发数据不一致、死循环、数据覆盖</strong>等问题‌。</p><h2 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h2><p>对于在 Map 中<strong>插入、删除、定位</strong>一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但是如果你要对一个 key 集合进行<strong>有序的遍历</strong>，那 TreeMap 是更好的选择。</p><h2 id="HashSet-的实现原理？"><a href="#HashSet-的实现原理？" class="headerlink" title="HashSet 的实现原理？"></a>HashSet 的实现原理？</h2><p>HashSet 是基于 HashMap 实现的，HashSet 不允许重复的值。<br>HashSet 保证元素不重复是利用 HashMap 的 put 方法实现的，在<strong>存储之前先根据 key 的 hashCode 和 equals 判断是否已存在，如果存在就不在重复插入了</strong>，这样就保证了元素的不重复。</p><h2 id="HashMap-和-ConcurrentHashMap-有什么区别？"><a href="#HashMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 有什么区别？"></a>HashMap 和 ConcurrentHashMap 有什么区别？</h2><p>ConcurrentHashMap的线程安全实现</p><ul><li>Java7：分段锁(Segment)。将数据分成多个段，每段独立加锁，不同段的操作可并发。</li><li>Java 8+：CAS(无锁算法)+ synchronized(锁单个桶的头节点)。锁粒度更细，并发度更高。插入时，如果桶为空，用 CAS 添加;否则锁住头节点再操作。CAS（Compare And Swap(比较与交换)）。读操作通常无锁(依赖 volatile 保证可见性)。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/20250618205242.png"></p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h2><ul><li><strong>数据结构实现：</strong>ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li><strong>随机访问效率：</strong>ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li><strong>增加和删除效率：</strong>在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li></ul><h2 id="如何实现数组和-List-之间的转换？"><a href="#如何实现数组和-List-之间的转换？" class="headerlink" title="如何实现数组和 List 之间的转换？"></a>如何实现数组和 List 之间的转换？</h2><ul><li>数组转 List：使用 Arrays. asList(array) 进行转换。</li><li>List 转数组：使用 List 自带的 toArray() 方法。</li></ul><h2 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h2><ul><li><strong>线程安全：</strong>Vector 使用了 <code>Synchronized</code> 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li><strong>性能：</strong>ArrayList 在性能方面要优于 Vector。</li><li><strong>扩容：</strong>ArrayList 和 Vector 都会根据实际需要动态调整容量，不过 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul><h2 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h2><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 <code>addAll、removeAll、iteration</code> 等方法只有 ArrayList 有。</p><h1 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h1><h2 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h2><p><strong>Iterator 接口提供遍历任何 Collection 的接口</strong>。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，<strong>迭代器允许调用者在迭代过程中移除元素</strong>。</p><h2 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h2><p>Iterator 使用代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;string&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;string&gt;it = list.iterator();</span><br><span class="line">while(it.hasNext()*)&#123;</span><br><span class="line">    String obj = it.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改时，就会抛出 ConcurrentModificationException 异常。</p><h2 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h2><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。<br>ListIterator 从 Iterator 接口继承，添加了一些额外功能，如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p><h1 id="其他相关问题"><a href="#其他相关问题" class="headerlink" title="其他相关问题"></a>其他相关问题</h1><h2 id="在-Queue-中-poll-和-remove-有什么区别？"><a href="#在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="在 Queue 中 poll()和 remove()有什么区别？"></a>在 Queue 中 poll()和 remove()有什么区别？</h2><p><strong>相同点：</strong>都是返回第一个元素，并在队列中删除返回的对象。<br><strong>不同点：</strong>如果没有元素 poll() 会返回 null，而 remove()会直接抛出 <code>NoSuchElementException</code> 异常。</p><h2 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h2><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p><h2 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h2><p>使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。<br>示例代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;string&gt; list = new ArrayList&lt;&gt;();list. add(&quot;x”);</span><br><span class="line">Collection&lt;string&gt;clist = collections.unmodifiablecollection(list),clist. add(&quot;y”);// 运行时此行报错</span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于 java 的一些简单问题</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://southernfish.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个人博客搭建</title>
    <link href="https://southernfish.github.io/2025/06/18/hexo-blog-build/"/>
    <id>https://southernfish.github.io/2025/06/18/hexo-blog-build/</id>
    <published>2025-06-18T06:47:36.000Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 是一个简单、轻量、基于Node的静态博客<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020">框架</a>，可以方便的生成静态网页托管于GitHub和Heroku。本文以 Hexo + GitHub Pages + Typora + PicGo 为例。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p><strong>1、<a href="https://nodejs.org/en/download/">下载node</a>并安装。</strong>安装好node，会默认一起安装好 npm 包管理器，可通过（Ctrl+R）打开 cmd 终端，使用以下命令查看安装版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v </span><br><span class="line">npm -version</span><br></pre></td></tr></table></figure><p><strong>2、安装 git，配置个人信息。</strong>官网下载，选择自己操作系统的版本，根据提示一直 next 就装好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;xxxxxx@qq.com&quot;</span><br></pre></td></tr></table></figure><p><strong>生成密钥。</strong>一般是在 <strong>~/.ssh</strong> 路径下，其中 id_rsa 存储私钥（<strong>不要共享私钥</strong>），id_rsa.pub 存储公钥。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxxxxx@qq.com&quot;</span><br></pre></td></tr></table></figure><p>GitHub公钥配置步骤：登录 GitHub → Settings → SSH and GPG keys → New SSH key → 填写相关信息(如下) →  Add SSH key<br>填写信息如下：</p><p><strong>Title：</strong>标识密钥用途Key；</p><p><strong>type：</strong>保持默认 Authentication Key；</p><p><strong>Key：</strong>公钥内容</p><p><strong>3、测试 SSH 连接，</strong>出现如下则配置成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">Hi username! You&#x27;ve successfully authenticated...</span><br></pre></td></tr></table></figure><p>配置完 SSH 后，之后使用远程仓库的方式更新为 SSH 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:username/repo.git</span><br><span class="line">git remote -v</span><br><span class="line"># 显示 ssh 地址（git@github.com:...）则生效</span><br></pre></td></tr></table></figure><p>克隆新仓库地址也使用 SSH。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 克隆新仓库</span><br><span class="line">git clone git@github.com:username/repo.git</span><br></pre></td></tr></table></figure><p><strong>4、安装 hexo 及相关依赖 。</strong>在 git 终端执行安装 hexo 相关命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo --save</span><br><span class="line">npm install hexo-deployer-git --save # 用于部署发布</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h1 id="Hexo项目构建"><a href="#Hexo项目构建" class="headerlink" title="Hexo项目构建"></a>Hexo项目构建</h1><p><strong>1、开始搭建Hexo项目。</strong>自定义一个文件夹（我的路径是：<code>E://WorkSpace/fishblog</code>），在命令行窗口进入目录，或直接从本机进入文件夹，右键打开 Git Bash Here，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">hexo g </span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><code>hexo g </code>是 <code>hexo generate</code> 的简便写法；<code>hexo s</code> 是 <code>hexo server</code> 的简便写法。<code>hexo s</code>启动本地服务器，在浏览器打开localhost:4000即可看到效果。关闭本地服务：Ctrl + C 。部署的命令也可以并列的写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s -- 本地</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d -- 远程部署（发布到github）</span><br></pre></td></tr></table></figure><p><strong>2、新建博客文件。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;article title&quot;</span><br></pre></td></tr></table></figure><p>项目中 <code>/source/_posts </code>将会看到<code> article title.md</code> 文件。编辑之后运行生成、部署命令便可发布。我使用 Typora 编辑，后续会讲到 Typora 相关配置。之后也可以直接在该路径下新建md文件，上传到 GitHub，后续会讲到如何自动化部署发布。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g   # 生成</span><br><span class="line">hexo d   # 部署</span><br><span class="line">hexo d -g # 在部署前先生成</span><br></pre></td></tr></table></figure><p><strong>3、个性化设置。</strong>主题替换、卡通人物、数字统计等。渲染md文件还需执行如下命令安装依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-renderer-markdown-it --save # 需要安装这个渲染插件</span><br></pre></td></tr></table></figure><p>卡通人物。选自己喜欢的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line">npm install live2d-widget-model-haruto</span><br></pre></td></tr></table></figure><p>主题替换。挑一个喜欢 blog theme，此处以 <code>butterfly</code> 为例，点进去（多数是贡献者的博客网站）找到当前主题的 GitHub 仓库入口（通常情况在博客的正下方），进入 GitHub 克隆当前仓库，放在 Hexo 所在目录的 themes 文件夹下（原目录下有一个默认的 landscape 主题，新主题目录和它同级）。修改 Hexo 根目录下的 <code>_config.yml</code> 文件，找到 theme 配置项，修改为克隆的主题名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/jerryc127/hexo-theme-butterfly.git</span><br></pre></td></tr></table></figure><p>统计数字、数学公式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save # 统计数字</span><br><span class="line">npm install @neilsustc/markdown-it-katex --save # 渲染数学公式</span><br></pre></td></tr></table></figure><p><strong>4、新建分类、目录、标签 。</strong>修改对应的 md 文件便可自定义属于自己的分类、标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about      # 根目录/source/about/index.md</span><br><span class="line">hexo new page categories # 根目录/source/categories/index.md</span><br><span class="line">hexo new page tags       # 根目录/source/tags/index.md</span><br></pre></td></tr></table></figure><p>编辑md文件时，注意多个分类写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分级c2是c1的子类</span><br><span class="line">categories:</span><br><span class="line">- c1</span><br><span class="line">- c2</span><br><span class="line">同级多类</span><br><span class="line">categories:</span><br><span class="line">- [c1]</span><br><span class="line">- [c2]</span><br></pre></td></tr></table></figure><p>相应的配置 <code>_config.yml</code> 文件设置。其他更多配置可参考<a href="https://segmentfault.com/a/1190000042212798?utm_source=sf-similar-article">文章</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 右下角的卡通人物</span><br><span class="line">## https://github.com/xiazeyu/live2d-widget-models/tree/master/packages</span><br><span class="line">lived2:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptForm: local</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-haruto # model name select</span><br><span class="line">  display: # model position size</span><br><span class="line">    position: left</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br><span class="line"></span><br><span class="line"># 主题配置，更换主题需要将主题放在landscape同级文件夹下，名字就是文件夹名   </span><br><span class="line">theme: butterfly </span><br><span class="line"></span><br><span class="line"># 数学 katex</span><br><span class="line">markdown:</span><br><span class="line">  plugins:</span><br><span class="line">    - plugin:</span><br><span class="line">      name: &#x27;@neilsustc/markdown-it-katex&#x27;</span><br><span class="line">      options:</span><br><span class="line">        strict: false</span><br></pre></td></tr></table></figure><h1 id="将Hexo与GitHub-Page-关联起来"><a href="#将Hexo与GitHub-Page-关联起来" class="headerlink" title="将Hexo与GitHub Page 关联起来"></a>将Hexo与GitHub Page 关联起来</h1><p>此处使用私有库 fishBlog 存储 hexo 项目，也就是你自己新建的项目，公共库 <code>username.github.io</code> 存储编译后的静态文件以便访问。<br><strong>1、上传 hexo 项目，并完成相关配置。</strong>上传之前，需要更新一下 <code>.gitignore</code> 文件。默认情况下 <code>public/</code> 不会被上传(也不该被上传)，确保 <code>.gitignore</code> 文件中包含一行 <code>public/</code>。</p><p>上传完成之后，将该项目设置为<strong>私有</strong>，配置 Repository secrets 。进入该项目 →  Settings → Secrets and variables → Actions → New repository secret 。新建<code> HEXO_DEPLOY_PRI</code>（配置deploy.yml会用到）,  <code>GIT_PASSWORD</code></p><p><strong>2、创建一个公共库 <code>username.github.io</code>。</strong>设置为 public 并初始化，用同样的方法新建<code> HEXO_DEPLOY_PRI</code>。</p><p>开启 pages 功能：进入该公共库 →  Settings → 左侧Pages → Build and deployment → 选择 <code>main</code> 分支， <code>/root</code>  →  save</p><p>站点配置文件_config.yml 中配置 url 和 deploy 配置项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url: https://southernfish.github.io/</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:username/username.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p><strong>3、创建GitHub Actions工作流。</strong>在你的私有库中，创建一个新的目录<code>.github/workflows/</code>，并在其中创建<code>deploy.yml</code>文件。该文件将包含自动部署的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"># Action的名字</span><br><span class="line">name: Deploy Hexo Action Name</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main</span><br><span class="line"></span><br><span class="line">#这里放环境变量,需要替换成自己的</span><br><span class="line">env:</span><br><span class="line">  # Hexo编译后使用此 git用户部署到github仓库</span><br><span class="line">  GIT_USER: username</span><br><span class="line">  # Hexo 编译后使用此 git邮箱部署到github仓库</span><br><span class="line">  GIT_EMAIL: xxxxxx@qq.com</span><br><span class="line">  # Hexo编译后要部署的github仓库</span><br><span class="line">  GIT_DEPLOY_REPO: username/username.github.io</span><br><span class="line">  # Hexo编译后要部署到的分支</span><br><span class="line">  GIT_DEPLOY_BRANCH: main</span><br><span class="line"># 工作流</span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    name: Build on node</span><br><span class="line">    runs-on: ubuntu-latest # 使用 Ubuntu 最新版</span><br><span class="line">    if: github.event.repository.owner.id == github.event.sender.id</span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        os: [ubuntu-latest]</span><br><span class="line">        node_version: [12.x] # 使用 Node.js 12.x 版本</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - name: Checkout code</span><br><span class="line">        uses: actions/checkout@v2 # 检出代码到 runner</span><br><span class="line"></span><br><span class="line">      - name: Checkout deploy repo</span><br><span class="line">        uses: actions/checkout@v2</span><br><span class="line">        with:</span><br><span class="line">          repository: $&#123;&#123; env.GIT_DEPLOY_REPO &#125;&#125;</span><br><span class="line">          ref: $&#123;&#123; env.GIT_DEPLOY_BRANCH &#125;&#125;</span><br><span class="line">          path: .deploy_git</span><br><span class="line"></span><br><span class="line">      - name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125; # 设置 Node.js 环境</span><br><span class="line">        uses: actions/setup-node@v1</span><br><span class="line">        with:</span><br><span class="line">          node-version: $&#123;&#123; matrix.node_version &#125;&#125; # 使用 Node.js 的版本，根据需要调整</span><br><span class="line"></span><br><span class="line">      - name: Configuration environment # 设置密钥、设置Git信息</span><br><span class="line">        env:</span><br><span class="line">          HEXO_DEPLOY_PRI: $&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span><br><span class="line">        run: |</span><br><span class="line">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br><span class="line">          mkdir -p ~/.ssh/</span><br><span class="line">          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span><br><span class="line">          chmod 600 ~/.ssh/id_rsa</span><br><span class="line">          ssh-keyscan -t rsa github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="line">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br><span class="line">          git config --global user.name $GIT_USER</span><br><span class="line">          git config --global user.email $GIT_EMAIL</span><br><span class="line"></span><br><span class="line">      - name: Install dependencies # 安装hexo和其他依赖</span><br><span class="line">        run: |</span><br><span class="line">          npm install hexo-cli -g</span><br><span class="line">          npm install --save</span><br><span class="line"></span><br><span class="line">      - name: Deploy hexo # 包含了clean、generate、deploy</span><br><span class="line">        run: |</span><br><span class="line">          npm run deploy</span><br></pre></td></tr></table></figure><p><strong>4、参考链接</strong></p><ul><li><a href="https://docs.github.com/zh/pages">GitHub Pages</a></li><li><a href="https://docs.github.com/zh/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#publishing-with-a-custom-github-actions-workflow">使用自定义 GitHub Actions 工作流进行发布</a></li><li><a href="https://github.com/marketplace/actions/deploy-github-pages-site">actions/deploy-github-pages-site</a></li></ul><h1 id="PicGo安装"><a href="#PicGo安装" class="headerlink" title="PicGo安装"></a>PicGo安装</h1><p>1、下载安装。直接根据提示安装，路径可自己指定。</p><p>2、PicGo<code>预置的有四种链接格式：</code>Markdown<code>、</code>HTML<code>、</code>URL<code>、</code>UBB`，其得到的上传文件链接分别为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Makdown: ![](https://i.loli.net/2021/09/14/KB3LimF5SGtI6vf.png)</span><br><span class="line">HTML: &lt;img src=&quot;https://i.loli.net/2021/09/14/KB3LimF5SGtI6vf.png&quot;/&gt;</span><br><span class="line">URL: https://i.loli.net/2021/09/14/KB3LimF5SGtI6vf.png</span><br><span class="line">UBB: [IMG]https://i.loli.net/2021/09/14/KB3LimF5SGtI6vf.png[/IMG]</span><br></pre></td></tr></table></figure><p>3、自定义链接格式<code>Custom</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Custom:  &lt;center&gt;&lt;img src=&quot;$url&quot; alt=&quot;$fileName&quot;/&gt;&lt;/center&gt;</span><br></pre></td></tr></table></figure><p>4、PicGo设置中可以配置如日志、代理等设置，一定要注意要打开该自动复制URL的设置<strong>上传后自动复制URL：开</strong></p><p>5、图床设置，此处使用GitHub图床。首先需要在 GitHub 中初始化一个 公共库 ImageHostServer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设定仓库名: username/ImageHostServer</span><br><span class="line">设定分支名: main</span><br><span class="line">设定Token: xxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">指定存储路径: /hexo</span><br><span class="line">设定自定义域名：此处我没用到，便不做设置</span><br></pre></td></tr></table></figure><p>Token 设置方式：Settings → Developer Settings → personal access tokens → Fine-grained → Generate new token → 设置名字为ImageHostServerToken → 找到Repository access → 选择 Only select repositories，并选择库 ImageHostServer → 找到 Repository permissions 的 contens  → 点击右侧下拉按钮设置为 Read and write → Generate token → 复制Token值并保存下来，picGo配置需要</p><h1 id="Typora-安装"><a href="#Typora-安装" class="headerlink" title="Typora 安装"></a>Typora 安装</h1><p>1、安装可参考<a href="https://www.cnblogs.com/fengyanqiblog/p/18928611">Typora安装及破解</a></p><p>2、配置。打开 Typora 的偏好设置，选择图像，把插入图片设置为上传图片；上传服务设置为 PicGo(app) ，PicGo路径设置为PicGo的安装路径（D:\HexoBlog\Typora\Typora.exe），配置完成之后，点击验证上传，提示成功上传图片并获得新的URL则说明成功了。如若不成功检测一下 PicGo设置的server设置端口是否一致，不一致的话需要改成一致。</p>]]></content>
    
    
    <summary type="html">本文以 Hexo + GitHub Pages + Typora + PicGo 为例介绍搭建一个 Hexo 博客日志。</summary>
    
    
    
    <category term="hexo" scheme="https://southernfish.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://southernfish.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Test-4</title>
    <link href="https://southernfish.github.io/2022/08/13/Test-4/"/>
    <id>https://southernfish.github.io/2022/08/13/Test-4/</id>
    <published>2022-08-13T12:43:11.000Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).</summary>
    
    
    
    <category term="分类3" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB3/"/>
    
    
    <category term="tag1" scheme="https://southernfish.github.io/tags/tag1/"/>
    
  </entry>
  
  <entry>
    <title>Test-3</title>
    <link href="https://southernfish.github.io/2022/08/13/Test-3/"/>
    <id>https://southernfish.github.io/2022/08/13/Test-3/</id>
    <published>2022-08-13T08:45:31.000Z</published>
    <updated>2022-08-13T09:09:10.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start-4">Quick Start</h2><h3 id="Create-a-new-post-4">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server-2">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files-2">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites-2">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).</summary>
    
    
    
    <category term="分类3" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB3/"/>
    
    <category term="分类3-1" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB3/%E5%88%86%E7%B1%BB3-1/"/>
    
    
    <category term="tag1" scheme="https://southernfish.github.io/tags/tag1/"/>
    
    <category term="tag2" scheme="https://southernfish.github.io/tags/tag2/"/>
    
  </entry>
  
  <entry>
    <title>Test-2</title>
    <link href="https://southernfish.github.io/2022/08/11/Test-2/"/>
    <id>https://southernfish.github.io/2022/08/11/Test-2/</id>
    <published>2022-08-11T01:51:21.000Z</published>
    <updated>2022-08-11T02:39:00.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start-3">Quick Start</h2><h3 id="Create-a-new-post-3">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">这是摘要哦。。。。</summary>
    
    
    
    <category term="分类1" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB1/"/>
    
    <category term="分类2" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB2/"/>
    
    
    <category term="tag3" scheme="https://southernfish.github.io/tags/tag3/"/>
    
    <category term="tag4" scheme="https://southernfish.github.io/tags/tag4/"/>
    
  </entry>
  
  <entry>
    <title>Test-1</title>
    <link href="https://southernfish.github.io/2022/08/11/Test-1/"/>
    <id>https://southernfish.github.io/2022/08/11/Test-1/</id>
    <published>2022-08-11T01:45:15.000Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">这是摘要。。。。。。</summary>
    
    
    
    <category term="分类3" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB3/"/>
    
    <category term="分类3-1" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB3/%E5%88%86%E7%B1%BB3-1/"/>
    
    
    <category term="tag1" scheme="https://southernfish.github.io/tags/tag1/"/>
    
    <category term="tag2" scheme="https://southernfish.github.io/tags/tag2/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://southernfish.github.io/2022/08/10/hello-world/"/>
    <id>https://southernfish.github.io/2022/08/10/hello-world/</id>
    <published>2022-08-10T01:15:36.000Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">hello word</summary>
    
    
    
    <category term="hexo" scheme="https://southernfish.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://southernfish.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="https://southernfish.github.io/2022/08/10/java-exceptions/"/>
    <id>https://southernfish.github.io/2022/08/10/java-exceptions/</id>
    <published>2022-08-10T01:15:36.000Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于 Java异常的问题</p><h1 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h1><h2 id="throw-和-throws-的区别？"><a href="#throw-和-throws-的区别？" class="headerlink" title="throw 和 throws 的区别？"></a>throw 和 throws 的区别？</h2><p><strong>throw：</strong>是真实抛出一个异常。<br><strong>throws：</strong>是声明可能会抛出一个异常。</p><h2 id="final、finally、finalize-有什么区别？"><a href="#final、finally、finalize-有什么区别？" class="headerlink" title="final、finally、finalize 有什么区别？"></a>final、finally、finalize 有什么区别？</h2><p><strong>final：</strong>是<strong>修饰符</strong>，如果修饰类，此类<strong>不能被继承</strong>；如果修饰方法和变量，此方法和此变量<strong>不能再被改变</strong>，只能使用。<br><strong>finally：</strong>是 try{} catch{} finally{} 最后一部分，表示<strong>不论发生任何情况都会执行</strong>，finally 部分可以省略，但若 finally 部分存在，则一定会执行 finally 里面的代码。<br><strong>finalize：</strong>是 Object 类的一个方法，在<strong>垃圾收集器执行的时候会调用被回收对象的此方法</strong>。</p><h2 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h2><p>try-catch-finally 其中 <strong>catch 和 finally 都可以被省略，但不能同时省略</strong>，也就是说有 try 时，必须后面跟一个 catch 或 finally。</p><h2 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><p><strong>finally 一定会执行</strong>，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常机制？"><a href="#异常机制？" class="headerlink" title="异常机制？"></a>异常机制？</h2><p><strong>异常机制：</strong>当<em>程序出现异常，程序安全的退出、处理完后继续执行的机制</em><br>Java是采用面向对象的方式来处理异常的。<strong>处理过程：</strong></p><ul><li><strong>抛出异常：</strong>在执行一个方法时，如果发生异常，则这个方法<strong>生成代表该异常的一个对象</strong>，停止当前执行路径，并<strong>把异常对象提交给JRE</strong>。</li><li><strong>捕获异常：</strong>JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，<strong>从生成异常的方法开始回溯，直到找到相应的异常处理代码为止</strong></li></ul><h2 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h2><p>可以使用 try-with-resources 语句来自动管理资源，如自动关闭实现了 AutoCloseable 或 Closeable 接口的资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以使用 try-with-resources 语句来自动管理资源，如自动关闭实现了 AutoCloseable 或 Closeable 接口的资源。</span><br><span class="line">try (Resource resource = new Resource()) &#123;</span><br><span class="line">    // 使用资源</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // 处理异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见的异常类有哪些？"><a href="#常见的异常类有哪些？" class="headerlink" title="常见的异常类有哪些？"></a>常见的异常类有哪些？</h2><ul><li>NullPointerException 空指针异常 （RuntimeException 无需编译器处理，增加逻辑处理来避免这些异常）</li><li>ClassNotFoundException 指定类不存在（CheckedException 需要编译器处理，使用 try-catch 结构）</li><li>NumberFormatException 字符串转换为数字异常（RuntimeException ）</li><li>IndexOutOfBoundsException 数组下标越界异常</li><li>ClassCastException 数据类型转换异常</li><li>FileNotFoundException 文件未找到异常</li><li>NoSuchMethodException 方法不存在异常</li><li>IOException IO 异常</li><li>SocketException Socket 异常</li></ul><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>所有异常的<strong>根类为 java.lang.Throwable</strong>。若内置的异常类不能够满足需要，还可以创建自己的异常类。<br>Throwable 派生了两个子类：Error 和 Exception。<br><strong>Error</strong> 是程序无法处理的错误。大多错误与代码编写者执行的操作无关，而表示代码运行时 JVM 出现的问题。<br><strong>Exception</strong> 是程序本身能够处理的异常。分为 RuntimeException 运行时异常，CheckedException 已检查异常。<strong>RuntimeException 无需编译器处理，增加逻辑处理</strong>来避免这些异常；<strong>CheckedException 需要编译器处理，使用 try-catch 结构</strong>。</p>]]></content>
    
    
    <summary type="html">java 异常</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Exceptions" scheme="https://southernfish.github.io/tags/Exceptions/"/>
    
  </entry>
  
  <entry>
    <title>对象拷贝</title>
    <link href="https://southernfish.github.io/2022/08/10/java-object-copy/"/>
    <id>https://southernfish.github.io/2022/08/10/java-object-copy/</id>
    <published>2022-08-10T01:15:36.000Z</published>
    <updated>2025-06-19T06:57:23.572Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录关于Java中对象拷贝的问题</p><h2 id="为什么要使用克隆？"><a href="#为什么要使用克隆？" class="headerlink" title="为什么要使用克隆？"></a>为什么要使用克隆？</h2><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以<strong>当需要一个新的对象来保存当前对象的“状态”</strong>就靠克隆方法了。</p><h2 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h2><p>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。<br>实现 Serializable 接口，通过<strong>对象的序列化和反序列化实现克隆</strong>，可以实现真正的深度克隆。</p><h2 id="深拷贝和浅拷贝区别是什么？"><a href="#深拷贝和浅拷贝区别是什么？" class="headerlink" title="深拷贝和浅拷贝区别是什么？"></a>深拷贝和浅拷贝区别是什么？</h2><p><strong>浅克隆：</strong>当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。<br><strong>深克隆：</strong>除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p>]]></content>
    
    
    <summary type="html">对象拷贝</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Object" scheme="https://southernfish.github.io/tags/Object/"/>
    
  </entry>
  
</feed>
