<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Southern Fish</title>
  
  
  <link href="https://southernfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://southernfish.github.io/"/>
  <updated>2025-06-23T13:16:46.574Z</updated>
  <id>https://southernfish.github.io/</id>
  
  <author>
    <name>Southern Fish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发编程</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-concurrency/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-concurrency/</id>
    <published>2025-06-23T06:29:36.000Z</published>
    <updated>2025-06-23T13:16:46.574Z</updated>
    
    <content type="html"><![CDATA[<p>并发，在<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192?fromModule=lemma_inlink">操作系统</a>中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA/128842?fromModule=lemma_inlink">处理机</a>上运行，但任一个时刻点上只有一个程序在处理机上运行。本文转载自<a href="https://blog.csdn.net/linxiaosongXXDDDGS/article/details/147779420">Java并发编程详解</a>。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="线程的本质"><a href="#线程的本质" class="headerlink" title="线程的本质"></a>线程的本质</h3><p><strong>线程是轻量级进程：</strong>在同一个进程中，多个线程共享内存空间（堆、方法区），但每个线程拥有独立的栈和程序计数器（PC）。<br>并发 vs 并行：</p><ul><li><strong>并发：</strong>线程在单核CPU上交替执行（时间片轮转）。</li><li><strong>并行：</strong>多核CPU上线程真正同时运行</li></ul><h3 id="创建线程的两种方式"><a href="#创建线程的两种方式" class="headerlink" title="创建线程的两种方式"></a>创建线程的两种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：继承Thread类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running by extending Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：实现Runnable接口（推荐，避免单继承限制，在Java中，类只能继承一个父类（单继承），但可以实现多个接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running by implementing Runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式1 启动线程（调用start()，而非run()！直接调用run()只是普通方法调用，不会创建新线程）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">        <span class="comment">// 方式2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()).start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Runnable</code>优势总结：</p><ul><li><strong>解耦任务与线程：</strong>Runnable表示任务逻辑，<code>Thread</code>表示线程载体，符合面向对象的职责分离原则。</li><li><strong>资源共享：</strong>多个线程可共享同一个Runnable实例（例如售票系统的共享票池）。</li><li><strong>灵活组合：</strong>可与线程池（<code>ExecutorService</code>）、<code>Lambda表达式</code>等现代特性无缝结合。</li></ul><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><ol><li>新建（<code>New</code>）：线程对象已创建，但未调用<code>start()</code>。</li><li>就绪（<code>Runnable</code>）：调用<code>start()</code>后，等待CPU调度。</li><li>运行（<code>Running</code>）：获得CPU时间片，执行<code>run()</code>方法。</li><li>阻塞（<code>Blocked</code>）：因等待锁、I/O操作或<code>sleep()</code>等暂停执行。</li><li>终止（<code>Terminated</code>）：<code>run()</code>执行完毕或发生未捕获异常。</li></ol><h2 id="线程同步锁机制"><a href="#线程同步锁机制" class="headerlink" title="线程同步锁机制"></a>线程同步锁机制</h2><h3 id="1、竞态条件（Race-Condition）"><a href="#1、竞态条件（Race-Condition）" class="headerlink" title="1、竞态条件（Race Condition）"></a>1、竞态条件（Race Condition）</h3><p>当多个线程同时访问共享资源且未正确同步时，结果依赖于线程执行顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 典型竞态条件示例：不安全的计数器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 非原子操作（实际为 read-modify-write）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、同步解决方案"><a href="#2、同步解决方案" class="headerlink" title="2、同步解决方案"></a>2、同步解决方案</h3><ul><li><p><code>synchronized</code> 关键字：</p><ul><li><strong>同步方法</strong>：锁对象为当前实例（<code>this</code>）或类对象（静态方法）。</li><li><strong>同步代码块</strong>：显式指定锁对象（任意对象）。</li></ul></li><li><p><strong>Lock 接口</strong>（更灵活，支持超时、公平锁）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeCounterWithLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、volatile-关键字"><a href="#3、volatile-关键字" class="headerlink" title="3、volatile 关键字"></a>3、volatile 关键字</h3><ul><li><strong>保证可见性</strong>：对<code>volatile</code>变量的修改立即对其他线程可见。</li><li><strong>禁止指令重排序</strong>：防止编译器和CPU优化导致的执行顺序错乱。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toggleFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = !flag; <span class="comment">// 非原子操作，volatile仅保证可见性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程间的协作"><a href="#线程间的协作" class="headerlink" title="线程间的协作"></a>线程间的协作</h2><h3 id="1、-wait-、notify-、notifyAll"><a href="#1、-wait-、notify-、notifyAll" class="headerlink" title="1、 wait()、notify()、notifyAll()"></a>1、 wait()、notify()、notifyAll()</h3><ul><li><p>Object类的核心方法：</p><ul><li><p><code>wait()</code>：释放锁并进入等待状态。</p></li><li><p><code>notify()</code>：随机唤醒一个等待线程。</p></li><li><p><code>notifyAll()</code>：唤醒所有等待线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者线程逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> item)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">            wait(); <span class="comment">// 缓冲区满，等待消费者消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(item);</span><br><span class="line">        System.out.println(<span class="string">&quot;生产: &quot;</span> + item + <span class="string">&quot;，当前队列大小: &quot;</span> + queue.size());</span><br><span class="line">        notifyAll(); <span class="comment">// 通知消费者可以消费</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者线程逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            wait(); <span class="comment">// 缓冲区空，等待生产者生产</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;消费: &quot;</span> + item + <span class="string">&quot;，剩余队列大小: &quot;</span> + queue.size());</span><br><span class="line">        notifyAll(); <span class="comment">// 通知生产者可以生产</span></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SharedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.produce(i);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>); <span class="comment">// 模拟生产耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Producer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.consume();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟消费耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Consumer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2、Condition-接口"><a href="#2、Condition-接口" class="headerlink" title="2、Condition 接口"></a>2、Condition 接口</h3><ul><li>与<code>Lock</code>配合使用，提供更精细的线程等待与唤醒。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> item)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                notFull.await(); <span class="comment">// 等待&quot;非满&quot;条件</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(item);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产: &quot;</span> + item + <span class="string">&quot;，队列大小: &quot;</span> + queue.size());</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 触发&quot;非空&quot;条件</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                notEmpty.await(); <span class="comment">// 等待&quot;非空&quot;条件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费: &quot;</span> + item + <span class="string">&quot;，剩余队列大小: &quot;</span> + queue.size());</span><br><span class="line">            notFull.signal(); <span class="comment">// 触发&quot;非满&quot;条件</span></span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AdvancedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdvancedBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建生产者线程（Lambda实现Runnable）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.produce(i);</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.consume();</span><br><span class="line">                    Thread.sleep(<span class="number">800</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a><a href="https://so.csdn.net/so/search?q=%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">并发编程</a></h1><h2 id="并发工具类-java-util-concurrent"><a href="#并发工具类-java-util-concurrent" class="headerlink" title="并发工具类(java.util.concurrent)"></a>并发工具类(java.util.concurrent)</h2><h3 id="1、Executor-框架"><a href="#1、Executor-框架" class="headerlink" title="1、Executor 框架"></a>1、Executor 框架</h3><ul><li><p><strong>线程池管理</strong>：避免频繁创建/销毁线程的开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建固定大小的线程池（4个线程）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交10个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由 &quot;</span> </span><br><span class="line">                    + Thread.currentThread().getName() + <span class="string">&quot; 执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池（不再接受新任务）</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、并发集合"><a href="#2、并发集合" class="headerlink" title="2、并发集合"></a>2、并发集合</h3><ul><li><p><strong>线程安全容器</strong>：避免手动同步。</p><ul><li><p><code>CopyOnWriteArrayList</code>：读多写少场景。</p></li><li><p><code>ConcurrentHashMap</code>：高并发哈希表。</p></li><li><p><code>BlockingQueue</code>：阻塞队列（如<code>LinkedBlockingQueue</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap 示例</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个写线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key-&quot;</span> + threadId + <span class="string">&quot;-&quot;</span> + j;</span><br><span class="line">                    map.put(key, j);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;写线程 &quot;</span> + threadId + <span class="string">&quot; 完成&quot;</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建读线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前Map大小: &quot;</span> + map.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3、原子类（Atomic）"><a href="#3、原子类（Atomic）" class="headerlink" title="3、原子类（Atomic）"></a>3、原子类（Atomic）</h3><ul><li><p>基于CAS（Compare-And-Swap）保证原子性，实现无锁线程安全。</p></li><li><p>性能优于<code>synchronized</code>，适用于高并发场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count.incrementAndGet(); <span class="comment">// 原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count.get()); <span class="comment">// 正确输出20000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、CountDownLatch-与-CyclicBarrier"><a href="#4、CountDownLatch-与-CyclicBarrier" class="headerlink" title="4、CountDownLatch 与 CyclicBarrier"></a>4、CountDownLatch 与 CyclicBarrier</h3><ul><li><p><strong>CountDownLatch</strong>：等待多个任务完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TASK_COUNT</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(TASK_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动多个任务线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= TASK_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 开始执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 完成&quot;</span>);</span><br><span class="line">                latch.countDown(); <span class="comment">// 计数器减1    多个线程调用 latch.countDown()</span></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待所有任务完成</span></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务已完成，继续主线程逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>CyclicBarrier</strong>：多个线程相互等待至屏障点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; System.out.println(<span class="string">&quot;All threads reached barrier&quot;</span>));</span><br><span class="line"><span class="comment">// 每个线程调用 barrier.await()</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="典型陷阱"><a href="#典型陷阱" class="headerlink" title="典型陷阱"></a>典型陷阱</h2><h3 id="1、死锁（Deadlock）"><a href="#1、死锁（Deadlock）" class="headerlink" title="1、死锁（Deadlock）"></a>1、死锁（Deadlock）</h3><p>四个必要条件：</p><ol><li><strong>互斥</strong>：资源只能被一个线程持有。</li><li><strong>占有且等待</strong>：线程持有资源并等待其他资源。</li><li><strong>不可抢占</strong>：资源不能被强制释放。</li><li><strong>循环等待</strong>：多个线程形成环形等待链。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 死锁示例</span></span><br><span class="line"><span class="comment">// Thread 1: lock A → try lock B</span></span><br><span class="line"><span class="comment">// Thread 2: lock B → try lock A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程1：先获取lockA，再请求lockB</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1 持有lockA&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟操作耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1 获取lockB&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2：先获取lockB，再请求lockA</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2 持有lockB&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2 获取lockA&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：破坏任一条件，如按固定顺序获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免死锁（统一锁顺序）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockSolution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 所有线程按相同顺序获取锁（先lockA后lockB）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; acquireLocks(lockA, lockB, <span class="string">&quot;线程1&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; acquireLocks(lockA, lockB, <span class="string">&quot;线程2&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">acquireLocks</span><span class="params">(Object firstLock, Object secondLock, String threadName)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (firstLock) &#123;</span><br><span class="line">            System.out.println(threadName + <span class="string">&quot; 持有 &quot;</span> + firstLock);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (secondLock) &#123;</span><br><span class="line">                System.out.println(threadName + <span class="string">&quot; 获取 &quot;</span> + secondLock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、活锁（Livelock）"><a href="#2、活锁（Livelock）" class="headerlink" title="2、活锁（Livelock）"></a>2、活锁（Livelock）</h3><p>线程不断重试失败的操作（如谦让式资源释放），但无法推进。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 活锁示例：两个线程互相让出CPU</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryLock(lockA)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryLock(lockB)) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; unlock(lockA); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.yield(); <span class="comment">// 让出CPU但未解决问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LivelockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">active</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(Runnable task, Worker otherWorker)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!active) &#123;</span><br><span class="line">                <span class="keyword">if</span> (otherWorker.active) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;让出执行权...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    active = <span class="literal">true</span>;</span><br><span class="line">                    task.run();</span><br><span class="line">                    active = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    active = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Worker</span> <span class="variable">worker1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Worker</span> <span class="variable">worker2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; worker1.work(() -&gt; System.out.println(<span class="string">&quot;Worker1执行任务&quot;</span>), worker2)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; worker2.work(() -&gt; System.out.println(<span class="string">&quot;Worker2执行任务&quot;</span>), worker1)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、资源竞争与性能问题"><a href="#3、资源竞争与性能问题" class="headerlink" title="3、资源竞争与性能问题"></a>3、资源竞争与性能问题</h3><p>资源竞争和性能问题是并发编程中的核心挑战之一。以下通过具体示例展示资源竞争导致的数据错误，以及不同锁策略对性能的影响，并给出优化方案。</p><ul><li><strong>锁粒度</strong>：粗粒度锁（简单但低效） vs 细粒度锁（复杂但高效）。</li><li><strong>锁分离</strong>：如<code>ReadWriteLock</code>分离读锁与写锁。</li></ul><p><strong>示例1：资源竞争导致数据错误（未同步的计数器）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeCounterExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count++; <span class="comment">// 非原子操作：read → modify → write</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动两个线程同时修改count</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预期结果：20000，实际结果可能小于20000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count); <span class="comment">// 结果不确定，因线程竞争而异</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题分析</strong>：</p><ul><li><p><code>count++</code> 是非原子操作，实际包含以下步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int tmp = count;  // Step 1: 读取当前值</span><br><span class="line">tmp = tmp + 1;    // Step 2: 修改值</span><br><span class="line">count = tmp;      // Step 3: 写回新值</span><br></pre></td></tr></table></figure></li><li><p>当两个线程同时执行时，可能出现以下时序：</p><ul><li>线程A读取<code>count=100</code> → 线程B读取<code>count=100</code> → 线程A写入<code>101</code> → 线程B写入<code>101</code></li><li>最终结果为<code>101</code>，而非预期的<code>102</code>。</li></ul></li></ul><p><strong>示例2：粗粒度锁的性能问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoarseLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 粗粒度锁：锁住整个循环</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时: &quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Final count: <span class="number">200000</span></span><br><span class="line">耗时: 120ms  <span class="comment">// 实际时间因机器性能而异，但明显较长</span></span><br></pre></td></tr></table></figure><p><strong>问题分析</strong>：</p><ul><li><strong>粗粒度锁</strong>：将整个循环包裹在<code>synchronized</code>块内，每次循环都会获取/释放锁。</li><li><strong>性能问题</strong>：频繁的锁竞争导致大量线程上下文切换，CPU时间浪费在锁管理而非实际计算。</li></ul><p><strong>示例3：细粒度锁优化（减少锁范围）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FineGrainedLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">localCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                localCount++; <span class="comment">// 先在线程本地累加</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 仅对最终合并操作加锁</span></span><br><span class="line">                count += localCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时: &quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Final count: <span class="number">200000</span></span><br><span class="line">耗时: 5ms  <span class="comment">// 性能显著提升</span></span><br></pre></td></tr></table></figure><p><strong>优化分析</strong>：</p><ul><li><strong>细粒度锁</strong>：线程先在本地变量<code>localCount</code>中累加，最后仅对合并操作加锁。</li><li><strong>性能提升</strong>：锁竞争频率从每次循环减少到每线程一次，大幅降低同步开销。</li></ul><p><strong>示例4：锁分离（读写锁优化）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 写线程（频繁修改数据）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">writer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                rwLock.writeLock().lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    value++;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>); <span class="comment">// 模拟写操作耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    rwLock.writeLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读线程（频繁读取数据）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">reader</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                rwLock.readLock().lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;读取 value: &quot;</span> + value);</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>); <span class="comment">// 模拟读操作耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    rwLock.readLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动2个写线程和4个读线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(writer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(writer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化分析</strong>：</p><ul><li><strong>读写锁分离：</strong><ul><li><strong>读锁（共享锁）</strong>：允许多个线程同时读数据。</li><li><strong>写锁（独占锁）</strong>：仅允许单个线程写数据，且与读锁互斥。</li></ul></li><li><strong>适用场景</strong>：读多写少（如缓存系统），通过减少锁竞争提升吞吐量。</li></ul><hr><h1 id="关键性总结"><a href="#关键性总结" class="headerlink" title="关键性总结"></a>关键性总结</h1><ol><li><strong>资源竞争问题</strong>：<ul><li><strong>表现</strong>：多线程同时修改共享数据导致结果错误（如计数器值不准确）。</li><li><strong>解决方案</strong>：使用同步机制（<code>synchronized</code>、<code>Lock</code>）保证原子性。</li></ul></li><li><strong>性能优化策略</strong>：<ul><li><strong>减少锁粒度</strong>：仅对必要代码块加锁（如示例3的本地累加优化）。</li><li><strong>锁分离</strong>：读写锁（<code>ReadWriteLock</code>）区分读写操作，提升并发度。</li><li><strong>无锁编程</strong>：使用原子类（<code>AtomicInteger</code>）或并发容器（<code>ConcurrentHashMap</code>）。</li></ul></li><li><strong>性能测试建议</strong>：<ul><li>对比不同锁策略的耗时（如示例2和示例3的耗时差异）。</li><li>使用性能分析工具（如<code>JProfiler</code>、<code>VisualVM</code>）定位瓶颈。</li></ul></li></ol><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ol><li>**优先使用高层并发工具:**如<code>Executor</code>、<code>ConcurrentHashMap</code>。</li><li><strong>避免过早优化：</strong>仅在性能瓶颈出现时考虑低层同步。</li><li><strong>测试并发代码：</strong>使用压力测试工具（如<code>JMeter</code>）和静态分析工具（如<code>FindBugs</code>）。</li><li><strong>遵循不变性（Immutability）：</strong>使用<code>final</code>字段和不可变对象（如<code>String</code>）。</li></ol>]]></content>
    
    
    <summary type="html">并发，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>List</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-list/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-list/</id>
    <published>2025-06-23T06:15:36.000Z</published>
    <updated>2025-06-23T13:16:46.574Z</updated>
    
    <content type="html"><![CDATA[<p>List 是 Java 集合框架中的有序列表，元素按插入顺序存储，支持通过索引（从 0 开始）访问。类似数组，但提供动态增删功能，避免数组手动扩容和元素移动的繁琐。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="List的接口方法"><a href="#List的接口方法" class="headerlink" title="List的接口方法"></a>List的接口方法</h2><p>List接口继承自<code>Collection</code>接口，提供了额外的功能来处理索引位置上的元素。与Set、Map不同，List允许包含重复的元素，并且可以通过索引来访问或修改特定位置的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 核心接口方法 */</span></span><br><span class="line">add(E e) <span class="comment">// 添加指定元素到列表末尾。</span></span><br><span class="line">add(<span class="type">int</span> index, E element)<span class="comment">// 在指定索引处插入指定元素。</span></span><br><span class="line">remove(<span class="type">int</span> index) <span class="comment">// 移除指定索引处的元素。</span></span><br><span class="line">get(<span class="type">int</span> index) <span class="comment">// 获取指定索引处的元素。</span></span><br><span class="line">set(<span class="type">int</span> index, E element) <span class="comment">// 替换指定索引处的元素。</span></span><br><span class="line">size() <span class="comment">// 返回列表中的元素数量。</span></span><br><span class="line"><span class="comment">/* 其他常用方法 */</span> </span><br><span class="line">isEmpty() <span class="comment">// 判断列表是否为空。</span></span><br><span class="line">contains(Object o) <span class="comment">// 检查列表是否包含指定元素。</span></span><br><span class="line">indexOf(Object o) <span class="comment">// 返回指定元素首次出现的索引，如果不存在则返回-1。</span></span><br><span class="line">lastIndexOf(Object o) <span class="comment">// 返回指定元素最后一次出现的索引，如果不存在则返回-1。</span></span><br><span class="line">subList(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex) <span class="comment">// 获取从fromIndex（包括）到toIndex（不包括）之间的子列表</span></span><br></pre></td></tr></table></figure><h2 id="主要实现类"><a href="#主要实现类" class="headerlink" title="主要实现类"></a>主要实现类</h2><ol><li><p><code>ArrayList</code></p><p>ArrayList是最常用的List实现之一，它基于动态数组实现，支持随机访问，查询效率高，但插入和删除效率较低。<br><strong>特点</strong>：支持快速随机访问。非线程安全。初始容量为10，每次扩容时增长50%。<br><strong>使用场景</strong>：适用于频繁读取而不经常修改的数据集合。</p></li><li><p><code>LinkedList</code></p><p>LinkedList是另一个重要的List实现，它基于双向链表实现，对于插入和删除操作具有较高的性能，但对于随机访问效率较低。<br><strong>特点</strong>：支持高效的插入和删除操作。非线程安全。可以作为堆栈、队列或双端队列使用。<br><strong>使用场景</strong>：适用于频繁进行插入和删除操作的数据集合。</p></li><li><p><code>Vector</code></p><p>早期线程安全集合类，通过方法级<code>synchronized</code>实现同步。默认扩容增长一倍。<br><strong>特点</strong>：线程安全同步锁导致并发效率低下（方法都使用了 synchronized）。性能低（主要用于同步开销）。遗留类，不推荐使用</p></li><li><p>三者对比</p><table><thead><tr><th></th><th>ArrayList</th><th>LinkedList</th><th>Vector</th></tr></thead><tbody><tr><td>底层结构</td><td>动态数组</td><td>双向链表</td><td>动态数组</td></tr><tr><td>线程安全</td><td>不安全</td><td>不安全</td><td>安全，方法都加了<code>Synchronized</code></td></tr><tr><td>是否允许重复元素</td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td>是否有序</td><td>是</td><td>是</td><td>是</td></tr><tr><td>随机访问</td><td>快O(1)，索引访问</td><td>慢O(n)，需遍历链表</td><td>快O(1)，但因同步影响性能较低</td></tr><tr><td>插入/删除</td><td>慢O(n)，需移动元素</td><td>快O(1)，只需修改指针</td><td>慢，同步开销大</td></tr><tr><td>扩容机制</td><td>默认增长50%</td><td>无需扩容，动态添加节点</td><td>默认翻倍容量</td></tr><tr><td>加载因子</td><td>1</td><td>无</td><td>1</td></tr></tbody></table></li></ol><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><ol><li><p><code>for</code>循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：可以灵活控制索引。支持随机访问（适合 ArrayList）。</span></span><br><span class="line"><span class="comment">// 缺点：对于 LinkedList 来说效率较低（因为每次都要从头开始查找元素）。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Index: &quot;</span> + i + <span class="string">&quot;, Value: &quot;</span> + list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：简洁易读。适用于所有实现了 Iterable 接口的集合类。</span></span><br><span class="line"><span class="comment">// 缺点：无法获取索引。不能修改集合结构（如删除元素会抛出异常）。</span></span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Item: &quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Iterator</code>。可以安全地在遍历时进行删除操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;B&quot;</span>.equals(item)) &#123;</span><br><span class="line">        iterator.remove();  <span class="comment">// 安全删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="去重方式"><a href="#去重方式" class="headerlink" title="去重方式"></a>去重方式</h2><ol><li><p>利用 <code>HashSet</code> 或 <code>LinkedHashSet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet 不保留顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出顺序可能不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashSet 保留插入顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Stream.distinct()</code>，Java 8+ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; uniqueList = list.stream().distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(uniqueList);</span><br></pre></td></tr></table></figure></li></ol><h2 id="List-与数组的转换"><a href="#List-与数组的转换" class="headerlink" title="List 与数组的转换"></a>List 与数组的转换</h2><ul><li><p>List 转数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无类型参数：丢失类型信息</span></span><br><span class="line">Object[] array = list.toArray();</span><br><span class="line"><span class="comment">// 带类型参数：推荐，自动匹配类型</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 函数式写法</span></span><br><span class="line">String[] array = list.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></li><li><p>数组转 List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(array);（只读）</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));（可修改）</span><br></pre></td></tr></table></figure></li></ul><h2 id="List-的元素判断机制"><a href="#List-的元素判断机制" class="headerlink" title="List 的元素判断机制"></a>List 的元素判断机制</h2><p>List的 <code>contains(Object o)</code> 和 <code>indexOf(Object o)</code> 方法通过 <code>equals()</code>而非 <code>==</code> 判断元素是否相等。</p><hr><h1 id="List的安全类"><a href="#List的安全类" class="headerlink" title="List的安全类"></a>List的安全类</h1><p>在单线程应用中，通常采取<code>new ArrayList()</code>，指定一个List集合，用于存放可重复的数据。但<code>ArrayList</code>是不安全的集合。多线程操作同一集合对象信息，往往会出现<code>java.util.ConcurrentModificationException</code>异常报错信息。</p><h2 id="Java的安全类Vector"><a href="#Java的安全类Vector" class="headerlink" title="Java的安全类Vector"></a>Java的安全类Vector</h2><p>java提供了<code>java.util.Vector</code>类，多线程下不会出现<code>java.util.ConcurrentModificationException</code>报错信息。因为采取了 <code>synchronized</code> 针对方法执行调用者加锁，保证add操作的多线程安全性！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建lists集合</span></span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JUC下的安全List集合"><a href="#JUC下的安全List集合" class="headerlink" title="JUC下的安全List集合"></a>JUC下的安全List集合</h2><ol><li><code>Collections.synchronizedList(new ArrayList&lt;&gt;());</code>。该方法返回具有同步包装器的List，保证了对List的操作是安全的。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">( <span class="meta">@NotNull</span> List&lt;T&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(list <span class="keyword">instanceof</span> RandomAccess ? </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list) : </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">synchronizedList</span>&lt;&gt;(list));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断传入的 list 集合类型，判断类型是否为 java.util.RandomAccess，如果是则采取java.util.Collections.SynchronizedRandomAccessList构造集合，如果不是则采取java.util.Collections.SynchronizedList构造集合。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码中对应的add操作逻辑如下所示。采取synchronized同步代码块的方式，对数据的add操作实现加锁！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>&#123; </span><br><span class="line">    synchron1zed (mutex) &#123;</span><br><span class="line">        list.add(index, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>new CopyOnWriteArrayList();</code>。该类中所有修改操作都在一个独立的副本上进行，不会影响原始数据，保证了线程安全。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&quot;</span>+lists);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates an empty list</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyonWriteArrayList</span><span class="params">()</span>&#123; setArray(<span class="keyword">new</span> <span class="title class_">object</span>[<span class="number">0</span>]); &#125;</span><br><span class="line"><span class="comment">// add 逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[]elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copy0f(elements, len +<span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong><code>add</code>逻辑如下所示</strong><br>  1、调用add方法后，拿到<code>java.util.concurrent.locks.ReentrantLock</code>对象信息。<br>  2、调用 <code>lock.lock()</code> 拿到锁！<br>  3、将原数组对象<code>copy</code>操作，并创建<code>原数组大小+1</code>的新数组。<br>  4、将新数据放入新数组中。<br>  5、任何操作<code>finally</code>，都进行锁的释放！</p><p>原文链接：<a href="https://blog.csdn.net/qq_47980550/article/details/148012216">java基础——java集合list详解</a>、<a href="https://blog.csdn.net/qq_38322527/article/details/114703142">JUC中的List安全类集合</a></p>]]></content>
    
    
    <summary type="html">List是 Java 集合框架中的有序列表，元素按插入顺序存储，支持通过索引（从 0 开始）访问。类似数组，但提供动态增删功能，避免数组手动扩容和元素移动的繁琐。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="集合框架" scheme="https://southernfish.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Set</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-set/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-set/</id>
    <published>2025-06-23T05:49:36.000Z</published>
    <updated>2025-06-23T13:16:46.574Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的Set是集合框架（Collection Framework）的核心接口之一，用于存储无序且唯一的元素。主要实现类包括HashSet（基于哈希表）、LinkedHashSet（维护插入顺序）和TreeSet（基于红黑树排序），三者分别适用于快速查找、保持插入顺序和自然排序的场景。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>List是有序集合的根接口，Set是无序集合的根接口，无序也就意味着元素不重复。更严格地说，Set集合不包含一对元素e1和e2 ，使得e1.equals(e2) ，并且最多一个空元素。<br>使用Set存储的特点与List相反：<strong>元素无序、不可重复</strong>。常用的实现方式：HashSet、LinkedHashSet和TreeSet。</p><table><thead><tr><th>具体实现</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>HashSet</td><td>底层数据结构是哈希表，可以存储null元素，效率高</td><td>线程不安全，需要重写hashCode()和equals()来保证元素唯一性</td></tr><tr><td>LinkedHashSet</td><td>底层数据结构是链表和哈希表(链表保证了元素的顺序与存储顺序一致，哈希表保证了元素的唯一性)，效率高</td><td>线程不安全</td></tr><tr><td>TreeSet</td><td>底层数据结构是二叉树，元素唯一且已经排好序</td><td>需要重写hashCode和equals()来保证元素唯一性</td></tr></tbody></table><p>当向HashSet结合中存入一个元素时，HashSet会调用该对象的<code>hashCode()</code>方法来得到该对象的hashCode值，然后根据hashCode值来决定该对象在HashSet中存储位置。简单的说，<strong>HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等</strong>。<br>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p><p>在使用Set存储数据时，为保障元素唯一性，常常要重写hashCode。重写hashCode方法时，尽量遵循以下原则：</p><ul><li>相同的对象返回相同的hashCode值。</li><li>不同的对象返回不同的hashCode值，否则，就会增加冲突的概率。</li><li>尽量的让hashCode值散列开（用异或运算可使结果的范围更广）。</li></ul><p>原文链接：<a href="https://blog.csdn.net/m0_37741420/article/details/112407684">Java集合（四）Set的常用实现类</a></p><hr><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>HashSet是一个无序集合，其底层结构是HashMap，简单来说，HashSet是value是固定值（<code>Object PRESENT = new Object()</code>）的HashMap。HashSet的特点(<strong>底层是HashMap/元素无序且不能重复/线程不安全</strong>)：</p><ul><li><p>HashSet的<strong>底层实现是HashMap</strong>（HashSet的值存放于HashMap的key上，HashMap的value是一个统一的值）。</p></li><li><p>HashSet中的<strong>元素无序且不能重复</strong>（从插入HashSet元素的顺序和遍历HashSet的顺序对比可以看出：遍历顺序和存入到Set的顺序并不一致）。</p></li><li><p>HashSet是<strong>线程不安全</strong>的。如果要保证线程安全，其中一种方法是将其改造成线程安全的类，示例：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>(...));</span><br></pre></td></tr></table></figure></li><li><p>HashSet<code>允许存入null</code></p></li></ul><h2 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h2><p>把对象加入HashSet时，HashSet会<strong>先计算对象的hashcode值来判断对象加入的位置</strong>，同时也会与Set中其他元素的hashcode值作比较，如果没有相同的hashcode，HashSet会假设对象没有重复出现。如果发现有相同hashcode值的对象，这时会调用<code>equals</code>方法来检查<strong>hashcode相等的对象是否真的相同</strong>。如果两者相同，HashSet就不再存储该元素。<code>hashCode()</code>与 <code>equals()</code>的相关规定：</p><ul><li>如果两个对象相等，则hashcode一定也是相同的；</li><li>两个对象相等，对两个equals方法返回true；</li><li>两个对象有相同的hashcode值，它们也不一定是相等的；</li><li>如果equals方法被覆盖过，则hashCode方法也必须被覆盖；</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该 class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ul><h2 id="HashSet的使用"><a href="#HashSet的使用" class="headerlink" title="HashSet的使用"></a>HashSet的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> <span class="comment">// 默认初始容量为16，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> <span class="comment">// 指定初始容量，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> <span class="comment">// 指定初始容量和负载因子</span></span><br><span class="line"><span class="comment">/* 增、删、包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断Set是否为空    </span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> <span class="comment">//获取迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 返回此集合中的元素数        </span></span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>LinkedHashSet是有序集合，其底层是通过LinkedHashMap来实现的，LinkedHashMap其实也就是value是固定值的LinkedHashMap。因此LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。LinkedHashSet继承了HashSet。LinkedHashSet的特点(<strong>底层是LinkedHashMap/线程不安全/元素有序</strong>)：</p><ul><li><p>底层是用LinkedHashMap来实现的。</p></li><li><p>线程不安全 。</p></li><li><p>元素有序，是按照插入的顺序排序的。</p></li><li><p>最多只能存一个null。</p></li><li><p>不支持按访问顺序对元素排序</p><p>LinkedHashSet所有的构造方法都是调用HashSet的同一个构造方法：（accessOrder = false）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>TreeSet是一个有序集合，基于TreeMap实现。TreeSet特点(支持元素排序/线程不安全/):</p><ul><li><p>TreeSet支持元素的自然排序和按照在创建时指定的Comparator比较器(外比较器)进行排序</p><ul><li><p>TreeSet使用二叉树原理对新增对象按照指定顺序排序，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</p></li><li><p>TreeSet中存储自定义类的对象时， 自定义的类必须实现Comparable接口，并且覆写相应<code>compareTo()</code>函数。</p></li><li><p>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的。自己定义的类必须实现Comparable接口，并且覆写相应的compareTo()函数，才可以正常使用。</p></li><li><p>在重写compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>  <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(student s)</span> &#123;</span><br><span class="line">        <span class="comment">// 主要条件：按照年龄从小到大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="built_in">this</span>.age - s.age;</span><br><span class="line">        <span class="comment">//次要条件：年龄相同时，按照姓名的字母顺序排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num == <span class="number">0</span> ? <span class="built_in">this</span>.name.compareTo(s.name) : num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comparabledemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;student&gt; tree = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;student&gt;();</span><br><span class="line">        <span class="type">student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;wuer&quot;</span>,<span class="number">27</span>);</span><br><span class="line">        <span class="type">student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;weuers&quot;</span>,<span class="number">250</span>);</span><br><span class="line">        tree.add(s1);</span><br><span class="line">        tree.add(s2);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>TreeSet的基本操作（增删）的时间复杂度是log(n) 。</p></li><li><p>TreeSet是非线程安全的。</p></li><li><p>TreeSet的迭代器是fail-fast策略的。</p></li><li><p>TreeSet中元素不允许为null，不允许重复值。</p></li></ul><h2 id="TreeSet的使用"><a href="#TreeSet的使用" class="headerlink" title="TreeSet的使用"></a>TreeSet的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> <span class="comment">// 创建一个空的 TreeSet，使用自然排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> <span class="comment">// 指定比较器，如果比较器是 null 将使用自然排序</span></span><br><span class="line"><span class="comment">/* 增 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> <span class="comment">// 添加一个元素</span></span><br><span class="line"><span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> <span class="comment">// 添加集合中的元素</span></span><br><span class="line"><span class="comment">/* 删 */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> <span class="comment">// 检索和删除最小（第一个）元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> <span class="comment">// 检索和删除最大（最后）元素</span></span><br><span class="line"><span class="comment">/* 包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 获取特殊元素 */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">last</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">first</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">floor</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中小于或者等于给定元素的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">ceiling</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中大于或者等于给定元素的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">higher</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中大于某个元素的最小的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">lower</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中小于某个元素的最大的元素   </span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 获取TreeSet元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断TreeSet是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空TreeSet</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java中的Set是集合框架（Collection Framework）的核心接口之一，用于存储无序且唯一的元素。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="集合框架" scheme="https://southernfish.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Map</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-map/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-map/</id>
    <published>2025-06-23T02:45:36.000Z</published>
    <updated>2025-06-23T13:16:46.574Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap是基于哈希表实现的键值对存储结构，提供高效的插入和查询操作（平均时间复杂度O(1)），允许null键/值，非线程安全，且不保证元素顺序。其核心实现包括数组+链表（JDK1.7及之前）或数组+链表+红黑树（JDK1.8及之后），通过哈希冲突解决机制（链地址法）和动态扩容优化性能。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><a href="https://so.csdn.net/so/search?q=Collection%E6%8E%A5%E5%8F%A3&spm=1001.2101.3001.7020">Collection接口</a>的实现类中存储的是具体的单个元素，Map中存储的是键值对。常用的Map实现类有：HashMap、LinkedHashMap、TreeMap、HashTable和ConcurrentHashMap。</p><table><thead><tr><th>实现类</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>HashMap</td><td>基于哈希表实现，查询快，效率高</td><td>元素存储时无序，非线程安全</td></tr><tr><td>LinkedHashMap</td><td>基于哈希表和链表实现，可以保留元素插入时的顺序</td><td>非线程安全</td></tr><tr><td>TreeMap</td><td>存储的元素有序</td><td>非线程安全</td></tr><tr><td>HashTable</td><td>线程安全，不允许null值</td><td>效率低</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>线程安全，性能较好</td><td></td></tr></tbody></table><p>原文链接：<a href="https://blog.csdn.net/m0_37741420/article/details/112424663">Java集合（三）Map的常用实现类</a></p><hr><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><code>HashMap</code>是基于哈希表实现的键值对存储结构，HashMap的核心实现结合了<code>数组</code>、<code>链表</code>和<code>红黑树</code>。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>数组</code>：默认初始容量为16，数组的每个位置称为一个桶(<code>Bucket</code>)。容量始终为<strong>2的幂次方</strong>(如16、32)，便于通过位运算快速定位索引。<br><code>链表</code>：当多个键的哈希值冲突时，这些键值对以链表形式存储在同一个桶中（链地址法）。<br><code>红黑树</code>：当链表长度超过阈值（默认8）且数组容量≥64时，链表会转换为<code>红黑树</code>，以提高查找效率（从<code>O(n)</code>优化为<code>O(log n)</code>）。</p><h3 id="哈希函数与索引定位"><a href="#哈希函数与索引定位" class="headerlink" title="哈希函数与索引定位"></a>哈希函数与索引定位</h3><p>HashMap通过哈希函数将键映射到数组的索引位置。具体步骤如下：</p><ol><li><p>调用键的<code>hashCode()</code>方法获取哈希值。</p></li><li><p><strong>扰动处理：</strong>将高16位与低16位异或<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，减少哈希碰撞概率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>(n-1) &amp; hash</code>计算桶位置，等价于<code>hash % n</code>，但性能更高‌。</p></li></ol><h3 id="冲突处理机制"><a href="#冲突处理机制" class="headerlink" title="冲突处理机制"></a>冲突处理机制</h3><ol><li><p><strong>链地址法：</strong>冲突的键值对以链表形式链接。在JDK 8之前采用头插法，JDK 8之后采用尾插法以避免多线程下的死循环问题‌</p></li><li><p><strong>红黑树转换：</strong></p><ol><li><p>当链表长度≥8且数组容量≥64时，链表会转换为红黑树‌。</p></li><li><p>红黑树节点数≤6时，退化为链表</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250623125725272.png" alt="image-20250623125725272"></p></li></ol></li></ol><h3 id="动态扩容机制"><a href="#动态扩容机制" class="headerlink" title="动态扩容机制"></a>动态扩容机制</h3><p>HashMap的扩容机制基于负载因子（默认值为0.75）。当元素数量超过<code>容量乘以负载因子</code>时，比如<strong>当数组添加到16*0.75=12时</strong>，HashMap会自动触发扩容，扩容为自身的两倍：16*2=32。扩容步骤如下：</p><ol><li>创建一个新的数组，<code>容量为原容量的两倍</code>（保持2的幂次方）。</li><li>重新计算所有元素的位置并放入新数组的对应位置，利用高位快速判断元素是否需要移动（如原索引为<code>oldIndex</code>，新索引可能为<code>oldIndex</code>或<code>oldIndex + oldCapacity</code>）。</li><li>扩容后，链表或红黑树可能会被拆分到不同的桶中‌</li></ol><h2 id="关键操作"><a href="#关键操作" class="headerlink" title="关键操作"></a>关键操作</h2><ol><li><strong>插入（put</strong>）<ol><li>计算键的哈希值并定位桶索引。</li><li>桶为空：直接插入新节点。</li><li>桶非空：遍历链表或红黑树，若存在相同键（通过<code>equals</code>判断），则更新值；否则追加节点。</li><li>触发扩容：插入后检查元素总数是否超过阈值。</li></ol></li><li><strong>查询（get）</strong>：根据哈希值定位桶，遍历链表或红黑树，通过<code>equals</code>匹配键。</li></ol><h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><ul><li><p><strong>遍历EntrySet（键值对）</strong>：支持通过<code>iterator.remove()</code>安全删除元素(优点)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;K, V&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>遍历KeySet（仅键）</strong>：性能低于<code>EntrySet</code>遍历，需多次调用<code>get()</code>（缺点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;K&gt; keyIterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key); <span class="comment">// 需要额外查询值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for-each循环"></a>for-each循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历EntrySet</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历键</span></span><br><span class="line"><span class="keyword">for</span> (K key : map.keySet()) &#123; ... &#125;</span><br><span class="line"><span class="comment">// 遍历值</span></span><br><span class="line"><span class="keyword">for</span> (V value : map.values()) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式遍历（Java-8-）"><a href="#Lambda表达式遍历（Java-8-）" class="headerlink" title="Lambda表达式遍历（Java 8+）"></a>Lambda表达式遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach( (key, value) -&gt; System.out.println(key + <span class="string">&quot; : &quot;</span> + value) );</span><br></pre></td></tr></table></figure><h3 id="Stream-API遍历（Java-8-）"><a href="#Stream-API遍历（Java-8-）" class="headerlink" title="Stream API遍历（Java 8+）"></a>Stream API遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单线程遍历</span></span><br><span class="line">map.entrySet().stream().forEach(entry -&gt; ...);</span><br><span class="line"><span class="comment">// 多线程遍历</span></span><br><span class="line">map.entrySet().parallelStream().forEach(entry -&gt; ...);</span><br></pre></td></tr></table></figure><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><table><thead><tr><th><strong>遍历方式</strong></th><th><strong>时间复杂度</strong></th><th><strong>适用场景</strong></th><th><strong>线程安全</strong></th></tr></thead><tbody><tr><td>EntrySet迭代器</td><td>O(n)</td><td>需要删除元素</td><td>需手动同步</td></tr><tr><td>EntrySet for-each</td><td>O(n)</td><td>常规遍历</td><td>需手动同步</td></tr><tr><td>KeySet遍历</td><td>O(n)（性能较低）</td><td>仅需键</td><td>需手动同步</td></tr><tr><td>Lambda表达式</td><td>O(n)</td><td>代码简洁性优先</td><td>需手动同步</td></tr><tr><td>Stream API</td><td>O(n)</td><td>大数据量处理或并行计算</td><td>需手动同步</td></tr></tbody></table><p><strong>推荐选择</strong>：</p><ul><li><strong>需键值对</strong>：优先使用<code>entrySet()</code>（迭代器或for-each）。</li><li><strong>仅需键或值</strong>：直接遍历<code>keySet()</code>或<code>values()</code>。</li><li><strong>代码简洁性</strong>：Java 8+环境下推荐Lambda表达式。</li><li><strong>线程安全</strong>：改用<code>ConcurrentHashMap</code>或使用同步包装类。</li></ul><h2 id="HashMap安全"><a href="#HashMap安全" class="headerlink" title="HashMap安全"></a>HashMap安全</h2><h3 id="HashMap线程不安全的表现"><a href="#HashMap线程不安全的表现" class="headerlink" title="HashMap线程不安全的表现"></a>HashMap线程不安全的表现</h3><ol><li><strong>数据覆盖（丢失）</strong><br> <strong>场景：</strong>多线程同时调用 <code>put()</code> 方法插入数据。<br> <strong>原因：</strong>两个线程同时计算哈希值并定位到同一个桶(bucket)时，若该位置为空，可能发生数据覆盖。<strong>无锁导致复合操作非原子性</strong>。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设线程A和线程B同时执行以下代码</span></span><br><span class="line"><span class="keyword">if</span> (table[bucket] == <span class="literal">null</span>) &#123;</span><br><span class="line">    table[bucket] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value); <span class="comment">// 可能被覆盖</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK 1.8 的数据覆盖问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapUnsafeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;Map size: &quot;</span> + map.size()); <span class="comment">// 结果可能小于 1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>链表成环</strong>（JDK 1.7 的经典问题）<br> <strong>场景：</strong>多线程同时触发 <code>resize()</code>（扩容）。<br> <strong>原因：</strong>JDK 1.7 的 HashMap 使用<strong>头插法</strong>迁移链表，<strong>并发扩容时可能导致链表成环</strong>，后续的 <code>get()</code>操作触发死循环</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.7 的扩容代码（简化）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程A执行到这里挂起</span></span><br><span class="line">            e.next = newTable[bucket]; <span class="comment">// 线程B先执行，导致链表成环</span></span><br><span class="line">            newTable[bucket] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>size 不准确</strong><br> <strong>场景：</strong>多线程同时调用 <code>put()</code> 或 <code>remove()</code>。<br> <strong>原因：</strong>size 变量是非原子操作（如 size++），并发修改可能导致最终值错误。<strong>非原子操作 + 无可见性保证</strong>。</li></ol><h3 id="HashMap线程不安全的根本原因"><a href="#HashMap线程不安全的根本原因" class="headerlink" title="HashMap线程不安全的根本原因"></a>HashMap线程不安全的根本原因</h3><ol><li><strong>无同步机制</strong><br>HashMap 的设计目标是单线程高性能，未对多线程操作进行同步（如 <code>synchronized</code> 或 <code>CAS</code>）。<br>关键操作（<code>put()、get()、resize()</code>）没有锁保护。</li><li><strong>可见性问题</strong><br>多线程修改共享变量（如 <code>table、size</code>）时，未使用 <code>volatile</code> 关键字，可能导致一个线程的修改对其他线程不可见。</li><li><strong>复合操作非原子性</strong><br>例如 <code>put()</code> 操作包含多个步骤（计算哈希、定位桶、插入节点），多线程交叉执行时可能破坏内部结构。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>使用线程安全的替代类<pre><code>`Collections.synchronizedMap()`：通过包装类对所有方法加锁（性能较差）。`ConcurrentHashMap`：分段锁（JDK 1.7）或 CAS + synchronized（JDK 1.8），高并发性能更好。</code></pre></li><li>避免多线程直接操作 HashMap<br>  限制为单线程使用，或通过副本、消息队列等方式隔离并发访问。</li></ol><hr><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>在<code>jdk1.7</code>版本<ul><li>ConcurrentHashMap的数据结构是由一个<code>Segment</code>数组和多个<code>HashEntry</code>组成。</li><li>主要实现原理是实现了<strong>锁分离</strong>的思路，采用<strong>分段锁的机制</strong>，实现并发的更新操作。</li><li>底层采用<strong>数组+链表</strong>的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。</li><li>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到 的锁分离技术。每一个Segment元素存储的是HashEntry 数组+链表（若干个桶），这个和HashMap的数据存储结构一样。</li><li>HashEntry用来封装映射表的键值对，每个桶是由若干个HashEntry对象链接起来的链表。</li></ul></li><li>在<code>jdk1.8</code>后<ul><li>取消了Segment类，直接用table数组存储键值对。采用<code>Node + CAS + Synchronized</code>来保证并发安全。</li><li>Node数据结构比较简单，就是一个链表，但是只允许对数据进行查找，不允许进行修改。</li><li>当HashEntry对象组成的链表长度超过8时，或数组长度小于64 就会扩容，则链表转换为红黑树，提升性能。底层变更为<strong>数组＋链表＋红黑树</strong>。</li></ul></li></ul><h2 id="底层原理（jdk1-8）"><a href="#底层原理（jdk1-8）" class="headerlink" title="底层原理（jdk1.8）"></a>底层原理（jdk1.8）</h2><ol><li><p>Node节点数字用的是<code>volatile</code>修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap使用volatile修饰节点数组，保证其可见性，禁止指令重排。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p>ConcurrentHashMap的<code>put()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put()方法直接调用putVal()方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以直接看putVal()方法。</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            tab = initTable();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;                  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法并未用synchronized修饰。<strong>put过程如下：</strong><br>（1）根据 key 计算出 hashcode，然后开始遍历 table；<br>（2）判断是否需要初始化；<br>（3）f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。<br>（4）如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。<br>（5）如果都不满足，则利用 synchronized 锁写入数据。<br>（6）如果数量大于 TREEIFY_THRESHOLD ，则要转换为红黑树。</p></li><li><p>ConcurrentHashMap的<code>get()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap的get()方法是不加锁的，方法内部也没加锁。</span></span><br><span class="line"><span class="comment">// 因为table有`volatile`关键字修饰，保证每次获取值都是最新的。</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span></span><br></pre></td></tr></table></figure><p>get方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头节点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果头节点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get过程如下：</strong><br>（1）首先根据key计算出来的 hashcode 寻址，如果就在桶上那么直接返回值，<br>（2）如果是红黑树那就按照树的方式获取值，<br>（3）都不满足那就按照链表的方式遍历获取值。</p></li></ol><p>原文链接：<a href="https://blog.csdn.net/FAQEW/article/details/146542959">HashMap底层原理</a>、<a href="https://blog.csdn.net/winterPassing/article/details/148248794">HashMap安全性问题</a>、<a href="https://blog.csdn.net/qq_42077317/article/details/138009817">Java中的ConcurrentHashMap原理详解</a></p>]]></content>
    
    
    <summary type="html">HashMap是基于哈希表实现的键值对存储结构，提供高效的插入和查询操作（平均时间复杂度O(1)），允许null键/值，非线程安全，且不保证元素顺序。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="集合框架" scheme="https://southernfish.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的较难题</title>
    <link href="https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-hard/"/>
    <id>https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-hard/</id>
    <published>2025-06-22T13:30:36.000Z</published>
    <updated>2025-06-23T13:16:46.571Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集了一些<a href="https://leetcode.cn/">LeetCode</a>的一些较难的题目。</p><h2 id="找出两个正序数组的中位数"><a href="#找出两个正序数组的中位数" class="headerlink" title="找出两个正序数组的中位数"></a>找出两个正序数组的中位数</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 (归并、快速排序 n.log(n))。假设 nums1 和 nums2 不会同时为空。<br>示例 1: nums1 = [1, 3]   nums2 = [2]       则中位数是 2.0<br>示例 2: nums1 = [1, 2]   nums2 = [3, 4]   则中位数是 (2 + 3)/2 = 2.5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">problem1</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 偶数个 排序后 找下标 (nums1.length + nums2.length) / 2 和 (nums1.length + nums2.length) / 2 - 1</span></span><br><span class="line">    <span class="keyword">if</span>((nums1.length + nums2.length) % <span class="number">2</span> == <span class="number">0</span> )&#123; </span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 相同长度部分</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt;= nums2[j])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// right</span></span><br><span class="line">                    right = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot; -&gt;&quot;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// right</span></span><br><span class="line">                    right = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组1 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// right</span></span><br><span class="line">                right = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组2 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// right</span></span><br><span class="line">                right = nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left + right) <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 奇数个 找下标 (nums1.length + nums2.length - 1) / 2        </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;   </span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 相同长度部分</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt;= nums2[j])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组1 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组2 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支持’-’和’-’的正则表达式匹配"><a href="#支持’-’和’-’的正则表达式匹配" class="headerlink" title="支持’.’和’*’的正则表达式匹配"></a>支持’.’和’*’的正则表达式匹配</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持<code> &#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。<code>&#39;.&#39; </code>匹配任意单个字符；<code>&#39;*&#39; </code>匹配零个或多个前面的那一个元素所谓匹配，是要涵盖整个字符串 s的，而不是部分字符串。<br>说明：s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 <em>。<br>示例 1：输入: s = “aa”    p = “a”   输出: false。解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2：输入: s = “aa”    p = “a</em>“   输出: true。<br>    解释: ‘<em>‘ 代表可匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。<br>示例 3：输入: s = “ab”    p = “.</em>“   输出: true。解释: “.<em>“ 表示可匹配零个或多个（’</em>‘）任意字符（’.’）。<br>示例 4：输入: s = “aab”    p = “c<em>a</em>b”  输出: true。<br>    解释: 因为 ‘<em>‘ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。<br>示例 5：输入:s = “mississippi”  p = “mis</em>is<em>p</em>.”  输出: false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">problem2</span><span class="params">(String s, String p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((s.length() == <span class="number">0</span> || s == <span class="literal">null</span>) &amp;&amp; (p.length() == <span class="number">0</span> || p == <span class="literal">null</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">if</span>((p == <span class="literal">null</span> &amp;&amp; s != <span class="literal">null</span>) || (p != <span class="literal">null</span> &amp;&amp; s == <span class="literal">null</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode hard</summary>
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的中等难度题</title>
    <link href="https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-medium/"/>
    <id>https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-medium/</id>
    <published>2025-06-22T12:30:36.000Z</published>
    <updated>2025-06-23T13:16:46.571Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集了一些<a href="https://leetcode.cn/">LeetCode</a>的一些中等难度的题目。</p><h2 id="基础数据类型定义"><a href="#基础数据类型定义" class="headerlink" title="基础数据类型定义"></a>基础数据类型定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode1</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode1 next;</span><br><span class="line"></span><br><span class="line">    ListNode1(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode1</span><span class="params">(<span class="type">int</span> val , ListNode1 next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode1 <span class="title function_">reverseLink</span><span class="params">(ListNode1 head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode1</span> <span class="variable">head1</span> <span class="operator">=</span> head, next1 = head.next, prev1 = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            head1.next = prev1;</span><br><span class="line">            prev1 = head1;</span><br><span class="line">            head1 = next1;</span><br><span class="line">            next1 = head1.next;  <span class="comment">// next1 = next1.next;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>给出两个非空链表来表示两个非负的整数。其中，它们各自的位数是按照<code>逆序</code>的方式存储的，并且它们的每个节点只能存储一位数字。<br>如果我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。假设除了数字 0 之外，这两个数都不会以 0 开头。<br>示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)；输出：7 -&gt; 0 -&gt; 8。原因：342 + 465 = 807</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem</span><span class="params">(ListNode1 l1, ListNode1 l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2, re = head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span> || temp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            re.val = (p1.val + p2.val + temp) % <span class="number">10</span>;</span><br><span class="line">            temp = (p1.val + p2.val + temp) / <span class="number">10</span>;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1 == <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;     <span class="comment">// p2 长</span></span><br><span class="line">            re.val = (p2.val + temp) % <span class="number">10</span>;</span><br><span class="line">            temp = (p2.val + temp) / <span class="number">10</span>;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 == <span class="literal">null</span>) &#123;   <span class="comment">// p1 长</span></span><br><span class="line">            re.val = (p1.val + temp) % <span class="number">10</span>;</span><br><span class="line">            temp = (p1.val + temp) / <span class="number">10</span>;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">            re.val = temp;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span> || temp != <span class="number">0</span>) &#123;</span><br><span class="line">            re.next = <span class="keyword">new</span> <span class="title class_">ListNode1</span>(<span class="number">0</span>);</span><br><span class="line">            re = re.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            re.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem_pre</span><span class="params">(ListNode1 l1, ListNode1 l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2, re = head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span> || temp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (p1 != <span class="literal">null</span> ? p1.val : <span class="number">0</span>)  + (p2 != <span class="literal">null</span> ? p2.val : <span class="number">0</span>) + temp;</span><br><span class="line">        temp = sum / <span class="number">10</span>;</span><br><span class="line">        re.next = <span class="keyword">new</span> <span class="title class_">ListNode1</span>(sum % <span class="number">10</span>);</span><br><span class="line">        p1 = p1 != <span class="literal">null</span> ?  p1.next : <span class="literal">null</span>;</span><br><span class="line">        p2 = p2 != <span class="literal">null</span> ?  p2.next : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不含重复字符的最长子串长度"><a href="#不含重复字符的最长子串长度" class="headerlink" title="不含重复字符的最长子串长度"></a>不含重复字符的最长子串长度</h2><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。  请注意，你的答案必须是子串的长度。<br>示例 1: 输入: “abcabcbb”。输出: 3。解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2: 输入: “bbbbb”。输出: 1。解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3: 输入: “pwwkew”。输出: 3。解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(String strSrc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strSrc.equals(<span class="string">&quot;&quot;</span>) || strSrc.length() == <span class="number">0</span> || strSrc.length() == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;源字符串&lt;&quot;</span> + strSrc + <span class="string">&quot;&gt;的最长子串&lt;&quot;</span> + strSrc + <span class="string">&quot;&gt;长度为 &gt;&gt; &quot;</span> + strSrc.length());</span><br><span class="line">        <span class="keyword">return</span> strSrc.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + strSrc.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> subStr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> maxStr.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strSrc.length(); ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; subStr.length(); j++) &#123;  <span class="comment">// 和子串的全部字符比较</span></span><br><span class="line">            <span class="keyword">if</span> (strSrc.charAt(i) == subStr.charAt(j)) &#123; <span class="comment">// 有重复字符 回退 子串长度-1 位 当前字符为新子串 指针下一位</span></span><br><span class="line">                count++;</span><br><span class="line">                i = i - subStr.length() + <span class="number">1</span>;</span><br><span class="line">                subStr = <span class="string">&quot;&quot;</span> + strSrc.charAt(i);</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == subStr.length() &amp;&amp; flag &amp;&amp; i &lt; strSrc.length()) &#123; <span class="comment">// 比完没有重复字符  当前字符串加入字符集</span></span><br><span class="line">            subStr = subStr + strSrc.charAt(i);</span><br><span class="line">            maxStr = maxStr.length() &lt; subStr.length() ? subStr : maxStr;</span><br><span class="line">            maxLen = maxStr.length();</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;源字符串&lt;&quot;</span> + strSrc + <span class="string">&quot;&gt;的最长子串&lt;&quot;</span> + maxStr + <span class="string">&quot;&gt;长度为 &gt;&gt; &quot;</span> + maxLen);</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>) || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + s.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> subStr.length();</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; subStr.length(); j++) &#123;  <span class="comment">// 和子串的全部字符比较</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == subStr.charAt(j)) &#123; <span class="comment">// 有重复字符 回退 子串长度-1个位置 取当前字符为新子串 指针下一位</span></span><br><span class="line">                i = i - subStr.length() + <span class="number">1</span>;</span><br><span class="line">                subStr = <span class="string">&quot;&quot;</span> + s.charAt(i);</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == subStr.length() &amp;&amp; flag &amp;&amp; i &lt; s.length()) &#123; <span class="comment">// 比完没有重复字符  当前字符串加入字符集</span></span><br><span class="line">            subStr = subStr + s.charAt(i);</span><br><span class="line">            maxLen = maxLen &gt; subStr.length() ? maxLen : subStr.length();</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找出字符串中最长回文子串"><a href="#找出字符串中最长回文子串" class="headerlink" title="找出字符串中最长回文子串"></a>找出字符串中最长回文子串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：输入: “babad”。输出: “bab”。注意: “aba” 也是一个有效答案。<br>示例 2：输入: “cbbd”。输出: “bb”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> dp[][] = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s.length(); j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 枚举所有子串长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; s.length(); l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123; <span class="comment">// 枚举子串的起始位置 i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + l; <span class="comment">// 通过 j=i+l 得到子串的结束位置</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= s.length()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = (s.charAt(i) == s.charAt(j));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s.charAt(i) == s.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断回文串长度</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; l + <span class="number">1</span> &gt; result.length())&#123;</span><br><span class="line">                result = s.substring(i, j + <span class="number">1</span>); <span class="comment">// 取值为左闭右开区间 [ start, end )</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将给定字符串按给定行数Z字排列"><a href="#将给定字符串按给定行数Z字排列" class="headerlink" title="将给定字符串按给定行数Z字排列"></a>将给定字符串按给定行数Z字排列</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。具体示例如下图所示。请你实现这个将字符串进行指定行数变换的函数： <code>string convert(string s, int numRows);</code></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250622221010005.png" alt="image-20250622221010005"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*官方解答</span></span><br><span class="line"><span class="comment">按顺序遍历字符串 s；</span></span><br><span class="line"><span class="comment">res[i] += c： 把每个字符 c 填入对应行s_i；</span></span><br><span class="line"><span class="comment">i += flag： 更新当前字符 c 对应的行索引；</span></span><br><span class="line"><span class="comment">flag = - flag： 在达到 ZZ 字形转折点时，执行反向*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;StringBuilder&gt;();  <span class="comment">// 每一行的字符数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        rows.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, flag = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray()) &#123; <span class="comment">// 所有字符串</span></span><br><span class="line">        rows.get(i).append(c); <span class="comment">// 实际上 遍历了rows数组</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || i == numRows - <span class="number">1</span>)&#123; <span class="comment">// 转折点 反向遍历</span></span><br><span class="line">            flag = -flag;</span><br><span class="line">        &#125;</span><br><span class="line">        i += flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(StringBuilder row : rows) &#123;</span><br><span class="line">        res.append(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串转整数的实现函数-atoi"><a href="#字符串转整数的实现函数-atoi" class="headerlink" title="字符串转整数的实现函数 atoi"></a>字符串转整数的实现函数 atoi</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的<strong>转化规则如下</strong>：<br>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。在任何情况下，若函数不能进行有效的转换时，请返回 0 。<br>提示：本题中的空白字符只包括空格字符 ‘ ‘ 。假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。<br>示例 1: 输入: “42”。输出: 42。<br>示例 2: 输入: “   -42”。输出: -42<br>    解释: 第一个非空白字符为 ‘-‘是一个负号。尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3: 输入: “4193 with words”  输出: 4193。解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4: 输入: “words and 987”。输出: 0。解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。<br>示例 5: 输入: “-91283472332”。输出: -2147483648。解释: 数字”-91283472332”超过32位有符号整数范围。返回 INT_MIN (−231) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span> || str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, flag = <span class="number">0</span>; <span class="comment">// flag 表示有没有数字</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">numStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27; &#x27;</span> &amp;&amp; numStr.length() == <span class="number">0</span>) &#123; <span class="comment">// 忽略有效字符前面的空格</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; (str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span> || str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">            &amp;&amp; (str.charAt(i) != <span class="string">&#x27;-&#x27;</span> &amp;&amp; str.charAt(i) != <span class="string">&#x27;+&#x27;</span>)) &#123; <span class="comment">// 排除第一个有效字符不是 + - 0到9的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; numStr.length() == <span class="number">1</span> &amp;&amp; (str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>)) &#123; </span><br><span class="line">            <span class="comment">// + - 后面不是0-9的数字</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span> &amp;&amp; (str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>)) &#123; <span class="comment">// 一串有效值后遇到了非数字字符</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; (str.charAt(i) == <span class="string">&#x27;-&#x27;</span> || str.charAt(i) == <span class="string">&#x27;+&#x27;</span>)) &#123; <span class="comment">// 第一个字符是 + -</span></span><br><span class="line">            numStr = numStr + str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            numStr = numStr + str.charAt(i);</span><br><span class="line">            target = target <span class="number">10</span> + (str.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!numStr.equals(<span class="string">&quot;&quot;</span>) &amp;&amp; numStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        target = <span class="number">0</span> - target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; Math.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span> || target &lt; Math.pow(-<span class="number">2</span>, <span class="number">31</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> numStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span> ? (<span class="type">int</span>) Math.pow(-<span class="number">2</span>, <span class="number">31</span>) : (<span class="type">int</span>) Math.pow(<span class="number">2</span>, <span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大容量的容器"><a href="#最大容量的容器" class="headerlink" title="最大容量的容器"></a>最大容量的容器</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code>。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。<br>示例：输入：[1,8,6,2,5,4,8,3,7]。输出：49</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="literal">null</span> || height.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> bottomLen, target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            bottomLen = j - i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> bottomLen Math.min(height[i], height[j]);</span><br><span class="line">            target = Math.max(target, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>罗马数字包含以下七种字符:I，V，X，L，C，D和M。<br>字符（数值）对应关系：I（1）、V（5）、X（10）、L（50）、C（100）、D（500）、M（1000）<br>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：<br>I可以放在V(5)        和X(10)       的左边，来表示 4        和9。<br>X可以放在L(50)     和C(100)     的左边，来表示 40     和90。<br>C可以放在D(500)  和M(1000)  的左边，来表示 400  和900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1到 3999 的范围内<br>示例 1: 输入:”III”            输出: 3<br>示例 2: 输入:”IV”            输出: 4<br>示例 3: 输入:”IX”                输出: 9<br>示例 4: 输入:”LVIII”            输出: 58         解释: L = 50, V= 5, III = 3。<br>示例 5: 输入:”MCMXCIV”      输出: 1994         解释: M = 1000, CM = 900, XC = 90, IV = 4。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String sub[] = &#123;<span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;M&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> cons[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">90</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">500</span>, <span class="number">900</span>, <span class="number">1000</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cons.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num / cons[i] == <span class="number">0</span>) &#123; <span class="comment">// 不能匹配当前了 则匹配较小的</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num / cons[i] != <span class="number">0</span>) &#123; <span class="comment">// 减去已经匹配的</span></span><br><span class="line">            target = target + sub[i];</span><br><span class="line">            num -= cons[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中三数之和为0的三元组"><a href="#数组中三数之和为0的三元组" class="headerlink" title="数组中三数之和为0的三元组"></a>数组中三数之和为0的三元组</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。<br>示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2] ]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;Integer&gt;&gt; problem8(int[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; re = new ArrayList&lt;&gt;();</span><br><span class="line">    // 找出所有的三元组 [a, b, c] 对应的指针分别为 i j k</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    Arrays.<span class="built_in">sort</span>(nums);  // 从小到大排序</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;//  跳过数组中的重复元素</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = n - 1; // c对应的指针初始指向数组的最右端</span><br><span class="line">        <span class="keyword">for</span> (int j = i + 1; j &lt; nums.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;//  跳过数组中的重复元素</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k &gt; j &amp;&amp; nums[i] + nums[j] + nums[k] &gt; 0) &#123;  // 保证 b 的指针在 c 的指针的左侧</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果指针重合，随着 b增大 不再存在满足 a+b+c=0 并且 b &lt; c 的 c</span><br><span class="line">            <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == 0) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                list.add(nums[j]);</span><br><span class="line">                list.add(nums[k]);</span><br><span class="line">                re.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中与给定值最接近的三数之和"><a href="#数组中与给定值最接近的三数之和" class="headerlink" title="数组中与给定值最接近的三数之和"></a>数组中与给定值最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。<br>示例：输入：nums = [-1,2,1,-4], target = 1    输出：2。解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。<br>提示：3 &lt;= nums.length &lt;= 10^3；-10^3 &lt;= nums[i] &lt;= 10^3；-10^4 &lt;= target &lt;= 10^4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 每个三元组 [a, b, c] 对应的指针分别为 i j k</span></span><br><span class="line">    Arrays.sort(nums);  <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">3</span>) &#123; <span class="comment">// 只有三位数</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res - target == <span class="number">0</span>) &#123; <span class="comment">// 前三位之和为target</span></span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 跳过数组中的重复元素</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// c对应的指针初始指向数组的最右端</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; j) &#123; <span class="comment">// 保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k];</span><br><span class="line">            <span class="keyword">if</span> (temp == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(res - target) &gt;= Math.abs(temp - target)) &#123;</span><br><span class="line">                res = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (temp &gt; target) &#123; <span class="comment">// 当前和比目标值较大 第三个数减小 右往左</span></span><br><span class="line">                k = k - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) &#123; <span class="comment">// 跳过数组中的重复元素</span></span><br><span class="line">                    k = k - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; target) &#123; <span class="comment">// 当前和比目标值较小 第二个数增大 左往右</span></span><br><span class="line">                j = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123; <span class="comment">// 跳过数组中的重复元素</span></span><br><span class="line">                    j = j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拼音九键中给定两数字对应字符串列表"><a href="#拼音九键中给定两数字对应字符串列表" class="headerlink" title="拼音九键中给定两数字对应字符串列表"></a>拼音九键中给定两数字对应字符串列表</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话(拼音九键)按键相同）。<br>注意： 1 不对应任何字母。示例：输入：”23”。输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">problem</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">    List&lt;String&gt; re = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (digits.length() == <span class="number">0</span> || digits.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> digit[] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    String corr[] = &#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;!@#&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    re = findCombination(re, corr, digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findCombination</span><span class="params">(List&lt;String&gt; re, String[] corr, String digits, <span class="type">int</span> index, String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">        re.add(s);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">    <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> corr[c - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; letters.length(); i++) &#123;</span><br><span class="line">        findCombination(re, corr, digits, index + <span class="number">1</span>, s + letters.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转每对括号间的子串"><a href="#反转每对括号间的子串" class="headerlink" title="反转每对括号间的子串"></a>反转每对括号间的子串</h2><p>给出一个字符串 s（仅含有小写英文字母和括号）。请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。注意，结果中不应包含任何括号。<br>示例 1：输入：s = “(abcd)”。输出：”dcba”<br>示例 2：输入：s = “(u(love)i)”。输出：”iloveu”。解释：先反转子字符串 “love” ，然后反转整个字符串。<br>示例 3：输入：s = “(ed(et(oc))el)”。输出：”leetcode”。解释：先反转子字符串 “oc” ，接着反转 “etco” ，然后反转整个字符串。<br>提示：1 &lt;= s.length &lt;= 2000；s 中只有小写英文字母和括号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            reverse(arr, stack.pop() + <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="string">&#x27;)&#x27;</span> &amp;&amp; arr[i] != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            sb.append(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = tmp;</span><br><span class="line">        right--;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode medium</summary>
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的简单题</title>
    <link href="https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-easy/"/>
    <id>https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-easy/</id>
    <published>2025-06-22T11:58:36.000Z</published>
    <updated>2025-06-23T13:16:46.571Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集了一些<a href="https://leetcode.cn/">LeetCode</a>的一些简单的题目</p><h2 id="基础数据类型定义"><a href="#基础数据类型定义" class="headerlink" title="基础数据类型定义"></a>基础数据类型定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode1</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode1 next;</span><br><span class="line">    ListNode1() &#123;&#125;</span><br><span class="line">    ListNode1(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode1(<span class="type">int</span> val, ListNode1 next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode1</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode1 left;</span><br><span class="line">     TreeNode1 right;</span><br><span class="line">    </span><br><span class="line">     TreeNode1(<span class="type">int</span> x) &#123;</span><br><span class="line">         val = x;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和为目标值的两数在数组中的下标"><a href="#和为目标值的两数在数组中的下标" class="headerlink" title="和为目标值的两数在数组中的下标"></a>和为目标值的两数在数组中的下标</h2><p>给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br>示例: nums = [2, 7, 11, 15], target = 9。因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] problem(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> result[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32位整数反转"><a href="#32位整数反转" class="headerlink" title="32位整数反转"></a>32位整数反转</h2><p>给出一个 <code>32位</code>的有符号整数，你需要将这个整数中每位上的数字进行反转。注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为<code>[−231, 231− 1]</code>。请根据这个假设，如果反转后整数溢出那么就返回 0。<br>示例 1: 输入: 123   输出: 321<br>示例 2: 输入: -123  输出: -321<br>示例 3: 输入: 120   输出: 21</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;     </span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// int  溢出问题</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;        <span class="comment">// 1534236469</span></span><br><span class="line">        len = (x + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        len = (x + <span class="string">&quot;&quot;</span>).length() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        target += tempMath.pow(<span class="number">10</span>, len - <span class="number">1</span>);</span><br><span class="line">        len = len - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println((<span class="type">int</span>)Math.pow(<span class="number">2</span>, <span class="number">31</span>) + <span class="string">&quot; --- &quot;</span> + Math.pow(<span class="number">2</span>, <span class="number">31</span>));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) target == target ? <span class="type">int</span>(target) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        target = target10 + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((target &gt; Math.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) || (target &lt; Math.pow(-<span class="number">2</span>, <span class="number">31</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((target &gt; Math.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) || (target &lt; Math.pow(-<span class="number">2</span>, <span class="number">31</span>))) ? <span class="number">0</span> : (<span class="type">int</span>) target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回文数判断"><a href="#回文数判断" class="headerlink" title="回文数判断"></a>回文数判断</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>示例 1: 输入: 121  输出: true<br>示例 2: 输入: -121 输出: false  解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3: 输入: 10    输出: false  解释: 从右向左读, 为 01 。因此它不是一个回文数。<br><strong>进阶:</strong> 能不将整数转为字符串来解决这个问题吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)) &#123; <span class="comment">// 负数都不是回文数  除0以外的整十数都不是回文数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> x + <span class="string">&quot;&quot;</span>; </span><br><span class="line">    System.out.println(src.length());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = src.length() - <span class="number">1</span>; i &lt;= src.length() / <span class="number">2</span> &amp;&amp; j &gt;= src.length() / <span class="number">2</span>; i++, j--) &#123;</span><br><span class="line">        System.out.println(src.charAt(i) + <span class="string">&quot;&lt;----&gt;&quot;</span> + src.charAt(j));</span><br><span class="line">        <span class="keyword">if</span> (src.charAt(i) != src.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不使用字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)) &#123; <span class="comment">// 负数都不是回文数  除0以外的整十数都不是回文数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (x + <span class="string">&quot;&quot;</span>).length() / <span class="number">2</span>, target = <span class="number">0</span>, isEven = (x + <span class="string">&quot;&quot;</span>).length() % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        target += (<span class="type">int</span>) tempMath.pow(<span class="number">10</span>, count - <span class="number">1</span>);</span><br><span class="line">        count = count - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;--&gt;&quot;</span> + target);</span><br><span class="line">    <span class="keyword">if</span> (isEven == <span class="number">0</span> &amp;&amp; target != x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEven == <span class="number">1</span> &amp;&amp; target != (x / <span class="number">10</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>罗马数字包含以下七种字符:I，V，X，L，C，D和M。<br>字符（数值）对应关系：I（1）、V（5）、X（10）、L（50）、C（100）、D（500）、M（1000）<br>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：<br>I可以放在V(5)        和X(10)       的左边，来表示 4        和9。<br>X可以放在L(50)     和C(100)     的左边，来表示 40     和90。<br>C可以放在D(500)  和M(1000)  的左边，来表示 400  和900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1到 3999 的范围内<br>示例 1: 输入:”III”            输出: 3<br>示例 2: 输入:”IV”            输出: 4<br>示例 3: 输入:”IX”                输出: 9<br>示例 4: 输入:”LVIII”            输出: 58         解释: L = 50, V= 5, III = 3。<br>示例 5: 输入:”MCMXCIV”      输出: 1994         解释: M = 1000, CM = 900, XC = 90, IV = 4。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        char constant[] = &#123;&#x27;I&#x27;,&#x27;V&#x27;,&#x27;X&#x27;,&#x27;L&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;M&#x27;&#125;;</span></span><br><span class="line">    <span class="type">int</span> cons[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">1000</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">SRC</span> <span class="operator">=</span> <span class="string">&quot;IVXLCDM&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s.charAt(i) == <span class="string">&#x27;I&#x27;</span> &amp;&amp; (s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;V&#x27;</span> || s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;X&#x27;</span>)) ||</span><br><span class="line">                (s.charAt(i) == <span class="string">&#x27;X&#x27;</span> &amp;&amp; (s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;L&#x27;</span> || s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;C&#x27;</span>)) ||</span><br><span class="line">                (s.charAt(i) == <span class="string">&#x27;C&#x27;</span> &amp;&amp; (s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;D&#x27;</span> || s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;M&#x27;</span>))) &#123;</span><br><span class="line">            target += cons[SRC.indexOf(s.charAt(i + <span class="number">1</span>))] - cons[SRC.indexOf(s.charAt(i))];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target += cons[SRC.indexOf(s.charAt(i))];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="keyword">if</span> (i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        target += cons[SRC.indexOf(s.charAt(i))];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串数组的最长公共前缀"><a href="#字符串数组的最长公共前缀" class="headerlink" title="字符串数组的最长公共前缀"></a>字符串数组的最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。 说明: 所有输入只包含小写字母a-z。<br>如果不存在公共前缀，返回空字符串””。<br>示例 1: 输入: [“flower”,”flow”,”flight”]  输出: “fl”<br>示例 2: 输入: [“dog”,”racecar”,”car”]     输出: “” 解释: 输入不存在公共前缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.min(strs[i].length(), prefix.length()); <span class="comment">// 比较直到较小长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 字符比较 下标</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; len &amp;&amp; prefix.charAt(index) == strs[i].charAt(index)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        prefix = prefix.substring(<span class="number">0</span>, index); <span class="comment">// 取公共前缀</span></span><br><span class="line">        <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123; <span class="comment">// 前缀已经为空 则退出比较</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效字符串判定"><a href="#有效字符串判定" class="headerlink" title="有效字符串判定"></a>有效字符串判定</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>    左括号必须用相同类型的右括号闭合。<br>    左括号必须以正确的顺序闭合。<br>    注意空字符串可被认为是有效字符串。<br>示例 1: 输入: “()”  输出: true<br>示例 2: 输入: “()[]{}”    输出: true<br>示例 3: 输入: “(]”   输出: false<br>示例 4: 输入: “([)]”   输出: false<br>示例 5: 输入: “{[]}” 输出: true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">problem</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 空串合法</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个字符为右括号 或者 串长为奇数 非法</span></span><br><span class="line">    <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">&#x27;)&#x27;</span> || s.charAt(<span class="number">0</span>) == <span class="string">&#x27;]&#x27;</span> || s.charAt(<span class="number">0</span>) == <span class="string">&#x27;&#125;&#x27;</span> || s.length() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//左括号进栈  右括号出栈 判断是否合法</span></span><br><span class="line">    <span class="type">char</span> stack[] = <span class="keyword">new</span> <span class="title class_">char</span>[s.length()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span> || s.charAt(i) == <span class="string">&#x27;[&#x27;</span> || s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack[top++] = s.charAt(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--top];</span><br><span class="line">            <span class="keyword">if</span> ((temp == <span class="string">&#x27;(&#x27;</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) || (temp == <span class="string">&#x27;[&#x27;</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27;]&#x27;</span>) ||</span><br><span class="line">                        (temp == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27;&#125;&#x27;</span>)) &#123;</span><br><span class="line">                </span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top != <span class="number">0</span>) &#123;  <span class="comment">// 栈不空 非法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个升序链表"><a href="#合并两个升序链表" class="headerlink" title="合并两个升序链表"></a>合并两个升序链表</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过 拼接给定的两个链表的所有节点 组成的。<br>示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4; 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem</span><span class="params">(ListNode1 l1, ListNode1 l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span> &amp;&amp; l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1 == <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2, h;</span><br><span class="line">    <span class="keyword">if</span> (p1.val &lt; p2.val) &#123;</span><br><span class="line">        h = p1;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        h = p2;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">head</span> <span class="operator">=</span> h;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt; p2.val) &#123;</span><br><span class="line">            h.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span>) &#123; <span class="comment">// l1剩下的</span></span><br><span class="line">        h.next = p1;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span>) &#123; <span class="comment">// l2 剩下的</span></span><br><span class="line">        h.next = p2;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序数组原地去重"><a href="#排序数组原地去重" class="headerlink" title="排序数组原地去重"></a>排序数组原地去重</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 【原地】修改输入数组 并在使用 O(1) 额外空间的条件下完成。<br>示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>      不需要考虑数组中超出新长度后面的元素。<br>示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。       不需要考虑数组中超出新长度后面的元素。<br>说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:<br>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br><code>int len = removeDuplicates(nums);</code><br>// 在函数里修改输入数组对于调用者是可见的。根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br><code>for (int i = 0; i &lt; len; i++) &#123; print(nums[i]); &#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] != nums[i]) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            nums[index] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原地删除数组中特定值"><a href="#原地删除数组中特定值" class="headerlink" title="原地删除数组中特定值"></a>原地删除数组中特定值</h2><p>给你一个数组 nums和一个值 val，你需要 原地 移除所有数值等于val的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>       你不需要考虑数组中超出新长度后面的元素。<br>示例2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>       注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。<br>说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:<br>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br><code>int len = removeElement(nums, val);</code><br>// 在函数里修改输入数组对于调用者是可见的。根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br><code>for (int i = 0; i &lt; len; i++) &#123; print(nums[i]); &#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现strStr-函数"><a href="#实现strStr-函数" class="headerlink" title="实现strStr()函数"></a>实现strStr()函数</h2><p>给定一个haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。<br>示例 1: 输入: haystack = “hello”, needle = “ll”   输出: 2<br>示例 2: 输入: haystack = “aaaaa”, needle = “bba”  输出: -1<br>说明: 当needle是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当needle是空字符串时我们应当返回 0 。这与C语言的<code>strstr()</code>以及 Java的<code>indexOf()</code>定义相符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem10</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.length() == <span class="number">0</span> || needle.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haystack.length() &lt; needle.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> haystack.length() - needle.length() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; diff; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; needle.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123; <span class="comment">// 不匹配 退出比较</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.length()) &#123; <span class="comment">// 比完 第一次找到匹配的needle  退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == diff) &#123; <span class="comment">// 比完 没找到</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在排序数组中找目标值"><a href="#在排序数组中找目标值" class="headerlink" title="在排序数组中找目标值"></a>在排序数组中找目标值</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。<br>示例 1: 输入: [1,3,5,6], 5      输出: 2<br>示例 2: 输入: [1,3,5,6], 2      输出: 1<br>示例 3: 输入: [1,3,5,6], 7      输出: 4<br>示例 4: 输入: [1,3,5,6], 0      输出: 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target || (i == <span class="number">0</span> &amp;&amp; nums[i] &gt; target)) &#123; <span class="comment">// 原数组中找到了  target 或者比第一个还小</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] &lt; target &amp;&amp; nums[i + <span class="number">1</span>] &gt; target) &#123;  </span><br><span class="line">            <span class="comment">// 插在数组的第 2 到第 nums.length-1个位置</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.length; <span class="comment">// 插到第 nums.length 个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h2><p>外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：<br><code>1（1）、2（11）、3（21）、4（1211）、5（111221）</code><br><code>1</code>读作”one 1”(“一个一”),即11。<code>11</code>读作”two 1”(“两个一”）,即21。<code>21</code>读作”one 2”,”one 1”（”一个二”,”一个一”), 即1211。<br>给定一个正整数 n（1 ≤n≤ 30），输出外观数列的第 n 项。<strong>注意：</strong>整数序列中的每一项将表示为一个字符串。<br>示例 1: 输入: 1 输出: “1”        解释：这是一个基本样例。<br>示例 2: 输入: 4  输出: “1211”<br>解释：当 n = 3 时，序列是 “21”，其中我们有 “2” 和 “1” 两组，”2” 可以读作 “12”，也就是出现频次 = 1 而 值 = 2；类似 “1” 可以读作 “11”。所以答案是 “12” 和 “11” 组合在一起，也就是 “1211”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;  <span class="comment">// 首项</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123; <span class="comment">// 第二项</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 推导</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">nextStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>, index = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; str.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str.charAt(index) == str.charAt(j)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextStr = nextStr + count + str.charAt(index);</span><br><span class="line">                    index = j;</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == str.length()) &#123; <span class="comment">// 比到了最后</span></span><br><span class="line">                nextStr = nextStr + count + str.charAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">            str = nextStr;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; ---&gt;&gt; &quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大连续数组"><a href="#最大连续数组" class="headerlink" title="最大连续数组"></a>最大连续数组</h2><p>给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6。解释:连续子数组[4,-1,2,1] 的和最大，为6。<br>进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> nums[<span class="number">0</span>], max = target, index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        target += nums[i];</span><br><span class="line">        max = max &gt; target ? max : target;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.length - <span class="number">1</span> &amp;&amp; index &lt; nums.length) &#123; <span class="comment">// 已经最后 回退</span></span><br><span class="line">            System.out.println(index + <span class="string">&quot; --&gt; &quot;</span> + max);</span><br><span class="line">            i = index++ - <span class="number">1</span>; <span class="comment">// 执行完后 i会加1;</span></span><br><span class="line">            target = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    <span class="comment">/*考虑分治的方法*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算字符串中最后一个单词的长度"><a href="#计算字符串中最后一个单词的长度" class="headerlink" title="计算字符串中最后一个单词的长度"></a>计算字符串中最后一个单词的长度</h2><p>给定一个仅包含大小写字母和空格’ ‘的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。如果不存在最后一个单词，请返回 0。说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。<br>示例: 输入: “Hello World”  输出: 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem14</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// 从后往前看第一个单词的长度</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组代表一个数字，做加一计算"><a href="#数组代表一个数字，做加一计算" class="headerlink" title="数组代表一个数字，做加一计算"></a>数组代表一个数字，做加一计算</h2><p>给定一个由整数组成的 【非空数组】 所表示的 【非负整数】 ，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。<br>示例1: 输入: [1,2,3]       输出: [1,2,4]        解释: 输入数组表示数字 123。<br>示例2: 输入: [4,3,2,1]    输出: [4,3,2,2]     解释: 输入数组表示数字 4321。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] problem(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == digits.length - <span class="number">1</span> &amp;&amp; (digits[i] + <span class="number">1</span> &lt; <span class="number">10</span>)) &#123; <span class="comment">// 最后一位没有进位</span></span><br><span class="line">            digits[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> digits[i];</span><br><span class="line">            <span class="keyword">if</span> (i == digits.length - <span class="number">1</span>) &#123; <span class="comment">// 最后一位有进位</span></span><br><span class="line">                digits[i] = (digits[i] + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                digits[i] = (pre + temp) % <span class="number">10</span>;</span><br><span class="line">                temp = (pre + temp) / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123;  <span class="comment">// 最后一位数有进位</span></span><br><span class="line">        <span class="type">int</span>[] re = <span class="keyword">new</span> <span class="title class_">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        re[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; digits.length; i++) &#123;</span><br><span class="line">            re[i + <span class="number">1</span>] = digits[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二进制相加"><a href="#二进制相加" class="headerlink" title="二进制相加"></a>二进制相加</h2><p>给你两个二进制字符串，返回它们的和（用二进制表示）。输入为 【非空】 字符串且只包含数字1和0。<br>示例 1: 输入: a = “11”, b = “1”              输出: “100”<br>示例 2: 输入: a = “1010”, b = “1011”   输出: “10101”<br>提示：每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。 <code>1 &lt;= a.length, b.length &lt;= 10^4</code>。字符串如果不是 “0” ，就都不含前导零。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">re</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>, temp = <span class="number">0</span>; <span class="comment">// temp 是进位</span></span><br><span class="line">    <span class="comment">// char型的数字 转 int：  char - &#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        re = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + (b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) % <span class="number">2</span> + re;</span><br><span class="line">        temp = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + (b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) / <span class="number">2</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;  <span class="comment">// a 剩下的</span></span><br><span class="line">        re = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + temp) % <span class="number">2</span> + re;</span><br><span class="line">        temp = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + temp) / <span class="number">2</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123; <span class="comment">// b 剩下的</span></span><br><span class="line">        re = ((b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) % <span class="number">2</span> + re;</span><br><span class="line">        temp = ((b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) / <span class="number">2</span>;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123; <span class="comment">// 最后还有进位</span></span><br><span class="line">        re = temp + re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现int-sqrt-int-x-函数"><a href="#实现int-sqrt-int-x-函数" class="headerlink" title="实现int sqrt(int x)函数"></a>实现int sqrt(int x)函数</h2><p>计算并返回x的平方根，其中x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。<br>示例 1: 输入: 4   输出: 2<br>示例 2: 输入: 8   输出: 2。说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> (<span class="type">int</span>)Math.exp(<span class="number">0.5</span> Math.log(x));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>)(ans + <span class="number">1</span>) (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种 二分查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, e = x;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e) &#123;     <span class="comment">// 二分查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> i + (e - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>)mid mid &lt;= x) &#123; <span class="comment">// 右边  (long long)mid  mid</span></span><br><span class="line">            target = mid;</span><br><span class="line">            i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 左边</span></span><br><span class="line">            e = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三种 牛顿迭代</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">C</span> <span class="operator">=</span> x, x0 = x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="comment">// 牛顿迭代   比二分快</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">xi</span> <span class="operator">=</span> <span class="number">0.5</span> (x0 + C / x0);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(x0 - xi) &lt; <span class="number">1e-7</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x0 = xi;</span><br><span class="line">    &#125;</span><br><span class="line">    target = (<span class="type">int</span>) x0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="爬楼梯算法"><a href="#爬楼梯算法" class="headerlink" title="爬楼梯算法"></a>爬楼梯算法</h2><p>假设你正在爬楼梯。需要n阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。有多少种不同方法可以爬到楼顶？注意：给定 n 是正整数。<br>示例 1：输入： 2  输出： 2。解释： 有两种方法可以爬到楼顶。（1 阶 + 1 阶）、（2 阶）<br>示例 2：输入： 3  输出： 3。解释： 有三种方法可以爬到楼顶。（1 阶 + 1 阶 + 1 阶）、（1 阶 + 2 阶）、（2 阶 + 1 阶）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        target = test_math(n);       // 排列组合</span></span><br><span class="line">    target = test_dynamicProgram(n); <span class="comment">// 滚动数组</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test_math</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 排列组合中的排列  排列： A(n,m)=n×（n-1）...（n-m+1）=n!/（n-m）!(n为下标,m为上标）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> n, count2 = <span class="number">0</span>, target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count1 - <span class="number">2</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count1 - <span class="number">2</span> == <span class="number">0</span>) &#123;<span class="comment">// 全2</span></span><br><span class="line">            target += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count2++; <span class="comment">// 2的个数</span></span><br><span class="line">            count1 = count1 - <span class="number">2</span>;</span><br><span class="line">            target += combination(count1 + count2, count2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target + <span class="number">1</span>; <span class="comment">// 加一个全 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合   C(n,m) = A(n,m) / m!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">combination</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (n - m + <span class="number">1</span>); i &lt;= n; i++) &#123; <span class="comment">// A(n,m)=n*(n-1)...(n-m+1)=n! / (n-m)!</span></span><br><span class="line">        target *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &gt;= <span class="number">1</span>; i--) &#123; <span class="comment">// C(n,m) = A(n,m) / m!</span></span><br><span class="line">        target /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态规划的转移方程：</strong>用 <code>f(x)</code> 表示爬到<code>第 x 级台阶</code>的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，故可列出如下式子：<code>f(x) = f(x−1) + f(x−2)</code>。它意味着爬到第 x级台阶的方案数是爬到<code>第 x−1 级台阶</code>的方案数和爬到<code>第 x−2 级台阶</code>的方案数的和。因为每次只能爬 11 级或 22 级，所以 <code>f(x)</code>只能从 <code>f(x−1) </code>和 <code>f(x−2)</code> 转移过来，要统计方案总数，就需要对这两项的贡献求和。<br><strong>边界条件：</strong>从第 0 级开始爬，从第 0 级爬到第 0 级可以看作只有一种方案，即 <code>f(0)=1</code>；从第 0 级到第 1 级也只有一种方案，即爬一级，<code>f(1)=1</code>。这两个作为边界条件就可以继续向后推导出第 n 级的正确结果。<br>不妨写几项来验证一下，根据转移方程得到 <code>f(2)=2</code>，<code>f(3)=3</code>，<code>f(4)=5</code>……把这些情况都枚举出来，发现计算的结果是正确的。<br>不难通过转移方程和边界条件给出一个时间复杂度和空间复杂度都是 O(n) 的实现，但由于这里的 <code>f(x)</code> 只和 <code>f(x−1)</code> 与 <code>f(x−2)</code> 有关，所以可以用「<strong>滚动数组思想</strong>」把空间复杂度优化成 <code>O(1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test_dynamicProgram</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序链表去重"><a href="#排序链表去重" class="headerlink" title="排序链表去重"></a>排序链表去重</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。<br>示例1: 输入: 1-&gt;1-&gt;2             输出: 1-&gt;2<br>示例2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3  输出: 1-&gt;2-&gt;3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem</span><span class="params">(ListNode1 head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p</span> <span class="operator">=</span> head.next, pre = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val == pre.val) &#123;</span><br><span class="line">            pre.next = p.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两无序数组为一个有序数组"><a href="#合并两无序数组为一个有序数组" class="headerlink" title="合并两无序数组为一个有序数组"></a>合并两无序数组为一个有序数组</h2><p>给你两个有序整数数组nums1 和 nums2，请你将 nums2 合并到nums1中，使 nums1 成为一个有序数组。<br>说明：初始化nums1 和 nums2 元素数量分别为m 和 n 。设nums1有足够的空间（空间大小大于或等于m + n）保存 nums2 中元素。<br>示例：输入: nums1 = [1,2,3,0,0,0], m = 3；nums2 = [2,5,6], n = 3。输出:[1,2,2,3,5,6]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] num1, <span class="type">int</span> m, <span class="type">int</span>[] num2, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m + j &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1[i] &gt; num2[j])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> m + j; k &gt;= i; k--)&#123; <span class="comment">// 第i+1个元素到第m+j个元素依次后移</span></span><br><span class="line">                <span class="keyword">if</span>(k == i)&#123;</span><br><span class="line">                    num1[i] = num2[j]; <span class="comment">// 插入元素</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    num1[k] = num1[k - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n)&#123;  <span class="comment">// num2 还有剩</span></span><br><span class="line">        num1[i++] = num2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断两个二叉树是否相同"><a href="#判断两个二叉树是否相同" class="headerlink" title="判断两个二叉树是否相同"></a>判断两个二叉树是否相同</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250622221035975.png" alt="image-20250622221035975"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">problem</span><span class="params">(TreeNode1 p, TreeNode1 q)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode1 p, TreeNode1 q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="comment">// 两棵树同时为 null 则相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) <span class="comment">// 其中一棵树为 null 则不同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p.val != q.val) <span class="comment">// 根节点不同 则不同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); <span class="comment">// 左子树 右子树都相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode easy</summary>
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Linux备份数据到本地</title>
    <link href="https://southernfish.github.io/2025/06/21/linux/linux-database-backup/"/>
    <id>https://southernfish.github.io/2025/06/21/linux/linux-database-backup/</id>
    <published>2025-06-21T11:23:36.000Z</published>
    <updated>2025-06-23T13:16:46.575Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单记录了将Linux中数据库数据备份到本地是实现流程。</p><h2 id="安装下载命令"><a href="#安装下载命令" class="headerlink" title="安装下载命令"></a>安装下载命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装下载命令</span><br><span class="line">sudo yum install lrzsz</span><br><span class="line">sz filename  下载</span><br><span class="line">rz filename  上传</span><br></pre></td></tr></table></figure><h2 id="登录到MySQL"><a href="#登录到MySQL" class="headerlink" title="登录到MySQL"></a>登录到MySQL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h2 id="查看所有用户及权限"><a href="#查看所有用户及权限" class="headerlink" title="查看所有用户及权限"></a>查看所有用户及权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT User, Host FROM mysql.user;</span><br></pre></td></tr></table></figure><h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line">USE your_database_name;</span><br><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><h2 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p mysql &gt; mysql_dump.sql</span><br><span class="line">mysqldump -u username -p mydatabase &gt; mydatabase_dump.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中：</span></span><br><span class="line"><span class="comment"># username 是你的MySQL用户名。</span></span><br><span class="line"><span class="comment"># -p 选项会提示你输入密码。</span></span><br><span class="line"><span class="comment"># mydatabase 是要导出的数据库名称。</span></span><br><span class="line"><span class="comment"># mydatabase_dump.sql 是导出的文件名。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux备份数据到本地</summary>
    
    
    
    <category term="Linux" scheme="https://southernfish.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://southernfish.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker命令</title>
    <link href="https://southernfish.github.io/2025/06/21/docker/docker-commands/"/>
    <id>https://southernfish.github.io/2025/06/21/docker/docker-commands/</id>
    <published>2025-06-21T08:20:36.000Z</published>
    <updated>2025-06-23T13:16:46.572Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一个用于创建、部署和管理容器的开源平台。在使用Docker时，有效地管理和监控容器是非常重要的，其中查看和解析Docker命令(command)是基本且关键的一步。本文将介绍一些关于Docker的命令。</p><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="Docker命令的格式"><a href="#Docker命令的格式" class="headerlink" title="Docker命令的格式"></a>Docker命令的格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker &lt;<span class="built_in">command</span>&gt;[options] [arguments]</span><br></pre></td></tr></table></figure><h2 id="Docker基础命令"><a href="#Docker基础命令" class="headerlink" title="Docker基础命令"></a>Docker基础命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker version           <span class="comment">#显示版本信息</span></span><br><span class="line">docker info              <span class="comment">#显示docker系统信息，包括容器、镜像</span></span><br><span class="line">docker stats             <span class="comment">#cpu/内存使用情况</span></span><br><span class="line">docker  [<span class="built_in">command</span>] --<span class="built_in">help</span>       <span class="comment">#帮助命令</span></span><br></pre></td></tr></table></figure><hr><h1 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h1><h2 id="查看本地镜像-images"><a href="#查看本地镜像-images" class="headerlink" title="查看本地镜像 images"></a>查看本地镜像 images</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">    -a, --all             <span class="comment"># 列出所有的镜像</span></span><br><span class="line">    -q, --quiet           <span class="comment"># 只显示的镜像的id</span></span><br><span class="line"><span class="comment"># 举例说明</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID           CREATED        SIZE</span><br><span class="line">centos              7         8652b9f0cb4c   2 months ago   204MB</span><br><span class="line"><span class="comment"># 解释</span></span><br><span class="line">    REPOSITORY  镜像仓库源</span><br><span class="line">    TAG         标签（版本）</span><br><span class="line">    IMAGE ID    镜像ID</span><br><span class="line">    CREATED     创建时间</span><br><span class="line">    SIZE        大小</span><br></pre></td></tr></table></figure><h2 id="搜索镜像-search"><a href="#搜索镜像-search" class="headerlink" title="搜索镜像 search"></a>搜索镜像 search</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker search [镜像名]</span><br><span class="line">    --filter=STARS=3000                            <span class="comment"># 列出收藏数不小于指定值的镜像</span></span><br><span class="line">docker search centos                            <span class="comment"># 搜索centos镜像</span></span><br><span class="line">docker search --filter=STARS=3000 centos        <span class="comment"># 搜索收藏大于3000的centos镜像</span></span><br></pre></td></tr></table></figure><h2 id="下载镜像-pull"><a href="#下载镜像-pull" class="headerlink" title="下载镜像 pull"></a>下载镜像 pull</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull [镜像名]:[版本号]</span><br><span class="line">      -a, --all-tags                <span class="comment"># 下载所有镜像名的镜像</span></span><br><span class="line">docker pull nginx                    <span class="comment"># 下载nginx镜像，默认最新版</span></span><br><span class="line">docker pull nginx:1.14.0            <span class="comment"># 下载nginx镜像，版本为1.14.0</span></span><br><span class="line">docker pull -a nginx                <span class="comment"># 下载REPOSITORY为nginx的所有镜像</span></span><br></pre></td></tr></table></figure><h2 id="删除镜像-rmi"><a href="#删除镜像-rmi" class="headerlink" title="删除镜像 rmi"></a>删除镜像 rmi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">删除镜像 rmi</span><br><span class="line">docker rmi [镜像名或者镜像<span class="built_in">id</span>]</span><br><span class="line">    -f                                       <span class="comment"># 强制删除</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span>                        <span class="comment"># 删除指定的镜像</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span>    镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span>  <span class="comment"># 删除多个镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)         <span class="comment"># 删除全部的镜像</span></span><br></pre></td></tr></table></figure><h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [镜像名或者镜像<span class="built_in">id</span>]                  <span class="comment"># 将镜像推送至远程仓库</span></span><br></pre></td></tr></table></figure><hr><h1 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h1><h2 id="启动容器-rmi"><a href="#启动容器-rmi" class="headerlink" title="启动容器 rmi"></a>启动容器 rmi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">启动容器 run</span><br><span class="line">docker run [镜像名]</span><br><span class="line">-d                                            <span class="comment"># 后台运行容器，并返回容器ID</span></span><br><span class="line">-i                                            <span class="comment"># 以交互模式运行容器，通常与 -t 同时使用；</span></span><br><span class="line">-P                                            <span class="comment"># 随机端口映射，容器内部端口随机映射到主机的端口</span></span><br><span class="line">-p                                            <span class="comment"># 指定端口映射，格式为：主机(宿主)端口:容器端口</span></span><br><span class="line">    -p ip:主机端口:容器端口</span><br><span class="line">    -p 主机端口:容器端口</span><br><span class="line">    -p 容器端口</span><br><span class="line">-t                                            <span class="comment"># 为容器重新分配一个伪输入终端，通常与 -i 同时使用（-it    交互模式运行）</span></span><br><span class="line">--name=<span class="string">&quot;nginx-lb&quot;</span>                            <span class="comment"># 为容器指定一个名称</span></span><br><span class="line">--dns 8.8.8.8                                <span class="comment"># 指定容器使用的DNS服务器，默认和宿主一致</span></span><br><span class="line">--dns-search example.com                    <span class="comment"># 指定容器DNS搜索域名，默认和宿主一致</span></span><br><span class="line">-h <span class="string">&quot;hostname&quot;</span>                                <span class="comment"># 指定容器的hostname</span></span><br><span class="line">-e username=<span class="string">&quot;ritchie&quot;</span>                        <span class="comment"># 设置环境变量</span></span><br><span class="line">--env-file=[]                                <span class="comment"># 从指定文件读入环境变量；</span></span><br><span class="line">--cpuset=<span class="string">&quot;0-2&quot;</span> or --cpuset=<span class="string">&quot;0,1,2&quot;</span>            <span class="comment"># 绑定容器到指定CPU运行；</span></span><br><span class="line">-m                                             <span class="comment"># 设置容器使用内存最大值；</span></span><br><span class="line">--net=<span class="string">&quot;bridge&quot;</span>                                 <span class="comment"># 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</span></span><br><span class="line">--<span class="built_in">link</span>=[]                                    <span class="comment"># 添加链接到另一个容器</span></span><br><span class="line">--expose=[]                                 <span class="comment"># 开放一个端口或一组端口；</span></span><br><span class="line">--volume , -v                                 <span class="comment"># 绑定一个卷</span></span><br><span class="line">docker run -it centos /bin/bash               <span class="comment"># 启动并进入容器</span></span><br><span class="line">docker run -it -v 主机目录：容器内目录           <span class="comment"># 挂载目录</span></span><br></pre></td></tr></table></figure><h2 id="查看容器信息-ps"><a href="#查看容器信息-ps" class="headerlink" title="查看容器信息 ps"></a>查看容器信息 ps</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps [CONTAINER ID or CONTAINER NAME]</span><br><span class="line">-a                        <span class="comment"># 列出当前正在运行的容器+历史运行过的容器</span></span><br><span class="line">-n=?                    <span class="comment"># 显示最近创建的容器</span></span><br><span class="line">-q                        <span class="comment"># 只显示容器的ID</span></span><br><span class="line">docker ps                <span class="comment"># 显示正在运行的容器</span></span><br><span class="line">docker ps -n=3          <span class="comment"># 显示最近三个创建的容器</span></span><br></pre></td></tr></table></figure><h2 id="退出容器-exit"><a href="#退出容器-exit" class="headerlink" title="退出容器 exit"></a>退出容器 exit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">退出容器 <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span>            <span class="comment"># 直接容器停止并退出</span></span><br><span class="line">Ctrl + P + Q    <span class="comment"># 容器不停止退出</span></span><br></pre></td></tr></table></figure><h2 id="删除容器-rm"><a href="#删除容器-rm" class="headerlink" title="删除容器 rm"></a>删除容器 rm</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> 容器<span class="built_in">id</span>                          <span class="comment"># 删除指定容器，不能删除正在运行的容器   </span></span><br><span class="line">docker <span class="built_in">rm</span> --f 容器<span class="built_in">id</span>                     <span class="comment"># 删除正在运行的容器    </span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)            <span class="comment"># 删除全部的容器</span></span><br><span class="line">docker ps -q -a|xargs docker <span class="built_in">rm</span>         <span class="comment"># 删除全部的容器</span></span><br></pre></td></tr></table></figure><h2 id="启动和停止容器的操作"><a href="#启动和停止容器的操作" class="headerlink" title="启动和停止容器的操作"></a>启动和停止容器的操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动和停止容器的操作</span><br><span class="line">docker start 容器<span class="built_in">id</span>        <span class="comment"># 启动容器</span></span><br><span class="line">docker restart 容器<span class="built_in">id</span>      <span class="comment"># 重启容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>         <span class="comment"># 停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span>         <span class="comment"># 强制停止当前的容器</span></span><br></pre></td></tr></table></figure><h2 id="查看容器日志-logs"><a href="#查看容器日志-logs" class="headerlink" title="查看容器日志 logs"></a>查看容器日志 logs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --<span class="built_in">tail</span> 10 8e633673e3c2     <span class="comment"># 查看容器id为8e633673e3c2的容器，最新10条日志</span></span><br><span class="line">    -f                 <span class="comment"># 跟踪日志输出</span></span><br><span class="line">    --since         <span class="comment"># 显示某个开始时间的所有日志</span></span><br><span class="line">    -t                 <span class="comment"># 显示时间戳</span></span><br><span class="line">    --<span class="built_in">tail</span>             <span class="comment"># 仅列出最新N条容器日志</span></span><br><span class="line">docker logs -tf --<span class="built_in">tail</span> 10 8e633673e3c2</span><br></pre></td></tr></table></figure><h2 id="查看容器中的进程信息-top"><a href="#查看容器中的进程信息-top" class="headerlink" title="查看容器中的进程信息 top"></a>查看容器中的进程信息 top</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [容器<span class="built_in">id</span>]        <span class="comment"># 显示容器的进程信息</span></span><br></pre></td></tr></table></figure><h2 id="查看镜像的元数据-inspect"><a href="#查看镜像的元数据-inspect" class="headerlink" title="查看镜像的元数据 inspect"></a>查看镜像的元数据 inspect</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [容器<span class="built_in">id</span>]</span><br><span class="line">    -f             <span class="comment"># 指定返回值的模板文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器ip</span></span><br><span class="line">[root@layman ~]<span class="comment"># docker inspect -f  &#x27;&#123;&#123;.NetworkSettings.Networks.redis.IPAMConfig.IPv4Address&#125;&#125;&#x27; 0233</span></span><br><span class="line">172.31.38.16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器环境变量</span></span><br><span class="line">[root@layman ~]<span class="comment"># docker inspect -f &#x27;&#123;&#123;.Config.Env&#125;&#125;&#x27; 0233</span></span><br><span class="line">[PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin REDIS_VERSION=5.0.9 REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-5.0.9.tar.gz REDIS_DOWNLOAD_SHA=53d0ae164cd33</span><br><span class="line">536c3d4b720ae9a128ea6166ebf04ff1add3b85f1242090cb85]</span><br></pre></td></tr></table></figure><h2 id="进入容器-exec-attach"><a href="#进入容器-exec-attach" class="headerlink" title="进入容器 exec attach"></a>进入容器 exec attach</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/bash        <span class="comment"># 进入容器后开启一个新的终端，可以在里面操作（常用）</span></span><br><span class="line">docker attach 容器<span class="built_in">id</span>                    <span class="comment"># 进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure><hr><h1 id="其他相关命令"><a href="#其他相关命令" class="headerlink" title="其他相关命令"></a>其他相关命令</h1><h2 id="docker-run-与-docker-start区别"><a href="#docker-run-与-docker-start区别" class="headerlink" title="docker run 与 docker start区别"></a>docker run 与 docker start区别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run 只在第一次运行时使用，将镜像放到容器中，以后再次启动这个容器时，只需要使用命令docker start 即可；</span><br><span class="line">docker run相当于执行两步操作：将镜像放入容器（docker create）,然后将容器启动，变成运行时容器（docker start）；</span><br><span class="line">docker start的作用是，重新启动已存在的镜像。</span><br></pre></td></tr></table></figure><h2 id="Docker-run的基本流程"><a href="#Docker-run的基本流程" class="headerlink" title="Docker run的基本流程"></a>Docker run的基本流程</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621155307829.png" alt="image-20250621155307829"></p><h2 id="挂载卷-v"><a href="#挂载卷-v" class="headerlink" title="挂载卷 -v"></a>挂载卷 -v</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span>                      <span class="comment"># 查看所有的volume的情况</span></span><br><span class="line">-v 容器内路径                           <span class="comment"># 匿名挂载</span></span><br><span class="line">-v 卷名：容器内路径                       <span class="comment"># 具名挂载</span></span><br><span class="line">-v /宿主机路径：容器内路径               <span class="comment"># 指定路径挂载</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx     <span class="comment"># 只读权限</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx     <span class="comment"># 可读可写</span></span><br><span class="line"><span class="comment"># 没有指定目录的情况下都是在“/var/lib/docker/volumes/xxxx/_data&quot;下</span></span><br><span class="line"></span><br><span class="line">构建 build</span><br><span class="line">docker build -f /home/docker-test-volume/dockerfile1 -t layman/dockerfile .</span><br><span class="line">-f     <span class="comment"># 指定要使用的Dockerfile路径</span></span><br><span class="line">-t     <span class="comment"># 镜像的名字及标签</span></span><br><span class="line"></span><br><span class="line">查看docker网络 network</span><br><span class="line"><span class="comment"># 查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span>                            <span class="comment"># 查看所有容器的网络状态</span></span><br><span class="line">docker network inspect [NETWORK ID]        <span class="comment"># 查看一个详细信息</span></span><br><span class="line">docker network <span class="built_in">rm</span> [NETWORK ID]            <span class="comment"># 可以移除一个网络</span></span><br><span class="line"><span class="comment"># 创建网络</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">--driver bridge                自定义网络模式，使用桥接</span><br><span class="line">--subnet 192.168.0.0/16        设置子网地址</span><br><span class="line">--gateway 192.168.0.1        设置出口网关</span><br><span class="line">mynet                        自己定义的一个网络名字</span><br><span class="line"><span class="comment"># 查看网络详细信息</span></span><br><span class="line">docker network inspect mynet</span><br><span class="line"></span><br><span class="line">加入网络 connect</span><br><span class="line">docker network connect mynet tomcat01</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建-build"><a href="#构建-build" class="headerlink" title="构建 build"></a>构建 build</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /home/docker-test-volume/dockerfile1 -t layman/dockerfile .</span><br><span class="line">-f     <span class="comment"># 指定要使用的Dockerfile路径</span></span><br><span class="line">-t     <span class="comment"># 镜像的名字及标签</span></span><br></pre></td></tr></table></figure><h2 id="查看docker网络-network"><a href="#查看docker网络-network" class="headerlink" title="查看docker网络 network"></a>查看docker网络 network</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span>                            <span class="comment"># 查看所有容器的网络状态</span></span><br><span class="line">docker network inspect [NETWORK ID]        <span class="comment"># 查看一个详细信息</span></span><br><span class="line">docker network <span class="built_in">rm</span> [NETWORK ID]            <span class="comment"># 可以移除一个网络</span></span><br><span class="line"><span class="comment"># 创建网络</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">--driver bridge                自定义网络模式，使用桥接</span><br><span class="line">--subnet 192.168.0.0/16        设置子网地址</span><br><span class="line">--gateway 192.168.0.1        设置出口网关</span><br><span class="line">mynet                        自己定义的一个网络名字</span><br><span class="line"><span class="comment"># 查看网络详细信息</span></span><br><span class="line">docker network inspect mynet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入网络 connect</span></span><br><span class="line">docker network connect mynet tomcat01</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Docker</summary>
    
    
    
    <category term="Containerization Platform" scheme="https://southernfish.github.io/categories/Containerization-Platform/"/>
    
    
    <category term="Docker" scheme="https://southernfish.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://southernfish.github.io/2025/06/21/docker/docker/"/>
    <id>https://southernfish.github.io/2025/06/21/docker/docker/</id>
    <published>2025-06-21T06:15:36.000Z</published>
    <updated>2025-06-23T13:16:46.572Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一组平台即服务（PaaS）的产品。它基于操作系统层级的虚拟化技术，将软件与其依赖项打包为容器。托管容器的软件称为Docker引擎。Docker能够帮助开发者在轻量级容器中自动部署应用程序，并使得不同容器中的应用程序彼此隔离，高效工作。</p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="参考文档链接"><a href="#参考文档链接" class="headerlink" title="参考文档链接"></a>参考文档链接</h2><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a>   </p><p>仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p><code>Docker</code> 是基于Go语言开发的开源项目，是开源的容器化平台，旨在简化应用程序的开发、部署和运行过程。它提供了一种轻量级、可移植和自包含的容器化环境，使开发人员能够在不同的计算机上以一致的方式构建、打包和分发应用程序。<br><strong>核心概念：</strong></p><ul><li><strong>容器（<code>Container</code>）：</strong>容器是 Docker 的<strong>基本部署单元</strong>。它是一个轻量级的、独立的运行时环境，包含应用程序及其相关依赖。容器利用 Linux 内核的命名空间和控制组技术，实现了隔离性和资源管理，使得应用程序在不同的容器中运行不会相互影响。</li><li><strong>镜像（<code>Image</code>）：</strong>镜像是用于<strong>创建容器的模板</strong>。它包含了一个完整的文件系统，其中包括应用程序运行所需的所有文件、依赖和配置信息。镜像是不可变的，通过 Docker 镜像可以创建多个相同的容器实例。</li><li><strong>镜像仓库（<code>Image Registry</code>）：</strong>镜像仓库是用于<strong>存储和分发 Docker 镜像的地方</strong>。最常用的公共镜像仓库是 <code>Docker Hub</code>，上面有大量的官方和社区共享的镜像。也可以搭建私有的镜像仓库，用于存放自己的镜像。</li><li><strong><code>Dockerfile</code>：</strong>Dockerfile 是一种<strong>文本文件</strong>，用于<strong>定义 Docker 镜像的构建过程</strong>。它包含了一系列的指令，用于<strong>指定基础镜像、安装软件、拷贝文件、配置环境等</strong>。通过 Dockerfile，可以自动化地构建镜像，确保镜像的一致性和可重复性。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621152126465.png" alt="image-20250621152126465"></p><p><strong>Docker 的优势</strong>：<code>轻量性、可移植性和灵活性</code>。通过使用 Docker，开发人员可以更轻松地创建一个可靠的开发环境、快速部署应用程序、实现弹性扩展和服务编排等。同时，它也提供了<code>生态系统丰富的工具和服务</code>，例如容器编排工具 <code>Docker Compose</code> 和容器编排平台 <code>Kubernetes</code>，使得容器化应用的管理更加便捷和高效。</p><p><strong>Linux容器技术：</strong></p><ul><li>Docker是在Linuk容器(<code>Linux Containers</code>)技术的基础上发展起来的。</li><li>LUX把单个操作系统的资源划分到多个孤立的组里，在孤立的组里平衡有冲突的资源使用需求。与虚拟机相比，这种通过划分组来平衡资源冲突的方式代价更小，它不需要指令级别模拟也不需要即使编译。</li><li><strong>容器直接在本地CPU上运行</strong>。</li></ul><h3 id="为什么要使用Docker"><a href="#为什么要使用Docker" class="headerlink" title="为什么要使用Docker"></a>为什么要使用Docker</h3><ul><li><strong>更快的交付和部署。</strong>开发人员使用镜像构建标准开发环境，运维和测试人员使用镜像来获得和开发人员相同的运行环境。开发环境和测试运维环境无缝对接，节约开发、测试、部署时间。</li><li><strong>更高效的资源利用。</strong>相较于虚拟机Docker不需要额外的<code>Hypervisor</code>支持，Docker是<strong>内核级别的虚拟化</strong>，实现更高的性能。</li><li><strong>更简单的更新管理。</strong>使用<code>Dockerfile</code>，通过简单的修改就可以代替大量的更新操作。</li></ul><h2 id="Docker与虚拟化"><a href="#Docker与虚拟化" class="headerlink" title="Docker与虚拟化"></a>Docker与虚拟化</h2><p><strong>虚拟化：</strong>虚拟化是对计算机资源的抽象，是为了更好的管理计算机资源。让同时运行在一个计算机上的多个进程以为自己能够独占当前操作系统资源。<br><strong>有三种类型的虚拟化：</strong>仿真、半虚拟化、基于容器的虚拟化<br><strong>Docker虚拟化与虚拟机比较</strong></p><ul><li><strong>Docker不是虚拟化方法</strong>。它依赖于实际实现基于容器的虚拟化或操作系统级虚拟化的其他工具。</li><li><strong>Docker是操作系统级的虚拟化</strong>，内核通过创建多个虚拟操作系统实例来隔离进程。虚拟机是硬件辅助虚拟化，虚拟的是整个硬件。</li><li>虚拟机需要模拟一个独立的<code>OS Kernel</code>而Docker不需要，与虚拟机映像相比，容器状态(<code>Docker或LXC映像</code>)的<strong>大小很小</strong>，因此容器映像很容易分发</li><li>虚拟机需要一个虚拟机管理程序如<code>VMware</code>，而Docker只需要一个Docker引擎，<strong>后者的开销更小</strong>。</li><li><strong>Docker更快秒级，虚拟机分钟级别</strong></li><li>Docker<strong>对系统资源需求更少</strong>。<ul><li>主机上的所有容器共享主机的调度程序，从而节省了额外资源的需求。容器中的资源管理是通过cgroup实现的。Cgroups不允许容器消耗比分配给它们更多的资源。</li></ul></li><li>Docker通过类似<code>Git</code>理念来方便用户获取、分发更新镜像</li><li>Docker通过<code>dockerfile</code>实现灵活的创建、部署机制</li></ul><p><strong>虚拟机和Docker本质的区别</strong>在于虚拟化的方式不同，虚拟机是一种硬件级别的虚拟化，通过软件去模拟硬件系统，并且虚拟机里需要虚拟OS Kernel。Docker是一种容器，是一种隔离机制，是软件级别的模拟。</p><p>虚拟机技术：资源占用十分多、冗余步骤多、启动慢；容器技术：不是模拟一个完整的OS</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151302533.png" alt="image-20250621151302533"></p><h2 id="Docker为什么比VM快"><a href="#Docker为什么比VM快" class="headerlink" title="Docker为什么比VM快"></a>Docker为什么比VM快</h2><p>1、Docker比VM有更少的抽象层<br>2、Docker利用的是宿主机的内核，VM需要的是Guest OS<br>故新建一个容器的时候，docker无需像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而docker利用宿主机的操作系统，省略了这个复杂的过程，秒级！</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151312130.png" alt="image-20250621151312130"></p><table><thead><tr><th></th><th>Docker容器</th><th>LXC</th><th>VM</th></tr></thead><tbody><tr><td>虚拟化类型</td><td>OS虚拟化</td><td>OS虚拟化</td><td>硬件虚拟化</td></tr><tr><td>性能</td><td>=物理机性能</td><td>=物理机性能</td><td>5%-20%损耗</td></tr><tr><td>隔离性</td><td>NS隔离</td><td>NS隔离</td><td>强</td></tr><tr><td>QoS</td><td>Cgroup 弱</td><td>Cgroup 弱</td><td>强</td></tr><tr><td>安全性</td><td>中</td><td>差</td><td>强</td></tr><tr><td>GuestOS</td><td>只支持Linux&lt;</td><td>只支持Linux&lt;</td><td>全部</td></tr><tr><td>可迁移性</td><td>强</td><td>弱</td><td>强</td></tr></tbody></table><h2 id="docker是怎么工作的"><a href="#docker是怎么工作的" class="headerlink" title="docker是怎么工作的?"></a>docker是怎么工作的?</h2><p>一个完整的Docker由<code>DockerClient</code>客户端、<code>Docker Daemon</code>守护进程、<code>Docker Image</code>镜像、<code>DockerContainer</code>容器四部分组成<br>Docker是一个<code>Client-Server</code>结构的系统，，<strong>docker client负责处理用户输入的各种命令</strong>，比如docker build、docker run，真正工作的其实是server，也就是docker daemon，值得注意的是，<strong>docker client和docker daemon可以运行在同一台机器上</strong>。<br>Docker守护进程运行在主机上，然后通过<code>Socket</code>连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151356904.png" alt="image-20250621151356904"></p><h2 id="基本的Docker使用工作流程是怎样的？"><a href="#基本的Docker使用工作流程是怎样的？" class="headerlink" title="基本的Docker使用工作流程是怎样的？"></a>基本的Docker使用工作流程是怎样的？</h2><ol><li><strong>构建镜像：</strong>Dockerfile是镜像的源代码；用其创建镜像</li><li><strong>推送镜像到注册表：</strong>将镜像上传到 <code>Docker Hub</code> 或<code>私有注册表</code>中。</li><li><strong>拉取镜像：</strong>通过 <code>docker pull</code> 从注册表中拉取镜像。</li><li><strong>运行容器：</strong>使用镜像创建并启动容器。</li><li><strong>管理容器：</strong>使用 Docker 客户端命令管理正在运行的容器(例如查看日志、停止容器、查看资源使用情况等)。</li><li><strong>网络与存储：</strong>容器之间通过 Docker 网络连接，数据通过 <code>Docker 卷</code>或<code>绑定挂载</code>进行持久化。</li></ol><h2 id="什么是docker-compose？"><a href="#什么是docker-compose？" class="headerlink" title="什么是docker-compose？"></a>什么是docker-compose？</h2><p><code>docker-compose</code>就是一个编排同时管理多个容器的工具，与它配对使用的是一个<code>docker-compose.yaml</code>文件，<code>docker-compose</code>命令必须在一个包含<code>docker-compose.yaml</code>文件目录下才能使用。且当下docker-compose命令<strong>只能管理当前目录docker-compose文件中所涉及的容器，安装在机器上的其他容器无法干扰</strong>。</p><p>docker-compose的大部分命令基本和docker的命令重合，他们唯一的区别是docker命令能管理机器上所有的容器和镜像文件，而docker-compose只能管理当前docker-compose文件所涉及的容器。</p><h2 id="如何在生产中监控Docker？"><a href="#如何在生产中监控Docker？" class="headerlink" title="如何在生产中监控Docker？"></a>如何在生产中监控Docker？</h2><p>Docker提供<code>docker status</code>和<code>docker事件</code>等工具来监控生产中的Docker。我们可以使用这些命令获取重要统计数据的报告。<br><strong>Docker统计数据：</strong>当我们使用容器ID调用docker status时，我们获得容器的CPU、内存使用情况等。它类似于Linux中<code>top</code>命令。<br><strong>Docker事件：</strong> Docker事件是一个命令，用于查看Docker守护进程中整改再进行的活动流。一些常见的Docker事件是：<code>attach</code>、<code>commit</code>、<code>die</code>、<code>datach</code>、<code>rename</code>、<code>destroy</code>。</p><h2 id="Docker安全么？"><a href="#Docker安全么？" class="headerlink" title="Docker安全么？"></a>Docker安全么？</h2><p>Docker<strong>利用了Linux内核中很多安全特性来保证不同容器之间的隔离，并且通过签名机制来对镜像进行验证</strong>。<br>Docker虽然隔离性无法与虚拟机相比，但仍然具有极高的安全性。</p><h2 id="Docker如何在非Linux系统中运行容器"><a href="#Docker如何在非Linux系统中运行容器" class="headerlink" title="Docker如何在非Linux系统中运行容器"></a>Docker如何在非Linux系统中运行容器</h2><p>通过添加到Linux内核版本2.6.24的<strong>名称空间功能</strong>，可以实现容器的概念。容器将其<code>ID</code><strong>添加到每个进程</strong>，并向每个系统调用添加新的访问控制检查。它由<code>clone</code>系统调用访问，该调用允许创建先前全局命名空间的单独实例。</p><hr><h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><h2 id="什么是Docker镜像"><a href="#什么是Docker镜像" class="headerlink" title="什么是Docker镜像"></a>什么是Docker镜像</h2><p>Docker镜像是Docker容器的源代码。换句话说，Docker镜像用于创建容器。使用<code>build</code>创建镜像，用<code>run</code>启动时它们将生成容器。<br>镜像存储在Docker注册表（<code>docker hub</code>）中，<code>registry.hub.docker.com</code>因为它们可能变得非常大，镜像被设计为由其他镜像层组成，允许在通过网络传输镜像时发送最少量的数据。</p><h2 id="Docker镜像联合文件系统"><a href="#Docker镜像联合文件系统" class="headerlink" title="Docker镜像联合文件系统"></a>Docker镜像联合文件系统</h2><p><strong><code>UnionFS</code>（联合文件系统）：</strong>是一种分成，轻量级并且高性能的文件系统，支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统的Docker镜像可以<strong>通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像</strong>。<br><strong>特性：</strong><code>一次同时加载多个文件系统</code>，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统进行叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h2 id="镜像与-UnionFS区别"><a href="#镜像与-UnionFS区别" class="headerlink" title="镜像与 UnionFS区别"></a>镜像与 UnionFS区别</h2><p>Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。<br><code>Docker 镜像</code>其实<strong>本质就是一个压缩包</strong>，我们可以使用命令将一个 Docker 镜像中的文件导出，你可以看到这个镜像中的目录结构与 Linux 操作系统的根目录中的内容并没有太多的区别，可以说 Docker 镜像就是一个文件。</p><h2 id="什么是Docker-Hub"><a href="#什么是Docker-Hub" class="headerlink" title="什么是Docker Hub"></a>什么是Docker Hub</h2><p><code>Docker Hub</code>是一个基于云的在线存储库，Docker进行可以由其他用户发布和使用。<br><code>Docker hub</code>是一个基于云的注册表服务，允许链接到代码存储库，构建镜像并测试，存储手动推送的镜像以及指向Docker云的链接，以便将镜像部署到主机。它为整个开发流程中的容器镜像发现，分发和变更管理，用户和团队协作以及工作流自动化提供了集中资源。</p><hr><h1 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h1><h2 id="Docker容器可扩展到多远？"><a href="#Docker容器可扩展到多远？" class="headerlink" title="Docker容器可扩展到多远？"></a>Docker容器可扩展到多远？</h2><p>诸如<code>Foogle</code>和<code>Twitter</code>之类的大型Web部署以及诸如<code>Heroku</code>和<code>dotCloud</code>之类的平台提供商都基于容器技术运行，并行运行的容器数以十万甚至至数八百计。</p><h2 id="Docker容器退出时是否丢失数据"><a href="#Docker容器退出时是否丢失数据" class="headerlink" title="Docker容器退出时是否丢失数据"></a>Docker容器退出时是否丢失数据</h2><p>不、当Docker<strong>容器退出时，不会丢失数据</strong>。<br>应用程序写入磁盘的所有数据都会保留在其容器中<strong>直到明确删除该容器为止</strong>。即使在容器停止后，该容器的文件系统仍然存在。</p><h2 id="Docker容器有几种状态？"><a href="#Docker容器有几种状态？" class="headerlink" title="Docker容器有几种状态？"></a>Docker容器有几种状态？</h2><p>有四种状态：运行、已暂停、重新启动、已退出。</p><h2 id="容器内部机制"><a href="#容器内部机制" class="headerlink" title="容器内部机制"></a>容器内部机制</h2><p>每个容器都在自己的命名空间中运行，但使用与所有其他容器完全相同的内核。发生隔离是因为内核知道分配给进程的命名空间，并且在API调用期间确保进程只能访问其自己的命名空间中的资源。</p><h2 id="docker容器之间怎么隔离"><a href="#docker容器之间怎么隔离" class="headerlink" title="docker容器之间怎么隔离?"></a>docker容器之间怎么隔离?</h2><p>Linux中的<code>PID、IPC、网络</code>等资源是全局的，而<code>NameSpace机制</code>是一种资源隔离方案，在<strong>该机制下这些资源就不再是全局的</strong>了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰。<br>NameSpace技术可实现资源隔离，但进程仍可不受控的访问（CPU、内存、磁盘、网络等）系统资源，为了控制容器中进程对资源的访问，Docker采用<code>control groups</code>技术(也就是<code>cgroup</code>)<strong>控制容器中进程对系统资源的消耗</strong>，如限制某容器使用内存的上限、可在哪些CPU上运行等。这两项技术使容器像真正独立的操作系统。</p><h2 id="容器与主机之间的数据拷贝命令-docker-cp"><a href="#容器与主机之间的数据拷贝命令-docker-cp" class="headerlink" title="容器与主机之间的数据拷贝命令 docker cp"></a>容器与主机之间的数据拷贝命令 docker cp</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> /www 96f7f14e99ab:/www/     <span class="comment"># 主机到容器</span></span><br><span class="line">docker <span class="built_in">cp</span> 96f7f14e99ab:/www /tmp    <span class="comment"># 容器到主机</span></span><br></pre></td></tr></table></figure><h2 id="进入容器的方法"><a href="#进入容器的方法" class="headerlink" title="进入容器的方法"></a>进入容器的方法</h2><ol><li><code>docker attach</code>，用于附加到正在运行的容器的标准输入、输出和错误流。<strong>不会启动新的进程</strong>。</li><li><code>docker exec</code>，如<code>docker exec -it 容器id /bin/bash</code>，此命令将以<strong>交互模式（-i）和终端（-t）的方式进入指定容器，并开启起一个新的终端</strong>。</li><li>通过 <code>docker run</code> 命令来进入容器。这种方式<strong>适用于需要在容器内执行命令而不是交互式操作的情况</strong>，使用 docker run 命令指定容器镜像和执行的命令，类似于直接进入容器</li></ol><h2 id="无状态或有状态应用程序谁更适合Docker容器"><a href="#无状态或有状态应用程序谁更适合Docker容器" class="headerlink" title="无状态或有状态应用程序谁更适合Docker容器"></a>无状态或有状态应用程序谁更适合Docker容器</h2><p>最好为<code>Docker Container</code>创建<strong>无状态应用程序</strong>。我们可以从应用程序中创建一个容器，并<strong>从应用程序中取出可配置的状态参数</strong>。现在我们可以<strong>在生产环境和具有不同参数的QA环境中运行相同的容器</strong>。这有助于在不同场景中重用相同的镜像。另外，无状态应用程序比有状态应用程序<strong>更容易使用Docker容器进行扩展</strong>。</p><hr><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="Dockerfile中最常见的指令是什么"><a href="#Dockerfile中最常见的指令是什么" class="headerlink" title="Dockerfile中最常见的指令是什么"></a>Dockerfile中最常见的指令是什么</h2><ul><li><code>FROM</code>：指定基础镜像；</li><li><code>LABEL</code>：功能是为镜像指定标签；</li><li><code>RUN</code>：运行指定的命令；</li><li><code>CMD</code>：容器启动时要运行的命令。</li></ul><h2 id="Dockerfile中的命令COPY和ADD命令区别"><a href="#Dockerfile中的命令COPY和ADD命令区别" class="headerlink" title="Dockerfile中的命令COPY和ADD命令区别"></a>Dockerfile中的命令COPY和ADD命令区别</h2><p>一般而言，<code>ADD</code>和<code>COPY</code>在功能上类似，但是首选COPY。因为COPY比ADD更易懂。<strong>COPY仅支持将本地文件复制到容器中</strong>，而ADD具有一些功能（如仅限本地的tar提取和远程URL支持），这些功能并不是很明显。<br>因此，<strong>ADD最佳用途是将本地tar文件自动提取到镜像中</strong>，如<code>ADD rootfs.tar.xz /</code>。</p><h2 id="使用dockerfile构建apache容器服务"><a href="#使用dockerfile构建apache容器服务" class="headerlink" title="使用dockerfile构建apache容器服务"></a>使用dockerfile构建apache容器服务</h2><ol><li><p>基础镜像目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir apache</span></span><br><span class="line"><span class="comment"># cd apache</span></span><br></pre></td></tr></table></figure></li><li><p>编辑镜像dockerfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim Dockerfile</span></span><br><span class="line"> </span><br><span class="line">FROM centos:7 <span class="comment"># 基于的基础镜像</span></span><br><span class="line">MAINTAINER The porject &lt;cloud-ops@centos.org&gt; <span class="comment"># 维护镜像的用户信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作指令安装apache软件</span></span><br><span class="line">RUN yum -y update    <span class="comment">#更新yum</span></span><br><span class="line">RUN yum -y install httpd</span><br><span class="line"></span><br><span class="line">EXPOSE 80 <span class="comment"># 开启80端口</span></span><br><span class="line">ADD index.html /var/www/html/index.html <span class="comment"># 复制网站首页文件</span></span><br><span class="line">ADD run.sh /run.sh <span class="comment"># 将执行脚本复制到镜像中</span></span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /run.sh <span class="comment"># 启动容器时执行脚本</span></span><br><span class="line"></span><br><span class="line">CMD [<span class="string">&quot;/run.sh&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>编辑启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim run.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -rf /run/httpd/*</span><br><span class="line"><span class="built_in">exec</span> /usr/sbin/apachectl -D FOREGROUND</span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;web test&quot;</span> &gt; index.html</span><br></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker build -t httpd:centos . (注意别忘 了末尾有&quot;.&quot;，且.前面有空格)</span></span><br></pre></td></tr></table></figure></li><li><p>镜像容器启动运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -d -p 1216:80 httpd:centos</span></span><br></pre></td></tr></table></figure></li><li><p>测试验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl http://192.168.40.30:1216</span></span><br></pre></td></tr></table></figure></li></ol><p>参考链接：<a href="https://blog.csdn.net/ygq13572549874/article/details/136558153">Docker镜像及Dockerfile详解</a></p><h2 id="docker-构建一个服务的过程-node-js"><a href="#docker-构建一个服务的过程-node-js" class="headerlink" title="docker 构建一个服务的过程(node.js)"></a>docker 构建一个服务的过程(node.js)</h2><ol><li><p>编写应用代码。首先，你需要有一个应用代码。例如，一个简单的 Node.js 应用</p></li><li><p>创建 Dockerfile<br>在应用的根目录下创建一个名为 Dockerfile 的文件。Dockerfile 包含了一系列的指令，用于告诉 Docker 如何构建镜像。例如，对于 Node.js 应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方 Node.js 镜像作为基础镜像</span></span><br><span class="line">FROM node:14</span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /usr/src/app</span><br><span class="line"><span class="comment"># 复制 package.json 和 package-lock.json (如果有) 到工作目录</span></span><br><span class="line">COPY package*.json ./</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">RUN npm install</span><br><span class="line"><span class="comment"># 复制项目文件到工作目录</span></span><br><span class="line">COPY . .</span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">EXPOSE 3000</span><br><span class="line"><span class="comment"># 定义容器启动时执行的命令</span></span><br><span class="line">CMD [ <span class="string">&quot;node&quot;</span>, <span class="string">&quot;app.js&quot;</span> ]</span><br></pre></td></tr></table></figure></li><li><p>构建 Docker 镜像。打开终端或命令行工具，导航到包含 Dockerfile 的目录，然后运行以下命令来构建 Docker 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-nodejs-app .</span><br><span class="line"><span class="comment"># 这里，-t 参数用于标记你的镜像，my-nodejs-app 是你的镜像名称，. 表示 Dockerfile 所在的当前目录。</span></span><br></pre></td></tr></table></figure></li><li><p>运行 Docker 容器。构建完成后，你可以使用以下命令来运行你的 Docker 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:3000 my-nodejs-app</span><br><span class="line"><span class="comment"># 这里，-p 参数将容器的 3000 端口映射到主机的 4000 端口。现在，如果你的机器上的任何程序访问 localhost:4000，它们将会看到你的 Node.js 应用运行。</span></span><br></pre></td></tr></table></figure></li><li><p>检查运行状态（可选）。可以使用以下命令来查看正在运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p>停止并删除容器（可选）。当完成测试后，可以停止并删除容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;container_id&gt;  <span class="comment"># 使用 docker ps 获取 container_id</span></span><br><span class="line">docker <span class="built_in">rm</span> &lt;container_id&gt;    <span class="comment"># 使用 docker ps 获取 container_id 或 docker rm $(docker ps -aq) 来删除所有容器</span></span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="部署相关"><a href="#部署相关" class="headerlink" title="部署相关"></a>部署相关</h1><h2 id="CI-CD聚焦代码集成与交付的自动化流程（Jenkins）"><a href="#CI-CD聚焦代码集成与交付的自动化流程（Jenkins）" class="headerlink" title="CI/CD聚焦代码集成与交付的自动化流程（Jenkins）"></a>CI/CD聚焦代码集成与交付的自动化流程（Jenkins）</h2><p>CI/CD 是指持续集成(<code>Continuous Integration</code>)和持续部署(<code>Continuous Deployment</code>)或持续交付(<code>Continuous Delivery</code>)<br><strong>持续集成(Continuous Integration)</strong><br>持续集成是一种软件开发实践，团队成员频繁地将他们的工作集成到共享的代码仓库中。<strong>其主要特点包括</strong>:</p><ol><li><code>频繁提交代码</code>：开发人员可以每天多次提交代码，确保代码库始终保持最新状态。</li><li><code>自动化构建</code>：每次提交后，自动触发构建过程，包括编译、测试、静态分析等</li><li><code>快速反馈</code>：如果构建失败或测试不通过，能够快速地向开发人员提供反馈，以便及时修复问题。</li></ol><p><strong>持续部署(Continuous Deployment)</strong><br>持续部署是在持续集成的基础上，将通过所有测试的代码自动部署到生产环境中。其<strong>特点如下</strong>:</p><ol><li><code>自动化流程</code>：从代码提交到生产环境的部署完全自动化，无需人工干预。</li><li><code>高频率部署</code>：可以实现频繁的部署，使得新功能能够快速地提供给用户,</li><li><code>风险控制</code>：需要有强大的测试和监控体系来确保部署的稳定性和可靠性。</li></ol><p><strong>持续交付(continuous Delivery)</strong><br>持续交付与持续部署类似，但不一定自动部署到生产环境，而是随时可以部署。重点在于确保软件随时处于可发布状态。</p><p><strong>CI/CD 好处包括:</strong></p><ol><li><code>提高开发效率</code>：减少手动操作和等待时间，加快开发周期。</li><li><code>尽早发现问题</code>：通过频繁的集成和测试，问题能够在早期被发现和解决。</li><li><code>降低风险</code>：减少了大规模部署时可能出现的问题，提高了软件的质量和稳定性。</li><li><code>增强团队协作</code>：促进团队成员之间的沟通和协作，提高团队的整体效率，</li></ol><h2 id="DevOps？"><a href="#DevOps？" class="headerlink" title="DevOps？"></a>DevOps？</h2><p>DevOps是涵盖开发与运维全生命周期协作的文化与实践体系。<br>DevOps是一种文化与方法论，旨在打破开发与运维的壁垒，通过自动化工具链、协作流程和共享责任，加速软件全生命周期交付。<br>DevOps覆盖更广包括需求规划、基础设施管理、监控反馈等全流程，强调团队协作、文化变革及工具整合。更强调“人+流程+工具”的系统性优化。<br><strong>技术优势：</strong>更快地解决问题<br><strong>商业利益：</strong>有更多时间可以增加价值（而不是修复/维护）</p>]]></content>
    
    
    <summary type="html">Docker</summary>
    
    
    
    <category term="Containerization Platform" scheme="https://southernfish.github.io/categories/Containerization-Platform/"/>
    
    
    <category term="Docker" scheme="https://southernfish.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://southernfish.github.io/2025/06/21/front-end/front-end-websocket/"/>
    <id>https://southernfish.github.io/2025/06/21/front-end/front-end-websocket/</id>
    <published>2025-06-21T05:33:36.000Z</published>
    <updated>2025-06-23T13:16:46.573Z</updated>
    
    <content type="html"><![CDATA[<p><strong>WebSocket</strong>是一种在单个<a href="https://baike.baidu.com/item/TCP/0?fromModule=lemma_inlink">TCP</a>连接上进行<a href="https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5/0?fromModule=lemma_inlink">全双工</a>通信的协议。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><h2 id="WebSocket-的优势和适用场景是什么？"><a href="#WebSocket-的优势和适用场景是什么？" class="headerlink" title="WebSocket 的优势和适用场景是什么？"></a>WebSocket 的优势和适用场景是什么？</h2><ol><li><code>WebSocket</code> 提供了<strong>低延迟的实时通信能力</strong>，能够在服务器端有新数据时立即推送给客户端。</li><li><code>WebSocket</code> 支持<strong>客户端和服务器之间的双向通信</strong>，可以实现实时聊天、实时数据更新等场景</li><li><code>WebSocket</code> 使<strong>用长连接，相对于频繁的短连接请求，减少了网络开销</strong>。</li><li><code>WebSocket</code> 具备<strong>跨域通信</strong>的能力，可以跨域进行实时通信</li></ol><p><strong>适用场景：</strong>实时聊天应用、股票行情推送、实时协作编辑、多人游戏、实时数据监控等<strong>需要实时双向通信的场景</strong>。</p><h2 id="WebSocket-的连接建立过程是怎样的？"><a href="#WebSocket-的连接建立过程是怎样的？" class="headerlink" title="WebSocket 的连接建立过程是怎样的？"></a>WebSocket 的连接建立过程是怎样的？</h2><ol><li>客户端<strong>发送 <code>WebSocket</code> 握手请求</strong></li><li>服务器收到握手请求后，<strong>验证请求头的字段，并返回握手响应</strong></li><li>客户端收到握手响应后，<strong>验证响应头的字段，并生成一个 <code>Sec-WebSocket-Accept</code> 值进行验证</strong></li><li>验证通过后，<code>WebSocket</code> <strong>连接建立成功，客户端和服务器可以开始进行实时通信</strong></li></ol><h2 id="如何处理错误和关闭连接？"><a href="#如何处理错误和关闭连接？" class="headerlink" title="如何处理错误和关闭连接？"></a>如何处理错误和关闭连接？</h2><p>WebSocket 在<strong>出现错误时会触发 error 事件</strong>，可以通过<strong>设置 <code>onerror</code> 事件处理函数来处理错误。</strong>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket 错误:&#x27;</span>, error); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 WebSocket <strong>连接关闭时，会触发 close 事件</strong>，可以通过<strong>设置 <code>onclose</code> 事件处理函数</strong>来执行一些清理操作或重新连接等操作，可以通过<strong>调用 <code>close()</code> 方法来显式地关闭</strong> WebSocket 连接</p><h2 id="实际应用中，如何处理连接状态的变化和重连机制？"><a href="#实际应用中，如何处理连接状态的变化和重连机制？" class="headerlink" title="实际应用中，如何处理连接状态的变化和重连机制？"></a>实际应用中，如何处理连接状态的变化和重连机制？</h2><p>在 <code>onopen</code> 事件中，使用 <code>setInterval</code> 方法定时发送心跳数据包。如<strong>每 5000 毫秒发送一次心跳数据包</strong>，如下所示代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  heartcheck = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;HeartBeat&#x27;</span>); <span class="comment">// 发送心跳数据包</span></span><br><span class="line">  &#125;，<span class="number">5000</span>); <span class="comment">// 时间间隔，单位毫秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>onmessage</code>事件中，当接收到服务器返回的心跳响应或其他消息时，可以<strong>重置心跳定时器</strong>，以避免不必要的心跳发送。例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(heartcheck);<span class="comment">// 清除原来的心跳定时器</span></span><br><span class="line">  heartcheck=<span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;HeartBeat&#x27;</span>); <span class="comment">// 重新创建心跳定时器并发送心跳数据包</span></span><br><span class="line">  &#125;, <span class="number">5000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>onclose</code>和<code>onerror</code>事件中，需要<strong>清除心跳定时器</strong>，以避免在连接关闭后继续发送心跳数据包。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(heartcheck);<span class="comment">//清除心跳定时器</span></span><br><span class="line">&#125;;</span><br><span class="line">ws.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(heartcheck);<span class="comment">// 清除心跳定时器</span></span><br><span class="line">  <span class="comment">// 可以添加重连逻辑或其他错误处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">WebSocket</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="WebSocket" scheme="https://southernfish.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>WebPack</title>
    <link href="https://southernfish.github.io/2025/06/21/front-end/front-end-webpack/"/>
    <id>https://southernfish.github.io/2025/06/21/front-end/front-end-webpack/</id>
    <published>2025-06-21T04:55:36.000Z</published>
    <updated>2025-06-23T13:16:46.573Z</updated>
    
    <content type="html"><![CDATA[<p>webpack 是代码编译工具，有入口、出口、loader 和<a href="https://baike.baidu.com/item/%E6%8F%92%E4%BB%B6/369160?fromModule=lemma_inlink">插件</a>。webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 <em>bundle</em>。</p><h2 id="什么是-webpack"><a href="#什么是-webpack" class="headerlink" title="什么是 webpack ?"></a>什么是 webpack ?</h2><p><code>webpack</code> 是一个现代 JavaScript 应用程序的<strong>静态模块打包器</strong><br><code>webpack</code> 可以<strong>递归的打包项目中所有模块</strong>（递归：指定一个入口，分析模块的依赖，它会递归的查找所有相关的依赖）</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p><code>Entry</code>：配置入口文件。webpack 会找出有哪些模块是入库的依赖 ， 相关的依赖会被处理，输出到 bundles 的文件中<br><code>Output</code>：output 属性会告诉 webpack 它<strong>所创建的bundles 如何命名，默认值为 ./dist</strong><br><code>module</code>：模块。Webpack 里一切皆模块，一个模块对应一个文件。Webpack 从配置的 Entry 开始递归找出所有依赖的模块。<br><code>Chunk</code>：代码块。一个 chunk 由多个模块组合而成，用于代码的合并和分割。<br><code>loader</code>：模块转换器。用于将模块的原内容按照需要转成你想要的内容<br><strong>babel 和 webpack的区别：</strong></p><ul><li><code>babel</code>：JS新语法编译工具，只关心语法，不关心模块化</li><li><code>webpack</code>：打包构建工具，是多个 Loader plugin 的集合</li></ul><h2 id="webpack与grunt、gulp的不同？"><a href="#webpack与grunt、gulp的不同？" class="headerlink" title="webpack与grunt、gulp的不同？"></a>webpack与grunt、gulp的不同？</h2><p>Webpack 与 Gulp、Grunt 没有什么可比性。<br>Webpack 可以看作<strong>模块打包机</strong>，通过分析项目结构找到js模块及一些浏览器不能直接运行的语言（<code>scss typescript</code>）<br><strong><code>Grunt</code> 和 <code>Gulp</code> 的工作方式</strong>：在一个<strong>配置文件</strong>中，指明对某些文件进行类似编译，组合，压缩等<strong>任务的具体步骤，工具之后可以自动替你完成这些任务</strong>。<br><strong><code>Webpack</code> 的工作方式</strong>：把项目当做一个整体，通过一个<strong>给定主文件</strong>（如：index.js），Webpack 将这个文件<strong>开始找到你的项目的所有依赖文件，使用 <code>loaders</code> 处理它们，最后打包为一个（或多个）浏览器可识别的 <code>JavaScript</code> 文件</strong>。</p><h2 id="webpack有哪些优缺点"><a href="#webpack有哪些优缺点" class="headerlink" title="webpack有哪些优缺点"></a>webpack有哪些优缺点</h2><p><strong>优点：</strong></p><ul><li>可通过 <code>plugin</code> 扩展</li><li>使用场景不局限于 <code>web</code> 开发</li><li>良好的开发体验</li></ul><p><strong>缺点：</strong>只能用于采用模块化开发的项目</p><h2 id="webpack打包原理？"><a href="#webpack打包原理？" class="headerlink" title="webpack打包原理？"></a>webpack打包原理？</h2><p><strong>把所有依赖打包成一个 bundle.js 文件，通过代码分割成单元片段并按需加载</strong>。<br>Webpack 是一个模块打包器，grunt 和 gulp 是执行任务的，<br>webpack 递归的打包项目中所有模块，最终生成几个打包后的文件，与其他工具最大的不同在于它<strong>支持 code-splitting（代码分割），模块化（AMD，ESM，CommonJS）开发，全局的分析工具（分析整个项目引入的模块）</strong></p><h2 id="什么是模块热跟新-？-有什么优点？"><a href="#什么是模块热跟新-？-有什么优点？" class="headerlink" title="什么是模块热跟新 ？ 有什么优点？"></a>什么是模块热跟新 ？ 有什么优点？</h2><p><strong>模块热更新：</strong>是webpack的一个功能，可以使<strong>代码修改后不用刷新浏览器就可更新内容</strong>。 是高级版的自动刷新浏览器（将代码重新执行一遍而不是整体刷新浏览器）<br><strong>优点：</strong>只更新变更内容，以节省开发时间。<strong>调整样式更加快速</strong>，几乎相当于在浏览器中更改样式</p><h2 id="如何利用webpack来优化前端性能？"><a href="#如何利用webpack来优化前端性能？" class="headerlink" title="如何利用webpack来优化前端性能？"></a>如何利用webpack来优化前端性能？</h2><p><strong>代码压缩、按需加载、使用 <code>Dll</code> 进行分包</strong><br>正常情况下 <code>node_module</code> 会被打包成一个文件，使用 <code>dll</code> 技术，可<strong>将不常更新的框架和库进行单独打包，生成一个chunk</strong></p><h2 id="webpack-为什么启动速度慢"><a href="#webpack-为什么启动速度慢" class="headerlink" title="webpack 为什么启动速度慢"></a>webpack 为什么启动速度慢</h2><p>它是将所有模块构建完了，再去启动项目的</p><h2 id="如何提高webpack的构建速度？"><a href="#如何提高webpack的构建速度？" class="headerlink" title="如何提高webpack的构建速度？"></a>如何提高webpack的构建速度？</h2><ul><li>减少需要构建的文件或代码</li><li>多进程打包 <code>thread-loader</code>，将其放在费时的 <code>loader</code> 之前</li></ul>]]></content>
    
    
    <summary type="html">WebPack</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="WebPack" scheme="https://southernfish.github.io/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://southernfish.github.io/2025/06/21/front-end/front-end-javascript/"/>
    <id>https://southernfish.github.io/2025/06/21/front-end/front-end-javascript/</id>
    <published>2025-06-21T04:35:36.000Z</published>
    <updated>2025-06-23T13:16:46.573Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript是一种轻量级、解释型或者说即时编译型的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131?fromModule=lemma_inlink">编程语言</a>， [20]广泛应用于网页开发中，主要用于增强网页的<a href="https://baike.baidu.com/item/%E4%BA%A4%E4%BA%92%E6%80%A7/10758528?fromModule=lemma_inlink">交互性</a>和<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E6%80%A7/53339475?fromModule=lemma_inlink">动态性</a>。作为Web开发的核心技术之一，它与<a href="https://baike.baidu.com/item/HTML/97049?fromModule=lemma_inlink">HTML</a>和<a href="https://baike.baidu.com/item/CSS/5457?fromModule=lemma_inlink">CSS</a>共同协作，HTML负责定义网页的内容结构，CSS处理样式和布局，而JavaScript则控制网页的行为和交互。</p><h2 id="js的事件循环机制"><a href="#js的事件循环机制" class="headerlink" title="js的事件循环机制"></a>js的事件循环机制</h2><p><strong>js是单线程的，会出现阻塞问题。</strong><br>比如说网络请求和 <code>settimeout</code> ，它<strong>通过异步来做</strong>的，若都用异步则会放在队列里面，<strong>异步队列没有优先级</strong>，所以为了更灵活增加了事件循环<br><strong>事件循环：</strong><br>js是单线程，有同步任务和异步任务，一般是异步任务又分为微任务和宏任务<br><strong>先执行同步任务队列，再执行微任务队列，之后再执行宏任务</strong>，每执行一次宏任务时会<strong>时时检测微任务队列有没有任务</strong>，若有则会先清空微任务队列，执行完了，再去执行下一个宏任务。</p><p><strong>运行机制：</strong><br>单线程，从上到下按顺序执行代码。<strong>运行的两个阶段</strong>：</p><ol><li><strong>预解析：</strong>把所有的函数定义提前，所有的变量声明提前，变量的赋值不提前</li><li><strong>执行：</strong>从上到下执行（按照js运行机制）</li></ol><h2 id="javascript的数据类型"><a href="#javascript的数据类型" class="headerlink" title="javascript的数据类型"></a>javascript的数据类型</h2><p><code>Boolean</code>、<code>null</code>、<code>String</code>、<code>Number</code>、<code>Object</code>、<code>Undefined</code><br><strong>常见基本数据类型：</strong><code>Number</code>、<code>String</code> 、<code>Boolean</code>、<code>Null</code> 和 <code>Undefined</code>。<br>基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值<br><strong>引用类型：</strong><code>Objec</code>t 、<code>Array</code> 、<code>Function</code> 、<code>Data</code>等。</p><h2 id="怎样判断变量的类型"><a href="#怎样判断变量的类型" class="headerlink" title="怎样判断变量的类型"></a>怎样判断变量的类型</h2><p><code>typeof</code> 能够区分<strong>除数组、对象和null外的所有类型</strong>，[] {} null 都返回object<br><code>instanceof</code> 及原理：<code>object.toString().call()</code></p><h2 id="Cookie（4kb）、-storage-（5MB）-localStorage（5-10MB）"><a href="#Cookie（4kb）、-storage-（5MB）-localStorage（5-10MB）" class="headerlink" title="Cookie（4kb）、 storage （5MB） localStorage（5-10MB）"></a>Cookie（4kb）、 storage （5MB） localStorage（5-10MB）</h2><p>首先，<code>webstorage</code>中包含<code>sessionStorage</code>和<code>localStorage</code>。 <strong>cookie和webstorage的区别:</strong></p><ol><li><strong>出现的时间：</strong><code>cookie</code> 很早之前就有了，<code>webstorage</code> H5之后才有的</li><li><strong>跟随请求状态</strong>：cookie 会跟着前后台请求，webstorage 不跟随</li><li><strong>储存大小：</strong>cookie 4K，storage 5M左右</li><li><strong>生命周期：</strong>cookie 生命周期可以设置，webstorage 生命周期不可设置</li><li><strong>存在的位置：</strong>cookie / sessionStorage / localStorage 在客户端，<strong>seesion 在服务端</strong>，较其他的安全</li></ol><h2 id="操作数组和对象的常见方法"><a href="#操作数组和对象的常见方法" class="headerlink" title="操作数组和对象的常见方法"></a>操作数组和对象的常见方法</h2><p><strong><code>array</code>：</strong> <code>slice / splice / concat / filter / map / reduce</code><br><strong><code>obj</code> ：</strong> <code>keys / assign</code></p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Lemon&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Mango&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> citrus = fruits.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>);   <span class="comment">// [&#x27;Orange&#x27;,&#x27;Lemon&#x27;]</span></span><br><span class="line"><span class="keyword">const</span> removed = fruits.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="string">&#x27;Kiwi&#x27;</span>, <span class="string">&#x27;Pineapple&#x27;</span>); <span class="comment">//替换了原数组[&#x27;Kiwi&#x27;, &#x27;Pineapple&#x27;, &#x27;Lemon&#x27;, &#x27;Apple&#x27;, &#x27;Mango&#x27;]</span></span><br><span class="line"><span class="comment">//fruits.splice(2, 2)   // [&#x27;Lemon&#x27;, &#x27;Apple&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="new内部做了什么"><a href="#new内部做了什么" class="headerlink" title="new内部做了什么"></a>new内部做了什么</h2><ol><li>创建了一个新对象 <code>var obj = &#123;&#125;</code>；</li><li><code>this</code>关键字指向obj；</li><li><code>prototype</code>原型指向<code>obj</code>原型；</li><li>执行构造函数</li></ol><h2 id="防抖、节流-函数节流的应用场景"><a href="#防抖、节流-函数节流的应用场景" class="headerlink" title="防抖、节流 , 函数节流的应用场景"></a>防抖、节流 , 函数节流的应用场景</h2><p>js 中一些事件如浏览器的 <code>resize</code>、<code>scroll</code>，鼠标的 <code>mousemove</code>、<code>mouseover</code>，input 输入框的 <code>keypress</code> 等<strong>事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</strong>。为优化体验，需要对这类事件进行调用次数的限制。<br><strong>函数防抖：</strong>在一段连续操作结束后，处理回调，利用 <code>clearTimeout</code> 和 <code>setTimeout</code>实现<br><strong>函数节流：</strong>每隔一段时间，只执行一次函数。<br><strong>场景：</strong></p><ol><li>滚动加载，加载更多或滚到底部监听； </li><li>谷歌搜索框，搜索联想功能；</li><li>高频点击提交，表单重复提交</li></ol><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ol><li><strong>普通函数调用</strong>，此时 this 指向 <code>window</code></li><li><strong>构造函数调用</strong>，此时 this 指向 <code>实例对象</code></li><li><strong>对象方法调用</strong>，此时 this 指向 <code>该方法所属的对象</code></li><li><strong>通过事件绑定的方法</strong>，此时 this 指向 <code>绑定事件的对象</code></li><li><strong>定时器函数</strong>，此时 this 指向 <code>window</code></li></ol><h2 id="let-const-var-的区别"><a href="#let-const-var-的区别" class="headerlink" title="let const var 的区别"></a>let const var 的区别</h2><p><code>var</code>：作用域是<strong>全域的</strong>； var<strong>允许重复声明变量</strong><br><code>let</code>：作用域是<strong>块级</strong>；let<strong>不允许重复声明变量</strong><br><code>const</code>：声明的是<strong>常量</strong>，不可改变，<strong>必须初始化</strong>，作用于<strong>块级作用域</strong>，没有变量提升，不允许重复声明</p><h2 id="实现继承的几种方式"><a href="#实现继承的几种方式" class="headerlink" title="实现继承的几种方式"></a>实现继承的几种方式</h2><p><strong>原型链</strong>继承、<strong>构造</strong>继承、<strong>实例</strong>继承、<strong>拷贝</strong>继承、<strong>组合</strong>继承</p><h2 id="promiss的理解"><a href="#promiss的理解" class="headerlink" title="promiss的理解"></a>promiss的理解</h2><p><code>Promise</code> 是 JavaScript 中异步编程的一种解决方案，用于处理异步操作的结果<br><strong>特点：</strong>Promise 对象的状态不受外界影响，只有异步操作的结果才能决定其状态<br><strong>优点：</strong></p><ul><li><strong>解决了回调地狱问题</strong>，使得代码结构更加清晰和可维护；</li><li>提供了<strong>统一的API</strong>，使得异步操作的控制更加容易</li><li> function a(){  var n =0;  function b(){     n++;    console.log(n);  }}js</li></ul><p><strong>回调地狱问题：</strong>每个接口都依赖于前一个接口的返回,</p><h2 id="promiss为什么支持链式调用"><a href="#promiss为什么支持链式调用" class="headerlink" title="promiss为什么支持链式调用"></a>promiss为什么支持链式调用</h2><p>在 then 方法中返回另一个 Promise，因此可将多个 then 方法串联起来，形成一个链式调用。每个 then 方法的返回值都会作为下一个 then 方法的输入，从而实现异步操作的顺序执行。如下示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPromise</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(value), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getPromise</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getPromise</span>(result * <span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getPromise</span>(result * <span class="number">3</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: 6</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;  </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="在-try，catch中-报错了在catch中会被检测到么"><a href="#在-try，catch中-报错了在catch中会被检测到么" class="headerlink" title="在 try，catch中 报错了在catch中会被检测到么"></a>在 try，catch中 报错了在catch中会被检测到么</h2><p>如果在 <code>catch</code> 块中再次抛出错误，这个新的错误<strong>可以被外层的 <code>try…catch</code> 语句捕获</strong>，或者如果没有外层的 try…catch 语句，它会<strong>继续向上抛出，直到被捕获或导致程序终止</strong>。</p><h2 id="浏览器垃圾回收"><a href="#浏览器垃圾回收" class="headerlink" title="浏览器垃圾回收"></a>浏览器垃圾回收</h2><p>当 <code>JavaScript</code> 代码运行时，需要分配内存空间来存储变量和值。<br>当<strong>变量不再参与运行时，就需要系统收回被占用的内存空间</strong>，这就是垃圾回收<br><strong>常见内存泄露的原因</strong></p><ul><li><strong>全局变量</strong>引起的内存泄露</li><li><strong>闭包</strong>引起的内存泄露：慎用闭包</li><li><strong>dom清空或删除时，事件未清除导致</strong>的内存泄漏</li><li><strong>循环引用</strong>带来的内存泄露</li></ul><p><strong>优化写法</strong></p><ul><li>在<strong>对象结束使用后 ，令obj = null</strong>；</li><li>js中开辟空间的操作有 new()，[ ]，{ }，function (){…}，最大限度的实现<strong>对象的重用</strong>；</li><li><strong>慎用闭包</strong>，闭包容易引起内存泄露</li></ul><h2 id="js重复的问题-作用域链、原型、原型链、闭包？-面向对象-继承"><a href="#js重复的问题-作用域链、原型、原型链、闭包？-面向对象-继承" class="headerlink" title="js重复的问题 作用域链、原型、原型链、闭包？ 面向对象 继承"></a>js重复的问题 作用域链、原型、原型链、闭包？ 面向对象 继承</h2><p><strong>面向对象：</strong>是一种编程思想，将现实世界的事物抽象为对象，并使用类和对象来创建各种功能<br><strong>作用域链</strong><br>内部环境可以通过作用域链来访问外部环境的属性和方法，但<strong>外部环境不能访问内部环境的任何属性和方法</strong>。注意，<strong>只能通过定义函数来延长作用域链条</strong>。<br><strong>闭包</strong><br><strong>概念：</strong>闭包就是<strong>能够读取其他函数内部变量的函数</strong>，<code>Javascript</code> 语言中，只有函数内部的子函数才能读取局部变量，因此简单理解闭包为<strong>定义在一个函数内部的函数</strong>。<em>本质上</em>，闭包就是<strong>将函数内部和函数外部连接起来</strong>的一座桥梁。<br>例子(如下代码所示)：函数 b 就是一个闭包函数，用于获取函数 a 内部的变量 i。当函数 a 的内部函数 b，被函数 a 外的一个变量 c 引用的时候，就创建了一个闭包。<br><strong>作用：</strong>可以<strong>读取函数内部的变量；让这些变量的值始终保持在内存中</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(++i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="title function_">a</span>();</span><br><span class="line"><span class="title function_">c</span>()</span><br></pre></td></tr></table></figure><p><strong>原型链</strong><br><strong>原型：</strong>所有函数都有一个特殊属性 <code>prototype</code>(原型)，<strong>prototype 属性是一个指针，指向的是一个对象(原型对象)，原型对象中的方法和属性都可以被函数的实例所共享</strong>。所谓<code>函数实例</code>是指<strong>以函数作为构造函数创建的对象</strong>，这些对象实例都可以共享构造函数的原型的方法。<br><strong>原型链：</strong>原型链是<strong>用于查找引用类型（对象）的属性</strong>，查找属性会沿着原型链依次进行，找到后停止搜索并做相应的操作，否则会<strong>沿着原型链依次查找直到结尾</strong>。常见的应用是用在<strong>创建对象和继承</strong>中。</p>]]></content>
    
    
    <summary type="html">JavaScript</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="JavaScript" scheme="https://southernfish.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>VUE</title>
    <link href="https://southernfish.github.io/2025/06/20/front-end/front-end-vue/"/>
    <id>https://southernfish.github.io/2025/06/20/front-end/front-end-vue/</id>
    <published>2025-06-20T14:15:36.000Z</published>
    <updated>2025-06-23T13:16:46.573Z</updated>
    
    <content type="html"><![CDATA[<p>款用于构建用户界面的JavaScript框架。它基于标准<a href="https://baike.baidu.com/item/HTML/97049?fromModule=lemma_inlink">HTML</a>、CSS和<a href="https://baike.baidu.com/item/JavaScript/321142?fromModule=lemma_inlink">JavaScript</a>构建，并提供了一套声明式的、<a href="https://baike.baidu.com/item/%E7%BB%84%E4%BB%B6/6902128?fromModule=lemma_inlink">组件</a>化的编程模型，可以高效地开发<a href="https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/6582461?fromModule=lemma_inlink">用户界面</a>。无论是简单还是复杂的界面，Vue都可以胜任。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="对于MVVM的理解？"><a href="#对于MVVM的理解？" class="headerlink" title="对于MVVM的理解？"></a>对于MVVM的理解？</h2><ul><li><code>MVVM</code> 是 <code>Model-View-ViewModel</code> 的缩写</li><li>MVVM 的设计原理是<strong>基于 MVC</strong> 的</li><li><strong>Model代表数据模型 ；View 代表UI 组件视图；</strong>ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是<strong>一个同步 View 和 Model 的对象，连接 Model 和 View</strong></li></ul><p><strong>优势：</strong><code>vue</code> 和 <code>mode</code> 之间是双向数据传递的，视图改变数据就可以改变，数据改变了视图也跟着改变</p><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p><strong>生命周期：</strong>Vue 实例<strong>从创建到销毁的过程</strong>，就是生命周期。从<strong>开始创建、初始化数据、编译模板、挂载 Dom →渲染、更新→渲染、销毁</strong>等一系列过程，称之为 Vue 的生命周期。<br><strong>vue 生命周期的作用：</strong>它的生命周期中<strong>有多个事件钩子，在控制整个 Vue 实例的过程时更容易形成好的逻辑</strong>。<br><strong>vue 生命周期总共有 8 个阶段：</strong><code>创建前/后， 载入前/后，更新前/后，销毁前/销毁后</code>。<br>第一次页面加载会触发以下几个钩子：<code>beforeCreate, created, beforeMount, mounted</code> 。<br>DOM 渲染在 <code>mounted</code> 周期中就已经完成</p><h2 id="Vue的生命周期-1"><a href="#Vue的生命周期-1" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p><code>beforeCreate</code>：在实例创建之间执行，数据是未加载状态。<br><code>created</code>：在实例创建、数据加载后，能初始化数据，DOM 渲染之前执行。<br><code>beforeMount</code>：虚拟 DOM 已创建完成，在数据渲染前最后一次更改数据。el 未挂载。<br><code>mounted</code>：页面、数据渲染完成。el 挂载完毕。可以访问 DOM 节点。<br><code>beforeUpdate</code>：重新渲染之前触发。不会造成重渲染。<br><code>Updated</code>：数据已经更新完成，DOM 也重新 render 完成，更改数据会陷入死循环。<br><code>beforeDestroy</code>：实例销毁前执行，实例仍然完全可用。<br><code>destroyed</code>：实例销毁后执行，这时候只剩下 DOM 空壳。</p><h2 id="Vue3的生命周期？"><a href="#Vue3的生命周期？" class="headerlink" title="Vue3的生命周期？"></a>Vue3的生命周期？</h2><p><strong>创建期setup()</strong><br><strong>挂载期：</strong></p><ul><li><code>onBeforeMount()</code>：<strong>组件挂载到节点上之前</strong>执行的函数</li><li><code>onMounted()</code>：<strong>组件挂载完成后</strong>执行的函数，<strong>此时可以访问和操作DOM</strong></li></ul><p><strong>更新期：</strong></p><ul><li><code>onBeforeUpdate()</code>：<strong>组件更新之前</strong>执行的函数</li><li><code>onUpdated()</code>：<strong>组件更新完成之后</strong>执行的函数</li></ul><p><strong>销毁期：</strong></p><ul><li><code>onBeforeUnmount()</code>：<strong>组件卸载之前</strong>执行的函数，可以进行一些<strong>善后的工作</strong>，例如清理定时器等</li><li><code>onUnmounted()</code>：<strong>组件卸载完成后</strong>执行的函数，表示组件已经被完全销毁</li></ul><h2 id="vue获取数据在哪个周期函数"><a href="#vue获取数据在哪个周期函数" class="headerlink" title="vue获取数据在哪个周期函数?"></a>vue获取数据在哪个周期函数?</h2><p>一般 <code>created</code> / <code>beforeMount</code> / <code>mounted</code> 皆可， 比如如果你要操作 DOM , 那肯定 mounted 时候才能操作</p><h2 id="Vue实现数据双向绑定的原理"><a href="#Vue实现数据双向绑定的原理" class="headerlink" title="Vue实现数据双向绑定的原理"></a>Vue实现数据双向绑定的原理</h2><p><strong>Vue2 实现数据双向绑定的原理：</strong><code>Object.defineProperty()</code><br>采用<strong>数据劫持结合发布者-订阅者模式的方式</strong>，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，<strong>触发相应监听回调</strong></p><p><strong>Vue3 实现数据双向绑定的原理：</strong><code>Proxy</code><br>当<strong>属性被修改时，Proxy 对象的 set 陷阱会被触发</strong>。此时，<strong>Vue3会通知所有依赖该属性的 Watcher 对象进行更新</strong>。Watcher 对象会调用对应的更新函数，从而触发视图的重新渲染</p><h2 id="Vue的路由实现：hash模式-和-history模式区别，上线有什么区别。"><a href="#Vue的路由实现：hash模式-和-history模式区别，上线有什么区别。" class="headerlink" title="Vue的路由实现：hash模式 和 history模式区别，上线有什么区别。"></a>Vue的路由实现：hash模式 和 history模式区别，上线有什么区别。</h2><p><strong>hash模式：</strong>在浏览器中符号<code>“#”</code>， 用<code>window.location.hash</code>读取<br><strong>history模式：</strong>采用HTML5新特性；<strong>方法 <code>pushState()，replaceState()</code> 可修改浏览器历史记录栈</strong>，<code>popState</code> 事件监听状态变更。<br>上线区别<br><strong>hash模式：</strong>URL 形式：<a href="http://example.com/**#/path**%EF%BC%8C**#">http://example.com/**#/path**，**#</a> 后面的部分来模拟一个完整的 URL<strong>，不会引起页面的重新加载。<br><strong>history 模式：</strong>URL 形式：<a href="http://example.com/">http://example.com</a></strong>/path<strong>，</strong>需配置服务器**，否则会当成真正的路径要后端配置重定向，不然访问不到。</p><h2 id="Vue组件间的参数传递-和父子组件方法调用（组件通信）"><a href="#Vue组件间的参数传递-和父子组件方法调用（组件通信）" class="headerlink" title="Vue组件间的参数传递 和父子组件方法调用（组件通信）"></a>Vue组件间的参数传递 和父子组件方法调用（组件通信）</h2><ul><li><strong>父组件与子组件传值</strong><ul><li> 父组件传给子组件：<strong>子组件通过<code>props</code>方法接受数据；</strong></li><li> 子组件传给父组件：**<code>$emit</code> 方法传递参数**</li></ul></li><li><strong>非父子组件间的数据传递，兄弟组件传值</strong><ul><li><code>eventBus</code>，就是<strong>创建一个事件中心</strong>，相当于中转站，<strong>可用它传递事件和接收事件</strong>。比较适合项目较小时。</li><li>事件总线： <code>Vue.prototype.$bus = new Vue()；</code>使用 <code>Vuex</code></li></ul></li><li>provide 和 inject</li><li>父组件调用子组件方法：<code>this.$refs.mychildren.function()</code></li><li>子组件调用父组件方法： <code>this.$parent.function()</code></li></ul><h2 id="params和query的区别"><a href="#params和query的区别" class="headerlink" title="params和query的区别"></a>params和query的区别</h2><p><strong>用法：</strong>query 用 path 引入，params 用 name 引入，接收参数类似，分别是 <code>this.$route.query.name</code> , <code>this.$route.params.name</code><br><strong>url地址显示：</strong>query 类似于 ajax 中 get 传参，params 类似于 post，或者说 query 在浏览器地址栏中显示参数，params 不显示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// params传值</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="regexp">/user/</span>:id&#125; <span class="comment">// 路由里:id</span></span><br><span class="line">&lt;router-link to =<span class="string">&quot;/user/123&quot;</span>&gt;&lt;<span class="regexp">/router-link&gt; /</span><span class="regexp">/ 组件传值 用/i</span>d</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="property">params</span>.<span class="property">id</span> <span class="comment">// js代码中获取路由传递的id值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// query传值</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/user&#x27;</span>&#125; <span class="comment">// 路由</span></span><br><span class="line"><span class="comment">// 组件传值 使用?拼接 参数之间用&amp;</span></span><br><span class="line">&lt;router-link to =<span class="string">&quot;/user? id=123&quot;</span>&gt;&lt;/router-link&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span> =<span class="string">&quot;/user?id=123&amp;name=zs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span> <span class="comment">//组件传值</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="property">query</span>.<span class="property">id</span> <span class="comment">//取值</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="property">query</span>.<span class="property">name</span> <span class="comment">//取值</span></span><br></pre></td></tr></table></figure><h2 id="vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex是什么？怎么使用？哪种功能场景使用它？"></a>vuex是什么？怎么使用？哪种功能场景使用它？</h2><p><code>vuex</code> 是一种集中式状态管理模式，它按照一定的规则管理状态，保证状态的变化是可预测的。<br>vuex 可以理解为一种开发模式或框架，<strong>通过状态集中管理驱动组件的变化，应用级的状态集中放在store中，改变状态的方式是提交 mutations，异步逻辑封装在 action 中</strong>。</p><p><strong>使用方式：</strong><br>在 main.js 引入 store，注入。只用来读取的状态集中放在 store 中；<br>改变状态的方式是提交 mutations ，这是个同步的事物； 异步逻辑应该封装在 action 中。</p><p><strong>场景：单页应用中</strong>，组件之间的状态、音乐播放、登录状态、加入购物车<br><code>state</code>：定义初始化状态<br><code>getters</code>：获取状态<br><code>mutations</code>：设置状态<br><code>actions</code>：异步提交 mutations<br><code>modules</code>：把状态管理模块化，各自的组件构成各自的模块</p><h2 id="css只在当前组件起作用"><a href="#css只在当前组件起作用" class="headerlink" title="css只在当前组件起作用"></a>css只在当前组件起作用</h2><p>在 style 标签中写入 <code>scoped</code> 即可 例如：<code>&lt;style scoped&gt;&lt;/style&gt;</code></p><h2 id="v-if-和-v-show-区别"><a href="#v-if-和-v-show-区别" class="headerlink" title="v-if 和 v-show 区别"></a>v-if 和 v-show 区别</h2><p><strong>相同点：</strong>v-if 与 v-show 都可以<strong>动态控制 dom 元素显示隐藏</strong><br><strong>不同点：</strong>v-if 将 dom 元素整个添加或删除 ，<strong>v-show 隐藏是为该元素添加 css–display:none，dom 元素还在</strong>。</p><h2 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别"></a>$route和$router的区别</h2><p><code>$route</code> 是<strong>路由信息对象</strong>，包括 path，params，hash，query，fullPath，matched，name等路由信息参数。 而$router 是<code>VueRouter</code> <strong>路由实例</strong> 对象包括了路由的跳转方法，钩子函数等。</p><h2 id="vue-js的两个核心是什么？"><a href="#vue-js的两个核心是什么？" class="headerlink" title="vue.js的两个核心是什么？"></a>vue.js的两个核心是什么？</h2><p>数据驱动、组件系统</p><h2 id="computed、watch、methods的区别"><a href="#computed、watch、methods的区别" class="headerlink" title="computed、watch、methods的区别"></a>computed、watch、methods的区别</h2><p><code>computed</code> 要有返回值，支持缓存。watch 不支持缓存。methods 不支持缓存。<br><strong><code>watch</code> 项目用处：</strong>搜索框输入框的监听；监听路由地址的改变</p><h2 id="vue几种常用的指令"><a href="#vue几种常用的指令" class="headerlink" title="vue几种常用的指令"></a>vue几种常用的指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v-for (循环指令，可以循环数组或对象)</span><br><span class="line">v-if (是否渲染元素，会销毁并重建)</span><br><span class="line">v-bind (动态绑定数据)</span><br><span class="line">v-on (绑定事件监听器)</span><br><span class="line">v-show (显示隐藏元素，修改元素的 display 属性)</span><br><span class="line">v-else(与 v-if 配合使用)</span><br><span class="line">v-model (实现双向绑定)</span><br></pre></td></tr></table></figure><h2 id="v-for与v-if-一起使用"><a href="#v-for与v-if-一起使用" class="headerlink" title="v-for与v-if 一起使用"></a>v-for与v-if 一起使用</h2><p>由于<strong>v-for会先执行，v-if 将分别重复运行于每个 v-for 循环中</strong>。这可能会导致不必要的计算，性能下降，特别是在处理大型数据集时，可能会使代码的逻辑变得不清晰。<br>在<code>Vue 2</code>中在同一个元素上同时使用这两个指令时 <strong>v-for 的优先级高于 v-if</strong> ，<br>在<code>Vue 3</code>中，<strong>v-if 的优先级高于 v-for</strong>。不推荐一起使用 在外层包装一个 template 标签</p><h2 id="v-on-可以绑定多个方法吗？"><a href="#v-on-可以绑定多个方法吗？" class="headerlink" title="v-on 可以绑定多个方法吗？"></a>v-on 可以绑定多个方法吗？</h2><p>可以 … 例：<code> &lt;p @click=“one(),two()”&gt;</code>点击</p><h2 id="vue中key-值的作用"><a href="#vue中key-值的作用" class="headerlink" title="vue中key 值的作用"></a>vue中key 值的作用</h2><p>原理是vue 在**<code>pacth</code>过程中<strong>通过 key 可以精准判断两个节点是否是同一个， 从而避免平凡更新不同元素，减少dom操作，提升性能<br>key值</strong>对数据改变之后的diff更新比较有很大的性能提升<strong>，或者说有了key和没有key是两种比较和更新机制<br>作用主要是为了</strong>高效的更新虚拟DOM<strong>。另外vue中在</strong>使用相同标签名元素的过渡切换时**，也会使用到key属性，目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果，就不会达到最小更新<br><strong>index值不是一定不变的</strong>，若不加key值，删除前面的项。后面的index可能变也可能不变，如加个定时器时会变，不加定时器不变</p><h2 id="nextTick的使用"><a href="#nextTick的使用" class="headerlink" title="$nextTick的使用"></a>$nextTick的使用</h2><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新的 DOM。</p><h2 id="nextTick能获取到最新dom是什么原理"><a href="#nextTick能获取到最新dom是什么原理" class="headerlink" title="$nextTick能获取到最新dom是什么原理"></a>$nextTick能获取到最新dom是什么原理</h2><p>当修改了数据，Vue 会将这些变更放入一个异步任务队列，而不是立即更新 DOM。<br><code>$nextTick</code> 的<strong>回调函数是在任务队列中的所有任务执行完毕后调用的</strong>，这意味着 DOM 更新已经完成。</p><h2 id="项目初始化页面闪动问题"><a href="#项目初始化页面闪动问题" class="headerlink" title="项目初始化页面闪动问题"></a>项目初始化页面闪动问题</h2><p>vue 页面在加载的时候闪烁花括号{}，v-cloak 指令和 css 规则如 [v-cloak]{ display:none }一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。<br>如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*css样式*/</span></span><br><span class="line"><span class="selector-attr">[v-cloak]</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!<span class="attr">--html</span>代码--&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> id=&quot;app&quot; v-cloak&gt;</span><br><span class="line">    &lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span> v-for=&quot;item in tabs&quot;&gt;&#123;&#123;item<span class="selector-class">.text</span>&#125;&#125;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="怎么理解vue中的-diff-算法？"><a href="#怎么理解vue中的-diff-算法？" class="headerlink" title="怎么理解vue中的 diff 算法？"></a>怎么理解vue中的 diff 算法？</h2><p><code>diff</code> 算法是<strong>虚拟DOM的产物</strong>，通过新旧虚拟 dom 对比， 将变化的地方更新在真实的 dom 上<br><code>diff</code> 算法<strong>能精准找到发生的变化的地方</strong></p><h2 id="vue-怎么缓存-keep-alive"><a href="#vue-怎么缓存-keep-alive" class="headerlink" title="vue 怎么缓存 keep-alive"></a>vue 怎么缓存 keep-alive</h2><p><code>keep-alive</code> 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染；可以实现组件缓存，当组件切换时不会对当前组件进行卸载；有 <code>include</code>、<code>exclude</code> 两个属性，可以有条件的进行组件缓存<br><code>keep-alive</code>功能：当组件切换为非激活状态时，不会触发销毁流程，而是将组件实例及其状态完整封存。这一特性使其成为保留组件状态、优化渲染性能的核心工具。<br>生命周期钩子联动。当组件在 keep-alive 内切换时，会触发专属生命周期钩子：</p><ul><li> function a() {    var i = 0;    function b(){        alert(++i);    }    return b;}var c = a();c()js</li><li><code>deactivated</code>：组件失活时调用（被切换出但未销毁）</li></ul><p>应用场景1：路由页面状态持久化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 缓存所有路由组件 --&gt;</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;!-- 精准缓存指定路由组件 --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;[&#x27;Home&#x27;, &#x27;Profile&#x27;]&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>应用场景2：动态组件状态保留</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;keep-alive&gt;</span><br><span class="line">    &lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/keep-alive&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123; currentComponent: &#x27;Login&#x27; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="vue组件中data为什么必须是一个函数？"><a href="#vue组件中data为什么必须是一个函数？" class="headerlink" title="vue组件中data为什么必须是一个函数？"></a>vue组件中data为什么必须是一个函数？</h2><p>由 <code>JavaScript</code> 的特性所导致，在 <code>component</code> 中，data 必须以函数的形式存在，不可以是对象。组建中的 data 写成一个函数，数据以函数返回值的形式定义，这样<strong>每次复用组件的时候，都会返回一份新的 data ，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱</strong>。而单纯的写成对象形式，就是所有的组件实例共用了一个 data ，这样改一个全都改了。</p><h2 id="assets和static的区别"><a href="#assets和static的区别" class="headerlink" title="assets和static的区别?"></a>assets和static的区别?</h2><p>这两个都是用来<strong>存放项目中所使用的静态资源文件</strong>。<br><strong>两者的区别：</strong><br><code>assets</code> 中的文件在运行 <code>npm run build</code> 的时候会打包，也就是会被<strong>压缩体积，代码格式化</strong>之类的。<strong>打包之后也会放到 static 中</strong>。<br><code>static </code>中的文件则<strong>不会被打包</strong>。<br><strong>建议：</strong>将图片等未处理的文件放在 assets 中，打包减少体积。而对于第三方引入的资源文件（如：iconfont.css等）可以放在static 中，因为这些文件已经经过处理了。</p><h2 id="vue的常用修饰符"><a href="#vue的常用修饰符" class="headerlink" title="vue的常用修饰符"></a>vue的常用修饰符</h2><p><code>.prevent</code>：提交事件不再重载页面；等同于 JavaScript 中的 event.preventDefault()，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）<br><code>.stop</code>：阻止单击事件冒泡；等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡。<br><code>.self</code>：只会触发自己范围内的事件，不包含子元素；<br><code>.capture</code>：事件侦听，事件发生的时候会调用；与事件冒泡的方向相反，事件捕获由外到内<br><code>.once</code>：只会触发一次<br><code>.passive</code>：提升移动端的性能。</p><h2 id="vue其他修饰符？"><a href="#vue其他修饰符？" class="headerlink" title="vue其他修饰符？"></a>vue其他修饰符？</h2><p><strong>按键修饰符：</strong><code>.enter</code>、<code>.delete</code>、<code>.space</code>、<code>.esc</code>、<code>.up</code>、<code>.down</code>等<br><strong>系统修饰键：</strong><code>.ctrl</code>、<code>.alt</code><br><strong>鼠标按钮修饰符：</strong><code>.left</code>、<code>.right</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 阻止单击事件继续传播</span><br><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line">// 提交事件不再重载页面</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line">// 修饰符可以串联</span><br><span class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line">// 只有修饰符</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class="line">// 添加事件监听器时使用事件捕获模式 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理</span><br><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line">// 只当在 event.target 是当前元素自身时触发处理函数  即事件不是从内部元素触发的</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class="line">// 点击事件将只会触发一次</span><br><span class="line">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line">// 滚动事件的默认行为 (即滚动行为) 将会立即触发, 不会等待onScroll完成,这其中包含 `event.preventDefault()` 的情况</span><br><span class="line">&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="vue深度监听（watch）"><a href="#vue深度监听（watch）" class="headerlink" title="vue深度监听（watch）"></a>vue深度监听（watch）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">watch:</span><br><span class="line">// 第一种</span><br><span class="line">&quot;a.b.c&quot;:function(newValue, oldValue)&#123;</span><br><span class="line">    console.log(newValue, oldValue);</span><br><span class="line">&#125;</span><br><span class="line">// 第二种</span><br><span class="line">a: &#123;</span><br><span class="line">    deep: true, // deep为ture 意味着开启了深度监听a对象里面任何数据变化都会触发</span><br><span class="line">    handler(newValue, oldvalue)&#123;</span><br><span class="line">        //这个函数是固定写法</span><br><span class="line">        console.log(newValue, oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h1><h2 id="vue路由的钩子函数-路由守卫"><a href="#vue路由的钩子函数-路由守卫" class="headerlink" title="vue路由的钩子函数 (路由守卫)"></a>vue路由的钩子函数 (路由守卫)</h2><p>首页可控制导航跳转，beforeEach，afterEach等，一般用于页面title修改。一些需要登录才能调整页面的重定向功能。<br><strong>beforeEach((to,from,next)=&gt;{});</strong></p><ul><li><code>to</code>：route 即将进入的目标路由对象，</li><li><code>from</code>：route 当前导航正要离开的路由</li><li><code>next</code>：function一定要调用该方法resolve这个钩子。执行效果依赖 next 方法的调用参数。可控制网页跳转。</li></ul><p><strong>router.afterEach((to,from)=&gt;{});</strong></p><ul><li><code>to</code>：已进入的目标路由对象</li><li><code>from</code>：已离开的路由对象</li></ul><h2 id="vue-router有哪几种导航钩子？以及它的参数？"><a href="#vue-router有哪几种导航钩子？以及它的参数？" class="headerlink" title="vue-router有哪几种导航钩子？以及它的参数？"></a>vue-router有哪几种导航钩子？以及它的参数？</h2><p><strong>第一种：全局导航</strong>钩子：<code>router.beforeEach(to,from,next)</code>，<strong>作用：</strong>跳转前进行判断拦截。<br><strong>第二种：组件内</strong>的钩子<br><strong>第三种：单独路由独享组件</strong><br>beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave<br><strong>参数：</strong>to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，不用就拦截）</p><h2 id="Vue-router的跳转原理"><a href="#Vue-router的跳转原理" class="headerlink" title="Vue-router的跳转原理"></a>Vue-router的跳转原理</h2><p><strong>Vue-router的跳转原理:</strong> 通过不同的模式来实现页面的无刷新跳转，主要包括 hash 模式、history 模式和 abstract 模式。</p><ul><li><code>hash</code>：使用 <code>URL hash</code> 值来作路由。默认模式。</li><li><code>history</code>：依赖 <code>HTML5 History API</code> 和服务器配置。查看 HTML5 History 模式。</li><li><code>abstract</code>：支持所有 JavaScript 运行环境，如 Node.js 服务器端</li></ul><p><strong>路由之间的跳转:</strong></p><ul><li>声明式（标签跳转）<ul><li><code>&lt;router-view&gt;</code>标签用于展示路由组件，DOM节点中使用 <code>v-link</code> 进行跳转，或使用 <code>router-link</code> 标签</li></ul></li><li>编程式（js跳转）</li></ul><h2 id="怎么定义vue-router的动态路由及如何获取传过来的动态参数？"><a href="#怎么定义vue-router的动态路由及如何获取传过来的动态参数？" class="headerlink" title="怎么定义vue-router的动态路由及如何获取传过来的动态参数？"></a>怎么定义vue-router的动态路由及如何获取传过来的动态参数？</h2><p>在 router 目录下的 index.js 文件中，对 path 属性加上/：id<br>使用 router 对象的 params id<br><strong>用 watch 去监听 router 变化：</strong>当路由发生变化的时候，在 watch 中写具体的业务逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">    $router(to, from)&#123;</span><br><span class="line">        console.log(to.path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue的路由实现-hash模式和history模式-Vue的两种状态"><a href="#Vue的路由实现-hash模式和history模式-Vue的两种状态" class="headerlink" title="Vue的路由实现: hash模式和history模式(Vue的两种状态)"></a>Vue的路由实现: hash模式和history模式(Vue的两种状态)</h2><p><strong>hash模式：</strong>即地址栏URL的#符号<br>通过<code> window.onhashchange</code> <strong>监听，匹配不同的 url 路径，进行解析，加载不同的组件，然后动态的渲染出区域内的html 内容</strong>，不会被包含在HTTP请求中，对后端完全没有影响<br><strong>HashHistory 有两个方法：</strong></p><ul><li><code>HashHistory.push() </code>是将路由添加到浏览器访问历史的栈顶</li><li><code>hashHistory.replace() </code>是替换掉当前栈顶的路由</li></ul><p>因为<strong>hash发生变化的url都会被浏览器历史访问栈记录下来</strong>，因此尽管浏览器没有请求服务器，但页面状态是和url关联起来的，浏览器还是可以进行前进后退的</p><p><strong>history模式</strong><br>利用 HTML5 History Interface 中新增的 <strong>pushState()</strong> 和 <strong>replaceState()</strong> 方法。这两个方式应用于浏览器的历史记录栈，<strong>提供了对历史记录的修改功能</strong>。history模式不怕页面的前s进和后腿，就怕刷新，当<strong>刷新时，若服务器没有相应的响应或者资源，就会刷出404</strong>，而hash模式不会<br>$route 从当前 router 跳转对象里面可以获取 <code>name、path、query、params</code> 等<br>    （<code>&lt;router-link&gt;</code>传的参数有<code>this.$route.query</code> 或者 <code>this.$route.params</code> 接收）<br>导航到不同URL，则使用 <code>$router.push</code> 方式，返回上一个history也是使用 <code>$router.go/$router.back</code> 方法</p>]]></content>
    
    
    <summary type="html">VUE</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="VUE" scheme="https://southernfish.github.io/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>前端基础</title>
    <link href="https://southernfish.github.io/2025/06/20/front-end/front-end-base/"/>
    <id>https://southernfish.github.io/2025/06/20/front-end/front-end-base/</id>
    <published>2025-06-20T13:15:36.000Z</published>
    <updated>2025-06-23T13:16:46.573Z</updated>
    
    <content type="html"><![CDATA[<p>前端技术是Web应用开发中基于浏览器的程序开发，涵盖HTML、CSS和JavaScript等基础技术，并通过BOM、DOM实现用户交互。该技术以HTML、CSS、JavaScript为核心基础，通过DOM与BOM实现动态页面控制。</p><h2 id="HTML5的新特性和CSS3的新特性"><a href="#HTML5的新特性和CSS3的新特性" class="headerlink" title="HTML5的新特性和CSS3的新特性"></a>HTML5的新特性和CSS3的新特性</h2><p><strong>HTML5的新特性</strong></p><ul><li><strong>语义化标签 ：</strong><code>header</code>、<code>nav</code>、 <code>aside</code>、<code>footer</code>、<code>article</code>、<code>section</code> 等。可以更清晰地描述网页的结构和内容，提高网页的可读性和可访问性，利于搜索引擎优化（SEO）。</li><li><strong>表单控件验证功能：</strong>如日期选择器、颜色选择器、滑块等，表单更加易用，同时内置表单验证功能，减少了验证代码的编写量。</li><li><strong>多媒体支持：</strong> video audio等</li></ul><p><strong>CSS3的新特性</strong></p><ul><li><strong>改善布局和样式：</strong> 如边框圆角、边框阴影、渐变、文本装饰</li><li><strong>动画和过渡：</strong> <code>transition</code> 属性和 <code>@keyframes</code> 规则制定动画效果</li><li>多列布局和弹性盒子布局</li><li><strong>媒体查询:</strong> 不同屏幕的尺寸使用不同的<code>css</code></li><li>自定义字体和背景</li><li><strong>网格布局 ：</strong>上下居中水平对齐方式<code>display: grid; place-items: center; </code>/* 水平和垂直都居中 */</li></ul><h3 id="css-选择器的优先级排序"><a href="#css-选择器的优先级排序" class="headerlink" title="css 选择器的优先级排序"></a>css 选择器的优先级排序</h3><p>优先级排序从高到低：<code>!important</code> 、<code>行内样式</code>、<code>ID选择器</code>、<code>类选择器</code></p><h2 id="link和a标签区别"><a href="#link和a标签区别" class="headerlink" title="link和a标签区别"></a>link和a标签区别</h2><p><code>link</code>是一个组件，用处也是页面内跳转。<code>a</code>是基础的标签，也是用来跳的。</p><h2 id="什么是CSS盒模型-gt-gt-gt-IE盒模型和W3C盒模型"><a href="#什么是CSS盒模型-gt-gt-gt-IE盒模型和W3C盒模型" class="headerlink" title="什么是CSS盒模型 &gt;&gt;&gt; -IE盒模型和W3C盒模型"></a>什么是CSS盒模型 &gt;&gt;&gt; -IE盒模型和W3C盒模型</h2><p><strong>标准模式</strong>下，一个块的宽度 = width + padding(内边距) + border(边框) + margin(外边距)；<br><strong>怪异模式</strong>下，一个块的宽度 = width + margin(外边距) （即怪异模式下，width包含了border以及padding）;</p><h3 id="div-上下居中对齐的几种方式"><a href="#div-上下居中对齐的几种方式" class="headerlink" title="div 上下居中对齐的几种方式"></a>div 上下居中对齐的几种方式</h3><p>第一种：flex布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center; // 水平居中 </span><br><span class="line">    <span class="attribute">align-items</span>: center; // 垂直居中 </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>; // 或其他高度 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：grid网格布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    place-items: center; // 水平和垂直都居中 </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>; // 或者其他需要的高度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种：相对定位和绝对定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123; <span class="attribute">position</span>: relative; <span class="attribute">height</span>: <span class="number">100vh</span>; &#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四种：line-height 适用于单行文本</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: cente</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h3><p><strong>伪类：</strong>伪类<strong>用于选择DOM树之外的信息</strong>。<code>:hover</code> 伪类用于选择鼠标悬停在其上的元素，<code>:visited</code> 用于选择已访问的链接等<br><strong>伪元素：</strong>伪元素为<strong>DOM树没有定义的虚拟元素</strong>。 例如，<code>::before</code> 和 <code>::after </code>伪元素允许在元素内容之前或之后插入内容</p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p><strong>浅拷贝</strong><br>在栈内存中重新开辟一块内存空间，并将拷贝对象储存在栈内存中的数据存放到其中。<br><strong>存在问题：</strong>浅拷贝只复制了引用，所以修改新对象会影响到原对象<br><strong>实现方法：</strong> 使用<code>赋值运算符（=）</code>或者<code>Object.assign()</code>函数进行拷贝</p><p><strong>深拷贝</strong><br>另外创造一个一模一样的对象<br><strong>优点：</strong>修改新对象不会影响到原对象<br><strong>实现方法：</strong>递归拷贝 <code>JSON.parse(JSON.stringify(obj))</code>，<code> …扩展运算符</code><br><code>const b = […a]; </code>// 这只适用于一层深拷贝<br><code>const c = JSON.parse(JSON.stringify(a)); </code>// 深拷贝<br>// 如果是个对象有函数或者空值，<code>undefind</code>时会有问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的深拷贝</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>())</span><br><span class="line"><span class="comment">// 递归的实现复制一个对象或者数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(obj === <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> obj !=== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cloneObj= <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? []:&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    cloneObj[key]= <span class="title function_">clone</span>(obj[key])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h2><p>例如一次发出两个一模一样的请求如何清除一个，通过使用 <code>Axios</code> 的 <code>CancelToken</code> 和请求拦截器，如果已经有相同的请求在进行中，取消之前的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//axios封装</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.example.com&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 封装 GET 请求</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">url, params, cancelToken</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> instance.<span class="title function_">get</span>(url, &#123;params, cancelToken &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 封装 POST 请求</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">post</span> = (<span class="params">url, data, cancelToken</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> instance.<span class="title function_">post</span>(url, data, &#123; cancelToken &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;get,post,&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 CancelToken 取消重复请求</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">&#x27;./api&#x27;</span>; <span class="comment">// 上面封装的 Axios 实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pendingRequests = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">requestInterceptor</span> = (<span class="params">config</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; url, method, params, data &#125; = config;</span><br><span class="line">  <span class="comment">// 生成唯一标识符</span></span><br><span class="line">  <span class="keyword">const</span> key = <span class="string">`<span class="subst">$&#123;method&#125;</span>-<span class="subst">$&#123;url&#125;</span>-<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(params)&#125;</span>-<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">if</span> (pendingRequests.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">    <span class="comment">// 如果已经有相同的请求在进行中，取消之前的请求</span></span><br><span class="line">    <span class="keyword">const</span> cancelToken = pendingRequests.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="title function_">cancelToken</span>(<span class="string">&#x27;Request canceled due to duplicate request&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建新的取消令牌</span></span><br><span class="line">  <span class="keyword">const</span> source = <span class="title class_">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line">  config.<span class="property">cancelToken</span> = source.<span class="property">token</span>;</span><br><span class="line">  <span class="comment">// 将新的请求加入到 pendingRequests 中</span></span><br><span class="line">  pendingRequests.<span class="title function_">set</span>(key, source.<span class="property">cancel</span>);</span><br><span class="line">  <span class="comment">// 在请求完成后删除该请求</span></span><br><span class="line">  config.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      pendingRequests.<span class="title function_">delete</span>(key);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      pendingRequests.<span class="title function_">delete</span>(key);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(requestInterceptor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例请求</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetchUserData</span> = <span class="keyword">async</span> (<span class="params">userId</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123; &#125; <span class="keyword">catch</span> (error) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起两个相同的请求</span></span><br><span class="line"><span class="title function_">fetchUserData</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">fetchUserData</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="HTTPS的工作流程，HTTPS证书的验证"><a href="#HTTPS的工作流程，HTTPS证书的验证" class="headerlink" title="HTTPS的工作流程，HTTPS证书的验证"></a>HTTPS的工作流程，HTTPS证书的验证</h2><p><strong>客户端发起<code>HTTPS</code>请求：</strong>客户端向服务器发起HTTPS请求，并指定要访问的HTTPS资源的URL。<br><strong>服务器返回公钥证书：</strong>服务器将包含公钥的证书发送给客户端。<br><strong>客户端验证证书：</strong>客户端验证证书的合法性，包括证书<strong>是否由受信任的CA（证书颁发机构）签发、证书是否过期等</strong>。<br><strong>生成并发送对称加密密钥：</strong>如果证书验证通过，客户端将生成一个对称加密密钥，并使用服务器公钥对该密钥进行加密后发送给服务器。<br><strong>服务器解密对称加密密钥：</strong>服务器使用自己的私钥解密得到对称加密密钥。<br><strong>加密传输数据：</strong>双方使用协商好的对称加密密钥对传输的数据进行加密和解密。</p><h2 id="JSONP原理"><a href="#JSONP原理" class="headerlink" title="JSONP原理"></a>JSONP原理</h2><p>利用script标签 的 src 没有跨域限制的“漏洞” 来达到与第三方通讯的目的。只能处理get请求<br><strong>CORS：</strong>服务器端支持CORS主要通过设置<strong>Access-Control-Allow-Origin</strong>进行。浏览器检测到相应设置则允许Ajax跨域访问。</p><p><strong>vue中的跨域问题：</strong><br>找到配置文件config.js   <strong>修改<code>proxyTable</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxyTable</span>:</span><br><span class="line"><span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">  <span class="attr">target</span>: <span class="string">&#x27;http://www.xxxxxx.com/api&#x27;</span>，<span class="comment">//指定代理的地址</span></span><br><span class="line">  <span class="attr">changeOrigin</span>: <span class="literal">true</span>，<span class="comment">//是否允许跨越, 改变源到url，在虚拟主机上很有用</span></span><br><span class="line">  <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;/&#x27;</span>, <span class="comment">// 重写</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若后端地址不带路径’/api’, ‘http://www.xxxxxx.com/api’ 改为‘http://www.xxxxxx.com’</span></span><br></pre></td></tr></table></figure><h2 id="cookie、sessionStorage、localStorage的区别"><a href="#cookie、sessionStorage、localStorage的区别" class="headerlink" title="cookie、sessionStorage、localStorage的区别"></a>cookie、sessionStorage、localStorage的区别</h2><p>它们的区别在于存储的<strong>有效期和作用域的不同</strong><br><strong><code>cookie</code>：</strong>默认的，<strong>有效期很短，一旦用户关闭浏览器，Cookie保持的数据就会丢失；cookie存储空间比较小（ 4KB左右）</strong>。<br>为解决 HTTP 无状态的问题，常使用 Cookie 和 Session 等机制来在客户端和服务器之间保持状态。Cookie 是一种<em>在客户端存储少量数据并在每个请求中发送给服务器的机制，而 Session 则是在服务器端存储用户状态信息，并通过在客户端和服务器之间传递 Session ID 来保持会话状态</em>。<br><strong><code>localStorage</code>：存储的数据是永久性的， 除非手动删除；存储大小通常为5-10MB；作用域限制在文档源级别</strong>，同源的文档间共享同样的localStorage数据<br><strong><code>sessionStorage</code>：存储的数据存在会话期 ； 通常可以达到5MB左右；一旦窗口或者浏览器标签页关闭存储的数据也会被删除； 作用域也是限定在文档源中。</strong></p><h2 id="浏览器与服务器的交互原理"><a href="#浏览器与服务器的交互原理" class="headerlink" title="浏览器与服务器的交互原理"></a>浏览器与服务器的交互原理</h2><ol><li>输入网址</li><li>浏览器发送 http 请求</li><li>与dns 建立tcp/ip 3次握手</li><li>服务器 解析 并查找对应的域名</li><li>服务器相应数据返回</li><li>浏览器 下载 解析 服务器的响应数据</li><li>创建dom树 并解析css 与js 直到页面渲染完毕</li></ol><h2 id="A解释一下闭包，B为什么要使用闭包？-缺点"><a href="#A解释一下闭包，B为什么要使用闭包？-缺点" class="headerlink" title="A解释一下闭包，B为什么要使用闭包？ 缺点"></a>A解释一下闭包，B为什么要使用闭包？ 缺点</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> n =<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123; </span><br><span class="line">    n++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>闭包：</strong>以上代码中，b 函数访问了构造函数 a 里面的变量，所以形成了一个闭包<br><strong>使用闭包的原因：</strong>想要持续的使用一个变量，放在全局中会造成全局污染，放在函数中，函数执行完后会销毁，变量也随之销毁，因此需要使用闭包。<br><strong>拓展：</strong> 闭包函数是在<code>window</code>作用域下执行的，也就是说，<code>this</code>指向windows<br><strong>缺点 ：</strong>内存泄露问题， 所以不能滥用闭包</p><h2 id="解释一下作用域链"><a href="#解释一下作用域链" class="headerlink" title="解释一下作用域链"></a>解释一下作用域链</h2><p>函数A 嵌套函数B， 函数B嵌套函数C ：函数C里访问一个变量，先去C的作用域找 ，再往上一级找，直到window</p><h2 id="如何处理不让别人盗用你的图片，访问你的服务器资源？"><a href="#如何处理不让别人盗用你的图片，访问你的服务器资源？" class="headerlink" title="如何处理不让别人盗用你的图片，访问你的服务器资源？"></a>如何处理不让别人盗用你的图片，访问你的服务器资源？</h2><ul><li>对于 nginx，可考虑用 location 通配你的图片后缀，根据 refer，再决定是否返回图片资源。</li><li><strong>又拍云、七牛云</strong>都有<strong>防盗链配置</strong></li><li>若未使用 cdn，即需要自己做防盗链。<ul><li><strong>一是</strong>判断 <code>refer</code>，看来源是不是自己的网站，不是就拒绝。适用范围最大，也<strong>容易破解， 因为 refer 可以伪造</strong>。</li><li><strong>二是</strong> <code>session 校验</code>，若不通过特定服务生成 cookie 和 session 就不能请求得到资源。最保险，因为 session 在后端。</li></ul></li><li>给图片加水印</li></ul><h2 id="如何优化网站性能"><a href="#如何优化网站性能" class="headerlink" title="如何优化网站性能"></a>如何优化网站性能</h2><ul><li>许多<strong>小图片整合到一张大图片中</strong>（精灵图）减少网页http请求，以提升网页加载速度。对于小图标，可使用 base64 位编码，以减少网络请求。但不建议大图使用，比较耗费CPU； <strong>小图标优势</strong>在于：<strong>减少 HTTP 请求； 避免文件跨域； 修改及时生效</strong>。</li><li><strong>代码压缩</strong>，应用第三方资源库，cdn 托管</li><li><strong>控制资源文件加载优先级</strong>，css 优先，一般情况下都是CSS在头部，JS在底部。</li><li>利用浏览器<strong>缓存</strong></li><li><strong>减少页面重排</strong>，使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）；</li><li><strong>图片<code>lazyload</code> 懒加载</strong>，提高用户体验</li><li><strong>禁止使用gif图片实现loading效果</strong>（降低CPU消耗，提升渲染性能）；</li><li><strong>减少dom 操作，优化js</strong></li></ul>]]></content>
    
    
    <summary type="html">涵盖HTML、CSS和JavaScript等基础技术，通过DOM与BOM实现动态页面控制。</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="front end" scheme="https://southernfish.github.io/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://southernfish.github.io/2025/06/20/java/java-jvm/"/>
    <id>https://southernfish.github.io/2025/06/20/java/java-jvm/</id>
    <published>2025-06-20T04:58:36.000Z</published>
    <updated>2025-06-23T13:16:46.574Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E6%9C%BA/104440?fromModule=lemma_inlink">虚拟机</a>是一种抽象化的计算机，通过在实际的计算机上<a href="https://baike.baidu.com/item/%E4%BB%BF%E7%9C%9F%E6%A8%A1%E6%8B%9F/407213?fromModule=lemma_inlink">仿真模拟</a>各种计算机功能来实现的。<a href="https://baike.baidu.com/item/Java/85979?fromModule=lemma_inlink">Java</a>虚拟机有自己完善的<a href="https://baike.baidu.com/item/%E7%A1%AC%E4%BD%93/1298863?fromModule=lemma_inlink">硬体</a>架构，如处理器、<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032?fromModule=lemma_inlink">堆栈</a>、<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682?fromModule=lemma_inlink">寄存器</a>等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的<a href="https://baike.baidu.com/item/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81/9407934?fromModule=lemma_inlink">目标代码</a>（<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E7%A0%81/9953683?fromModule=lemma_inlink">字节码</a>），就可以在多种平台上不加修改地运行。本文简单记录一些关于JVM的问题。</p><h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="JVM-的主要组成部分？及其作用？"><a href="#JVM-的主要组成部分？及其作用？" class="headerlink" title="JVM 的主要组成部分？及其作用？"></a>JVM 的主要组成部分？及其作用？</h2><p>类加载器（<code>ClassLoader</code>）、运行时数据区（<code>Runtime Data Area</code>）、执行引擎（<code>Execution Engine</code>）、本地库接口（<code>Native Interface</code>）<br><strong>组件的作用：</strong> 首先通过类加载器（<code>ClassLoader</code>）<strong>把 Java 代码转换成字节码</strong>，然后运行时数据区（<code>Runtime Data Area</code>）再<strong>把字节码加载到内存</strong>中，而字节码文件只是 JVM 的一套指令集规范，不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（<code>Execution Engine</code>），<strong>将字节码翻译成底层系统指令</strong>，再<strong>交由 CPU 执行</strong>，而这个<strong>过程中需要调用其他语言的本地库接口</strong>（<code>Native Interface</code>）来实现整个程序的功能。</p><h2 id="JVM-运行时数据区？"><a href="#JVM-运行时数据区？" class="headerlink" title="JVM 运行时数据区？"></a>JVM 运行时数据区？</h2><p>不同虚拟机运行时数据区可能略微有所不同，但都会遵从Java 虚拟机规范，Java 虚拟机规范规定区域分为以下 5 个部分：<br><strong>程序计数器（<code>Program Counter Register</code>）：</strong>当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，<strong>分支、循环、跳转、异常处理、线程恢复等基础功能</strong>，都需要依赖这个计数器来完成；<br><strong>Java 虚拟机栈（<code>Java Virtual Machine Stacks</code>）：</strong>用于<strong>存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>；<br><strong>本地方法栈（<code>Native Method Stack</code>）：</strong>与虚拟机栈的作用一样，只不过虚拟机栈是服务 Java 方法的，而本地方法栈<strong>为虚拟机调用 Native 方法服务</strong>；<br><strong>Java 堆（<code>Java Heap</code>）：</strong>Java 虚拟机中<strong>内存最大的一块，被所有线程共享，几乎所有的对象实例都在这里分配内存</strong>；<br><strong>方法区（<code>Methed Area</code>）：</strong>用于<strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据</strong>。</p><h2 id="堆栈的区别？"><a href="#堆栈的区别？" class="headerlink" title="堆栈的区别？"></a>堆栈的区别？</h2><p><strong>功能方面：堆是用来存放对象的，栈是用来执行程序的</strong>。<br><strong>共享性：</strong>堆是线程共享的，<strong>栈是线程私有</strong>的。<br><strong>空间大小：</strong>堆大小远远大于栈。</p><h2 id="队列和栈是什么？有什么区别？"><a href="#队列和栈是什么？有什么区别？" class="headerlink" title="队列和栈是什么？有什么区别？"></a>队列和栈是什么？有什么区别？</h2><p>队列和栈都是被用来预存储数据的。<br><strong>队列</strong>允许<strong>先进先出检索元素</strong>，但也有例外的情况，Deque 接口<strong>允许从两端检索元素</strong>。<br><strong>栈</strong>和队列很相似，但它运行对元素进行<strong>后进先出进行检索</strong>。</p><h2 id="Java-中都有哪些引用类型？"><a href="#Java-中都有哪些引用类型？" class="headerlink" title="Java 中都有哪些引用类型？"></a>Java 中都有哪些引用类型？</h2><p><strong>强引用：</strong>发生 <em><code>gc</code> 的时候不会被回收</em>。<br><strong>软引用：</strong>有用但不是必须的对象，在发生<strong>内存溢出之前被回收</strong>。<br><strong>弱引用：</strong>有用但不是必须的对象，在<strong>下一次GC时被回收</strong>。<br><strong>虚引用(幽灵引用/幻影引用)：</strong>无法通过虚引用获得对象，用 <code>PhantomReference</code> 实现虚引用，虚引用的用途是在 <strong>gc 时返回一个通知</strong>。</p><h2 id="JVM-调优的工具？"><a href="#JVM-调优的工具？" class="headerlink" title="JVM 调优的工具？"></a>JVM 调优的工具？</h2><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 <code>jconsole</code> 和 <code>jvisualvm</code> 这两款视图监控工具。<br><strong><code>jconsole</code>：</strong>对 JVM 中的<strong>内存、线程和类等进行监控</strong>；<br><strong><code>jvisualvm</code>：</strong>JDK 自带的全能分析工具，可以分析：<strong>内存快照、线程快照、程序死锁、监控内存的变化、gc 变化</strong>等。</p><h2 id="常用的-JVM-调优的参数都有哪些？"><a href="#常用的-JVM-调优的参数都有哪些？" class="headerlink" title="常用的 JVM 调优的参数都有哪些？"></a>常用的 JVM 调优的参数都有哪些？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g：初始化推大小为 2g；</span><br><span class="line">-Xmx2g：堆最大内存为 2g；</span><br><span class="line">-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</span><br><span class="line">-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</span><br><span class="line">–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+PrintGC：开启打印 gc 信息；</span><br><span class="line">-XX:+PrintGCDetails：打印 gc 详细信息。</span><br></pre></td></tr></table></figure><h2 id="内存溢出的情况？"><a href="#内存溢出的情况？" class="headerlink" title="内存溢出的情况？"></a>内存溢出的情况？</h2><ul><li><strong><code>JVM Heap</code>（堆）溢出：</strong><code>java.lang.OutOfMemoryError: Java heap space</code><ul><li>JVM在启动的时候会自动设置 JVM Heap 的值， 可以利用JVM提供的<code>-Xmn -Xms -Xmx</code>等选项可进行设置。</li><li>Heap的大小是<code>Young Generation</code> 和<code>Tenured Generaion</code> 之和。</li><li>在JVM中如果98%的时间是用于GC，且可用的<code>Heap size</code> <strong>不足2%时</strong>将抛出此异常信息。</li></ul></li><li><strong>解决方法：</strong>手动设置JVM Heap（堆）的大小。</li><li><strong><code>Permanent Generation space</code>（内存的永久保存区域）溢出：</strong> <code>java.lang.OutOfMemoryError: PermGen space</code><ul><li>这块内存主要是被 JVM 存放 Class 和 Meta 信息的，Class在被Load的时候被放入 PermGen space 区域，它和存放 Instance 的Heap区域不同，sun 的 GC 不会在主程序运行期对<code>PermGen space</code>进行清理，所以如果你的 APP 会载入很多 CLASS 的话，就很可能出现 PermGen space 溢出。<strong>一般发生在程序的启动阶段</strong>。</li></ul></li><li><strong>解决方法</strong>： 通过<code>-XX:PermSize</code>和<code>-XX:MaxPermSize</code>设置永久代大小。</li><li><strong>栈溢出：</strong> <code>java.lang.StackOverflowError : Thread Stack space</code><ul><li>栈溢出了，JVM是采用栈式的虚拟机，这个和C和Pascal一样。<em>函数的调用过程都体现在堆栈和退栈上了。调用构造函数的 “层”太多以致于把栈区溢出了</em>。 一般栈区远远小于堆区，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K的空间（这大约相当于在一个C函数内声明了256个int变量），那么栈区也不过是需要1MB的空间。</li><li><strong>通常栈的大小是1-2MB</strong>。通俗点讲就是单线程的程序所需内存太大了。 通常<strong>递归也不要递归的层次过多</strong>，很容易溢出。</li></ul></li><li><strong>解决方法：</strong><ul><li><strong>修改程序</strong>。</li><li>通过 <strong><code>-Xss: </code>来设置每个线程的Stack大小</strong>。</li></ul></li></ul><hr><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h2 id="类加载器？"><a href="#类加载器？" class="headerlink" title="类加载器？"></a>类加载器？</h2><p><strong>类加载器：</strong><br>对于任意一个类，都需要<strong>由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性</strong>，每一个类加载器都有一个独立的类名称空间。类加载器根据指定<strong>全限定名称</strong>将 class 文件加载到 JVM 内存，然后再转化为 class 对象。<br><strong>类加载器分类：</strong></p><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）：是虚拟机自身的一部分，用来<strong>加载<code>Java_HOME/lib/目录</code>中的，或者被<code> -Xbootclasspath</code> 参数所指定的路径中并且被虚拟机识别的类库</strong>；</li><li>扩展类加载器（<code>Extension ClassLoader</code>）：负责加载<code>&lt;java_home style=”box-sizing: border-box; outline: 0px !important;”&gt;libext目录</code>或<code>Java. ext.dirs</code><strong>系统变量指定的路径中的所有类库</strong>；</li><li>应用程序类加载器（<code>Application ClassLoader</code>）：负责<strong>加载用户类路径（<code>classpath</code>）上的指定类库</strong>，我们可以直接使用这个类加载器。一般情况，如果没有自定义类加载器默认就是用这个加载器。</li></ul><p><strong>双亲委派模型：</strong><br>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是<strong>先把这个请求委派给父类加载器去完成</strong>，每一层的类加载器都是如此，这样所有的<strong>加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求</strong>（它的搜索范围中没找到所需的类）时，<strong>子加载器才会尝试去加载类</strong>。</p><h2 id="类装载的执行过程？"><a href="#类装载的执行过程？" class="headerlink" title="类装载的执行过程？"></a>类装载的执行过程？</h2><p>类装载分为以下 5 个步骤：</p><ul><li><strong>加载：</strong>根据查找路径<strong>找到相应的 class 文件然后导入</strong>；</li><li><strong>检查：</strong>检查加载的 class 文件的<strong>正确性</strong>；</li><li><strong>准备：</strong>给类中的<strong>静态变量分配内存空间</strong>；</li><li><strong>解析：</strong>虚拟机将<strong>常量池中的符号引用替换成直接引用</strong>的过程。<ul><li>符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li></ul></li><li><strong>初始化：</strong>对<strong>静态变量和静态代码块执行初始化工作</strong>。</li></ul><hr><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="怎么判断对象是否可以被回收？"><a href="#怎么判断对象是否可以被回收？" class="headerlink" title="怎么判断对象是否可以被回收？"></a>怎么判断对象是否可以被回收？</h2><p>一般有两种方法来判断：<br><strong>引用计数器：</strong>为每个对象创建一个引用计数，<strong>有对象引用时计数器 +1</strong>，引用被释放时计数 -1，当<strong>计数器为 0 时</strong>就可被回收。它有一个缺点不能解决循环引用问题；<br><strong>可达性分析：</strong>从 <code>GC Roots</code> 开始向下搜索，<strong>搜索所走过的路径</strong>称为<code>引用链</code>。当一个<strong>对象到 GC Roots 没有任何引用链相连时</strong>，则证明此对象是可以被回收的。</p><h2 id="JVM-有哪些垃圾回收算法？"><a href="#JVM-有哪些垃圾回收算法？" class="headerlink" title="JVM 有哪些垃圾回收算法？"></a>JVM 有哪些垃圾回收算法？</h2><p><strong>标记-清除算法：</strong>标记无用对象，然后进行清除回收。<strong>缺点：</strong>效率不高，<strong>无法清除垃圾碎片</strong>。<br><strong>标记-整理算法：</strong>标记无用对象，让所有<strong>存活的对象都向一端移动</strong>，然后直接<strong>清除端边界以外的内存</strong>。<br><strong>复制算法：</strong>按照容量划分两个大小相等的内存区域，当一块用完的时候<strong>将活着的对象复制到另一块</strong>上，然后再把<strong>已使用的内存空间一次清理掉</strong>。<em>缺点：</em>内存使用率不高，只有原来的一半。<br><strong>分代算法：</strong>根<strong>据对象存活周期的不同将内存划分为几块</strong>，一般是新生代和老年代，<strong>新生代基本采用复制算法，老年代采用标记整理算法</strong>。</p><h2 id="JVM-有哪些垃圾回收器？"><a href="#JVM-有哪些垃圾回收器？" class="headerlink" title="JVM 有哪些垃圾回收器？"></a>JVM 有哪些垃圾回收器？</h2><p><code>Serial</code>：最早的<strong>单线程串行</strong>垃圾回收器。<br><code>Serial Old</code>：Serial 垃圾回收器的老年版本，同样也是<strong>单线程</strong>的，可以作为 CMS 垃圾回收器的备选预案。<br><code>ParNew</code>：是 Serial 的<strong>多线程</strong>版本。<br><code>Parallel</code> ： <strong>多线程</strong>的， 使用<strong>复制的内存回收算法</strong>。但 Parallel 是<strong>吞吐量优先</strong>的收集器，可以牺牲等待时间换取系统的吞吐量。<br><code>Parallel Old</code>：是 Parallel 老生代版本，Parallel Old 使用<strong>标记-整理的内存回收算法</strong>。<br><code>CMS</code>：一种<strong>以获得最短停顿时间为目标</strong>的收集器，非常适用 B/S 系统。<br><code>G1</code>：一种<strong>兼顾吞吐量和停顿时间</strong>的 GC 实现，是 <strong>JDK 9 以后的默认 GC 选项</strong>。</p><h2 id="CMS-垃圾回收器？"><a href="#CMS-垃圾回收器？" class="headerlink" title="CMS 垃圾回收器？"></a>CMS 垃圾回收器？</h2><p>CMS 是英文 <code>Concurrent Mark-Sweep</code> 的简称，是<strong>以牺牲吞吐量为代价来获得最短回收停顿时间</strong>的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上<code>“-XX:+UseConcMarkSweepGC”</code>来指定使用 CMS 垃圾回收器。<br>CMS 使用的是<strong>标记-清除的算法</strong>实现的，所以在 gc 的时候<strong>会产生大量的内存碎片</strong>，当剩余内存不能满足程序运行要求时，系统将会出现 <code>Concurrent Mode Failure</code>，<strong>临时 CMS 会采用 Serial Old 回收器进行垃圾清除</strong>，此时的性能将会被降低。</p><h2 id="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h2><p><strong>新生代回收器：</strong><code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code><br><strong>老年代回收器：</strong><code>Serial Old</code>、<code>Parallel Old</code>、<code>CMS</code><br><strong>整堆回收器：</strong>G1<br>新生代垃圾回收器一般采用的是<strong>复制</strong>算法，复制算法的优点是<strong>效率高</strong>，缺点是<strong>内存利用率低</strong>；<br>老年代回收器一般采用的是<strong>标记-整理</strong>的算法进行垃圾回收。</p><h2 id="分代垃圾回收器是怎么工作的？"><a href="#分代垃圾回收器是怎么工作的？" class="headerlink" title="分代垃圾回收器是怎么工作的？"></a>分代垃圾回收器是怎么工作的？</h2><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。<br>新生代使用的是复制算法，新生代里有 3 个分区：<code>Eden</code>、<code>To Survivor</code>、<code>From Survivor</code>，它们的<strong>默认占比是 8:1:1</strong>。<br><strong>它的执行流程如下：</strong></p><ul><li>把 <code>Eden + From Survivor</code> 存活的对象放入 <code>To Survivor</code> 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor <strong>分区交换</strong>（From Survivor 变 To Survivor，To Survivor 变 From Survivor）</li><li>每次在 From Survivor 到 To Survivor <strong>移动时</strong>都存活的对象，<strong>年龄 +1</strong>，当<strong>年龄到达 15（默认配置是 15）时，升级为老生代</strong>。大对象也会直接进入老生代。</li><li>老生代空间占用到达某个值后就<strong>触发全局垃圾收回</strong>，一般使用<strong>标记整理</strong>执行算法。</li></ul><p>以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>]]></content>
    
    
    <summary type="html">本文简单记录一些关于JVM的问题。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://southernfish.github.io/2025/06/20/database/database-redis/"/>
    <id>https://southernfish.github.io/2025/06/20/database/database-redis/</id>
    <published>2025-06-20T02:15:36.000Z</published>
    <updated>2025-06-23T13:16:46.571Z</updated>
    
    <content type="html"><![CDATA[<p>Redis(Remote Dictionary Server)，远程字典服务，是用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，提供多种语言的API。</p><h2 id="Redis-是什么？都有哪些使用场景？"><a href="#Redis-是什么？都有哪些使用场景？" class="headerlink" title="Redis 是什么？都有哪些使用场景？"></a>Redis 是什么？都有哪些使用场景？</h2><p>Redis 是一个使<strong>用 C 语言开发的高速缓存数据库</strong>。Redis 使用场景如下：</p><ul><li>记录帖子点赞数、点击数、评论数</li><li>缓存近期热帖</li><li>缓存文章详情信息</li><li>记录用户会话信息</li></ul><h2 id="Redis-有哪些功能？"><a href="#Redis-有哪些功能？" class="headerlink" title="Redis 有哪些功能？"></a>Redis 有哪些功能？</h2><p>数据缓存功能、分布式锁的功能、支持数据持久化、支持事务、支持消息队列</p><h2 id="Redis-和-memcache-有什么区别？"><a href="#Redis-和-memcache-有什么区别？" class="headerlink" title="Redis 和 memcache 有什么区别？"></a>Redis 和 memcache 有什么区别？</h2><ul><li><strong>存储方式不同：</strong><code>memcache</code> 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；<code>Redis</code> 有<strong>部份存在硬盘上，这样能保证数据的持久性</strong>。</li><li><strong>数据支持类型：</strong>memcache 对数据类型支持相对简单；Redis 有<strong>复杂的数据类型</strong>。</li><li><strong>使用底层模型不同：</strong>它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，<strong>Redis 自己构建了 vm 机制</strong>，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li><strong>value 值大小不同：Redis 最大可以达到 512mb；</strong>memcache 只有 1mb。</li></ul><h2 id="Redis-为什么是单线程的？"><a href="#Redis-为什么是单线程的？" class="headerlink" title="Redis 为什么是单线程的？"></a>Redis 为什么是单线程的？</h2><p>因为 <strong>cpu 不是 Redis 的瓶颈</strong>，Redis 的瓶颈<strong>最有可能是机器内存或者网络带宽</strong>。既然<strong>单线程容易实现</strong>，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。<br>关于 <code>Redis</code> 的性能，官方网站也有，普通笔记本轻松处理<strong>每秒几十万的请求</strong>。<br>而且单线程并不代表就慢，<code>nginx</code> 和 <code>nodejs</code> 也都是高性能单线程的代表。</p><h2 id="Redis-支持的数据类型有哪些？"><a href="#Redis-支持的数据类型有哪些？" class="headerlink" title="Redis 支持的数据类型有哪些？"></a>Redis 支持的数据类型有哪些？</h2><p><code>string</code>（字符串）、<code>list</code>（列表）、<code>hash</code>（字典）、<code>set</code>（集合）、<code>zset</code>（有序集合）。</p><h2 id="哨兵和集群机制？"><a href="#哨兵和集群机制？" class="headerlink" title="哨兵和集群机制？"></a>哨兵和集群机制？</h2><p><code>Redis哨兵（Sentinel）</code>是一个高可用性解决方案。哨兵系统可以<strong>监测Redis主从服务器的健康状态，自动执行故障转移，选举新的主服务器，并通知应用程序新主服务器的地址</strong>。哨兵还负责通知管理员，发送警报，并执行自定义脚本响应各种事件。<br><code>Redis集群（Cluster）</code>提供了一个<strong>数据分区（sharding）和自动管理的环境，支持在多个节点间进行数据共享</strong>。它能够在<strong>节点间自动分配数据，并在节点故障时提供自动的故障转移功能</strong>。集群通过分片来提高数据库的可扩展性，并能在不中断服务的情况下，动态地添加或移除节点。</p><h2 id="jedis-和-Redisson-有哪些区别？"><a href="#jedis-和-Redisson-有哪些区别？" class="headerlink" title="jedis 和 Redisson 有哪些区别？"></a>jedis 和 Redisson 有哪些区别？</h2><p><code>jedis</code>：提供了比较全面的 Redis 命令的支持。<br><code>Redisson</code>：实现了<strong>分布式和可扩展的 Java 数据结构</strong>，与 jedis 相比 Redisson 的<strong>功能相对简单，不支持排序、事务、管道、分区等 Redis 特性</strong>。</p><h2 id="怎么保证缓存和数据库数据的一致性？"><a href="#怎么保证缓存和数据库数据的一致性？" class="headerlink" title="怎么保证缓存和数据库数据的一致性？"></a>怎么保证缓存和数据库数据的一致性？</h2><p><strong>合理设置缓存的过期时间</strong>。<br>新增、更改、删除数据库操作时<strong>同步更新 Redis</strong>，可以使<strong>用事务机制来保证数据的一致性</strong>。</p><h2 id="Redis-持久化有几种方式？"><a href="#Redis-持久化有几种方式？" class="headerlink" title="Redis 持久化有几种方式？"></a>Redis 持久化有几种方式？</h2><p><code>Redis 的持久化</code>有两种策略：<br><code>RDB（Redis Database）</code>：指定的时间间隔能对你的数据进行快照存储。<br><code>AOF（Append Only File）</code>：每一个收到的写命令都<strong>通过write函数追加到文件中</strong>。</p><h2 id="Redis-支持的-Java-客户端都有哪些？"><a href="#Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？"></a>Redis 支持的 Java 客户端都有哪些？</h2><p>支持的 Java 客户端有 <code>Redisson</code>、<code>jedis</code>、<code>lettuce</code> 等。</p><h2 id="Redis-如何做内存优化？"><a href="#Redis-如何做内存优化？" class="headerlink" title="Redis 如何做内存优化？"></a>Redis 如何做内存优化？</h2><p><strong>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储</strong>，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p><h2 id="Redis-常见的性能问题有哪些？该如何解决"><a href="#Redis-常见的性能问题有哪些？该如何解决" class="headerlink" title="Redis 常见的性能问题有哪些？该如何解决"></a>Redis 常见的性能问题有哪些？该如何解决</h2><p><strong>主服务器写内存快照，会阻塞主线程的工作</strong>，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以<strong>主服务器最好不要写内存快照</strong>。<br><code>Redis 主从复制</code>的性能问题，为了主从复制的速度和连接的稳定性，<strong>主从库最好在同一个局域网内</strong>。</p><h2 id="Redis-淘汰策略有哪些？"><a href="#Redis-淘汰策略有哪些？" class="headerlink" title="Redis 淘汰策略有哪些？"></a>Redis 淘汰策略有哪些？</h2><p><code>volatile-lru</code>：从已<strong>设置过期时间的数据集</strong>（<code>server.db[i].expires</code>）中挑选<strong>最近最少使用的数据</strong>淘汰。<br><code>volatile-ttl</code>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选<strong>将要过期的数据</strong>淘汰。<br><code>volatile-random</code>：从已设置过期时间的数据集（<code>server db[i].expires</code>）中<strong>任意选择数据</strong>淘汰。<br><code>allkeys-lru</code>：从<strong>数据集</strong>（<code>server.db[i].dict</code>）中挑选<strong>最近最少使用的数据</strong>淘汰。<br><code>allkeys-random</code>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。<br><code>no-enviction</code>（驱逐）：<strong>禁止驱逐数据</strong>。</p><h2 id="Redis的缓存穿透、缓存击穿、缓存雪崩"><a href="#Redis的缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="Redis的缓存穿透、缓存击穿、缓存雪崩"></a>Redis的缓存穿透、缓存击穿、缓存雪崩</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>缓存穿透：缓存和数据库中都没有的数据，可用户仍源源不断的发起请求</strong>，导致每次请求都到数据库，从而压垮数据库<br><strong>解决办法</strong></p><ul><li><strong>业务层校验</strong><ul><li>用户发过来的请求，<strong>根据请求参数进行校验</strong>，对于明显错误的参数，直接拦截返回。</li><li>如请求参数为主键自增id，那么对于请求小于0的id参数，可以直接返回错误请求。</li></ul></li><li><strong>不存在数据设置短过期时间</strong><ul><li>对于某个查询为空的数据，可以将这个空结果进行<code>Redis</code>缓存，但设置很短的过期时间，如30s，可以根据实际业务设定。</li></ul></li><li><strong>布隆过滤器</strong><ul><li>布隆过滤器是<strong>一种数据结构，利用极小的内存，可以判断大量的数据</strong>“一定不存在或者可能存在”。</li><li>对于缓存击穿，我们可以将查询的数据条件都哈希到一个足够大的布隆过滤器中，用户发送的<strong>请求会先被布隆过滤器拦截，一定不存在的数据就直接拦截返回了</strong>，从而避免下一步对数据库的压力。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620114220915.png" alt="image-20250620114220915"></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿：Redis中一个<code>热点key</code>在失效的同时，大量的请求过来</strong>，从而会全部到达数据库，压垮数据库。<br><strong>解决办法</strong></p><ul><li><strong>设置热点数据永不过期</strong><ul><li>对于某个需要频繁获取的信息，缓存在Redis中，并设置其永不过期。</li><li>当然这种方式比较粗暴，对于某些业务场景是不适合的。</li></ul></li><li><strong>定时更新</strong><ul><li>比如这个热点数据的过期时间是1h，那么每到59minutes时，</li><li>通过定时任务去更新这个热点key，并重新设置其过期时间。</li></ul></li><li><strong>互斥锁（常用</strong>）<ul><li>在<code>Redis</code>中根据key获得value为空时先锁上，再从数据库加载，加载完毕，释放锁。</li><li>若其他线程也在请求该key时，获取锁失败，则睡眠一段时间（如100ms）后重试。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620115506995.png" alt="image-20250620115506995"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>缓存雪崩：Redis中缓存的数据大面积同时失效，或者Redis宕机</strong>，从而会导致大量请求直接到数据库，压垮数据库。<br><strong>解决办法</strong></p><ul><li><strong>设置有效期均匀分布</strong><ul><li>避免缓存设置相近的有效期，我们可以在设置有效期时增加随机值；</li><li>或者统一规划有效期，使得过期时间均匀分布。</li></ul></li><li><strong>数据预热</strong><ul><li>对于即将来临的大量请求，我们可以提前走一遍系统，将数据提前缓存在Redis中，并设置不同的过期时间。</li></ul></li><li><strong>保证Redis服务高可用</strong><ul><li>为防止Redis集群单节点故障，可以通过哨兵模式和集群模式实现高可用。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620115530134.png" alt="image-20250620115530134"></p><hr><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="分布式锁？"><a href="#分布式锁？" class="headerlink" title="分布式锁？"></a>分布式锁？</h2><p><strong>分布式锁</strong></p><ul><li>控制分布式系统<strong>不同进程共同访问共享资源</strong>的一种锁的实现。</li><li>如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往<strong>需要互斥来防止彼此干扰，以保证一致性</strong>。</li></ul><p><strong>特征</strong></p><ul><li><code>互斥性</code>: 任意时刻，只有一个客户端能持有锁。</li><li><code>锁超时释放</code>：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。</li><li><code>可重入性</code>:一个线程如果获取了锁之后,可以再次对其请求加锁。</li><li><code>高性能和高可用</code>：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。</li><li><code>安全性</code>：锁只能被持有的客户端删除，不能被其他客户端删除。</li></ul><p><strong>Redis分布式锁</strong></p><ul><li>其实就是在系统里面<strong>占一个“坑”，其他程序也要占“坑”时，占用成功了就可继续执行，失败了只能放弃或稍后重试</strong>。</li></ul><h2 id="Redis-分布式锁有什么缺陷？"><a href="#Redis-分布式锁有什么缺陷？" class="headerlink" title="Redis 分布式锁有什么缺陷？"></a>Redis 分布式锁有什么缺陷？</h2><p>Redis 分布式锁不能解决超时的问题，分布式锁<strong>有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题</strong>。</p><h2 id="Redis分布式锁实现"><a href="#Redis分布式锁实现" class="headerlink" title="Redis分布式锁实现"></a>Redis分布式锁实现</h2><h3 id="方案一：SETNX-EXPIRE"><a href="#方案一：SETNX-EXPIRE" class="headerlink" title="方案一：SETNX + EXPIRE"></a>方案一：SETNX + EXPIRE</h3><p><strong>先用<code>setnx</code>来抢锁，抢到之后，再用<code>expire</code>给锁设置一个过期时间，防止锁忘记了释放</strong>。<br>SETNX 是<code>SET IF NOT EXISTS</code>的简写。命令格式是<code>SETNX key value</code>，若 key不存在，则SETNX成功返回1，若这个key已经存在，则返回0。<br>该方案中，setnx和expire两个命令分开了，<strong>不是原子操作</strong>。若执行完setnx加锁，正要执行expire设置过期时间时，进程crash或要重启维护了，那么这个锁就“长生不老”了，<strong>别的线程永远获取不到锁</strong>。<br>假设某电商网站的<strong>某商品做秒杀活动</strong>，key可以设置为<code>key_resource_id,value</code>设置任意值，<em>伪代码如下</em>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.setnx(key_resource_id, lock_value) == 1)&#123; // 加锁</span><br><span class="line">  expire(key_resource_id，100);// 设置过期时间</span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="keyword">do</span> something // 业务请求</span><br><span class="line">  &#125; <span class="function"><span class="title">catch</span></span>()&#123;</span><br><span class="line">    // ......</span><br><span class="line">  &#125; finally&#123;</span><br><span class="line">    jedis.del(key_resource_id); // 释放锁</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案二：SETNX-value值是-系统时间-过期时间"><a href="#方案二：SETNX-value值是-系统时间-过期时间" class="headerlink" title="方案二：SETNX + value值是(系统时间+过期时间)"></a>方案二：SETNX + value值是(系统时间+过期时间)</h3><p>为了<em>解决发生异常锁得不到释放的场景</em>，<strong>把过期时间放到<code>setnx</code>的<code>value</code>值里面</strong>。若加锁失败，再拿出value值校验一下即可</p><p>但这个方案有<strong>缺点</strong>：<br>过期时间是客户端自己生成的（<code>System.currentTimeMillis()</code>是当前系统的时间），要求分布式环境下，每个<strong>客户端的时间必须同步</strong>。<br>若锁过期的时候，并发多个客户端同时请求过来，都执行<code>jedis.getSet()</code>，最终只能有一个客户端加锁成功，但该客户端锁的过期时间，可能被别的客户端覆盖。<br><strong>该锁没有保存持有者的唯一标识，可能被别的客户端释放/解锁。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">long expires = System.currentTimeMillis() + expireTime;// 系统时间+设置的过期时间</span><br><span class="line">String expiresStr = String.value0f(expires);</span><br><span class="line">// 如果当前锁不存在，返回加锁成功</span><br><span class="line"><span class="keyword">if</span>(jedis.setnx(key resource <span class="built_in">id</span>,expiresStr) == 1)&#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 如果锁已经存在，获取锁的过期时间</span><br><span class="line">String currentValueStr = jedis.get(key resource <span class="built_in">id</span>);</span><br><span class="line">// 如果杂取到的过期时间，小于系统当前时间，表示已经过期</span><br><span class="line"><span class="keyword">if</span>(currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis())&#123;</span><br><span class="line">  // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span><br><span class="line">  String oldValueStr =jedis.getSet(key resource <span class="built_in">id</span>, expiresStr);</span><br><span class="line">  <span class="keyword">if</span>(oldValueStr != null &amp;&amp; oldValueStr.equals(currentValueStr))&#123;</span><br><span class="line">    // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 其他情况，均返回加锁失败</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="方案三：使用Lua脚本-包含SETNX-EXPIRE两条指令"><a href="#方案三：使用Lua脚本-包含SETNX-EXPIRE两条指令" class="headerlink" title="方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)"></a>方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)</h3><p>可以使用Lua脚本来保证原子性（包含<code>setnx</code>和<code>expire</code>两条指令）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// lua脚本如下：</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;setnx&#x27;</span>,KEYS[1],ARGV[1]) == 1 <span class="keyword">then</span></span><br><span class="line">   redis.call(<span class="string">&#x27;expire&#x27;</span>,KEYS[1],ARGV[2])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">return</span> 0</span><br><span class="line">end;</span><br><span class="line">// 加锁代码如下：</span><br><span class="line">String lua_scripts = <span class="string">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +</span><br><span class="line">        <span class="string">&quot; redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;   </span><br><span class="line">Object result = jedis.eval(lua_scripts, Collections.singletonList(key_resource_id), Collections.singletonList(values));</span><br><span class="line">//判断是否成功</span><br><span class="line"><span class="built_in">return</span> result.equals(1L);</span><br></pre></td></tr></table></figure><h3 id="方案四：SET的扩展命令（SET-EX-PX-NX）"><a href="#方案四：SET的扩展命令（SET-EX-PX-NX）" class="headerlink" title="方案四：SET的扩展命令（SET EX PX NX）"></a>方案四：SET的扩展命令（SET EX PX NX）</h3><p>巧用Redis的SET指令扩展参数，它也是原子性的！伪代码如下：<br><code>SET key value[EX seconds][PX milliseconds][NX|XX]</code></p><ul><li><code>NX</code>：表示key不存在时，才能set成功，也保证只有第一个客户端请求才能获得锁。其他客户端请求只能等其释放锁，才能获取。</li><li><code>EX seconds</code>：设定key的过期时间，时间单位是秒。</li><li><code>PX milliseconds</code>：设定key的过期时间，单位为毫秒</li><li><code>XX</code>：仅当key存在时设置值</li></ul><p>这个方案可能<strong>存在问题</strong>：</p><ul><li><strong>锁过期释放了，业务还没执行完</strong>。<ul><li>假设线程a获取锁成功，一直在执行临界区的代码。100s过去后，它还没执行完。但锁已过期，此时线程b请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么临界区的业务代码都不是严格串行执行的了。</li></ul></li><li><strong>锁被别的线程误删</strong><ul><li>假设线程a执行完后，去释放锁。但它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但线程b临界区业务代码可能都还没执行完。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.set(key_resource <span class="built_in">id</span>, lock_value, <span class="string">&quot;NX&quot;</span>,<span class="string">&quot;EX&quot;</span>，100s) == 1)&#123; // 加锁</span><br><span class="line">  try &#123;</span><br><span class="line">    // <span class="keyword">do</span> something 业务处理</span><br><span class="line">  &#125; <span class="function"><span class="title">catch</span></span>()&#123;</span><br><span class="line">    // ......</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    jedis.del(key_resource_id); // 释放锁</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案五：SET-EX-PX-NX-校验唯一随机值，再删除"><a href="#方案五：SET-EX-PX-NX-校验唯一随机值，再删除" class="headerlink" title="方案五：SET EX PX NX  + 校验唯一随机值，再删除"></a>方案五：SET EX PX NX  + 校验唯一随机值，再删除</h3><p>既然锁可能被别的线程误删，那我们<strong>给value值设置一个标记当前线程唯一的随机数，在删除的时候，校验一下</strong>，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.<span class="built_in">set</span>(key _resource id, uni_request id, <span class="string">&quot;NX&quot;</span>,<span class="string">&quot;EX&quot;</span>，<span class="number">100</span>s) == <span class="number">1</span>)&#123; <span class="comment">// 加锁</span></span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="comment">// do something 业务处理</span></span><br><span class="line">  &#125; catch()&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    <span class="comment">// 判断是不是当前线程加的锁, 是才释放</span></span><br><span class="line">    <span class="keyword">if</span>(uni request id.equals(jedis.get(key resource id)))&#123;</span><br><span class="line">      jedis.del(lockKey);<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断是不是当前线程加的锁 和 释放锁 不是原子操作</strong>。调用<code>jedis.del()</code>释放锁时，可能这把锁已经不属于当前客户端，会解除他人加的锁。<br>为了更严谨，用lua脚本代替。lua脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[1]) == ARGV[1] <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[1])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">return</span> 0</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h3 id="方案六：Redisson框架"><a href="#方案六：Redisson框架" class="headerlink" title="方案六：Redisson框架"></a>方案六：Redisson框架</h3><p><code>Redisson</code>框架下，只要线程加锁成功，就会启动一个<code>watch dog</code>看门狗（一个后台线程），每隔10秒检查一下，若线程1还持有锁，就会不断延长锁key的生存时间。因此，<code>Redisson</code><strong>解决了<em>锁过期释放，业务没执行完</em>问题</strong>。Redisson底层原理如图所示：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620122023110.png" alt="image-20250620122023110"></p><h3 id="方案七：多机实现的分布式锁Redlock-Redisson"><a href="#方案七：多机实现的分布式锁Redlock-Redisson" class="headerlink" title="方案七：多机实现的分布式锁Redlock+Redisson"></a>方案七：多机实现的分布式锁Redlock+Redisson</h3><p>前六种方案都是基于单机版。但Redis一般都是集群部署的（如图）：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620122038873.png" alt="image-20250620122038873"></p><p>若线程一在Redis的master节点上拿到了锁，但加锁的key还没同步到slave节点。恰好这时master节点发生故障，一个slave节点就会升级为master节点。线程二就可以获取同个key的锁，但线程一也已经拿到锁了，锁的安全性就没了。</p><h3 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h3><p><strong>Redlock核心思想：</strong><br>搞多个<code>Redis master</code>部署，以保证它们不会同时宕掉。并且<strong>这些master节点是完全相互独立的，相互之间不存在数据同步</strong>。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。<br><strong>RedLock的简化实现步骤：</strong></p><ul><li>按顺序向<code>N</code>（N=5）个master节点请求加锁</li><li>根据设置的超时时间来判断，是不是要跳过该master节点。</li><li>如果**大于等于<code>N/2+1</code>**（5/2+1=3）个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功。</li><li>如果获取锁失败，解锁！</li></ul><p><strong>RedLock的实现步骤：</strong></p><ul><li><p>获取当前时间，以毫秒为单位。</p></li><li><p>按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，且超时时间要小于锁的失效时间。</p><ul><li>（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间，就假设超时时间是50ms）。若超时则跳过该master节点，尽快尝试下一个master节点。</li></ul></li><li><p>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如图，10s&gt; 30ms+40ms+50ms+40ms+50ms）</p><ul><li><p>如果<strong>获取到了锁</strong>，key的真正有效时间就变了，需要减去获取锁所使用的时间。</p></li><li><p>如果<strong>获取锁失败</strong>（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也<strong>需要解锁</strong>，以防止有些漏网之鱼）。</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/1750393665152.png" alt="1750393665152"></p>]]></content>
    
    
    <summary type="html">‌Redis(Remote Dictionary Server)，远程字典服务，是用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，提供多种语言的API。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="Redis" scheme="https://southernfish.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Kafka and Zookeeper</title>
    <link href="https://southernfish.github.io/2025/06/19/middleware/kafka-zookeeper/"/>
    <id>https://southernfish.github.io/2025/06/19/middleware/kafka-zookeeper/</id>
    <published>2025-06-19T11:55:36.000Z</published>
    <updated>2025-06-23T13:16:46.575Z</updated>
    
    <content type="html"><![CDATA[<p>kafka的诞生，是为了解决linkedin的数据管道问题，起初linkedin采用了<a href="https://baike.baidu.com/item/ActiveMQ/7889688?fromModule=lemma_inlink">ActiveMQ</a>来进行<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2/1586256?fromModule=lemma_inlink">数据交换</a>，大约是在2010年前后，那时的ActiveMQ还远远无法满足linkedin对<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/56279193?fromModule=lemma_inlink">数据传递</a>系统的要求，经常由于各种缺陷而导致消息阻塞或者服务无法正常访问，为了能够解决这个问题，linkedin决定研发自己的消息传递系统，当时linkedin的<a href="https://baike.baidu.com/item/%E9%A6%96%E5%B8%AD%E6%9E%B6%E6%9E%84%E5%B8%88/10884085?fromModule=lemma_inlink">首席架构师</a>jay kreps便开始组织团队进行消息传递系统的研发。ZooKeeper是一个分布式的，<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E6%BA%90%E7%A0%81/7176422?fromModule=lemma_inlink">开放源码</a>的<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/9854429?fromModule=lemma_inlink">分布式应用程序</a>协调服务，是<a href="https://baike.baidu.com/item/Google/86964?fromModule=lemma_inlink">Google</a>的Chubby一个开源的实现，是<a href="https://baike.baidu.com/item/Hadoop/3526507?fromModule=lemma_inlink">Hadoop</a>和<a href="https://baike.baidu.com/item/Hbase/7670213?fromModule=lemma_inlink">Hbase</a>的重要组件。它是一个为<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8/1372598?fromModule=lemma_inlink">分布式应用</a>提供一致性服务的软件，提供的功能包括：配置维护、<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1/3352191?fromModule=lemma_inlink">域名服务</a>、分布式同步、组服务等。<br>Kafka 和 ZooKeeper 在分布式系统中扮演着不同的角色，并且它们之间有着紧密的合作关系。</p><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="Kafka是什么？"><a href="#Kafka是什么？" class="headerlink" title="Kafka是什么？"></a>Kafka是什么？</h2><p>‌<strong>Kafka</strong>‌是一个<strong>分布式流处理平台</strong>，最初由<code>LinkedIn</code>开发，后成为<code>Apache</code>开源项目。<code>Kafka</code>主要用于<strong>构建实时数据管道和流应用</strong>，具有高吞吐量、低延迟和可扩展性等特点‌。Kafka的<strong>核心功能</strong>包括：</p><ul><li>‌<strong>消息发布与订阅</strong>‌：Kafka允许应用程序发布和订阅消息流。</li><li>‌<strong>分布式日志</strong>‌：Kafka将数据持久化到磁盘，支持高吞吐量的数据收集。</li><li>‌<strong>流处理</strong>‌：支持复杂的流处理操作，如转换、过滤和聚合</li></ul><h2 id="kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>kafka 可以脱离 zookeeper 单独使用吗？为什么？</h2><p><code>kafka</code> 不能脱离 <code>zookeeper</code> 单独使用，因为 <strong>kafka 使用 zookeeper 管理和协调 kafka 的节点服务器</strong>。</p><h2 id="kafka-有几种数据保留的策略？"><a href="#kafka-有几种数据保留的策略？" class="headerlink" title="kafka 有几种数据保留的策略？"></a>kafka 有几种数据保留的策略？</h2><p>kafka 有<strong>两种</strong>数据保存策略：<strong>按照过期时间保留</strong>、<strong>按照存储的消息大小保留</strong>。</p><h2 id="kafka-设置了-7-天和-10G-清除数据，第五天消息达-10G，kafka-如何处理？"><a href="#kafka-设置了-7-天和-10G-清除数据，第五天消息达-10G，kafka-如何处理？" class="headerlink" title="kafka 设置了 7 天和 10G 清除数据，第五天消息达 10G，kafka 如何处理？"></a>kafka 设置了 7 天和 10G 清除数据，第五天消息达 10G，kafka 如何处理？</h2><p>这个时候 kafka 会执行数据清除工作，<strong>时间和大小不论那个满足条件，都会清空数据</strong>。</p><h2 id="什么情况会导致-kafka-运行变慢？"><a href="#什么情况会导致-kafka-运行变慢？" class="headerlink" title="什么情况会导致 kafka 运行变慢？"></a>什么情况会导致 kafka 运行变慢？</h2><p>cpu 性能瓶颈<br>磁盘读写瓶颈<br>网络瓶颈</p><h2 id="使用-kafka-集群需要注意什么？"><a href="#使用-kafka-集群需要注意什么？" class="headerlink" title="使用 kafka 集群需要注意什么？"></a>使用 kafka 集群需要注意什么？</h2><p>集群的数量不是越多越好，<strong>最好不要超过 7 个</strong>，因为<strong>节点越多</strong>，消息复制需要的时间就越长，<strong>整个群组的吞吐量就越低</strong>。<br>集群数量最好是<strong>单数</strong>，因为<strong>超过一半故障集群就不能用了，设置为单数容错率更高</strong>。</p><hr><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="zookeeper-是什么？"><a href="#zookeeper-是什么？" class="headerlink" title="zookeeper 是什么？"></a>zookeeper 是什么？</h2><p>‌<strong>ZooKeeper</strong>‌是一个开源的<strong>分布式协调服务</strong>，由<code>Apache</code>开发。它主要用于<strong>解决分布式系统中的一致性问题</strong>，如配置管理、节点选举和分布式锁等‌。<code>ZooKeeper</code>的<strong>主要功能</strong>包括：</p><ul><li>‌<strong>配置管理</strong>‌：集中管理分布式系统中的配置信息。</li><li>‌<strong>命名服务</strong>‌：提供唯一的命名服务，帮助分布式系统中的服务发现，客户端能根据指定名字获取资源或服务的地址，提供者等信息。</li><li>‌<strong>分布式锁</strong>‌：实现分布式环境中的锁机制。<code>zookeeper</code> 提供两种锁：<strong>独占锁、共享锁</strong>。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可有多个线程同时读同一个资源，若要使用写锁也只能有一个线程使用。</li><li>‌<strong>集群管理</strong>‌：管理集群中的节点，<strong>确保数据的一致性和系统的可靠性</strong>。监控节点存活状态、运行请求等。</li><li><strong>主节点选举：</strong>主节点挂掉了之后可以从备用的节点开始<strong>新一轮选主</strong>，使用 zookeeper 可以协助完成这个过程。</li></ul><h2 id="zookeeper-有几种部署模式？-三种"><a href="#zookeeper-有几种部署模式？-三种" class="headerlink" title="zookeeper 有几种部署模式？(三种)"></a>zookeeper 有几种部署模式？(三种)</h2><p><strong>单机部署：</strong>一台集群上运行；<br><strong>集群部署：</strong>多台集群运行；<br><strong>伪集群部署：</strong>一台集群启动多个 zookeeper 实例运行。</p><h2 id="zookeeper-怎么保证主从节点的状态同步？"><a href="#zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="zookeeper 怎么保证主从节点的状态同步？"></a>zookeeper 怎么保证主从节点的状态同步？</h2><p><code>zookeeper</code> 的核心是<strong>原子广播</strong>，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。<code>zab 协议</code>有两种模式，分别是<strong>恢复模式（选主）和广播模式（同步）</strong>。<em>当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了</em>。状态同步保证了 <code>leader</code> 和 <code>server</code> 具有相同的系统状态。</p><h2 id="集群中为什么要有主节点？"><a href="#集群中为什么要有主节点？" class="headerlink" title="集群中为什么要有主节点？"></a>集群中为什么要有主节点？</h2><p>在分布式环境中，<strong>有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果</strong>，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p><h2 id="集群中有-3-台服务器，一个节点宕机了，zookeeper-还可以用吗？"><a href="#集群中有-3-台服务器，一个节点宕机了，zookeeper-还可以用吗？" class="headerlink" title="集群中有 3 台服务器，一个节点宕机了，zookeeper 还可以用吗？"></a>集群中有 3 台服务器，一个节点宕机了，zookeeper 还可以用吗？</h2><p>可以继续使用，<strong>单数服务器只要没超过一半的服务器宕机就可以继续使用</strong>。</p><h2 id="zookeeper-的通知机制？"><a href="#zookeeper-的通知机制？" class="headerlink" title="zookeeper 的通知机制？"></a>zookeeper 的通知机制？</h2><p><strong>客户端会对某个 <code>znode</code> 建立一个 <code>watcher</code> 事件</strong>，当该 <code>znode</code> 发生变化时，这些客户端会<strong>收到 zookeeper 的通知</strong>，然后客户端可以<strong>根据 znode 变化来做出业务上的改变</strong>。</p><h2 id="Kafka与ZooKeeper的关系"><a href="#Kafka与ZooKeeper的关系" class="headerlink" title="Kafka与ZooKeeper的关系"></a>Kafka与ZooKeeper的关系</h2><p><code>Kafka</code>依赖<code> ZooKeeper</code>来管理集群元数据、控制器选举和消费者组协调等任务。ZooKeeper 为 Kafka 提供了选主（<code>leader election</code>）、集群成员管理等核心功能，<strong>确保Kafka能够在多个节点之间进行有效的通信和管理‌</strong>。随着 Kafka 的发展，其对 ZooKeeper的依赖也带来了一些问题：</p><ul><li>‌<strong>复杂性增加</strong>‌：ZooKeeper 是一个独立的外部组件，增加了运维的复杂度。</li><li>‌<strong>性能瓶颈</strong>‌：在高负载情况下，ZooKeeper 可能成为系统的瓶颈，限制Kafka的扩展能力。</li><li>‌<strong>一致性问题</strong>‌：Kafka内部的一致性模型与 ZooKeeper 的一致性模型有所不同，可能导致状态不一致，影响系统的稳定性和消息传递的可靠性‌。</li></ul>]]></content>
    
    
    <summary type="html">‌Kafka 和 ZooKeeper 在分布式系统中扮演着不同的角色，并且它们之间有着紧密的合作关系。</summary>
    
    
    
    <category term="Middleware" scheme="https://southernfish.github.io/categories/Middleware/"/>
    
    <category term="Distributed" scheme="https://southernfish.github.io/categories/Middleware/Distributed/"/>
    
    
    <category term="Kafka" scheme="https://southernfish.github.io/tags/Kafka/"/>
    
    <category term="Zookeeper" scheme="https://southernfish.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="https://southernfish.github.io/2025/06/19/database/database-sql/"/>
    <id>https://southernfish.github.io/2025/06/19/database/database-sql/</id>
    <published>2025-06-19T11:55:36.000Z</published>
    <updated>2025-06-23T13:16:46.572Z</updated>
    
    <content type="html"><![CDATA[<p>数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。数据库软件有着整体性和共享性的特点。</p><h2 id="数据库的三范式是什么？"><a href="#数据库的三范式是什么？" class="headerlink" title="数据库的三范式是什么？"></a>数据库的三范式是什么？</h2><p><strong>第一范式：</strong>强调的是<strong>列的原子性</strong>，即数据库表的每一列都是不可分割的原子数据项。<br><strong>第二范式：</strong>要求实体的属性<strong>完全依赖于主关键字</strong>。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。<br><strong>第三范式：</strong>任何<strong>非主属性不依赖于其它非主属性</strong>。</p><h2 id="一自增表共-7-条数据，删了最后-2-条，重启-MySQL后插入一条，此时-id-？"><a href="#一自增表共-7-条数据，删了最后-2-条，重启-MySQL后插入一条，此时-id-？" class="headerlink" title="一自增表共 7 条数据，删了最后 2 条，重启 MySQL后插入一条，此时 id ？"></a>一自增表共 7 条数据，删了最后 2 条，重启 MySQL后插入一条，此时 id ？</h2><p>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p><h2 id="char-和-varchar-的区别是什么？"><a href="#char-和-varchar-的区别是什么？" class="headerlink" title="char 和 varchar 的区别是什么？"></a>char 和 varchar 的区别是什么？</h2><p><strong>char(n) ：</strong>固定长度类型，如 char(10)，当输入”abc”三个字符时，它们占的空间还是 10 个字节，其他 7 个是空字节。</p><ul><li><strong>优点：</strong>效率高；</li><li><strong>缺点：</strong>占用空间；</li><li><strong>适用场景：</strong>存储密码的 md5 值，固定长度的，使用 char 非常合适。</li></ul><p><strong>varchar(n) ：</strong>可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p><ul><li>从<strong>空间</strong>上考虑 varcahr 比较合适；</li><li>从<strong>效率</strong>上考虑 char 比较合适，二者使用需要权衡。</li></ul><h2 id="如何获取当前数据库版本？"><a href="#如何获取当前数据库版本？" class="headerlink" title="如何获取当前数据库版本？"></a>如何获取当前数据库版本？</h2><p>使用 select version() 获取当前 MySQL 数据库版本。</p><h2 id="float-和-double-的区别是什么？"><a href="#float-和-double-的区别是什么？" class="headerlink" title="float 和 double 的区别是什么？"></a>float 和 double 的区别是什么？</h2><p><strong><code>float</code></strong> 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br><strong><code>double</code></strong> 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p><h2 id="MySQL-的内连接、左连接、右连接有什么区别？"><a href="#MySQL-的内连接、左连接、右连接有什么区别？" class="headerlink" title="MySQL 的内连接、左连接、右连接有什么区别？"></a>MySQL 的内连接、左连接、右连接有什么区别？</h2><p>内连接：<code>inner join</code>；左连接：<code>left join</code>；右连接：<code>right join</code>。<br>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h2 id="怎么验证-MySQL-的索引是否满足需求？"><a href="#怎么验证-MySQL-的索引是否满足需求？" class="headerlink" title="怎么验证 MySQL 的索引是否满足需求？"></a>怎么验证 MySQL 的索引是否满足需求？</h2><p>使用 <code>explain</code> 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。<br><strong>explain 语法：</strong><code>explain select * from table where type=1</code>。</p><h2 id="数据库的事务隔离？"><a href="#数据库的事务隔离？" class="headerlink" title="数据库的事务隔离？"></a>数据库的事务隔离？</h2><p>MySQL 的事务隔离是在 <code>MySQL. ini</code> 配置文件里添加的，在文件的最后添加：<br>    transaction-isolation = REPEATABLE-READ<br><strong>可用的配置值：</strong><code>READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE</code>。</p><ul><li><code>READ-UNCOMMITTED</code>：<strong>读未提交</strong>，事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li><li><code>READ-COMMITTED</code>：<strong>读提交</strong>，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li><li><code>REPEATABLE-READ</code>：<strong>可重复读</strong>，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</li><li><code>SERIALIZABLE</code>：<strong>序列化</strong>，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><p><strong>脏读：</strong>表示一个事务能够读取另一个事务中还未提交的数据。<br><strong>不可重复读：</strong>是指在一个事务内，多次读同一数据。<br><strong>幻读：</strong>指同一个事务内多次查询返回的结果集不一样。发生<strong>幻读的原因</strong>是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所以数据行的记录就变多或者变少了。</p><ul><li><em>MySQL默认使用的是“可重复读”隔离级别，SQL标准的默认隔离级别是“读提交”</em>。</li><li>MySQL在“可重复读”级别下通过<strong>多版本并发控制（MVCC）机制避免幻读</strong>的问题。</li></ul><h2 id="MySQL-常用的引擎？"><a href="#MySQL-常用的引擎？" class="headerlink" title="MySQL 常用的引擎？"></a>MySQL 常用的引擎？</h2><p><code>InnoDB 引擎</code>：mysql 5.1 后默认的数据库引擎，提供了对数据库 <strong>acid 事务的支持</strong>，并且还提供了<strong>行级锁和外键的约束</strong>，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在<strong>内存中建立缓冲池，用于缓冲数据和索引</strong>。但该引擎<em>不支持全文搜索，同时启动也比较慢，它不会保存表的行数</em>，所以当进行 <code>select count(*) from table</code> 指令时，需要进行扫描全表。由于锁的粒度小，写操作不会锁定全表,所以<strong>在并发度较高的场景下使用会提升效率</strong>。<br><code>MyIASM 引擎</code>：<strong>不提供事务的支持，也不支持行级锁和外键</strong>。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是<strong>保存了表的行数</strong>，于是当进行 <code>select count(*) from table</code> 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p><h2 id="MySQL-的行锁和表锁？"><a href="#MySQL-的行锁和表锁？" class="headerlink" title="MySQL 的行锁和表锁？"></a>MySQL 的行锁和表锁？</h2><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。<br><strong>表级锁：</strong>开销小，加锁快，不会出现死锁。锁粒度大，发生锁冲突的概率最高，并发量最低。<br><strong>行级锁：</strong>开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高。</p><h2 id="乐观锁和悲观锁？"><a href="#乐观锁和悲观锁？" class="headerlink" title="乐观锁和悲观锁？"></a>乐观锁和悲观锁？</h2><p><strong>乐观锁：</strong>每次拿数据时都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br><strong>悲观锁：</strong>每次拿数据时都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。采用数据库自身的<code>for update</code>能力，对数据库表或者行增加锁<br><em>数据库的乐观锁需要自己实现</em>，在表里面<strong>添加一个 <code>version</code> 字段，每次修改成功值加 1</strong>，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><h2 id="MySQL-问题排查都有哪些手段？"><a href="#MySQL-问题排查都有哪些手段？" class="headerlink" title="MySQL 问题排查都有哪些手段？"></a>MySQL 问题排查都有哪些手段？</h2><p>使用 <code>show processlist</code> 命令查看当前所有连接信息。<br>使用 <code>explain</code> 命令查询 SQL 语句执行计划。<br>开启<strong>慢查询日志</strong>，查看慢查询的 SQL。</p><h2 id="如何做-SQL-优化？"><a href="#如何做-SQL-优化？" class="headerlink" title="如何做 SQL 优化？"></a>如何做 SQL 优化？</h2><p><strong>一、避免不走索引的场景</strong></p><ul><li>尽量<strong>避免在字段开头模糊查询</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>尽量**避免使用<code>not in</code>**，会导致引擎走全表扫描。</li><li>尽量<strong>避免使用 or</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>尽量<strong>避免进行null值的判断</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>尽量<strong>避免在where条件中等号的左侧进行表达式、函数操作</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>数据量大时，**避免使用<code>where 1 = 1</code>**。通常为方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引做全表扫描。</li><li>查询条件<strong>不能用 &lt;&gt; 或者 !=</strong></li><li>隐式类型转换造成不使用索引</li><li><strong><code>order by</code> 条件要与<code>where</code>中条件一致</strong>，否则order by不会利用索引进行排序</li><li><strong>正确使用<code>hint</code>优化语句</strong></li></ul><p><strong>二、SELECT语句其他优化</strong></p><ul><li><strong>避免出现select</strong></li><li><strong>避免出现不确定结果的函数</strong></li><li>多表关联查询时，<strong>小表在前，大表在后</strong>。</li><li>使用<strong>表的别名</strong></li><li>尽可能<strong>用<code>where</code>子句替换<code>HAVING</code>子句中的条件</strong></li></ul><h2 id="MySQL数据中有很多换行符和回车符怎么办？"><a href="#MySQL数据中有很多换行符和回车符怎么办？" class="headerlink" title="MySQL数据中有很多换行符和回车符怎么办？"></a>MySQL数据中有很多换行符和回车符怎么办？</h2><p><strong>换行符：</strong>CHAR(10) = “\n”<br><strong>回车符：</strong> CHAR(13) = “\r”<br>在MySQL中，回车符、换行符都属于char类型，放到varchar中时，在navcat等插件上是不显示的，需要在mysql终端和navcat对比才能看出来。</p><p><strong>如何去掉换行符、回车符</strong>。如果条件允许，建议<strong>直接通过语句清除掉换行符和回车符</strong>，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 去除<span class="string">&quot;hero title&quot;</span>列中所有换行符 (通过以下两种方式都可以)</span><br><span class="line">update <span class="string">&#x27;LOL&#x27;</span> <span class="built_in">set</span> hero_title = REPLACE(hero_title, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">update <span class="string">&#x27;LOL&#x27;</span> <span class="built_in">set</span> hero_title = REPLACE(hero_title, char(10), <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">// 去除<span class="string">&quot;hero title&quot;</span>列中所有回车符</span><br><span class="line">update <span class="string">&#x27;LOL&#x27;</span> <span class="built_in">set</span> hero_title = REPLACE(hero_title, <span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">update <span class="string">&#x27;LOL&#x27;</span> <span class="built_in">set</span> hero_title = REPLACE(hero_title, char(13),<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>如何忽略”换行符、回车符”进行SELECT查询</strong>。条件不允许，不能动库里的数据。可以通过修改SQL来<strong>过滤掉换行符、回车符，但一定程度上会影响查询效率</strong>，而且要改很多代码，你懂得。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 忽略掉换行符查询</span><br><span class="line">SELECT * from <span class="string">&#x27;LOL&#x27;</span> <span class="built_in">where</span> REPLACE(hero_title, char(10), <span class="string">&#x27;&#x27;</span>) = <span class="string">&#x27;换行符换行符换行符’; </span></span><br><span class="line"><span class="string">// 忽略掉回车符查询</span></span><br><span class="line"><span class="string">SELECT * from &#x27;</span>LOL<span class="string">&#x27; where REPLACE(hero_title, char(13), &#x27;</span><span class="string">&#x27;) =&#x27;</span>回车符回车符回车符’;</span><br><span class="line">// 忽略掉换行符 &amp; 回车符查询</span><br><span class="line">SELECT * from <span class="string">&#x27;LOL&#x27;</span> <span class="built_in">where</span> REPLACE(REPLACE(hero_title, char(13), <span class="string">&#x27;&#x27;</span>), char(18),<span class="string">&#x27;&#x27;</span>) = <span class="string">&#x27;回车符回车符回车符’;</span></span><br></pre></td></tr></table></figure><h2 id="int-20-中20的涵义"><a href="#int-20-中20的涵义" class="headerlink" title="int(20)中20的涵义"></a>int(20)中20的涵义</h2><p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；<br>不影响内部存储，只是<strong>影响带 zerofill 定义的 int 时，前面补多少个 0</strong>，易于报表展示</p><h2 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h2><ul><li>数据定义语言DDL（<code>Data Definition Language</code>）CREATE，DROP，ALTER<ul><li>对<strong>逻辑结构</strong>等有操作的，其中包括表结构，视图和索引。</li></ul></li><li>数据查询语言DQL（<code>Data Query Language</code>）SELEC<ul><li>即<strong>查询</strong>操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</li></ul></li><li>数据操纵语言DML（<code>Data Manipulation Language</code>）INSERT，UPDATE，DELETE<ul><li>对<strong>数据</strong>进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。</li></ul></li><li>数据控制功能DCL（<code>Data Control Languag</code>e）GRANT，REVOKE，COMMIT，ROLLBACK<ul><li>对<strong>数据库安全性完整性</strong>等有操作的，可以简单的理解为<strong>权限控制</strong>等。</li></ul></li></ul><h2 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a>SQL 约束有哪几种？</h2><p><code>NOT NULL</code>：用于控制字段的内容一定不能为空（NULL）。<br><code>UNIQUE</code>：控件<strong>字段内容不能重复</strong>，一个表<strong>允许有多个 Unique 约束</strong>。<br><code>PRIMARY KEY</code>：控件<strong>字段内容不能重复</strong>，但它在一个表只允许出现一个。<br><code>FOREIGN KEY</code>：用于<strong>预防破坏表之间连接的动作，也能防止非法数据插入外键列</strong>，因为它必须是它指向表中的值之一。<br><code>CHECK</code>：用于<strong>控制字段的值范围</strong>。</p><h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><p>在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p><table><thead><tr><th></th><th><strong>delete</strong></th><th><strong>truncate</strong></th><th><strong>drop</strong></th></tr></thead><tbody><tr><td>类型</td><td>DML</td><td>DDL</td><td>DDL</td></tr><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除表的全部或者一部分数据行，不释放空间，不重置自增列</td><td>表结构还在，删除表方全部数据，重置自增列，释放空间</td><td>删除表结构、数据、索引、约束等全部内容，释放空间，表不复存在</td></tr></tbody></table><hr><h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><h2 id="ACID-是什么？"><a href="#ACID-是什么？" class="headerlink" title="ACID 是什么？"></a>ACID 是什么？</h2><p><strong><code>Atomicity</code>（原子性）：</strong>一个事务（<code>transaction</code>）中的所有操作，<strong>或全部完成，或全部不完成</strong>，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（<code>Rollback</code>）到事务开始前的状态，就像这个事务从来没有执行过一样。即<strong>事务不可分割、不可约简</strong>。<br><strong><code>Consistency</code>（一致性）：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示<strong>写入的资料必须完全符合所有的预设约束、触发器、级联回滚</strong>等。<br><strong><code>Isolation</code>（隔离性）：</strong>数据库<strong>允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致</strong>。事务隔离分为不同级别，包括读未提交（<code>Read uncommitted</code>）、读提交（<code>read committed</code>）、可重复读（<code>repeatable read</code>）和串行化（<code>Serializable</code>）。<br><strong><code>Durability</code>（持久性）：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</p><h2 id="ACID-原子性：MySQL通过使用日志文件来实现事务的原子性？"><a href="#ACID-原子性：MySQL通过使用日志文件来实现事务的原子性？" class="headerlink" title="ACID-原子性：MySQL通过使用日志文件来实现事务的原子性？"></a>ACID-原子性：MySQL通过使用日志文件来实现事务的原子性？</h2><p><strong>日志刷盘</strong><br>当一个事务开始时，InnoDB会为该事务分配一个<strong>唯一事务ID</strong>，并开始<strong>记录重做日志和回滚日志</strong>。随着事务的执行，所有的数据修改都会<strong>先写入到重做日志缓冲区</strong>中，然后在适当时机，<strong>这些修改会被刷新到磁盘上的重做日志文件中</strong>。如果系统崩溃，重做日志将被用来重做事务，确保事务的修改被应用到数据库中。<br><strong>Redo Log</strong><br>事务执行过程中发生错误或系统故障时，如果数据修改已经写入重做日志缓冲区中，在适当的时机（系统恢复时），这些修改会被刷新到磁盘上的重做日志文件中。<br><strong>Undo Log</strong><br>在事务执行过程中发生错误或系统故障，且无法通过**<code>Redo Log</code>** 保证数据一致性和完整性，MySQL将<strong>利用日志来回滚事务中的所有操作</strong>，保证数据库的原子性不被破坏。</p><h2 id="ACID-一致性：MySQL通过几种机制来保证数据的一致性？"><a href="#ACID-一致性：MySQL通过几种机制来保证数据的一致性？" class="headerlink" title="ACID-一致性：MySQL通过几种机制来保证数据的一致性？"></a>ACID-一致性：MySQL通过几种机制来保证数据的一致性？</h2><p><strong>约束（<code>Constraints</code>）：</strong>MySQL允许定义各种约束（如<strong>主键约束、外键约束、唯一约束</strong>等），这些约束直接作用于数据表上，确保数据的完整性和一致性。<br><strong>事务隔离级别（<code>Transaction Isolation Levels</code>）：</strong>通过合理选择事务隔离级别，可以在并发环境下有效地维护数据的一致性。读未提交（<code>Read Uncommitted</code>）、读提交（<code>Read Committed</code>）、可重复读（<code>Repeatable Read</code>）、串行化（<code>Serializable</code>）<br><strong>锁定机制（<code>Locking Mechanisms</code>）：</strong>MySQL使用锁定机制来<strong>控制对数据的并发访问</strong>，包括<em>行级锁（<code>Row-Level Locks</code>）、表级锁（<code>Table Locks</code>）</em>等，以确保在并发事务中数据的一致性和完整性。<br><strong>原子性操作（<code>Atomic Operations</code>）：</strong>MySQL通过原子性操作确保事务中的所有操作<strong>要么全部成功，要么全部失败</strong>，从而保持数据的一致性。</p><h2 id="ACID-持久性：MySQL中保证数据持久性的技术？"><a href="#ACID-持久性：MySQL中保证数据持久性的技术？" class="headerlink" title="ACID-持久性：MySQL中保证数据持久性的技术？"></a>ACID-持久性：MySQL中保证数据持久性的技术？</h2><ul><li>日志文件<ul><li><strong>重做日志（<code>Redo Log</code>）：</strong>InnoDB存储引擎使用重做日志来保证事务的持久性。事务提交时，事务所做的所有<strong>修改都会被记录到重做日志</strong>中。即使数据库发生崩溃，重做日志也可以在重启后被用来重放这些修改，确保数据的持久性。</li><li><strong>二进制日志（<code>Binary Log</code>）：</strong>MySQL服务器使用<strong>二进制日志记录所有修改数据库数据的操作</strong>，如<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>等。二进制日志不仅对数据恢复至关重要，也是复制和增量备份的基础。</li></ul></li><li>备份策略<ul><li><strong>全量备份：</strong>定期对整个数据库进行完整备份，以确保数据的持久性和可恢复性。</li><li><strong>增量备份：仅备份自上次备份以来发生变化的数据</strong>。与全量备份结合使用，可以有效减少数据恢复时间和存储需求。</li><li><strong>点对点恢复（<code>Point-in-Time Recovery, PITR</code>）：</strong>使用二进制日志实现，可以<strong>将数据库恢复到特定时间点的状态</strong>，非常适合处理操作错误或数据损坏的情况。</li></ul></li></ul><h2 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h2><p>有三种格式，statement，row和mixed。</p><ul><li><strong><code>statement</code>模式</strong>下，每一条会<strong>修改数据的sql都会记录在<code>binlog</code>中</strong>。不需要记录每一行的变化，<strong>减少了binlog日志量，节约了IO，提高性能</strong>。由于sql的执行是有上下文的，因此在<strong>保存的时候需要保存相关的信息</strong>，同时还有一些使用了函数之类的语句无法被记录复制。</li><li><strong><code>row</code>级别</strong>下，不记录sql语句上下文相关信息，仅<strong>保存哪条记录被修改。记录单元为每一行的改动</strong>，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件<strong>保存的信息太多，日志量太大</strong>。</li><li><strong><code>mixed</code><strong>，一种折中的方案，</strong>普通操作使用statement记录，当无法使用statement的时候使用row</strong>。</li></ul><p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="MySQL-索引是怎么实现的？"><a href="#MySQL-索引是怎么实现的？" class="headerlink" title="MySQL 索引是怎么实现的？"></a>MySQL 索引是怎么实现的？</h2><p>索引是<strong>满足某种特定查找算法的数据结构</strong>，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 <strong><code>B+ 树</code><strong>实现的，</strong><code>B+ 树</code>的搜索效率，可到达二分法的性能</strong>，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p><h2 id="创建索引的原则有哪些？"><a href="#创建索引的原则有哪些？" class="headerlink" title="创建索引的原则有哪些？"></a>创建索引的原则有哪些？</h2><ul><li><strong>最左前缀匹配原则</strong>，组合索引非常重要的原则，mysql会一直**向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配**，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li><strong>较频繁作为查询条件的字段</strong>才去创建索引</li><li>更新频繁字段不适合创建索引</li><li><strong>不能有效区分数据的列不适合做索引列</strong>(如性别，男女未知，最多也就三种，区分度实在太低)</li><li>尽量的<strong>扩展索引，不要新建索引</strong>。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li><li><strong>定义有外键的数据列</strong>一定要建立索引。</li><li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li><li>对于定义为text、image和bit的数据类型的列不要建立索引。</li></ul><hr><h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><h2 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h2><p><strong><code>InnoDB</code>索引是聚簇索引</strong>，MyISAM索引是非聚簇索引。<br><code>InnoDB</code>的<strong>主键索引的叶子节点存储着行数据</strong>，因此主键索引非常高效。<br><strong><code>MyISAM</code>索引的叶子节点存储的是行数据地址</strong>，需要再寻址一次才能得到数据。<br><strong>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据</strong>，因此查询时做到覆盖索引会非常高效。</p><h2 id="mysql-innodb存储引擎的特点"><a href="#mysql-innodb存储引擎的特点" class="headerlink" title="mysql innodb存储引擎的特点"></a>mysql innodb存储引擎的特点</h2><p><strong>事务支持：</strong>InnoDB支持ACID事务属性。<br><strong>崩溃恢复</strong>：InnoDB会<strong>将数据写入到磁盘上的日志文件</strong>中，即使在系统崩溃的情况下，也能通过这些日志文件恢复数据。<br><strong>MVCC (多版本并发控制)：</strong>InnoDB使用多版本并发控制，这允许更高的并发性。<br><strong>外键约束：</strong>InnoDB支持外键约束，这对于维护数据库的引用完整性非常有用。<br><strong>行级锁定：</strong>与表级锁定相比，InnoDB<strong>支持行级锁定，提供了更高的并发性能</strong>。<br><strong>自适应哈希索引：</strong>InnoDB会<strong>自动为频繁访问的热点数据创建哈希索引，以提高查询速度</strong>。</p><h2 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h2><p>推荐使用自增ID，不要使用UUID。<br>在InnoDB存储引擎中，主键索引是作为<strong>聚簇索引</strong>存在的，主键索引的<code>B+树</code>叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，只需要不断向后排列即可，如果是*<code>UUID</code>，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降*。<br>总之，在数据量大一些的情况下，用自增主键性能会好一些。<br>主键是聚簇索引，若没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个<strong>隐式的主键</strong>。</p><h2 id="如何使用InnoDB？"><a href="#如何使用InnoDB？" class="headerlink" title="如何使用InnoDB？"></a>如何使用InnoDB？</h2><p>在创建表时指定使用InnoDB存储引擎，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE example (</span><br><span class="line">    <span class="built_in">id</span> INT AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (<span class="built_in">id</span>)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h2 id="优化InnoDB性能的技巧"><a href="#优化InnoDB性能的技巧" class="headerlink" title="优化InnoDB性能的技巧"></a>优化InnoDB性能的技巧</h2><p><strong>配置<code>innodb_buffer_pool_size</code>：控制InnoDB缓存数据和索引的内存大小</strong>。通常设置为系统内存的50%-80%。<br><strong>调整<code>innodb_log_file_size</code>：增加日志文件的大小可以减少日志磁盘写入次数</strong>，但需要确保磁盘I/O足够快。<br><strong>使用合适的索引：</strong>确保对查询进行优化的索引。<br><strong>监控和调整<code>innodb_io_capacity</code>：</strong>这个参数<strong>控制后台I/O操作的速率</strong>，需要根据实际的磁盘I/O性能进行调整。<br><strong>批量操作：</strong>大量插入、更新或删除操作时，尽量使用<strong>事务批量处理，减少对数据库的冲击</strong>。</p><h2 id="InnoDB常见问题及解决方案？"><a href="#InnoDB常见问题及解决方案？" class="headerlink" title="InnoDB常见问题及解决方案？"></a>InnoDB常见问题及解决方案？</h2><p><strong>性能问题：</strong>若发现InnoDB性能不佳，<strong>先检查是否有足够的内存分配给<code>innodb_buffer_pool_size</code>，以及磁盘I/O是否成为瓶颈</strong>。<br><strong>锁等待：</strong>高并发下，锁等待可能导致性能下降。可<strong>通过<code>SHOW ENGINE INNODB STATUS</code>查看锁等待情况</strong>，并考虑优化查询或增加索引。<br><strong>死锁：</strong>死锁是多个事务相互等待对方释放资源的情况。MySQL会检测到死锁并自动回滚其中一个事务以解除死锁。可以<strong>通过<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>表来诊断死锁</strong>。</p><hr><h1 id="业务相关"><a href="#业务相关" class="headerlink" title="业务相关"></a>业务相关</h1><h2 id="导入数据后数据库数据重复原因及解决？"><a href="#导入数据后数据库数据重复原因及解决？" class="headerlink" title="导入数据后数据库数据重复原因及解决？"></a>导入数据后数据库数据重复原因及解决？</h2><p><strong>表象原因：</strong>如<em>网络延迟、用户连点、并发</em>等<br><strong>本质原因：</strong>在<em>数据库设计、及代码逻辑的严谨性</em>出了问题。</p><p><strong>前端解决方案（不可靠，推荐）</strong><br>    <em>用户点击按钮后，让按钮点击失效或者禁用</em>，待后端响应完成后，按钮可用<br><strong>数据库解决方案(可靠，推荐，适合高并发场景)</strong></p><ul><li>幂等主要手段就是通过表中的<strong>唯一约束</strong>实现。</li><li>添加表的<strong>唯一约束或唯一索引</strong>进行约束处理，是最有效的防治重复提交的方法</li><li>MySql 避免”重复插入记录”的方法：<code>INSERT ignore into，Replace into，ON DUPLICATE KEY UPDATE</code></li><li>使用 <code>ignore</code> 关键字，若用主键 <code>primary</code>或唯一索引 <code>unique</code> 区分了记录的唯一性，避免重复插入记录可以使用</li></ul><p><strong>悲观锁解决方案(可靠，推荐，适合高并发场景)</strong></p><ul><li><strong>悲观锁：</strong>以一种预防的姿态在<strong>修改数据之前把数据锁住</strong>，再对数据进行读写，<strong>释放锁之前任何人都不能对其数据进行操作</strong>，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，才可以对数据进行操作，一般数据库本身锁的机制都基于悲观锁;</li><li><strong>特点：</strong>可以完全<strong>保证数据的独占性和正确性</strong>，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</li></ul><p><strong>幂等：</strong>其任意多次执行所产生的影响均与一次执行的影响相同<br><strong>需要幂等的场景:</strong></p><ul><li><strong>核心业务数据新增</strong>，如订单系统中新增订单、用户信息系统中新增用户；</li><li><strong>审批流系统多人审批同一数据</strong>时，可能导致审批多次。</li><li><strong>定时任务触发</strong>数据生成时可能重复触发，导致数据生成多次。</li></ul>]]></content>
    
    
    <summary type="html">‌数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。数据库软件有着整体性和共享性的特点。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件</title>
    <link href="https://southernfish.github.io/2025/06/19/middleware/message-queue-middleware/"/>
    <id>https://southernfish.github.io/2025/06/19/middleware/message-queue-middleware/</id>
    <published>2025-06-19T10:15:36.000Z</published>
    <updated>2025-06-23T13:16:46.575Z</updated>
    
    <content type="html"><![CDATA[<p><strong>RabbitMQ</strong>是实现了高级<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4751675?fromModule=lemma_inlink">消息队列</a>协议（<a href="https://baike.baidu.com/item/AMQP/8354716?fromModule=lemma_inlink">AMQP</a>）的开源消息代理软件（亦称面向消息的<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240?fromModule=lemma_inlink">中间件</a>）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang/0?fromModule=lemma_inlink">Erlang</a>语言编写的，而集群和<a href="https://baike.baidu.com/item/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/14768924?fromModule=lemma_inlink">故障转移</a>是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0/15696499?fromModule=lemma_inlink">开放电信平台</a>框架上的。所有主要的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131?fromModule=lemma_inlink">编程语言</a>均有与代理接口通讯的客户端库。本文简单记录一些关于RabbitMQ的问题。</p><h2 id="RabbitMQ-的使用场景有哪些？"><a href="#RabbitMQ-的使用场景有哪些？" class="headerlink" title="RabbitMQ 的使用场景有哪些？"></a>RabbitMQ 的使用场景有哪些？</h2><p><strong>抢购活动，削峰填谷，防止系统崩塌</strong>。<br><strong>延迟信息处理</strong>，比如 10 分钟之后给下单未付款的用户<strong>发送邮件提醒</strong>。<br><strong>解耦系统</strong>，对于<strong>新增的功能可以单独写模块扩展</strong>，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p><h2 id="RabbitMQ-有哪些重要的角色？"><a href="#RabbitMQ-有哪些重要的角色？" class="headerlink" title="RabbitMQ 有哪些重要的角色？"></a>RabbitMQ 有哪些重要的角色？</h2><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p><ul><li><strong>生产者：</strong>消息的创建者，负责<strong>创建和推送数据</strong>到消息服务器；</li><li><strong>消费者：</strong>消息的接收方，用于<strong>处理数据和确认消息</strong>；</li><li><strong>代理：</strong>就是 <strong><code>RabbitMQ</code> 本身</strong>，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li></ul><h2 id="RabbitMQ-有哪些重要的组件？"><a href="#RabbitMQ-有哪些重要的组件？" class="headerlink" title="RabbitMQ 有哪些重要的组件？"></a>RabbitMQ 有哪些重要的组件？</h2><p><code>ConnectionFactory</code>（连接管理器）：<strong>应用程序与Rabbit之间建立连接的管理器</strong>，程序代码中使用。<br><code>Channel</code>（信道）：<strong>消息推送使用的通道</strong>。<br><code>Exchange</code>（交换器）：用于<strong>接受、分配消息</strong>。<br><code>Queue</code>（队列）：用于<strong>存储</strong>生产者的消息。<br><code>RoutingKey</code>（路由键）：用于把生成者的数据<strong>分配到交换器</strong>上。<br><code>BindingKey</code>（绑定键）：用于<strong>把交换器的消息绑定到队列</strong>上。</p><h2 id="RabbitMQ-中-vhost-的作用是什么？"><a href="#RabbitMQ-中-vhost-的作用是什么？" class="headerlink" title="RabbitMQ 中 vhost 的作用是什么？"></a>RabbitMQ 中 vhost 的作用是什么？</h2><p><strong>vhost：</strong>每个 RabbitMQ 都能创建很多 <code>vhost</code>，我们称之为<strong>虚拟主机</strong>，每个虚拟主机其实都是 <strong>mini 版的RabbitMQ</strong>，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p><h2 id="RabbitMQ-的消息是怎么发送的？"><a href="#RabbitMQ-的消息是怎么发送的？" class="headerlink" title="RabbitMQ 的消息是怎么发送的？"></a>RabbitMQ 的消息是怎么发送的？</h2><p>首先客户端必须<strong>连接到 <code>RabbitMQ</code> 服务器</strong>才能发布和消费消息，<strong>客户端和 <code>rabbit server</code> 之间会创建一个 <code>tcp 连接</code><strong>，一旦 <strong><code>tcp</code> 打开并通过了认证</strong>（认证就是你发送给 rabbit 服务器的用户名和密码），你的</strong>客户端和 <code>RabbitMQ</code> 就创建了一条 <code>amqp 信道</code>（channel）</strong>，信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p><h2 id="RabbitMQ-怎么保证消息的稳定性？"><a href="#RabbitMQ-怎么保证消息的稳定性？" class="headerlink" title="RabbitMQ 怎么保证消息的稳定性？"></a>RabbitMQ 怎么保证消息的稳定性？</h2><p>提供了<strong>事务</strong>的功能。<br>通过<strong>将 <code>channel</code> 设置为 <code>confirm</code>（确认）模式</strong>。</p><h2 id="RabbitMQ-怎么避免消息丢失？"><a href="#RabbitMQ-怎么避免消息丢失？" class="headerlink" title="RabbitMQ 怎么避免消息丢失？"></a>RabbitMQ 怎么避免消息丢失？</h2><ul><li><strong>把消息持久化磁盘</strong>，保证服务器重启消息不丢失。</li><li><strong>每个集群中至少有一个物理磁盘，保证消息落入磁盘</strong>。</li></ul><h2 id="要保证消息持久化成功的条件有哪些？"><a href="#要保证消息持久化成功的条件有哪些？" class="headerlink" title="要保证消息持久化成功的条件有哪些？"></a>要保证消息持久化成功的条件有哪些？</h2><p><strong>声明队列</strong>必须<strong>设置持久化 <code>durable</code> 设置为 <code>true</code><strong>。<br><strong>消息推送投递模式</strong>必须设置持久化，</strong><code>deliveryMode</code> 设置为 2（持久）</strong>。<br>消息<strong>已经到达持久化交换器</strong>。<br>消息<strong>已经到达持久化队列</strong>。<br>以上四个条件都满足才能保证消息持久化成功。</p><h2 id="RabbitMQ-持久化有什么缺点？"><a href="#RabbitMQ-持久化有什么缺点？" class="headerlink" title="RabbitMQ 持久化有什么缺点？"></a>RabbitMQ 持久化有什么缺点？</h2><p>持久化的缺点就是<strong>降低了服务器的吞吐量</strong>，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可**尽量使用 <code>ssd 硬盘</code>**来缓解吞吐量的问题。</p><h2 id="RabbitMQ-有几种广播类型？"><a href="#RabbitMQ-有几种广播类型？" class="headerlink" title="RabbitMQ 有几种广播类型？"></a>RabbitMQ 有几种广播类型？</h2><p><code>direct</code>（默认方式）：最基础最简单的模式，<strong>发送方把消息发送给订阅方</strong>，针对多个订阅者，<strong>默认采取轮询方式进行消息发送</strong>。<br><code>headers</code>：与 <code>direct</code> 类似，只是性能很差，此类型几乎用不到。<br><code>fanout</code>：<strong>分发模式</strong>，把消息<strong>分发给所有订阅者</strong>。<br><code>topic</code>：<strong>匹配订阅模式</strong>，使用<strong>正则匹配</strong>到消息队列，能匹配到的都能接收到。</p><h2 id="RabbitMQ-怎么实现延迟消息队列？"><a href="#RabbitMQ-怎么实现延迟消息队列？" class="headerlink" title="RabbitMQ 怎么实现延迟消息队列？"></a>RabbitMQ 怎么实现延迟消息队列？</h2><p>延迟队列的实现有两种方式：</p><ul><li>通过<strong>消息过期后进入死信交换器，再由交换器转发到延迟消费队列</strong>，实现延迟功能；</li><li>使用 <code>RabbitMQ-delayed-message-exchange</code> 插件实现延迟功能。</li></ul><h2 id="RabbitMQ-集群有什么用？"><a href="#RabbitMQ-集群有什么用？" class="headerlink" title="RabbitMQ 集群有什么用？"></a>RabbitMQ 集群有什么用？</h2><p>集群主要有以下两个用途：</p><ul><li><strong>高可用：</strong>某个服务器出现问题，整个 <code>RabbitMQ</code> 还可以继续使用；</li><li><strong>高容量：</strong>集群可以承载更多的消息量。</li></ul><h2 id="RabbitMQ-节点的类型有哪些？"><a href="#RabbitMQ-节点的类型有哪些？" class="headerlink" title="RabbitMQ 节点的类型有哪些？"></a>RabbitMQ 节点的类型有哪些？</h2><p><strong>磁盘节点：</strong>消息会存储到磁盘。<br><strong>内存节点：</strong>消息都存储在内存中，<strong>重启服务器消息丢失，性能高于磁盘类型</strong>。</p><h2 id="RabbitMQ-集群搭建需要注意哪些问题？"><a href="#RabbitMQ-集群搭建需要注意哪些问题？" class="headerlink" title="RabbitMQ 集群搭建需要注意哪些问题？"></a>RabbitMQ 集群搭建需要注意哪些问题？</h2><p>各<strong>节点之间使用<code>“–link”</code>连接</strong>，此属性不能忽略。<br>各节点使用的 <strong><code>erlang cookie</code> 值必须相同</strong>，此值相当于“秘钥”的功能，<strong>用于各节点的认证</strong>。<br><strong>整个集群中必须包含一个磁盘节点</strong>。</p><h2 id="RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h2><p>不是，原因有以下两个：</p><ul><li><strong>存储空间的考虑：</strong>若每个节点都拥有所有队列的完全拷贝，新增节点不但没有新增存储空间，反而<strong>增加了冗余数据</strong>；</li><li><strong>性能的考虑：</strong>若每条消息都需要完整拷贝到每一个集群节点，那新增节点并<strong>没有提升处理消息的能力</strong>，最多是保持和单节点相同的性能<strong>甚至是更糟</strong>。</li></ul><h2 id="RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h2><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p><ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li></ul><p>唯一磁盘节点崩溃了，<strong>集群可以保持运行，但不能更改任何东西</strong></p><h2 id="RabbitMQ-对集群节点停止顺序有要求吗？"><a href="#RabbitMQ-对集群节点停止顺序有要求吗？" class="headerlink" title="RabbitMQ 对集群节点停止顺序有要求吗？"></a>RabbitMQ 对集群节点停止顺序有要求吗？</h2><p><code>RabbitMQ</code> 对集群的停止顺序是有要求的，应该<strong>先关闭内存节点，最后再关闭磁盘节点。若顺序恰好相反的话，可能会造成消息的丢失</strong>。</p>]]></content>
    
    
    <summary type="html">简单记录一些关于消息中间件的问题</summary>
    
    
    
    <category term="Middleware" scheme="https://southernfish.github.io/categories/Middleware/"/>
    
    <category term="MQ" scheme="https://southernfish.github.io/categories/Middleware/MQ/"/>
    
    
    <category term="RabbitMQ" scheme="https://southernfish.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
</feed>
