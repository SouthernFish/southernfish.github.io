<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Southern Fish</title>
  
  
  <link href="https://southernfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://southernfish.github.io/"/>
  <updated>2025-06-24T06:44:33.642Z</updated>
  <id>https://southernfish.github.io/</id>
  
  <author>
    <name>Southern Fish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库引擎InnoDB</title>
    <link href="https://southernfish.github.io/2025/06/24/database/database-innodb/"/>
    <id>https://southernfish.github.io/2025/06/24/database/database-innodb/</id>
    <published>2025-06-24T05:34:36.000Z</published>
    <updated>2025-06-24T06:44:33.642Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB，是<a href="https://baike.baidu.com/item/MySQL/471251?fromModule=lemma_inlink">MySQL</a>的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/1239260?fromModule=lemma_inlink">数据库引擎</a>之一，现为MySQL的默认<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/8969956?fromModule=lemma_inlink">存储引擎</a>，为[MySQL AB](<a href="https://baike.baidu.com/item/MySQL">https://baike.baidu.com/item/MySQL</a> AB/2620844?fromModule=lemma_inlink)发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由<a href="https://baike.baidu.com/item/%E7%94%B2%E9%AA%A8%E6%96%87%E5%85%AC%E5%8F%B8/430115?fromModule=lemma_inlink">甲骨文公司</a>并购。与传统的ISAM与<a href="https://baike.baidu.com/item/MyISAM/0?fromModule=lemma_inlink">MyISAM</a>相比，InnoDB的最大特色就是支持了<a href="https://baike.baidu.com/item/ACID/10738?fromModule=lemma_inlink">ACID</a>兼容的<a href="https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1/5945882?fromModule=lemma_inlink">事务</a>（Transaction）功能，类似于<a href="https://baike.baidu.com/item/PostgreSQL/530240?fromModule=lemma_inlink">PostgreSQL</a>。InnoDB采用<a href="https://baike.baidu.com/item/%E5%8F%8C%E8%BD%A8%E5%88%B6/8309993?fromModule=lemma_inlink">双轨制</a>授权，一个是<a href="https://baike.baidu.com/item/GPL/0?fromModule=lemma_inlink">GPL</a>授权，另一个是专有软件授权。</p><h1>InnoDB</h1><h2 id="MyISAM索引与InnoDB索引的区别？">MyISAM索引与InnoDB索引的区别？</h2><p><strong><code>InnoDB</code>索引是聚簇索引</strong>，MyISAM索引是非聚簇索引。<br><code>InnoDB</code>的<strong>主键索引的叶子节点存储着行数据</strong>，因此主键索引非常高效。<br><strong><code>MyISAM</code>索引的叶子节点存储的是行数据地址</strong>，需要再寻址一次才能得到数据。<br><strong>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据</strong>，因此查询时做到覆盖索引会非常高效。</p><h2 id="MySQL-InnoDB存储引擎的特点">MySQL InnoDB存储引擎的特点</h2><p><strong>事务支持：<strong>InnoDB支持ACID事务属性。<br><strong>崩溃恢复</strong>：InnoDB会</strong>将数据写入到磁盘上的日志文件</strong>中，即使在系统崩溃的情况下，也能通过这些日志文件恢复数据。<br>**MVCC (多版本并发控制)：**InnoDB使用多版本并发控制，这允许更高的并发性。<br>**外键约束：**InnoDB支持外键约束，这对于维护数据库的引用完整性非常有用。<br><strong>行级锁定：<strong>与表级锁定相比，InnoDB</strong>支持行级锁定，提供了更高的并发性能</strong>。<br><strong>自适应哈希索引：<strong>InnoDB会</strong>自动为频繁访问的热点数据创建哈希索引，以提高查询速度</strong>。</p><h2 id="主键使用自增ID还是UUID？">主键使用自增ID还是UUID？</h2><p>推荐使用自增ID，不要使用UUID。<br>在InnoDB存储引擎中，主键索引是作为<strong>聚簇索引</strong>存在的，主键索引的<code>B+树</code>叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，只需要不断向后排列即可，如果是*<code>UUID</code>，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降*。<br>总之，在数据量大一些的情况下，用自增主键性能会好一些。<br>主键是聚簇索引，若没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个<strong>隐式的主键</strong>。</p><h2 id="如何使用InnoDB？">如何使用InnoDB？</h2><p>在创建表时指定使用InnoDB存储引擎，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE example (</span><br><span class="line">    <span class="built_in">id</span> INT AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (<span class="built_in">id</span>)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h2 id="优化InnoDB性能的技巧">优化InnoDB性能的技巧</h2><p><strong>配置<code>innodb_buffer_pool_size</code>：控制InnoDB缓存数据和索引的内存大小</strong>。通常设置为系统内存的50%-80%。<br><strong>调整<code>innodb_log_file_size</code>：增加日志文件的大小可以减少日志磁盘写入次数</strong>，但需要确保磁盘I/O足够快。<br>**使用合适的索引：**确保对查询进行优化的索引。<br><strong>监控和调整<code>innodb_io_capacity</code>：<strong>这个参数</strong>控制后台I/O操作的速率</strong>，需要根据实际的磁盘I/O性能进行调整。<br><strong>批量操作：<strong>大量插入、更新或删除操作时，尽量使用</strong>事务批量处理，减少对数据库的冲击</strong>。</p><h2 id="InnoDB常见问题及解决方案？">InnoDB常见问题及解决方案？</h2><p>**性能问题：**若发现InnoDB性能不佳，<strong>先检查是否有足够的内存分配给<code>innodb_buffer_pool_size</code>，以及磁盘I/O是否成为瓶颈</strong>。<br><strong>锁等待：<strong>高并发下，锁等待可能导致性能下降。可</strong>通过<code>SHOW ENGINE INNODB STATUS</code>查看锁等待情况</strong>，并考虑优化查询或增加索引。<br><strong>死锁：<strong>死锁是多个事务相互等待对方释放资源的情况。MySQL会检测到死锁并自动回滚其中一个事务以解除死锁。可以</strong>通过<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>表来诊断死锁</strong>。</p><hr><h1>多版本并发控制（MVCC）</h1><p>MVCC全称<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6&amp;spm=1001.2101.3001.7020">多版本并发控制</a>，是在并发访问数据库时对操作数据做多版本管理，避免因为写数据时要加写锁而阻塞读取数据的请求问题。</p><h2 id="InnoDB的MVCC实现原理">InnoDB的MVCC实现原理</h2><p>MySQL <code>InnoDB</code> 存储引擎使用多版本并发控制（MVCC，<code>Multi-Version Concurrency Control</code>）来支持高并发环境下的读写操作，而不会互相阻塞。MVCC 允许在同一个时刻有多个事务对同一数据进行操作，而不会导致数据不一致。使用软性手段既要保证串行化隔离级别的安全性同时保证系统的整体性能和吞吐量。转载自文章 <a href="https://blog.csdn.net/carolineme/article/details/145860802">Innodb MVCC实现原理</a></p><ol><li><p><strong>事务版本号</strong></p><p>每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。</p></li><li><p><strong>表格的隐藏列</strong></p><table><thead><tr><th>隐藏列名称</th><th>说明</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>记录操作该数据事务的事务ID；</td></tr><tr><td>DB_ROLL_PTR</td><td>指向上一个版本数据在undo log 里的位置指针；</td></tr><tr><td>DB_ROW_ID</td><td>隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引;</td></tr></tbody></table></li><li><p><strong>Undo log</strong></p><p>Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。<strong>主要用途：</strong></p><ul><li><p>保证事务进行<code>rollback</code>时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。</p></li><li><p><strong>用于MVCC快照读的数据</strong>，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。</p></li></ul></li><li><p><strong>Read view</strong></p><p>在innodb 中每个事务开启后都会得到一个read_view。副本主要保存了当前<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F&amp;spm=1001.2101.3001.7020">数据库系统</a>中正处于活跃（没有commit）的事务的ID号，保存的是系统中当前不应该被本事务看到的其他事务id列表。<strong>Read view 的几个重要属性：</strong></p><table><thead><tr><th>属性名称</th><th>说明</th></tr></thead><tbody><tr><td>trx_ids</td><td>当前系统活跃(未提交)事务版本号集合</td></tr><tr><td>max_limit_id</td><td>创建当前read view 时“当前系统最大事务版本号+1”</td></tr><tr><td>min_limit_id</td><td>创建当前read view 时“系统正处于活跃事务最小版本号”</td></tr><tr><td>creator_trx_id</td><td>创建当前read view的事务版本号</td></tr></tbody></table><p><strong>Read view 匹配条件规则：</strong></p><ul><li>如果数据事务ID <code>trx_id &lt; min_limit_id</code>，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。</li><li>如果<code>trx_id&gt;= max_limit_id</code>，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</li><li>如果 <code>min_limit_id =&lt;trx_id&lt; max_limit_id</code>，<strong>需要分3种情况讨论</strong>：<ul><li>如果<code>m_ids包含trx_id</code>，则代表Read View生成时刻，这个事务还未提交，但如果数据的<code>trx_id等于creator_trx_id</code>的话，表明数据是自己生成的，因此是可见的。</li><li>如果<code>m_ids包含trx_id</code>，并且<code>trx_id不等于creator_trx_id</code>，则Read View生成时，事务未提交，并且不是自己生产的，所以当前事务也是看不见的；</li><li>如果<code>m_ids不包含trx_id</code>，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是能看见的。</li></ul></li></ul><p><code>READ_UNCOMMITTED</code> 级别的事务不会获取read view 副本；<code>RC(read commit)</code> 级别下同一个事务里面的每一次查询都会获得一个新的read view副本；<code>RR(重复读)</code>级别下的一个事务里只会获取一次read view副本，从而保证每次查询的数据都是一样的。</p></li></ol><h2 id="MVCC-Next-key-Lock-防止幻读">MVCC+Next-key-Lock 防止幻读</h2><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p><ol><li><p><strong>执行普通 select，此时会以 MVCC 快照读的方式读取数据</strong></p><ul><li><p>在快照读的情况下，RR 隔离级别只会在<strong>事务开启后的第一次查询生成 <code>Read View</code></strong> ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。</p></li><li><p><strong>快照读</strong>是指读取数据时不是读取最新版本的数据，而是基于历史版本读取的一个快照信息（mysql读取undo log历史版本)</p></li></ul></li><li><p><strong>执行 select…for update/lock in share mode、insert、update、delete 等当前读</strong></p><ul><li>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，<strong>就会产生幻读</strong>！</li><li>InnoDB 使用 <code>Next-key Lock</code> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。</li><li>当前读是读取的数据库最新的数据，当前读和快照读不同，因为要读取最新的数据而且要保证事务的隔离性，所以当前读是需要对数据进行加锁的</li></ul></li></ol>]]></content>
    
    
    <summary type="html">‌InnoDB是为处理巨大数据量时的最大性能设计。InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring注解</title>
    <link href="https://southernfish.github.io/2025/06/23/framwork/spring-annotation/"/>
    <id>https://southernfish.github.io/2025/06/23/framwork/spring-annotation/</id>
    <published>2025-06-23T13:10:36.000Z</published>
    <updated>2025-06-24T06:44:33.643Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring框架中，注解是一种非常重要的特性，它极大地简化了配置和开发过程。‌Spring注解是Spring框架中用于简化配置和开发的核心机制，主要分为组件管理、依赖注入、配置类、AOP、Web开发等类别‌。</p><h1>Spring注解的底层实现逻辑</h1><h2 id="实践案例">实践案例</h2><p>Java注解的底层实现逻辑主要包括<strong>定义注解、使用注解和通过反射获取注解</strong>。具体源码分析转载自 <a href="https://blog.csdn.net/fk1778770286/article/details/148581060">Java注解底层实现原理 - 源码分析</a></p><h3 id="定义注解">定义注解</h3><p>注解是通过<code>@interface</code>关键字定义的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 默认值</span></span><br><span class="line">    <span class="type">int</span>[] numbers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>@Target</code>和<code>@Retention</code>是元注解，分别指定了注解的应用目标和保留策略。<code>ElementType.TYPE</code>表示该注解可以应用于类、接口或枚举上，<code>RetentionPolicy.RUNTIME</code>表示注解在运行时可以通过反射获取‌</p><h3 id="使用注解">使用注解</h3><p>使用注解时，只需在声明处添加相应的注解即可。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> TestClass.class.getAnnotation(MyAnnotation.class);</span><br><span class="line">        System.out.println(annotation.value()); <span class="comment">// 输出: hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码通过反射获取了<code>TestClass</code>类上的<code>MyAnnotation</code>注解，并打印了其<code>value</code>属性的值‌。</p><h3 id="反射获取注解">反射获取注解</h3><p>通过反射，可以在运行时获取类、方法、参数等上的注解信息。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = TestClass.class;</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line">System.out.println(annotation.value());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取所有methods</span></span><br><span class="line">    Method[] methods = MyAnnotation.class.getClassLoader()</span><br><span class="line">          .loadClass((<span class="string">&quot;com.pdai.java.annotation.TestMyAnnotation&quot;</span>))</span><br><span class="line">          .getMethods();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(MyAnnotation.class)) &#123; <span class="comment">// 方法上是否有MyAnnotation注解</span></span><br><span class="line">            <span class="type">MyAnnotation</span> <span class="variable">anno</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class); <span class="comment">// 获取MyAnnotation对象信息</span></span><br><span class="line">            System.out.println(anno.title()); <span class="comment">// 访问注解的属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="源码分析注解的底层实现">源码分析注解的底层实现</h2><p>从 <code>MyAnnotation annotation = clazz.getAnnotation(MyAnnotation.class);</code> 开始分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#getAnnotation】</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; A <span class="title function_">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(annotationClass);</span><br><span class="line">    <span class="keyword">return</span> (A) annotationData().annotations.get(annotationClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>annotationData().annotations.get(annotationClass);</code>：调用 <code>annotationData()</code> 方法获取<strong>当前类的注解数据</strong>，然后从 annotations 映射中获取<strong>指定类型的注解实例</strong></li><li><code>(A)</code>：将获取到的<strong>注解实例强制转换为泛型类型 A</strong></li></ul><h3 id="获取注解数据集-annotationData">获取注解数据集 annotationData</h3><p>使用 <code>Atomic.casAnnotationData</code> 方法（基于 CAS <a href="https://so.csdn.net/so/search?q=%E4%B9%90%E8%A7%82%E9%94%81&amp;spm=1001.2101.3001.7020">乐观锁</a>机制）尝试将新的 AnnotationData 对象更新到当前类中。若更新成功，返回新的 AnnotationData 对象；若失败，循环会继续重试，直到成功为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#annotationData】</span></span><br><span class="line"><span class="comment">/* 获取当前类的注解数据对象。如果缓存的注解数据已过期或不存在，则创建新的注解数据对象并尝试更新到缓存中。</span></span><br><span class="line"><span class="comment"> * 该方法使用循环重试和 CAS 操作来保证数据的一致性和线程安全。</span></span><br><span class="line"><span class="comment"> * @return 当前类的注解数据对象  */</span></span><br><span class="line"><span class="keyword">private</span> AnnotationData <span class="title function_">annotationData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="comment">// 进入无限循环，实现重试机制，直到成功获取有效的注解数据</span></span><br><span class="line">        <span class="type">AnnotationData</span> <span class="variable">annotationData</span> <span class="operator">=</span> <span class="built_in">this</span>.annotationData; <span class="comment">// 获取当前缓存的注解数据对象</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">classRedefinedCount</span> <span class="operator">=</span> <span class="built_in">this</span>.classRedefinedCount; <span class="comment">// 获取当前类的重定义计数，该值在类被重新定义时会递增</span></span><br><span class="line">        <span class="keyword">if</span> (annotationData != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            annotationData.redefinedCount == classRedefinedCount) &#123; <span class="comment">// 检查缓存的注解数据是否存在且未过期</span></span><br><span class="line">            <span class="keyword">return</span> annotationData; <span class="comment">// 若注解数据有效，直接返回缓存的对象</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若缓存的注解数据为空或已过期，乐观地创建一个新的注解数据对象</span></span><br><span class="line">        <span class="type">AnnotationData</span> <span class="variable">newAnnotationData</span> <span class="operator">=</span> createAnnotationData(classRedefinedCount);</span><br><span class="line">        <span class="comment">// 尝试使用 CAS（Compare-And-Swap）操作将新的注解数据对象更新到缓存中</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic.casAnnotationData(<span class="built_in">this</span>, annotationData, newAnnotationData)) &#123;</span><br><span class="line">            <span class="keyword">return</span> newAnnotationData; <span class="comment">// 若 CAS 操作成功，说明新的注解数据已成功更新到缓存，返回该对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 CAS 操作失败，说明在创建新对象期间，其他线程已经更新了注解数据，进入下一次循环重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建注解数据集-createAnnotationData">构建注解数据集 createAnnotationData</h3><ul><li>调用 <code>AnnotationParser.parseAnnotations</code> 方法，解析当前类的原始注解数据，将结果存储在 <code>declaredAnnotations</code> 映射中，<em>键为注解类，值为注解实例</em></li><li>**处理父类继承注解：**父类存在，获取父类的注解数据中的注解映射 <code>superAnnotations</code>。遍历 superAnnotations，对于每个注解，检查其是否使用了<code>@Inherited</code>元注解（通过 <code>AnnotationType.getInstance(annotationClass).isInherited()</code> 判断）。若使用了 @Inherited 元注解，且 annotations 为 null，则进行懒初始化，创建一个 LinkedHashMap 来存储继承的注解。将继承的注解添加到 annotations 映射中</li><li>**合并注解：**若 annotations 仍为 null，说明没有继承的注解，直接将 annotations 指向 declaredAnnotations。若存在继承的注解，将 declaredAnnotations 中的注解添加到 annotations 中，当前类声明的注解会覆盖继承的注解</li><li>**总结：**该方法的核心逻辑是解析当前类的声明注解，若父类存在，获取父类中可继承的注解，将两者合并后创建 AnnotationData 对象。这样可以保证 AnnotationData 对象包含当前类完整的注解信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#createAnnotationData】</span></span><br><span class="line"><span class="keyword">private</span> AnnotationData <span class="title function_">createAnnotationData</span><span class="params">(<span class="type">int</span> classRedefinedCount)</span> &#123;</span><br><span class="line">    <span class="comment">// ------------------------ 处理父类继承注解 ----------------------------------</span></span><br><span class="line">    <span class="comment">// 解析当前类的原始注解数据，将结果存储在 declaredAnnotations 映射中</span></span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; declaredAnnotations =</span><br><span class="line">        AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), <span class="built_in">this</span>);</span><br><span class="line">        </span><br><span class="line">    Class&lt;?&gt; superClass = getSuperclass(); <span class="comment">// 父类获取</span></span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; annotations = <span class="literal">null</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (superClass != <span class="literal">null</span>) &#123; <span class="comment">// 若父类存在</span></span><br><span class="line">        Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; superAnnotations =</span><br><span class="line">            superClass.annotationData().annotations; <span class="comment">// 获取父类的注解数据中的注解映射</span></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; e : superAnnotations.entrySet()) &#123;</span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass = e.getKey();</span><br><span class="line">            <span class="comment">// 判断每个注解是否使用了元注解@Inherited</span></span><br><span class="line">            <span class="keyword">if</span> (AnnotationType.getInstance(annotationClass).isInherited()) &#123; </span><br><span class="line">                <span class="keyword">if</span> (annotations == <span class="literal">null</span>) &#123; <span class="comment">// lazy construction （懒初始化）</span></span><br><span class="line">                    <span class="comment">// 创建一个 LinkedHashMap 来存储继承的注解</span></span><br><span class="line">                    annotations = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;((Math.max(</span><br><span class="line">                            declaredAnnotations.size(),</span><br><span class="line">                            Math.min(<span class="number">12</span>, declaredAnnotations.size() + superAnnotations.size())</span><br><span class="line">                        ) * <span class="number">4</span> + <span class="number">2</span>) / <span class="number">3</span></span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将继承的注解添加到 annotations 映射中</span></span><br><span class="line">                annotations.put(annotationClass, e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------ 处理父类继承注解 --------------------------------</span></span><br><span class="line">    <span class="comment">// --------------------------- 合并注解 ----------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (annotations == <span class="literal">null</span>) &#123; <span class="comment">// annotations 仍为 null，说明没有继承的注解</span></span><br><span class="line">        <span class="comment">// no inherited annotations -&gt; share the Map with declaredAnnotations</span></span><br><span class="line">        annotations = declaredAnnotations;</span><br><span class="line">    <span class="comment">// --------------------------- 合并注解 ----------------------------------</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 存在继承的注解 添加后，当前类声明的注解会覆盖继承的注解</span></span><br><span class="line">        <span class="comment">// at least one inherited annotation -&gt; declared may override inherited</span></span><br><span class="line">        annotations.putAll(declaredAnnotations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationData</span>(annotations, declaredAnnotations, classRedefinedCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取当前类的原始注解数据-getRawAnnotations">获取当前类的原始注解数据 getRawAnnotations</h3><ul><li><strong>native 关键字</strong>：在 Java 里，<code>native</code> 关键字用于声明本地方法。本地方法并非用 Java 实现，而是借助其他编程语言（像 C、C++）实现。Java 虚拟机（JVM）会负责加载并调用这些本地方法。通常，本地方法用于和底层系统交互，或实现对性能要求极高的操作。</li><li><strong>byte[] 返回类型</strong>：该方法返回一个字节数组 byte[]。这意味着<strong>方法会返回当前类原始注解数据的字节表示形式</strong>。原始注解数据是注解在字节码层面的存储形式，可能包含<strong>注解类型、注解属性值</strong>等信息。</li><li><strong>元注解</strong>：作用于自定义注解类型的注解类，在JDK 1.5中提供了4个标准的元注解：<code>@Target，@Retention，@Documented，@Inherited</code>，在JDK 1.8中提供了两个元注解 <code>@Repeatable</code>和<code>@Native</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#getRawAnnotations】</span></span><br><span class="line"><span class="keyword">native</span> <span class="type">byte</span>[] getRawAnnotations();</span><br></pre></td></tr></table></figure><h3 id="获取当前类对应的常量池-getConstantPool">获取当前类对应的常量池 getConstantPool</h3><p><code>getConstantPool</code> 方法是一个本地方法，其作用是获取当前类对应的常量池对象。由于需要直接访问 JVM 内部的数据结构，所以采用本地方法实现。调用该方法后，能得到一个 <code>ConstantPool</code> 对象，进而访问常量池中的常量信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#getConstantPool】</span></span><br><span class="line"><span class="keyword">native</span> ConstantPool <span class="title function_">getConstantPool</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="解析当前类的原始注解数据-parseAnnotations">解析当前类的原始注解数据 parseAnnotations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationParser#parseAnnotations】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; parseAnnotations(</span><br><span class="line">        <span class="type">byte</span>[] var0, ConstantPool var1, Class&lt;?&gt; var2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (var0 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parseAnnotations2(var0, var1, var2, (Class[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BufferUnderflowException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Unexpected end of annotations.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; parseAnnotations2(</span><br><span class="line">        <span class="type">byte</span>[] var0, ConstantPool var1, Class&lt;?&gt; var2, Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;[] var3) &#123;</span><br><span class="line">    <span class="type">LinkedHashMap</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">var5</span> <span class="operator">=</span> ByteBuffer.wrap(var0);</span><br><span class="line">    <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> var5.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var7</span> <span class="operator">=</span> <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">        <span class="type">Annotation</span> <span class="variable">var8</span> <span class="operator">=</span> parseAnnotation2(var5, var1, var2, <span class="literal">false</span>, var3);</span><br><span class="line">        <span class="keyword">if</span> (var8 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">var9</span> <span class="operator">=</span> var8.annotationType();</span><br><span class="line">            <span class="keyword">if</span> (AnnotationType.getInstance(var9).retention() == RetentionPolicy.RUNTIME &amp;&amp; var4.put(var9, var8) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Duplicate annotation for class: &quot;</span> + var9 + <span class="string">&quot;: &quot;</span> + var8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体会调用到下面的 <code>parseAnnotation2</code> 方法，该方法主要都是解析注解里面的信息，解析出来的值最终会给到我们去创建代理对象用。我们重点关注的是 <code>annotationForMap</code> 这个方法，该方法里面就是通过动态代理来创建注解实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationParser#parseAnnotation2】</span></span><br><span class="line"><span class="comment">/* 解析注解字节数据，生成注解实例。</span></span><br><span class="line"><span class="comment"> * @param var0 包含注解数据的字节缓冲区</span></span><br><span class="line"><span class="comment"> * @param var1 常量池对象，用于获取注解相关的常量信息</span></span><br><span class="line"><span class="comment"> * @param var2 注解所属的类</span></span><br><span class="line"><span class="comment"> * @param var3 若为 true，在遇到类型不存在异常时抛出异常；否则跳过该注解</span></span><br><span class="line"><span class="comment"> * @param var4 要解析的注解类型数组，若为 null 则解析所有注解</span></span><br><span class="line"><span class="comment"> * @return 解析得到的注解实例，若跳过解析则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Annotation <span class="title function_">parseAnnotation2</span><span class="params">(</span></span><br><span class="line"><span class="params">    ByteBuffer var0, ConstantPool var1, Class&lt;?&gt; var2, <span class="type">boolean</span> var3, Class&lt;? extends Annotation&gt;[] var4)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> var0.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>; <span class="comment">// 从字节缓冲区读取注解类型的常量池索引</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 用于存储临时对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">var7</span> <span class="operator">=</span> <span class="string">&quot;[unknown]&quot;</span>; <span class="comment">// 注解类型名称，初始为未知</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试获取注解类型的类对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var7 = var1.getUTF8At(var5); <span class="comment">// 从常量池中获取注解类型的名称</span></span><br><span class="line">            var21 = parseSig(var7, var2); <span class="comment">// 解析签名，获取注解类型的类对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var18) &#123;</span><br><span class="line">            var21 = var1.getClassAt(var5);  <span class="comment">// 若解析签名失败，直接从常量池中获取类对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError var19) &#123; <span class="comment">// 若找不到类定义</span></span><br><span class="line">        <span class="keyword">if</span> (var3) &#123; <span class="comment">// 若 var3 为 true，抛出类型不存在异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeNotPresentException</span>(var7, var19);</span><br><span class="line">        &#125;</span><br><span class="line">        skipAnnotation(var0, <span class="literal">false</span>); <span class="comment">// 跳过当前注解的解析</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TypeNotPresentException var20) &#123; <span class="comment">// 若类型不存在</span></span><br><span class="line">        <span class="keyword">if</span> (var3) &#123; <span class="comment">// 若 var3 为 true，抛出类型不存在异常</span></span><br><span class="line">            <span class="keyword">throw</span> var20;</span><br><span class="line">        &#125;</span><br><span class="line">        skipAnnotation(var0, <span class="literal">false</span>); <span class="comment">// 跳过当前注解的解析</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否只需要解析特定类型的注解</span></span><br><span class="line">    <span class="keyword">if</span> (var4 != <span class="literal">null</span> &amp;&amp; !contains(var4, var21)) &#123; <span class="comment">// 若当前注解类型不在需要解析的类型列表中，跳过解析</span></span><br><span class="line">        skipAnnotation(var0, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 用于存储临时对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var23 = AnnotationType.getInstance(var21); <span class="comment">// 获取注解类型的元数据</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var17) &#123; <span class="comment">// 若获取元数据失败，跳过当前注解的解析</span></span><br><span class="line">            skipAnnotation(var0, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">var9</span> <span class="operator">=</span> var23.memberTypes(); <span class="comment">// 获取注解类型的成员类型映射</span></span><br><span class="line">        <span class="type">LinkedHashMap</span> <span class="variable">var10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(var23.memberDefaults()); <span class="comment">// 初始化注解成员值映射，使用默认值填充</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">var11</span> <span class="operator">=</span> var0.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>; <span class="comment">// 从字节缓冲区读取注解成员的数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var12</span> <span class="operator">=</span> <span class="number">0</span>; var12 &lt; var11; ++var12) &#123;  <span class="comment">// 遍历所有注解成员</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">var13</span> <span class="operator">=</span> var0.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>; <span class="comment">// 从字节缓冲区读取成员名称的常量池索引</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">var14</span> <span class="operator">=</span> var1.getUTF8At(var13); <span class="comment">// 从常量池中获取成员名称</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">var15</span> <span class="operator">=</span> (Class)var9.get(var14); <span class="comment">// 获取成员的类型</span></span><br><span class="line">            <span class="keyword">if</span> (var15 == <span class="literal">null</span>) &#123; <span class="comment">// 若成员类型不存在，跳过该成员值的解析</span></span><br><span class="line">                skipMemberValue(var0);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">var16</span> <span class="operator">=</span> parseMemberValue(var15, var0, var1, var2); <span class="comment">// 解析成员值</span></span><br><span class="line">                <span class="comment">// 若成员值类型不匹配，设置异常代理的成员信息</span></span><br><span class="line">                <span class="keyword">if</span> (var16 <span class="keyword">instanceof</span> AnnotationTypeMismatchExceptionProxy) &#123;</span><br><span class="line"> ((AnnotationTypeMismatchExceptionProxy)var16).setMember((Method)var23.members().get(var14));</span><br><span class="line">                &#125;</span><br><span class="line">                var10.put(var14, var16); <span class="comment">// 将解析得到的成员值放入映射中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> annotationForMap(var21, var10); <span class="comment">// 根据注解类型和成员值映射生成注解实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过java动态代理实例化注解代理对象">通过java动态代理实例化注解代理对象</h3><ul><li><code>AccessController.doPrivileged</code>：该方法用于在特权环境下执行特定操作。在 Java 安全模型里，有些操作需要特定权限才能执行，使用 <code>doPrivileged</code> 可确保代码在足够权限下运行</li><li><code>annotationForMap</code> 方法利用 Java 的反射和代理机制，根据给定的注解类型和成员值映射，动态创建一个注解实例。借助 <code>AccessController</code> 确保操作在特权环境下执行，最终返回一个实现了指定注解接口的代理对象（此处需要注意，用的代理类 <code>AnnotationInvocationHandler</code>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationParser#annotationForMap】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Annotation <span class="title function_">annotationForMap</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> Class&lt;? extends Annotation&gt; var0, <span class="keyword">final</span> Map&lt;String, Object&gt; var1)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (Annotation)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Annotation&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Annotation <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Annotation)Proxy.newProxyInstance(var0.getClassLoader(), </span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;var0&#125;, </span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">AnnotationInvocationHandler</span>(var0, var1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-AnnotationInvocationHandler">实现 AnnotationInvocationHandler</h3><ul><li><code>AnnotationInvocationHandler</code> 类中的 invoke 方法，该类实现了 <code>InvocationHandler</code> 接口。<strong>在 Java 动态代理机制里，InvocationHandler 接口的 invoke 方法是核心</strong>，当调用代理对象的方法时，实际上会调用 invoke 方法来处理</li><li><strong>处理特殊方法调用：</strong><ul><li>若被调用方法是 toString，调用 <code>toStringImpl</code> 方法生成注解的字符串表示并返回</li><li>若被调用方法是 hashCode，调用 <code>hashCodeImpl</code> 方法计算注解的哈希码并返回</li><li>若被调用方法是 <code>annotationType</code>，返回注解的类型 <code>this.type</code></li></ul></li><li><strong>处理注解成员方法调用：</strong><ul><li>若被调用方法是注解的成员方法，从 <code>memberValues</code> 映射中获取对应的值</li><li>若值为 null，说明注解实例缺少该成员的值，抛出 <code>IncompleteAnnotationException</code> 异常</li><li>若值是 <code>ExceptionProxy</code> 类型，调用 <code>generateException</code> 方法抛出异常</li><li>若值是数组且不为空，调用 <code>cloneArray</code> 方法克隆数组，避免外部修改原始数组，最后返回该值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationInvocationHandler】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6182022883658399397L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Method[] memberMethods = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = var1;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = var2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">var4</span> <span class="operator">=</span> var2.getName();</span><br><span class="line">    Class[] var5 = var2.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (var4.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.equalsImpl(var3[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var5.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (var4) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.toStringImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.hashCodeImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.type;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.get(var4);</span><br><span class="line">                <span class="keyword">if</span> (var6 == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(<span class="built_in">this</span>.type, var4);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var6 <span class="keyword">instanceof</span> ExceptionProxy) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ((ExceptionProxy)var6).generateException();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != <span class="number">0</span>) &#123;</span><br><span class="line">                        var6 = <span class="built_in">this</span>.cloneArray(var6);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> var6;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>其他相关问题</h1><h2 id="注解如何生效">注解如何生效</h2><p><strong>编译期扫描处理，运行期反射处理。编译期扫描处理一般只有Java内置注解会用到</strong>，比如<code>@Override</code>修饰的方法，编译器会检查父类是否有相同的方法。大部分自定义的注解，都是在运行期通过反射拿到并处理。</p><h2 id="运行期如何获取注解">运行期如何获取注解</h2><p>运行时注解<strong>存放在class文件中的<code>attributes属性表</code>中</strong>。<br><strong>反射获取注解的核心</strong>在：<code>java.lang.reflect</code>下的 <strong><code>AnnotatedElement</code><strong>接口，而</strong><code>AnnotatedElement</code></strong> 接口是所有程序元素（<code>Class</code>、<code>Method</code>和<code>Constructor</code>）的父接口。</p><h2 id="Spring加与不加注解的区别">Spring加与不加注解的区别</h2><ol><li>‌<strong>配置方式</strong>‌：<ul><li>‌<strong>不加注解</strong>‌：可以<strong>通过XML配置文件来定义bean</strong>，这种方式更加直观，但需要编写XML文件。</li><li>‌<strong>加注解</strong>‌：通过使用<code>@Configuration</code>和<code>@Bean</code>注解来定义bean，这种方式更加灵活，代码更加简洁，且易于维护和修改。</li></ul></li><li>‌<strong>管理方式</strong>‌：<ul><li>‌<strong>不加注解</strong>‌：需要手动编写XML配置文件，并通过XML配置文件来管理bean的创建和依赖关系。</li><li>‌<strong>加注解</strong>‌：通过注解来定义bean，Spring框架在启动时会扫描这些注解并自动创建和管理bean，减少了手动配置的工作量。</li></ul></li></ol><hr><h1>常用注解及解释</h1><h2 id="核心注解">核心注解</h2><ul><li>‌**<code>@Component</code>**‌：用于把当前类对象存入Spring容器中。<code>@Controller、@Service、@Repository</code>都可以称为@Component，它们分别用于控制层、业务层和数据访问层。</li><li>‌**<code>@Autowired</code>**‌：自动按照类型注入Spring容器中的bean。它可以作用在变量、setter方法或构造函数上。</li><li>‌**<code>@Qualifier</code>**‌：在按照类型注入的基础上，通过名称进行注入。通常与<code>@Autowired</code>一起使用，用于解决相同类型bean的注入冲突。</li><li>‌**<code>@Inject</code>**‌：由<code>JSR-330</code>提供，用法与<code>@Autowired</code>相似，但它是Java标准的一部分，而@Autowired是Spring特有的。</li><li>‌**<code>@Resource</code>**‌：由<code>JSR-250</code>提供，按照bean的id进行注入，可以独立使用。</li><li>‌**<code>@Primary</code>**‌：当存在多个相同类型的bean时，标记首选的bean进行注入。</li></ul><h2 id="Java配置类相关注解">Java配置类相关注解</h2><ul><li>‌**<code>@Configuration</code>**‌：声明当前类为配置类，相当于传统的XML配置文件。</li><li>‌**<code>@Bean</code>**‌：注解在方法上，声明当前方法的返回值为一个bean，替代XML中的<code>&lt;bean&gt;</code>标签。</li><li>‌**<code>@ComponentScan</code>**‌：用于指定Spring在创建容器时要扫描的包，以找到带有<code>@Component、@Repository、@Service、@Controller</code>等注解的类，并注册为bean。</li></ul><h2 id="切面（AOP）相关注解">切面（AOP）相关注解</h2><ul><li>‌**<code>@Aspect</code>**‌：声明一个切面。</li><li>‌**<code>@After</code>**‌：在目标方法执行之后执行。</li><li>‌**<code>@Before</code>**‌：在目标方法执行之前执行。</li><li>‌**<code>@Around</code>**‌：在目标方法执行之前和之后执行，可以围绕目标方法创建一个“拦截器”。</li><li>‌**<code>@PointCut</code>**‌：声明一个切点，即指定哪些方法将被增强。</li></ul><h2 id="配置和环境相关注解">配置和环境相关注解</h2><ul><li>‌**<code>@Value</code>**‌：用于注入基本类型和String类型的数据，支持使用<code>Spring EL</code>表达式。</li><li>‌**<code>@Profile</code>**‌：指定组件在哪个环境的情况下才能被注册到容器中。</li><li>‌**<code>@Conditional</code>**‌：通过实现Condition接口，并重写<code>matches</code>方法，从而决定该bean是否被实例化。</li></ul><h2 id="其他常用注解">其他常用注解</h2><ul><li>‌**<code>@Lazy</code>**‌：用于延迟初始化bean，即只有在第一次使用时才会创建和初始化。</li><li>‌**<code>@Scope</code><strong>‌：用于指定bean的作用范围，如</strong>单例（singleton）或多例（prototype）**。</li><li>‌**<code>@EnableAsync</code>**‌：在配置类中通过此注解开启对异步任务的支持。</li><li>‌**<code>@Async</code>**‌：在实际执行的bean方法使用该注解来声明其是一个异步任务。</li><li>‌**<code>@EnableScheduling</code>**‌：在配置类上使用，开启计划任务的支持。</li><li>‌**<code>@Scheduled</code>**‌：用于声明一个定时任务。</li></ul>]]></content>
    
    
    <summary type="html">在Spring框架中，注解是一种非常重要的特性，它极大地简化了配置和开发过程。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="Spring" scheme="https://southernfish.github.io/categories/Framwork/Spring/"/>
    
    
    <category term="Spring Boot" scheme="https://southernfish.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>使用多线程解决问题</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-thread-impl/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-thread-impl/</id>
    <published>2025-06-23T12:25:36.000Z</published>
    <updated>2025-06-24T06:44:33.644Z</updated>
    
    <content type="html"><![CDATA[<p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同<a href="https://baike.baidu.com/item/%E4%B8%80%E6%97%B6%E9%97%B4/3618565?fromModule=lemma_inlink">一时间</a>执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括<a href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA/10375153?fromModule=lemma_inlink">对称多处理机</a>、<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%A0%B8%E5%BF%83/1013410?fromModule=lemma_inlink">多核心</a>处理器以及<a href="https://baike.baidu.com/item/%E8%8A%AF%E7%89%87%E7%BA%A7%E5%A4%9A%E5%A4%84%E7%90%86/924724?fromModule=lemma_inlink">芯片级多处理</a>或<a href="https://baike.baidu.com/item/%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B/22689341?fromModule=lemma_inlink">同时多线程</a>处理器。在一个程序中，这些独立运行的程序片段叫作“<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fromModule=lemma_inlink">线程</a>”（Thread），利用它编程的概念就叫作“多线程处理” 。本文简单记录一些关于线程、多线程的问题。本文记录了关于一些常见多线程业务问题处理。</p><h2 id="多线程问题-1">多线程问题 1</h2><p>**问题：**100个线程并发向1个银行账户中存入1元钱,并在全部完成后，打印银行账户的金额。</p><p>**思路：**创建100个线程（<code>线程池</code>）；保证线程安全，同一时刻只有一个线程对账户进行操作（<code>Lock</code> 或者 <code>synchronized</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种加锁 synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="comment">// 获得账户余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁 存钱方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> <span class="built_in">this</span>.balance + money;</span><br><span class="line">        <span class="built_in">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种锁 lock</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="comment">// 获得账户余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁 存钱方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        reentrantLock.lock;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newBalance = balance + money;</span><br><span class="line">            balance = newBalance;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">          reentrantLock.unlock();  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存钱的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadSaveAccount</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TheadSaveAccount</span><span class="params">(Account account, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁 整个账户</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            account.deposit(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadSave</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            service.execute( <span class="keyword">new</span> <span class="title class_">TheadSaveAccount</span>(account, <span class="number">1</span>) );</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">        <span class="keyword">if</span> (service.isTerminated()) &#123;</span><br><span class="line">            System.out.println(account.getBalance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多线程是并行化的一种形式，或者是拆分工作以便同时进行处理。线程化的程序将工作拆分到多个软件线程，而不是将大量工作交给单个内核。这些线程由不同的 CPU 内核并行处理，以节省时间。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务</title>
    <link href="https://southernfish.github.io/2025/06/23/framwork/spring-transaction/"/>
    <id>https://southernfish.github.io/2025/06/23/framwork/spring-transaction/</id>
    <published>2025-06-23T07:52:36.000Z</published>
    <updated>2025-06-24T06:44:33.643Z</updated>
    
    <content type="html"><![CDATA[<p>事务是一组操作的集合，是一个不可分割的操作。事务会把所有的操作作为一个整体，一起向数据库提交或者是撤销操作请求。所以这组操作要么同时成功，要么同时失败。我们在进行程序开发时，也会有事务的需求。</p><h1>Spring事务基本信息</h1><h2 id="Spring事务在解决什么问题">Spring事务在解决什么问题</h2><ol><li>**‌数据一致性‌：**在分布式系统中，多个服务或组件可能需要同时操作同一数据，事务确保这些操作要么全部成功，要么全部失败，从而保持数据的一致性。</li><li>**并发控制‌：**在多用户并发访问的情况下，事务可以控制对共享资源的访问，避免数据冲突和损坏。</li><li>**故障恢复‌：**当操作过程中发生错误时，事务可以回滚到操作前的状态，确保系统不会处于不一致的状态。</li></ol><h2 id="Spring事务的实现原理">Spring事务的实现原理</h2><p>Spring事务的实现<strong>基于<code> AOP</code> （面向切面编程）和 动态代理</strong> 。Spring通过代理机制对目标对象进行包装，插入事务管理的逻辑，包括开启事务、提交事务和回滚事务等。具体来说：</p><ul><li>‌<strong>动态代理</strong>‌：Spring使用 <code>JDK动态代理</code> 或 <code>CGLIB动态代理</code> 来创建代理对象。</li><li>‌<strong>AOP</strong>‌：通过切面编程，在方法调用前后插入事务管理的逻辑。</li></ul><h2 id="Spring事务的配置和使用">Spring事务的配置和使用</h2><p>在Spring中配置事务主要通过注解<code>@Transactional</code>来实现。该注解可以应用于类或方法上，指示该方法需要事务管理。</p><hr><h1>@Transactional</h1><h2 id="基础信息">基础信息</h2><p><code>@Transactional</code>是Spring框架中用于<strong>声明式事务管理的关键注解</strong>，其<em>核心功能</em>是确保标注的方法或类在数据库操作中遵循ACID原则（原子性、一致性、隔离性、持久性），实现要么全部成功提交，要么全部回滚的机制。通过AOP（面向切面编程）实现，在方法执行前开启事务，执行后根据结果提交或回滚。‌‌参考文章 <a href="https://juejin.cn/post/7473315367490781195">深入解析 @Transactional——Spring 事务管理的核心</a></p><h2 id="Spring-事务默认的回滚规则">Spring 事务默认的回滚规则</h2><p>只有未捕获的 <code>RuntimeException</code>（运行时异常）或 <code>Error</code> 才会触发回滚，而普通的 <code>Exception</code>（检查异常）不会触发回滚。</p><p>若你希望所有异常都能回滚，可加上 <code>rollbackFor = Exception.class</code>，避免出现“事务看起来生效了，但并没有真正回滚”的情况。</p><h2 id="常见属性配置">常见属性配置</h2><table><thead><tr><th>属性</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>propagation</td><td>控制事务传播行为（如REQUIRED、REQUIRES_NEW）</td><td>@Transactional(propagation = Propagation.REQUIRED)</td></tr><tr><td>isolation</td><td>设置事务隔离级别（如READ_COMMITTED）</td><td>@Transactional(isolation = Isolation.READ_COMMITTED)</td></tr><tr><td>rollbackFor</td><td>指定触发回滚的异常类型</td><td>@Transactional(rollbackFor = Exception.class)</td></tr><tr><td>timeout</td><td>定义事务超时时间（秒）</td><td>@Transactional(timeout = 30)</td></tr></tbody></table><h2 id="Spring事务为什么会失效">Spring事务为什么会失效</h2><ol><li><p><strong>try-catch导致的事务失效</strong></p><p>Spring 只有在方法抛出异常时，才会触发回滚。如果你在 catch 里吞掉了异常，那事务也就不会回滚了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePersonById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 业务处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// 触发异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">//  catch 里吞掉了异常，Spring 感知不到异常的发生</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发生异常，但事务未回滚&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 手动抛出异常</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePersonById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 业务处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// 触发异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;手动抛出异常，确保事务回滚&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异常自然传播</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePersonById</span><span class="params">(Long id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 业务处理</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// 事务会回滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方法不是public</strong></p><p><code>@Transactional</code> 只会作用于 <strong>public 方法</strong>，如果你加在 <code>private</code> 或 <code>protected</code> 方法上，事务不会生效。因为Spring 事务是通过 <strong>代理机制</strong> 实现的，而 JDK 动态代理只能代理 <code>public</code> 方法，所以其他访问级别的方法都不行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteDept</span><span class="params">(Long id)</span> &#123; &#125; <span class="comment">// 事务不会生效</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">deleteDept</span><span class="params">(Long id)</span> &#123; &#125; <span class="comment">// 事务不会生效</span></span><br></pre></td></tr></table></figure></li><li><p><strong>同一类里，方法互相调用</strong></p><p>这里 <code>deleteDept</code> 方法调用了 <code>deleteEmp</code>，但 <code>deleteEmp</code> 上的 <code>@Transactional</code> <strong>不会生效</strong>！原因是：Spring 的事务是基于<strong>代理</strong>的，<code>this.deleteEmp(id)</code> 直接调用了本类的方法，没有经过 Spring 代理，所以事务不会生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper deptMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDept</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.deleteEmp(id); <span class="comment">// 事务不会生效！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteEmp</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        empMapper.delByDeptId(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的处理方法应是<strong>通过 Spring 管理的 Bean 调用</strong>(如下)，或者使用 <code>ApplicationContext</code> 获取代理对象，再调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptServiceImpl self;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDept</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        self.deleteEmp(id); <span class="comment">// 事务生效！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteEmp</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        empMapper.delByDeptId(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>数据库引擎不支持事务</strong></p><p>如果你用的 MySQL <strong>表引擎是 MyISAM</strong>，事务是不可能生效的，因为 MyISAM <strong>根本不支持事务</strong>！要确保你的表是 InnoDB：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">WHERE</span> Name <span class="operator">=</span> <span class="string">&#x27;dept&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dept ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Transactional的传播机制">@Transactional的传播机制</h2><p>@Transactional注解<strong>支持多种事务传播机制</strong>，这些机制定义了事务的行为方式。通过<code>Propagation</code>配置，主要的传播机制及含义如下：</p><table><thead><tr><th>传播类型</th><th>含义</th></tr></thead><tbody><tr><td>Propagation.REQUIRED</td><td>如果当前已有事务则加入当前事务，否则开启新的事务</td></tr><tr><td>Propagation.REQUIRED_NEW</td><td>无论当前是否有事务都开启新的事务；如果当前存在事务，则把当前事务挂起。</td></tr><tr><td>Propagation.SUPPORTED</td><td>如果当前事务存在就加入事务，否则以非事务运行</td></tr><tr><td>Propagation.NOT_SUPPORTED</td><td>始终以非事务方式执行；如果当前存在事务，则挂起当前事务</td></tr><tr><td>Propagation.NEVER</td><td>不使用事务，如果当前事务存在，则抛出异常</td></tr><tr><td>Propagation.MANDATORY</td><td>当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</td></tr><tr><td>Propagation.NESTED</td><td>父子（嵌套）事务，父提交子提交，父回滚全回滚，子回滚不影响父事务</td></tr></tbody></table><p>这些传播机制提供了灵活的事务控制选项，可以根据不同的业务需求选择合适的事务行为，避免事务的方法过于长，一个事务里面调用的库表越多，就越有可能造成死锁，所以我们要根据具体的需要拆分使用。例如:</p><ul><li>在需要<em>确保操作完全独立于其他事务时，可以使用REQUIRES_NEW</em>；</li><li>在<em>不需要事务时，可以使用NOT_SUPPORTED或NEVER</em>；</li><li>在<em>需要嵌套事务时，可以使用NESTED</em>等</li></ul><p>避免事务的方法过于长，一个事务里面调用的库表越多，就越有可能造成死锁，所以我们要根据具体的需要拆分使用</p><h2 id="高吞吐量下使用-Transactional注解导致性能降低">高吞吐量下使用<code>@Transactional</code>注解导致性能降低</h2><ol><li><p><strong>批量处理</strong></p><p>尽可能将多个数据库操作合并到单个事务中。例如，可以使用JDBC的<code>batch updates</code>或者在<code>ORM框架</code>（如Spring Data JPA, Hibernate）中利用其批量操作功能。 示例（<code>Spring Data JPA</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchSave</span><span class="params">(List&lt;Entity&gt; entities)</span> &#123;</span><br><span class="line">    entityRepository.saveAll(entities);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>减少事务范围</strong></p><p>尽量减小@Transactional注解覆盖的方法范围。只在确实需要事务控制的代码块上使用@Transactional。例如，只在服务层而非控制器层使用事务。</p></li><li><p><strong>异步事务处理</strong></p></li></ol><p>对于非阻塞操作，可以考虑将事务逻辑移至异步处理中。例如，使用<code>@Async</code>注解来异步执行事务操作，但这通常需要额外的配置来确保事务的正确管理。示例（Spring <code>@Async</code>）：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncTransactionalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行事务操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>优化数据库配置</strong></p><ul><li><p><strong>索引优化</strong>：确保数据库表上有适当的索引，以加快查询和插入速度。</p></li><li><p><strong>连接池优化</strong>：使用高效的数据库连接池（如<code>HikariCP</code>），并合理配置其参数（如最大连接数、连接超时时间等）。</p></li><li><p><strong>读写分离</strong>：对于读多写少的应用，可以考虑实现数据库的读写分离。</p></li></ul></li><li><p><strong>避免大事务</strong></p><ul><li>避免在单个事务中处理大量数据。如果可能，将大事务拆分成多个小事务。</li></ul></li><li><p><strong>使用乐观锁或悲观锁</strong></p><ul><li>在高并发场景下，使用乐观锁或悲观锁可以减少锁的竞争，提高并发性能。乐观锁通常用于写操作较少的情况，而悲观锁则适用于写操作较多的情况。</li></ul></li></ol><hr><h1>@Transactional大事务处理</h1><p>此处转载自原文 <a href="https://blog.csdn.net/huangchong0107/article/details/136652281">Springboot @Transactional大事务处理的几点建议</a></p><h2 id="什么是大事务"><strong>什么是大事务</strong></h2><p>总体任务对应的事务<a href="https://so.csdn.net/so/search?q=%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4&amp;spm=1001.2101.3001.7020">运行时间</a>比较长，长时间未提交的事务</p><h2 id="大事务的危害"><strong>大事务的危害</strong></h2><ul><li>并发情况下，数据库连接池资源占满。大事务提交不及时，导致连接资源释放缓慢。</li><li>数据库死锁和锁等待。<code>innodb</code>引擎背景下，事务如果占用了排他锁，会容易导致并发情况下数据死锁或者锁等待。</li><li>大事务Rt时间长，容易导致接口超时。</li><li>大事务回滚时间长。</li><li>数据库主从架构下，数据同步延迟</li></ul><h2 id="解决方案"><strong>解决方案</strong></h2><ul><li><p><strong>将声明式事务的@Transactional方式 合理的替换为 编程式事务TransactionTemplate 的方式</strong><br>声明式事务的粒度最小是整个方法，可能会导致业务里不必要的逻辑都加了事务。编程式事务细化需要加事务的逻辑上，形成实际有用的事务块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// ....  业务代码</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="comment">//回滚</span></span><br><span class="line">                transactionStatus.setRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>将查询放在事务方法外</strong><br>使用@Transactional 又想避免产生大事务，需对方法进行拆分，将不需要事务管理的逻辑与事务操作分开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionTestService</span>&#123;</span><br><span class="line">    <span class="comment">// 避免同一个类内部方法相互调用，实例方法调用代理方法而导致事务失效</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TransactionTestService service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(ParamDto dto)</span>&#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        service.save(dto);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//事务操作</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(ParamDto dto)</span>&#123;</span><br><span class="line">        paramDao.insert(dto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>避免跨服务间的远程调用</strong><br>服务间的通讯及服务之间的调用时间 受网络环境和远端接口Rt时间的影响，可能会比较耗时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反例：</span></span><br><span class="line"><span class="comment">// 事务操作</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(ParamDto dto)</span>&#123;</span><br><span class="line">    <span class="comment">// 调用了其他服务</span></span><br><span class="line">    otherRemoteApi();</span><br><span class="line">    paramDao.insert(dto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改为：</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(ParamDto dto)</span>&#123;</span><br><span class="line">    <span class="comment">// 调用了其他服务</span></span><br><span class="line">    otherRemoteApi();</span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                  paramDao.insert(dto);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="comment">//回滚</span></span><br><span class="line">                transactionStatus.setRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>事务中不应该一次性处理太多的数据，可以使用分批执行</strong></p></li><li><p><strong>事务中的方法可以根据业务使用异步执行</strong></p></li></ul>]]></content>
    
    
    <summary type="html">Spring事务是一组操作的集合，是一个不可分割的操作。事务会把所有的操作作为一个整体，一起向数据库提交或者是撤销操作请求。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="Spring" scheme="https://southernfish.github.io/categories/Framwork/Spring/"/>
    
    
    <category term="Spring Boot" scheme="https://southernfish.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>并发编程</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-concurrency/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-concurrency/</id>
    <published>2025-06-23T06:29:36.000Z</published>
    <updated>2025-06-24T06:44:33.643Z</updated>
    
    <content type="html"><![CDATA[<p>并发，在<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192?fromModule=lemma_inlink">操作系统</a>中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA/128842?fromModule=lemma_inlink">处理机</a>上运行，但任一个时刻点上只有一个程序在处理机上运行。本文转载自<a href="https://blog.csdn.net/linxiaosongXXDDDGS/article/details/147779420">Java并发编程详解</a>。</p><h1>线程</h1><h2 id="线程基础">线程基础</h2><h3 id="线程的本质">线程的本质</h3><p>**线程是轻量级进程：**在同一个进程中，多个线程共享内存空间（堆、方法区），但每个线程拥有独立的栈和程序计数器（PC）。<br>并发 vs 并行：</p><ul><li>**并发：**线程在单核CPU上交替执行（时间片轮转）。</li><li>**并行：**多核CPU上线程真正同时运行</li></ul><h3 id="创建线程的两种方式">创建线程的两种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：继承Thread类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running by extending Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：实现Runnable接口（推荐，避免单继承限制，在Java中，类只能继承一个父类（单继承），但可以实现多个接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running by implementing Runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式1 启动线程（调用start()，而非run()！直接调用run()只是普通方法调用，不会创建新线程）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">        <span class="comment">// 方式2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()).start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Runnable</code>优势总结：</p><ul><li>**解耦任务与线程：**Runnable表示任务逻辑，<code>Thread</code>表示线程载体，符合面向对象的职责分离原则。</li><li>**资源共享：**多个线程可共享同一个Runnable实例（例如售票系统的共享票池）。</li><li>**灵活组合：**可与线程池（<code>ExecutorService</code>）、<code>Lambda表达式</code>等现代特性无缝结合。</li></ul><h3 id="线程的生命周期">线程的生命周期</h3><ol><li>新建（<code>New</code>）：线程对象已创建，但未调用<code>start()</code>。</li><li>就绪（<code>Runnable</code>）：调用<code>start()</code>后，等待CPU调度。</li><li>运行（<code>Running</code>）：获得CPU时间片，执行<code>run()</code>方法。</li><li>阻塞（<code>Blocked</code>）：因等待锁、I/O操作或<code>sleep()</code>等暂停执行。</li><li>终止（<code>Terminated</code>）：<code>run()</code>执行完毕或发生未捕获异常。</li></ol><h2 id="线程同步锁机制">线程同步锁机制</h2><h3 id="1、竞态条件（Race-Condition）">1、竞态条件（Race Condition）</h3><p>当多个线程同时访问共享资源且未正确同步时，结果依赖于线程执行顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 典型竞态条件示例：不安全的计数器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 非原子操作（实际为 read-modify-write）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、同步解决方案">2、同步解决方案</h3><ul><li><p><code>synchronized</code> 关键字：</p><ul><li><strong>同步方法</strong>：锁对象为当前实例（<code>this</code>）或类对象（静态方法）。</li><li><strong>同步代码块</strong>：显式指定锁对象（任意对象）。</li></ul></li><li><p><strong>Lock 接口</strong>（更灵活，支持超时、公平锁）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeCounterWithLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、volatile-关键字">3、volatile 关键字</h3><ul><li><strong>保证可见性</strong>：对<code>volatile</code>变量的修改立即对其他线程可见。</li><li><strong>禁止指令重排序</strong>：防止编译器和CPU优化导致的执行顺序错乱。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toggleFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = !flag; <span class="comment">// 非原子操作，volatile仅保证可见性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程间的协作">线程间的协作</h2><h3 id="1、-wait-、notify-、notifyAll">1、 wait()、notify()、notifyAll()</h3><ul><li><p>Object类的核心方法：</p><ul><li><p><code>wait()</code>：释放锁并进入等待状态。</p></li><li><p><code>notify()</code>：随机唤醒一个等待线程。</p></li><li><p><code>notifyAll()</code>：唤醒所有等待线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者线程逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> item)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">            wait(); <span class="comment">// 缓冲区满，等待消费者消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(item);</span><br><span class="line">        System.out.println(<span class="string">&quot;生产: &quot;</span> + item + <span class="string">&quot;，当前队列大小: &quot;</span> + queue.size());</span><br><span class="line">        notifyAll(); <span class="comment">// 通知消费者可以消费</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者线程逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            wait(); <span class="comment">// 缓冲区空，等待生产者生产</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;消费: &quot;</span> + item + <span class="string">&quot;，剩余队列大小: &quot;</span> + queue.size());</span><br><span class="line">        notifyAll(); <span class="comment">// 通知生产者可以生产</span></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SharedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.produce(i);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>); <span class="comment">// 模拟生产耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Producer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.consume();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟消费耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Consumer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2、Condition-接口">2、Condition 接口</h3><ul><li>与<code>Lock</code>配合使用，提供更精细的线程等待与唤醒。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> item)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                notFull.await(); <span class="comment">// 等待&quot;非满&quot;条件</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(item);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产: &quot;</span> + item + <span class="string">&quot;，队列大小: &quot;</span> + queue.size());</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 触发&quot;非空&quot;条件</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                notEmpty.await(); <span class="comment">// 等待&quot;非空&quot;条件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费: &quot;</span> + item + <span class="string">&quot;，剩余队列大小: &quot;</span> + queue.size());</span><br><span class="line">            notFull.signal(); <span class="comment">// 触发&quot;非满&quot;条件</span></span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AdvancedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdvancedBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建生产者线程（Lambda实现Runnable）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.produce(i);</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.consume();</span><br><span class="line">                    Thread.sleep(<span class="number">800</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1><a href="https://so.csdn.net/so/search?q=%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B&amp;spm=1001.2101.3001.7020">并发编程</a></h1><h2 id="并发工具类-java-util-concurrent">并发工具类(java.util.concurrent)</h2><h3 id="1、Executor-框架">1、Executor 框架</h3><ul><li><p><strong>线程池管理</strong>：避免频繁创建/销毁线程的开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建固定大小的线程池（4个线程）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交10个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由 &quot;</span> </span><br><span class="line">                    + Thread.currentThread().getName() + <span class="string">&quot; 执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池（不再接受新任务）</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、并发集合">2、并发集合</h3><ul><li><p><strong>线程安全容器</strong>：避免手动同步。</p><ul><li><p><code>CopyOnWriteArrayList</code>：读多写少场景。</p></li><li><p><code>ConcurrentHashMap</code>：高并发哈希表。</p></li><li><p><code>BlockingQueue</code>：阻塞队列（如<code>LinkedBlockingQueue</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap 示例</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个写线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key-&quot;</span> + threadId + <span class="string">&quot;-&quot;</span> + j;</span><br><span class="line">                    map.put(key, j);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;写线程 &quot;</span> + threadId + <span class="string">&quot; 完成&quot;</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建读线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前Map大小: &quot;</span> + map.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3、原子类（Atomic）">3、原子类（Atomic）</h3><ul><li><p>基于CAS（Compare-And-Swap）保证原子性，实现无锁线程安全。</p></li><li><p>性能优于<code>synchronized</code>，适用于高并发场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count.incrementAndGet(); <span class="comment">// 原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count.get()); <span class="comment">// 正确输出20000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、CountDownLatch-与-CyclicBarrier">4、CountDownLatch 与 CyclicBarrier</h3><ul><li><p><strong>CountDownLatch</strong>：等待多个任务完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TASK_COUNT</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(TASK_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动多个任务线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= TASK_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 开始执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 完成&quot;</span>);</span><br><span class="line">                latch.countDown(); <span class="comment">// 计数器减1    多个线程调用 latch.countDown()</span></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待所有任务完成</span></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务已完成，继续主线程逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>CyclicBarrier</strong>：多个线程相互等待至屏障点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; System.out.println(<span class="string">&quot;All threads reached barrier&quot;</span>));</span><br><span class="line"><span class="comment">// 每个线程调用 barrier.await()</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="典型陷阱">典型陷阱</h2><h3 id="1、死锁（Deadlock）">1、死锁（Deadlock）</h3><p>四个必要条件：</p><ol><li><strong>互斥</strong>：资源只能被一个线程持有。</li><li><strong>占有且等待</strong>：线程持有资源并等待其他资源。</li><li><strong>不可抢占</strong>：资源不能被强制释放。</li><li><strong>循环等待</strong>：多个线程形成环形等待链。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 死锁示例</span></span><br><span class="line"><span class="comment">// Thread 1: lock A → try lock B</span></span><br><span class="line"><span class="comment">// Thread 2: lock B → try lock A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程1：先获取lockA，再请求lockB</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1 持有lockA&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟操作耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1 获取lockB&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2：先获取lockB，再请求lockA</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2 持有lockB&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2 获取lockA&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：破坏任一条件，如按固定顺序获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免死锁（统一锁顺序）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockSolution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 所有线程按相同顺序获取锁（先lockA后lockB）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; acquireLocks(lockA, lockB, <span class="string">&quot;线程1&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; acquireLocks(lockA, lockB, <span class="string">&quot;线程2&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">acquireLocks</span><span class="params">(Object firstLock, Object secondLock, String threadName)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (firstLock) &#123;</span><br><span class="line">            System.out.println(threadName + <span class="string">&quot; 持有 &quot;</span> + firstLock);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (secondLock) &#123;</span><br><span class="line">                System.out.println(threadName + <span class="string">&quot; 获取 &quot;</span> + secondLock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、活锁（Livelock）">2、活锁（Livelock）</h3><p>线程不断重试失败的操作（如谦让式资源释放），但无法推进。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 活锁示例：两个线程互相让出CPU</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryLock(lockA)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryLock(lockB)) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; unlock(lockA); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.yield(); <span class="comment">// 让出CPU但未解决问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LivelockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">active</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(Runnable task, Worker otherWorker)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!active) &#123;</span><br><span class="line">                <span class="keyword">if</span> (otherWorker.active) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;让出执行权...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    active = <span class="literal">true</span>;</span><br><span class="line">                    task.run();</span><br><span class="line">                    active = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    active = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Worker</span> <span class="variable">worker1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Worker</span> <span class="variable">worker2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; worker1.work(() -&gt; System.out.println(<span class="string">&quot;Worker1执行任务&quot;</span>), worker2)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; worker2.work(() -&gt; System.out.println(<span class="string">&quot;Worker2执行任务&quot;</span>), worker1)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、资源竞争与性能问题">3、资源竞争与性能问题</h3><p>资源竞争和性能问题是并发编程中的核心挑战之一。以下通过具体示例展示资源竞争导致的数据错误，以及不同锁策略对性能的影响，并给出优化方案。</p><ul><li><strong>锁粒度</strong>：粗粒度锁（简单但低效） vs 细粒度锁（复杂但高效）。</li><li><strong>锁分离</strong>：如<code>ReadWriteLock</code>分离读锁与写锁。</li></ul><p><strong>示例1：资源竞争导致数据错误（未同步的计数器）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeCounterExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count++; <span class="comment">// 非原子操作：read → modify → write</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动两个线程同时修改count</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预期结果：20000，实际结果可能小于20000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count); <span class="comment">// 结果不确定，因线程竞争而异</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题分析</strong>：</p><ul><li><p><code>count++</code> 是非原子操作，实际包含以下步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int tmp = count;  // Step 1: 读取当前值</span><br><span class="line">tmp = tmp + 1;    // Step 2: 修改值</span><br><span class="line">count = tmp;      // Step 3: 写回新值</span><br></pre></td></tr></table></figure></li><li><p>当两个线程同时执行时，可能出现以下时序：</p><ul><li>线程A读取<code>count=100</code> → 线程B读取<code>count=100</code> → 线程A写入<code>101</code> → 线程B写入<code>101</code></li><li>最终结果为<code>101</code>，而非预期的<code>102</code>。</li></ul></li></ul><p><strong>示例2：粗粒度锁的性能问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoarseLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 粗粒度锁：锁住整个循环</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时: &quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Final count: <span class="number">200000</span></span><br><span class="line">耗时: 120ms  <span class="comment">// 实际时间因机器性能而异，但明显较长</span></span><br></pre></td></tr></table></figure><p><strong>问题分析</strong>：</p><ul><li><strong>粗粒度锁</strong>：将整个循环包裹在<code>synchronized</code>块内，每次循环都会获取/释放锁。</li><li><strong>性能问题</strong>：频繁的锁竞争导致大量线程上下文切换，CPU时间浪费在锁管理而非实际计算。</li></ul><p><strong>示例3：细粒度锁优化（减少锁范围）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FineGrainedLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">localCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                localCount++; <span class="comment">// 先在线程本地累加</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 仅对最终合并操作加锁</span></span><br><span class="line">                count += localCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时: &quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Final count: <span class="number">200000</span></span><br><span class="line">耗时: 5ms  <span class="comment">// 性能显著提升</span></span><br></pre></td></tr></table></figure><p><strong>优化分析</strong>：</p><ul><li><strong>细粒度锁</strong>：线程先在本地变量<code>localCount</code>中累加，最后仅对合并操作加锁。</li><li><strong>性能提升</strong>：锁竞争频率从每次循环减少到每线程一次，大幅降低同步开销。</li></ul><p><strong>示例4：锁分离（读写锁优化）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 写线程（频繁修改数据）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">writer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                rwLock.writeLock().lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    value++;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>); <span class="comment">// 模拟写操作耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    rwLock.writeLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读线程（频繁读取数据）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">reader</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                rwLock.readLock().lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;读取 value: &quot;</span> + value);</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>); <span class="comment">// 模拟读操作耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    rwLock.readLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动2个写线程和4个读线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(writer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(writer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化分析</strong>：</p><ul><li><strong>读写锁分离：</strong><ul><li><strong>读锁（共享锁）</strong>：允许多个线程同时读数据。</li><li><strong>写锁（独占锁）</strong>：仅允许单个线程写数据，且与读锁互斥。</li></ul></li><li><strong>适用场景</strong>：读多写少（如缓存系统），通过减少锁竞争提升吞吐量。</li></ul><hr><h1>关键性总结</h1><ol><li><strong>资源竞争问题</strong>：<ul><li><strong>表现</strong>：多线程同时修改共享数据导致结果错误（如计数器值不准确）。</li><li><strong>解决方案</strong>：使用同步机制（<code>synchronized</code>、<code>Lock</code>）保证原子性。</li></ul></li><li><strong>性能优化策略</strong>：<ul><li><strong>减少锁粒度</strong>：仅对必要代码块加锁（如示例3的本地累加优化）。</li><li><strong>锁分离</strong>：读写锁（<code>ReadWriteLock</code>）区分读写操作，提升并发度。</li><li><strong>无锁编程</strong>：使用原子类（<code>AtomicInteger</code>）或并发容器（<code>ConcurrentHashMap</code>）。</li></ul></li><li><strong>性能测试建议</strong>：<ul><li>对比不同锁策略的耗时（如示例2和示例3的耗时差异）。</li><li>使用性能分析工具（如<code>JProfiler</code>、<code>VisualVM</code>）定位瓶颈。</li></ul></li></ol><h1>最佳实践</h1><ol><li>**优先使用高层并发工具:**如<code>Executor</code>、<code>ConcurrentHashMap</code>。</li><li>**避免过早优化：**仅在性能瓶颈出现时考虑低层同步。</li><li>**测试并发代码：**使用压力测试工具（如<code>JMeter</code>）和静态分析工具（如<code>FindBugs</code>）。</li><li>**遵循不变性（Immutability）：**使用<code>final</code>字段和不可变对象（如<code>String</code>）。</li></ol>]]></content>
    
    
    <summary type="html">并发，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>List</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-list/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-list/</id>
    <published>2025-06-23T06:15:36.000Z</published>
    <updated>2025-06-24T06:44:33.644Z</updated>
    
    <content type="html"><![CDATA[<p>List 是 Java 集合框架中的有序列表，元素按插入顺序存储，支持通过索引（从 0 开始）访问。类似数组，但提供动态增删功能，避免数组手动扩容和元素移动的繁琐。</p><h1>基础</h1><h2 id="List的接口方法">List的接口方法</h2><p>List接口继承自<code>Collection</code>接口，提供了额外的功能来处理索引位置上的元素。与Set、Map不同，List允许包含重复的元素，并且可以通过索引来访问或修改特定位置的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 核心接口方法 */</span></span><br><span class="line">add(E e) <span class="comment">// 添加指定元素到列表末尾。</span></span><br><span class="line">add(<span class="type">int</span> index, E element)<span class="comment">// 在指定索引处插入指定元素。</span></span><br><span class="line">remove(<span class="type">int</span> index) <span class="comment">// 移除指定索引处的元素。</span></span><br><span class="line">get(<span class="type">int</span> index) <span class="comment">// 获取指定索引处的元素。</span></span><br><span class="line">set(<span class="type">int</span> index, E element) <span class="comment">// 替换指定索引处的元素。</span></span><br><span class="line">size() <span class="comment">// 返回列表中的元素数量。</span></span><br><span class="line"><span class="comment">/* 其他常用方法 */</span> </span><br><span class="line">isEmpty() <span class="comment">// 判断列表是否为空。</span></span><br><span class="line">contains(Object o) <span class="comment">// 检查列表是否包含指定元素。</span></span><br><span class="line">indexOf(Object o) <span class="comment">// 返回指定元素首次出现的索引，如果不存在则返回-1。</span></span><br><span class="line">lastIndexOf(Object o) <span class="comment">// 返回指定元素最后一次出现的索引，如果不存在则返回-1。</span></span><br><span class="line">subList(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex) <span class="comment">// 获取从fromIndex（包括）到toIndex（不包括）之间的子列表</span></span><br></pre></td></tr></table></figure><h2 id="主要实现类">主要实现类</h2><ol><li><p><code>ArrayList</code></p><p>ArrayList是最常用的List实现之一，它基于动态数组实现，支持随机访问，查询效率高，但插入和删除效率较低。<br><strong>特点</strong>：支持快速随机访问。非线程安全。初始容量为10，每次扩容时增长50%。<br><strong>使用场景</strong>：适用于频繁读取而不经常修改的数据集合。</p></li><li><p><code>LinkedList</code></p><p>LinkedList是另一个重要的List实现，它基于双向链表实现，对于插入和删除操作具有较高的性能，但对于随机访问效率较低。<br><strong>特点</strong>：支持高效的插入和删除操作。非线程安全。可以作为堆栈、队列或双端队列使用。<br><strong>使用场景</strong>：适用于频繁进行插入和删除操作的数据集合。</p></li><li><p><code>Vector</code></p><p>早期线程安全集合类，通过方法级<code>synchronized</code>实现同步。默认扩容增长一倍。<br><strong>特点</strong>：线程安全同步锁导致并发效率低下（方法都使用了 synchronized）。性能低（主要用于同步开销）。遗留类，不推荐使用</p></li><li><p>三者对比</p><table><thead><tr><th></th><th>ArrayList</th><th>LinkedList</th><th>Vector</th></tr></thead><tbody><tr><td>底层结构</td><td>动态数组</td><td>双向链表</td><td>动态数组</td></tr><tr><td>线程安全</td><td>不安全</td><td>不安全</td><td>安全，方法都加了<code>Synchronized</code></td></tr><tr><td>是否允许重复元素</td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td>是否有序</td><td>是</td><td>是</td><td>是</td></tr><tr><td>随机访问</td><td>快O(1)，索引访问</td><td>慢O(n)，需遍历链表</td><td>快O(1)，但因同步影响性能较低</td></tr><tr><td>插入/删除</td><td>慢O(n)，需移动元素</td><td>快O(1)，只需修改指针</td><td>慢，同步开销大</td></tr><tr><td>扩容机制</td><td>默认增长50%</td><td>无需扩容，动态添加节点</td><td>默认翻倍容量</td></tr><tr><td>加载因子</td><td>1</td><td>无</td><td>1</td></tr></tbody></table></li></ol><h2 id="遍历方式">遍历方式</h2><ol><li><p><code>for</code>循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：可以灵活控制索引。支持随机访问（适合 ArrayList）。</span></span><br><span class="line"><span class="comment">// 缺点：对于 LinkedList 来说效率较低（因为每次都要从头开始查找元素）。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Index: &quot;</span> + i + <span class="string">&quot;, Value: &quot;</span> + list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：简洁易读。适用于所有实现了 Iterable 接口的集合类。</span></span><br><span class="line"><span class="comment">// 缺点：无法获取索引。不能修改集合结构（如删除元素会抛出异常）。</span></span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Item: &quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Iterator</code>。可以安全地在遍历时进行删除操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;B&quot;</span>.equals(item)) &#123;</span><br><span class="line">        iterator.remove();  <span class="comment">// 安全删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="去重方式">去重方式</h2><ol><li><p>利用 <code>HashSet</code> 或 <code>LinkedHashSet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet 不保留顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出顺序可能不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashSet 保留插入顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Stream.distinct()</code>，Java 8+ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; uniqueList = list.stream().distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(uniqueList);</span><br></pre></td></tr></table></figure></li></ol><h2 id="List-与数组的转换">List 与数组的转换</h2><ul><li><p>List 转数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无类型参数：丢失类型信息</span></span><br><span class="line">Object[] array = list.toArray();</span><br><span class="line"><span class="comment">// 带类型参数：推荐，自动匹配类型</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 函数式写法</span></span><br><span class="line">String[] array = list.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></li><li><p>数组转 List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(array);（只读）</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));（可修改）</span><br></pre></td></tr></table></figure></li></ul><h2 id="List-的元素判断机制">List 的元素判断机制</h2><p>List的 <code>contains(Object o)</code> 和 <code>indexOf(Object o)</code> 方法通过 <code>equals()</code>而非 <code>==</code> 判断元素是否相等。</p><hr><h1>List的安全类</h1><p>在单线程应用中，通常采取<code>new ArrayList()</code>，指定一个List集合，用于存放可重复的数据。但<code>ArrayList</code>是不安全的集合。多线程操作同一集合对象信息，往往会出现<code>java.util.ConcurrentModificationException</code>异常报错信息。</p><h2 id="Java的安全类Vector">Java的安全类Vector</h2><p>java提供了<code>java.util.Vector</code>类，多线程下不会出现<code>java.util.ConcurrentModificationException</code>报错信息。因为采取了 <code>synchronized</code> 针对方法执行调用者加锁，保证add操作的多线程安全性！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建lists集合</span></span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JUC下的安全List集合">JUC下的安全List集合</h2><ol><li><code>Collections.synchronizedList(new ArrayList&lt;&gt;());</code>。该方法返回具有同步包装器的List，保证了对List的操作是安全的。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">( <span class="meta">@NotNull</span> List&lt;T&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(list <span class="keyword">instanceof</span> RandomAccess ? </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list) : </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">synchronizedList</span>&lt;&gt;(list));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断传入的 list 集合类型，判断类型是否为 java.util.RandomAccess，如果是则采取java.util.Collections.SynchronizedRandomAccessList构造集合，如果不是则采取java.util.Collections.SynchronizedList构造集合。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码中对应的add操作逻辑如下所示。采取synchronized同步代码块的方式，对数据的add操作实现加锁！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>&#123; </span><br><span class="line">    synchron1zed (mutex) &#123;</span><br><span class="line">        list.add(index, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>new CopyOnWriteArrayList();</code>。该类中所有修改操作都在一个独立的副本上进行，不会影响原始数据，保证了线程安全。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&quot;</span>+lists);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates an empty list</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyonWriteArrayList</span><span class="params">()</span>&#123; setArray(<span class="keyword">new</span> <span class="title class_">object</span>[<span class="number">0</span>]); &#125;</span><br><span class="line"><span class="comment">// add 逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[]elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copy0f(elements, len +<span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>add</code>逻辑如下所示</strong><br>1、调用add方法后，拿到<code>java.util.concurrent.locks.ReentrantLock</code>对象信息。<br>2、调用 <code>lock.lock()</code> 拿到锁！<br>3、将原数组对象<code>copy</code>操作，并创建<code>原数组大小+1</code>的新数组。<br>4、将新数据放入新数组中。<br>5、任何操作<code>finally</code>，都进行锁的释放！</p><p>原文链接：<a href="https://blog.csdn.net/qq_47980550/article/details/148012216">java基础——java集合list详解</a>、<a href="https://blog.csdn.net/qq_38322527/article/details/114703142">JUC中的List安全类集合</a></p>]]></content>
    
    
    <summary type="html">List是 Java 集合框架中的有序列表，元素按插入顺序存储，支持通过索引（从 0 开始）访问。类似数组，但提供动态增删功能，避免数组手动扩容和元素移动的繁琐。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="集合框架" scheme="https://southernfish.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Set</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-set/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-set/</id>
    <published>2025-06-23T05:49:36.000Z</published>
    <updated>2025-06-24T06:44:33.644Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的Set是集合框架（Collection Framework）的核心接口之一，用于存储无序且唯一的元素。主要实现类包括HashSet（基于哈希表）、LinkedHashSet（维护插入顺序）和TreeSet（基于红黑树排序），三者分别适用于快速查找、保持插入顺序和自然排序的场景。</p><h1>Set</h1><p>List是有序集合的根接口，Set是无序集合的根接口，无序也就意味着元素不重复。更严格地说，Set集合不包含一对元素e1和e2 ，使得e1.equals(e2) ，并且最多一个空元素。<br>使用Set存储的特点与List相反：<strong>元素无序、不可重复</strong>。常用的实现方式：HashSet、LinkedHashSet和TreeSet。</p><table><thead><tr><th>具体实现</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>HashSet</td><td>底层数据结构是哈希表，可以存储null元素，效率高</td><td>线程不安全，需要重写hashCode()和equals()来保证元素唯一性</td></tr><tr><td>LinkedHashSet</td><td>底层数据结构是链表和哈希表(链表保证了元素的顺序与存储顺序一致，哈希表保证了元素的唯一性)，效率高</td><td>线程不安全</td></tr><tr><td>TreeSet</td><td>底层数据结构是二叉树，元素唯一且已经排好序</td><td>需要重写hashCode和equals()来保证元素唯一性</td></tr></tbody></table><p>当向HashSet结合中存入一个元素时，HashSet会调用该对象的<code>hashCode()</code>方法来得到该对象的hashCode值，然后根据hashCode值来决定该对象在HashSet中存储位置。简单的说，<strong>HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等</strong>。<br>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p><p>在使用Set存储数据时，为保障元素唯一性，常常要重写hashCode。重写hashCode方法时，尽量遵循以下原则：</p><ul><li>相同的对象返回相同的hashCode值。</li><li>不同的对象返回不同的hashCode值，否则，就会增加冲突的概率。</li><li>尽量的让hashCode值散列开（用异或运算可使结果的范围更广）。</li></ul><p>原文链接：<a href="https://blog.csdn.net/m0_37741420/article/details/112407684">Java集合（四）Set的常用实现类</a></p><hr><h1>HashSet</h1><h2 id="特点">特点</h2><p>HashSet是一个无序集合，其底层结构是HashMap，简单来说，HashSet是value是固定值（<code>Object PRESENT = new Object()</code>）的HashMap。HashSet的特点(<strong>底层是HashMap/元素无序且不能重复/线程不安全</strong>)：</p><ul><li><p>HashSet的<strong>底层实现是HashMap</strong>（HashSet的值存放于HashMap的key上，HashMap的value是一个统一的值）。</p></li><li><p>HashSet中的<strong>元素无序且不能重复</strong>（从插入HashSet元素的顺序和遍历HashSet的顺序对比可以看出：遍历顺序和存入到Set的顺序并不一致）。</p></li><li><p>HashSet是<strong>线程不安全</strong>的。如果要保证线程安全，其中一种方法是将其改造成线程安全的类，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>(...));</span><br></pre></td></tr></table></figure></li><li><p>HashSet<code>允许存入null</code></p></li></ul><h2 id="HashSet如何检查重复">HashSet如何检查重复</h2><p>把对象加入HashSet时，HashSet会<strong>先计算对象的hashcode值来判断对象加入的位置</strong>，同时也会与Set中其他元素的hashcode值作比较，如果没有相同的hashcode，HashSet会假设对象没有重复出现。如果发现有相同hashcode值的对象，这时会调用<code>equals</code>方法来检查<strong>hashcode相等的对象是否真的相同</strong>。如果两者相同，HashSet就不再存储该元素。<code>hashCode()</code>与 <code>equals()</code>的相关规定：</p><ul><li>如果两个对象相等，则hashcode一定也是相同的；</li><li>两个对象相等，对两个equals方法返回true；</li><li>两个对象有相同的hashcode值，它们也不一定是相等的；</li><li>如果equals方法被覆盖过，则hashCode方法也必须被覆盖；</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该 class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ul><h2 id="HashSet的使用">HashSet的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> <span class="comment">// 默认初始容量为16，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> <span class="comment">// 指定初始容量，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> <span class="comment">// 指定初始容量和负载因子</span></span><br><span class="line"><span class="comment">/* 增、删、包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断Set是否为空    </span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> <span class="comment">//获取迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 返回此集合中的元素数        </span></span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet">LinkedHashSet</h2><h2 id="特点-2">特点</h2><p>LinkedHashSet是有序集合，其底层是通过LinkedHashMap来实现的，LinkedHashMap其实也就是value是固定值的LinkedHashMap。因此LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。LinkedHashSet继承了HashSet。LinkedHashSet的特点(<strong>底层是LinkedHashMap/线程不安全/元素有序</strong>)：</p><ul><li><p>底层是用LinkedHashMap来实现的。</p></li><li><p>线程不安全 。</p></li><li><p>元素有序，是按照插入的顺序排序的。</p></li><li><p>最多只能存一个null。</p></li><li><p>不支持按访问顺序对元素排序</p><p>LinkedHashSet所有的构造方法都是调用HashSet的同一个构造方法：（accessOrder = false）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1>TreeSet</h1><h2 id="特点-3">特点</h2><p>TreeSet是一个有序集合，基于TreeMap实现。TreeSet特点(支持元素排序/线程不安全/):</p><ul><li><p>TreeSet支持元素的自然排序和按照在创建时指定的Comparator比较器(外比较器)进行排序</p><ul><li><p>TreeSet使用二叉树原理对新增对象按照指定顺序排序，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</p></li><li><p>TreeSet中存储自定义类的对象时， 自定义的类必须实现Comparable接口，并且覆写相应<code>compareTo()</code>函数。</p></li><li><p>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的。自己定义的类必须实现Comparable接口，并且覆写相应的compareTo()函数，才可以正常使用。</p></li><li><p>在重写compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>  <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(student s)</span> &#123;</span><br><span class="line">        <span class="comment">// 主要条件：按照年龄从小到大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="built_in">this</span>.age - s.age;</span><br><span class="line">        <span class="comment">//次要条件：年龄相同时，按照姓名的字母顺序排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num == <span class="number">0</span> ? <span class="built_in">this</span>.name.compareTo(s.name) : num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comparabledemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;student&gt; tree = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;student&gt;();</span><br><span class="line">        <span class="type">student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;wuer&quot;</span>,<span class="number">27</span>);</span><br><span class="line">        <span class="type">student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;weuers&quot;</span>,<span class="number">250</span>);</span><br><span class="line">        tree.add(s1);</span><br><span class="line">        tree.add(s2);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>TreeSet的基本操作（增删）的时间复杂度是log(n) 。</p></li><li><p>TreeSet是非线程安全的。</p></li><li><p>TreeSet的迭代器是fail-fast策略的。</p></li><li><p>TreeSet中元素不允许为null，不允许重复值。</p></li></ul><h2 id="TreeSet的使用">TreeSet的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> <span class="comment">// 创建一个空的 TreeSet，使用自然排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> <span class="comment">// 指定比较器，如果比较器是 null 将使用自然排序</span></span><br><span class="line"><span class="comment">/* 增 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> <span class="comment">// 添加一个元素</span></span><br><span class="line"><span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> <span class="comment">// 添加集合中的元素</span></span><br><span class="line"><span class="comment">/* 删 */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> <span class="comment">// 检索和删除最小（第一个）元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> <span class="comment">// 检索和删除最大（最后）元素</span></span><br><span class="line"><span class="comment">/* 包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 获取特殊元素 */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">last</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">first</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">floor</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中小于或者等于给定元素的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">ceiling</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中大于或者等于给定元素的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">higher</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中大于某个元素的最小的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">lower</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中小于某个元素的最大的元素   </span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 获取TreeSet元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断TreeSet是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空TreeSet</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java中的Set是集合框架（Collection Framework）的核心接口之一，用于存储无序且唯一的元素。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="集合框架" scheme="https://southernfish.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Map</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-map/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-map/</id>
    <published>2025-06-23T02:45:36.000Z</published>
    <updated>2025-06-24T06:44:33.644Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap是基于哈希表实现的键值对存储结构，提供高效的插入和查询操作（平均时间复杂度O(1)），允许null键/值，非线程安全，且不保证元素顺序。其核心实现包括数组+链表（JDK1.7及之前）或数组+链表+红黑树（JDK1.8及之后），通过哈希冲突解决机制（链地址法）和动态扩容优化性能。</p><h1>Map</h1><p><a href="https://so.csdn.net/so/search?q=Collection%E6%8E%A5%E5%8F%A3&amp;spm=1001.2101.3001.7020">Collection接口</a>的实现类中存储的是具体的单个元素，Map中存储的是键值对。常用的Map实现类有：HashMap、LinkedHashMap、TreeMap、HashTable和ConcurrentHashMap。</p><table><thead><tr><th>实现类</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>HashMap</td><td>基于哈希表实现，查询快，效率高</td><td>元素存储时无序，非线程安全</td></tr><tr><td>LinkedHashMap</td><td>基于哈希表和链表实现，可以保留元素插入时的顺序</td><td>非线程安全</td></tr><tr><td>TreeMap</td><td>存储的元素有序</td><td>非线程安全</td></tr><tr><td>HashTable</td><td>线程安全，不允许null值</td><td>效率低</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>线程安全，性能较好</td><td></td></tr></tbody></table><p>原文链接：<a href="https://blog.csdn.net/m0_37741420/article/details/112424663">Java集合（三）Map的常用实现类</a></p><hr><h1>HashMap</h1><h2 id="底层原理">底层原理</h2><p><code>HashMap</code>是基于哈希表实现的键值对存储结构，HashMap的核心实现结合了<code>数组</code>、<code>链表</code>和<code>红黑树</code>。</p><h3 id="数据结构">数据结构</h3><p><code>数组</code>：默认初始容量为16，数组的每个位置称为一个桶(<code>Bucket</code>)。容量始终为<strong>2的幂次方</strong>(如16、32)，便于通过位运算快速定位索引。<br><code>链表</code>：当多个键的哈希值冲突时，这些键值对以链表形式存储在同一个桶中（链地址法）。<br><code>红黑树</code>：当链表长度超过阈值（默认8）且数组容量≥64时，链表会转换为<code>红黑树</code>，以提高查找效率（从<code>O(n)</code>优化为<code>O(log n)</code>）。</p><h3 id="哈希函数与索引定位">哈希函数与索引定位</h3><p>HashMap通过哈希函数将键映射到数组的索引位置。具体步骤如下：</p><ol><li><p>调用键的<code>hashCode()</code>方法获取哈希值。</p></li><li><p>**扰动处理：**将高16位与低16位异或<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，减少哈希碰撞概率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>(n-1) &amp; hash</code>计算桶位置，等价于<code>hash % n</code>，但性能更高‌。</p></li></ol><h3 id="冲突处理机制">冲突处理机制</h3><ol><li><p>**链地址法：**冲突的键值对以链表形式链接。在JDK 8之前采用头插法，JDK 8之后采用尾插法以避免多线程下的死循环问题‌</p></li><li><p><strong>红黑树转换：</strong></p><ol><li><p>当链表长度≥8且数组容量≥64时，链表会转换为红黑树‌。</p></li><li><p>红黑树节点数≤6时，退化为链表</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250623125725272.png" alt="image-20250623125725272"></p></li></ol></li></ol><h3 id="动态扩容机制">动态扩容机制</h3><p>HashMap的扩容机制基于负载因子（默认值为0.75）。当元素数量超过<code>容量乘以负载因子</code>时，比如<strong>当数组添加到16*0.75=12时</strong>，HashMap会自动触发扩容，扩容为自身的两倍：16*2=32。扩容步骤如下：</p><ol><li>创建一个新的数组，<code>容量为原容量的两倍</code>（保持2的幂次方）。</li><li>重新计算所有元素的位置并放入新数组的对应位置，利用高位快速判断元素是否需要移动（如原索引为<code>oldIndex</code>，新索引可能为<code>oldIndex</code>或<code>oldIndex + oldCapacity</code>）。</li><li>扩容后，链表或红黑树可能会被拆分到不同的桶中‌</li></ol><h2 id="关键操作">关键操作</h2><ol><li><strong>插入（put</strong>）<ol><li>计算键的哈希值并定位桶索引。</li><li>桶为空：直接插入新节点。</li><li>桶非空：遍历链表或红黑树，若存在相同键（通过<code>equals</code>判断），则更新值；否则追加节点。</li><li>触发扩容：插入后检查元素总数是否超过阈值。</li></ol></li><li><strong>查询（get）</strong>：根据哈希值定位桶，遍历链表或红黑树，通过<code>equals</code>匹配键。</li></ol><h2 id="遍历方法">遍历方法</h2><h3 id="迭代器遍历">迭代器遍历</h3><ul><li><p><strong>遍历EntrySet（键值对）</strong>：支持通过<code>iterator.remove()</code>安全删除元素(优点)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;K, V&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>遍历KeySet（仅键）</strong>：性能低于<code>EntrySet</code>遍历，需多次调用<code>get()</code>（缺点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;K&gt; keyIterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key); <span class="comment">// 需要额外查询值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="for-each循环">for-each循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历EntrySet</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历键</span></span><br><span class="line"><span class="keyword">for</span> (K key : map.keySet()) &#123; ... &#125;</span><br><span class="line"><span class="comment">// 遍历值</span></span><br><span class="line"><span class="keyword">for</span> (V value : map.values()) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式遍历（Java-8-）">Lambda表达式遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach( (key, value) -&gt; System.out.println(key + <span class="string">&quot; : &quot;</span> + value) );</span><br></pre></td></tr></table></figure><h3 id="Stream-API遍历（Java-8-）">Stream API遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单线程遍历</span></span><br><span class="line">map.entrySet().stream().forEach(entry -&gt; ...);</span><br><span class="line"><span class="comment">// 多线程遍历</span></span><br><span class="line">map.entrySet().parallelStream().forEach(entry -&gt; ...);</span><br></pre></td></tr></table></figure><h3 id="性能对比">性能对比</h3><table><thead><tr><th><strong>遍历方式</strong></th><th><strong>时间复杂度</strong></th><th><strong>适用场景</strong></th><th><strong>线程安全</strong></th></tr></thead><tbody><tr><td>EntrySet迭代器</td><td>O(n)</td><td>需要删除元素</td><td>需手动同步</td></tr><tr><td>EntrySet for-each</td><td>O(n)</td><td>常规遍历</td><td>需手动同步</td></tr><tr><td>KeySet遍历</td><td>O(n)（性能较低）</td><td>仅需键</td><td>需手动同步</td></tr><tr><td>Lambda表达式</td><td>O(n)</td><td>代码简洁性优先</td><td>需手动同步</td></tr><tr><td>Stream API</td><td>O(n)</td><td>大数据量处理或并行计算</td><td>需手动同步</td></tr></tbody></table><p><strong>推荐选择</strong>：</p><ul><li><strong>需键值对</strong>：优先使用<code>entrySet()</code>（迭代器或for-each）。</li><li><strong>仅需键或值</strong>：直接遍历<code>keySet()</code>或<code>values()</code>。</li><li><strong>代码简洁性</strong>：Java 8+环境下推荐Lambda表达式。</li><li><strong>线程安全</strong>：改用<code>ConcurrentHashMap</code>或使用同步包装类。</li></ul><h2 id="HashMap安全">HashMap安全</h2><h3 id="HashMap线程不安全的表现">HashMap线程不安全的表现</h3><ol><li><strong>数据覆盖（丢失）</strong><br>**场景：**多线程同时调用 <code>put()</code> 方法插入数据。<br>**原因：**两个线程同时计算哈希值并定位到同一个桶(bucket)时，若该位置为空，可能发生数据覆盖。<strong>无锁导致复合操作非原子性</strong>。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设线程A和线程B同时执行以下代码</span></span><br><span class="line"><span class="keyword">if</span> (table[bucket] == <span class="literal">null</span>) &#123;</span><br><span class="line">    table[bucket] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value); <span class="comment">// 可能被覆盖</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK 1.8 的数据覆盖问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapUnsafeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;Map size: &quot;</span> + map.size()); <span class="comment">// 结果可能小于 1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>链表成环</strong>（JDK 1.7 的经典问题）<br>**场景：**多线程同时触发 <code>resize()</code>（扩容）。<br><strong>原因：<strong>JDK 1.7 的 HashMap 使用</strong>头插法</strong>迁移链表，<strong>并发扩容时可能导致链表成环</strong>，后续的 <code>get()</code>操作触发死循环</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.7 的扩容代码（简化）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程A执行到这里挂起</span></span><br><span class="line">            e.next = newTable[bucket]; <span class="comment">// 线程B先执行，导致链表成环</span></span><br><span class="line">            newTable[bucket] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>size 不准确</strong><br>**场景：**多线程同时调用 <code>put()</code> 或 <code>remove()</code>。<br>**原因：**size 变量是非原子操作（如 size++），并发修改可能导致最终值错误。<strong>非原子操作 + 无可见性保证</strong>。</li></ol><h3 id="HashMap线程不安全的根本原因">HashMap线程不安全的根本原因</h3><ol><li><strong>无同步机制</strong><br>HashMap 的设计目标是单线程高性能，未对多线程操作进行同步（如 <code>synchronized</code> 或 <code>CAS</code>）。<br>关键操作（<code>put()、get()、resize()</code>）没有锁保护。</li><li><strong>可见性问题</strong><br>多线程修改共享变量（如 <code>table、size</code>）时，未使用 <code>volatile</code> 关键字，可能导致一个线程的修改对其他线程不可见。</li><li><strong>复合操作非原子性</strong><br>例如 <code>put()</code> 操作包含多个步骤（计算哈希、定位桶、插入节点），多线程交叉执行时可能破坏内部结构。</li></ol><h3 id="解决方案-2">解决方案</h3><ol><li>使用线程安全的替代类<br><code>Collections.synchronizedMap()</code>：通过包装类对所有方法加锁（性能较差）。<br><code>ConcurrentHashMap</code>：分段锁（JDK 1.7）或 CAS + synchronized（JDK 1.8），高并发性能更好。</li><li>避免多线程直接操作 HashMap<br>限制为单线程使用，或通过副本、消息队列等方式隔离并发访问。</li></ol><hr><h1>ConcurrentHashMap</h1><h2 id="数据结构-2">数据结构</h2><ul><li>在<code>jdk1.7</code>版本<ul><li>ConcurrentHashMap的数据结构是由一个<code>Segment</code>数组和多个<code>HashEntry</code>组成。</li><li>主要实现原理是实现了<strong>锁分离</strong>的思路，采用<strong>分段锁的机制</strong>，实现并发的更新操作。</li><li>底层采用<strong>数组+链表</strong>的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。</li><li>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到 的锁分离技术。每一个Segment元素存储的是HashEntry 数组+链表（若干个桶），这个和HashMap的数据存储结构一样。</li><li>HashEntry用来封装映射表的键值对，每个桶是由若干个HashEntry对象链接起来的链表。</li></ul></li><li>在<code>jdk1.8</code>后<ul><li>取消了Segment类，直接用table数组存储键值对。采用<code>Node + CAS + Synchronized</code>来保证并发安全。</li><li>Node数据结构比较简单，就是一个链表，但是只允许对数据进行查找，不允许进行修改。</li><li>当HashEntry对象组成的链表长度超过8时，或数组长度小于64 就会扩容，则链表转换为红黑树，提升性能。底层变更为<strong>数组＋链表＋红黑树</strong>。</li></ul></li></ul><h2 id="底层原理（jdk1-8）">底层原理（jdk1.8）</h2><ol><li><p>Node节点数字用的是<code>volatile</code>修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap使用volatile修饰节点数组，保证其可见性，禁止指令重排。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p>ConcurrentHashMap的<code>put()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put()方法直接调用putVal()方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以直接看putVal()方法。</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            tab = initTable();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;                  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法并未用synchronized修饰。<strong>put过程如下：</strong><br>（1）根据 key 计算出 hashcode，然后开始遍历 table；<br>（2）判断是否需要初始化；<br>（3）f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。<br>（4）如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。<br>（5）如果都不满足，则利用 synchronized 锁写入数据。<br>（6）如果数量大于 TREEIFY_THRESHOLD ，则要转换为红黑树。</p></li><li><p>ConcurrentHashMap的<code>get()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap的get()方法是不加锁的，方法内部也没加锁。</span></span><br><span class="line"><span class="comment">// 因为table有`volatile`关键字修饰，保证每次获取值都是最新的。</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span></span><br></pre></td></tr></table></figure><p>get方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头节点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果头节点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get过程如下：</strong><br>（1）首先根据key计算出来的 hashcode 寻址，如果就在桶上那么直接返回值，<br>（2）如果是红黑树那就按照树的方式获取值，<br>（3）都不满足那就按照链表的方式遍历获取值。</p></li></ol><p>原文链接：<a href="https://blog.csdn.net/FAQEW/article/details/146542959">HashMap底层原理</a>、<a href="https://blog.csdn.net/winterPassing/article/details/148248794">HashMap安全性问题</a>、<a href="https://blog.csdn.net/qq_42077317/article/details/138009817">Java中的ConcurrentHashMap原理详解</a></p>]]></content>
    
    
    <summary type="html">HashMap是基于哈希表实现的键值对存储结构，提供高效的插入和查询操作（平均时间复杂度O(1)），允许null键/值，非线程安全，且不保证元素顺序。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="集合框架" scheme="https://southernfish.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的较难题</title>
    <link href="https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-hard/"/>
    <id>https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-hard/</id>
    <published>2025-06-22T13:30:36.000Z</published>
    <updated>2025-06-24T06:44:33.641Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集了一些<a href="https://leetcode.cn/">LeetCode</a>的一些较难的题目。</p><h2 id="找出两个正序数组的中位数">找出两个正序数组的中位数</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 (归并、快速排序 n.log(n))。假设 nums1 和 nums2 不会同时为空。<br>示例 1: nums1 = [1, 3]   nums2 = [2]       则中位数是 2.0<br>示例 2: nums1 = [1, 2]   nums2 = [3, 4]   则中位数是 (2 + 3)/2 = 2.5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">problem1</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 偶数个 排序后 找下标 (nums1.length + nums2.length) / 2 和 (nums1.length + nums2.length) / 2 - 1</span></span><br><span class="line">    <span class="keyword">if</span>((nums1.length + nums2.length) % <span class="number">2</span> == <span class="number">0</span> )&#123; </span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 相同长度部分</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt;= nums2[j])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// right</span></span><br><span class="line">                    right = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot; -&gt;&quot;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// right</span></span><br><span class="line">                    right = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组1 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// right</span></span><br><span class="line">                right = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组2 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// right</span></span><br><span class="line">                right = nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left + right) <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 奇数个 找下标 (nums1.length + nums2.length - 1) / 2        </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;   </span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 相同长度部分</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt;= nums2[j])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组1 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组2 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支持’-‘和’-的正则表达式匹配">支持’.‘和’*'的正则表达式匹配</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持<code> '.'</code> 和 <code>'*'</code> 的正则表达式匹配。<code>'.' </code>匹配任意单个字符；<code>'*' </code>匹配零个或多个前面的那一个元素所谓匹配，是要涵盖整个字符串 s的，而不是部分字符串。<br>说明：s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 <em>。<br>示例 1：输入: s = “aa”    p = “a”   输出: false。解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2：输入: s = “aa”    p = &quot;a</em>&quot;   输出: true。<br>解释: ‘<em>’ 代表可匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。<br>示例 3：输入: s = “ab”    p = &quot;.</em>&quot;   输出: true。解释: &quot;.<em>&quot; 表示可匹配零个或多个（'</em>’）任意字符（‘.’）。<br>示例 4：输入: s = “aab”    p = “c<em>a</em>b”  输出: true。<br>解释: 因为 '<em>’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。<br>示例 5：输入:s = “mississippi”  p = &quot;mis</em>is<em>p</em>.&quot;  输出: false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">problem2</span><span class="params">(String s, String p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((s.length() == <span class="number">0</span> || s == <span class="literal">null</span>) &amp;&amp; (p.length() == <span class="number">0</span> || p == <span class="literal">null</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">if</span>((p == <span class="literal">null</span> &amp;&amp; s != <span class="literal">null</span>) || (p != <span class="literal">null</span> &amp;&amp; s == <span class="literal">null</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode hard</summary>
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的中等难度题</title>
    <link href="https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-medium/"/>
    <id>https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-medium/</id>
    <published>2025-06-22T12:30:36.000Z</published>
    <updated>2025-06-24T06:44:33.641Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集了一些<a href="https://leetcode.cn/">LeetCode</a>的一些中等难度的题目。</p><h2 id="基础数据类型定义-2">基础数据类型定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode1</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode1 next;</span><br><span class="line"></span><br><span class="line">    ListNode1(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode1</span><span class="params">(<span class="type">int</span> val , ListNode1 next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode1 <span class="title function_">reverseLink</span><span class="params">(ListNode1 head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode1</span> <span class="variable">head1</span> <span class="operator">=</span> head, next1 = head.next, prev1 = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            head1.next = prev1;</span><br><span class="line">            prev1 = head1;</span><br><span class="line">            head1 = next1;</span><br><span class="line">            next1 = head1.next;  <span class="comment">// next1 = next1.next;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Quick-Start-2">Quick Start</h2><p>给出两个非空链表来表示两个非负的整数。其中，它们各自的位数是按照<code>逆序</code>的方式存储的，并且它们的每个节点只能存储一位数字。<br>如果我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。假设除了数字 0 之外，这两个数都不会以 0 开头。<br>示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)；输出：7 -&gt; 0 -&gt; 8。原因：342 + 465 = 807</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem</span><span class="params">(ListNode1 l1, ListNode1 l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2, re = head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span> || temp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            re.val = (p1.val + p2.val + temp) % <span class="number">10</span>;</span><br><span class="line">            temp = (p1.val + p2.val + temp) / <span class="number">10</span>;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1 == <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;     <span class="comment">// p2 长</span></span><br><span class="line">            re.val = (p2.val + temp) % <span class="number">10</span>;</span><br><span class="line">            temp = (p2.val + temp) / <span class="number">10</span>;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 == <span class="literal">null</span>) &#123;   <span class="comment">// p1 长</span></span><br><span class="line">            re.val = (p1.val + temp) % <span class="number">10</span>;</span><br><span class="line">            temp = (p1.val + temp) / <span class="number">10</span>;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">            re.val = temp;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span> || temp != <span class="number">0</span>) &#123;</span><br><span class="line">            re.next = <span class="keyword">new</span> <span class="title class_">ListNode1</span>(<span class="number">0</span>);</span><br><span class="line">            re = re.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            re.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem_pre</span><span class="params">(ListNode1 l1, ListNode1 l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2, re = head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span> || temp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (p1 != <span class="literal">null</span> ? p1.val : <span class="number">0</span>)  + (p2 != <span class="literal">null</span> ? p2.val : <span class="number">0</span>) + temp;</span><br><span class="line">        temp = sum / <span class="number">10</span>;</span><br><span class="line">        re.next = <span class="keyword">new</span> <span class="title class_">ListNode1</span>(sum % <span class="number">10</span>);</span><br><span class="line">        p1 = p1 != <span class="literal">null</span> ?  p1.next : <span class="literal">null</span>;</span><br><span class="line">        p2 = p2 != <span class="literal">null</span> ?  p2.next : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不含重复字符的最长子串长度">不含重复字符的最长子串长度</h2><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。  请注意，你的答案必须是子串的长度。<br>示例 1: 输入: “abcabcbb”。输出: 3。解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2: 输入: “bbbbb”。输出: 1。解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3: 输入: “pwwkew”。输出: 3。解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(String strSrc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strSrc.equals(<span class="string">&quot;&quot;</span>) || strSrc.length() == <span class="number">0</span> || strSrc.length() == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;源字符串&lt;&quot;</span> + strSrc + <span class="string">&quot;&gt;的最长子串&lt;&quot;</span> + strSrc + <span class="string">&quot;&gt;长度为 &gt;&gt; &quot;</span> + strSrc.length());</span><br><span class="line">        <span class="keyword">return</span> strSrc.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + strSrc.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> subStr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> maxStr.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strSrc.length(); ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; subStr.length(); j++) &#123;  <span class="comment">// 和子串的全部字符比较</span></span><br><span class="line">            <span class="keyword">if</span> (strSrc.charAt(i) == subStr.charAt(j)) &#123; <span class="comment">// 有重复字符 回退 子串长度-1 位 当前字符为新子串 指针下一位</span></span><br><span class="line">                count++;</span><br><span class="line">                i = i - subStr.length() + <span class="number">1</span>;</span><br><span class="line">                subStr = <span class="string">&quot;&quot;</span> + strSrc.charAt(i);</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == subStr.length() &amp;&amp; flag &amp;&amp; i &lt; strSrc.length()) &#123; <span class="comment">// 比完没有重复字符  当前字符串加入字符集</span></span><br><span class="line">            subStr = subStr + strSrc.charAt(i);</span><br><span class="line">            maxStr = maxStr.length() &lt; subStr.length() ? subStr : maxStr;</span><br><span class="line">            maxLen = maxStr.length();</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;源字符串&lt;&quot;</span> + strSrc + <span class="string">&quot;&gt;的最长子串&lt;&quot;</span> + maxStr + <span class="string">&quot;&gt;长度为 &gt;&gt; &quot;</span> + maxLen);</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>) || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + s.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> subStr.length();</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; subStr.length(); j++) &#123;  <span class="comment">// 和子串的全部字符比较</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == subStr.charAt(j)) &#123; <span class="comment">// 有重复字符 回退 子串长度-1个位置 取当前字符为新子串 指针下一位</span></span><br><span class="line">                i = i - subStr.length() + <span class="number">1</span>;</span><br><span class="line">                subStr = <span class="string">&quot;&quot;</span> + s.charAt(i);</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == subStr.length() &amp;&amp; flag &amp;&amp; i &lt; s.length()) &#123; <span class="comment">// 比完没有重复字符  当前字符串加入字符集</span></span><br><span class="line">            subStr = subStr + s.charAt(i);</span><br><span class="line">            maxLen = maxLen &gt; subStr.length() ? maxLen : subStr.length();</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找出字符串中最长回文子串">找出字符串中最长回文子串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：输入: “babad”。输出: “bab”。注意: “aba” 也是一个有效答案。<br>示例 2：输入: “cbbd”。输出: “bb”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> dp[][] = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s.length(); j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 枚举所有子串长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; s.length(); l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123; <span class="comment">// 枚举子串的起始位置 i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + l; <span class="comment">// 通过 j=i+l 得到子串的结束位置</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= s.length()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = (s.charAt(i) == s.charAt(j));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s.charAt(i) == s.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断回文串长度</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; l + <span class="number">1</span> &gt; result.length())&#123;</span><br><span class="line">                result = s.substring(i, j + <span class="number">1</span>); <span class="comment">// 取值为左闭右开区间 [ start, end )</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将给定字符串按给定行数Z字排列">将给定字符串按给定行数Z字排列</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。具体示例如下图所示。请你实现这个将字符串进行指定行数变换的函数： <code>string convert(string s, int numRows);</code></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250622221010005.png" alt="image-20250622221010005"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*官方解答</span></span><br><span class="line"><span class="comment">按顺序遍历字符串 s；</span></span><br><span class="line"><span class="comment">res[i] += c： 把每个字符 c 填入对应行s_i；</span></span><br><span class="line"><span class="comment">i += flag： 更新当前字符 c 对应的行索引；</span></span><br><span class="line"><span class="comment">flag = - flag： 在达到 ZZ 字形转折点时，执行反向*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;StringBuilder&gt;();  <span class="comment">// 每一行的字符数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        rows.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, flag = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray()) &#123; <span class="comment">// 所有字符串</span></span><br><span class="line">        rows.get(i).append(c); <span class="comment">// 实际上 遍历了rows数组</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || i == numRows - <span class="number">1</span>)&#123; <span class="comment">// 转折点 反向遍历</span></span><br><span class="line">            flag = -flag;</span><br><span class="line">        &#125;</span><br><span class="line">        i += flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(StringBuilder row : rows) &#123;</span><br><span class="line">        res.append(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串转整数的实现函数-atoi">字符串转整数的实现函数 atoi</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的<strong>转化规则如下</strong>：<br>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。在任何情况下，若函数不能进行有效的转换时，请返回 0 。<br>提示：本题中的空白字符只包括空格字符 ’ ’ 。假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。<br>示例 1: 输入: “42”。输出: 42。<br>示例 2: 输入: &quot;   -42&quot;。输出: -42<br>解释: 第一个非空白字符为 '-'是一个负号。尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3: 输入: “4193 with words”  输出: 4193。解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4: 输入: “words and 987”。输出: 0。解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。<br>示例 5: 输入: “-91283472332”。输出: -2147483648。解释: 数字&quot;-91283472332&quot;超过32位有符号整数范围。返回 INT_MIN (−231) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span> || str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, flag = <span class="number">0</span>; <span class="comment">// flag 表示有没有数字</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">numStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27; &#x27;</span> &amp;&amp; numStr.length() == <span class="number">0</span>) &#123; <span class="comment">// 忽略有效字符前面的空格</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; (str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span> || str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">            &amp;&amp; (str.charAt(i) != <span class="string">&#x27;-&#x27;</span> &amp;&amp; str.charAt(i) != <span class="string">&#x27;+&#x27;</span>)) &#123; <span class="comment">// 排除第一个有效字符不是 + - 0到9的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; numStr.length() == <span class="number">1</span> &amp;&amp; (str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>)) &#123; </span><br><span class="line">            <span class="comment">// + - 后面不是0-9的数字</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span> &amp;&amp; (str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>)) &#123; <span class="comment">// 一串有效值后遇到了非数字字符</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; (str.charAt(i) == <span class="string">&#x27;-&#x27;</span> || str.charAt(i) == <span class="string">&#x27;+&#x27;</span>)) &#123; <span class="comment">// 第一个字符是 + -</span></span><br><span class="line">            numStr = numStr + str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            numStr = numStr + str.charAt(i);</span><br><span class="line">            target = target <span class="number">10</span> + (str.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!numStr.equals(<span class="string">&quot;&quot;</span>) &amp;&amp; numStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        target = <span class="number">0</span> - target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; Math.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span> || target &lt; Math.pow(-<span class="number">2</span>, <span class="number">31</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> numStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span> ? (<span class="type">int</span>) Math.pow(-<span class="number">2</span>, <span class="number">31</span>) : (<span class="type">int</span>) Math.pow(<span class="number">2</span>, <span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大容量的容器">最大容量的容器</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code>。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。<br>示例：输入：[1,8,6,2,5,4,8,3,7]。输出：49</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="literal">null</span> || height.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> bottomLen, target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            bottomLen = j - i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> bottomLen Math.min(height[i], height[j]);</span><br><span class="line">            target = Math.max(target, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="罗马数字转整数-2">罗马数字转整数</h2><p>罗马数字包含以下七种字符:I，V，X，L，C，D和M。<br>字符（数值）对应关系：I（1）、V（5）、X（10）、L（50）、C（100）、D（500）、M（1000）<br>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：<br>I可以放在V(5)        和X(10)       的左边，来表示 4        和9。<br>X可以放在L(50)     和C(100)     的左边，来表示 40     和90。<br>C可以放在D(500)  和M(1000)  的左边，来表示 400  和900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1到 3999 的范围内<br>示例 1: 输入:“III”    输出: 3<br>示例 2: 输入:“IV”    输出: 4<br>示例 3: 输入:“IX”            输出: 9<br>示例 4: 输入:“LVIII”        输出: 58 解释: L = 50, V= 5, III = 3。<br>示例 5: 输入:“MCMXCIV”      输出: 1994     解释: M = 1000, CM = 900, XC = 90, IV = 4。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String sub[] = &#123;<span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;M&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> cons[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">90</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">500</span>, <span class="number">900</span>, <span class="number">1000</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cons.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num / cons[i] == <span class="number">0</span>) &#123; <span class="comment">// 不能匹配当前了 则匹配较小的</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num / cons[i] != <span class="number">0</span>) &#123; <span class="comment">// 减去已经匹配的</span></span><br><span class="line">            target = target + sub[i];</span><br><span class="line">            num -= cons[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中三数之和为0的三元组">数组中三数之和为0的三元组</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。<br>示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2] ]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;Integer&gt;&gt; problem8(int[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; re = new ArrayList&lt;&gt;();</span><br><span class="line">    // 找出所有的三元组 [a, b, c] 对应的指针分别为 i j k</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    Arrays.<span class="built_in">sort</span>(nums);  // 从小到大排序</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;//  跳过数组中的重复元素</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = n - 1; // c对应的指针初始指向数组的最右端</span><br><span class="line">        <span class="keyword">for</span> (int j = i + 1; j &lt; nums.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;//  跳过数组中的重复元素</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k &gt; j &amp;&amp; nums[i] + nums[j] + nums[k] &gt; 0) &#123;  // 保证 b 的指针在 c 的指针的左侧</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果指针重合，随着 b增大 不再存在满足 a+b+c=0 并且 b &lt; c 的 c</span><br><span class="line">            <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == 0) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                list.add(nums[j]);</span><br><span class="line">                list.add(nums[k]);</span><br><span class="line">                re.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中与给定值最接近的三数之和">数组中与给定值最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。<br>示例：输入：nums = [-1,2,1,-4], target = 1    输出：2。解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。<br>提示：3 &lt;= nums.length &lt;= 10^3；-10^3 &lt;= nums[i] &lt;= 10^3；-10^4 &lt;= target &lt;= 10^4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 每个三元组 [a, b, c] 对应的指针分别为 i j k</span></span><br><span class="line">    Arrays.sort(nums);  <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">3</span>) &#123; <span class="comment">// 只有三位数</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res - target == <span class="number">0</span>) &#123; <span class="comment">// 前三位之和为target</span></span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 跳过数组中的重复元素</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// c对应的指针初始指向数组的最右端</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; j) &#123; <span class="comment">// 保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k];</span><br><span class="line">            <span class="keyword">if</span> (temp == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(res - target) &gt;= Math.abs(temp - target)) &#123;</span><br><span class="line">                res = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (temp &gt; target) &#123; <span class="comment">// 当前和比目标值较大 第三个数减小 右往左</span></span><br><span class="line">                k = k - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) &#123; <span class="comment">// 跳过数组中的重复元素</span></span><br><span class="line">                    k = k - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; target) &#123; <span class="comment">// 当前和比目标值较小 第二个数增大 左往右</span></span><br><span class="line">                j = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123; <span class="comment">// 跳过数组中的重复元素</span></span><br><span class="line">                    j = j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拼音九键中给定两数字对应字符串列表">拼音九键中给定两数字对应字符串列表</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话(拼音九键)按键相同）。<br>注意： 1 不对应任何字母。示例：输入：“23”。输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">problem</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">    List&lt;String&gt; re = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (digits.length() == <span class="number">0</span> || digits.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> digit[] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    String corr[] = &#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;!@#&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    re = findCombination(re, corr, digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findCombination</span><span class="params">(List&lt;String&gt; re, String[] corr, String digits, <span class="type">int</span> index, String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">        re.add(s);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">    <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> corr[c - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; letters.length(); i++) &#123;</span><br><span class="line">        findCombination(re, corr, digits, index + <span class="number">1</span>, s + letters.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转每对括号间的子串">反转每对括号间的子串</h2><p>给出一个字符串 s（仅含有小写英文字母和括号）。请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。注意，结果中不应包含任何括号。<br>示例 1：输入：s = “(abcd)”。输出：“dcba”<br>示例 2：输入：s = “(u(love)i)”。输出：“iloveu”。解释：先反转子字符串 “love” ，然后反转整个字符串。<br>示例 3：输入：s = “(ed(et(oc))el)”。输出：“leetcode”。解释：先反转子字符串 “oc” ，接着反转 “etco” ，然后反转整个字符串。<br>提示：1 &lt;= s.length &lt;= 2000；s 中只有小写英文字母和括号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            reverse(arr, stack.pop() + <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="string">&#x27;)&#x27;</span> &amp;&amp; arr[i] != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            sb.append(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = tmp;</span><br><span class="line">        right--;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode medium</summary>
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的简单题</title>
    <link href="https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-easy/"/>
    <id>https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-easy/</id>
    <published>2025-06-22T11:58:36.000Z</published>
    <updated>2025-06-24T06:44:33.641Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集了一些<a href="https://leetcode.cn/">LeetCode</a>的一些简单的题目</p><h2 id="基础数据类型定义">基础数据类型定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode1</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode1 next;</span><br><span class="line">    ListNode1() &#123;&#125;</span><br><span class="line">    ListNode1(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode1(<span class="type">int</span> val, ListNode1 next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode1</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode1 left;</span><br><span class="line">     TreeNode1 right;</span><br><span class="line">    </span><br><span class="line">     TreeNode1(<span class="type">int</span> x) &#123;</span><br><span class="line">         val = x;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和为目标值的两数在数组中的下标">和为目标值的两数在数组中的下标</h2><p>给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br>示例: nums = [2, 7, 11, 15], target = 9。因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] problem(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> result[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32位整数反转">32位整数反转</h2><p>给出一个 <code>32位</code>的有符号整数，你需要将这个整数中每位上的数字进行反转。注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为<code>[−231, 231− 1]</code>。请根据这个假设，如果反转后整数溢出那么就返回 0。<br>示例 1: 输入: 123   输出: 321<br>示例 2: 输入: -123  输出: -321<br>示例 3: 输入: 120   输出: 21</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;     </span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// int  溢出问题</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;        <span class="comment">// 1534236469</span></span><br><span class="line">        len = (x + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        len = (x + <span class="string">&quot;&quot;</span>).length() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        target += tempMath.pow(<span class="number">10</span>, len - <span class="number">1</span>);</span><br><span class="line">        len = len - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println((<span class="type">int</span>)Math.pow(<span class="number">2</span>, <span class="number">31</span>) + <span class="string">&quot; --- &quot;</span> + Math.pow(<span class="number">2</span>, <span class="number">31</span>));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) target == target ? <span class="type">int</span>(target) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        target = target10 + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((target &gt; Math.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) || (target &lt; Math.pow(-<span class="number">2</span>, <span class="number">31</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((target &gt; Math.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) || (target &lt; Math.pow(-<span class="number">2</span>, <span class="number">31</span>))) ? <span class="number">0</span> : (<span class="type">int</span>) target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回文数判断">回文数判断</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>示例 1: 输入: 121  输出: true<br>示例 2: 输入: -121 输出: false  解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3: 输入: 10    输出: false  解释: 从右向左读, 为 01 。因此它不是一个回文数。<br><strong>进阶:</strong> 能不将整数转为字符串来解决这个问题吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)) &#123; <span class="comment">// 负数都不是回文数  除0以外的整十数都不是回文数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> x + <span class="string">&quot;&quot;</span>; </span><br><span class="line">    System.out.println(src.length());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = src.length() - <span class="number">1</span>; i &lt;= src.length() / <span class="number">2</span> &amp;&amp; j &gt;= src.length() / <span class="number">2</span>; i++, j--) &#123;</span><br><span class="line">        System.out.println(src.charAt(i) + <span class="string">&quot;&lt;----&gt;&quot;</span> + src.charAt(j));</span><br><span class="line">        <span class="keyword">if</span> (src.charAt(i) != src.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不使用字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)) &#123; <span class="comment">// 负数都不是回文数  除0以外的整十数都不是回文数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (x + <span class="string">&quot;&quot;</span>).length() / <span class="number">2</span>, target = <span class="number">0</span>, isEven = (x + <span class="string">&quot;&quot;</span>).length() % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        target += (<span class="type">int</span>) tempMath.pow(<span class="number">10</span>, count - <span class="number">1</span>);</span><br><span class="line">        count = count - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;--&gt;&quot;</span> + target);</span><br><span class="line">    <span class="keyword">if</span> (isEven == <span class="number">0</span> &amp;&amp; target != x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEven == <span class="number">1</span> &amp;&amp; target != (x / <span class="number">10</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="罗马数字转整数">罗马数字转整数</h2><p>罗马数字包含以下七种字符:I，V，X，L，C，D和M。<br>字符（数值）对应关系：I（1）、V（5）、X（10）、L（50）、C（100）、D（500）、M（1000）<br>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：<br>I可以放在V(5)        和X(10)       的左边，来表示 4        和9。<br>X可以放在L(50)     和C(100)     的左边，来表示 40     和90。<br>C可以放在D(500)  和M(1000)  的左边，来表示 400  和900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1到 3999 的范围内<br>示例 1: 输入:“III”    输出: 3<br>示例 2: 输入:“IV”    输出: 4<br>示例 3: 输入:“IX”            输出: 9<br>示例 4: 输入:“LVIII”        输出: 58 解释: L = 50, V= 5, III = 3。<br>示例 5: 输入:“MCMXCIV”      输出: 1994     解释: M = 1000, CM = 900, XC = 90, IV = 4。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        char constant[] = &#123;&#x27;I&#x27;,&#x27;V&#x27;,&#x27;X&#x27;,&#x27;L&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;M&#x27;&#125;;</span></span><br><span class="line">    <span class="type">int</span> cons[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">1000</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">SRC</span> <span class="operator">=</span> <span class="string">&quot;IVXLCDM&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s.charAt(i) == <span class="string">&#x27;I&#x27;</span> &amp;&amp; (s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;V&#x27;</span> || s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;X&#x27;</span>)) ||</span><br><span class="line">                (s.charAt(i) == <span class="string">&#x27;X&#x27;</span> &amp;&amp; (s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;L&#x27;</span> || s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;C&#x27;</span>)) ||</span><br><span class="line">                (s.charAt(i) == <span class="string">&#x27;C&#x27;</span> &amp;&amp; (s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;D&#x27;</span> || s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;M&#x27;</span>))) &#123;</span><br><span class="line">            target += cons[SRC.indexOf(s.charAt(i + <span class="number">1</span>))] - cons[SRC.indexOf(s.charAt(i))];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target += cons[SRC.indexOf(s.charAt(i))];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="keyword">if</span> (i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        target += cons[SRC.indexOf(s.charAt(i))];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串数组的最长公共前缀">字符串数组的最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。 说明: 所有输入只包含小写字母a-z。<br>如果不存在公共前缀，返回空字符串&quot;&quot;。<br>示例 1: 输入: [“flower”,“flow”,“flight”]  输出: “fl”<br>示例 2: 输入: [“dog”,“racecar”,“car”]     输出: “” 解释: 输入不存在公共前缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.min(strs[i].length(), prefix.length()); <span class="comment">// 比较直到较小长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 字符比较 下标</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; len &amp;&amp; prefix.charAt(index) == strs[i].charAt(index)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        prefix = prefix.substring(<span class="number">0</span>, index); <span class="comment">// 取公共前缀</span></span><br><span class="line">        <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123; <span class="comment">// 前缀已经为空 则退出比较</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效字符串判定">有效字符串判定</h2><p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，']'的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。<br>示例 1: 输入: “()”  输出: true<br>示例 2: 输入: “()[]{}”    输出: true<br>示例 3: 输入: “(]”   输出: false<br>示例 4: 输入: “([)]”   输出: false<br>示例 5: 输入: “{[]}” 输出: true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">problem</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 空串合法</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个字符为右括号 或者 串长为奇数 非法</span></span><br><span class="line">    <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">&#x27;)&#x27;</span> || s.charAt(<span class="number">0</span>) == <span class="string">&#x27;]&#x27;</span> || s.charAt(<span class="number">0</span>) == <span class="string">&#x27;&#125;&#x27;</span> || s.length() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//左括号进栈  右括号出栈 判断是否合法</span></span><br><span class="line">    <span class="type">char</span> stack[] = <span class="keyword">new</span> <span class="title class_">char</span>[s.length()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span> || s.charAt(i) == <span class="string">&#x27;[&#x27;</span> || s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack[top++] = s.charAt(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--top];</span><br><span class="line">            <span class="keyword">if</span> ((temp == <span class="string">&#x27;(&#x27;</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) || (temp == <span class="string">&#x27;[&#x27;</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27;]&#x27;</span>) ||</span><br><span class="line">                        (temp == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27;&#125;&#x27;</span>)) &#123;</span><br><span class="line">                </span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top != <span class="number">0</span>) &#123;  <span class="comment">// 栈不空 非法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个升序链表">合并两个升序链表</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过 拼接给定的两个链表的所有节点 组成的。<br>示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4; 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem</span><span class="params">(ListNode1 l1, ListNode1 l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span> &amp;&amp; l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1 == <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2, h;</span><br><span class="line">    <span class="keyword">if</span> (p1.val &lt; p2.val) &#123;</span><br><span class="line">        h = p1;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        h = p2;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">head</span> <span class="operator">=</span> h;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt; p2.val) &#123;</span><br><span class="line">            h.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span>) &#123; <span class="comment">// l1剩下的</span></span><br><span class="line">        h.next = p1;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span>) &#123; <span class="comment">// l2 剩下的</span></span><br><span class="line">        h.next = p2;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序数组原地去重">排序数组原地去重</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 【原地】修改输入数组 并在使用 O(1) 额外空间的条件下完成。<br>示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>不需要考虑数组中超出新长度后面的元素。<br>示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。       不需要考虑数组中超出新长度后面的元素。<br>说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:<br>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br><code>int len = removeDuplicates(nums);</code><br>// 在函数里修改输入数组对于调用者是可见的。根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br><code>for (int i = 0; i &lt; len; i++) &#123; print(nums[i]); &#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] != nums[i]) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            nums[index] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原地删除数组中特定值">原地删除数组中特定值</h2><p>给你一个数组 nums和一个值 val，你需要 原地 移除所有数值等于val的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。<br>示例2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。<br>说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:<br>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br><code>int len = removeElement(nums, val);</code><br>// 在函数里修改输入数组对于调用者是可见的。根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br><code>for (int i = 0; i &lt; len; i++) &#123; print(nums[i]); &#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现strStr-函数">实现strStr()函数</h2><p>给定一个haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。<br>示例 1: 输入: haystack = “hello”, needle = “ll”   输出: 2<br>示例 2: 输入: haystack = “aaaaa”, needle = “bba”  输出: -1<br>说明: 当needle是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当needle是空字符串时我们应当返回 0 。这与C语言的<code>strstr()</code>以及 Java的<code>indexOf()</code>定义相符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem10</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.length() == <span class="number">0</span> || needle.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haystack.length() &lt; needle.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> haystack.length() - needle.length() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; diff; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; needle.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123; <span class="comment">// 不匹配 退出比较</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.length()) &#123; <span class="comment">// 比完 第一次找到匹配的needle  退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == diff) &#123; <span class="comment">// 比完 没找到</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在排序数组中找目标值">在排序数组中找目标值</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。<br>示例 1: 输入: [1,3,5,6], 5      输出: 2<br>示例 2: 输入: [1,3,5,6], 2      输出: 1<br>示例 3: 输入: [1,3,5,6], 7      输出: 4<br>示例 4: 输入: [1,3,5,6], 0      输出: 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target || (i == <span class="number">0</span> &amp;&amp; nums[i] &gt; target)) &#123; <span class="comment">// 原数组中找到了  target 或者比第一个还小</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] &lt; target &amp;&amp; nums[i + <span class="number">1</span>] &gt; target) &#123;  </span><br><span class="line">            <span class="comment">// 插在数组的第 2 到第 nums.length-1个位置</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.length; <span class="comment">// 插到第 nums.length 个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观数列">外观数列</h2><p>外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：<br><code>1（1）、2（11）、3（21）、4（1211）、5（111221）</code><br><code>1</code>读作&quot;one 1&quot;(“一个一”),即11。<code>11</code>读作&quot;two 1&quot;(“两个一”）,即21。<code>21</code>读作&quot;one 2&quot;,“one 1”（“一个二”,“一个一”), 即1211。<br>给定一个正整数 n（1 ≤n≤ 30），输出外观数列的第 n 项。**注意：**整数序列中的每一项将表示为一个字符串。<br>示例 1: 输入: 1 输出: “1”        解释：这是一个基本样例。<br>示例 2: 输入: 4  输出: “1211”<br>解释：当 n = 3 时，序列是 “21”，其中我们有 “2” 和 “1” 两组，“2” 可以读作 “12”，也就是出现频次 = 1 而 值 = 2；类似 “1” 可以读作 “11”。所以答案是 “12” 和 “11” 组合在一起，也就是 “1211”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;  <span class="comment">// 首项</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123; <span class="comment">// 第二项</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 推导</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">nextStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>, index = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; str.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str.charAt(index) == str.charAt(j)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextStr = nextStr + count + str.charAt(index);</span><br><span class="line">                    index = j;</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == str.length()) &#123; <span class="comment">// 比到了最后</span></span><br><span class="line">                nextStr = nextStr + count + str.charAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">            str = nextStr;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; ---&gt;&gt; &quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大连续数组">最大连续数组</h2><p>给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6。解释:连续子数组[4,-1,2,1] 的和最大，为6。<br>进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> nums[<span class="number">0</span>], max = target, index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        target += nums[i];</span><br><span class="line">        max = max &gt; target ? max : target;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.length - <span class="number">1</span> &amp;&amp; index &lt; nums.length) &#123; <span class="comment">// 已经最后 回退</span></span><br><span class="line">            System.out.println(index + <span class="string">&quot; --&gt; &quot;</span> + max);</span><br><span class="line">            i = index++ - <span class="number">1</span>; <span class="comment">// 执行完后 i会加1;</span></span><br><span class="line">            target = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    <span class="comment">/*考虑分治的方法*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算字符串中最后一个单词的长度">计算字符串中最后一个单词的长度</h2><p>给定一个仅包含大小写字母和空格’ '的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。如果不存在最后一个单词，请返回 0。说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。<br>示例: 输入: “Hello World”  输出: 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem14</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// 从后往前看第一个单词的长度</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组代表一个数字，做加一计算">数组代表一个数字，做加一计算</h2><p>给定一个由整数组成的 【非空数组】 所表示的 【非负整数】 ，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。<br>示例1: 输入: [1,2,3]       输出: [1,2,4]        解释: 输入数组表示数字 123。<br>示例2: 输入: [4,3,2,1]    输出: [4,3,2,2]     解释: 输入数组表示数字 4321。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] problem(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == digits.length - <span class="number">1</span> &amp;&amp; (digits[i] + <span class="number">1</span> &lt; <span class="number">10</span>)) &#123; <span class="comment">// 最后一位没有进位</span></span><br><span class="line">            digits[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> digits[i];</span><br><span class="line">            <span class="keyword">if</span> (i == digits.length - <span class="number">1</span>) &#123; <span class="comment">// 最后一位有进位</span></span><br><span class="line">                digits[i] = (digits[i] + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                digits[i] = (pre + temp) % <span class="number">10</span>;</span><br><span class="line">                temp = (pre + temp) / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123;  <span class="comment">// 最后一位数有进位</span></span><br><span class="line">        <span class="type">int</span>[] re = <span class="keyword">new</span> <span class="title class_">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        re[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; digits.length; i++) &#123;</span><br><span class="line">            re[i + <span class="number">1</span>] = digits[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二进制相加">二进制相加</h2><p>给你两个二进制字符串，返回它们的和（用二进制表示）。输入为 【非空】 字符串且只包含数字1和0。<br>示例 1: 输入: a = “11”, b = “1”              输出: “100”<br>示例 2: 输入: a = “1010”, b = “1011”   输出: “10101”<br>提示：每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。 <code>1 &lt;= a.length, b.length &lt;= 10^4</code>。字符串如果不是 “0” ，就都不含前导零。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">re</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>, temp = <span class="number">0</span>; <span class="comment">// temp 是进位</span></span><br><span class="line">    <span class="comment">// char型的数字 转 int：  char - &#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        re = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + (b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) % <span class="number">2</span> + re;</span><br><span class="line">        temp = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + (b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) / <span class="number">2</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;  <span class="comment">// a 剩下的</span></span><br><span class="line">        re = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + temp) % <span class="number">2</span> + re;</span><br><span class="line">        temp = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + temp) / <span class="number">2</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123; <span class="comment">// b 剩下的</span></span><br><span class="line">        re = ((b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) % <span class="number">2</span> + re;</span><br><span class="line">        temp = ((b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) / <span class="number">2</span>;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123; <span class="comment">// 最后还有进位</span></span><br><span class="line">        re = temp + re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现int-sqrt-int-x-函数">实现int sqrt(int x)函数</h2><p>计算并返回x的平方根，其中x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。<br>示例 1: 输入: 4   输出: 2<br>示例 2: 输入: 8   输出: 2。说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> (<span class="type">int</span>)Math.exp(<span class="number">0.5</span> Math.log(x));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>)(ans + <span class="number">1</span>) (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种 二分查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, e = x;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e) &#123;     <span class="comment">// 二分查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> i + (e - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>)mid mid &lt;= x) &#123; <span class="comment">// 右边  (long long)mid  mid</span></span><br><span class="line">            target = mid;</span><br><span class="line">            i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 左边</span></span><br><span class="line">            e = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三种 牛顿迭代</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">C</span> <span class="operator">=</span> x, x0 = x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="comment">// 牛顿迭代   比二分快</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">xi</span> <span class="operator">=</span> <span class="number">0.5</span> (x0 + C / x0);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(x0 - xi) &lt; <span class="number">1e-7</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x0 = xi;</span><br><span class="line">    &#125;</span><br><span class="line">    target = (<span class="type">int</span>) x0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="爬楼梯算法">爬楼梯算法</h2><p>假设你正在爬楼梯。需要n阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。有多少种不同方法可以爬到楼顶？注意：给定 n 是正整数。<br>示例 1：输入： 2  输出： 2。解释： 有两种方法可以爬到楼顶。（1 阶 + 1 阶）、（2 阶）<br>示例 2：输入： 3  输出： 3。解释： 有三种方法可以爬到楼顶。（1 阶 + 1 阶 + 1 阶）、（1 阶 + 2 阶）、（2 阶 + 1 阶）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        target = test_math(n);       // 排列组合</span></span><br><span class="line">    target = test_dynamicProgram(n); <span class="comment">// 滚动数组</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test_math</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 排列组合中的排列  排列： A(n,m)=n×（n-1）...（n-m+1）=n!/（n-m）!(n为下标,m为上标）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> n, count2 = <span class="number">0</span>, target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count1 - <span class="number">2</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count1 - <span class="number">2</span> == <span class="number">0</span>) &#123;<span class="comment">// 全2</span></span><br><span class="line">            target += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count2++; <span class="comment">// 2的个数</span></span><br><span class="line">            count1 = count1 - <span class="number">2</span>;</span><br><span class="line">            target += combination(count1 + count2, count2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target + <span class="number">1</span>; <span class="comment">// 加一个全 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合   C(n,m) = A(n,m) / m!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">combination</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (n - m + <span class="number">1</span>); i &lt;= n; i++) &#123; <span class="comment">// A(n,m)=n*(n-1)...(n-m+1)=n! / (n-m)!</span></span><br><span class="line">        target *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &gt;= <span class="number">1</span>; i--) &#123; <span class="comment">// C(n,m) = A(n,m) / m!</span></span><br><span class="line">        target /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**动态规划的转移方程：**用 <code>f(x)</code> 表示爬到<code>第 x 级台阶</code>的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，故可列出如下式子：<code>f(x) = f(x−1) + f(x−2)</code>。它意味着爬到第 x级台阶的方案数是爬到<code>第 x−1 级台阶</code>的方案数和爬到<code>第 x−2 级台阶</code>的方案数的和。因为每次只能爬 11 级或 22 级，所以 <code>f(x)</code>只能从 <code>f(x−1) </code>和 <code>f(x−2)</code> 转移过来，要统计方案总数，就需要对这两项的贡献求和。<br>**边界条件：**从第 0 级开始爬，从第 0 级爬到第 0 级可以看作只有一种方案，即 <code>f(0)=1</code>；从第 0 级到第 1 级也只有一种方案，即爬一级，<code>f(1)=1</code>。这两个作为边界条件就可以继续向后推导出第 n 级的正确结果。<br>不妨写几项来验证一下，根据转移方程得到 <code>f(2)=2</code>，<code>f(3)=3</code>，<code>f(4)=5</code>…把这些情况都枚举出来，发现计算的结果是正确的。<br>不难通过转移方程和边界条件给出一个时间复杂度和空间复杂度都是 O(n) 的实现，但由于这里的 <code>f(x)</code> 只和 <code>f(x−1)</code> 与 <code>f(x−2)</code> 有关，所以可以用「<strong>滚动数组思想</strong>」把空间复杂度优化成 <code>O(1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test_dynamicProgram</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序链表去重">排序链表去重</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。<br>示例1: 输入: 1-&gt;1-&gt;2             输出: 1-&gt;2<br>示例2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3  输出: 1-&gt;2-&gt;3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem</span><span class="params">(ListNode1 head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p</span> <span class="operator">=</span> head.next, pre = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val == pre.val) &#123;</span><br><span class="line">            pre.next = p.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两无序数组为一个有序数组">合并两无序数组为一个有序数组</h2><p>给你两个有序整数数组nums1 和 nums2，请你将 nums2 合并到nums1中，使 nums1 成为一个有序数组。<br>说明：初始化nums1 和 nums2 元素数量分别为m 和 n 。设nums1有足够的空间（空间大小大于或等于m + n）保存 nums2 中元素。<br>示例：输入: nums1 = [1,2,3,0,0,0], m = 3；nums2 = [2,5,6], n = 3。输出:[1,2,2,3,5,6]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] num1, <span class="type">int</span> m, <span class="type">int</span>[] num2, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m + j &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1[i] &gt; num2[j])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> m + j; k &gt;= i; k--)&#123; <span class="comment">// 第i+1个元素到第m+j个元素依次后移</span></span><br><span class="line">                <span class="keyword">if</span>(k == i)&#123;</span><br><span class="line">                    num1[i] = num2[j]; <span class="comment">// 插入元素</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    num1[k] = num1[k - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n)&#123;  <span class="comment">// num2 还有剩</span></span><br><span class="line">        num1[i++] = num2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断两个二叉树是否相同">判断两个二叉树是否相同</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250622221035975.png" alt="image-20250622221035975"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">problem</span><span class="params">(TreeNode1 p, TreeNode1 q)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode1 p, TreeNode1 q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="comment">// 两棵树同时为 null 则相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) <span class="comment">// 其中一棵树为 null 则不同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p.val != q.val) <span class="comment">// 根节点不同 则不同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); <span class="comment">// 左子树 右子树都相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode easy</summary>
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Linux备份数据到本地</title>
    <link href="https://southernfish.github.io/2025/06/21/linux/linux-database-backup/"/>
    <id>https://southernfish.github.io/2025/06/21/linux/linux-database-backup/</id>
    <published>2025-06-21T11:23:36.000Z</published>
    <updated>2025-06-24T06:44:33.644Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单记录了将Linux中数据库数据备份到本地是实现流程。</p><h2 id="安装下载命令">安装下载命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装下载命令</span><br><span class="line">sudo yum install lrzsz</span><br><span class="line">sz filename  下载</span><br><span class="line">rz filename  上传</span><br></pre></td></tr></table></figure><h2 id="登录到MySQL">登录到MySQL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h2 id="查看所有用户及权限">查看所有用户及权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT User, Host FROM mysql.user;</span><br></pre></td></tr></table></figure><h2 id="查看数据库">查看数据库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line">USE your_database_name;</span><br><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><h2 id="下载数据">下载数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p mysql &gt; mysql_dump.sql</span><br><span class="line">mysqldump -u username -p mydatabase &gt; mydatabase_dump.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中：</span></span><br><span class="line"><span class="comment"># username 是你的MySQL用户名。</span></span><br><span class="line"><span class="comment"># -p 选项会提示你输入密码。</span></span><br><span class="line"><span class="comment"># mydatabase 是要导出的数据库名称。</span></span><br><span class="line"><span class="comment"># mydatabase_dump.sql 是导出的文件名。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux备份数据到本地</summary>
    
    
    
    <category term="Linux" scheme="https://southernfish.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://southernfish.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker命令</title>
    <link href="https://southernfish.github.io/2025/06/21/docker/docker-commands/"/>
    <id>https://southernfish.github.io/2025/06/21/docker/docker-commands/</id>
    <published>2025-06-21T08:20:36.000Z</published>
    <updated>2025-06-24T06:44:33.642Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一个用于创建、部署和管理容器的开源平台。在使用Docker时，有效地管理和监控容器是非常重要的，其中查看和解析Docker命令(command)是基本且关键的一步。本文将介绍一些关于Docker的命令。</p><h1>基础命令</h1><h2 id="Docker命令的格式">Docker命令的格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker &lt;<span class="built_in">command</span>&gt;[options] [arguments]</span><br></pre></td></tr></table></figure><h2 id="Docker基础命令">Docker基础命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker version           <span class="comment">#显示版本信息</span></span><br><span class="line">docker info              <span class="comment">#显示docker系统信息，包括容器、镜像</span></span><br><span class="line">docker stats             <span class="comment">#cpu/内存使用情况</span></span><br><span class="line">docker  [<span class="built_in">command</span>] --<span class="built_in">help</span>       <span class="comment">#帮助命令</span></span><br></pre></td></tr></table></figure><hr><h1>镜像相关命令</h1><h2 id="查看本地镜像-images">查看本地镜像 images</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">    -a, --all             <span class="comment"># 列出所有的镜像</span></span><br><span class="line">    -q, --quiet           <span class="comment"># 只显示的镜像的id</span></span><br><span class="line"><span class="comment"># 举例说明</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID           CREATED        SIZE</span><br><span class="line">centos              7         8652b9f0cb4c   2 months ago   204MB</span><br><span class="line"><span class="comment"># 解释</span></span><br><span class="line">    REPOSITORY  镜像仓库源</span><br><span class="line">    TAG         标签（版本）</span><br><span class="line">    IMAGE ID    镜像ID</span><br><span class="line">    CREATED     创建时间</span><br><span class="line">    SIZE        大小</span><br></pre></td></tr></table></figure><h2 id="搜索镜像-search">搜索镜像 search</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker search [镜像名]</span><br><span class="line">    --filter=STARS=3000                            <span class="comment"># 列出收藏数不小于指定值的镜像</span></span><br><span class="line">docker search centos                            <span class="comment"># 搜索centos镜像</span></span><br><span class="line">docker search --filter=STARS=3000 centos        <span class="comment"># 搜索收藏大于3000的centos镜像</span></span><br></pre></td></tr></table></figure><h2 id="下载镜像-pull">下载镜像 pull</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull [镜像名]:[版本号]</span><br><span class="line">      -a, --all-tags                <span class="comment"># 下载所有镜像名的镜像</span></span><br><span class="line">docker pull nginx                    <span class="comment"># 下载nginx镜像，默认最新版</span></span><br><span class="line">docker pull nginx:1.14.0            <span class="comment"># 下载nginx镜像，版本为1.14.0</span></span><br><span class="line">docker pull -a nginx                <span class="comment"># 下载REPOSITORY为nginx的所有镜像</span></span><br></pre></td></tr></table></figure><h2 id="删除镜像-rmi">删除镜像 rmi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">删除镜像 rmi</span><br><span class="line">docker rmi [镜像名或者镜像<span class="built_in">id</span>]</span><br><span class="line">    -f                                       <span class="comment"># 强制删除</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span>                        <span class="comment"># 删除指定的镜像</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span>    镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span>  <span class="comment"># 删除多个镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)         <span class="comment"># 删除全部的镜像</span></span><br></pre></td></tr></table></figure><h2 id="推送镜像">推送镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [镜像名或者镜像<span class="built_in">id</span>]                  <span class="comment"># 将镜像推送至远程仓库</span></span><br></pre></td></tr></table></figure><hr><h1>容器相关命令</h1><h2 id="启动容器-rmi">启动容器 rmi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">启动容器 run</span><br><span class="line">docker run [镜像名]</span><br><span class="line">-d                                            <span class="comment"># 后台运行容器，并返回容器ID</span></span><br><span class="line">-i                                            <span class="comment"># 以交互模式运行容器，通常与 -t 同时使用；</span></span><br><span class="line">-P                                            <span class="comment"># 随机端口映射，容器内部端口随机映射到主机的端口</span></span><br><span class="line">-p                                            <span class="comment"># 指定端口映射，格式为：主机(宿主)端口:容器端口</span></span><br><span class="line">    -p ip:主机端口:容器端口</span><br><span class="line">    -p 主机端口:容器端口</span><br><span class="line">    -p 容器端口</span><br><span class="line">-t                                            <span class="comment"># 为容器重新分配一个伪输入终端，通常与 -i 同时使用（-it    交互模式运行）</span></span><br><span class="line">--name=<span class="string">&quot;nginx-lb&quot;</span>                            <span class="comment"># 为容器指定一个名称</span></span><br><span class="line">--dns 8.8.8.8                                <span class="comment"># 指定容器使用的DNS服务器，默认和宿主一致</span></span><br><span class="line">--dns-search example.com                    <span class="comment"># 指定容器DNS搜索域名，默认和宿主一致</span></span><br><span class="line">-h <span class="string">&quot;hostname&quot;</span>                                <span class="comment"># 指定容器的hostname</span></span><br><span class="line">-e username=<span class="string">&quot;ritchie&quot;</span>                        <span class="comment"># 设置环境变量</span></span><br><span class="line">--env-file=[]                                <span class="comment"># 从指定文件读入环境变量；</span></span><br><span class="line">--cpuset=<span class="string">&quot;0-2&quot;</span> or --cpuset=<span class="string">&quot;0,1,2&quot;</span>            <span class="comment"># 绑定容器到指定CPU运行；</span></span><br><span class="line">-m                                             <span class="comment"># 设置容器使用内存最大值；</span></span><br><span class="line">--net=<span class="string">&quot;bridge&quot;</span>                                 <span class="comment"># 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</span></span><br><span class="line">--<span class="built_in">link</span>=[]                                    <span class="comment"># 添加链接到另一个容器</span></span><br><span class="line">--expose=[]                                 <span class="comment"># 开放一个端口或一组端口；</span></span><br><span class="line">--volume , -v                                 <span class="comment"># 绑定一个卷</span></span><br><span class="line">docker run -it centos /bin/bash               <span class="comment"># 启动并进入容器</span></span><br><span class="line">docker run -it -v 主机目录：容器内目录           <span class="comment"># 挂载目录</span></span><br></pre></td></tr></table></figure><h2 id="查看容器信息-ps">查看容器信息 ps</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps [CONTAINER ID or CONTAINER NAME]</span><br><span class="line">-a                        <span class="comment"># 列出当前正在运行的容器+历史运行过的容器</span></span><br><span class="line">-n=?                    <span class="comment"># 显示最近创建的容器</span></span><br><span class="line">-q                        <span class="comment"># 只显示容器的ID</span></span><br><span class="line">docker ps                <span class="comment"># 显示正在运行的容器</span></span><br><span class="line">docker ps -n=3          <span class="comment"># 显示最近三个创建的容器</span></span><br></pre></td></tr></table></figure><h2 id="退出容器-exit">退出容器 exit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">退出容器 <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span>            <span class="comment"># 直接容器停止并退出</span></span><br><span class="line">Ctrl + P + Q    <span class="comment"># 容器不停止退出</span></span><br></pre></td></tr></table></figure><h2 id="删除容器-rm">删除容器 rm</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> 容器<span class="built_in">id</span>                          <span class="comment"># 删除指定容器，不能删除正在运行的容器   </span></span><br><span class="line">docker <span class="built_in">rm</span> --f 容器<span class="built_in">id</span>                     <span class="comment"># 删除正在运行的容器    </span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)            <span class="comment"># 删除全部的容器</span></span><br><span class="line">docker ps -q -a|xargs docker <span class="built_in">rm</span>         <span class="comment"># 删除全部的容器</span></span><br></pre></td></tr></table></figure><h2 id="启动和停止容器的操作">启动和停止容器的操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动和停止容器的操作</span><br><span class="line">docker start 容器<span class="built_in">id</span>        <span class="comment"># 启动容器</span></span><br><span class="line">docker restart 容器<span class="built_in">id</span>      <span class="comment"># 重启容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>         <span class="comment"># 停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span>         <span class="comment"># 强制停止当前的容器</span></span><br></pre></td></tr></table></figure><h2 id="查看容器日志-logs">查看容器日志 logs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --<span class="built_in">tail</span> 10 8e633673e3c2     <span class="comment"># 查看容器id为8e633673e3c2的容器，最新10条日志</span></span><br><span class="line">    -f                 <span class="comment"># 跟踪日志输出</span></span><br><span class="line">    --since         <span class="comment"># 显示某个开始时间的所有日志</span></span><br><span class="line">    -t                 <span class="comment"># 显示时间戳</span></span><br><span class="line">    --<span class="built_in">tail</span>             <span class="comment"># 仅列出最新N条容器日志</span></span><br><span class="line">docker logs -tf --<span class="built_in">tail</span> 10 8e633673e3c2</span><br></pre></td></tr></table></figure><h2 id="查看容器中的进程信息-top">查看容器中的进程信息 top</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [容器<span class="built_in">id</span>]        <span class="comment"># 显示容器的进程信息</span></span><br></pre></td></tr></table></figure><h2 id="查看镜像的元数据-inspect">查看镜像的元数据 inspect</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [容器<span class="built_in">id</span>]</span><br><span class="line">    -f             <span class="comment"># 指定返回值的模板文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器ip</span></span><br><span class="line">[root@layman ~]<span class="comment"># docker inspect -f  &#x27;&#123;&#123;.NetworkSettings.Networks.redis.IPAMConfig.IPv4Address&#125;&#125;&#x27; 0233</span></span><br><span class="line">172.31.38.16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器环境变量</span></span><br><span class="line">[root@layman ~]<span class="comment"># docker inspect -f &#x27;&#123;&#123;.Config.Env&#125;&#125;&#x27; 0233</span></span><br><span class="line">[PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin REDIS_VERSION=5.0.9 REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-5.0.9.tar.gz REDIS_DOWNLOAD_SHA=53d0ae164cd33</span><br><span class="line">536c3d4b720ae9a128ea6166ebf04ff1add3b85f1242090cb85]</span><br></pre></td></tr></table></figure><h2 id="进入容器-exec-attach">进入容器 exec attach</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/bash        <span class="comment"># 进入容器后开启一个新的终端，可以在里面操作（常用）</span></span><br><span class="line">docker attach 容器<span class="built_in">id</span>                    <span class="comment"># 进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure><hr><h1>其他相关命令</h1><h2 id="docker-run-与-docker-start区别">docker run 与 docker start区别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run 只在第一次运行时使用，将镜像放到容器中，以后再次启动这个容器时，只需要使用命令docker start 即可；</span><br><span class="line">docker run相当于执行两步操作：将镜像放入容器（docker create）,然后将容器启动，变成运行时容器（docker start）；</span><br><span class="line">docker start的作用是，重新启动已存在的镜像。</span><br></pre></td></tr></table></figure><h2 id="Docker-run的基本流程">Docker run的基本流程</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621155307829.png" alt="image-20250621155307829"></p><h2 id="挂载卷-v">挂载卷 -v</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span>                      <span class="comment"># 查看所有的volume的情况</span></span><br><span class="line">-v 容器内路径                           <span class="comment"># 匿名挂载</span></span><br><span class="line">-v 卷名：容器内路径                       <span class="comment"># 具名挂载</span></span><br><span class="line">-v /宿主机路径：容器内路径               <span class="comment"># 指定路径挂载</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx     <span class="comment"># 只读权限</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx     <span class="comment"># 可读可写</span></span><br><span class="line"><span class="comment"># 没有指定目录的情况下都是在“/var/lib/docker/volumes/xxxx/_data&quot;下</span></span><br><span class="line"></span><br><span class="line">构建 build</span><br><span class="line">docker build -f /home/docker-test-volume/dockerfile1 -t layman/dockerfile .</span><br><span class="line">-f     <span class="comment"># 指定要使用的Dockerfile路径</span></span><br><span class="line">-t     <span class="comment"># 镜像的名字及标签</span></span><br><span class="line"></span><br><span class="line">查看docker网络 network</span><br><span class="line"><span class="comment"># 查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span>                            <span class="comment"># 查看所有容器的网络状态</span></span><br><span class="line">docker network inspect [NETWORK ID]        <span class="comment"># 查看一个详细信息</span></span><br><span class="line">docker network <span class="built_in">rm</span> [NETWORK ID]            <span class="comment"># 可以移除一个网络</span></span><br><span class="line"><span class="comment"># 创建网络</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">--driver bridge                自定义网络模式，使用桥接</span><br><span class="line">--subnet 192.168.0.0/16        设置子网地址</span><br><span class="line">--gateway 192.168.0.1        设置出口网关</span><br><span class="line">mynet                        自己定义的一个网络名字</span><br><span class="line"><span class="comment"># 查看网络详细信息</span></span><br><span class="line">docker network inspect mynet</span><br><span class="line"></span><br><span class="line">加入网络 connect</span><br><span class="line">docker network connect mynet tomcat01</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建-build">构建 build</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /home/docker-test-volume/dockerfile1 -t layman/dockerfile .</span><br><span class="line">-f     <span class="comment"># 指定要使用的Dockerfile路径</span></span><br><span class="line">-t     <span class="comment"># 镜像的名字及标签</span></span><br></pre></td></tr></table></figure><h2 id="查看docker网络-network">查看docker网络 network</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span>                            <span class="comment"># 查看所有容器的网络状态</span></span><br><span class="line">docker network inspect [NETWORK ID]        <span class="comment"># 查看一个详细信息</span></span><br><span class="line">docker network <span class="built_in">rm</span> [NETWORK ID]            <span class="comment"># 可以移除一个网络</span></span><br><span class="line"><span class="comment"># 创建网络</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">--driver bridge                自定义网络模式，使用桥接</span><br><span class="line">--subnet 192.168.0.0/16        设置子网地址</span><br><span class="line">--gateway 192.168.0.1        设置出口网关</span><br><span class="line">mynet                        自己定义的一个网络名字</span><br><span class="line"><span class="comment"># 查看网络详细信息</span></span><br><span class="line">docker network inspect mynet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入网络 connect</span></span><br><span class="line">docker network connect mynet tomcat01</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Docker</summary>
    
    
    
    <category term="Containerization Platform" scheme="https://southernfish.github.io/categories/Containerization-Platform/"/>
    
    
    <category term="Docker" scheme="https://southernfish.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://southernfish.github.io/2025/06/21/docker/docker/"/>
    <id>https://southernfish.github.io/2025/06/21/docker/docker/</id>
    <published>2025-06-21T06:15:36.000Z</published>
    <updated>2025-06-24T06:44:33.642Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一组平台即服务（PaaS）的产品。它基于操作系统层级的虚拟化技术，将软件与其依赖项打包为容器。托管容器的软件称为Docker引擎。Docker能够帮助开发者在轻量级容器中自动部署应用程序，并使得不同容器中的应用程序彼此隔离，高效工作。</p><h1>Docker</h1><h2 id="参考文档链接">参考文档链接</h2><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p><p>仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="什么是Docker">什么是Docker</h2><p><code>Docker</code> 是基于Go语言开发的开源项目，是开源的容器化平台，旨在简化应用程序的开发、部署和运行过程。它提供了一种轻量级、可移植和自包含的容器化环境，使开发人员能够在不同的计算机上以一致的方式构建、打包和分发应用程序。<br><strong>核心概念：</strong></p><ul><li><strong>容器（<code>Container</code>）：<strong>容器是 Docker 的</strong>基本部署单元</strong>。它是一个轻量级的、独立的运行时环境，包含应用程序及其相关依赖。容器利用 Linux 内核的命名空间和控制组技术，实现了隔离性和资源管理，使得应用程序在不同的容器中运行不会相互影响。</li><li><strong>镜像（<code>Image</code>）：<strong>镜像是用于</strong>创建容器的模板</strong>。它包含了一个完整的文件系统，其中包括应用程序运行所需的所有文件、依赖和配置信息。镜像是不可变的，通过 Docker 镜像可以创建多个相同的容器实例。</li><li><strong>镜像仓库（<code>Image Registry</code>）：<strong>镜像仓库是用于</strong>存储和分发 Docker 镜像的地方</strong>。最常用的公共镜像仓库是 <code>Docker Hub</code>，上面有大量的官方和社区共享的镜像。也可以搭建私有的镜像仓库，用于存放自己的镜像。</li><li><strong><code>Dockerfile</code>：<strong>Dockerfile 是一种</strong>文本文件</strong>，用于<strong>定义 Docker 镜像的构建过程</strong>。它包含了一系列的指令，用于<strong>指定基础镜像、安装软件、拷贝文件、配置环境等</strong>。通过 Dockerfile，可以自动化地构建镜像，确保镜像的一致性和可重复性。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621152126465.png" alt="image-20250621152126465"></p><p><strong>Docker 的优势</strong>：<code>轻量性、可移植性和灵活性</code>。通过使用 Docker，开发人员可以更轻松地创建一个可靠的开发环境、快速部署应用程序、实现弹性扩展和服务编排等。同时，它也提供了<code>生态系统丰富的工具和服务</code>，例如容器编排工具 <code>Docker Compose</code> 和容器编排平台 <code>Kubernetes</code>，使得容器化应用的管理更加便捷和高效。</p><p><strong>Linux容器技术：</strong></p><ul><li>Docker是在Linuk容器(<code>Linux Containers</code>)技术的基础上发展起来的。</li><li>LUX把单个操作系统的资源划分到多个孤立的组里，在孤立的组里平衡有冲突的资源使用需求。与虚拟机相比，这种通过划分组来平衡资源冲突的方式代价更小，它不需要指令级别模拟也不需要即使编译。</li><li><strong>容器直接在本地CPU上运行</strong>。</li></ul><h3 id="为什么要使用Docker">为什么要使用Docker</h3><ul><li>**更快的交付和部署。**开发人员使用镜像构建标准开发环境，运维和测试人员使用镜像来获得和开发人员相同的运行环境。开发环境和测试运维环境无缝对接，节约开发、测试、部署时间。</li><li><strong>更高效的资源利用。<strong>相较于虚拟机Docker不需要额外的<code>Hypervisor</code>支持，Docker是</strong>内核级别的虚拟化</strong>，实现更高的性能。</li><li>**更简单的更新管理。**使用<code>Dockerfile</code>，通过简单的修改就可以代替大量的更新操作。</li></ul><h2 id="Docker与虚拟化">Docker与虚拟化</h2><p>**虚拟化：**虚拟化是对计算机资源的抽象，是为了更好的管理计算机资源。让同时运行在一个计算机上的多个进程以为自己能够独占当前操作系统资源。<br>**有三种类型的虚拟化：**仿真、半虚拟化、基于容器的虚拟化<br><strong>Docker虚拟化与虚拟机比较</strong></p><ul><li><strong>Docker不是虚拟化方法</strong>。它依赖于实际实现基于容器的虚拟化或操作系统级虚拟化的其他工具。</li><li><strong>Docker是操作系统级的虚拟化</strong>，内核通过创建多个虚拟操作系统实例来隔离进程。虚拟机是硬件辅助虚拟化，虚拟的是整个硬件。</li><li>虚拟机需要模拟一个独立的<code>OS Kernel</code>而Docker不需要，与虚拟机映像相比，容器状态(<code>Docker或LXC映像</code>)的<strong>大小很小</strong>，因此容器映像很容易分发</li><li>虚拟机需要一个虚拟机管理程序如<code>VMware</code>，而Docker只需要一个Docker引擎，<strong>后者的开销更小</strong>。</li><li><strong>Docker更快秒级，虚拟机分钟级别</strong></li><li>Docker<strong>对系统资源需求更少</strong>。<ul><li>主机上的所有容器共享主机的调度程序，从而节省了额外资源的需求。容器中的资源管理是通过cgroup实现的。Cgroups不允许容器消耗比分配给它们更多的资源。</li></ul></li><li>Docker通过类似<code>Git</code>理念来方便用户获取、分发更新镜像</li><li>Docker通过<code>dockerfile</code>实现灵活的创建、部署机制</li></ul><p><strong>虚拟机和Docker本质的区别</strong>在于虚拟化的方式不同，虚拟机是一种硬件级别的虚拟化，通过软件去模拟硬件系统，并且虚拟机里需要虚拟OS Kernel。Docker是一种容器，是一种隔离机制，是软件级别的模拟。</p><p>虚拟机技术：资源占用十分多、冗余步骤多、启动慢；容器技术：不是模拟一个完整的OS</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151302533.png" alt="image-20250621151302533"></p><h2 id="Docker为什么比VM快">Docker为什么比VM快</h2><p>1、Docker比VM有更少的抽象层<br>2、Docker利用的是宿主机的内核，VM需要的是Guest OS<br>故新建一个容器的时候，docker无需像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而docker利用宿主机的操作系统，省略了这个复杂的过程，秒级！</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151312130.png" alt="image-20250621151312130"></p><table><thead><tr><th></th><th>Docker容器</th><th>LXC</th><th>VM</th></tr></thead><tbody><tr><td>虚拟化类型</td><td>OS虚拟化</td><td>OS虚拟化</td><td>硬件虚拟化</td></tr><tr><td>性能</td><td>=物理机性能</td><td>=物理机性能</td><td>5%-20%损耗</td></tr><tr><td>隔离性</td><td>NS隔离</td><td>NS隔离</td><td>强</td></tr><tr><td>QoS</td><td>Cgroup 弱</td><td>Cgroup 弱</td><td>强</td></tr><tr><td>安全性</td><td>中</td><td>差</td><td>强</td></tr><tr><td>GuestOS</td><td>只支持Linux&lt;</td><td>只支持Linux&lt;</td><td>全部</td></tr><tr><td>可迁移性</td><td>强</td><td>弱</td><td>强</td></tr></tbody></table><h2 id="docker是怎么工作的">docker是怎么工作的?</h2><p>一个完整的Docker由<code>DockerClient</code>客户端、<code>Docker Daemon</code>守护进程、<code>Docker Image</code>镜像、<code>DockerContainer</code>容器四部分组成<br>Docker是一个<code>Client-Server</code>结构的系统，，<strong>docker client负责处理用户输入的各种命令</strong>，比如docker build、docker run，真正工作的其实是server，也就是docker daemon，值得注意的是，<strong>docker client和docker daemon可以运行在同一台机器上</strong>。<br>Docker守护进程运行在主机上，然后通过<code>Socket</code>连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151356904.png" alt="image-20250621151356904"></p><h2 id="基本的Docker使用工作流程是怎样的？">基本的Docker使用工作流程是怎样的？</h2><ol><li>**构建镜像：**Dockerfile是镜像的源代码；用其创建镜像</li><li>**推送镜像到注册表：**将镜像上传到 <code>Docker Hub</code> 或<code>私有注册表</code>中。</li><li>**拉取镜像：**通过 <code>docker pull</code> 从注册表中拉取镜像。</li><li>**运行容器：**使用镜像创建并启动容器。</li><li>**管理容器：**使用 Docker 客户端命令管理正在运行的容器(例如查看日志、停止容器、查看资源使用情况等)。</li><li>**网络与存储：**容器之间通过 Docker 网络连接，数据通过 <code>Docker 卷</code>或<code>绑定挂载</code>进行持久化。</li></ol><h2 id="什么是docker-compose？">什么是docker-compose？</h2><p><code>docker-compose</code>就是一个编排同时管理多个容器的工具，与它配对使用的是一个<code>docker-compose.yaml</code>文件，<code>docker-compose</code>命令必须在一个包含<code>docker-compose.yaml</code>文件目录下才能使用。且当下docker-compose命令<strong>只能管理当前目录docker-compose文件中所涉及的容器，安装在机器上的其他容器无法干扰</strong>。</p><p>docker-compose的大部分命令基本和docker的命令重合，他们唯一的区别是docker命令能管理机器上所有的容器和镜像文件，而docker-compose只能管理当前docker-compose文件所涉及的容器。</p><h2 id="如何在生产中监控Docker？">如何在生产中监控Docker？</h2><p>Docker提供<code>docker status</code>和<code>docker事件</code>等工具来监控生产中的Docker。我们可以使用这些命令获取重要统计数据的报告。<br>**Docker统计数据：**当我们使用容器ID调用docker status时，我们获得容器的CPU、内存使用情况等。它类似于Linux中<code>top</code>命令。<br><strong>Docker事件：</strong> Docker事件是一个命令，用于查看Docker守护进程中整改再进行的活动流。一些常见的Docker事件是：<code>attach</code>、<code>commit</code>、<code>die</code>、<code>datach</code>、<code>rename</code>、<code>destroy</code>。</p><h2 id="Docker安全么？">Docker安全么？</h2><p>Docker<strong>利用了Linux内核中很多安全特性来保证不同容器之间的隔离，并且通过签名机制来对镜像进行验证</strong>。<br>Docker虽然隔离性无法与虚拟机相比，但仍然具有极高的安全性。</p><h2 id="Docker如何在非Linux系统中运行容器">Docker如何在非Linux系统中运行容器</h2><p>通过添加到Linux内核版本2.6.24的<strong>名称空间功能</strong>，可以实现容器的概念。容器将其<code>ID</code><strong>添加到每个进程</strong>，并向每个系统调用添加新的访问控制检查。它由<code>clone</code>系统调用访问，该调用允许创建先前全局命名空间的单独实例。</p><hr><h1>Docker镜像</h1><h2 id="什么是Docker镜像">什么是Docker镜像</h2><p>Docker镜像是Docker容器的源代码。换句话说，Docker镜像用于创建容器。使用<code>build</code>创建镜像，用<code>run</code>启动时它们将生成容器。<br>镜像存储在Docker注册表（<code>docker hub</code>）中，<code>registry.hub.docker.com</code>因为它们可能变得非常大，镜像被设计为由其他镜像层组成，允许在通过网络传输镜像时发送最少量的数据。</p><h2 id="Docker镜像联合文件系统">Docker镜像联合文件系统</h2><p><strong><code>UnionFS</code>（联合文件系统）：<strong>是一种分成，轻量级并且高性能的文件系统，支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统的Docker镜像可以</strong>通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像</strong>。<br><strong>特性：</strong><code>一次同时加载多个文件系统</code>，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统进行叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h2 id="镜像与-UnionFS区别">镜像与 UnionFS区别</h2><p>Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。<br><code>Docker 镜像</code>其实<strong>本质就是一个压缩包</strong>，我们可以使用命令将一个 Docker 镜像中的文件导出，你可以看到这个镜像中的目录结构与 Linux 操作系统的根目录中的内容并没有太多的区别，可以说 Docker 镜像就是一个文件。</p><h2 id="什么是Docker-Hub">什么是Docker Hub</h2><p><code>Docker Hub</code>是一个基于云的在线存储库，Docker进行可以由其他用户发布和使用。<br><code>Docker hub</code>是一个基于云的注册表服务，允许链接到代码存储库，构建镜像并测试，存储手动推送的镜像以及指向Docker云的链接，以便将镜像部署到主机。它为整个开发流程中的容器镜像发现，分发和变更管理，用户和团队协作以及工作流自动化提供了集中资源。</p><hr><h1>Docker容器</h1><h2 id="Docker容器可扩展到多远？">Docker容器可扩展到多远？</h2><p>诸如<code>Foogle</code>和<code>Twitter</code>之类的大型Web部署以及诸如<code>Heroku</code>和<code>dotCloud</code>之类的平台提供商都基于容器技术运行，并行运行的容器数以十万甚至至数八百计。</p><h2 id="Docker容器退出时是否丢失数据">Docker容器退出时是否丢失数据</h2><p>不、当Docker<strong>容器退出时，不会丢失数据</strong>。<br>应用程序写入磁盘的所有数据都会保留在其容器中<strong>直到明确删除该容器为止</strong>。即使在容器停止后，该容器的文件系统仍然存在。</p><h2 id="Docker容器有几种状态？">Docker容器有几种状态？</h2><p>有四种状态：运行、已暂停、重新启动、已退出。</p><h2 id="容器内部机制">容器内部机制</h2><p>每个容器都在自己的命名空间中运行，但使用与所有其他容器完全相同的内核。发生隔离是因为内核知道分配给进程的命名空间，并且在API调用期间确保进程只能访问其自己的命名空间中的资源。</p><h2 id="docker容器之间怎么隔离">docker容器之间怎么隔离?</h2><p>Linux中的<code>PID、IPC、网络</code>等资源是全局的，而<code>NameSpace机制</code>是一种资源隔离方案，在<strong>该机制下这些资源就不再是全局的</strong>了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰。<br>NameSpace技术可实现资源隔离，但进程仍可不受控的访问（CPU、内存、磁盘、网络等）系统资源，为了控制容器中进程对资源的访问，Docker采用<code>control groups</code>技术(也就是<code>cgroup</code>)<strong>控制容器中进程对系统资源的消耗</strong>，如限制某容器使用内存的上限、可在哪些CPU上运行等。这两项技术使容器像真正独立的操作系统。</p><h2 id="容器与主机之间的数据拷贝命令-docker-cp">容器与主机之间的数据拷贝命令 docker cp</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> /www 96f7f14e99ab:/www/     <span class="comment"># 主机到容器</span></span><br><span class="line">docker <span class="built_in">cp</span> 96f7f14e99ab:/www /tmp    <span class="comment"># 容器到主机</span></span><br></pre></td></tr></table></figure><h2 id="进入容器的方法">进入容器的方法</h2><ol><li><code>docker attach</code>，用于附加到正在运行的容器的标准输入、输出和错误流。<strong>不会启动新的进程</strong>。</li><li><code>docker exec</code>，如<code>docker exec -it 容器id /bin/bash</code>，此命令将以<strong>交互模式（-i）和终端（-t）的方式进入指定容器，并开启起一个新的终端</strong>。</li><li>通过 <code>docker run</code> 命令来进入容器。这种方式<strong>适用于需要在容器内执行命令而不是交互式操作的情况</strong>，使用 docker run 命令指定容器镜像和执行的命令，类似于直接进入容器</li></ol><h2 id="无状态或有状态应用程序谁更适合Docker容器">无状态或有状态应用程序谁更适合Docker容器</h2><p>最好为<code>Docker Container</code>创建<strong>无状态应用程序</strong>。我们可以从应用程序中创建一个容器，并<strong>从应用程序中取出可配置的状态参数</strong>。现在我们可以<strong>在生产环境和具有不同参数的QA环境中运行相同的容器</strong>。这有助于在不同场景中重用相同的镜像。另外，无状态应用程序比有状态应用程序<strong>更容易使用Docker容器进行扩展</strong>。</p><hr><h1>Dockerfile</h1><h2 id="Dockerfile中最常见的指令是什么">Dockerfile中最常见的指令是什么</h2><ul><li><code>FROM</code>：指定基础镜像；</li><li><code>LABEL</code>：功能是为镜像指定标签；</li><li><code>RUN</code>：运行指定的命令；</li><li><code>CMD</code>：容器启动时要运行的命令。</li></ul><h2 id="Dockerfile中的命令COPY和ADD命令区别">Dockerfile中的命令COPY和ADD命令区别</h2><p>一般而言，<code>ADD</code>和<code>COPY</code>在功能上类似，但是首选COPY。因为COPY比ADD更易懂。<strong>COPY仅支持将本地文件复制到容器中</strong>，而ADD具有一些功能（如仅限本地的tar提取和远程URL支持），这些功能并不是很明显。<br>因此，<strong>ADD最佳用途是将本地tar文件自动提取到镜像中</strong>，如<code>ADD rootfs.tar.xz /</code>。</p><h2 id="使用dockerfile构建apache容器服务">使用dockerfile构建apache容器服务</h2><ol><li><p>基础镜像目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir apache</span></span><br><span class="line"><span class="comment"># cd apache</span></span><br></pre></td></tr></table></figure></li><li><p>编辑镜像dockerfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim Dockerfile</span></span><br><span class="line"> </span><br><span class="line">FROM centos:7 <span class="comment"># 基于的基础镜像</span></span><br><span class="line">MAINTAINER The porject &lt;cloud-ops@centos.org&gt; <span class="comment"># 维护镜像的用户信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作指令安装apache软件</span></span><br><span class="line">RUN yum -y update    <span class="comment">#更新yum</span></span><br><span class="line">RUN yum -y install httpd</span><br><span class="line"></span><br><span class="line">EXPOSE 80 <span class="comment"># 开启80端口</span></span><br><span class="line">ADD index.html /var/www/html/index.html <span class="comment"># 复制网站首页文件</span></span><br><span class="line">ADD run.sh /run.sh <span class="comment"># 将执行脚本复制到镜像中</span></span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /run.sh <span class="comment"># 启动容器时执行脚本</span></span><br><span class="line"></span><br><span class="line">CMD [<span class="string">&quot;/run.sh&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>编辑启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim run.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -rf /run/httpd/*</span><br><span class="line"><span class="built_in">exec</span> /usr/sbin/apachectl -D FOREGROUND</span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;web test&quot;</span> &gt; index.html</span><br></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker build -t httpd:centos . (注意别忘 了末尾有&quot;.&quot;，且.前面有空格)</span></span><br></pre></td></tr></table></figure></li><li><p>镜像容器启动运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -d -p 1216:80 httpd:centos</span></span><br></pre></td></tr></table></figure></li><li><p>测试验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl http://192.168.40.30:1216</span></span><br></pre></td></tr></table></figure></li></ol><p>参考链接：<a href="https://blog.csdn.net/ygq13572549874/article/details/136558153">Docker镜像及Dockerfile详解</a></p><h2 id="docker-构建一个服务的过程-node-js">docker 构建一个服务的过程(node.js)</h2><ol><li><p>编写应用代码。首先，你需要有一个应用代码。例如，一个简单的 Node.js 应用</p></li><li><p>创建 Dockerfile<br>在应用的根目录下创建一个名为 Dockerfile 的文件。Dockerfile 包含了一系列的指令，用于告诉 Docker 如何构建镜像。例如，对于 Node.js 应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方 Node.js 镜像作为基础镜像</span></span><br><span class="line">FROM node:14</span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /usr/src/app</span><br><span class="line"><span class="comment"># 复制 package.json 和 package-lock.json (如果有) 到工作目录</span></span><br><span class="line">COPY package*.json ./</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">RUN npm install</span><br><span class="line"><span class="comment"># 复制项目文件到工作目录</span></span><br><span class="line">COPY . .</span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">EXPOSE 3000</span><br><span class="line"><span class="comment"># 定义容器启动时执行的命令</span></span><br><span class="line">CMD [ <span class="string">&quot;node&quot;</span>, <span class="string">&quot;app.js&quot;</span> ]</span><br></pre></td></tr></table></figure></li><li><p>构建 Docker 镜像。打开终端或命令行工具，导航到包含 Dockerfile 的目录，然后运行以下命令来构建 Docker 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-nodejs-app .</span><br><span class="line"><span class="comment"># 这里，-t 参数用于标记你的镜像，my-nodejs-app 是你的镜像名称，. 表示 Dockerfile 所在的当前目录。</span></span><br></pre></td></tr></table></figure></li><li><p>运行 Docker 容器。构建完成后，你可以使用以下命令来运行你的 Docker 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:3000 my-nodejs-app</span><br><span class="line"><span class="comment"># 这里，-p 参数将容器的 3000 端口映射到主机的 4000 端口。现在，如果你的机器上的任何程序访问 localhost:4000，它们将会看到你的 Node.js 应用运行。</span></span><br></pre></td></tr></table></figure></li><li><p>检查运行状态（可选）。可以使用以下命令来查看正在运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p>停止并删除容器（可选）。当完成测试后，可以停止并删除容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;container_id&gt;  <span class="comment"># 使用 docker ps 获取 container_id</span></span><br><span class="line">docker <span class="built_in">rm</span> &lt;container_id&gt;    <span class="comment"># 使用 docker ps 获取 container_id 或 docker rm $(docker ps -aq) 来删除所有容器</span></span><br></pre></td></tr></table></figure></li></ol><hr><h1>部署相关</h1><h2 id="CI-CD聚焦代码集成与交付的自动化流程（Jenkins）">CI/CD聚焦代码集成与交付的自动化流程（Jenkins）</h2><p>CI/CD 是指持续集成(<code>Continuous Integration</code>)和持续部署(<code>Continuous Deployment</code>)或持续交付(<code>Continuous Delivery</code>)<br><strong>持续集成(Continuous Integration)</strong><br>持续集成是一种软件开发实践，团队成员频繁地将他们的工作集成到共享的代码仓库中。<strong>其主要特点包括</strong>:</p><ol><li><code>频繁提交代码</code>：开发人员可以每天多次提交代码，确保代码库始终保持最新状态。</li><li><code>自动化构建</code>：每次提交后，自动触发构建过程，包括编译、测试、静态分析等</li><li><code>快速反馈</code>：如果构建失败或测试不通过，能够快速地向开发人员提供反馈，以便及时修复问题。</li></ol><p><strong>持续部署(Continuous Deployment)</strong><br>持续部署是在持续集成的基础上，将通过所有测试的代码自动部署到生产环境中。其<strong>特点如下</strong>:</p><ol><li><code>自动化流程</code>：从代码提交到生产环境的部署完全自动化，无需人工干预。</li><li><code>高频率部署</code>：可以实现频繁的部署，使得新功能能够快速地提供给用户,</li><li><code>风险控制</code>：需要有强大的测试和监控体系来确保部署的稳定性和可靠性。</li></ol><p><strong>持续交付(continuous Delivery)</strong><br>持续交付与持续部署类似，但不一定自动部署到生产环境，而是随时可以部署。重点在于确保软件随时处于可发布状态。</p><p><strong>CI/CD 好处包括:</strong></p><ol><li><code>提高开发效率</code>：减少手动操作和等待时间，加快开发周期。</li><li><code>尽早发现问题</code>：通过频繁的集成和测试，问题能够在早期被发现和解决。</li><li><code>降低风险</code>：减少了大规模部署时可能出现的问题，提高了软件的质量和稳定性。</li><li><code>增强团队协作</code>：促进团队成员之间的沟通和协作，提高团队的整体效率，</li></ol><h2 id="DevOps？">DevOps？</h2><p>DevOps是涵盖开发与运维全生命周期协作的文化与实践体系。<br>DevOps是一种文化与方法论，旨在打破开发与运维的壁垒，通过自动化工具链、协作流程和共享责任，加速软件全生命周期交付。<br>DevOps覆盖更广包括需求规划、基础设施管理、监控反馈等全流程，强调团队协作、文化变革及工具整合。更强调“人+流程+工具”的系统性优化。<br>**技术优势：**更快地解决问题<br>**商业利益：**有更多时间可以增加价值（而不是修复/维护）</p>]]></content>
    
    
    <summary type="html">Docker</summary>
    
    
    
    <category term="Containerization Platform" scheme="https://southernfish.github.io/categories/Containerization-Platform/"/>
    
    
    <category term="Docker" scheme="https://southernfish.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://southernfish.github.io/2025/06/21/front-end/front-end-websocket/"/>
    <id>https://southernfish.github.io/2025/06/21/front-end/front-end-websocket/</id>
    <published>2025-06-21T05:33:36.000Z</published>
    <updated>2025-06-24T06:44:33.643Z</updated>
    
    <content type="html"><![CDATA[<p><strong>WebSocket</strong>是一种在单个<a href="https://baike.baidu.com/item/TCP/0?fromModule=lemma_inlink">TCP</a>连接上进行<a href="https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5/0?fromModule=lemma_inlink">全双工</a>通信的协议。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><h2 id="WebSocket-的优势和适用场景是什么？">WebSocket 的优势和适用场景是什么？</h2><ol><li><code>WebSocket</code> 提供了<strong>低延迟的实时通信能力</strong>，能够在服务器端有新数据时立即推送给客户端。</li><li><code>WebSocket</code> 支持<strong>客户端和服务器之间的双向通信</strong>，可以实现实时聊天、实时数据更新等场景</li><li><code>WebSocket</code> 使<strong>用长连接，相对于频繁的短连接请求，减少了网络开销</strong>。</li><li><code>WebSocket</code> 具备<strong>跨域通信</strong>的能力，可以跨域进行实时通信</li></ol><p><strong>适用场景：<strong>实时聊天应用、股票行情推送、实时协作编辑、多人游戏、实时数据监控等</strong>需要实时双向通信的场景</strong>。</p><h2 id="WebSocket-的连接建立过程是怎样的？">WebSocket 的连接建立过程是怎样的？</h2><ol><li>客户端<strong>发送 <code>WebSocket</code> 握手请求</strong></li><li>服务器收到握手请求后，<strong>验证请求头的字段，并返回握手响应</strong></li><li>客户端收到握手响应后，<strong>验证响应头的字段，并生成一个 <code>Sec-WebSocket-Accept</code> 值进行验证</strong></li><li>验证通过后，<code>WebSocket</code> <strong>连接建立成功，客户端和服务器可以开始进行实时通信</strong></li></ol><h2 id="如何处理错误和关闭连接？">如何处理错误和关闭连接？</h2><p>WebSocket 在<strong>出现错误时会触发 error 事件</strong>，可以通过**设置 <code>onerror</code> 事件处理函数来处理错误。**例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket 错误:&#x27;</span>, error); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 WebSocket <strong>连接关闭时，会触发 close 事件</strong>，可以通过<strong>设置 <code>onclose</code> 事件处理函数</strong>来执行一些清理操作或重新连接等操作，可以通过<strong>调用 <code>close()</code> 方法来显式地关闭</strong> WebSocket 连接</p><h2 id="实际应用中，如何处理连接状态的变化和重连机制？">实际应用中，如何处理连接状态的变化和重连机制？</h2><p>在 <code>onopen</code> 事件中，使用 <code>setInterval</code> 方法定时发送心跳数据包。如<strong>每 5000 毫秒发送一次心跳数据包</strong>，如下所示代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  heartcheck = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;HeartBeat&#x27;</span>); <span class="comment">// 发送心跳数据包</span></span><br><span class="line">  &#125;，<span class="number">5000</span>); <span class="comment">// 时间间隔，单位毫秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>onmessage</code>事件中，当接收到服务器返回的心跳响应或其他消息时，可以<strong>重置心跳定时器</strong>，以避免不必要的心跳发送。例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(heartcheck);<span class="comment">// 清除原来的心跳定时器</span></span><br><span class="line">  heartcheck=<span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;HeartBeat&#x27;</span>); <span class="comment">// 重新创建心跳定时器并发送心跳数据包</span></span><br><span class="line">  &#125;, <span class="number">5000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>onclose</code>和<code>onerror</code>事件中，需要<strong>清除心跳定时器</strong>，以避免在连接关闭后继续发送心跳数据包。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(heartcheck);<span class="comment">//清除心跳定时器</span></span><br><span class="line">&#125;;</span><br><span class="line">ws.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(heartcheck);<span class="comment">// 清除心跳定时器</span></span><br><span class="line">  <span class="comment">// 可以添加重连逻辑或其他错误处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">WebSocket</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="WebSocket" scheme="https://southernfish.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>WebPack</title>
    <link href="https://southernfish.github.io/2025/06/21/front-end/front-end-webpack/"/>
    <id>https://southernfish.github.io/2025/06/21/front-end/front-end-webpack/</id>
    <published>2025-06-21T04:55:36.000Z</published>
    <updated>2025-06-24T06:44:33.643Z</updated>
    
    <content type="html"><![CDATA[<p>webpack 是代码编译工具，有入口、出口、loader 和<a href="https://baike.baidu.com/item/%E6%8F%92%E4%BB%B6/369160?fromModule=lemma_inlink">插件</a>。webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 <em>bundle</em>。</p><h2 id="什么是-webpack">什么是 webpack ?</h2><p><code>webpack</code> 是一个现代 JavaScript 应用程序的<strong>静态模块打包器</strong><br><code>webpack</code> 可以<strong>递归的打包项目中所有模块</strong>（递归：指定一个入口，分析模块的依赖，它会递归的查找所有相关的依赖）</p><h2 id="核心概念">核心概念</h2><p><code>Entry</code>：配置入口文件。webpack 会找出有哪些模块是入库的依赖 ， 相关的依赖会被处理，输出到 bundles 的文件中<br><code>Output</code>：output 属性会告诉 webpack 它<strong>所创建的bundles 如何命名，默认值为 ./dist</strong><br><code>module</code>：模块。Webpack 里一切皆模块，一个模块对应一个文件。Webpack 从配置的 Entry 开始递归找出所有依赖的模块。<br><code>Chunk</code>：代码块。一个 chunk 由多个模块组合而成，用于代码的合并和分割。<br><code>loader</code>：模块转换器。用于将模块的原内容按照需要转成你想要的内容<br><strong>babel 和 webpack的区别：</strong></p><ul><li><code>babel</code>：JS新语法编译工具，只关心语法，不关心模块化</li><li><code>webpack</code>：打包构建工具，是多个 Loader plugin 的集合</li></ul><h2 id="webpack与grunt、gulp的不同？">webpack与grunt、gulp的不同？</h2><p>Webpack 与 Gulp、Grunt 没有什么可比性。<br>Webpack 可以看作<strong>模块打包机</strong>，通过分析项目结构找到js模块及一些浏览器不能直接运行的语言（<code>scss typescript</code>）<br><strong><code>Grunt</code> 和 <code>Gulp</code> 的工作方式</strong>：在一个<strong>配置文件</strong>中，指明对某些文件进行类似编译，组合，压缩等<strong>任务的具体步骤，工具之后可以自动替你完成这些任务</strong>。<br><strong><code>Webpack</code> 的工作方式</strong>：把项目当做一个整体，通过一个<strong>给定主文件</strong>（如：index.js），Webpack 将这个文件<strong>开始找到你的项目的所有依赖文件，使用 <code>loaders</code> 处理它们，最后打包为一个（或多个）浏览器可识别的 <code>JavaScript</code> 文件</strong>。</p><h2 id="webpack有哪些优缺点">webpack有哪些优缺点</h2><p><strong>优点：</strong></p><ul><li>可通过 <code>plugin</code> 扩展</li><li>使用场景不局限于 <code>web</code> 开发</li><li>良好的开发体验</li></ul><p>**缺点：**只能用于采用模块化开发的项目</p><h2 id="webpack打包原理？">webpack打包原理？</h2><p><strong>把所有依赖打包成一个 bundle.js 文件，通过代码分割成单元片段并按需加载</strong>。<br>Webpack 是一个模块打包器，grunt 和 gulp 是执行任务的，<br>webpack 递归的打包项目中所有模块，最终生成几个打包后的文件，与其他工具最大的不同在于它<strong>支持 code-splitting（代码分割），模块化（AMD，ESM，CommonJS）开发，全局的分析工具（分析整个项目引入的模块）</strong></p><h2 id="什么是模块热跟新-？-有什么优点？">什么是模块热跟新 ？ 有什么优点？</h2><p><strong>模块热更新：<strong>是webpack的一个功能，可以使</strong>代码修改后不用刷新浏览器就可更新内容</strong>。 是高级版的自动刷新浏览器（将代码重新执行一遍而不是整体刷新浏览器）<br>**优点：**只更新变更内容，以节省开发时间。<strong>调整样式更加快速</strong>，几乎相当于在浏览器中更改样式</p><h2 id="如何利用webpack来优化前端性能？">如何利用webpack来优化前端性能？</h2><p><strong>代码压缩、按需加载、使用 <code>Dll</code> 进行分包</strong><br>正常情况下 <code>node_module</code> 会被打包成一个文件，使用 <code>dll</code> 技术，可<strong>将不常更新的框架和库进行单独打包，生成一个chunk</strong></p><h2 id="webpack-为什么启动速度慢">webpack 为什么启动速度慢</h2><p>它是将所有模块构建完了，再去启动项目的</p><h2 id="如何提高webpack的构建速度？">如何提高webpack的构建速度？</h2><ul><li>减少需要构建的文件或代码</li><li>多进程打包 <code>thread-loader</code>，将其放在费时的 <code>loader</code> 之前</li></ul>]]></content>
    
    
    <summary type="html">WebPack</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="WebPack" scheme="https://southernfish.github.io/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://southernfish.github.io/2025/06/21/front-end/front-end-javascript/"/>
    <id>https://southernfish.github.io/2025/06/21/front-end/front-end-javascript/</id>
    <published>2025-06-21T04:35:36.000Z</published>
    <updated>2025-06-24T06:44:33.643Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript是一种轻量级、解释型或者说即时编译型的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131?fromModule=lemma_inlink">编程语言</a>， [20]广泛应用于网页开发中，主要用于增强网页的<a href="https://baike.baidu.com/item/%E4%BA%A4%E4%BA%92%E6%80%A7/10758528?fromModule=lemma_inlink">交互性</a>和<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E6%80%A7/53339475?fromModule=lemma_inlink">动态性</a>。作为Web开发的核心技术之一，它与<a href="https://baike.baidu.com/item/HTML/97049?fromModule=lemma_inlink">HTML</a>和<a href="https://baike.baidu.com/item/CSS/5457?fromModule=lemma_inlink">CSS</a>共同协作，HTML负责定义网页的内容结构，CSS处理样式和布局，而JavaScript则控制网页的行为和交互。</p><h2 id="js的事件循环机制">js的事件循环机制</h2><p><strong>js是单线程的，会出现阻塞问题。</strong><br>比如说网络请求和 <code>settimeout</code> ，它<strong>通过异步来做</strong>的，若都用异步则会放在队列里面，<strong>异步队列没有优先级</strong>，所以为了更灵活增加了事件循环<br><strong>事件循环：</strong><br>js是单线程，有同步任务和异步任务，一般是异步任务又分为微任务和宏任务<br><strong>先执行同步任务队列，再执行微任务队列，之后再执行宏任务</strong>，每执行一次宏任务时会<strong>时时检测微任务队列有没有任务</strong>，若有则会先清空微任务队列，执行完了，再去执行下一个宏任务。</p><p><strong>运行机制：</strong><br>单线程，从上到下按顺序执行代码。<strong>运行的两个阶段</strong>：</p><ol><li>**预解析：**把所有的函数定义提前，所有的变量声明提前，变量的赋值不提前</li><li>**执行：**从上到下执行（按照js运行机制）</li></ol><h2 id="javascript的数据类型">javascript的数据类型</h2><p><code>Boolean</code>、<code>null</code>、<code>String</code>、<code>Number</code>、<code>Object</code>、<code>Undefined</code><br><strong>常见基本数据类型：</strong><code>Number</code>、<code>String</code> 、<code>Boolean</code>、<code>Null</code> 和 <code>Undefined</code>。<br>基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值<br><strong>引用类型：</strong><code>Objec</code>t 、<code>Array</code> 、<code>Function</code> 、<code>Data</code>等。</p><h2 id="怎样判断变量的类型">怎样判断变量的类型</h2><p><code>typeof</code> 能够区分<strong>除数组、对象和null外的所有类型</strong>，[] {} null 都返回object<br><code>instanceof</code> 及原理：<code>object.toString().call()</code></p><h2 id="Cookie（4kb）、-storage-（5MB）-localStorage（5-10MB）">Cookie（4kb）、 storage （5MB） localStorage（5-10MB）</h2><p>首先，<code>webstorage</code>中包含<code>sessionStorage</code>和<code>localStorage</code>。 <strong>cookie和webstorage的区别:</strong></p><ol><li><strong>出现的时间：</strong><code>cookie</code> 很早之前就有了，<code>webstorage</code> H5之后才有的</li><li><strong>跟随请求状态</strong>：cookie 会跟着前后台请求，webstorage 不跟随</li><li>**储存大小：**cookie 4K，storage 5M左右</li><li>**生命周期：**cookie 生命周期可以设置，webstorage 生命周期不可设置</li><li>**存在的位置：**cookie / sessionStorage / localStorage 在客户端，<strong>seesion 在服务端</strong>，较其他的安全</li></ol><h2 id="操作数组和对象的常见方法">操作数组和对象的常见方法</h2><p><strong><code>array</code>：</strong> <code>slice / splice / concat / filter / map / reduce</code><br><strong><code>obj</code> ：</strong> <code>keys / assign</code></p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Lemon&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Mango&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> citrus = fruits.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>);   <span class="comment">// [&#x27;Orange&#x27;,&#x27;Lemon&#x27;]</span></span><br><span class="line"><span class="keyword">const</span> removed = fruits.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="string">&#x27;Kiwi&#x27;</span>, <span class="string">&#x27;Pineapple&#x27;</span>); <span class="comment">//替换了原数组[&#x27;Kiwi&#x27;, &#x27;Pineapple&#x27;, &#x27;Lemon&#x27;, &#x27;Apple&#x27;, &#x27;Mango&#x27;]</span></span><br><span class="line"><span class="comment">//fruits.splice(2, 2)   // [&#x27;Lemon&#x27;, &#x27;Apple&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="new内部做了什么">new内部做了什么</h2><ol><li>创建了一个新对象 <code>var obj = &#123;&#125;</code>；</li><li><code>this</code>关键字指向obj；</li><li><code>prototype</code>原型指向<code>obj</code>原型；</li><li>执行构造函数</li></ol><h2 id="防抖、节流-函数节流的应用场景">防抖、节流 , 函数节流的应用场景</h2><p>js 中一些事件如浏览器的 <code>resize</code>、<code>scroll</code>，鼠标的 <code>mousemove</code>、<code>mouseover</code>，input 输入框的 <code>keypress</code> 等<strong>事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</strong>。为优化体验，需要对这类事件进行调用次数的限制。<br>**函数防抖：**在一段连续操作结束后，处理回调，利用 <code>clearTimeout</code> 和 <code>setTimeout</code>实现<br>**函数节流：**每隔一段时间，只执行一次函数。<br><strong>场景：</strong></p><ol><li>滚动加载，加载更多或滚到底部监听；</li><li>谷歌搜索框，搜索联想功能；</li><li>高频点击提交，表单重复提交</li></ol><h2 id="this指向">this指向</h2><ol><li><strong>普通函数调用</strong>，此时 this 指向 <code>window</code></li><li><strong>构造函数调用</strong>，此时 this 指向 <code>实例对象</code></li><li><strong>对象方法调用</strong>，此时 this 指向 <code>该方法所属的对象</code></li><li><strong>通过事件绑定的方法</strong>，此时 this 指向 <code>绑定事件的对象</code></li><li><strong>定时器函数</strong>，此时 this 指向 <code>window</code></li></ol><h2 id="let-const-var-的区别">let const var 的区别</h2><p><code>var</code>：作用域是<strong>全域的</strong>； var<strong>允许重复声明变量</strong><br><code>let</code>：作用域是<strong>块级</strong>；let<strong>不允许重复声明变量</strong><br><code>const</code>：声明的是<strong>常量</strong>，不可改变，<strong>必须初始化</strong>，作用于<strong>块级作用域</strong>，没有变量提升，不允许重复声明</p><h2 id="实现继承的几种方式">实现继承的几种方式</h2><p><strong>原型链</strong>继承、<strong>构造</strong>继承、<strong>实例</strong>继承、<strong>拷贝</strong>继承、<strong>组合</strong>继承</p><h2 id="promiss的理解">promiss的理解</h2><p><code>Promise</code> 是 JavaScript 中异步编程的一种解决方案，用于处理异步操作的结果<br>**特点：**Promise 对象的状态不受外界影响，只有异步操作的结果才能决定其状态<br><strong>优点：</strong></p><ul><li><strong>解决了回调地狱问题</strong>，使得代码结构更加清晰和可维护；</li><li>提供了<strong>统一的API</strong>，使得异步操作的控制更加容易</li><li>function a(){  var n =0;  function b(){     n++;    console.log(n);  }}js</li></ul><p>**回调地狱问题：**每个接口都依赖于前一个接口的返回,</p><h2 id="promiss为什么支持链式调用">promiss为什么支持链式调用</h2><p>在 then 方法中返回另一个 Promise，因此可将多个 then 方法串联起来，形成一个链式调用。每个 then 方法的返回值都会作为下一个 then 方法的输入，从而实现异步操作的顺序执行。如下示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPromise</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(value), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getPromise</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getPromise</span>(result * <span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getPromise</span>(result * <span class="number">3</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: 6</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;  </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="在-try，catch中-报错了在catch中会被检测到么">在 try，catch中 报错了在catch中会被检测到么</h2><p>如果在 <code>catch</code> 块中再次抛出错误，这个新的错误<strong>可以被外层的 <code>try…catch</code> 语句捕获</strong>，或者如果没有外层的 try…catch 语句，它会<strong>继续向上抛出，直到被捕获或导致程序终止</strong>。</p><h2 id="浏览器垃圾回收">浏览器垃圾回收</h2><p>当 <code>JavaScript</code> 代码运行时，需要分配内存空间来存储变量和值。<br>当<strong>变量不再参与运行时，就需要系统收回被占用的内存空间</strong>，这就是垃圾回收<br><strong>常见内存泄露的原因</strong></p><ul><li><strong>全局变量</strong>引起的内存泄露</li><li><strong>闭包</strong>引起的内存泄露：慎用闭包</li><li><strong>dom清空或删除时，事件未清除导致</strong>的内存泄漏</li><li><strong>循环引用</strong>带来的内存泄露</li></ul><p><strong>优化写法</strong></p><ul><li>在<strong>对象结束使用后 ，令obj = null</strong>；</li><li>js中开辟空间的操作有 new()，[ ]，{ }，function (){…}，最大限度的实现<strong>对象的重用</strong>；</li><li><strong>慎用闭包</strong>，闭包容易引起内存泄露</li></ul><h2 id="js重复的问题-作用域链、原型、原型链、闭包？-面向对象-继承">js重复的问题 作用域链、原型、原型链、闭包？ 面向对象 继承</h2><p><strong>面向对象：<strong>是一种编程思想，将现实世界的事物抽象为对象，并使用类和对象来创建各种功能<br><strong>作用域链</strong><br>内部环境可以通过作用域链来访问外部环境的属性和方法，但</strong>外部环境不能访问内部环境的任何属性和方法</strong>。注意，<strong>只能通过定义函数来延长作用域链条</strong>。<br><strong>闭包</strong><br><strong>概念：<strong>闭包就是</strong>能够读取其他函数内部变量的函数</strong>，<code>Javascript</code> 语言中，只有函数内部的子函数才能读取局部变量，因此简单理解闭包为<strong>定义在一个函数内部的函数</strong>。<em>本质上</em>，闭包就是<strong>将函数内部和函数外部连接起来</strong>的一座桥梁。<br>例子(如下代码所示)：函数 b 就是一个闭包函数，用于获取函数 a 内部的变量 i。当函数 a 的内部函数 b，被函数 a 外的一个变量 c 引用的时候，就创建了一个闭包。<br><strong>作用：<strong>可以</strong>读取函数内部的变量；让这些变量的值始终保持在内存中</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(++i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="title function_">a</span>();</span><br><span class="line"><span class="title function_">c</span>()</span><br></pre></td></tr></table></figure><p><strong>原型链</strong><br><strong>原型：<strong>所有函数都有一个特殊属性 <code>prototype</code>(原型)，<strong>prototype 属性是一个指针，指向的是一个对象(原型对象)，原型对象中的方法和属性都可以被函数的实例所共享</strong>。所谓<code>函数实例</code>是指</strong>以函数作为构造函数创建的对象</strong>，这些对象实例都可以共享构造函数的原型的方法。<br><strong>原型链：<strong>原型链是</strong>用于查找引用类型（对象）的属性</strong>，查找属性会沿着原型链依次进行，找到后停止搜索并做相应的操作，否则会<strong>沿着原型链依次查找直到结尾</strong>。常见的应用是用在<strong>创建对象和继承</strong>中。</p>]]></content>
    
    
    <summary type="html">JavaScript</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="JavaScript" scheme="https://southernfish.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>VUE</title>
    <link href="https://southernfish.github.io/2025/06/20/front-end/front-end-vue/"/>
    <id>https://southernfish.github.io/2025/06/20/front-end/front-end-vue/</id>
    <published>2025-06-20T14:15:36.000Z</published>
    <updated>2025-06-24T06:44:33.643Z</updated>
    
    <content type="html"><![CDATA[<p>款用于构建用户界面的JavaScript框架。它基于标准<a href="https://baike.baidu.com/item/HTML/97049?fromModule=lemma_inlink">HTML</a>、CSS和<a href="https://baike.baidu.com/item/JavaScript/321142?fromModule=lemma_inlink">JavaScript</a>构建，并提供了一套声明式的、<a href="https://baike.baidu.com/item/%E7%BB%84%E4%BB%B6/6902128?fromModule=lemma_inlink">组件</a>化的编程模型，可以高效地开发<a href="https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/6582461?fromModule=lemma_inlink">用户界面</a>。无论是简单还是复杂的界面，Vue都可以胜任。</p><h1>基础</h1><h2 id="对于MVVM的理解？">对于MVVM的理解？</h2><ul><li><code>MVVM</code> 是 <code>Model-View-ViewModel</code> 的缩写</li><li>MVVM 的设计原理是<strong>基于 MVC</strong> 的</li><li><strong>Model代表数据模型 ；View 代表UI 组件视图；<strong>ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是</strong>一个同步 View 和 Model 的对象，连接 Model 和 View</strong></li></ul><p><strong>优势：</strong><code>vue</code> 和 <code>mode</code> 之间是双向数据传递的，视图改变数据就可以改变，数据改变了视图也跟着改变</p><h2 id="Vue的生命周期">Vue的生命周期</h2><p><strong>生命周期：<strong>Vue 实例</strong>从创建到销毁的过程</strong>，就是生命周期。从<strong>开始创建、初始化数据、编译模板、挂载 Dom →渲染、更新→渲染、销毁</strong>等一系列过程，称之为 Vue 的生命周期。<br><strong>vue 生命周期的作用：<strong>它的生命周期中</strong>有多个事件钩子，在控制整个 Vue 实例的过程时更容易形成好的逻辑</strong>。<br><strong>vue 生命周期总共有 8 个阶段：</strong><code>创建前/后， 载入前/后，更新前/后，销毁前/销毁后</code>。<br>第一次页面加载会触发以下几个钩子：<code>beforeCreate, created, beforeMount, mounted</code> 。<br>DOM 渲染在 <code>mounted</code> 周期中就已经完成</p><h2 id="Vue的生命周期-2">Vue的生命周期</h2><p><code>beforeCreate</code>：在实例创建之间执行，数据是未加载状态。<br><code>created</code>：在实例创建、数据加载后，能初始化数据，DOM 渲染之前执行。<br><code>beforeMount</code>：虚拟 DOM 已创建完成，在数据渲染前最后一次更改数据。el 未挂载。<br><code>mounted</code>：页面、数据渲染完成。el 挂载完毕。可以访问 DOM 节点。<br><code>beforeUpdate</code>：重新渲染之前触发。不会造成重渲染。<br><code>Updated</code>：数据已经更新完成，DOM 也重新 render 完成，更改数据会陷入死循环。<br><code>beforeDestroy</code>：实例销毁前执行，实例仍然完全可用。<br><code>destroyed</code>：实例销毁后执行，这时候只剩下 DOM 空壳。</p><h2 id="Vue3的生命周期？">Vue3的生命周期？</h2><p><strong>创建期setup()</strong><br><strong>挂载期：</strong></p><ul><li><code>onBeforeMount()</code>：<strong>组件挂载到节点上之前</strong>执行的函数</li><li><code>onMounted()</code>：<strong>组件挂载完成后</strong>执行的函数，<strong>此时可以访问和操作DOM</strong></li></ul><p><strong>更新期：</strong></p><ul><li><code>onBeforeUpdate()</code>：<strong>组件更新之前</strong>执行的函数</li><li><code>onUpdated()</code>：<strong>组件更新完成之后</strong>执行的函数</li></ul><p><strong>销毁期：</strong></p><ul><li><code>onBeforeUnmount()</code>：<strong>组件卸载之前</strong>执行的函数，可以进行一些<strong>善后的工作</strong>，例如清理定时器等</li><li><code>onUnmounted()</code>：<strong>组件卸载完成后</strong>执行的函数，表示组件已经被完全销毁</li></ul><h2 id="vue获取数据在哪个周期函数">vue获取数据在哪个周期函数?</h2><p>一般 <code>created</code> / <code>beforeMount</code> / <code>mounted</code> 皆可， 比如如果你要操作 DOM , 那肯定 mounted 时候才能操作</p><h2 id="Vue实现数据双向绑定的原理">Vue实现数据双向绑定的原理</h2><p><strong>Vue2 实现数据双向绑定的原理：</strong><code>Object.defineProperty()</code><br>采用<strong>数据劫持结合发布者-订阅者模式的方式</strong>，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，<strong>触发相应监听回调</strong></p><p><strong>Vue3 实现数据双向绑定的原理：</strong><code>Proxy</code><br>当<strong>属性被修改时，Proxy 对象的 set 陷阱会被触发</strong>。此时，<strong>Vue3会通知所有依赖该属性的 Watcher 对象进行更新</strong>。Watcher 对象会调用对应的更新函数，从而触发视图的重新渲染</p><h2 id="Vue的路由实现：hash模式-和-history模式区别，上线有什么区别。">Vue的路由实现：hash模式 和 history模式区别，上线有什么区别。</h2><p>**hash模式：**在浏览器中符号<code>“#”</code>， 用<code>window.location.hash</code>读取<br><strong>history模式：<strong>采用HTML5新特性；<strong>方法 <code>pushState()，replaceState()</code> 可修改浏览器历史记录栈</strong>，<code>popState</code> 事件监听状态变更。<br>上线区别<br><strong>hash模式：<strong>URL 形式：<a href="http://example.com/">http://example.com/</a></strong>#/path</strong>，</strong># 后面的部分来模拟一个完整的 URL</strong>，不会引起页面的重新加载。<br><strong>history 模式：<strong>URL 形式：<a href="http://example.com">http://example.com</a></strong>/path</strong>，<strong>需配置服务器</strong>，否则会当成真正的路径要后端配置重定向，不然访问不到。</p><h2 id="Vue组件间的参数传递-和父子组件方法调用（组件通信）">Vue组件间的参数传递 和父子组件方法调用（组件通信）</h2><ul><li><strong>父组件与子组件传值</strong><ul><li>父组件传给子组件：<strong>子组件通过<code>props</code>方法接受数据；</strong></li><li>子组件传给父组件：<strong><code>$emit</code> 方法传递参数</strong></li></ul></li><li><strong>非父子组件间的数据传递，兄弟组件传值</strong><ul><li><code>eventBus</code>，就是<strong>创建一个事件中心</strong>，相当于中转站，<strong>可用它传递事件和接收事件</strong>。比较适合项目较小时。</li><li>事件总线： <code>Vue.prototype.$bus = new Vue()；</code>使用 <code>Vuex</code></li></ul></li><li>provide 和 inject</li><li>父组件调用子组件方法：<code>this.$refs.mychildren.function()</code></li><li>子组件调用父组件方法： <code>this.$parent.function()</code></li></ul><h2 id="params和query的区别">params和query的区别</h2><p>**用法：**query 用 path 引入，params 用 name 引入，接收参数类似，分别是 <code>this.$route.query.name</code> , <code>this.$route.params.name</code><br>**url地址显示：**query 类似于 ajax 中 get 传参，params 类似于 post，或者说 query 在浏览器地址栏中显示参数，params 不显示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// params传值</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="regexp">/user/</span>:id&#125; <span class="comment">// 路由里:id</span></span><br><span class="line">&lt;router-link to =<span class="string">&quot;/user/123&quot;</span>&gt;&lt;<span class="regexp">/router-link&gt; /</span><span class="regexp">/ 组件传值 用/i</span>d</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="property">params</span>.<span class="property">id</span> <span class="comment">// js代码中获取路由传递的id值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// query传值</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/user&#x27;</span>&#125; <span class="comment">// 路由</span></span><br><span class="line"><span class="comment">// 组件传值 使用?拼接 参数之间用&amp;</span></span><br><span class="line">&lt;router-link to =<span class="string">&quot;/user? id=123&quot;</span>&gt;&lt;/router-link&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span> =<span class="string">&quot;/user?id=123&amp;name=zs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span> <span class="comment">//组件传值</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="property">query</span>.<span class="property">id</span> <span class="comment">//取值</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="property">query</span>.<span class="property">name</span> <span class="comment">//取值</span></span><br></pre></td></tr></table></figure><h2 id="vuex是什么？怎么使用？哪种功能场景使用它？">vuex是什么？怎么使用？哪种功能场景使用它？</h2><p><code>vuex</code> 是一种集中式状态管理模式，它按照一定的规则管理状态，保证状态的变化是可预测的。<br>vuex 可以理解为一种开发模式或框架，<strong>通过状态集中管理驱动组件的变化，应用级的状态集中放在store中，改变状态的方式是提交 mutations，异步逻辑封装在 action 中</strong>。</p><p><strong>使用方式：</strong><br>在 main.js 引入 store，注入。只用来读取的状态集中放在 store 中；<br>改变状态的方式是提交 mutations ，这是个同步的事物； 异步逻辑应该封装在 action 中。</p><p><strong>场景：单页应用中</strong>，组件之间的状态、音乐播放、登录状态、加入购物车<br><code>state</code>：定义初始化状态<br><code>getters</code>：获取状态<br><code>mutations</code>：设置状态<br><code>actions</code>：异步提交 mutations<br><code>modules</code>：把状态管理模块化，各自的组件构成各自的模块</p><h2 id="css只在当前组件起作用">css只在当前组件起作用</h2><p>在 style 标签中写入 <code>scoped</code> 即可 例如：<code>&lt;style scoped&gt;&lt;/style&gt;</code></p><h2 id="v-if-和-v-show-区别">v-if 和 v-show 区别</h2><p><strong>相同点：<strong>v-if 与 v-show 都可以</strong>动态控制 dom 元素显示隐藏</strong><br>**不同点：**v-if 将 dom 元素整个添加或删除 ，<strong>v-show 隐藏是为该元素添加 css–display:none，dom 元素还在</strong>。</p><h2 id="route和router的区别"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mtext>和</mtext></mrow><annotation encoding="application/x-tex">route和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">和</span></span></span></span>router的区别</h2><p><code>$route</code> 是<strong>路由信息对象</strong>，包括 path，params，hash，query，fullPath，matched，name等路由信息参数。 而$router 是<code>VueRouter</code> <strong>路由实例</strong> 对象包括了路由的跳转方法，钩子函数等。</p><h2 id="vue-js的两个核心是什么？">vue.js的两个核心是什么？</h2><p>数据驱动、组件系统</p><h2 id="computed、watch、methods的区别">computed、watch、methods的区别</h2><p><code>computed</code> 要有返回值，支持缓存。watch 不支持缓存。methods 不支持缓存。<br>**<code>watch</code> 项目用处：**搜索框输入框的监听；监听路由地址的改变</p><h2 id="vue几种常用的指令">vue几种常用的指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v-for (循环指令，可以循环数组或对象)</span><br><span class="line">v-if (是否渲染元素，会销毁并重建)</span><br><span class="line">v-bind (动态绑定数据)</span><br><span class="line">v-on (绑定事件监听器)</span><br><span class="line">v-show (显示隐藏元素，修改元素的 display 属性)</span><br><span class="line">v-else(与 v-if 配合使用)</span><br><span class="line">v-model (实现双向绑定)</span><br></pre></td></tr></table></figure><h2 id="v-for与v-if-一起使用">v-for与v-if 一起使用</h2><p>由于<strong>v-for会先执行，v-if 将分别重复运行于每个 v-for 循环中</strong>。这可能会导致不必要的计算，性能下降，特别是在处理大型数据集时，可能会使代码的逻辑变得不清晰。<br>在<code>Vue 2</code>中在同一个元素上同时使用这两个指令时 <strong>v-for 的优先级高于 v-if</strong> ，<br>在<code>Vue 3</code>中，<strong>v-if 的优先级高于 v-for</strong>。不推荐一起使用 在外层包装一个 template 标签</p><h2 id="v-on-可以绑定多个方法吗？">v-on 可以绑定多个方法吗？</h2><p>可以 … 例：<code> &lt;p @click=“one(),two()”&gt;</code>点击</p><h2 id="vue中key-值的作用">vue中key 值的作用</h2><p>原理是vue 在**<code>pacth</code>过程中<strong>通过 key 可以精准判断两个节点是否是同一个， 从而避免平凡更新不同元素，减少dom操作，提升性能<br>key值</strong>对数据改变之后的diff更新比较有很大的性能提升**，或者说有了key和没有key是两种比较和更新机制<br>作用主要是为了<strong>高效的更新虚拟DOM</strong>。另外vue中在<strong>使用相同标签名元素的过渡切换时</strong>，也会使用到key属性，目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果，就不会达到最小更新<br><strong>index值不是一定不变的</strong>，若不加key值，删除前面的项。后面的index可能变也可能不变，如加个定时器时会变，不加定时器不变</p><h2 id="nextTick的使用">$nextTick的使用</h2><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新的 DOM。</p><h2 id="nextTick能获取到最新dom是什么原理">$nextTick能获取到最新dom是什么原理</h2><p>当修改了数据，Vue 会将这些变更放入一个异步任务队列，而不是立即更新 DOM。<br><code>$nextTick</code> 的<strong>回调函数是在任务队列中的所有任务执行完毕后调用的</strong>，这意味着 DOM 更新已经完成。</p><h2 id="项目初始化页面闪动问题">项目初始化页面闪动问题</h2><p>vue 页面在加载的时候闪烁花括号{}，v-cloak 指令和 css 规则如 [v-cloak]{ display:none }一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。<br>如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*css样式*/</span></span><br><span class="line"><span class="selector-attr">[v-cloak]</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!<span class="attr">--html</span>代码--&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> id=&quot;app&quot; v-cloak&gt;</span><br><span class="line">    &lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span> v-for=&quot;item in tabs&quot;&gt;&#123;&#123;item<span class="selector-class">.text</span>&#125;&#125;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="怎么理解vue中的-diff-算法？">怎么理解vue中的 diff 算法？</h2><p><code>diff</code> 算法是<strong>虚拟DOM的产物</strong>，通过新旧虚拟 dom 对比， 将变化的地方更新在真实的 dom 上<br><code>diff</code> 算法<strong>能精准找到发生的变化的地方</strong></p><h2 id="vue-怎么缓存-keep-alive">vue 怎么缓存 keep-alive</h2><p><code>keep-alive</code> 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染；可以实现组件缓存，当组件切换时不会对当前组件进行卸载；有 <code>include</code>、<code>exclude</code> 两个属性，可以有条件的进行组件缓存<br><code>keep-alive</code>功能：当组件切换为非激活状态时，不会触发销毁流程，而是将组件实例及其状态完整封存。这一特性使其成为保留组件状态、优化渲染性能的核心工具。<br>生命周期钩子联动。当组件在 keep-alive 内切换时，会触发专属生命周期钩子：</p><ul><li>function a() {    var i = 0;    function b(){        alert(++i);    }    return b;}var c = a();c()js</li><li><code>deactivated</code>：组件失活时调用（被切换出但未销毁）</li></ul><p>应用场景1：路由页面状态持久化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 缓存所有路由组件 --&gt;</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;!-- 精准缓存指定路由组件 --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;[&#x27;Home&#x27;, &#x27;Profile&#x27;]&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>应用场景2：动态组件状态保留</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;keep-alive&gt;</span><br><span class="line">    &lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/keep-alive&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123; currentComponent: &#x27;Login&#x27; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="vue组件中data为什么必须是一个函数？">vue组件中data为什么必须是一个函数？</h2><p>由 <code>JavaScript</code> 的特性所导致，在 <code>component</code> 中，data 必须以函数的形式存在，不可以是对象。组建中的 data 写成一个函数，数据以函数返回值的形式定义，这样<strong>每次复用组件的时候，都会返回一份新的 data ，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱</strong>。而单纯的写成对象形式，就是所有的组件实例共用了一个 data ，这样改一个全都改了。</p><h2 id="assets和static的区别">assets和static的区别?</h2><p>这两个都是用来<strong>存放项目中所使用的静态资源文件</strong>。<br><strong>两者的区别：</strong><br><code>assets</code> 中的文件在运行 <code>npm run build</code> 的时候会打包，也就是会被<strong>压缩体积，代码格式化</strong>之类的。<strong>打包之后也会放到 static 中</strong>。<br><code>static </code>中的文件则<strong>不会被打包</strong>。<br>**建议：**将图片等未处理的文件放在 assets 中，打包减少体积。而对于第三方引入的资源文件（如：iconfont.css等）可以放在static 中，因为这些文件已经经过处理了。</p><h2 id="vue的常用修饰符">vue的常用修饰符</h2><p><code>.prevent</code>：提交事件不再重载页面；等同于 JavaScript 中的 event.preventDefault()，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）<br><code>.stop</code>：阻止单击事件冒泡；等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡。<br><code>.self</code>：只会触发自己范围内的事件，不包含子元素；<br><code>.capture</code>：事件侦听，事件发生的时候会调用；与事件冒泡的方向相反，事件捕获由外到内<br><code>.once</code>：只会触发一次<br><code>.passive</code>：提升移动端的性能。</p><h2 id="vue其他修饰符？">vue其他修饰符？</h2><p><strong>按键修饰符：</strong><code>.enter</code>、<code>.delete</code>、<code>.space</code>、<code>.esc</code>、<code>.up</code>、<code>.down</code>等<br><strong>系统修饰键：</strong><code>.ctrl</code>、<code>.alt</code><br><strong>鼠标按钮修饰符：</strong><code>.left</code>、<code>.right</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 阻止单击事件继续传播</span><br><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line">// 提交事件不再重载页面</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line">// 修饰符可以串联</span><br><span class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line">// 只有修饰符</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class="line">// 添加事件监听器时使用事件捕获模式 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理</span><br><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line">// 只当在 event.target 是当前元素自身时触发处理函数  即事件不是从内部元素触发的</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class="line">// 点击事件将只会触发一次</span><br><span class="line">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line">// 滚动事件的默认行为 (即滚动行为) 将会立即触发, 不会等待onScroll完成,这其中包含 `event.preventDefault()` 的情况</span><br><span class="line">&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="vue深度监听（watch）">vue深度监听（watch）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">watch:</span><br><span class="line">// 第一种</span><br><span class="line">&quot;a.b.c&quot;:function(newValue, oldValue)&#123;</span><br><span class="line">    console.log(newValue, oldValue);</span><br><span class="line">&#125;</span><br><span class="line">// 第二种</span><br><span class="line">a: &#123;</span><br><span class="line">    deep: true, // deep为ture 意味着开启了深度监听a对象里面任何数据变化都会触发</span><br><span class="line">    handler(newValue, oldvalue)&#123;</span><br><span class="line">        //这个函数是固定写法</span><br><span class="line">        console.log(newValue, oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>Vue-router</h1><h2 id="vue路由的钩子函数-路由守卫">vue路由的钩子函数 (路由守卫)</h2><p>首页可控制导航跳转，beforeEach，afterEach等，一般用于页面title修改。一些需要登录才能调整页面的重定向功能。<br><strong>beforeEach((to,from,next)=&gt;{});</strong></p><ul><li><code>to</code>：route 即将进入的目标路由对象，</li><li><code>from</code>：route 当前导航正要离开的路由</li><li><code>next</code>：function一定要调用该方法resolve这个钩子。执行效果依赖 next 方法的调用参数。可控制网页跳转。</li></ul><p><strong>router.afterEach((to,from)=&gt;{});</strong></p><ul><li><code>to</code>：已进入的目标路由对象</li><li><code>from</code>：已离开的路由对象</li></ul><h2 id="vue-router有哪几种导航钩子？以及它的参数？">vue-router有哪几种导航钩子？以及它的参数？</h2><p><strong>第一种：全局导航</strong>钩子：<code>router.beforeEach(to,from,next)</code>，**作用：**跳转前进行判断拦截。<br><strong>第二种：组件内</strong>的钩子<br><strong>第三种：单独路由独享组件</strong><br>beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave<br>**参数：**to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，不用就拦截）</p><h2 id="Vue-router的跳转原理">Vue-router的跳转原理</h2><p><strong>Vue-router的跳转原理:</strong> 通过不同的模式来实现页面的无刷新跳转，主要包括 hash 模式、history 模式和 abstract 模式。</p><ul><li><code>hash</code>：使用 <code>URL hash</code> 值来作路由。默认模式。</li><li><code>history</code>：依赖 <code>HTML5 History API</code> 和服务器配置。查看 HTML5 History 模式。</li><li><code>abstract</code>：支持所有 JavaScript 运行环境，如 Node.js 服务器端</li></ul><p><strong>路由之间的跳转:</strong></p><ul><li>声明式（标签跳转）<ul><li><code>&lt;router-view&gt;</code>标签用于展示路由组件，DOM节点中使用 <code>v-link</code> 进行跳转，或使用 <code>router-link</code> 标签</li></ul></li><li>编程式（js跳转）</li></ul><h2 id="怎么定义vue-router的动态路由及如何获取传过来的动态参数？">怎么定义vue-router的动态路由及如何获取传过来的动态参数？</h2><p>在 router 目录下的 index.js 文件中，对 path 属性加上/：id<br>使用 router 对象的 params id<br>**用 watch 去监听 router 变化：**当路由发生变化的时候，在 watch 中写具体的业务逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">    $router(to, from)&#123;</span><br><span class="line">        console.log(to.path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue的路由实现-hash模式和history模式-Vue的两种状态">Vue的路由实现: hash模式和history模式(Vue的两种状态)</h2><p>**hash模式：**即地址栏URL的#符号<br>通过<code> window.onhashchange</code> <strong>监听，匹配不同的 url 路径，进行解析，加载不同的组件，然后动态的渲染出区域内的html 内容</strong>，不会被包含在HTTP请求中，对后端完全没有影响<br><strong>HashHistory 有两个方法：</strong></p><ul><li><code>HashHistory.push() </code>是将路由添加到浏览器访问历史的栈顶</li><li><code>hashHistory.replace() </code>是替换掉当前栈顶的路由</li></ul><p>因为<strong>hash发生变化的url都会被浏览器历史访问栈记录下来</strong>，因此尽管浏览器没有请求服务器，但页面状态是和url关联起来的，浏览器还是可以进行前进后退的</p><p><strong>history模式</strong><br>利用 HTML5 History Interface 中新增的 <strong>pushState()</strong> 和 <strong>replaceState()</strong> 方法。这两个方式应用于浏览器的历史记录栈，<strong>提供了对历史记录的修改功能</strong>。history模式不怕页面的前s进和后腿，就怕刷新，当<strong>刷新时，若服务器没有相应的响应或者资源，就会刷出404</strong>，而hash模式不会<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mtext>从当前</mtext><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mtext>跳转对象里面可以获取</mtext><mi mathvariant="normal">‘</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mtext>、</mtext><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mtext>、</mtext><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mtext>、</mtext><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">‘</mi><mtext>等（</mtext><mi mathvariant="normal">‘</mi><mo>&lt;</mo><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo>−</mo><mi>l</mi><mi>i</mi><mi>n</mi><mi>k</mi><mo>&gt;</mo><mi mathvariant="normal">‘</mi><mtext>传的参数有</mtext><mi mathvariant="normal">‘</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">route 从当前 router 跳转对象里面可以获取 `name、path、query、params` 等（`&lt;router-link&gt;`传的参数有`this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">从当前</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord cjk_fallback">跳转对象里面可以获取</span><span class="mord">‘</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">ery</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">am</span><span class="mord mathnormal">s</span><span class="mord">‘</span><span class="mord cjk_fallback">等（</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03148em;">ink</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">‘</span><span class="mord cjk_fallback">传的参数有</span><span class="mord">‘</span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span>route.query<code>或者</code>this.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">‘</mi><mtext>接收）导航到不同</mtext><mi>U</mi><mi>R</mi><mi>L</mi><mtext>，则使用</mtext><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">route.params` 接收）导航到不同URL，则使用 `</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">am</span><span class="mord mathnormal">s</span><span class="mord">‘</span><span class="mord cjk_fallback">接收）导航到不同</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">L</span><span class="mord cjk_fallback">，则使用</span><span class="mord">‘</span></span></span></span>router.push<code>方式，返回上一个history也是使用</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>g</mi><mi>o</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">router.go/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">o</span><span class="mord">/</span></span></span></span>router.back` 方法</p>]]></content>
    
    
    <summary type="html">VUE</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="VUE" scheme="https://southernfish.github.io/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>前端基础</title>
    <link href="https://southernfish.github.io/2025/06/20/front-end/front-end-base/"/>
    <id>https://southernfish.github.io/2025/06/20/front-end/front-end-base/</id>
    <published>2025-06-20T13:15:36.000Z</published>
    <updated>2025-06-24T06:44:33.643Z</updated>
    
    <content type="html"><![CDATA[<p>前端技术是Web应用开发中基于浏览器的程序开发，涵盖HTML、CSS和JavaScript等基础技术，并通过BOM、DOM实现用户交互。该技术以HTML、CSS、JavaScript为核心基础，通过DOM与BOM实现动态页面控制。</p><h2 id="HTML5的新特性和CSS3的新特性">HTML5的新特性和CSS3的新特性</h2><p><strong>HTML5的新特性</strong></p><ul><li><strong>语义化标签 ：</strong><code>header</code>、<code>nav</code>、 <code>aside</code>、<code>footer</code>、<code>article</code>、<code>section</code> 等。可以更清晰地描述网页的结构和内容，提高网页的可读性和可访问性，利于搜索引擎优化（SEO）。</li><li>**表单控件验证功能：**如日期选择器、颜色选择器、滑块等，表单更加易用，同时内置表单验证功能，减少了验证代码的编写量。</li><li><strong>多媒体支持：</strong> video audio等</li></ul><p><strong>CSS3的新特性</strong></p><ul><li><strong>改善布局和样式：</strong> 如边框圆角、边框阴影、渐变、文本装饰</li><li><strong>动画和过渡：</strong> <code>transition</code> 属性和 <code>@keyframes</code> 规则制定动画效果</li><li>多列布局和弹性盒子布局</li><li><strong>媒体查询:</strong> 不同屏幕的尺寸使用不同的<code>css</code></li><li>自定义字体和背景</li><li>**网格布局 ：*<em>上下居中水平对齐方式<code>display: grid; place-items: center; </code>/</em> 水平和垂直都居中 */</li></ul><h3 id="css-选择器的优先级排序">css 选择器的优先级排序</h3><p>优先级排序从高到低：<code>!important</code> 、<code>行内样式</code>、<code>ID选择器</code>、<code>类选择器</code></p><h2 id="link和a标签区别">link和a标签区别</h2><p><code>link</code>是一个组件，用处也是页面内跳转。<code>a</code>是基础的标签，也是用来跳的。</p><h2 id="什么是CSS盒模型-IE盒模型和W3C盒模型">什么是CSS盒模型 &gt;&gt;&gt; -IE盒模型和W3C盒模型</h2><p><strong>标准模式</strong>下，一个块的宽度 = width + padding(内边距) + border(边框) + margin(外边距)；<br><strong>怪异模式</strong>下，一个块的宽度 = width + margin(外边距) （即怪异模式下，width包含了border以及padding）;</p><h3 id="div-上下居中对齐的几种方式">div 上下居中对齐的几种方式</h3><p>第一种：flex布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center; // 水平居中 </span><br><span class="line">    <span class="attribute">align-items</span>: center; // 垂直居中 </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>; // 或其他高度 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：grid网格布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    place-items: center; // 水平和垂直都居中 </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>; // 或者其他需要的高度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种：相对定位和绝对定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123; <span class="attribute">position</span>: relative; <span class="attribute">height</span>: <span class="number">100vh</span>; &#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四种：line-height 适用于单行文本</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: cente</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伪类和伪元素的区别">伪类和伪元素的区别</h3><p><strong>伪类：<strong>伪类</strong>用于选择DOM树之外的信息</strong>。<code>:hover</code> 伪类用于选择鼠标悬停在其上的元素，<code>:visited</code> 用于选择已访问的链接等<br><strong>伪元素：<strong>伪元素为</strong>DOM树没有定义的虚拟元素</strong>。 例如，<code>::before</code> 和 <code>::after </code>伪元素允许在元素内容之前或之后插入内容</p><h2 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h2><p><strong>浅拷贝</strong><br>在栈内存中重新开辟一块内存空间，并将拷贝对象储存在栈内存中的数据存放到其中。<br>**存在问题：**浅拷贝只复制了引用，所以修改新对象会影响到原对象<br><strong>实现方法：</strong> 使用<code>赋值运算符（=）</code>或者<code>Object.assign()</code>函数进行拷贝</p><p><strong>深拷贝</strong><br>另外创造一个一模一样的对象<br>**优点：**修改新对象不会影响到原对象<br>**实现方法：**递归拷贝 <code>JSON.parse(JSON.stringify(obj))</code>，<code> …扩展运算符</code><br><code>const b = […a]; </code>// 这只适用于一层深拷贝<br><code>const c = JSON.parse(JSON.stringify(a)); </code>// 深拷贝<br>// 如果是个对象有函数或者空值，<code>undefind</code>时会有问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的深拷贝</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>())</span><br><span class="line"><span class="comment">// 递归的实现复制一个对象或者数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(obj === <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> obj !=== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cloneObj= <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? []:&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    cloneObj[key]= <span class="title function_">clone</span>(obj[key])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装axios">封装axios</h2><p>例如一次发出两个一模一样的请求如何清除一个，通过使用 <code>Axios</code> 的 <code>CancelToken</code> 和请求拦截器，如果已经有相同的请求在进行中，取消之前的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//axios封装</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.example.com&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 封装 GET 请求</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">url, params, cancelToken</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> instance.<span class="title function_">get</span>(url, &#123;params, cancelToken &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 封装 POST 请求</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">post</span> = (<span class="params">url, data, cancelToken</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> instance.<span class="title function_">post</span>(url, data, &#123; cancelToken &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;get,post,&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 CancelToken 取消重复请求</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">&#x27;./api&#x27;</span>; <span class="comment">// 上面封装的 Axios 实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pendingRequests = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">requestInterceptor</span> = (<span class="params">config</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; url, method, params, data &#125; = config;</span><br><span class="line">  <span class="comment">// 生成唯一标识符</span></span><br><span class="line">  <span class="keyword">const</span> key = <span class="string">`<span class="subst">$&#123;method&#125;</span>-<span class="subst">$&#123;url&#125;</span>-<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(params)&#125;</span>-<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">if</span> (pendingRequests.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">    <span class="comment">// 如果已经有相同的请求在进行中，取消之前的请求</span></span><br><span class="line">    <span class="keyword">const</span> cancelToken = pendingRequests.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="title function_">cancelToken</span>(<span class="string">&#x27;Request canceled due to duplicate request&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建新的取消令牌</span></span><br><span class="line">  <span class="keyword">const</span> source = <span class="title class_">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line">  config.<span class="property">cancelToken</span> = source.<span class="property">token</span>;</span><br><span class="line">  <span class="comment">// 将新的请求加入到 pendingRequests 中</span></span><br><span class="line">  pendingRequests.<span class="title function_">set</span>(key, source.<span class="property">cancel</span>);</span><br><span class="line">  <span class="comment">// 在请求完成后删除该请求</span></span><br><span class="line">  config.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      pendingRequests.<span class="title function_">delete</span>(key);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      pendingRequests.<span class="title function_">delete</span>(key);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(requestInterceptor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例请求</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetchUserData</span> = <span class="keyword">async</span> (<span class="params">userId</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123; &#125; <span class="keyword">catch</span> (error) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起两个相同的请求</span></span><br><span class="line"><span class="title function_">fetchUserData</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">fetchUserData</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="HTTPS的工作流程，HTTPS证书的验证">HTTPS的工作流程，HTTPS证书的验证</h2><p>**客户端发起<code>HTTPS</code>请求：**客户端向服务器发起HTTPS请求，并指定要访问的HTTPS资源的URL。<br>**服务器返回公钥证书：**服务器将包含公钥的证书发送给客户端。<br><strong>客户端验证证书：<strong>客户端验证证书的合法性，包括证书</strong>是否由受信任的CA（证书颁发机构）签发、证书是否过期等</strong>。<br>**生成并发送对称加密密钥：**如果证书验证通过，客户端将生成一个对称加密密钥，并使用服务器公钥对该密钥进行加密后发送给服务器。<br>**服务器解密对称加密密钥：**服务器使用自己的私钥解密得到对称加密密钥。<br>**加密传输数据：**双方使用协商好的对称加密密钥对传输的数据进行加密和解密。</p><h2 id="JSONP原理">JSONP原理</h2><p>利用script标签 的 src 没有跨域限制的“漏洞” 来达到与第三方通讯的目的。只能处理get请求<br><strong>CORS：<strong>服务器端支持CORS主要通过设置</strong>Access-Control-Allow-Origin</strong>进行。浏览器检测到相应设置则允许Ajax跨域访问。</p><p><strong>vue中的跨域问题：</strong><br>找到配置文件config.js   <strong>修改<code>proxyTable</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxyTable</span>:</span><br><span class="line"><span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">  <span class="attr">target</span>: <span class="string">&#x27;http://www.xxxxxx.com/api&#x27;</span>，<span class="comment">//指定代理的地址</span></span><br><span class="line">  <span class="attr">changeOrigin</span>: <span class="literal">true</span>，<span class="comment">//是否允许跨越, 改变源到url，在虚拟主机上很有用</span></span><br><span class="line">  <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;/&#x27;</span>, <span class="comment">// 重写</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若后端地址不带路径’/api’, ‘http://www.xxxxxx.com/api’ 改为‘http://www.xxxxxx.com’</span></span><br></pre></td></tr></table></figure><h2 id="cookie、sessionStorage、localStorage的区别">cookie、sessionStorage、localStorage的区别</h2><p>它们的区别在于存储的<strong>有效期和作用域的不同</strong><br>**<code>cookie</code>：**默认的，<strong>有效期很短，一旦用户关闭浏览器，Cookie保持的数据就会丢失；cookie存储空间比较小（ 4KB左右）</strong>。<br>为解决 HTTP 无状态的问题，常使用 Cookie 和 Session 等机制来在客户端和服务器之间保持状态。Cookie 是一种<em>在客户端存储少量数据并在每个请求中发送给服务器的机制，而 Session 则是在服务器端存储用户状态信息，并通过在客户端和服务器之间传递 Session ID 来保持会话状态</em>。<br><strong><code>localStorage</code>：存储的数据是永久性的， 除非手动删除；存储大小通常为5-10MB；作用域限制在文档源级别</strong>，同源的文档间共享同样的localStorage数据<br><strong><code>sessionStorage</code>：存储的数据存在会话期 ； 通常可以达到5MB左右；一旦窗口或者浏览器标签页关闭存储的数据也会被删除； 作用域也是限定在文档源中。</strong></p><h2 id="浏览器与服务器的交互原理">浏览器与服务器的交互原理</h2><ol><li>输入网址</li><li>浏览器发送 http 请求</li><li>与dns 建立tcp/ip 3次握手</li><li>服务器 解析 并查找对应的域名</li><li>服务器相应数据返回</li><li>浏览器 下载 解析 服务器的响应数据</li><li>创建dom树 并解析css 与js 直到页面渲染完毕</li></ol><h2 id="A解释一下闭包，B为什么要使用闭包？-缺点">A解释一下闭包，B为什么要使用闭包？ 缺点</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> n =<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123; </span><br><span class="line">    n++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**闭包：**以上代码中，b 函数访问了构造函数 a 里面的变量，所以形成了一个闭包<br>**使用闭包的原因：**想要持续的使用一个变量，放在全局中会造成全局污染，放在函数中，函数执行完后会销毁，变量也随之销毁，因此需要使用闭包。<br><strong>拓展：</strong> 闭包函数是在<code>window</code>作用域下执行的，也就是说，<code>this</code>指向windows<br>**缺点 ：**内存泄露问题， 所以不能滥用闭包</p><h2 id="解释一下作用域链">解释一下作用域链</h2><p>函数A 嵌套函数B， 函数B嵌套函数C ：函数C里访问一个变量，先去C的作用域找 ，再往上一级找，直到window</p><h2 id="如何处理不让别人盗用你的图片，访问你的服务器资源？">如何处理不让别人盗用你的图片，访问你的服务器资源？</h2><ul><li>对于 nginx，可考虑用 location 通配你的图片后缀，根据 refer，再决定是否返回图片资源。</li><li><strong>又拍云、七牛云</strong>都有<strong>防盗链配置</strong></li><li>若未使用 cdn，即需要自己做防盗链。<ul><li><strong>一是</strong>判断 <code>refer</code>，看来源是不是自己的网站，不是就拒绝。适用范围最大，也<strong>容易破解， 因为 refer 可以伪造</strong>。</li><li><strong>二是</strong> <code>session 校验</code>，若不通过特定服务生成 cookie 和 session 就不能请求得到资源。最保险，因为 session 在后端。</li></ul></li><li>给图片加水印</li></ul><h2 id="如何优化网站性能">如何优化网站性能</h2><ul><li>许多<strong>小图片整合到一张大图片中</strong>（精灵图）减少网页http请求，以提升网页加载速度。对于小图标，可使用 base64 位编码，以减少网络请求。但不建议大图使用，比较耗费CPU； <strong>小图标优势</strong>在于：<strong>减少 HTTP 请求； 避免文件跨域； 修改及时生效</strong>。</li><li><strong>代码压缩</strong>，应用第三方资源库，cdn 托管</li><li><strong>控制资源文件加载优先级</strong>，css 优先，一般情况下都是CSS在头部，JS在底部。</li><li>利用浏览器<strong>缓存</strong></li><li><strong>减少页面重排</strong>，使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）；</li><li><strong>图片<code>lazyload</code> 懒加载</strong>，提高用户体验</li><li><strong>禁止使用gif图片实现loading效果</strong>（降低CPU消耗，提升渲染性能）；</li><li><strong>减少dom 操作，优化js</strong></li></ul>]]></content>
    
    
    <summary type="html">涵盖HTML、CSS和JavaScript等基础技术，通过DOM与BOM实现动态页面控制。</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="front end" scheme="https://southernfish.github.io/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://southernfish.github.io/2025/06/20/java/java-jvm/"/>
    <id>https://southernfish.github.io/2025/06/20/java/java-jvm/</id>
    <published>2025-06-20T04:58:36.000Z</published>
    <updated>2025-06-24T06:44:33.644Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E6%9C%BA/104440?fromModule=lemma_inlink">虚拟机</a>是一种抽象化的计算机，通过在实际的计算机上<a href="https://baike.baidu.com/item/%E4%BB%BF%E7%9C%9F%E6%A8%A1%E6%8B%9F/407213?fromModule=lemma_inlink">仿真模拟</a>各种计算机功能来实现的。<a href="https://baike.baidu.com/item/Java/85979?fromModule=lemma_inlink">Java</a>虚拟机有自己完善的<a href="https://baike.baidu.com/item/%E7%A1%AC%E4%BD%93/1298863?fromModule=lemma_inlink">硬体</a>架构，如处理器、<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032?fromModule=lemma_inlink">堆栈</a>、<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682?fromModule=lemma_inlink">寄存器</a>等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的<a href="https://baike.baidu.com/item/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81/9407934?fromModule=lemma_inlink">目标代码</a>（<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E7%A0%81/9953683?fromModule=lemma_inlink">字节码</a>），就可以在多种平台上不加修改地运行。本文简单记录一些关于JVM的问题。</p><h1>基础部分</h1><h2 id="JVM-的主要组成部分？及其作用？">JVM 的主要组成部分？及其作用？</h2><p>类加载器（<code>ClassLoader</code>）、运行时数据区（<code>Runtime Data Area</code>）、执行引擎（<code>Execution Engine</code>）、本地库接口（<code>Native Interface</code>）<br><strong>组件的作用：</strong> 首先通过类加载器（<code>ClassLoader</code>）<strong>把 Java 代码转换成字节码</strong>，然后运行时数据区（<code>Runtime Data Area</code>）再<strong>把字节码加载到内存</strong>中，而字节码文件只是 JVM 的一套指令集规范，不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（<code>Execution Engine</code>），<strong>将字节码翻译成底层系统指令</strong>，再<strong>交由 CPU 执行</strong>，而这个<strong>过程中需要调用其他语言的本地库接口</strong>（<code>Native Interface</code>）来实现整个程序的功能。</p><h2 id="JVM-运行时数据区？">JVM 运行时数据区？</h2><p>不同虚拟机运行时数据区可能略微有所不同，但都会遵从Java 虚拟机规范，Java 虚拟机规范规定区域分为以下 5 个部分：<br>**程序计数器（<code>Program Counter Register</code>）：**当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，<strong>分支、循环、跳转、异常处理、线程恢复等基础功能</strong>，都需要依赖这个计数器来完成；<br><strong>Java 虚拟机栈（<code>Java Virtual Machine Stacks</code>）：<strong>用于</strong>存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>；<br><strong>本地方法栈（<code>Native Method Stack</code>）：<strong>与虚拟机栈的作用一样，只不过虚拟机栈是服务 Java 方法的，而本地方法栈</strong>为虚拟机调用 Native 方法服务</strong>；<br><strong>Java 堆（<code>Java Heap</code>）：<strong>Java 虚拟机中</strong>内存最大的一块，被所有线程共享，几乎所有的对象实例都在这里分配内存</strong>；<br><strong>方法区（<code>Methed Area</code>）：<strong>用于</strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据</strong>。</p><h2 id="堆栈的区别？">堆栈的区别？</h2><p><strong>功能方面：堆是用来存放对象的，栈是用来执行程序的</strong>。<br>**共享性：**堆是线程共享的，<strong>栈是线程私有</strong>的。<br>**空间大小：**堆大小远远大于栈。</p><h2 id="队列和栈是什么？有什么区别？">队列和栈是什么？有什么区别？</h2><p>队列和栈都是被用来预存储数据的。<br><strong>队列</strong>允许<strong>先进先出检索元素</strong>，但也有例外的情况，Deque 接口<strong>允许从两端检索元素</strong>。<br><strong>栈</strong>和队列很相似，但它运行对元素进行<strong>后进先出进行检索</strong>。</p><h2 id="Java-中都有哪些引用类型？">Java 中都有哪些引用类型？</h2><p>**强引用：**发生 <em><code>gc</code> 的时候不会被回收</em>。<br><strong>软引用：<strong>有用但不是必须的对象，在发生</strong>内存溢出之前被回收</strong>。<br><strong>弱引用：<strong>有用但不是必须的对象，在</strong>下一次GC时被回收</strong>。<br>**虚引用(幽灵引用/幻影引用)：**无法通过虚引用获得对象，用 <code>PhantomReference</code> 实现虚引用，虚引用的用途是在 <strong>gc 时返回一个通知</strong>。</p><h2 id="JVM-调优的工具？">JVM 调优的工具？</h2><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 <code>jconsole</code> 和 <code>jvisualvm</code> 这两款视图监控工具。<br><strong><code>jconsole</code>：<strong>对 JVM 中的</strong>内存、线程和类等进行监控</strong>；<br>**<code>jvisualvm</code>：**JDK 自带的全能分析工具，可以分析：<strong>内存快照、线程快照、程序死锁、监控内存的变化、gc 变化</strong>等。</p><h2 id="常用的-JVM-调优的参数都有哪些？">常用的 JVM 调优的参数都有哪些？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g：初始化推大小为 2g；</span><br><span class="line">-Xmx2g：堆最大内存为 2g；</span><br><span class="line">-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</span><br><span class="line">-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</span><br><span class="line">–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+PrintGC：开启打印 gc 信息；</span><br><span class="line">-XX:+PrintGCDetails：打印 gc 详细信息。</span><br></pre></td></tr></table></figure><h2 id="内存溢出的情况？">内存溢出的情况？</h2><ul><li><strong><code>JVM Heap</code>（堆）溢出：</strong><code>java.lang.OutOfMemoryError: Java heap space</code><ul><li>JVM在启动的时候会自动设置 JVM Heap 的值， 可以利用JVM提供的<code>-Xmn -Xms -Xmx</code>等选项可进行设置。</li><li>Heap的大小是<code>Young Generation</code> 和<code>Tenured Generaion</code> 之和。</li><li>在JVM中如果98%的时间是用于GC，且可用的<code>Heap size</code> <strong>不足2%时</strong>将抛出此异常信息。</li></ul></li><li>**解决方法：**手动设置JVM Heap（堆）的大小。</li><li><strong><code>Permanent Generation space</code>（内存的永久保存区域）溢出：</strong> <code>java.lang.OutOfMemoryError: PermGen space</code><ul><li>这块内存主要是被 JVM 存放 Class 和 Meta 信息的，Class在被Load的时候被放入 PermGen space 区域，它和存放 Instance 的Heap区域不同，sun 的 GC 不会在主程序运行期对<code>PermGen space</code>进行清理，所以如果你的 APP 会载入很多 CLASS 的话，就很可能出现 PermGen space 溢出。<strong>一般发生在程序的启动阶段</strong>。</li></ul></li><li><strong>解决方法</strong>： 通过<code>-XX:PermSize</code>和<code>-XX:MaxPermSize</code>设置永久代大小。</li><li><strong>栈溢出：</strong> <code>java.lang.StackOverflowError : Thread Stack space</code><ul><li>栈溢出了，JVM是采用栈式的虚拟机，这个和C和Pascal一样。<em>函数的调用过程都体现在堆栈和退栈上了。调用构造函数的 “层”太多以致于把栈区溢出了</em>。 一般栈区远远小于堆区，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K的空间（这大约相当于在一个C函数内声明了256个int变量），那么栈区也不过是需要1MB的空间。</li><li><strong>通常栈的大小是1-2MB</strong>。通俗点讲就是单线程的程序所需内存太大了。 通常<strong>递归也不要递归的层次过多</strong>，很容易溢出。</li></ul></li><li><strong>解决方法：</strong><ul><li><strong>修改程序</strong>。</li><li>通过 <strong><code>-Xss: </code>来设置每个线程的Stack大小</strong>。</li></ul></li></ul><hr><h1>类加载</h1><h2 id="类加载器？">类加载器？</h2><p><strong>类加载器：</strong><br>对于任意一个类，都需要<strong>由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性</strong>，每一个类加载器都有一个独立的类名称空间。类加载器根据指定<strong>全限定名称</strong>将 class 文件加载到 JVM 内存，然后再转化为 class 对象。<br><strong>类加载器分类：</strong></p><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）：是虚拟机自身的一部分，用来<strong>加载<code>Java_HOME/lib/目录</code>中的，或者被<code> -Xbootclasspath</code> 参数所指定的路径中并且被虚拟机识别的类库</strong>；</li><li>扩展类加载器（<code>Extension ClassLoader</code>）：负责加载<code>&lt;java_home style=”box-sizing: border-box; outline: 0px !important;”&gt;libext目录</code>或<code>Java. ext.dirs</code><strong>系统变量指定的路径中的所有类库</strong>；</li><li>应用程序类加载器（<code>Application ClassLoader</code>）：负责<strong>加载用户类路径（<code>classpath</code>）上的指定类库</strong>，我们可以直接使用这个类加载器。一般情况，如果没有自定义类加载器默认就是用这个加载器。</li></ul><p><strong>双亲委派模型：</strong><br>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是<strong>先把这个请求委派给父类加载器去完成</strong>，每一层的类加载器都是如此，这样所有的<strong>加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求</strong>（它的搜索范围中没找到所需的类）时，<strong>子加载器才会尝试去加载类</strong>。</p><h2 id="类装载的执行过程？">类装载的执行过程？</h2><p>类装载分为以下 5 个步骤：</p><ul><li><strong>加载：<strong>根据查找路径</strong>找到相应的 class 文件然后导入</strong>；</li><li><strong>检查：<strong>检查加载的 class 文件的</strong>正确性</strong>；</li><li><strong>准备：<strong>给类中的</strong>静态变量分配内存空间</strong>；</li><li><strong>解析：<strong>虚拟机将</strong>常量池中的符号引用替换成直接引用</strong>的过程。<ul><li>符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li></ul></li><li><strong>初始化：<strong>对</strong>静态变量和静态代码块执行初始化工作</strong>。</li></ul><hr><h1>垃圾回收</h1><h2 id="怎么判断对象是否可以被回收？">怎么判断对象是否可以被回收？</h2><p>一般有两种方法来判断：<br><strong>引用计数器：<strong>为每个对象创建一个引用计数，<strong>有对象引用时计数器 +1</strong>，引用被释放时计数 -1，当</strong>计数器为 0 时</strong>就可被回收。它有一个缺点不能解决循环引用问题；<br><strong>可达性分析：<strong>从 <code>GC Roots</code> 开始向下搜索，<strong>搜索所走过的路径</strong>称为<code>引用链</code>。当一个</strong>对象到 GC Roots 没有任何引用链相连时</strong>，则证明此对象是可以被回收的。</p><h2 id="JVM-有哪些垃圾回收算法？">JVM 有哪些垃圾回收算法？</h2><p><strong>标记-清除算法：<strong>标记无用对象，然后进行清除回收。<strong>缺点：<strong>效率不高，<strong>无法清除垃圾碎片</strong>。<br><strong>标记-整理算法：<strong>标记无用对象，让所有</strong>存活的对象都向一端移动</strong>，然后直接</strong>清除端边界以外的内存</strong>。<br><strong>复制算法：<strong>按照容量划分两个大小相等的内存区域，当一块用完的时候</strong>将活着的对象复制到另一块</strong>上，然后再把</strong>已使用的内存空间一次清理掉</strong>。*缺点：*内存使用率不高，只有原来的一半。<br><strong>分代算法：<strong>根</strong>据对象存活周期的不同将内存划分为几块</strong>，一般是新生代和老年代，<strong>新生代基本采用复制算法，老年代采用标记整理算法</strong>。</p><h2 id="JVM-有哪些垃圾回收器？">JVM 有哪些垃圾回收器？</h2><p><code>Serial</code>：最早的<strong>单线程串行</strong>垃圾回收器。<br><code>Serial Old</code>：Serial 垃圾回收器的老年版本，同样也是<strong>单线程</strong>的，可以作为 CMS 垃圾回收器的备选预案。<br><code>ParNew</code>：是 Serial 的<strong>多线程</strong>版本。<br><code>Parallel</code> ： <strong>多线程</strong>的， 使用<strong>复制的内存回收算法</strong>。但 Parallel 是<strong>吞吐量优先</strong>的收集器，可以牺牲等待时间换取系统的吞吐量。<br><code>Parallel Old</code>：是 Parallel 老生代版本，Parallel Old 使用<strong>标记-整理的内存回收算法</strong>。<br><code>CMS</code>：一种<strong>以获得最短停顿时间为目标</strong>的收集器，非常适用 B/S 系统。<br><code>G1</code>：一种<strong>兼顾吞吐量和停顿时间</strong>的 GC 实现，是 <strong>JDK 9 以后的默认 GC 选项</strong>。</p><h2 id="CMS-垃圾回收器？">CMS 垃圾回收器？</h2><p>CMS 是英文 <code>Concurrent Mark-Sweep</code> 的简称，是<strong>以牺牲吞吐量为代价来获得最短回收停顿时间</strong>的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上<code>“-XX:+UseConcMarkSweepGC”</code>来指定使用 CMS 垃圾回收器。<br>CMS 使用的是<strong>标记-清除的算法</strong>实现的，所以在 gc 的时候<strong>会产生大量的内存碎片</strong>，当剩余内存不能满足程序运行要求时，系统将会出现 <code>Concurrent Mode Failure</code>，<strong>临时 CMS 会采用 Serial Old 回收器进行垃圾清除</strong>，此时的性能将会被降低。</p><h2 id="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？">新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h2><p><strong>新生代回收器：</strong><code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code><br><strong>老年代回收器：</strong><code>Serial Old</code>、<code>Parallel Old</code>、<code>CMS</code><br><strong>整堆回收器：<strong>G1<br>新生代垃圾回收器一般采用的是</strong>复制</strong>算法，复制算法的优点是<strong>效率高</strong>，缺点是<strong>内存利用率低</strong>；<br>老年代回收器一般采用的是<strong>标记-整理</strong>的算法进行垃圾回收。</p><h2 id="分代垃圾回收器是怎么工作的？">分代垃圾回收器是怎么工作的？</h2><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。<br>新生代使用的是复制算法，新生代里有 3 个分区：<code>Eden</code>、<code>To Survivor</code>、<code>From Survivor</code>，它们的<strong>默认占比是 8:1:1</strong>。<br><strong>它的执行流程如下：</strong></p><ul><li>把 <code>Eden + From Survivor</code> 存活的对象放入 <code>To Survivor</code> 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor <strong>分区交换</strong>（From Survivor 变 To Survivor，To Survivor 变 From Survivor）</li><li>每次在 From Survivor 到 To Survivor <strong>移动时</strong>都存活的对象，<strong>年龄 +1</strong>，当<strong>年龄到达 15（默认配置是 15）时，升级为老生代</strong>。大对象也会直接进入老生代。</li><li>老生代空间占用到达某个值后就<strong>触发全局垃圾收回</strong>，一般使用<strong>标记整理</strong>执行算法。</li></ul><p>以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>]]></content>
    
    
    <summary type="html">本文简单记录一些关于JVM的问题。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
