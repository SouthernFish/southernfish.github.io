<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Southern Fish</title>
  
  
  <link href="https://southernfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://southernfish.github.io/"/>
  <updated>2025-06-18T12:55:27.767Z</updated>
  <id>https://southernfish.github.io/</id>
  
  <author>
    <name>Southern Fish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA 基础</title>
    <link href="https://southernfish.github.io/2025/06/18/java-base/"/>
    <id>https://southernfish.github.io/2025/06/18/java-base/</id>
    <published>2025-06-18T10:28:36.000Z</published>
    <updated>2025-06-18T12:55:27.767Z</updated>
    
    <content type="html"><![CDATA[<p>关于 java 的一些简单问题</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="JVM-、JDK-和-JRE-有什么区别"><a href="#JVM-、JDK-和-JRE-有什么区别" class="headerlink" title="JVM 、JDK 和 JRE 有什么区别"></a>JVM 、JDK 和 JRE 有什么区别</h2><ul><li><strong>JVM ：</strong><code>(Java Virtual Machine)，Java虚拟机</code>。只认<code>xxx.class</code>文件，能识别<code>class</code> 文件中的字节码指令并调用操作系统向上的 API 完成动作。<code>jvm</code> 是 <code>Java</code> 能够跨平台的核心。</li><li><strong>JRE：</strong><code>(Java Runtime Environment)，Java 运行环境</code>。为 Java 的运行提供了所需环境。主要包含 jvm 的标准实现和 Java 的一些基本类库，相对于 jvm 来说，多出来的是一部分的 Java 类库。</li><li><strong>JDK：</strong><code>(Java Development Kit)，Java 开发工具包</code>。提供了 Java 的开发环境和运行环境。jdk 是整个 Java 开发的核心，集成了 jre 和一些好用 Java 程序调试和分析的小工具。如：<code>javac.exe</code>，<code>java.exe</code>，<code>jar.exe</code> 等</li></ul><h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals 的区别"></a>== 和 equals 的区别</h2><ul><li><p><strong>== 解读</strong>：</p><p><em>基本类型：</em>比较的是值是否相同；                          <em>引用类型：</em>比较的是引用是否相同； </p><p>若指向同一个引用，== 为 true，而 new String() 方法重新开辟了内存空间， == 结果为 false，而 equals 比较的是值，结果为 true</p></li><li><p><strong>equals 解读</strong>：equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较</p></li><li><p><strong>总结</strong>： == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，String、Integer 等类重写了equals，把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p></li></ul><h2 id="两个对象的-hashCode-相同，则-equals-也一定为-true，对吗"><a href="#两个对象的-hashCode-相同，则-equals-也一定为-true，对吗" class="headerlink" title="两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗"></a>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗</h2><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。代码解读：显然“通话”和“重地”的 hashCode() 相同，然而 equals()为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = “通话”;</span><br><span class="line">String str2 = &quot;重地”;</span><br><span class="line">System. out.printIn(string. format(&quot;str1:%d|str2:%d&quot;, str1. hashcode(),str2. hashcode()));</span><br><span class="line">System. out.println(str1. equals(str2));</span><br><span class="line"></span><br><span class="line"># 打印结果</span><br><span class="line">str1:1179395 | str2:1179395</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h2 id="Java-中的-Math-round-1-5-等于多少"><a href="#Java-中的-Math-round-1-5-等于多少" class="headerlink" title="Java 中的 Math. round(-1. 5) 等于多少"></a>Java 中的 Math. round(-1. 5) 等于多少</h2><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p><h2 id="final-在-Java-中有什么作用"><a href="#final-在-Java-中有什么作用" class="headerlink" title="final 在 Java 中有什么作用"></a>final 在 Java 中有什么作用</h2><ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><h2 id="基础的数据类型"><a href="#基础的数据类型" class="headerlink" title="基础的数据类型"></a>基础的数据类型</h2><p>基础类型有 8 种：<code>byte</code>、<code>boolean</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code></p><p> <code>String</code> 不属于基础类型， <code>String</code> 属于对象</p><h2 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Files. exists()：检测文件路径是否存在。</span><br><span class="line">Files. createFile()：创建文件。</span><br><span class="line">Files. createDirectory()：创建文件夹。</span><br><span class="line">Files. delete()：删除一个文件或目录。</span><br><span class="line">Files. copy()：复制文件。</span><br><span class="line">Files. move()：移动文件。</span><br><span class="line">Files. size()：查看文件个数。</span><br><span class="line">Files. read()：读取文件。</span><br><span class="line">Files. write()：写入文件。</span><br></pre></td></tr></table></figure><h1 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h1><h2 id="Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>Java 中操作字符串都有哪些类？它们之间有什么区别？</h2><p>操作字符串的类有：<code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code>。</p><p><code>String</code> 和 <code>StringBuffer</code>、<code>StringBuilder</code> 的区别在于 <strong><code>String</code> 声明的是不可变的对象，每次操作都会生成新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象</strong>，而 <code>StringBuffer</code>、<code>StringBuilder</code> 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 <code>String</code>。</p><p><code>StringBuffer</code> 和 <code>StringBuilder</code> 最大的区别在于，**<code>StringBuffer</code> 线程安全，而 <code>StringBuilder</code> 非线程安全**，但 <code>StringBuilder</code> 性能高于 <code>StringBuffer</code>，所以在单线程环境下推荐使用 <code>StringBuilder</code>，多线程环境下推荐使用 <code>StringBuffer</code>。</p><h2 id="String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="String str=”i”与 String str=new String(“i”)一样吗？"></a>String str=”i”与 String str=new String(“i”)一样吗？</h2><p>不一样，因为内存的分配方式不一样。</p><p>String str = ”i” 的方式，Java 虚拟机会将其分配到常量池中；</p><p>String str = new String(“i”) 则会被分到堆内存中。</p><h2 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="如何将字符串反转？"></a>如何将字符串反转？</h2><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// stringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer = new stringBuffer();</span><br><span class="line">stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuffer. reverse()); // gfedcba</span><br><span class="line">// stringBuilder reverse</span><br><span class="line">stringBuilder stringBuilder =new stringBuilder();</span><br><span class="line">stringBuilder. append(&quot;abcdefg&quot;);System. out. println(stringBuilder. reverse()); // gfedcba</span><br></pre></td></tr></table></figure><h2 id="String-类的常用方法"><a href="#String-类的常用方法" class="headerlink" title="String 类的常用方法"></a>String 类的常用方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">indexOf()：返回指定字符的索引。</span><br><span class="line">charAt()：返回指定索引处的字符。</span><br><span class="line">replace()：字符串替换。</span><br><span class="line">trim()：去除字符串两端空白。</span><br><span class="line">split()：分割字符串，返回一个分割后的字符串数组。</span><br><span class="line">getBytes()：返回字符串的 byte 类型数组。</span><br><span class="line">length()：返回字符串长度。</span><br><span class="line">toLowerCase()：将字符串转成小写字母。</span><br><span class="line">toUpperCase()：将字符串转成大写字符。</span><br><span class="line">substring()：截取字符串。</span><br><span class="line">equals()：字符串比较。</span><br></pre></td></tr></table></figure><h1 id="抽象类问题"><a href="#抽象类问题" class="headerlink" title="抽象类问题"></a>抽象类问题</h1><h2 id="抽象类必须要有抽象方法吗"><a href="#抽象类必须要有抽象方法吗" class="headerlink" title="抽象类必须要有抽象方法吗?"></a>抽象类必须要有抽象方法吗?</h2><p>不需要，抽象类不一定非要有抽象方法。</p><h2 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h2><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。抽象类不能直接实例化，普通类可以直接实例化。</p><h2 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h2><p>不能，定义抽象类就是让其他类继承的，定义为 final的类不能被继承，所以 final 不能修饰抽象类，编辑器也会提示错误信息：illegal combination of modifiers: ‘abstract’ and ‘final</p><h2 id="接口和抽象类有什么区别？"><a href="#接口和抽象类有什么区别？" class="headerlink" title="接口和抽象类有什么区别？"></a>接口和抽象类有什么区别？</h2><ul><li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li></ul><h1 id="Java中的IO"><a href="#Java中的IO" class="headerlink" title="Java中的IO"></a>Java中的IO</h1><h2 id="Java-中-IO-流分为几种？"><a href="#Java-中-IO-流分为几种？" class="headerlink" title="Java 中 IO 流分为几种？"></a>Java 中 IO 流分为几种？</h2><ul><li><strong>按功能来分：</strong>输入流（input）、输出流（output）。</li><li><strong>按类型来分：</strong>字节流和字符流。字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</li></ul><h2 id="BIO、NIO、AIO-有什么区别？"><a href="#BIO、NIO、AIO-有什么区别？" class="headerlink" title="BIO、NIO、AIO 有什么区别？"></a>BIO、NIO、AIO 有什么区别？</h2><ul><li>BIO：Block IO，同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：Non IO，同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO，是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="Lambda表达式的语法"><a href="#Lambda表达式的语法" class="headerlink" title="Lambda表达式的语法"></a>Lambda表达式的语法</h2><p><strong>基本语法：</strong> (parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }</p><p><strong>Lambda表达式由三部分组成：</strong></p><ul><li><strong>paramaters：</strong>类似方法中的形参列表，这里的参数是函数式接口里的参数。这里的参数类型可以明确的声明也可不声明而由JVM隐含的推断。另外当只有一个推断类型时可以省略掉圆括号。</li><li><strong>-&gt;：</strong>可理解为“被用于”的意思</li><li><strong>方法体：</strong>可以是表达式也可以代码块，是函数式接口里方法的实现。代码块可返回一个值或者什么都不反回，这里的代码块块等同于方法的方法体。如果是表达式，也可以返回一个值或者什么都不反回。</li></ul><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong>代码简洁，开发迅速、方便函数式编程、容易进行并行计算、Java 引入 Lambda，改善了集合操作</li><li><strong>缺点：</strong>代码可读性变差、在非并行计算中，很多计算未必有传统的 for 性能要高、不易调试</li></ul><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(s -&gt; s.length() &gt; 3).forEach(System.out::println);</span><br><span class="line">list.stream().map(StuffEntity::getCode).collect(Collectors.toList());</span><br><span class="line">list.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(</span><br><span class="line">                () -&gt; new TreeSet&lt;&gt;(Comparator.comparing(obj -&gt; obj.getDealerPlan() ))), ArrayList::new));</span><br><span class="line">Map&lt;String, List&lt;VpEntity&gt;&gt; map = stuffVp.stream().collect(Collectors.groupingBy(obj -&gt; obj.getDealerPlan() ));</span><br></pre></td></tr></table></figure><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="Java-中面向对象编程的三大特性"><a href="#Java-中面向对象编程的三大特性" class="headerlink" title="Java 中面向对象编程的三大特性"></a>Java 中面向对象编程的三大特性</h2><p><strong>封装、继承、多态。</strong>分别实现了<strong>数据的隐藏与保护、代码的复用扩展以及行为的灵活适配</strong>。‌</p><p><strong>封装</strong>是对数据和行为进行集中管理的过程‌，其核心在于隐藏内部实现细节，仅通过接口与外界交互。主要作用包括：‌</p><ul><li><em>数据保护‌：</em>通过访问权限控制，如 private、protected 限制外部直接修改属性；‌‌‌‌‌</li><li><em>接口标准化‌：</em>提供统一的方法调用入口，如 getter、setter 控制属性访问；‌‌‌</li><li><em>模块化设计‌：</em>将同一类功能封装到同一对象中。</li></ul><p><strong>继承</strong>通过父子类关系实现代码复用和扩展‌，其特点包括：‌</p><ul><li><em>子类复用父类功能‌：</em>子类可直接使用父类的公共属性和方法；‌‌‌‌‌</li><li><em>层级扩展能力‌：</em>子类可新增特性或重写父类方法，如子类用 extends 继承父类并添加特有属性；‌‌‌</li><li><em>访问规则约束‌：</em>父类私有成员（private）不可被子类继承，保证封装性。‌‌‌</li></ul><p><strong>多态</strong>通过统一的接口实现不同类型的差异化行为‌，具体表现为：‌</p><ul><li><em>动态绑定‌：</em>父类引用指向子类对象；‌‌‌</li><li><em>方法重写与重载‌：</em>子类覆写父类方法（重写）或同一类中同名不同参方法（重载）；‌‌‌‌‌</li><li><em>灵活性增强‌：</em>同一方法在不同子类中表现不同。‌</li></ul><h2 id="什么是泛型？为什么要使用泛型？"><a href="#什么是泛型？为什么要使用泛型？" class="headerlink" title="什么是泛型？为什么要使用泛型？"></a>什么是泛型？为什么要使用泛型？</h2><p>泛型，即<strong>“参数化类型”</strong>。泛型的出现是为了<em>统一集合当中的数据类型</em>。可<em>在编译阶段约束操作的数据类型，并进行检查</em><br><strong>参数化类型：</strong>在方法定义时，<em>将方法签名中的形参数据类型设置为参数</em>（可称之为类型参数：尖括号 &lt;&gt; 中的泛型标识，用于指代任何数据类型），调用该方法时再从外部传入一个具体的数据类型和变量。<br><strong>泛型的本质：</strong><em>将类型参数化</em>。泛型使用过程中，数据类型被设置为一个参数，<strong>使用时从外部传入一个数据类型</strong>；而一旦传入了具体的数据类型后，<strong>传入变量（实参）的数据类型若不匹配，编译器就会直接报错</strong>。这种参数化类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p><strong>细节：</strong>不能写基本数据类型；指定泛型具体类型后，传递数据时可传该类型和其子类类型；若不写泛型，默认是Object<br><strong>泛型标识：</strong>是任意设置的，Java 常见泛型标识及其代表含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T ：代表一般的任何类。</span><br><span class="line">E ：代表 Element 元素的意思，或者 Exception 异常的意思。</span><br><span class="line">K ：代表 Key 的意思。</span><br><span class="line">V ：代表 Value 的意思，通常与 K 一起配合使用。</span><br><span class="line">S ：代表 Subtype 的意思。</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong>定义类、方法、接口的时候，若类型不确定，可定义泛型；<em>若类型不确定，但知道继承体系，可用泛型通配符 ？</em><br><strong>泛型不具备继承性，但是数据具备继承性</strong></p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="Java-容器都有哪些？"><a href="#Java-容器都有哪些？" class="headerlink" title="Java 容器都有哪些？"></a>Java 容器都有哪些？</h2><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collection</span><br><span class="line">    List</span><br><span class="line">        ArrayList</span><br><span class="line">        LinkedList</span><br><span class="line">        Vector</span><br><span class="line">        Stack</span><br><span class="line">    Set</span><br><span class="line">        HashSet</span><br><span class="line">        LinkedHashSet</span><br><span class="line">        TreeSet</span><br><span class="line">Map</span><br><span class="line">    HashMap </span><br><span class="line">        LinkedHashMap</span><br><span class="line">    TreeMap</span><br><span class="line">    ConcurrentHashMap</span><br><span class="line">    Hashtable</span><br></pre></td></tr></table></figure><h2 id="Collection-和-Collections-有什么区别"><a href="#Collection-和-Collections-有什么区别" class="headerlink" title="Collection 和 Collections 有什么区别"></a>Collection 和 Collections 有什么区别</h2><p>Collection 是一个<strong>集合接口，它提供了对集合对象进行基本操作的通用接口方法</strong>，所有集合都是它的子类，比如 List、Set 等。Collections 是一个<strong>包装类，包含了很多静态方法，不能被实例化，就像一个工具类</strong>，比如提供的排序方法：Collections. sort(list)。</p><h2 id="List、Set、Map-之间的区别是什么？"><a href="#List、Set、Map-之间的区别是什么？" class="headerlink" title="List、Set、Map 之间的区别是什么？"></a>List、Set、Map 之间的区别是什么？</h2><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。三者之间的区别，如下表：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/20250618204117.png"></p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="HashMap-和-Hashtable-有什么区别？"><a href="#HashMap-和-Hashtable-有什么区别？" class="headerlink" title="HashMap 和 Hashtable 有什么区别？"></a>HashMap 和 Hashtable 有什么区别？</h2><ul><li>存储：HashMap 允许 key 和 value 为 null，而 Hashtable 不允许。</li><li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，    如果需要多线程使用则用 ConcurrentHashMap 替代。</li></ul><h2 id="HashMap-的实现原理？"><a href="#HashMap-的实现原理？" class="headerlink" title="HashMap 的实现原理？"></a>HashMap 的实现原理？</h2><p>HashMap 基于 <strong>Hash 算法</strong>实现的，我们通过 <strong>put(key,value)存储，get(key)来获取</strong>。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当<strong>计算出的 hash 值相同时，我们称为 hash 冲突</strong>，HashMap 的做法是<strong>用链表和红黑树存储相同 hash 值的 value</strong>。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p><h2 id="HashMap为什么线程不安全？"><a href="#HashMap为什么线程不安全？" class="headerlink" title="HashMap为什么线程不安全？"></a>HashMap为什么线程不安全？</h2><p>主要原因在于其<strong>内部结构的非原子性操作和缺乏同步机制</strong>，导致<strong>多线程并发操作时可能引发数据不一致、死循环、数据覆盖</strong>等问题‌。</p><h2 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h2><p>对于在 Map 中<strong>插入、删除、定位</strong>一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但是如果你要对一个 key 集合进行<strong>有序的遍历</strong>，那 TreeMap 是更好的选择。</p><h2 id="HashSet-的实现原理？"><a href="#HashSet-的实现原理？" class="headerlink" title="HashSet 的实现原理？"></a>HashSet 的实现原理？</h2><p>HashSet 是基于 HashMap 实现的，HashSet 不允许重复的值。<br>HashSet 保证元素不重复是利用 HashMap 的 put 方法实现的，在<strong>存储之前先根据 key 的 hashCode 和 equals 判断是否已存在，如果存在就不在重复插入了</strong>，这样就保证了元素的不重复。</p><h2 id="HashMap-和-ConcurrentHashMap-有什么区别？"><a href="#HashMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 有什么区别？"></a>HashMap 和 ConcurrentHashMap 有什么区别？</h2><p>ConcurrentHashMap的线程安全实现</p><ul><li>Java7：分段锁(Segment)。将数据分成多个段，每段独立加锁，不同段的操作可并发。</li><li>Java 8+：CAS(无锁算法)+ synchronized(锁单个桶的头节点)。锁粒度更细，并发度更高。插入时，如果桶为空，用 CAS 添加;否则锁住头节点再操作。CAS（Compare And Swap(比较与交换)）。读操作通常无锁(依赖 volatile 保证可见性)。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/20250618205242.png"></p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h2><ul><li><strong>数据结构实现：</strong>ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li><strong>随机访问效率：</strong>ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li><strong>增加和删除效率：</strong>在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li></ul><h2 id="如何实现数组和-List-之间的转换？"><a href="#如何实现数组和-List-之间的转换？" class="headerlink" title="如何实现数组和 List 之间的转换？"></a>如何实现数组和 List 之间的转换？</h2><ul><li>数组转 List：使用 Arrays. asList(array) 进行转换。</li><li>List 转数组：使用 List 自带的 toArray() 方法。</li></ul><h2 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h2><ul><li><strong>线程安全：</strong>Vector 使用了 <code>Synchronized</code> 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li><strong>性能：</strong>ArrayList 在性能方面要优于 Vector。</li><li><strong>扩容：</strong>ArrayList 和 Vector 都会根据实际需要动态调整容量，不过 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul><h2 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h2><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 <code>addAll、removeAll、iteration</code> 等方法只有 ArrayList 有。</p><h1 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h1><h2 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h2><p><strong>Iterator 接口提供遍历任何 Collection 的接口</strong>。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，<strong>迭代器允许调用者在迭代过程中移除元素</strong>。</p><h2 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h2><p>Iterator 使用代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;string&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;string&gt;it = list.iterator();</span><br><span class="line">while(it.hasNext()*)&#123;</span><br><span class="line">    String obj = it.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改时，就会抛出 ConcurrentModificationException 异常。</p><h2 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h2><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。<br>ListIterator 从 Iterator 接口继承，添加了一些额外功能，如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p><h1 id="其他相关问题"><a href="#其他相关问题" class="headerlink" title="其他相关问题"></a>其他相关问题</h1><h2 id="在-Queue-中-poll-和-remove-有什么区别？"><a href="#在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="在 Queue 中 poll()和 remove()有什么区别？"></a>在 Queue 中 poll()和 remove()有什么区别？</h2><p><strong>相同点：</strong>都是返回第一个元素，并在队列中删除返回的对象。<br><strong>不同点：</strong>如果没有元素 poll() 会返回 null，而 remove()会直接抛出 <code>NoSuchElementException</code> 异常。</p><h2 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h2><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p><h2 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h2><p>使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。<br>示例代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;string&gt; list = new ArrayList&lt;&gt;();list. add(&quot;x”);</span><br><span class="line">Collection&lt;string&gt;clist = collections.unmodifiablecollection(list),clist. add(&quot;y”);// 运行时此行报错</span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于 java 的一些简单问题&lt;/p&gt;
&lt;h1 id=&quot;常见问题&quot;&gt;&lt;a href=&quot;#常见问题&quot; class=&quot;headerlink&quot; title=&quot;常见问题&quot;&gt;&lt;/a&gt;常见问题&lt;/h1&gt;&lt;h2 id=&quot;JVM-、JDK-和-JRE-有什么区别&quot;&gt;&lt;a href=&quot;#JV</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://southernfish.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个人博客搭建</title>
    <link href="https://southernfish.github.io/2025/06/18/hexo-blog-build/"/>
    <id>https://southernfish.github.io/2025/06/18/hexo-blog-build/</id>
    <published>2025-06-18T06:47:36.000Z</published>
    <updated>2025-06-18T12:55:27.767Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 是一个简单、轻量、基于Node的静态博客<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020">框架</a>，可以方便的生成静态网页托管于GitHub和Heroku。本文以 Hexo + GitHub Pages + Typora + PicGo 为例。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p><strong>1、<a href="https://nodejs.org/en/download/">下载node</a>并安装。</strong>安装好node，会默认一起安装好 npm 包管理器，可通过（Ctrl+R）打开 cmd 终端，使用以下命令查看安装版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v </span><br><span class="line">npm -version</span><br></pre></td></tr></table></figure><p><strong>2、安装 git，配置个人信息。</strong>官网下载，选择自己操作系统的版本，根据提示一直 next 就装好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;xxxxxx@qq.com&quot;</span><br></pre></td></tr></table></figure><p><strong>生成密钥。</strong>一般是在 <strong>~/.ssh</strong> 路径下，其中 id_rsa 存储私钥（<strong>不要共享私钥</strong>），id_rsa.pub 存储公钥。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxxxxx@qq.com&quot;</span><br></pre></td></tr></table></figure><p>GitHub公钥配置步骤：登录 GitHub → Settings → SSH and GPG keys → New SSH key → 填写相关信息(如下) →  Add SSH key<br>填写信息如下：</p><p><strong>Title：</strong>标识密钥用途Key；</p><p><strong>type：</strong>保持默认 Authentication Key；</p><p><strong>Key：</strong>公钥内容</p><p><strong>3、测试 SSH 连接，</strong>出现如下则配置成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">Hi username! You&#x27;ve successfully authenticated...</span><br></pre></td></tr></table></figure><p>配置完 SSH 后，之后使用远程仓库的方式更新为 SSH 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:username/repo.git</span><br><span class="line">git remote -v</span><br><span class="line"># 显示 ssh 地址（git@github.com:...）则生效</span><br></pre></td></tr></table></figure><p>克隆新仓库地址也使用 SSH。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 克隆新仓库</span><br><span class="line">git clone git@github.com:username/repo.git</span><br></pre></td></tr></table></figure><p><strong>4、安装 hexo 及相关依赖 。</strong>在 git 终端执行安装 hexo 相关命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo --save</span><br><span class="line">npm install hexo-deployer-git --save # 用于部署发布</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h1 id="Hexo项目构建"><a href="#Hexo项目构建" class="headerlink" title="Hexo项目构建"></a>Hexo项目构建</h1><p><strong>1、开始搭建Hexo项目。</strong>自定义一个文件夹（我的路径是：<code>E://WorkSpace/fishblog</code>），在命令行窗口进入目录，或直接从本机进入文件夹，右键打开 Git Bash Here，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">hexo g </span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><code>hexo g </code>是 <code>hexo generate</code> 的简便写法；<code>hexo s</code> 是 <code>hexo server</code> 的简便写法。<code>hexo s</code>启动本地服务器，在浏览器打开localhost:4000即可看到效果。关闭本地服务：Ctrl + C 。部署的命令也可以并列的写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s -- 本地</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d -- 远程部署（发布到github）</span><br></pre></td></tr></table></figure><p><strong>2、新建博客文件。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;article title&quot;</span><br></pre></td></tr></table></figure><p>项目中 <code>/source/_posts </code>将会看到<code> article title.md</code> 文件。编辑之后运行生成、部署命令便可发布。我使用 Typora 编辑，后续会讲到 Typora 相关配置。之后也可以直接在该路径下新建md文件，上传到 GitHub，后续会讲到如何自动化部署发布。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g   # 生成</span><br><span class="line">hexo d   # 部署</span><br><span class="line">hexo d -g # 在部署前先生成</span><br></pre></td></tr></table></figure><p><strong>3、个性化设置。</strong>主题替换、卡通人物、数字统计等。渲染md文件还需执行如下命令安装依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-renderer-markdown-it --save # 需要安装这个渲染插件</span><br></pre></td></tr></table></figure><p>卡通人物。选自己喜欢的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line">npm install live2d-widget-model-haruto</span><br></pre></td></tr></table></figure><p>主题替换。挑一个喜欢 blog theme，此处以 <code>butterfly</code> 为例，点进去（多数是贡献者的博客网站）找到当前主题的 GitHub 仓库入口（通常情况在博客的正下方），进入 GitHub 克隆当前仓库，放在 Hexo 所在目录的 themes 文件夹下（原目录下有一个默认的 landscape 主题，新主题目录和它同级）。修改 Hexo 根目录下的 <code>_config.yml</code> 文件，找到 theme 配置项，修改为克隆的主题名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/jerryc127/hexo-theme-butterfly.git</span><br></pre></td></tr></table></figure><p>统计数字、数学公式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save # 统计数字</span><br><span class="line">npm install @neilsustc/markdown-it-katex --save # 渲染数学公式</span><br></pre></td></tr></table></figure><p><strong>4、新建分类、目录、标签 。</strong>修改对应的 md 文件便可自定义属于自己的分类、标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about      # 根目录/source/about/index.md</span><br><span class="line">hexo new page categories # 根目录/source/categories/index.md</span><br><span class="line">hexo new page tags       # 根目录/source/tags/index.md</span><br></pre></td></tr></table></figure><p>编辑md文件时，注意多个分类写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分级c2是c1的子类</span><br><span class="line">categories:</span><br><span class="line">- c1</span><br><span class="line">- c2</span><br><span class="line">同级多类</span><br><span class="line">categories:</span><br><span class="line">- [c1]</span><br><span class="line">- [c2]</span><br></pre></td></tr></table></figure><p>相应的配置 <code>_config.yml</code> 文件设置。其他更多配置可参考<a href="https://segmentfault.com/a/1190000042212798?utm_source=sf-similar-article">文章</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 右下角的卡通人物</span><br><span class="line">## https://github.com/xiazeyu/live2d-widget-models/tree/master/packages</span><br><span class="line">lived2:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptForm: local</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-haruto # model name select</span><br><span class="line">  display: # model position size</span><br><span class="line">    position: left</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br><span class="line"></span><br><span class="line"># 主题配置，更换主题需要将主题放在landscape同级文件夹下，名字就是文件夹名   </span><br><span class="line">theme: butterfly </span><br><span class="line"></span><br><span class="line"># 数学 katex</span><br><span class="line">markdown:</span><br><span class="line">  plugins:</span><br><span class="line">    - plugin:</span><br><span class="line">      name: &#x27;@neilsustc/markdown-it-katex&#x27;</span><br><span class="line">      options:</span><br><span class="line">        strict: false</span><br></pre></td></tr></table></figure><h1 id="将Hexo与GitHub-Page-关联起来"><a href="#将Hexo与GitHub-Page-关联起来" class="headerlink" title="将Hexo与GitHub Page 关联起来"></a>将Hexo与GitHub Page 关联起来</h1><p>此处使用私有库 fishBlog 存储 hexo 项目，也就是你自己新建的项目，公共库 <code>username.github.io</code> 存储编译后的静态文件以便访问。<br><strong>1、上传 hexo 项目，并完成相关配置。</strong>上传之前，需要更新一下 <code>.gitignore</code> 文件。默认情况下 <code>public/</code> 不会被上传(也不该被上传)，确保 <code>.gitignore</code> 文件中包含一行 <code>public/</code>。</p><p>上传完成之后，将该项目设置为<strong>私有</strong>，配置 Repository secrets 。进入该项目 →  Settings → Secrets and variables → Actions → New repository secret 。新建<code> HEXO_DEPLOY_PRI</code>（配置deploy.yml会用到）,  <code>GIT_PASSWORD</code></p><p><strong>2、创建一个公共库 <code>username.github.io</code>。</strong>设置为 public 并初始化，用同样的方法新建<code> HEXO_DEPLOY_PRI</code>。</p><p>开启 pages 功能：进入该公共库 →  Settings → 左侧Pages → Build and deployment → 选择 <code>main</code> 分支， <code>/root</code>  →  save</p><p>站点配置文件_config.yml 中配置 url 和 deploy 配置项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url: https://southernfish.github.io/</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:username/username.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p><strong>3、创建GitHub Actions工作流。</strong>在你的私有库中，创建一个新的目录<code>.github/workflows/</code>，并在其中创建<code>deploy.yml</code>文件。该文件将包含自动部署的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"># Action的名字</span><br><span class="line">name: Deploy Hexo Action Name</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main</span><br><span class="line"></span><br><span class="line">#这里放环境变量,需要替换成自己的</span><br><span class="line">env:</span><br><span class="line">  # Hexo编译后使用此 git用户部署到github仓库</span><br><span class="line">  GIT_USER: username</span><br><span class="line">  # Hexo 编译后使用此 git邮箱部署到github仓库</span><br><span class="line">  GIT_EMAIL: xxxxxx@qq.com</span><br><span class="line">  # Hexo编译后要部署的github仓库</span><br><span class="line">  GIT_DEPLOY_REPO: username/username.github.io</span><br><span class="line">  # Hexo编译后要部署到的分支</span><br><span class="line">  GIT_DEPLOY_BRANCH: main</span><br><span class="line"># 工作流</span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    name: Build on node</span><br><span class="line">    runs-on: ubuntu-latest # 使用 Ubuntu 最新版</span><br><span class="line">    if: github.event.repository.owner.id == github.event.sender.id</span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        os: [ubuntu-latest]</span><br><span class="line">        node_version: [12.x] # 使用 Node.js 12.x 版本</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - name: Checkout code</span><br><span class="line">        uses: actions/checkout@v2 # 检出代码到 runner</span><br><span class="line"></span><br><span class="line">      - name: Checkout deploy repo</span><br><span class="line">        uses: actions/checkout@v2</span><br><span class="line">        with:</span><br><span class="line">          repository: $&#123;&#123; env.GIT_DEPLOY_REPO &#125;&#125;</span><br><span class="line">          ref: $&#123;&#123; env.GIT_DEPLOY_BRANCH &#125;&#125;</span><br><span class="line">          path: .deploy_git</span><br><span class="line"></span><br><span class="line">      - name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125; # 设置 Node.js 环境</span><br><span class="line">        uses: actions/setup-node@v1</span><br><span class="line">        with:</span><br><span class="line">          node-version: $&#123;&#123; matrix.node_version &#125;&#125; # 使用 Node.js 的版本，根据需要调整</span><br><span class="line"></span><br><span class="line">      - name: Configuration environment # 设置密钥、设置Git信息</span><br><span class="line">        env:</span><br><span class="line">          HEXO_DEPLOY_PRI: $&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span><br><span class="line">        run: |</span><br><span class="line">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br><span class="line">          mkdir -p ~/.ssh/</span><br><span class="line">          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span><br><span class="line">          chmod 600 ~/.ssh/id_rsa</span><br><span class="line">          ssh-keyscan -t rsa github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="line">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br><span class="line">          git config --global user.name $GIT_USER</span><br><span class="line">          git config --global user.email $GIT_EMAIL</span><br><span class="line"></span><br><span class="line">      - name: Install dependencies # 安装hexo和其他依赖</span><br><span class="line">        run: |</span><br><span class="line">          npm install hexo-cli -g</span><br><span class="line">          npm install --save</span><br><span class="line"></span><br><span class="line">      - name: Deploy hexo # 包含了clean、generate、deploy</span><br><span class="line">        run: |</span><br><span class="line">          npm run deploy</span><br></pre></td></tr></table></figure><p><strong>4、参考链接</strong></p><ul><li><a href="https://docs.github.com/zh/pages">GitHub Pages</a></li><li><a href="https://docs.github.com/zh/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#publishing-with-a-custom-github-actions-workflow">使用自定义 GitHub Actions 工作流进行发布</a></li><li><a href="https://github.com/marketplace/actions/deploy-github-pages-site">actions/deploy-github-pages-site</a></li></ul><h1 id="PicGo安装"><a href="#PicGo安装" class="headerlink" title="PicGo安装"></a>PicGo安装</h1><p>1、下载安装。直接根据提示安装，路径可自己指定。</p><p>2、PicGo<code>预置的有四种链接格式：</code>Markdown<code>、</code>HTML<code>、</code>URL<code>、</code>UBB`，其得到的上传文件链接分别为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Makdown: ![](https://i.loli.net/2021/09/14/KB3LimF5SGtI6vf.png)</span><br><span class="line">HTML: &lt;img src=&quot;https://i.loli.net/2021/09/14/KB3LimF5SGtI6vf.png&quot;/&gt;</span><br><span class="line">URL: https://i.loli.net/2021/09/14/KB3LimF5SGtI6vf.png</span><br><span class="line">UBB: [IMG]https://i.loli.net/2021/09/14/KB3LimF5SGtI6vf.png[/IMG]</span><br></pre></td></tr></table></figure><p>3、自定义链接格式<code>Custom</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Custom:  &lt;center&gt;&lt;img src=&quot;$url&quot; alt=&quot;$fileName&quot;/&gt;&lt;/center&gt;</span><br></pre></td></tr></table></figure><p>4、PicGo设置中可以配置如日志、代理等设置，一定要注意要打开该自动复制URL的设置<strong>上传后自动复制URL：开</strong></p><p>5、图床设置，此处使用GitHub图床。首先需要在 GitHub 中初始化一个 公共库 ImageHostServer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设定仓库名: username/ImageHostServer</span><br><span class="line">设定分支名: main</span><br><span class="line">设定Token: xxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">指定存储路径: /hexo</span><br><span class="line">设定自定义域名：此处我没用到，便不做设置</span><br></pre></td></tr></table></figure><p>Token 设置方式：Settings → Developer Settings → personal access tokens → Fine-grained → Generate new token → 设置名字为ImageHostServerToken → 找到Repository access → 选择 Only select repositories，并选择库 ImageHostServer → 找到 Repository permissions 的 contens  → 点击右侧下拉按钮设置为 Read and write → Generate token → 复制Token值并保存下来，picGo配置需要</p><h1 id="Typora-安装"><a href="#Typora-安装" class="headerlink" title="Typora 安装"></a>Typora 安装</h1><p>1、安装可参考<a href="https://www.cnblogs.com/fengyanqiblog/p/18928611">Typora安装及破解</a></p><p>2、配置。打开 Typora 的偏好设置，选择图像，把插入图片设置为上传图片；上传服务设置为 PicGo(app) ，PicGo路径设置为PicGo的安装路径（D:\HexoBlog\Typora\Typora.exe），配置完成之后，点击验证上传，提示成功上传图片并获得新的URL则说明成功了。如若不成功检测一下 PicGo设置的server设置端口是否一致，不一致的话需要改成一致。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hexo 是一个简单、轻量、基于Node的静态博客&lt;a href=&quot;https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&amp;spm=1001.2101.3001.7020&quot;&gt;框架&lt;/a&gt;，可以方便的生成静态网页托管于GitHub</summary>
      
    
    
    
    <category term="hexo" scheme="https://southernfish.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://southernfish.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Test-4</title>
    <link href="https://southernfish.github.io/2022/08/13/Test-4/"/>
    <id>https://southernfish.github.io/2022/08/13/Test-4/</id>
    <published>2022-08-13T12:43:11.000Z</published>
    <updated>2025-06-18T12:55:27.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).</summary>
    
    
    
    <category term="分类3" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB3/"/>
    
    
    <category term="tag1" scheme="https://southernfish.github.io/tags/tag1/"/>
    
  </entry>
  
  <entry>
    <title>Test-3</title>
    <link href="https://southernfish.github.io/2022/08/13/Test-3/"/>
    <id>https://southernfish.github.io/2022/08/13/Test-3/</id>
    <published>2022-08-13T08:45:31.000Z</published>
    <updated>2022-08-13T09:09:10.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start-4">Quick Start</h2><h3 id="Create-a-new-post-4">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server-2">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files-2">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites-2">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).</summary>
    
    
    
    <category term="分类3" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB3/"/>
    
    <category term="分类3-1" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB3/%E5%88%86%E7%B1%BB3-1/"/>
    
    
    <category term="tag1" scheme="https://southernfish.github.io/tags/tag1/"/>
    
    <category term="tag2" scheme="https://southernfish.github.io/tags/tag2/"/>
    
  </entry>
  
  <entry>
    <title>Test-2</title>
    <link href="https://southernfish.github.io/2022/08/11/Test-2/"/>
    <id>https://southernfish.github.io/2022/08/11/Test-2/</id>
    <published>2022-08-11T01:51:21.000Z</published>
    <updated>2022-08-11T02:39:00.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start-3">Quick Start</h2><h3 id="Create-a-new-post-3">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">这是摘要哦。。。。</summary>
    
    
    
    <category term="分类1" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB1/"/>
    
    <category term="分类2" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB2/"/>
    
    
    <category term="tag3" scheme="https://southernfish.github.io/tags/tag3/"/>
    
    <category term="tag4" scheme="https://southernfish.github.io/tags/tag4/"/>
    
  </entry>
  
  <entry>
    <title>Test-1</title>
    <link href="https://southernfish.github.io/2022/08/11/Test-1/"/>
    <id>https://southernfish.github.io/2022/08/11/Test-1/</id>
    <published>2022-08-11T01:45:15.000Z</published>
    <updated>2025-06-18T12:55:27.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">这是摘要。。。。。。</summary>
    
    
    
    <category term="分类3" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB3/"/>
    
    <category term="分类3-1" scheme="https://southernfish.github.io/categories/%E5%88%86%E7%B1%BB3/%E5%88%86%E7%B1%BB3-1/"/>
    
    
    <category term="tag1" scheme="https://southernfish.github.io/tags/tag1/"/>
    
    <category term="tag2" scheme="https://southernfish.github.io/tags/tag2/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://southernfish.github.io/2022/08/10/hello-world/"/>
    <id>https://southernfish.github.io/2022/08/10/hello-world/</id>
    <published>2022-08-10T01:15:36.000Z</published>
    <updated>2025-06-18T12:55:27.767Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="hexo" scheme="https://southernfish.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://southernfish.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
