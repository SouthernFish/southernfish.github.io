<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Southern Fish</title>
  
  
  <link href="https://southernfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://southernfish.github.io/"/>
  <updated>2025-06-26T04:00:20.235Z</updated>
  <id>https://southernfish.github.io/</id>
  
  <author>
    <name>Southern Fish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高并发（High Concurrency）</title>
    <link href="https://southernfish.github.io/2025/06/26/framwork/system-design-high-concurrency/"/>
    <id>https://southernfish.github.io/2025/06/26/framwork/system-design-high-concurrency/</id>
    <published>2025-06-26T01:13:36.000Z</published>
    <updated>2025-06-26T04:00:20.235Z</updated>
    
    <content type="html"><![CDATA[<p>高性能、高并发、高可用是构建现代大规模系统的三个关键目标，它们各自解决不同的问题，但在实际系统中往往需要综合考虑，互为补充。本篇讨论高并发应对的策略、缓存、限流、降级等。原文链接：<a href="https://blog.csdn.net/ailiandeziwei/article/details/136561585">高并发架构设计（三大利器：缓存、限流和降级）</a></p><h1 id="高并发（High-Concurrency）"><a href="#高并发（High-Concurrency）" class="headerlink" title="高并发（High Concurrency）"></a>高并发（High Concurrency）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>高并发指的是系统能够同时处理大量请求或操作的能力。在互联网应用中，用户可能会同时访问某个功能，这就要求系统能够同时处理多个用户的请求而不发生性能下降或响应延迟。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><code>热门网站</code>、<code>电商平台</code>、<code>社交媒体</code>等互联网应用中。例如，在电商平台上有大量用户同时浏览、搜索商品，提交订单等操作；社交媒体平台上有大量用户同时发布、点赞、评论等操作。这些场景需要系统能够同时处理大量请求，并保证系统的性能、可用性和用户体验。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><strong>大量请求：</strong>系统需要同时处理大量的请求，这些请求可能来自于不同的用户或客户端。 </li><li><strong>同时访问：</strong>这些请求几乎同时到达系统，需要在短时间内进行处理和响应。 </li><li><strong>资源竞争：</strong>由于大量请求同时到达，系统的资源（如CPU、内存、网络带宽等）可能会面临竞争和争夺。 </li><li><strong>响应时间要求高：</strong>高并发场景通常对系统的响应速度有较高的要求，用户期望能够快速获取响应结果。</li></ol><h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><ul><li>系统性能的下降和延迟增加</li><li>资源竞争和资源耗尽</li><li>系统稳定性和可用性的挑战</li></ul><h2 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h2><ul><li><strong>缓存：</strong>缓解系统负载压力，提高系统响应速度</li><li><strong>限流：</strong>控制并发访问量，保护系统免受过载影响</li><li><strong>降级：</strong>保证核心功能的稳定性，舍弃非关键业务或简化处理</li></ul><hr><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>缓存的工作原理是先从缓存中获取数据，如果有数据则直接返回给用户，如果没有数据则从慢速设备上读取实际数据并且将数据放入缓存</p><h2 id="常用技术"><a href="#常用技术" class="headerlink" title="常用技术"></a>常用技术</h2><table><thead><tr><th>缓存类型</th><th>介绍</th><th align="left">方案/工具</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>浏览器缓存</td><td>存储在用户设备上的缓存，用于存储静态资源和页面内容。</td><td align="left">通过设置<code>HTTP头</code>中的缓存相关字段来控制缓存行为。</td><td>1.快速响应，避免频繁访问服务器或网络<br /> 2.减少网络带宽消耗，提升网站性能</td><td>1.缓存数据可能不是最新的，需要考虑缓存一致性和更新机制的设计<br />2.缓存命中率受限于缓存容量和缓存策略的选择</td><td>1.静态资源的缓存<br />2.减少网络带宽消耗</td></tr><tr><td>客户端缓存</td><td>应用程序在用户设备上的缓存，用于存储数据、计算结果或其他业务相关的内容。</td><td align="left">使用<code>本地存储</code>、<code>SessionStorage</code>、<code>LocalStorage</code>或<code>IndexedDB</code>等<strong>Web API</strong>来进行数据的存储和读取。</td><td>1.减轻后端负载，提升系统性能<br />2.快速响应，避免频繁访问服务器或网络资源</td><td>1.缓存数据可能不是最新的，需要考虑缓存一致性和更新机制的设计<br />2.缓存命中率受限于缓存容量和缓存策略的选择</td><td>1.频繁访问的数据或计算结果<br />2.减轻后端负载</td></tr><tr><td>CDN缓存</td><td>内容分发网络的缓存，用于存储和加速静态资源的分发。</td><td align="left">部署静态资源到<code>CDN服务器</code>并配置<code>CDN缓存策略</code>，用户请求将被转发到就近的CDN节点，加速内容的分发和访问。</td><td>1.加速静态资源的访问速度，提升用户体验<br />2.减轻源服务器负载，提高系统可扩展性</td><td>1.只适用于静态资源的缓存，动态内容无法缓存<br />2.CDN配置和管理的复杂性</td><td>1.静态资源的分发和访问<br />2.加速静态资源的加载和访问</td></tr><tr><td></td><td></td><td align="left"></td><td></td><td></td><td></td></tr><tr><td>反向代理缓存</td><td>位于服务器前端的缓存，用于缓存和加速动态内容和静态资源的访问。</td><td align="left">配置<code>反向代理服务器</code>并<code>设置缓存策略</code>，将用户请求转发到缓存服务器，减轻后端服务器的负载并加速内容的访问。</td><td>1.加速内容的访问速度，提升用户体验<br />2.减轻源服务器负载，提高系统可扩展性</td><td>只适用于特定的Web服务器和应用程序</td><td>1.动态内容和静态资源的缓存和加速访问<br /> 2. 减轻后端服务器的负载</td></tr><tr><td>本地缓存</td><td>应用程序在用户设备上的缓存，用于缓存数据和资源以提高应用的性能和响应速度。</td><td align="left">使用缓存库或框架（如<code>localStorage</code>、<code>sessionStorage</code>、<code>Workbox</code>等）来实现。</td><td>1.提升应用的性能和响应速度<br />2. 减少对远程资源的依赖，提高离线使用体验</td><td>本地缓存容量受限于用户设备的存储空间</td><td>1.频繁访问的数据或资源<br /> 2.提升应用的性能和响应速度</td></tr><tr><td>分布式缓存</td><td>在分布式系统中使用的缓存，用于存储和共享数据。分布式缓存通常部署在多台服务器上，并提供高并发读写能力和数据访问的可扩展性。分布式缓存常用于大规模应用和系统中。</td><td align="left">使用分布式缓存系统（如<code>Redis</code>、<code>Memcached</code>等）来存储和访问缓存数据。</td><td>高并发读写能力和数据存储的可扩展性</td><td>1.需要额外的服务器资源来部署和管理分布式缓存系统<br /> 2.缓存一致性和数据同步问题需要考虑</td><td>1.高并发读写能力和数据存储的可扩展性<br /> 2.大规模应用和系统的缓存和数据共享</td></tr></tbody></table><p>根据具体需求和系统架构，选择适合的缓存类型和方案，以提高系统性能、减轻服务器负载、改善用户体验和保证数据一致性。</p><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>浏览器缓存是指<strong>将网页中的资源（如HTML、CSS、JavaScript、图像等）存储在用户的浏览器内部</strong>，以便在后续请求同一资源时可以直接从本地缓存中获取，而无需再次从服务器下载。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>浏览器缓存适用于<strong>静态内容变化较少的网页和静态资源</strong>，可以显著提升网站性能和用户体验，并减少服务器的负载。</p><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>使用浏览器缓存可以通过<strong>设置响应头中的<code>Expires</code>和<code>Cache-Control</code>字段来控制缓存的行为</strong>。</p><ol><li><strong>使用Expires字段：</strong>Expires字段<strong>指定了缓存的过期时间，是一个具体的日期和时间</strong>。服务器可以在响应头中添加Expires字段，告诉浏览器在该时间之前可以直接从缓存中获取资源，而无需再向服务器发起请求。例如：Expires: Mon, 31 Dec 2022 23:59:59 GMT。</li><li><strong>使用Cache-Control字段：</strong>Cache-Control字段提供了更灵活的缓存控制选项。可以通过设置<code>max-age</code>指令来指定缓存的最大有效时间，单位是秒。例如：Cache-Control: max-age=3600 表示资源可以在1小时内直接从缓存中获取。还可以使用其他指令，如no-cache表示缓存但不使用缓存、no-store表示禁止缓存等。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>浏览器缓存存储<strong>实时性不敏感的数据</strong>，如商品框架、商家评分、评价和广告词。它有过期时间，并通过响应头进行控制。实时性要求高的数据不适合使用浏览器缓存。</p><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>客户端缓存是<strong>将数据存储在浏览器</strong>中，以提高访问速度和减少服务器请求。</p><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>在大促期间，为了防止服务端承受瞬间的高流量压力，可以<strong>提前将一些素材（如js/css/image等）下发到客户端进行缓存</strong>，避免在大促期间再次请求这些素材。此外，还可以<strong>将一些兜底数据或样式文件存放在客户端缓存</strong>中，以确保在服务端异常或网络异常的情况下，保持app的正常运行。</p><h2 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>CDN（<code>Content Delivery Network</code>）是建立在承载网之上的<strong>分布式网络，由分布在不同区域的边缘节点服务器组成</strong>。 </p><p>CDN缓存通常用于<strong>存放静态页面数据、活动页面、图片等数据</strong>。</p><p>CDN的两种<strong>缓存机制</strong>：<code>推送机制</code>（将数据主动推送到CDN节点）和<code>拉取机制</code>（首次访问时从源服务器获取数据并存储在CDN节点）。</p><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>CDN缓存可以提高网站访问速度，适用于<strong>网站访问量大、访问速度慢、数据变化不频繁的场景</strong>。</p><h3 id="常用工具以及用法"><a href="#常用工具以及用法" class="headerlink" title="常用工具以及用法"></a><strong>常用工具以及用法</strong></h3><p>常见的CDN缓存工具包括<code>Cloudflare</code>、<code>Akamai</code>、<code>Fastly</code>和<code>AWS CloudFront</code>等。这些工具提供了全球分布的CDN网络，以加速内容传输和提升性能。它们<strong>提供了控制台和API，用于配置CDN缓存规则、管理缓存内容、刷新和更新缓存等</strong>。</p><h2 id="反向代理缓存"><a href="#反向代理缓存" class="headerlink" title="反向代理缓存"></a>反向代理缓存</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>反向代理缓存是指<strong>在反向代理服务器上对请求的响应进行缓存</strong>，以提高服务的性能和用户体验。它<strong>将经常请求的静态内容缓存在代理服务器上</strong>，当有用户请求同样的内容时，代理服务器会直接返回缓存的响应，而无需再次向源服务器请求。</p><h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>适用于访问外部服务速度比较慢，但是<strong>数据变化不频繁</strong>的场景。</p><h3 id="常用工具以及用法-1"><a href="#常用工具以及用法-1" class="headerlink" title="常用工具以及用法"></a><strong>常用工具以及用法</strong></h3><p>1.<strong>Nginx：</strong>一款高性能的反向代理服务器，支持反向代理缓存功能，可通过配置文件进行缓存策略的设置。Nginx代理层缓存主要以<code>Http</code>模块与<code>proxy_cacahe</code>模块进行配置即可。</p><p>2.<strong>Varnish：</strong>一个专门用于反向代理缓存的开源软件，可以高效地缓存并提供快速的响应。</p><p>3.<strong>Squid：</strong>一款功能强大的缓存代理服务器，支持反向代理缓存和正向代理缓存。</p><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>本地缓存是将数据或资源存储在客户端的存储介质中，如硬盘、内存或数据库。它可以是临时的，只在应用程序运行期间有效，或者可以是持久的，即在不同的应用程序会话中保持有效。</p><h3 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>本地缓存适用于<strong>频繁访问数据</strong>、离线访问、减少带宽消耗和提升用户体验的场景。</p><h3 id="常用工具以及用法-2"><a href="#常用工具以及用法-2" class="headerlink" title="常用工具以及用法"></a><strong>常用工具以及用法</strong></h3><p><strong>一般分为磁盘缓存、CPU缓存、应用缓存</strong></p><ol><li><strong>磁盘缓存：</strong>存储在硬盘等永久性存储介质上，用于加速数据的读取和访问。</li><li><strong><a href="https://so.csdn.net/so/search?q=CPU%E7%BC%93%E5%AD%98&spm=1001.2101.3001.7020">CPU缓存</a>：</strong>位于处理器内部的高速存储器，用于<strong>暂时存储频繁访问的数据或指令</strong>，提高计算机的性能。</li><li><strong>应用缓存：</strong>存储在内存中的应用程序数据或资源，用于提高应用程序的响应速度和用户体验。用Java服务来举例，又分为 <strong>堆内缓存 与 堆外缓存</strong> 。</li></ol><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>分布式缓存是<strong>将缓存数据分散存储在多台服务器上</strong>的缓存解决方案。</p><h3 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p><strong>高并发读取、数据共享和协同处理、提供弹性和可扩展性、降低后端请求次数</strong>等场景。</p><h3 id="常用工具以及用法-3"><a href="#常用工具以及用法-3" class="headerlink" title="常用工具以及用法"></a><strong>常用工具以及用法</strong></h3><ol><li><strong><code>Redis</code>：</strong>Redis是一种<strong>高性能的键值存储系统，支持丰富的数据类型和灵活的缓存策略</strong>。可以使用Redis搭建分布式缓存集群，利用其快速的读写能力和一致性哈希算法实现数据分片和负载均衡。</li><li><strong><code>Memcached</code>：</strong>Memcached是一种<strong>简单而快速的分布式内存对象缓存系统</strong>，用于<strong>减轻数据库负载和加速动态Web应用程序</strong>。它采用分布哈希算法进行数据分片和分布式存储。</li><li><strong><code>Hazelcast</code>：</strong>Hazelcast是一个开源的<strong>分布式内存数据网格平台</strong>，<strong>提供分布式缓存和分布式计算能力</strong>。它可以用于构建高吞吐量和高可用性的分布式缓存系统。</li></ol><h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a><strong>缓存问题</strong></h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>关键词：<strong>强调缓存和数据库都没有数据+并发访问</strong>﻿<br>缓存穿透是指数据库和缓存都没有的数据，每次都要经过缓存去访问数据库，大量的请求有可能导致DB宕机。</p><h3 id="应对策略-1"><a href="#应对策略-1" class="headerlink" title="应对策略"></a><strong>应对策略</strong></h3><ol><li><strong>使用布隆过滤器（<code>Bloom Filter</code>）：</strong>布隆过滤器是一种<strong>快速判断元素是否存在的数据结构</strong>，它可以在很小的内存占用下，快速判断一个元素是否在一个集合中。<strong>将所有可能存在的数据哈希到一个足够大的位数组中</strong>，当一个请求过来时，先经过布隆过滤器判断是否存在于缓存中，如果不存在，则直接返回，避免对数据库的查询压力。</li><li><strong>空对象缓存：</strong>对于确定不存在的数据，在缓存中也存储一个空对象，表示该数据不存在。当请求访问这些不存在的数据时，直接从缓存中返回空对象，避免每次请求都穿透到数据库层进行查询。</li><li><strong>延迟双判：</strong>当一个查询请求穿透缓存到达数据库层后，先在数据库中进行查询，如果数据库也没有对应的数据，则将这个空结果写入缓存，并设置一个较短的过期时间。这样，下次相同的查询请求就会从缓存中得到空结果，而不会再次穿透到数据库。</li><li><strong>热点数据预加载：</strong>对于一些热点数据，在系统启动时或者在缓存过期前提前异步加载到缓存中，确保缓存的热点数据一直存在，避免被频繁请求的数据因为缓存过期而导致穿透问题。</li><li><strong>限流策略：</strong>针对频繁请求的特定数据，可以设置限流策略，例如使用<code>令牌桶算法</code>或<code>漏桶算法</code>，限制对这些数据的请求频率，减轻数据库的压力。</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>关键词：<strong>强调单个热点Key过期+并发访问</strong><br>缓存击穿是指数据库有，缓存没有的热点数据，大量请求访问这个缓存不存在的数据，最后请求打到DB可能导致DB宕机。</p><h3 id="应对策略-2"><a href="#应对策略-2" class="headerlink" title="应对策略"></a><strong>应对策略</strong></h3><ol><li><strong>设置热点数据的热度时间窗口：</strong>对于热点数据，可以设置一个热度时间窗口，在这个时间窗口内，如果一个数据被频繁访问，就将其缓存时间延长，避免频繁刷新缓存导致缓存击穿。</li><li><strong>使用互斥锁或分布式锁：</strong>在缓存失效时，只允许一个线程去查询数据库，其他线程等待查询结果。可以使用互斥锁或分布式锁来实现，确保只有一个线程能够查询数据库，其他线程等待结果，避免多个线程同时查询数据库造成数据库压力过大。</li><li><strong>缓存永不过期：</strong>对于一些热点数据，可以将其缓存设置为永不过期，或者设置一个很长的过期时间，这样即使缓存失效，也有足够的时间来刷新缓存，避免缓存击穿。</li><li><strong>异步更新缓存：</strong>在缓存失效时，可以异步地去更新缓存，而不是同步地去查询数据库并刷新缓存。这样可以减少对数据库的直接访问，并且不会阻塞其他请求的响应。</li><li><strong>多级缓存架构：</strong>使用多级缓存架构，将热点数据分散到多个缓存节点上，避免单一缓存节点发生故障导致整个缓存层崩溃。当某个缓存节点失效时，可以从其他缓存节点或数据库中获取数据。</li><li><strong>熔断机制：</strong>当缓存层发生故障或无法正常工作时，可以设置熔断机制，直接访问数据库，保证系统的正常运行。</li></ol><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>关键词：<strong>强调批量Key过期+并发访问</strong>﻿<br>缓存雪崩指的是在同一时段大量的缓存键（key）同时失效，导致大量请求打到数据库，最后请求打到DB可能导致DB宕机。</p><h3 id="应对策略-3"><a href="#应对策略-3" class="headerlink" title="应对策略"></a><strong>应对策略</strong></h3><ol><li><strong>使用多级缓存架构：</strong>将缓存划分为多个层级，每个层级的缓存设置不同的过期时间。例如，将热点数据存储在近期失效的缓存层级，而将非热点数据存储在长期失效的缓存层级。这样即使某一层级的缓存失效，仍然可以从其他层级获取数据，避免所有请求直接访问数据库。</li><li><strong>设置缓存数据的随机过期时间：</strong>在设置缓存数据的过期时间时，加上一个随机值，使得不同的缓存数据在过期时刻不一致。这样可以避免大量数据同时过期，减轻数据库负荷。</li><li><strong>分布式锁或互斥锁：</strong>在缓存失效时，使用分布式锁或互斥锁来保证只有一个请求可以重新加载缓存。其他请求等待该请求完成后，直接从缓存中获取数据。这样可以避免多个请求同时访问数据库。</li><li><strong>数据预热：</strong>在系统启动或者非高峰期，提前将热点数据加载到缓存中，预热缓存。这样即使在高并发时，也能够从缓存中获取到数据，减轻数据库的压力。</li><li><strong>缓存限流：</strong>当检测到缓存失效时，可以对请求进行限流处理，限制并发请求的数量。这样可以避免大量请求同时访问数据库，导致数据库负载过大。</li><li><strong>数据库优化：</strong>对于缓存雪崩问题，除了缓存层面的应对策略，还可以从数据库层面进行优化，如提升数据库性能、增加数据库的容量等，以应对大量请求导致的数据库压力。</li></ol><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>缓存一致性指的是缓存与DB之间的数据一致性，我们需要通过各种手段来防止缓存与DB不一致，我们要保证缓存与DB的数据一致或者数据最终一致。</p><h3 id="应对策略-4"><a href="#应对策略-4" class="headerlink" title="应对策略"></a><strong>应对策略</strong></h3><p>针对缓存一致性问题，可以从不同的层次来应对：</p><ol><li><p><strong>数据库层</strong></p><ul><li><p>在数据库层面，可以使用<strong>事务</strong>来确保数据的一致性。通过<strong>将读写操作放在同一个事务中</strong>，可以保证数据的更新和查询是一致的。</p></li><li><p>使用数据库的<strong>触发器</strong>或者<strong>存储过程</strong>，在数据更新的同时，主动触发缓存的更新操作，确保缓存与数据库的数据保持一致。</p></li></ul></li><li><p><strong>缓存层</strong></p><ul><li><p>在缓存层面，可以使用缓存更新策略，通过<strong>定时任务、异步消息队列</strong>等方式，定期或者在数据更新时<strong>异步地更新缓存</strong>，保持缓存与数据库的数据一致性。</p></li><li><p>使用<strong>互斥锁或者分布式锁来保证对缓存的读写操作的原子性</strong>，避免数据冲突。</p></li><li><p>设置<strong>合适的缓存过期时间</strong>，避免缓存数据长时间过期而导致数据不一致的问题。</p></li></ul></li><li><p><strong>应用层</strong></p><ul><li><p>在应用层面，可以采用<strong>读写分离策略，将读请求和写请求分发到不同的节点</strong>，读请求直接从缓存中获取数据，写请求则更新数据库并更新缓存，保持数据的一致性。</p></li><li><p>使用<strong>缓存中间件或者缓存组件，提供自动更新缓存</strong>的功能，减少手动维护缓存的复杂性。</p></li></ul></li><li><p><strong>监控和报警</strong></p><ul><li>建立监控和报警机制，通过监控缓存层和数据库层状态、数据一致性等指标，及时发现异常情况，并触发报警，以便及时处理。</li></ul></li></ol><p>综合使用以上层次的策略，可以有效地应对缓存一致性问题，保证数据的一致性和系统的稳定性。不同层次的策略可以相互配合，形成一个完善的缓存一致性解决方案。</p><hr><h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><h2 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>再强大的系统，也怕<strong>流量短事件内集中爆发</strong>，就像银行怕挤兑一样，所以，高并发另一个必不可少的模块就是限流。</p><p>限流是一种通过<strong>控制请求的速率或数量</strong>来保护系统免受过载的技术。流控的精髓是<strong>限制单位时间内的请求量</strong>，最大程度保障系统的可靠性及可用性。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h2><p>限流是在高并发环境下，为了保护系统的稳定性和可用性而引入的一种策略。通过限制并发请求的数量或频率，可以防止系统被过多的请求压垮或耗尽资源。</p><h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a><strong>限流算法</strong></h2><p>常见的流控算法包括：<strong>固定窗口、滑动窗口、漏桶、令牌桶、滑动日志</strong>等算法。</p><h3 id="固定窗口算法（计数器）"><a href="#固定窗口算法（计数器）" class="headerlink" title="固定窗口算法（计数器）"></a>固定窗口算法（计数器）</h3><h4 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>固定窗口限流算法（<code>Fixed Window Rate Limiting Algorithm</code>）原理是<strong>在固定时间窗口(单位时间)内限制请求的数量</strong>。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>固定窗口是最简单的流控算法。即，给定<strong>时间窗口</strong>，维护一个<strong>计数器</strong>用于统计访问次数，并实现以下规则：</p><ol><li>如果<em>访问次数小于阈值</em>，则允许访问，访问次数+1；</li><li>如果<em>访问次数超出阈值</em>，则限制访问，访问次数不增；</li><li>如果<em>超过了时间窗口，计数器清零</em>，并重置清零后的首次成功访问时间为当前时间。</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedWindowRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 统计请求数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">lastAcquireTime</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 记录上一次获取请求的时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">windowUnit</span> <span class="operator">=</span> <span class="number">1000L</span>; <span class="comment">// 假设固定时间窗口是1000ms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 窗口阀值是10，表示在时间窗口内的请求数阀值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字来实现线程安全</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">// 获取系统当前时间</span></span><br><span class="line">        <span class="keyword">if</span> (currentTime - lastAcquireTime &gt; windowUnit) &#123;  <span class="comment">// 检查 当前时间距离上次获取请求的时间 是否在时间窗口内</span></span><br><span class="line">            counter = <span class="number">0</span>;  <span class="comment">// 计数器清零</span></span><br><span class="line">            lastAcquireTime = currentTime;  <span class="comment">// 开启新的时间窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (counter &lt; threshold) &#123;  <span class="comment">// 小于阀值</span></span><br><span class="line">            counter++;  <span class="comment">// 计数器加1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 超过阀值，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-6"><a href="#适用场景-6" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li>保护后端服务免受大流量冲击，避免服务崩溃</li><li>对 API 调用进行限制，保证公平使用</li><li>防止恶意用户对服务进行洪水攻击</li></ul><h4 id="优劣分析"><a href="#优劣分析" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul><li><p><strong>优势：</strong>算法简单，易于实现和理解；<strong>性能高</strong></p></li><li><p><strong>劣势：</strong>存在明显的<strong>临界问题</strong>。</p><ul><li>比如：假设限流阀值为5个请求，单位时间窗口是1s，如果我们在单位时间内的<strong>前0.8-1s</strong>和<strong>1-1.2s</strong>，分别并发5个请求。虽然都没有超过阀值，但是如果算<strong>0.8-1.2s</strong>内的，则并发数高达10，已经超过单位时间1s不超过5阀值的定义了。</li></ul></li></ul><h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><h4 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>滑动窗口算法是把大的时间窗口拆分成若干<strong>粒度更细</strong>的子窗口，每个子窗口独立统计，<strong>按子窗口时间滑动</strong>，统一限流。当滑动窗口的格子周期划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。（<strong>为了解决临界突变问题</strong>）</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>将单位时间周期分为<strong>n个小周期</strong>，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。它可以解决固定窗口临界值的问题。</p><p>假设单位时间是<strong>1s</strong>，滑动窗口算法把它划分为<strong>5个小周期</strong>，也就是滑动窗口（单位时间）被划分为<strong>5个小格子</strong>。每格表示<strong>0.2s</strong>。每过<strong>0.2s</strong>，时间窗口就会往右滑动一格。<strong>每个小周期，都有自己独立的计数器</strong>，如果请求是<strong>0.83s</strong>到达的，<strong>0.8~1.0s</strong>对应的计数器就会<strong>加1</strong>。</p><p>假设我们1s内的限流阀值还是5个请求，0.8<del>1.0s内（比如0.9s的时候）来了5个请求，落在黄色格子里。﻿时间过了1.0s这个点之后，又来5个请求，落在紫色格子里。如果是固定窗口算法，是不会被限流的，但是滑动窗口的话，每过一个小周期，它会右移一个小格。过了1.0s这个点后，会右移一小格，当前的单位时间段是0.2</del>1.2s，这个区域的请求已经超过限定的5了，已触发限流啦，实际上，紫色格子的请求都被拒绝。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/1bb637a70d4209bc6aefb86b4ae94704.png" alt="img"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Long&gt; timestamps; <span class="comment">// 存储请求的时间戳队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> windowSize; <span class="comment">// 窗口大小，即时间窗口内允许的请求数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> windowDuration; <span class="comment">// 窗口持续时间，单位：毫秒</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SlidingWindowRateLimiter</span><span class="params">(<span class="type">int</span> windowSize, <span class="type">long</span> windowDuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.windowSize = windowSize;</span><br><span class="line">        <span class="built_in">this</span>.windowDuration = windowDuration;</span><br><span class="line">        <span class="built_in">this</span>.timestamps = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字来实现线程安全</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        <span class="comment">// 删除超过窗口持续时间的时间戳</span></span><br><span class="line">        <span class="keyword">while</span> (!timestamps.isEmpty() &amp;&amp; currentTime - timestamps.peek() &gt; windowDuration) &#123;</span><br><span class="line">            timestamps.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timestamps.size() &lt; windowSize) &#123; <span class="comment">// 判断当前窗口内请求数是否小于窗口大小</span></span><br><span class="line">            timestamps.offer(currentTime); <span class="comment">// 将当前时间戳加入队列</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 超过窗口大小，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-7"><a href="#适用场景-7" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>同固定窗口的场景，且对流量限制要求较高的场景，<strong>需要更好地应对突发流量</strong>。</p><h4 id="优劣分析-1"><a href="#优劣分析-1" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul><li><p><strong>优势：</strong>简单易懂；<strong>精度高</strong>（通过调整时间窗口的大小来实现不同的限流效果）；<strong>可扩展性强</strong>（易与其他限流算法结合使用）</p></li><li><p><strong>劣势：</strong>突发流量无法处理（无法应对短时间内的大量请求，但是一旦到达限流后，请求都会直接暴力被拒绝。这样我们会损失一部分请求，这其实对于产品来说，并不太友好），需要合理调整时间窗口大小。</p></li></ul><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><h4 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a><strong>简介</strong></h4><p><strong>基于（出口）流速来做流控。</strong>在网络通信中常用于流量整形，可以很好地解决平滑度问题。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li>可以以任意速率流入水滴到漏桶（流入请求）</li><li>漏桶具有固定容量，出水速率是固定常量（流出请求）</li><li>如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）</li></ul><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a><strong>原理</strong></h4><ul><li><p><strong>思想：</strong>将数据包看作是水滴，漏桶看作是一个固定容量的水桶，数据包像水滴一样从桶的顶部流入桶中，并通过桶底的一个小孔以一定的速度流出，从而限制了数据包的流量</p></li><li><p><strong>工作原理：</strong>对于每个到来的数据包，都将其加入到漏桶中，并检查漏桶中当前的水量是否超过了漏桶的容量。若超过了容量，就将多余的数据包丢弃。若漏桶中还有水，就以一定的速率从桶底输出数据包，保证输出的速率不超过预设的速率，从而达到限流目的。</p></li></ul><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakyBucketRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> capacity; <span class="comment">// 漏桶容量，即最大允许的请求数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> rate; <span class="comment">// 漏水速率，即每秒允许通过的请求数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> water; <span class="comment">// 漏桶当前水量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> lastTime; <span class="comment">// 上一次请求通过的时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeakyBucketRateLimiter</span><span class="params">(<span class="type">long</span> capacity, <span class="type">long</span> rate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.rate = rate;</span><br><span class="line">        <span class="built_in">this</span>.water = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lastTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字来实现线程安全</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> now - lastTime; <span class="comment">// 计算从上一次请求通过到当前的时间间隔</span></span><br><span class="line">        water = Math.max(<span class="number">0</span>, water - elapsedTime * rate / <span class="number">1000</span>); <span class="comment">// 计算漏桶中的水量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (water &lt; capacity) &#123; <span class="comment">// 判断漏桶中的水量是否小于容量</span></span><br><span class="line">            water++; <span class="comment">// 漏桶中的水量加1</span></span><br><span class="line">            lastTime = now; <span class="comment">// 更新上一次请求通过的时间戳</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 漏桶已满，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-8"><a href="#适用场景-8" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>一般用于保护第三方的系统，比如自身的系统需要调用第三方的接口，为了保护第三方的系统不被自身的调用打垮，便可以通过漏斗算法进行限流，保证自身的流量平稳的打到第三方的接口上。</p><h4 id="优劣分析-2"><a href="#优劣分析-2" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul><li><p><strong>优势</strong></p><ul><li><p>可以平滑限制请求的处理速度，<strong>避免瞬间请求过多导致系统崩溃或者雪崩</strong>。</p></li><li><p>可以<strong>控制请求的处理速度</strong>，使得系统可以适应不同的流量需求，<strong>避免过载或者过度闲置</strong>。</p></li><li><p>可以通过<strong>调整桶的大小和漏出速率来满足不同的限流需求</strong>，可以灵活地适应不同的场景。</p></li></ul></li><li><p><strong>劣势</strong></p><ul><li><p>需要<strong>对请求进行缓存</strong>，会增加服务器的内存消耗。</p></li><li><p>对于流量波动比较大的场景，需要较为灵活的参数配置才能达到较好的效果。</p></li><li><p>但是面对突发流量的时候，漏桶算法还是循规蹈矩地处理请求，这不是我们想看到的啦。流量变突发时，我们肯定希望系统尽量快点处理请求，提升用户体验。</p></li></ul></li></ul><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><h4 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>基于（入口）流速来做流控的一种限流算法。</p><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>该算法维护一个固定容量的令牌桶，每秒钟会向令牌桶中放入一定数量的令牌。当有请求到来时，如果令牌桶中有足够的令牌，则请求被允许通过并从令牌桶中消耗一个令牌，否则请求被拒绝。<strong>Guava</strong>的<strong>RateLimiter</strong>限流组件，就是基于令牌桶算法实现的。</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenBucketRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> capacity; <span class="comment">// 令牌桶容量，即最大允许的请求数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> rate; <span class="comment">// 令牌产生速率，即每秒产生的令牌数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> tokens; <span class="comment">// 当前令牌数量</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService scheduler; <span class="comment">// 调度器，用于调度令牌补充任务的线程池。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TokenBucketRateLimiter</span><span class="params">(<span class="type">long</span> capacity, <span class="type">long</span> rate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.rate = rate;</span><br><span class="line">        <span class="built_in">this</span>.tokens = capacity;</span><br><span class="line">        <span class="built_in">this</span>.scheduler = <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>);</span><br><span class="line">        scheduleRefill(); <span class="comment">// 启动令牌补充任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleRefill</span><span class="params">()</span> &#123; <span class="comment">// 使用调度器定期执行令牌补充任务，每秒补充一次令牌</span></span><br><span class="line">        scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">// 通过加锁的方式更新令牌数量，确保线程安全。</span></span><br><span class="line">                tokens = Math.min(capacity, tokens + rate); <span class="comment">// 补充令牌(当前令牌数量加上产生速率)，但不超过容量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS); <span class="comment">// 每秒产生一次令牌</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字实现线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (tokens &gt; <span class="number">0</span>) &#123; <span class="comment">// 判断令牌数量是否大于0</span></span><br><span class="line">            tokens--; <span class="comment">// 消耗一个令牌</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 令牌不足，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-9"><a href="#适用场景-9" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>一般用于保护自身的系统，对调用者进行限流，保护自身的系统不被突发的流量打垮。如果自身的系统实际的处理能力强于配置的流量限制时，可以允许一定程度的流量突发，使得实际的处理速率高于配置的速率，充分利用系统资源。</p><h4 id="优劣分析-3"><a href="#优劣分析-3" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul><li><p><strong>优势</strong></p><ul><li><p><strong>稳定性高：</strong>令牌桶算法可以<strong>控制请求的处理速度</strong>，可以使系统的负载变得稳定。</p></li><li><p><strong>精度高：</strong>令牌桶算法可以根据实际情况<strong>动态调整生成令牌的速率</strong>，可以实现较高精度的限流。</p></li><li><p><strong>弹性好：</strong>令牌桶算法可以<strong>处理突发流量</strong>，可以在短时间内提供更多的处理能力，以处理突发流量。</p></li></ul></li><li><p><strong>劣势</strong></p><ul><li><p><strong>实现复杂：</strong>相对于固定窗口算法等其他限流算法，令牌桶算法的实现较为复杂。</p></li><li><p><strong>对短时请求难以处理：</strong>在短时间内有大量请求到来时，可能会导致令牌桶中的令牌被快速消耗完，从而限流。这种情况下，可以考虑使用漏桶算法。</p></li><li><p><strong>时间精度要求高：</strong>令牌桶算法<strong>需要在固定的时间间隔内生成令牌</strong>，因此要求时间精度较高，如果系统时间不准确，可能会导致限流效果不理想。</p></li></ul></li></ul><h3 id="滑动日志算法（比较冷门）"><a href="#滑动日志算法（比较冷门）" class="headerlink" title="滑动日志算法（比较冷门）"></a>滑动日志算法（比较冷门）</h3><h4 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>滑动日志限速算法需要<strong>记录请求的时间戳</strong>，通常使用有序集合来存储，我们可以在单个有序集合中跟踪用户在一个时间段内所有的请求。</p><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>滑动日志算法可以用于<strong>实现限流功能，即控制系统在单位时间内处理请求的数量</strong>，以保护系统免受过载的影响。以下是滑动日志算法用于限流的原理：</p><ol><li><strong>划分时间窗口：</strong>将时间划分为固定的时间窗口，例如每秒、每分钟或每小时等。</li><li><strong>维护滑动窗口：</strong>使用一个滑动窗口来记录每个时间窗口内的请求次数。这个滑动窗口可以是一个固定长度的队列或数组。</li><li><strong>请求计数：</strong>当一个请求到达时，将其计数加一并放入当前时间窗口中。</li><li><strong>滑动：</strong>随着时间的流逝，滑动窗口会根据当前时间窗口的长度，移除最旧的请求计数，并将新的请求计数添加到最新的时间窗口中。</li><li><strong>限流判断：</strong>在每个时间窗口结束时，统计滑动窗口中的请求计数总和，并与预设的阈值进行比较。如果总请求数超过阈值，则触发限流处理。</li><li><strong>限流处理：</strong>一旦触发限流，可以采取不同的处理策略，如拒绝请求、延迟处理、返回错误信息等。具体的限流策略可以根据实际情况进行选择。</li></ol><p>通过滑动日志算法进行限流，可以<strong>实现对单位时间内的请求进行精确控制</strong>。它<strong>基于实时统计的方式</strong>，能够动态地适应请求流量的变化，并且在内存使用上比较高效。同时，通过调整时间窗口的长度和阈值的设置，可以<strong>灵活地控制限流的精度和灵敏度</strong>。</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingLogRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> requests; <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; timestamps; <span class="comment">// 存储请求的时间戳列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> windowDuration; <span class="comment">// 窗口持续时间，单位：毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// 窗口内的请求数阀值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SlidingLogRateLimiter</span><span class="params">(<span class="type">int</span> threshold, <span class="type">long</span> windowDuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.requests = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.timestamps = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.windowDuration = windowDuration;</span><br><span class="line">        <span class="built_in">this</span>.threshold = threshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字实现线程安全</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 获取当前时间戳</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除超过窗口持续时间的时间戳</span></span><br><span class="line">        <span class="keyword">while</span> (!timestamps.isEmpty() &amp;&amp; currentTime - timestamps.get(<span class="number">0</span>) &gt; windowDuration) &#123;</span><br><span class="line">            timestamps.remove(<span class="number">0</span>);</span><br><span class="line">            requests--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (requests &lt; threshold) &#123; <span class="comment">// 判断当前窗口内请求数是否小于阀值</span></span><br><span class="line">            timestamps.add(currentTime); <span class="comment">// 将当前时间戳添加到列表</span></span><br><span class="line">            requests++; <span class="comment">// 请求总数增加</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 超过阀值，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-10"><a href="#适用场景-10" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>对<strong>实时性要求高</strong>，且需要精确控制请求速率的高级限流场景。</p><h4 id="优劣分析-4"><a href="#优劣分析-4" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul><li><p><strong>优势：</strong></p><ul><li><p>滑动日志能够<strong>避免突发流量</strong>，实现较为精准的限流；</p></li><li><p>更加灵活，能够<strong>支持更加复杂的限流策略</strong>，如多级限流，每分钟不超过100次，每小时不超过300次，每天不超过1000次，我们只需要保存最近24小时所有的请求日志即可实现。</p></li></ul></li><li><p><strong>劣势：</strong>占用存储空间要高于其他限流算法。</p></li></ul><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a><strong>常用工具</strong></h2><h3 id="RateLimiter（单机）"><a href="#RateLimiter（单机）" class="headerlink" title="RateLimiter（单机）"></a>RateLimiter（单机）</h3><h4 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>基于<strong>令牌桶算法</strong>实现的一个多线程限流器，它可以将请求均匀的进行处理，当然他并不是一个分布式限流器，只是对单机进行限流。它可以应用在定时拉取接口数。通过aop、filter、Interceptor 等都可以达到限流效果。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h4><p>以下是一个基本的 RateLimiter 用法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个每秒允许2个请求的RateLimiter</span></span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 请求RateLimiter一个令牌，会阻塞当前线程直到获取到许可</span></span><br><span class="line">            rateLimiter.acquire(); </span><br><span class="line">            <span class="comment">// 执行操作</span></span><br><span class="line">            doSomeLimitedOperation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomeLimitedOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟一些操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Operation executed at: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rateLimiter.acquire()</code> 方法会阻塞当前线程直到获取到许可，确保调用 <code>doSomeLimitedOperation()</code> 操作的频率不会超过限制。</p><p><code>RateLimiter</code> 还提供了其他的方法，例如<code>tryAcquire()</code>，它会尝试获取许可而不会阻塞，立即返回获取成功或失败的结果。还可以设置等待时间上限，比如 <code>tryAcquire(long timeout, TimeUnit unit) </code>可以设置最大等待时间。</p><p>Guava的RateLimiter非常灵活，它支持平滑突发限制（<code>SmoothBursty</code>）和平滑预热限制（<code>SmoothWarmingUp</code>）等多种模式，可以根据特定的应用场景来选择合适的限流策略。</p><h3 id="sentinel（单机或者分布式）"><a href="#sentinel（单机或者分布式）" class="headerlink" title="sentinel（单机或者分布式）"></a>sentinel（单机或者分布式）</h3><h4 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h4><p><code>Sentinel</code>是阿里巴巴开源的一款面向分布式系统的<strong>流量控制和熔断降级组件</strong>。它提供了实时的<strong>流量控制、熔断降级、系统负载保护和实时监控</strong>等功能，可以帮助开发者保护系统的稳定性和可靠性。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250626112616426.png" alt="image-20250626112616426"></p><ul><li><code>DefaultController</code>：是一个非常典型的<strong>滑动窗口计数器</strong>算法实现，将当前统计的qps和请求进来的qps进行求和，小于限流值则通过，大于则计算一个等待时间，稍后再试；</li><li><code>ThrottlingController</code>：是<strong>漏斗算法</strong>的实现，实现思路已经在源码片段中加了备注；</li><li><code>WarmUpController</code>：实现参考了Guava的带预热的RateLimiter，区别是Guava侧重于请求间隔，类似前面提到的<strong>令牌桶</strong>，而Sentinel更关注于请求数，和令牌桶算法有点类似；</li><li><code>WarmUpRateLimiterController</code>：低水位使用<strong>预热算法</strong>，高水位使用<strong>滑动窗口计数器</strong>算法排队。</li></ul><h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a><strong>集群模式</strong></h4><p>Sentinel 集群限流服务端有两种启动方式：</p><ul><li>嵌入模式（Embedded）适合应用级别的限流，部署简单，但对应用性能有影响</li><li>独立模式（Alone）适合全局限流，需要独立部署</li></ul><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a><strong>用法</strong></h4><p>Sentinel的用法主要包括以下几个方面：</p><ol><li><p><strong>引入依赖：</strong>可以使用Maven或Gradle进行依赖管理。例如，在Maven项目的pom.xml文件中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>配置规则：</strong>根据实际需求，配置Sentinel的<strong>流量控制规则、熔断降级规则</strong>等。可以通过编程方式或配置文件方式进行规则的配置。例如，可以在启动类中使用<strong>注解方式</strong>配置流量控制规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(value = &quot;demo&quot;, blockHandler = &quot;handleBlock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>启动Agent：</strong>在应用启动时，启动Sentinel的Agent，开启对系统的流量控制和熔断降级功能的保护。可以通过命令行启动Agent，或者在代码中进行启动。例如，在Spring Boot的启动类中添加如下代码：</p></li><li><pre><code class="java">public static void main(String[] args) &#123;        System.setProperty(&quot;csp.sentinel.dashboard.server&quot;, &quot;localhost:8080&quot;); // 设置控制台地址    System.setProperty(&quot;project.name&quot;, &quot;your-project-name&quot;); // 设置应用名称     com.alibaba.csp.sentinel.init.InitExecutor.doInit();        SpringApplication.run(YourApplication.class, args);&#125;</code></pre></li><li><p><strong>监控和管理：</strong>使用Sentinel的控制台进行<strong>实时监控、配置管理</strong>等操作。可以通过浏览器访问<strong>Sentinel的控制台界面</strong>，查看系统的运行情况和流量控制情况。通过控制台，可以对规则进行动态修改，查看监控数据和告警信息。</p></li></ol><h3 id="Nginx（分布式）"><a href="#Nginx（分布式）" class="headerlink" title="Nginx（分布式）"></a>Nginx（分布式）</h3><h4 id="简介-14"><a href="#简介-14" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>Nginx从网关这一层面考虑，可以作为最前置的网关，抵挡大部分的网络流量，因此使用Nginx进行限流也是一个很好的选择，在Nginx中，也提供了常用的基于限流相关的策略配置。</p><h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a><strong>用法</strong></h4><p>Nginx 提供了两种限流方法：一种是<strong>控制速率</strong>，另一种是<strong>控制并发连接数</strong>。</p><h3 id="控制速率"><a href="#控制速率" class="headerlink" title="控制速率"></a><strong>控制速率</strong></h3><p>我们需要使用 <code>limit_req_zone</code> 用来限制单位时间内的请求数，即速率限制，因为Nginx的限流统计是基于毫秒的，我们设置的速度是 <code>2r/s</code>，转换一下就是500毫秒内单个IP只允许通过1个请求，从501ms开始才允许通过第2个请求。</p><h4 id="控制速率优化版"><a href="#控制速率优化版" class="headerlink" title="控制速率优化版"></a><strong>控制速率优化版</strong></h4><p>上面的速率控制虽然很精准但是在生产环境未免太苛刻了，实际情况下我们应该<strong>控制一个IP单位总时间内的总访问次数</strong>，而不是像上面那样精确到毫秒，我们可以使用 <code>burst</code> 关键字开启此设置。</p><p><code>burst=4</code>意思是<strong>每个IP最多允许4个突发请求</strong></p><h4 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a><strong>控制并发数</strong></h4><p>利用 <code>limit_conn_zone</code> 和 <code>limit_conn</code> 两个指令即可<strong>控制并发数</strong>，其中 <code>limit_conn perip 10</code> 表示<strong>限制单个 IP 同时最多能持有 10 个连接</strong>；<code>limit_conn perserver 100</code> 表示 <strong>server 同时能处理并发连接的总数为 100 个</strong>。</p><p><strong>注意：</strong>只有当 <code>request header</code> 被后端处理后，这个连接才进行计数。﻿</p><hr><h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><h2 id="简介-15"><a href="#简介-15" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>降级是在高并发或异常情况下<strong>舍弃非关键业务或简化处理的一种技术手段</strong>。按类型可分为有感降级，无感降级。</p><ul><li><strong>有感降级：</strong>主要是通过一定的监控感知到异常出现或即将出现，对调用服务进行快速失败返回或者进行切换，在指标回正的时候恢复服务调用，这个也可以称为熔断。</li><li><strong>无感降级：</strong>系统不作感知，在调用服务出现异常则自动忽略，进行空返回或无操作。降级的本质为作为服务调用方去规避提供方带来的风险。</li></ul><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>在限流中，服务调用方为每一个调用的服务维护一个有限状态机，在这个状态机会有三种状态：关闭（调用远程服务）、半打开（尝试调用远程服务）和打开（返回错误）。这三种状态之间切换的过程如下：﻿</p><ul><li>当调用失败的次数累积到一定阈值，熔断机制从关闭态切换到打开态。一般在实现时，如果调用成功一次，就会重置调用失败次数。</li><li>当熔断处于打开状态时，我们会启动一个计时器，当计时器超时后，状态切换到半打开态。也可以通过设置一个定时器，定期的探测服务是否恢复。</li><li>当熔断处于半打开状态时，请求可以达到后端服务，如果累计一定的成功次数后，状态切换到关闭态；如果出现调用失败的情况，则切换到打开态。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250626114727317.png" alt="image-20250626114727317"></p><h2 id="常用工具-1"><a href="#常用工具-1" class="headerlink" title="常用工具"></a><strong>常用工具</strong></h2><ul><li>降级开源组件：<strong>sentinel和Hystrix(不展开)</strong></li><li>手动降级：可采用<strong>系统配置开关</strong>来控制</li></ul><hr><h1 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h1><h2 id="简介-16"><a href="#简介-16" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>熔断在程序中表示“断开”。如发生了某事件，程序为了整体的稳定性，<strong>暂时（断开）停止服务一段时间</strong>，以保证程序可用时再被使用。</p><h2 id="熔断和降级的区别"><a href="#熔断和降级的区别" class="headerlink" title="熔断和降级的区别"></a><strong>熔断和降级的区别</strong></h2><ul><li><p>概念不同</p><ul><li><p>熔断程序为了整体的稳定性，所以暂时（断开）停止服务一段时间；</p></li><li><p>降级（<code>Degradation</code>）降低级别的意思，它是指程序在出现问题时，<strong>仍能保证有限功能可用</strong>的一种机制；</p></li></ul></li><li><p>触发条件不同</p><p>不同框架的熔断和降级的触发条件是不同，以<code>Hystrix</code>为例：</p><ul><li><p>Hystrix 熔断触发条件</p><ul><li>默认情况 hystrix 如果检测到 10 秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求。</li></ul></li><li><p>Hystrix 降级触发条件</p><ul><li><p>默认情况下，Hystrix 在以下 4 种条件下都会触发降级机制：</p><ul><li><p>方法抛出 <code>HystrixBadRequestException</code></p></li><li><p>方法<strong>调用超时</strong></p></li><li><p>熔断器开启拦截调用</p></li><li><p><strong>线程池或队列或信号量已满</strong></p></li></ul></li></ul></li></ul></li><li><p>归属关系不同</p><p>熔断时可能会调用降级机制，而降级时通常不会调用熔断机制。因为熔断是从全局出发，为了保证系统稳定性而停用服务，而降级是退而求其次，提供一种保底的解决方案，所以它们的归属关系是不同的（熔断 &gt; 降级）。</p></li></ul>]]></content>
    
    
    <summary type="html">高性能、高并发、高可用是现代系统设计中的三个重要指标，它们共同决定了一个系统在不同场景下的表现。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>高性能、高并发、高可用、高安全</title>
    <link href="https://southernfish.github.io/2025/06/25/framwork/system-design/"/>
    <id>https://southernfish.github.io/2025/06/25/framwork/system-design/</id>
    <published>2025-06-25T05:27:36.000Z</published>
    <updated>2025-06-26T04:00:20.235Z</updated>
    
    <content type="html"><![CDATA[<p>高性能、高并发、高可用是构建现代大规模系统的三个关键目标，它们各自解决不同的问题，但在实际系统中往往需要综合考虑，互为补充。例如，高并发可能会带来性能瓶颈，而高可用需要在性能和资源消耗之间找到平衡。通过合理的架构设计和技术选型，可以构建出既能应对大量并发请求，又具有快速响应和高可用性的系统。参考文章链接：<a href="https://blog.csdn.net/yanwenwennihao/article/details/141677135">高性能、高并发、高可用</a>、<a href="https://cloud.tencent.com/developer/article/2441609">高并发、高性能、高可用、高安全架构设计</a>、<a href="https://www.cnblogs.com/beatle-go/p/18302270">程序员的三高：高并发、高性能、高可用</a></p><h1 id="高性能（High-Performance）"><a href="#高性能（High-Performance）" class="headerlink" title="高性能（High Performance）"></a>高性能（High Performance）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>高性能指的是系统在处理请求时能够以最快的速度响应（<strong>程序处理速度非常快，所占内存少，cpu占用率低</strong>）。性能通常与系统的<strong>吞吐量和响应时间</strong>相关联。高性能系统能够在单位时间内处理大量请求，并在尽可能短的时间内提供响应。应用性能优化的时候，对于计算密集型和IO密集型还是有很大差别，需要分开来考虑。还可以增加服务器数量，内存，IO等参数提升系统的并发能力和性能，但不要浪费资源，要考虑硬件的使用率最高才能发挥到极致。</p><h2 id="关键指标"><a href="#关键指标" class="headerlink" title="关键指标"></a><strong>关键指标</strong></h2><ul><li><strong>吞吐量（<code>Throughput</code>）：</strong>系统在单位时间内处理的请求数量。通常以每秒请求数（<code>Requests Per Second, RPS</code>）或每秒事务数（<code>Transactions Per Second, TPS</code>）来衡量。</li><li><strong>响应时间（Response Time）：</strong>系统对请求进行反应的时间，及<strong>从发出请求到收到响应</strong>所需的时间，常以毫秒（ms）为单位。</li><li><strong>延迟（Latency）：</strong>系统中<strong>请求等待被处理的时间</strong>。高延迟会导致用户体验变差。</li></ul><h2 id="实现手段"><a href="#实现手段" class="headerlink" title="实现手段"></a><strong>实现手段</strong></h2><p>提高性能需要考虑，避免因为IO阻塞让CPU闲置，导致CPU的浪费，避免多线程间增加锁来保证同步，导致并行系统串行化，避免创建、销毁、维护太多进程、线程，导致操作系统浪费资源在调度上。具体如下等方面：</p><ul><li><p><strong>优化算法：</strong>使用更<strong>高效的数据结构和算法</strong>，减少时间复杂度。</p></li><li><p><strong>数据库性能优化：</strong></p><ul><li><strong>索引优化：</strong>创建适当的索引可以大幅提升查询效率。但需要注意索引的创建和维护成本，避免过多的索引影响写入性能。</li><li><strong>查询优化：</strong>优化SQL查询，避免全表扫描，尽量使用<code>JOIN</code>代替子查询，减少不必要的数据传输。</li><li><strong>数据库缓存：</strong>使用数据库缓存可以减少对数据库的访问次数，提高查询速度。</li><li><strong>数据库分区：</strong>将数据库分成多个分区，可以提高查询速度和可扩展性。</li><li><strong>数据库读写分离：</strong>将数据库的读操作和写操作分离到不同的服务器上，可以提高系统的吞吐量和并发处理能力。</li></ul></li><li><p><strong>缓存：</strong>通过在内存中存储常用数据，减少对数据库的访问，提高读取速度，提升热点数据的访问性能。</p><ul><li><p><strong>数据缓存：</strong>使用缓存（如<code>Redis</code>、<code>Memcached</code>）可以显著提高系统的响应速度。常见的<strong>缓存策略</strong>有<code>LRU（Least Recently Used）</code>、<code>LFU（Least Frequently Used）</code>。</p></li><li><p><strong>页面缓存：</strong>对于不经常变化的页面，可以使用CDN（Content Delivery Network）进行缓存，减少服务器压力。</p></li><li><p><strong>缓存根据性能由高到低分为：</strong><code>寄存器</code>、<code>L1缓存</code>、<code>L2缓存</code>、<code>L3缓存</code>、<code>本地内存</code>、<code>分布式缓存</code></p><ul><li>上层的寄存器、L1 缓存、L2 缓存是<strong>位于 CPU 核内的高速缓存</strong>，访问延迟通常在 10 纳秒以下。</li><li>L3 缓存是<strong>位于 CPU 核外部但在芯片内部的共享高速缓存</strong>，访问延迟通常在十纳秒左右。<strong>高速缓存</strong>具有成本高、容量小的特点，容量最大的 L3 缓存通常也只有几十MB。</li><li>本地内存是<strong>计算机内的主存储器</strong>，相比 CPU 芯片内部的高速缓存，内存的成本要低很多，容量通常是 GB 级别，访问延迟通常在几十到几百纳秒。</li></ul></li><li><p><strong>注意：</strong>内存和高速缓存都属于<strong>掉电易失的存储器</strong>，如果机器断电了，这类存储器中的数据就丢失了。</p></li></ul></li><li><p><strong>异步处理：</strong>将一些耗时操作（如 I/O 操作）放在后台异步执行，不阻塞主线程。</p><ul><li><strong>消息队列：</strong>使用消息队列（如<code>RabbitMQ</code>、<code>Kafka</code>）可以实现异步处理，解耦系统的各个组件。消息队列可以<strong>缓冲突发的请求</strong>，确保系统的稳定性。</li><li><strong>异步任务：</strong>通过异步任务处理（如<code>Celery</code>、<code>Resque</code>），可将<strong>不需要即时响应的任务放到后台处理</strong>，减少前端请求的响应时间。</li></ul></li><li><p><strong>资源利用优化：</strong>包括 <code>CPU</code>、<code>内存</code>、<code>磁盘 I/O</code> 的<strong>高效使用</strong>，以及<strong>减少上下文切换和锁争用</strong>。</p></li><li><p><strong>网络性能优化：</strong></p><ul><li><strong>减少网络延迟：</strong>通过CDN加速、内容压缩、减少HTTP请求等手段可以有效减少网络延迟。</li><li><strong>使用HTTP/2：</strong>HTTP/2支持多路复用、头部压缩等特性，可以显著提高网络传输效率。</li></ul></li><li><p><strong>服务性能优化</strong></p><ul><li><em>服务拆分：*<em>将单体应用拆分为微服务，各服务独立部署和扩展，可以提高整体系统的灵活性和性能。</em></em></li><li>服务降级：**在高并发场景下，对一些非核心服务进行降级处理，可以保证核心功能的稳定运行。</li></ul></li><li><p><strong>负载均衡（<code>Load Balancing</code>）</strong>：分散请求到多个服务器上，避免单个服务器过载。</p><ul><li>常用的<strong>负载均衡策略</strong>有<code>轮询</code>、<code>最少连接</code>、<code>源地址哈希</code>等。<a href="https://cloud.tencent.com/product/clb?from_column=20065&from=20065">负载均衡器</a>（如<code>Nginx</code>、<code>HAProxy</code>）。</li></ul></li></ul><h1 id="高并发（High-Concurrency）"><a href="#高并发（High-Concurrency）" class="headerlink" title="高并发（High Concurrency）"></a>高并发（High Concurrency）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>高并发指的是系统能够同时处理大量请求或操作的能力。在互联网应用中，用户可能会同时访问某个功能，这就要求系统能够同时处理多个用户的请求而不发生性能下降。</p><h2 id="关键指标-1"><a href="#关键指标-1" class="headerlink" title="关键指标"></a>关键指标</h2><ul><li><strong>并发用户数：</strong>同时承载正常使用系统功能的用户数量。</li><li><strong>并发事务数：</strong>系统能够同时处理的事务数量。</li><li><strong>QPS（Queries Per Second）：</strong>每秒钟系统处理的查询数量，反映了系统的并发处理能力。</li><li><strong>秒查询率（Queries Per Second，QPS）：</strong>每秒响应请求数，和吞吐量差不多，用于来<strong>衡量系统承载能力</strong>。</li></ul><h2 id="实现手段-1"><a href="#实现手段-1" class="headerlink" title="实现手段"></a>实现手段</h2><ul><li><strong>线程池：</strong>使用线程池技术复用线程资源，避免频繁创建和销毁线程，提升并发处理能力。</li><li><strong>无锁并发编程：</strong>减少锁的使用，或使用无锁数据结构，避免因锁竞争导致的性能瓶颈。</li><li><strong>消息队列：</strong>通过消息队列异步处理请求，削峰填谷，平滑系统的并发压力。</li><li><strong>水平扩展（<code>Horizontal Scaling</code>）：</strong>通过增加服务器节点的方式来处理更多的并发请求。<ul><li>相比之下，<strong>垂直扩展（<code>Vertical Scaling</code>）</strong>是通过增加单个服务器的硬件能力。<strong>水平扩展更具灵活性和可扩展性</strong>。</li></ul></li><li><strong>分布式架构：</strong>将系统功能分布到多个节点上，分担并发请求的压力。</li><li><strong>限流和熔断：</strong>在高并发情况下，保护系统不被突发的流量压垮，限流策略确保核心服务的稳定性。</li></ul><h1 id="高可用（High-Availability）"><a href="#高可用（High-Availability）" class="headerlink" title="高可用（High Availability）"></a>高可用（High Availability）</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>高可用指的是系统能够长时间持续稳定运行，并在出现故障时能够迅速恢复，以最小的停机时间提供服务。高可用性是衡量系统可靠性的关键指标。</p><h2 id="关键指标-2"><a href="#关键指标-2" class="headerlink" title="关键指标"></a>关键指标</h2><ul><li><strong>可用性（Availability）：</strong>系统在规定时间内可用的时间占比，通常以百分比表示。<ul><li>例如：99.9% 的可用性意味着系统每年最多停机约8小时45分钟。</li></ul></li><li><strong>故障切换时间（Failover Time）：</strong>当发生故障时，系统切换到备份系统或方案所需的时间。</li><li><strong>平均故障间隔时间（Mean Time Between Failures，MTBF）：</strong>系统在故障间的平均正常运行时间。</li><li><strong>平均修复时间（Mean Time to Repair，MTTR）：</strong>系统从故障到恢复正常服务的平均时间。</li></ul><h2 id="实现手段-2"><a href="#实现手段-2" class="headerlink" title="实现手段"></a>实现手段</h2><ul><li><strong>冗余设计：</strong>通过引入冗余（如双机热备、集群冗余等），在一个节点或组件故障时，另一个节点或组件可以无缝接管。</li><li><strong>故障转移（Failover）：</strong>在主服务器发生故障时，自动将请求转移到备份服务器上，保证服务的连续性。步骤如下：<ul><li><strong>1、故障自动侦测（<code>Auto-detect</code>）：</strong>采用健康检查、心跳等技术手段自动侦测故障节点；</li><li><strong>2、自动转移（<code>FailOver</code>）：</strong>当侦测到故障节点后，采用摘除流量、脱离集群等方式隔离故障节点，将流量转移到正常节点</li><li><strong>3、自动恢复（<code>FailBack</code>）：</strong>当故障节点恢复正常后，自动将其加入集群中，确保集群资源与故障前一致。</li></ul></li><li><strong>容错设计：</strong>设计系统时考虑各种可能的故障，并提供应对机制，如数据副本、自动重试等。<ul><li>如redis的高可用的集群方案： Redis单副本，Redis多副本（主从），Redis Sentinel（哨兵），Redis Cluster，Redis自研。</li></ul></li><li><strong>自动化运维：</strong>通过自动化脚本和工具，快速检测并修复故障，减少人为操作带来的误差和延迟。<ul><li><strong>自动化部署：</strong>使用容器化技术（如<code>Docker</code>、<code>Kubernetes</code>）实现自动化部署和管理，提高运维效率。</li><li><strong>自动化监控：</strong>通过监控系统（如<code>Prometheus</code>、<code>Zabbix</code>）实时监控系统状态，发现问题及时告警和处理。</li></ul></li><li><strong>分布式系统：</strong>将服务部署在多个地理位置或数据中心，防止单点故障带来的整体服务中断。<ul><li><strong>多数据中心：</strong>在不同的地理位置部署多个数据中心，实现跨区域的服务冗余和故障切换。</li><li><strong>主从切换：</strong>使用主从复制技术（如MySQL的主从复制）实现数据库的高可用，主库故障时可以切换到从库。</li></ul></li><li><strong>数据备份和恢复：</strong>定期备份数据，并提供快速的数据恢复机制，确保在数据损坏或丢失时能够迅速恢复。<ul><li><strong>数据备份：</strong>定期进行数据备份，确保在数据丢失或损坏时能够快速恢复。</li><li><strong>灾难恢复：</strong>制定详细的灾难恢复计划，模拟灾难场景进行演练，确保系统在灾难发生时能够迅速恢复。</li></ul></li><li><strong>过载保护：负载超过系统的承载能力时，系统会自动采取保护措施，确保自身不被压垮</strong><ul><li><strong>熔断：</strong>系统濒临崩溃的时候，<strong>立即中断服务</strong>，从而保障系统稳定避免崩溃。它类似于电器中的“保险丝”，当电流过大的时候，“保险丝”会先被烧掉，断开电流，以免电路过热烧毁电器引起火灾。</li><li><strong>限流：</strong>原理跟熔断有点类似，都是通过判断某个条件来确定是否执行某个策略。但它只处理自己能力范围之内的请求，<strong>超量的请求会被限流</strong>。限流算法：<code>计数器限流</code>、<code>滑动窗口限流</code>、<code>令牌桶限流</code>、<code>漏桶限流</code>。</li></ul></li><li><strong>降级：</strong>对<strong>非核心的功能</strong>进行降级 ，降低系统压力。 弃车保帅， 保证核心功能的正常使用 。</li></ul><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><ul><li><strong>内容分发网络（<code>CDN</code>）：</strong>内容分发网络通过在全球多个节点上分发内容，提高访问速度和可用性，防止单一节点故障影响用户访问。</li><li><strong>负载均衡：</strong>通过负载均衡器，将流量分发到多台服务器，确保即使某一台服务器出现故障，系统整体仍能继续服务。</li></ul><h1 id="高安全（High-Safety）"><a href="#高安全（High-Safety）" class="headerlink" title="高安全（High Safety）"></a>高安全（High Safety）</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>高安全是指系统能够保护用户数据和系统资源的安全，防止未经授权的访问和攻击。</p><h2 id="实现手段-3"><a href="#实现手段-3" class="headerlink" title="实现手段"></a>实现手段</h2><ul><li><strong>网络安全</strong><ul><li><strong>防火墙：</strong>配置防火墙（如<code>iptables</code>）限制不必要的网络访问，保护内部网络安全。</li><li><strong>入侵检测：</strong>部署入侵检测系统（如<code>Snort</code>、<code>Suricata</code>），实时监控和分析网络流量，发现潜在的入侵行为。</li></ul></li><li><strong>数据安全</strong><ul><li><strong>数据加密：</strong>对敏感数据进行加密存储和传输，防止数据泄露和篡改。例如，可使用 <code>SSL/TLS</code> 协议对通信内容进行加密。</li><li><strong>访问控制：</strong>通过权限控制（如<code>RBAC</code>、<code>ABAC</code>）确保只有授权用户才能访问敏感数据和功能。</li></ul></li><li><strong>应用安全</strong><ul><li><strong>身份验证：</strong>采用多因素身份验证（<code>MFA</code>）增加用户身份验证的安全性。</li><li><strong>防御常见攻击：</strong>防御常见的网络攻击（如<code>SQL注入</code>、<code>XSS</code>、<code>CSRF</code>），使用安全编码实践和<a href="https://cloud.tencent.com/product/waf?from_column=20065&from=20065">Web应用防火墙</a>（WAF）。</li></ul></li><li><strong>安全审计</strong><ul><li><strong>日志记录：</strong>记录关键操作日志，便于事后分析和审计。</li><li><strong>安全扫描：</strong>定期进行安全扫描和漏洞检测，及时修复发现的安全隐患。比如，可以使用<strong>漏洞扫描工具</strong>（如 <code>Nessus</code>）来定期扫描系统中的漏洞，并及时进行修复，防止攻击者利用漏洞进行攻击。</li><li><strong>安全监控：</strong>使用安全监控工具（如<code>Nagios</code>）实时监控系统的运行状态，可以及时发现安全事件，并采取相应的措施进行处理</li></ul></li></ul>]]></content>
    
    
    <summary type="html">高性能、高并发、高可用是现代系统设计中的三个重要指标，它们共同决定了一个系统在不同场景下的表现。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>java的加密方式</title>
    <link href="https://southernfish.github.io/2025/06/24/java/java-encription/"/>
    <id>https://southernfish.github.io/2025/06/24/java/java-encription/</id>
    <published>2025-06-24T09:53:36.000Z</published>
    <updated>2025-06-26T04:00:20.237Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，加密英文文本通常涉及到使用加密算法，比如对称加密（如AES）或非对称加密（如RSA）。本文整理了几种java常用的几种加密方法。本文转载自：<a href="https://blog.csdn.net/wa_ka_ka/article/details/148293941">Java常用加密方式</a></p><h1 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a>加密算法分类</h1><ul><li><strong>对称加密：</strong>指加密和解密的密钥相同，优点就是加解密的效率高且易于实现。</li><li><strong>非对称加密：</strong>指加密和解密的密钥不相同，也称为公私要加密。</li><li><strong>不可逆加密：</strong>特征就是加密过程不需要密钥，并且加密后的数据不能被解密，只能输入同样的数据并且经过同样的不可逆加密算法才能获取同样的加密数据。</li></ul><h1 id="加密算法的应用"><a href="#加密算法的应用" class="headerlink" title="加密算法的应用"></a>加密算法的应用</h1><ul><li><strong>数字签名：</strong>进行身份认证和数据完整性验证，主要用到了非对称密钥加密技术与数字摘要技术。</li><li><strong>数字证书：</strong>主要用来确保数字签名是安全有效的，数字证书由独立的证书发行机构发布。数字证书各不相同，每种证书可提供不同级别的可信度，该证书内包含用户的个人信息和他的公钥信息，同时还附有认证中心的签名信息。</li><li><strong>MD5：</strong>对用户密码进行加密并进行保存。</li><li><strong>网络数据加密：</strong>保障传输的数据安全，即使被截获报文，在没有密匙的情况下也无法得知报文真实内容。</li><li><strong>SSL协议：</strong>在<strong>握手阶段使用的是非对称加密</strong>，在<strong>传输阶段使用的是对称加密</strong>，即在SSL上传送的数据是使用对称密钥加密的。同时HTTPS也是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证（确认客户端连接的目标主机是否是真实正确的主机）的网络协议。</li></ul><h1 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h1><ul><li><strong>优点：</strong>算法对消息双方公开、计算量小、加解密速度快、效率高。</li><li><strong>缺点：</strong>在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。如果一方的秘钥被泄露，那么加密信息就会被破解。</li></ul><h2 id="DES介绍"><a href="#DES介绍" class="headerlink" title="DES介绍"></a>DES介绍</h2><p>DES全称为<code>Data Encryption Standard</code>，即<strong>数据加密标准</strong>，是一种<strong>使用密钥加密的<code>块算法</code><strong>，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（<code>FIPS</code>），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。但是近些年使用越来越少，因为</strong>DES使用56位密钥</strong>，以现代计算能力，24小时内即可被破解。DES加密和解密过程中，**密钥长度都必须是<code>8的倍数</code>**。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DESHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encrypt</span><span class="params">(String dataSource, String password)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// DES算法要求有一个可信任的随机数源</span></span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">        <span class="type">DESKeySpec</span> <span class="variable">desKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESKeySpec</span>(password.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 创建一个密钥工厂，然后用它对desKey进行转换</span></span><br><span class="line">        <span class="type">SecretKeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyFactory.generateSecret(desKey);</span><br><span class="line">        <span class="comment">// Cipher对象实际完成加密操作</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        <span class="comment">// 用密钥初始化Cipher对象，ENCRYPT_MODE用于将Cipher初始化为加密模式的常量</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,secretKey,random);</span><br><span class="line">        <span class="comment">// 正式对数据进行加密操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cipher.doFinal(dataSource.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decrypt</span><span class="params">(String src, String password)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">        <span class="type">DESKeySpec</span> <span class="variable">desKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESKeySpec</span>(password.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">SecretKeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyFactory.generateSecret(desKey);</span><br><span class="line">        <span class="comment">// Cipher对象实际完成解密操作</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE,secretKey,random);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cipher.doFinal(src.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加解密测试:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DESTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">DESHelper</span> <span class="variable">desHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESHelper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;原始数据：&quot;</span>+source);</span><br><span class="line">    <span class="type">byte</span>[] encryptData = desHelper.encrypt(source, <span class="string">&quot;1qaz2wsx&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;加密后数据：&quot;</span>+encryptData);</span><br><span class="line">    <span class="type">byte</span>[] decryptData = desHelper.decrypt(encryptData, <span class="string">&quot;1qaz2wsx&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;解密后数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(decryptData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IDEA介绍"><a href="#IDEA介绍" class="headerlink" title="IDEA介绍"></a>IDEA介绍</h2><ul><li>这种算法是在DES算法的基础上发展出来的，类似于<strong>三重DES</strong>。</li><li>发展IDEA也是因为感到DES具有密钥太短等缺点。</li><li><strong>DEA的密钥为128位</strong>，这么长的密钥在今后若干年内应该是安全的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDEAHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;IDEA&quot;</span>; <span class="comment">// 密钥算法</span></span><br><span class="line">    <span class="comment">// 加密、解密算法、工作模式、填充方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CIPHER_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;IDEA/ECB/ISO10126Padding&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥，只有bouncycastle支持</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[] 二进制密钥</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] initKey() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>()); <span class="comment">// 加入bouncyCastle支持</span></span><br><span class="line">        <span class="type">KeyGenerator</span> <span class="variable">kg</span> <span class="operator">=</span> KeyGenerator.getInstance(KEY_ALGORITHM);  <span class="comment">// 实例化密钥生成器</span></span><br><span class="line">        kg.init(<span class="number">128</span>); <span class="comment">// 初始化密钥生成器，IDEA要求密钥长度为128位</span></span><br><span class="line">        SecretKey secretKey=kg.generateKey(); <span class="comment">// 生成密钥</span></span><br><span class="line">        <span class="keyword">return</span> secretKey.getEncoded(); <span class="comment">// 获取二进制密钥编码形式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 二进制密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Key 密钥</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title function_">toKey</span><span class="params">(<span class="type">byte</span>[] key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key,KEY_ALGORITHM); <span class="comment">// 实例化DES密钥</span></span><br><span class="line">        <span class="keyword">return</span> secretKey; <span class="comment">// 生成密钥</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[] 加密后的数据</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encrypt(<span class="type">byte</span>[] data,<span class="type">byte</span>[] key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>()); <span class="comment">// 加入bouncyCastle支持</span></span><br><span class="line">        <span class="type">Key</span> <span class="variable">k</span> <span class="operator">=</span> toKey(key); <span class="comment">// 还原密钥</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM); <span class="comment">// 实例化</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, k);  <span class="comment">// 初始化，设置为加密模式</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data); <span class="comment">// 执行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[] 解密后的数据</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] data,<span class="type">byte</span>[] key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>()); <span class="comment">// 加入bouncyCastle支持</span></span><br><span class="line">        <span class="type">Key</span> <span class="variable">k</span> <span class="operator">=</span> toKey(key); <span class="comment">// 还原密钥</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, k); <span class="comment">// 初始化，设置为解密模式</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data); <span class="comment">// 执行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加解密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">IDEATest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;原始数据：&quot;</span>+str);</span><br><span class="line">    <span class="type">byte</span>[] key = IDEAHelper.initKey(); <span class="comment">// 初始化密钥</span></span><br><span class="line">    System.out.println(<span class="string">&quot;密钥：&quot;</span>+ Base64.encodeBase64String(key));</span><br><span class="line">    <span class="type">byte</span>[] data = IDEAHelper.encrypt(str.getBytes(), key); <span class="comment">// 加密数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;加密后数据：&quot;</span>+Base64.encodeBase64String(data));</span><br><span class="line">    data=IDEAHelper.decrypt(data, key);</span><br><span class="line">    System.out.println(<span class="string">&quot;解密后数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h1><ul><li><strong>优点：</strong>非对称加密与对称加密相比其安全性更好，只要私钥不泄露，很难被破解。</li><li><strong>缺点：</strong>加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</li></ul><h2 id="RSA介绍"><a href="#RSA介绍" class="headerlink" title="RSA介绍"></a>RSA介绍</h2><p>RSA是目前最有影响力和最常用的<strong>公钥加密算法</strong>。它能够抵抗到目前为止已知的绝大多数密码攻击，<strong>已被ISO推荐为公钥数据加密标准</strong>。<strong>RSA公开密钥密码体制的原理是：</strong>根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RSAHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SIGNATURE_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;MD5withRSA&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PUBLIC_KEY</span> <span class="operator">=</span> <span class="string">&quot;RSAPublicKey&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PRIVATE_KEY</span> <span class="operator">=</span> <span class="string">&quot;RSAPrivateKey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptBASE64(String key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.decodeBase64(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptBASE64</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用私钥对信息生成数字签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sign</span><span class="params">(<span class="type">byte</span>[] data, String privateKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 解密由base64编码的私钥</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(privateKey);</span><br><span class="line">        <span class="comment">// 构造PKCS8EncodedKeySpec对象</span></span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="comment">// KEY_ALGORITHM 指定的加密算法</span></span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">// 取私钥匙对象</span></span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">priKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 用私钥对信息生成数字签名</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        signature.initSign(priKey);</span><br><span class="line">        signature.update(data);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(signature.sign());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验数字签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sign 数字签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 校验成功返回true 失败返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(<span class="type">byte</span>[] data, String publicKey, String sign)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 解密由base64编码的公钥</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(publicKey);</span><br><span class="line">        <span class="comment">// 构造X509EncodedKeySpec对象</span></span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="comment">// KEY_ALGORITHM 指定的加密算法</span></span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">// 取公钥匙对象</span></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">pubKey</span> <span class="operator">=</span> keyFactory.generatePublic(keySpec);</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        signature.initVerify(pubKey);</span><br><span class="line">        signature.update(data);</span><br><span class="line">        <span class="comment">// 验证签名是否正常</span></span><br><span class="line">        <span class="keyword">return</span> signature.verify(decryptBASE64(sign));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptByPrivateKey(<span class="type">byte</span>[] data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得私钥</span></span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="type">Key</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 对数据解密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用私钥解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptByPrivateKey(String data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> decryptByPrivateKey(decryptBASE64(data), key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用公钥解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptByPublicKey(<span class="type">byte</span>[] data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得公钥</span></span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">x509KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="type">Key</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        <span class="comment">// 对数据解密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用公钥加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encryptByPublicKey(String data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对公钥解密</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得公钥</span></span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">x509KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="type">Key</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        <span class="comment">// 对数据加密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用私钥加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encryptByPrivateKey(<span class="type">byte</span>[] data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得私钥</span></span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="type">Key</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 对数据加密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPrivateKey</span><span class="params">(Map&lt;String, Key&gt; keyMap)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> (Key) keyMap.get(PRIVATE_KEY);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPublicKey</span><span class="params">(Map&lt;String, Key&gt; keyMap)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> keyMap.get(PUBLIC_KEY);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Key&gt; <span class="title function_">initKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGen</span> <span class="operator">=</span> KeyPairGenerator.getInstance(KEY_ALGORITHM);</span><br><span class="line">        keyPairGen.initialize(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGen.generateKeyPair();</span><br><span class="line">        Map&lt;String, Key&gt; keyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">2</span>);</span><br><span class="line">        keyMap.put(PUBLIC_KEY, keyPair.getPublic());<span class="comment">// 公钥</span></span><br><span class="line">        keyMap.put(PRIVATE_KEY, keyPair.getPrivate());<span class="comment">// 私钥</span></span><br><span class="line">        <span class="keyword">return</span> keyMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加解密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RSATest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Map&lt;String, Key&gt; keyMap = initKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">publicKey</span> <span class="operator">=</span> getPublicKey(keyMap);</span><br><span class="line">    <span class="type">String</span> <span class="variable">privateKey</span> <span class="operator">=</span> getPrivateKey(keyMap);</span><br><span class="line">    System.out.println(<span class="string">&quot;公钥：&quot;</span> + publicKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;私钥：&quot;</span> + privateKey);</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;原始数据：&quot;</span> + src);</span><br><span class="line">    <span class="type">byte</span>[] encryptByPrivateKey = encryptByPrivateKey(src.getBytes(), privateKey);</span><br><span class="line">    <span class="type">byte</span>[] encryptByPublicKey = encryptByPublicKey(src, publicKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;私钥加密后数据&quot;</span> + encryptByPrivateKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;公钥加密后数据&quot;</span> + encryptByPublicKey);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> sign(encryptByPrivateKey, privateKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;数字签名：&quot;</span> + sign);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">verify</span> <span class="operator">=</span> verify(encryptByPrivateKey, publicKey, sign);</span><br><span class="line">    System.out.println(<span class="string">&quot;签名验证结果：&quot;</span> + verify);</span><br><span class="line">    <span class="type">byte</span>[] decryptByPublicKey = decryptByPublicKey(encryptByPrivateKey, publicKey);</span><br><span class="line">    <span class="type">byte</span>[] decryptByPrivateKey = decryptByPrivateKey(encryptByPublicKey, privateKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;公钥解密私钥加密后的数据：&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(decryptByPublicKey));</span><br><span class="line">    System.out.println(<span class="string">&quot;私钥解密公钥加密后的数据：&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(decryptByPrivateKey));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不可逆算法"><a href="#不可逆算法" class="headerlink" title="不可逆算法"></a>不可逆算法</h1><h2 id="MD5介绍"><a href="#MD5介绍" class="headerlink" title="MD5介绍"></a>MD5介绍</h2><p>MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（也就是把一个任意长度的字节串变换成一定长的十六进制数字串）。主要有以下特点：</p><ol><li><strong>压缩性：</strong> 任意长度的数据，算出的MD5值长度都是固定的。</li><li><strong>容易计算：</strong> 从原数据计算出MD5值很容易。</li><li><strong>抗修改性：</strong> 对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li><li><strong>强抗碰撞：</strong> 已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MD5Helper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String s)</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md5</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] md5Bytes = md5.digest(s.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">return</span> md5ToString(md5Bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将md5数组转化为16进制字符串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">md5ToString</span><span class="params">(<span class="type">byte</span>[] md5Bytes)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">hexValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; md5Bytes.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> md5Bytes[i] &amp; <span class="number">0Xff</span>;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; <span class="number">16</span>)&#123;</span><br><span class="line">                hexValue.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            hexValue.append(Integer.toHexString(val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexValue.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MD5Test</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">    <span class="type">MD5Helper</span> <span class="variable">md5Helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MD5Helper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">src1</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src2</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;src1 加密后数据：&quot;</span> + md5Helper.encode(src1));</span><br><span class="line">    System.out.println(<span class="string">&quot;src2 加密后数据：&quot;</span> + md5Helper.encode(src2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SHA1介绍"><a href="#SHA1介绍" class="headerlink" title="SHA1介绍"></a>SHA1介绍</h2><p>对于长度小于<code>2^64位</code>的消息，SHA1会产生<strong>一个160位(40个字符)的消息摘要</strong>。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。SHA1有如下<strong>特性</strong>：</p><ul><li>不可以从消息摘要中复原信息；</li><li>两个不同的消息不会产生同样的消息摘要，(但会有1x10 ^ 48分之一的机率出现相同的消息摘要,一般使用时忽略)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SHA1Helper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String str)</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == str || str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="type">char</span>[] hexDigits = &#123; <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span> &#125;;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">mdTemp</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA1&quot;</span>); <span class="comment">// 创建SHA1算法消息摘要对象</span></span><br><span class="line">        mdTemp.update(str.getBytes(StandardCharsets.UTF_8)); <span class="comment">// 使用指定的字节数组更新摘要</span></span><br><span class="line">        <span class="type">byte</span>[] md = mdTemp.digest(); <span class="comment">// 生成hash值的字节数组</span></span><br><span class="line">        <span class="comment">// SHA1算法生成信息摘要的关键过程</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> md.length;</span><br><span class="line">        <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[j*<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">byte0</span> <span class="operator">=</span> md[i];</span><br><span class="line">            buf[k++] = hexDigits[byte0 &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0xf</span>];</span><br><span class="line">            buf[k++] = hexDigits[byte0 &amp; <span class="number">0xf</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SHA1Test</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">    <span class="type">SHA1Helper</span> <span class="variable">sha1Helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SHA1Helper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">src1</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src2</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;src1 加密后数据：&quot;</span> + sha1Helper.encode(src1));</span><br><span class="line">    System.out.println(<span class="string">&quot;src2 加密后数据：&quot;</span> + sha1Helper.encode(src2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HMAC-介绍"><a href="#HMAC-介绍" class="headerlink" title="HMAC 介绍"></a>HMAC 介绍</h2><p>HMAC 是密钥相关的<strong>哈希运算消息认证码</strong>（<code>Hash-based Message Authentication Code</code>），HMAC 运算利用 <strong>哈希算法</strong> (MD5、SHA1 等)，<strong>以 <code>一个密钥 和 一个消息</code> 为输入，生成一个 <code>消息摘要</code> 作为 输出。</strong>HMAC 发送方 和 接收方 都有的 key 进行计算，而没有该 key 的第三方，则 无法计算 出正确的 散列值，这样就可以 防止数据被篡改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HMACHelper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mac mac;</span><br><span class="line">    <span class="comment">// MAC算法可选以下多种算法：HmacMD5/HmacSHA1/HmacSHA256/HmacSHA384/HmacSHA512</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_MAC</span> <span class="operator">=</span> <span class="string">&quot;HmacMD5&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HMACHelper</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key.getBytes(StandardCharsets.UTF_8), KEY_MAC);</span><br><span class="line">        mac = Mac.getInstance(secretKey.getAlgorithm());</span><br><span class="line">        mac.init(secretKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sign</span><span class="params">(String content)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(mac.doFinal(content.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(String signature, String content)</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] result = mac.doFinal(content.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(result, signature.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">HMACTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HMACHelper</span> <span class="variable">hmacHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HMACHelper</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] signature = hmacHelper.sign(src);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> hmacHelper.verify(signature, src);</span><br><span class="line">    System.out.println(<span class="string">&quot;src 生成数字签名：&quot;</span> + signature);</span><br><span class="line">    System.out.println(<span class="string">&quot;签名验证结果：&quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在Java中，加密英文文本通常涉及到使用加密算法，比如对称加密（如AES）或非对称加密（如RSA）。本文整理了几种java常用的几种加密方法。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>超文本传输协议HTTP、HTTPS</title>
    <link href="https://southernfish.github.io/2025/06/24/framwork/http-and-https/"/>
    <id>https://southernfish.github.io/2025/06/24/framwork/http-and-https/</id>
    <published>2025-06-24T07:06:36.000Z</published>
    <updated>2025-06-26T04:00:20.234Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理了一些关于HTTP和HTTPS的相关内容。‌ 参考文章链接： <a href="https://blog.csdn.net/molangmolang/article/details/147905987">http和https的区别？（详细图文讲解）</a></p><h1 id="什么是-HTTP、HTTPS"><a href="#什么是-HTTP、HTTPS" class="headerlink" title="什么是 HTTP、HTTPS"></a>什么是 HTTP、HTTPS</h1><p><code>HTTP</code>（超文本传输协议，<code>Hypertext Transfer Protocol</code>）是一种用于<strong>分布式、协作式、超媒体信息系统</strong>的应用层协议。它允许客户端（如浏览器）与服务器之间进行通信，以请求和传输网页、图片、视频等资源。HTTP <strong>基于请求-响应模型</strong>，客户端发送请求到服务器，服务器处理请求后返回响应。</p><p><code>HTTPS</code>（安全超文本传输协议，<code>Hypertext Transfer Protocol Secure</code>）是 HTTP 的安全版本，通过在 HTTP 的基础上添加 <code>SSL/TLS（安全套接字层/传输层安全性）</code>协议来实现数据加密和安全传输。HTTPS 不仅能够传输数据，还能<strong>确保数据的机密性、完整性和身份验证，防止数据在传输过程中被窃取或篡改</strong>。</p><p> HTTP 在传输敏感信息（如用户登录信息、金融交易数据等）时存在较大的安全隐患，容易<strong>被中间人攻击、数据泄露</strong>等问题所困扰。为了解决这些问题，HTTPS 应运而生。它通过加密技术保护数据传输过程中的隐私和完整性，同时通过数字证书验证服务器的身份，确保用户与合法的服务器进行通信。此外，搜索引擎也倾向于优先推荐使用 HTTPS 的网站。</p><hr><h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>HTTP 是一种<strong>基于请求-响应模型的应用层协议</strong>，主要用于客户端（如浏览器）与服务器之间的通信。基本原理可概括为以下步骤：</p><ul><li> <strong>客户端发起请求：</strong>客户端通过浏览器或其他工具向服务器发送一个 HTTP 请求。请求中包含请求方法（如 GET、POST、PUT、DELETE 等）、请求的资源路径（URL）、HTTP 版本以及一系列<strong>请求头信息</strong>（如<code>Host</code>、<code>User-Agent</code>、<code>Accept</code>等）。</li><li><strong>服务器处理请求：</strong>服务器接收到请求后，根据请求方法和资源路径解析请求内容，并调用相应的应用程序或服务来处理请求。</li><li><strong>服务器返回响应：</strong>服务器处理完请求后，生成一个 HTTP 响应并发送回客户端。响应中包含 <strong>HTTP 状态码</strong>（如 200 表示成功，404 表示未找到等）、<strong>响应头信息</strong>（如<code>Content-Type</code>、<code>Content-Length</code>等）以及<strong>响应体</strong>（如网页内容、图片数据等）。</li><li><strong>客户端接收响应：</strong>客户端接收到服务器的响应后，解析响应内容并将其呈现给用户（如显示网页内容）。</li></ul><p>HTTP 协议<strong>基于无连接和无状态的通信方式</strong>，每次请求和响应完成后，连接即被关闭，服务器不会保存客户端的任何状态信息。这种设计使得 HTTP 协议简单高效，适合大规模的分布式网络应用。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li><strong>建立连接</strong><ol><li>客户端通过 <code>TCP/IP</code> 协议与服务器建立连接。默认情况下，HTTP 使用端口号 <code>80</code>。</li><li>客户端向服务器发送一个 TCP 连接请求，服务器接受连接后，双方建立一个可靠的 TCP 连接。</li></ol></li><li><strong>发送请求</strong><ol><li>客户端通过建立的 TCP 连接向服务器发送 HTTP 请求。请求由请求行、请求头和请求体组成。</li><li>请求行包含请求方法、资源路径和 HTTP 版本号，例如：<code>GET /index.html HTTP/1.1</code>。</li><li>请求头包含客户端的一些信息：<code>Host</code>（目标服务器地址）、<code>User-Agent</code>（客户端类型）、<code>Accept</code>（可接受的响应类型）等。</li><li>请求体（可选）包含客户端发送给服务器的数据，如表单数据、文件上传等。</li></ol></li><li><strong>服务器处理请求</strong><ol><li>服务器接收到客户端的请求后，解析请求行和请求头，确定请求的资源路径和方法。</li><li>根据请求方法和资源路径，服务器调用相应的应用程序或服务来处理请求。</li><li>如果请求方法是 GET，服务器会查找请求的资源并返回内容；如果是 POST，服务器会处理客户端提交的数据并返回结果。</li></ol></li><li><strong>返回响应</strong><ol><li>服务器处理完请求后，生成一个 HTTP 响应并发送回客户端。</li><li>响应由状态行、响应头和响应体组成。</li><li>状态行包含 HTTP 版本号、状态码和状态消息，例如：<code>HTTP/1.1 200 OK</code>。</li><li>响应头包含服务器的一些信息，如<code>Content-Type</code>（响应内容类型）、<code>Content-Length</code>（响应体长度）等。</li><li>响应体包含服务器返回的数据，如网页内容、图片数据等。</li></ol></li><li><strong>关闭连接</strong><ol><li>客户端接收到服务器的响应后，解析响应内容并将其呈现给用户。</li><li>一旦响应处理完成，客户端和服务器之间的 TCP 连接被关闭。</li></ol></li></ol><h2 id="特点与优势"><a href="#特点与优势" class="headerlink" title="特点与优势"></a>特点与优势</h2><ol><li><strong>简单高效</strong><ol><li>HTTP 协议的设计简洁明了，易于理解和实现。它基于文本格式，便于调试和开发。</li><li>HTTP 的无状态特性使每个请求和响应都独立，服务器不需要保存客户端的状态信息，提高了服务器的处理能力和扩展性。</li></ol></li><li><strong>灵活通用</strong><ol><li>HTTP 支持多种请求方法（如 GET、POST、PUT、DELETE 等），能够满足不同的应用场景。</li><li>它可以传输多种类型的数据，如文本、图片、视频等，适用于各种网络应用。</li></ol></li><li><strong>广泛支持</strong><ol><li>HTTP 是互联网上最广泛使用的协议之一，几乎所有浏览器和服务器都支持 HTTP 协议。</li><li>它与多种其他协议（如 TCP/IP、DNS 等）无缝集成，能够轻松构建复杂的网络应用。</li></ol></li><li><strong>可扩展性</strong><ol><li>HTTP 协议通过请求头和响应头提供了丰富的扩展机制，允许开发者添加自定义的头信息来实现特定的功能。</li><li>它还支持多种内容编码（如 gzip 压缩）和缓存机制，能够优化网络传输效率和性能。</li></ol></li><li><strong>兼容性强</strong><ol><li>HTTP 协议版本更新（如从 HTTP/1.1 到 HTTP/2）保持了向后兼容性，使旧的客户端和服务器能够无缝迁移到新的协议版本。</li><li>它还支持多种编程语言和开发框架，方便开发者进行开发和部署。</li></ol></li></ol><hr><h1 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h1><h2 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h2><p>HTTPS 是 HTTP 协议的安全版本，通过在 HTTP 的基础上添加 SSL/TLS（安全套接字层/传输层安全性）协议来实现数据的安全传输。其核心原理可概括为以下几个方面：</p><ol><li><p><strong>加密传输</strong></p><p>HTTPS 使用 SSL/TLS 协议对传输的数据进行加密。加密过程包括<strong>对称加密和非对称加密</strong>两种方式。在握手过程中，客户端和服务器首先使用<strong>非对称加密（如 RSA 或 ECC）交换密钥</strong>，然后使用<strong>对称加密（如 AES）对后续的通信数据进行加密</strong>。这种加密方式既保证了密钥交换的安全性，又提高了数据传输的效率。</p></li><li><p><strong>身份验证</strong></p><p>HTTPS 通过数字证书来验证服务器的身份。服务器需要从权威的证书颁发机构（CA）<strong>获取数字证书</strong>，并在握手过程中将证书发送给客户端。客户端通过<strong>验证证书的有效性</strong>（包括证书的颁发机构、有效期、域名等信息）来确认服务器的身份，防止中间人攻击。</p></li><li><p><strong>数据完整性</strong></p><p>HTTPS 使用<strong>哈希算法</strong>（如 <code>SHA-256</code>）对传输的数据进行完整性校验。在数据传输过程中，客户端和服务器会生成数据的哈希值，并在接收数据时验证哈希值是否一致。如果数据在传输过程中被篡改，哈希值将不匹配，从而确保数据的完整性。</p></li><li><p><strong>协议层级</strong></p><p>HTTPS 在 <code>TCP 层之上、HTTP 层之下</code>工作。它通过 SSL/TLS 协议封装 HTTP 数据，使得 HTTP 协议在传输过程中得到保护。默认情况下，HTTPS 使用端口号 <code>443</code>。</p></li></ol><h2 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li><strong>建立连接</strong><ol><li>客户端通过 TCP/IP 协议与服务器建立连接。默认情况下，HTTPS 使用端口号 443。</li><li>客户端向服务器发送一个 TCP 连接请求，服务器接受连接后，双方建立一个可靠的 TCP 连接。</li></ol></li><li><strong>SSL/TLS 握手</strong><ol><li>客户端向服务器发送一个<code>ClientHello</code>消息，包含客户端支持的 SSL/TLS 版本、加密算法列表、随机数等信息。</li><li>服务器收到<code>ClientHello</code>消息后，选择一种加密算法，并向客户端发送一个<code>ServerHello</code>消息，包含服务器选择的 SSL/TLS 版本、加密算法、随机数等信息。</li><li>服务器向客户端发送自己的数字证书（包括公钥），客户端验证证书的有效性。</li><li>客户端生成一个预主密钥（<code>Pre-Master Secret</code>），并使用服务器的公钥对其进行加密，然后发送给服务器。</li><li>服务器使用自己的私钥解密预主密钥，客户端和服务器分别使用预主密钥和之前交换的随机数生成主密钥（<code>Master Secret</code>），用于后续的对称加密通信。</li><li>客户端和服务器分别发送<code>ChangeCipherSpec</code>消息和<code>Finished</code>消息，表示握手完成，开始使用对称加密进行通信。</li></ol></li><li><strong>发送请求和响应</strong><ol><li>客户端通过建立的安全连接向服务器发送 HTTP 请求，请求内容经过 SSL/TLS 加密。</li><li>服务器接收到加密的请求后，解密请求内容并处理请求，然后将响应内容加密后发送回客户端。</li><li>客户端接收到加密的响应后，解密响应内容并将其呈现给用户。</li></ol></li><li><strong>关闭连接</strong><ol><li>客户端或服务器可以随时发送<code>CloseNotify</code>消息来关闭连接。</li><li>一旦连接关闭，<code>SSL/TLS</code> 会话结束。</li></ol></li></ol><h2 id="特点与优势-1"><a href="#特点与优势-1" class="headerlink" title="特点与优势"></a>特点与优势</h2><ol><li><p><strong>数据加密</strong></p><p>HTTPS 对传输的数据进行加密，防止数据在传输过程中被窃取或篡改。即使攻击者能够截获数据，也无法解密其内容，从而保护了用户的隐私和敏感信息。</p></li><li><p><strong>身份验证</strong></p><p>HTTPS 通过数字证书验证服务器身份，确保客户端与合法的服务器进行通信。这有效防止了中间人攻击，提高了网络通信的安全性。</p></li><li><p><strong>数据完整性</strong></p><p>HTTPS 使用哈希算法对数据进行完整性校验，确保数据在传输过程中未被篡改。如果数据被篡改，客户端将拒绝接收数据，从而保障了数据的完整性。</p></li><li><p><strong>兼容性强</strong></p><p>HTTPS 是基于 HTTP 协议的扩展，兼容现有的 HTTP 应用。大多数现代浏览器和服务器都支持 HTTPS，开发者可以轻松地将现有的 HTTP 应用迁移到 HTTPS。</p></li><li><p><strong>搜索引擎优化（SEO）</strong></p><p>搜索引擎（如 Google）倾向于优先推荐使用 HTTPS 的网站，因为 HTTPS 提供了更高的安全性。这有助于提升网站在搜索引擎结果页面（SERP）中的排名，增加网站的流量。</p></li><li><p><strong>提升用户信任</strong></p><p>使用 HTTPS 的网站在浏览器地址栏中会显示一个绿色的锁形图标，表明网站是安全的。这有助于提升用户对网站的信任，增加用户在网站上的停留时间和交互行为。</p></li><li><p><strong>支持 HTTP/2</strong></p><p>HTTPS 是 HTTP/2 的基础，HTTP/2 提供了更高的性能优化，如多路复用、服务器推送等。使用 HTTPS 可以更好地支持 HTTP/2 的特性，提升网站的加载速度和用户体验。</p></li></ol><hr><h1 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h1><h2 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h2><ol><li><p><strong>数据加密</strong><br><strong>HTTP：</strong>HTTP 是<strong>明文传输协议</strong>，数据在客户端和服务器之间传输时未经过加密。这意味着传输的数据（如用户名、密码、信用卡信息等）可能会被网络中的中间设备（如路由器、代理服务器）或恶意攻击者截获。<br><strong>HTTPS：</strong>HTTPS 在 HTTP 的基础上引入了 <strong>SSL/TLS 加密机制</strong>。在数据传输过程中，客户端和服务器之间通过<strong>非对称加密交换密钥</strong>，然后使用<strong>对称加密对数据进行加密</strong>。即使数据被截获，攻击者也无法解密其内容，从而有效保护了数据的机密性。</p></li><li><p><strong>数据完整性</strong><br><strong>HTTP：</strong>HTTP 协议本身<strong>不提供数据完整性校验机制</strong>。数据在传输过程中可能会被篡改，而客户端无法检测到这种篡改。<br><strong>HTTPS：</strong>HTTPS 使用<strong>哈希算法</strong>（如 SHA-256）对传输的数据进行完整性校验。在数据传输过程中，客户端和服务器会生成数据的哈希值，并<strong>在接收数据时验证哈希值是否一致</strong>。如果数据在传输过程中被篡改，哈希值将不匹配，从而确保数据的完整性。</p></li><li><p><strong>身份验证</strong><br><strong>HTTP：</strong>HTTP 协议<strong>不提供身份验证机制</strong>，无法验证服务器或客户端的身份。攻击者可以通过中间人攻击（<code>MITM</code>）伪装成合法的服务器或客户端，窃取用户数据。<br><strong>HTTPS：</strong>HTTPS 使用<strong>数字证书</strong>来验证服务器的身份。服务器需要从权威的证书颁发机构（<code>CA</code>）获取数字证书，并在握手过程中将证书发送给客户端。<strong>客户端通过验证证书的有效性</strong>（包括证书的颁发机构、有效期、域名等信息）来确认服务器的身份，从而防止中间人攻击。</p></li></ol><h2 id="协议基础"><a href="#协议基础" class="headerlink" title="协议基础"></a>协议基础</h2><ol><li><p><strong>使用的协议</strong><br><strong>HTTP：</strong>HTTP 是一种<strong>应用层协议</strong>，基于 <code>TCP/IP</code> 协议栈工作。它主要用于客户端和服务器之间的数据传输。<br><strong>HTTPS：</strong>HTTPS 是 HTTP 的安全版本，通过在 HTTP 的基础上添加 <code>SSL/TLS 协议</code>来实现数据的安全传输。SSL/TLS 是一种<strong>传输层安全协议</strong>，用于加密数据并验证通信双方的身份。</p></li><li><p><strong>端口号</strong><br><strong>HTTP：</strong>HTTP 默认使用端口号 <code>80</code>。<br><strong>HTTPS：</strong>HTTPS 默认使用端口号 <code>443</code>。</p></li></ol><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ol><li><p><strong>加载速度</strong><br><strong>HTTP：</strong>HTTP 是明文传输，数据传输速度快，但安全性差。在没有加密开销的情况下，HTTP 的加载速度通常比 HTTPS 快。<br><strong>HTTPS：</strong>HTTPS 在数据传输过程中需要进行加密和解密操作，这会增加一定的计算开销，可能导致加载速度略慢。然而，随着硬件性能的提升和 SSL/TLS 协议的优化，这种性能差距已经逐渐缩小。此外，HTTPS 支持 HTTP/2 协议，HTTP/2 通过多路复用、服务器推送等技术可以显著提升页面加载速度。</p></li><li><p><strong>对服务器的影响</strong><br><strong>HTTP：</strong>HTTP 不涉及加密和解密操作，<strong>对服务器的计算资源要求较低</strong>。<br><strong>HTTPS：</strong>HTTPS 的加密和解密操作会<strong>增加服务器的计算开销</strong>，尤其是在高并发场景下。不过，现代服务器的硬件性能已经足够强大，能够较好地处理这些额外的负载。此外，使用硬件加速（如 <code>SSL 加速卡</code>）可以进一步减轻服务器的负担。</p></li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>HTTP 的适用场景</strong></p><ol><li><strong>非敏感信息传输：</strong>HTTP 适用于传输非敏感信息，如公开的网页内容、新闻资讯等。这些信息即使被截获也不会对用户或企业造成严重损失。</li><li><strong>低安全性需求的内部网络：</strong>在企业内部网络中，如果数据传输的安全性要求不高，可以使用 HTTP 来降低系统复杂性和成本。</li><li><strong>简单的信息查询：</strong>对于一些简单的信息查询服务，如天气预报、股票行情等，HTTP 是一个高效且经济的选择。</li></ol><p><strong>HTTPS 的适用场景</strong></p><ol><li><strong>电子商务网站：</strong>电子商务网站涉及用户敏感信息（如信用卡信息、个人身份信息等），须使用 HTTPS 保护用户隐私和数据安全。</li><li><strong>金融服务：</strong>银行、证券等金融服务机构需要使用 HTTPS 来确保交易数据的安全性和完整性，防止数据泄露和欺诈行为。</li><li><strong>个人隐私保护：</strong>涉及用户个人隐私的应用（如电子邮件、社交媒体、在线医疗等）需要使用 HTTPS 来保护用户的隐私。</li><li><strong>搜索引擎优化（SEO）：</strong>搜索引擎倾向于优先推荐使用 HTTPS 的网站，为了提升网站在搜索结果中的排名，建议使用 HTTPS。</li><li><strong>需要高安全性的企业应用：</strong>对于企业内部的敏感应用（如人力资源管理系统、财务系统等），使用 HTTPS 可以有效防止数据泄露和中间人攻击。</li></ol><h1 id="HTTP-和-HTTPS-的实际应用"><a href="#HTTP-和-HTTPS-的实际应用" class="headerlink" title="HTTP 和 HTTPS 的实际应用"></a>HTTP 和 HTTPS 的实际应用</h1><h2 id="HTTP-的常见应用"><a href="#HTTP-的常见应用" class="headerlink" title="HTTP 的常见应用"></a>HTTP 的常见应用</h2><ul><li><strong>网站浏览</strong><br>HTTP 是互联网上最早广泛应用的协议之一，广泛用于普通的网站浏览场景。许多新闻网站、博客、社交媒体平台等在早期都使用 HTTP 协议来传输网页内容。例如：<ul><li><strong>新闻网站：</strong>用户通过浏览器访问新闻网站时，HTTP 协议用于从服务器获取新闻文章、图片和视频等资源。这些内容通常是公开的，对安全性要求不高，因此 HTTP 能够高效地完成任务。</li><li><strong>博客平台：</strong>博客作者发布文章后，读者可以通过 HTTP 协议访问博客页面，查看文章内容。由于博客内容大多是公开分享的，HTTP 的简单性和高效性使其成为合适的选择。</li></ul></li><li><strong>简单信息查询</strong><br>HTTP 也常用于简单的信息查询服务，如天气预报、股票行情、公共信息查询等。这些服务的特点是：<ul><li><strong>数据公开性：</strong>查询的内容通常是公开的，不需要加密保护。例如，用户查询天气信息时，数据是公开的，对安全性要求不高。</li><li><strong>高效性：</strong>HTTP 的无状态特性和简单的请求-响应模型使其能够快速处理大量用户的查询请求，适合这类对性能要求较高的场景。</li></ul></li></ul><h2 id="HTTPS-的常见应用"><a href="#HTTPS-的常见应用" class="headerlink" title="HTTPS 的常见应用"></a>HTTPS 的常见应用</h2><ul><li><strong>电子商务</strong><br>电子商务网站是 HTTPS 应用的典型场景之一。在这些网站上，用户需要输入敏感信息，如信用卡号、地址、联系方式等。HTTPS 的加密机制能够确保这些信息在传输过程中不被窃取或篡改。例如：<ul><li><strong>在线购物平台：</strong>用户在购买商品时，需要输入支付信息和个人信息。HTTPS 通过加密这些数据，确保用户的隐私和交易安全。</li><li><strong>支付网关：</strong>支付网关是处理支付交易的核心环节，必须使用 HTTPS 来保护用户的支付信息。SSL/TLS 加密和数字证书验证机制能够有效防止中间人攻击，确保交易的完整性和安全性。</li></ul></li><li><strong>金融交易</strong><br>金融行业对数据安全的要求极高，因此 HTTPS 是金融交易的必备技术。银行、证券公司等金融机构通过 HTTPS 来保护用户的账户信息、交易记录和资金操作。例如：</li><li><ul><li><strong>网上银行：</strong>用户登录网上银行时，HTTPS 用于加密登录信息，防止密码被窃取。在进行转账、查询余额等操作时，HTTPS 确保数据的安全传输。</li><li><strong>证券交易：</strong>证券交易系统需要处理大量的敏感数据，如股票买卖订单、资金流向等。HTTPS 通过加密和身份验证机制，确保交易的安全性和合规性。</li></ul></li><li><strong>个人隐私保护</strong><br>许多涉及个人隐私的应用和服务都采用了 HTTPS 来保护用户数据。例如：<ul><li><strong>社交媒体平台：</strong>用户在社交媒体上分享个人信息、照片和消息时，HTTPS 确保这些数据在传输过程中不被泄露。例如，Facebook 和 Twitter 等平台都使用 HTTPS 来保护用户的隐私。</li><li><strong>在线医疗平台：</strong>在线医疗平台涉及用户的健康信息和医疗记录，这些信息非常敏感。HTTPS 通过加密和身份验证机制，确保用户的医疗数据在传输过程中不被窃取或篡改。</li><li><strong>电子邮件服务：</strong>许多电子邮件服务提供商（如 Gmail、Outlook 等）使用 HTTPS 来保护用户的邮件内容。HTTPS 确保用户在登录邮箱、发送和接收邮件时，数据的安全性和隐私性得到保障。</li></ul></li></ul><p>HTTP 和 HTTPS 在实际应用中各有其适用场景。<strong>HTTP 适用于对安全性要求不高、注重效率的场景，而 HTTPS 则是处理敏感数据和需要高安全性的场景的首选协议</strong>。</p>]]></content>
    
    
    <summary type="html">‌本文整理了一些关于HTTP和HTTPS的相关内容。‌</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="RestfulApi" scheme="https://southernfish.github.io/categories/Framwork/RestfulApi/"/>
    
    
    <category term="RestfulApi" scheme="https://southernfish.github.io/tags/RestfulApi/"/>
    
  </entry>
  
  <entry>
    <title>数据库引擎InnoDB</title>
    <link href="https://southernfish.github.io/2025/06/24/database/database-innodb/"/>
    <id>https://southernfish.github.io/2025/06/24/database/database-innodb/</id>
    <published>2025-06-24T05:34:36.000Z</published>
    <updated>2025-06-26T04:00:20.233Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB，是<a href="https://baike.baidu.com/item/MySQL/471251?fromModule=lemma_inlink">MySQL</a>的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/1239260?fromModule=lemma_inlink">数据库引擎</a>之一，现为MySQL的默认<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/8969956?fromModule=lemma_inlink">存储引擎</a>，为[MySQL AB](<a href="https://baike.baidu.com/item/MySQL">https://baike.baidu.com/item/MySQL</a> AB/2620844?fromModule=lemma_inlink)发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由<a href="https://baike.baidu.com/item/%E7%94%B2%E9%AA%A8%E6%96%87%E5%85%AC%E5%8F%B8/430115?fromModule=lemma_inlink">甲骨文公司</a>并购。与传统的ISAM与<a href="https://baike.baidu.com/item/MyISAM/0?fromModule=lemma_inlink">MyISAM</a>相比，InnoDB的最大特色就是支持了<a href="https://baike.baidu.com/item/ACID/10738?fromModule=lemma_inlink">ACID</a>兼容的<a href="https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1/5945882?fromModule=lemma_inlink">事务</a>（Transaction）功能，类似于<a href="https://baike.baidu.com/item/PostgreSQL/530240?fromModule=lemma_inlink">PostgreSQL</a>。InnoDB采用<a href="https://baike.baidu.com/item/%E5%8F%8C%E8%BD%A8%E5%88%B6/8309993?fromModule=lemma_inlink">双轨制</a>授权，一个是<a href="https://baike.baidu.com/item/GPL/0?fromModule=lemma_inlink">GPL</a>授权，另一个是专有软件授权。</p><h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><h2 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h2><p><strong><code>InnoDB</code>索引是聚簇索引</strong>，MyISAM索引是非聚簇索引。<br><code>InnoDB</code>的<strong>主键索引的叶子节点存储着行数据</strong>，因此主键索引非常高效。<br><strong><code>MyISAM</code>索引的叶子节点存储的是行数据地址</strong>，需要再寻址一次才能得到数据。<br><strong>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据</strong>，因此查询时做到覆盖索引会非常高效。</p><h2 id="MySQL-InnoDB存储引擎的特点"><a href="#MySQL-InnoDB存储引擎的特点" class="headerlink" title="MySQL InnoDB存储引擎的特点"></a>MySQL InnoDB存储引擎的特点</h2><p><strong>事务支持：</strong>InnoDB支持ACID事务属性。<br><strong>崩溃恢复</strong>：InnoDB会<strong>将数据写入到磁盘上的日志文件</strong>中，即使在系统崩溃的情况下，也能通过这些日志文件恢复数据。<br><strong>MVCC (多版本并发控制)：</strong>InnoDB使用多版本并发控制，这允许更高的并发性。<br><strong>外键约束：</strong>InnoDB支持外键约束，这对于维护数据库的引用完整性非常有用。<br><strong>行级锁定：</strong>与表级锁定相比，InnoDB<strong>支持行级锁定，提供了更高的并发性能</strong>。<br><strong>自适应哈希索引：</strong>InnoDB会<strong>自动为频繁访问的热点数据创建哈希索引，以提高查询速度</strong>。</p><h2 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h2><p>推荐使用自增ID，不要使用UUID。<br>在InnoDB存储引擎中，主键索引是作为<strong>聚簇索引</strong>存在的，主键索引的<code>B+树</code>叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，只需要不断向后排列即可，如果是*<code>UUID</code>，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降*。<br>总之，在数据量大一些的情况下，用自增主键性能会好一些。<br>主键是聚簇索引，若没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个<strong>隐式的主键</strong>。</p><h2 id="如何使用InnoDB？"><a href="#如何使用InnoDB？" class="headerlink" title="如何使用InnoDB？"></a>如何使用InnoDB？</h2><p>在创建表时指定使用InnoDB存储引擎，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE example (</span><br><span class="line">    <span class="built_in">id</span> INT AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (<span class="built_in">id</span>)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h2 id="优化InnoDB性能的技巧"><a href="#优化InnoDB性能的技巧" class="headerlink" title="优化InnoDB性能的技巧"></a>优化InnoDB性能的技巧</h2><p><strong>配置<code>innodb_buffer_pool_size</code>：控制InnoDB缓存数据和索引的内存大小</strong>。通常设置为系统内存的50%-80%。<br><strong>调整<code>innodb_log_file_size</code>：增加日志文件的大小可以减少日志磁盘写入次数</strong>，但需要确保磁盘I/O足够快。<br><strong>使用合适的索引：</strong>确保对查询进行优化的索引。<br><strong>监控和调整<code>innodb_io_capacity</code>：</strong>这个参数<strong>控制后台I/O操作的速率</strong>，需要根据实际的磁盘I/O性能进行调整。<br><strong>批量操作：</strong>大量插入、更新或删除操作时，尽量使用<strong>事务批量处理，减少对数据库的冲击</strong>。</p><h2 id="InnoDB常见问题及解决方案？"><a href="#InnoDB常见问题及解决方案？" class="headerlink" title="InnoDB常见问题及解决方案？"></a>InnoDB常见问题及解决方案？</h2><p><strong>性能问题：</strong>若发现InnoDB性能不佳，<strong>先检查是否有足够的内存分配给<code>innodb_buffer_pool_size</code>，以及磁盘I/O是否成为瓶颈</strong>。<br><strong>锁等待：</strong>高并发下，锁等待可能导致性能下降。可<strong>通过<code>SHOW ENGINE INNODB STATUS</code>查看锁等待情况</strong>，并考虑优化查询或增加索引。<br><strong>死锁：</strong>死锁是多个事务相互等待对方释放资源的情况。MySQL会检测到死锁并自动回滚其中一个事务以解除死锁。可以<strong>通过<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>表来诊断死锁</strong>。</p><hr><h1 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h1><p>MVCC全称<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6&spm=1001.2101.3001.7020">多版本并发控制</a>，是在并发访问数据库时对操作数据做多版本管理，避免因为写数据时要加写锁而阻塞读取数据的请求问题。</p><h2 id="InnoDB的MVCC实现原理"><a href="#InnoDB的MVCC实现原理" class="headerlink" title="InnoDB的MVCC实现原理"></a>InnoDB的MVCC实现原理</h2><p>MySQL <code>InnoDB</code> 存储引擎使用多版本并发控制（MVCC，<code>Multi-Version Concurrency Control</code>）来支持高并发环境下的读写操作，而不会互相阻塞。MVCC 允许在同一个时刻有多个事务对同一数据进行操作，而不会导致数据不一致。使用软性手段既要保证串行化隔离级别的安全性同时保证系统的整体性能和吞吐量。转载自文章 <a href="https://blog.csdn.net/carolineme/article/details/145860802">Innodb MVCC实现原理</a></p><ol><li><p><strong>事务版本号</strong></p><p>每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。</p></li><li><p><strong>表格的隐藏列</strong></p><table><thead><tr><th>隐藏列名称</th><th>说明</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>记录操作该数据事务的事务ID；</td></tr><tr><td>DB_ROLL_PTR</td><td>指向上一个版本数据在undo log 里的位置指针；</td></tr><tr><td>DB_ROW_ID</td><td>隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引;</td></tr></tbody></table></li><li><p><strong>Undo log</strong></p><p>Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。<strong>主要用途：</strong></p><ul><li><p>保证事务进行<code>rollback</code>时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。</p></li><li><p><strong>用于MVCC快照读的数据</strong>，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。</p></li></ul></li><li><p><strong>Read view</strong></p><p>在innodb 中每个事务开启后都会得到一个read_view。副本主要保存了当前<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F&spm=1001.2101.3001.7020">数据库系统</a>中正处于活跃（没有commit）的事务的ID号，保存的是系统中当前不应该被本事务看到的其他事务id列表。<strong>Read view 的几个重要属性：</strong></p><table><thead><tr><th>属性名称</th><th>说明</th></tr></thead><tbody><tr><td>trx_ids</td><td>当前系统活跃(未提交)事务版本号集合</td></tr><tr><td>max_limit_id</td><td>创建当前read view 时“当前系统最大事务版本号+1”</td></tr><tr><td>min_limit_id</td><td>创建当前read view 时“系统正处于活跃事务最小版本号”</td></tr><tr><td>creator_trx_id</td><td>创建当前read view的事务版本号</td></tr></tbody></table><p><strong>Read view 匹配条件规则：</strong></p><ul><li>如果数据事务ID <code>trx_id &lt; min_limit_id</code>，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。</li><li>如果<code>trx_id&gt;= max_limit_id</code>，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</li><li>如果 <code>min_limit_id =&lt;trx_id&lt; max_limit_id</code>，<strong>需要分3种情况讨论</strong>：<ul><li>如果<code>m_ids包含trx_id</code>，则代表Read View生成时刻，这个事务还未提交，但如果数据的<code>trx_id等于creator_trx_id</code>的话，表明数据是自己生成的，因此是可见的。</li><li>如果<code>m_ids包含trx_id</code>，并且<code>trx_id不等于creator_trx_id</code>，则Read View生成时，事务未提交，并且不是自己生产的，所以当前事务也是看不见的；</li><li>如果<code>m_ids不包含trx_id</code>，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是能看见的。</li></ul></li></ul><p><code>READ_UNCOMMITTED</code> 级别的事务不会获取read view 副本；<code>RC(read commit)</code> 级别下同一个事务里面的每一次查询都会获得一个新的read view副本；<code>RR(重复读)</code>级别下的一个事务里只会获取一次read view副本，从而保证每次查询的数据都是一样的。</p></li></ol><h2 id="MVCC-Next-key-Lock-防止幻读"><a href="#MVCC-Next-key-Lock-防止幻读" class="headerlink" title="MVCC+Next-key-Lock 防止幻读"></a>MVCC+Next-key-Lock 防止幻读</h2><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p><ol><li><p><strong>执行普通 select，此时会以 MVCC 快照读的方式读取数据</strong></p><ul><li><p>在快照读的情况下，RR 隔离级别只会在<strong>事务开启后的第一次查询生成 <code>Read View</code></strong> ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。</p></li><li><p><strong>快照读</strong>是指读取数据时不是读取最新版本的数据，而是基于历史版本读取的一个快照信息（mysql读取undo log历史版本)</p></li></ul></li><li><p><strong>执行 select…for update/lock in share mode、insert、update、delete 等当前读</strong></p><ul><li>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，<strong>就会产生幻读</strong>！</li><li>InnoDB 使用 <code>Next-key Lock</code> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。</li><li>当前读是读取的数据库最新的数据，当前读和快照读不同，因为要读取最新的数据而且要保证事务的隔离性，所以当前读是需要对数据进行加锁的</li></ul></li></ol>]]></content>
    
    
    <summary type="html">‌InnoDB是为处理巨大数据量时的最大性能设计。InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>大模型</title>
    <link href="https://southernfish.github.io/2025/06/24/large-model/large-model/"/>
    <id>https://southernfish.github.io/2025/06/24/large-model/large-model/</id>
    <published>2025-06-24T03:22:36.000Z</published>
    <updated>2025-06-26T04:00:20.238Z</updated>
    
    <content type="html"><![CDATA[<p>人工智能大模型（简称“大模型”）是指由<a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/382460?fromModule=lemma_inlink">人工神经网络</a>构建的一类具有大量参数的人工智能模型。其通常先通过自监督学习或<a href="https://baike.baidu.com/item/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/9075473?fromModule=lemma_inlink">半监督学习</a>在海量数据上进行预训练，然后通过指令微调和人类对齐等方法进一步优化其性能和能力。大模型具有参数量大、训练数据大、计算资源大等特点，拥有解决通用任务、遵循人类指令、进行复杂推理等能力。器主要类别包括：<a href="https://baike.baidu.com/item/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/62884793?fromModule=lemma_inlink">大语言模型</a>、视觉大模型、<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B/63122644?fromModule=lemma_inlink">多模态大模型</a>以及基础科学大模型等。目前，大模型已在多个领域得到广泛应用，包括<a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/104812?fromModule=lemma_inlink">搜索引擎</a>、<a href="https://baike.baidu.com/item/%E6%99%BA%E8%83%BD%E4%BD%93/9446647?fromModule=lemma_inlink">智能体</a>、相关垂直产业及基础科学等领域，推动了各行业的智能化发展。</p><p>原文链接： <a href="https://zhuanlan.zhihu.com/p/1900212961517213051">大模型</a></p><h1 id="大模型"><a href="#大模型" class="headerlink" title="大模型"></a>大模型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>大模型</strong>（<code>Large Models</code>）通常指参数规模庞大（通常在十亿到万亿级别）的深度学习模型。这类模型通过在大规模数据集上进行训练，具备强大的泛化能力和复杂的任务处理能力，尤其在<strong>自然语言处理（NLP）、计算机视觉（CV）和多模态任务</strong>中表现突出。例如，<a href="https://zhida.zhihu.com/search?content_id=257103601&content_type=Article&match_order=1&q=GPT-3&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTA5NDIwMzEsInEiOiJHUFQtMyIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjI1NzEwMzYwMSwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.pRQ4bw78OW9OCPds9KYVAnts2vd5huIIdlV17yltino&zhida_source=entity">GPT-3</a>（1750亿参数）和<a href="https://zhida.zhihu.com/search?content_id=257103601&content_type=Article&match_order=1&q=PaLM&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTA5NDIwMzEsInEiOiJQYUxNIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MjU3MTAzNjAxLCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.pY7El6LSXHn6ol368EhPM_k_HmIaxDphK8H0ACiazno&zhida_source=entity">PaLM</a>（5400亿参数）是典型的大模型。</p><h2 id="大模型和小模型的区别"><a href="#大模型和小模型的区别" class="headerlink" title="大模型和小模型的区别"></a>大模型和小模型的区别</h2><table><thead><tr><th>维度</th><th>大模型</th><th>小模型</th></tr></thead><tbody><tr><td>参数规模</td><td>十亿到万亿级（如GPT-3：175B）</td><td>百万到十亿级（如<a href="https://zhida.zhihu.com/search?content_id=257103601&content_type=Article&match_order=1&q=BERT&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTA5NDIwMzEsInEiOiJCRVJUIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MjU3MTAzNjAxLCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.GgzgYV_OlNlMQ6Rk8on2UBVonjpddwn5kjEs0-wm-2k&zhida_source=entity">BERT</a>-base：110M）</td></tr><tr><td>训练数据</td><td>海量数据（TB级文本、图像等）</td><td>较小规模（GB级）</td></tr><tr><td>计算资源</td><td>需要分布式GPU/TPU集群，训练耗时数周至数月</td><td>单卡或少量GPU即可训练，耗时短</td></tr><tr><td>应用场景</td><td>通用任务（文本生成、复杂推理、多模态交互）</td><td>专用任务（分类、实体识别、轻量级部署）</td></tr><tr><td>部署成本</td><td>高昂（需云端算力支持，推理延迟高）</td><td>低成本（可嵌入手机、IoT设备）</td></tr><tr><td>能力特点</td><td>涌现能力（如零样本学习、上下文理解）</td><td>依赖任务微调，泛化能力有限</td></tr></tbody></table><h2 id="相关概念区分"><a href="#相关概念区分" class="headerlink" title="相关概念区分"></a><strong>相关概念区分</strong></h2><ul><li><strong>大模型（<code>Large Model</code>）：</strong>也称基础模型，即 <code>Foundation Model</code>，是指具有大量参数和复杂结构的机器学习模型，能够处理海量数据、完成各种复杂的任务，如<em>自然语言处理、计算机视觉、语音识别</em>等。</li><li>超大模型：超大模型是大模型的一个子集，它们的<strong>参数量远超过大模型</strong>。</li><li><strong>大语言模型（<code>Large Language Model</code>）：</strong>通常是具<strong>有大规模参数和计算能力的自然语言处理模型</strong>，例如 OpenAI 的 GPT-3 模型。这些模型可以通过大量的数据和参数进行训练，以生成人类类似的文本或回答自然语言的问题。大型语言模型在<strong>自然语言处理、文本生成和智能对话</strong>等领域有广泛应用。</li><li><strong><code>GPT（Generative Pre-trained Transformer）</code>：</strong>GPT 和 ChatGPT 都是基于 <code>Transformer</code> 架构的语言模型，但它们在设计和应用上存在区别，<code>GPT 模型</code>旨在<strong>生成自然语言文本并处理各种自然语言处理任务</strong>，如文本生成、翻译、摘要等。它通常在<strong>单向生成</strong>的情况下使用，即根据给定的文本生成连贯的输出。</li><li><strong><code>ChatGPT</code>：</strong>ChatGPT 则<strong>专注于对话和交互式对话</strong>。它经过特定的训练，以更好地处理多轮对话和上下文理解。ChatGPT 设计用于提供流畅、连贯和有趣的对话体验，以响应用户的输入并生成合适的回复。</li><li><strong>预训练模型（<code>Pre-trained Models</code>）：</strong> 在大规模数据上预训练的模型（如BERT、GPT），<strong>可通过微调适配下游任务</strong>。大模型多为预训练模型，但小模型也可预训练。</li><li><strong>基础模型（<code>Foundation Models</code>）：</strong> 斯坦福提出的概念，指<strong>通过自监督学习在大规模数据上训练、可适应多种任务的模型</strong>（如GPT-3）。大模型是基础模型的子集。</li><li><strong>多模态模型（<code>Multimodal Models</code>）：</strong> <strong>处理多种输入</strong>（文本、图像、音频）的模型（如CLIP、DALL·E）。大模型常具备多模态能力，但小模型也可设计为多模态。</li><li><strong>生成式AI（<code>Generative AI</code>）：</strong> 专注于<strong>生成内容</strong>的模型（如GPT、Stable Diffusion）。大模型常为生成式，但生成式模型不一定“大”（如小型GAN）</li></ul><h2 id="大模型的特点"><a href="#大模型的特点" class="headerlink" title="大模型的特点"></a><strong>大模型的特点</strong></h2><p><strong>参数规模超大</strong></p><ul><li><strong>量级</strong>：参数量从十亿（B）到万亿（T）级别，例如GPT-3（175B）、PaLM-2（340B）。</li><li><strong>意义</strong>：参数规模直接影响模型的“记忆容量”和复杂模式捕捉能力，是涌现（<code>Emergence</code>）能力（如逻辑推理、上下文学习）的基础。</li></ul><p><strong>训练数据海量</strong></p><ul><li><strong>数据量</strong>：通常使用<code>TB级</code>文本、图像等<strong>多模态数据</strong>（如GPT-3训练数据约45TB）。</li><li><strong>多样性</strong>：覆盖<strong>多语言、多领域</strong>（网页、书籍、代码等），降低模型对特定任务的过拟合风险。</li></ul><p><strong>计算资源密集</strong></p><ul><li><strong>训练成本</strong>：需数千张GPU/TPU并行训练数周，如GPT-3训练成本约460万美元。</li><li><strong>能耗问题</strong>：单次训练碳排放可达数百吨（如Bloom模型训练排放25吨CO₂）。</li></ul><p><strong>通用任务泛化</strong></p><ul><li><strong>少样本/零样本学习</strong>：无需微调即可完成新任务（如GPT-4直接生成代码）。</li><li><strong>多任务统一</strong>：同一模型处理文本生成、翻译、问答等多种任务（如PaLM-2）。</li></ul><p><strong>涌现能力（Emergent Abilities）</strong></p><ul><li><strong>不可预测性</strong>：模型在达到一定规模后突现出设计时未明确编程的能力，如：<ul><li><strong>上下文学习</strong>（In-context Learning）：通过示例提示调整输出。</li><li><strong>思维链</strong>（Chain-of-Thought）：分步骤推理解决数学问题。</li><li><strong>跨模态对齐</strong>：理解文本与图像的语义关联（如CLIP）。</li></ul></li></ul><h2 id="大模型的分类"><a href="#大模型的分类" class="headerlink" title="大模型的分类"></a><strong>大模型的分类</strong></h2><ul><li><strong>语言大模型（NLP）：</strong>是指在自然语言处理（<code>Natural Language Processing</code>，NLP）领域中的一类大模型，通常用于处理文本数据和理解自然语言。这类大模型的主要特点是它们在大规模语料库上进行了训练，以学习自然语言的各种语法、语义和语境规则。例如：GPT系列（OpenAI）、Bard（Google）、文心一言（百度）。</li><li><strong>视觉大模型（CV）：</strong>是指在计算机视觉（<code>Computer Vision</code>，CV）领域中使用的大模型，通常用于图像处理和分析。这类模型通过在大规模图像数据上进行训练，可以实现各种视觉任务，如图像分类、目标检测、图像分割、姿态估计、人脸识别等。例如：VIT 系列（Google）、文心UFO、华为盘古 CV、INTERN（商汤）。</li><li><strong>多模态大模型：</strong>是指<strong>能够处理多种不同类型数据的大模型</strong>，例如文本、图像、音频等多模态数据。这类模型结合了 NLP 和 CV 的能力，以实现对多模态信息的综合理解和分析，从而能够更全面地理解和处理复杂的数据。例如：DingoDB 多模向量数据库（九章云极 DataCanvas）、DALL-E(OpenAI)、悟空画画（华为）、midjourney。</li></ul><p>按照应用领域的不同，大模型主要可以分为 L0、L1、L2 三个层级：</p><ul><li><strong>通用大模型 L0：</strong>是指可以在<strong>多个领域和任务上通用</strong>的大模型。它们利用大算力、使用海量的开放数据与具有巨量参数的深度学习算法，在大规模无标注数据上进行训练，以寻找特征并发现规律，进而形成可“举一反三”的强大泛化能力，可在不进行微调或少量微调的情况下完成多场景任务，相当于 AI 完成了“通识教育”。</li><li><strong>行业大模型 L1：</strong>是指那些<strong>针对特定行业或领域</strong>的大模型。它们通常使用行业相关的数据进行预训练或微调，以提高在该领域的性能和准确度，相当于 AI 成为“行业专家”。</li><li><strong>垂直大模型 L2：</strong>是指那些<strong>针对特定任务或场景</strong>的大模型。它们通常使用任务相关的数据进行预训练或微调，以提高在该任务上的性能和效果。</li></ul><h2 id="大模型的泛化与微调"><a href="#大模型的泛化与微调" class="headerlink" title="大模型的泛化与微调"></a><strong>大模型的泛化与微调</strong></h2><p><strong>模型的泛化能力：</strong>是指一个模型在面对新的、未见过的数据时，能够正确理解和预测这些数据的能力。在机器学习和人工智能领域，模型的泛化能力是评估模型性能的重要指标之一。</p><p><strong>模型微调：</strong>给定预训练模型（Pre-trained model），基于模型进行微调（Fine Tune）。相对于从头开始训练(Training a model from scatch)，微调可以省去大量计算资源和计算时间，提高计算效率,甚至提高准确率。</p><p>模型微调的基本思想是<strong>使用少量带标签的数据对预训练模型进行再次训练，以适应特定任务</strong>。在这个过程中，模型的参数会根据新的数据分布进行调整。这种方法的好处在于，它利用了预训练模型的强大能力，同时还能够适应新的数据分布。因此，模型微调能够提高模型的泛化能力，减少过拟合现象。</p><p>常见的模型微调方法：</p><ul><li><strong><code>Fine-tuning</code>：</strong>这是最常用的微调方法。通过在预训练模型的最后一层添加一个新的分类层，然后根据新的数据集进行微调。</li><li><strong><code>Feature augmentation</code>：</strong>这种方法通过向数据中添加一些人工特征来增强模型的性能。这些特征可以是手工设计的，也可以是通过自动特征生成技术生成的。</li><li><strong><code>Transfer learning</code>：</strong>这种方法是使用在一个任务上训练过的模型作为新任务起点，然后对模型参数进行微调，以适应新任务。</li></ul><hr><h1 id="大型语言模型"><a href="#大型语言模型" class="headerlink" title="大型语言模型"></a><strong>大型语言模型</strong></h1><p>大型语言模型，一种能够以类似人类语言方式“说话”的软件。这些模型能获取上下文并生成不仅连贯而且感觉像是来自真实人类的回复。</p><p>这些语言模型通过分析大量的文本数据并学习语言使用的模式来工作。它们利用这些模式生成的文本几乎无法与人类所说或写的内容区分开来。例如，GPT-3模型拥有超过1750亿个参数，能够执行摘要生成、问答甚至创作等任务！</p><h2 id="大型语言模型的类型"><a href="#大型语言模型的类型" class="headerlink" title="大型语言模型的类型"></a><strong>大型语言模型的类型</strong></h2><ul><li><p><strong>基于自编码器的模型（Autoencoder-Based Model）</strong></p><p>它通过将输入文本编码为较低维度的表示，然后根据该表示生成新的文本。这类模型在<strong>文本摘要或内容生成</strong>等任务中表现出色。</p></li><li><p><strong>序列到序列模型（Sequence-to-Sequence Model）</strong></p><p>它接收一个输入序列（比如一个句子）并生成一个输出序列（比如翻译成另一种语言）。这些模型通常用于<strong>机器翻译和文本摘要</strong>。</p></li><li><p><strong>基于Transformer的模型（Transformer-Based Models）</strong></p><p>这些模型<strong>使用一种神经网络架构</strong>，非常擅长<strong>理解文本数据中的长距离依赖关系</strong>，使其在<strong>生成文本、翻译语言和回答问题</strong>等各种语言任务中非常有用。</p></li><li><p><strong>递归神经网络模型（Recursive Neural Network Models）</strong></p><p>递归神经网络模型被设计用于<strong>处理结构化数据</strong>，如句子的句法结构表示。这些模型对<strong>情感分析和自然语言推理</strong>等任务非常有用。</p></li><li><p><strong>分层模型（Hierarchical Models）</strong></p><p>分层模型被设计<strong>用于处理不同粒度级别的文本</strong>，例如句子、段落和文档。这些模型<strong>用于文档分类和主题建模</strong>等任务。</p></li></ul><h2 id="大型语言模型是如何工作的"><a href="#大型语言模型是如何工作的" class="headerlink" title="大型语言模型是如何工作的"></a><strong>大型语言模型是如何工作的</strong></h2><p>大型语言模型（LLM）架构是<code>Transformer</code>架构。典型的Transformer模型在处理输入数据时有四个主要步骤：</p><h3 id="词嵌入（Word-Embedding）"><a href="#词嵌入（Word-Embedding）" class="headerlink" title="词嵌入（Word Embedding）"></a><strong>词嵌入（Word Embedding）</strong></h3><p>它将单词表示为高维空间中的向量，使得相似的单词被归为一组。这有助于模型理解单词的含义，并基于此进行预测。</p><p>创建词嵌入<strong>涉及对大量文本数据进行神经网络训练</strong>，例如新闻文章或书籍。在训练过程中，网络学习根据单词在句子中的前后出现的词来预测其在给定上下文中出现的可能性。通过这个过程学习到的向量捕捉了语料库中不同单词之间的语义关系。</p><p>一旦创建了词嵌入，它们可以作为输入传递给在特定语言任务上进行训练的更大的神经网络，例如文本分类或机器翻译。通过使用词嵌入，模型能够更好地理解单词的含义，并基于这种理解做出更准确的预测。</p><h3 id="位置编码（Positional-Encoding）"><a href="#位置编码（Positional-Encoding）" class="headerlink" title="位置编码（Positional Encoding）"></a><strong>位置编码（Positional Encoding）</strong></h3><p>位置编码是<strong>帮助模型确定单词在序列中的位置</strong>的技术。它与单词的含义以及它们之间的关系无关。相反，位置编码主要用于跟踪单词的顺序。例如，当将句子”我喜欢猫”输入到模型时，位置编码可以帮助模型区分”我”是在句子的开头，而”猫”是在句子的结尾。这对于模型理解上下文和生成连贯的输出非常重要。</p><p>位置编码<strong>使用一系列特定模式的向量来表示单词的位置</strong>。这些向量与词嵌入的向量相加，以获得包含位置信息的表示。通过这种方式，模型能够将单词的位置作为输入的一部分，并在生成输出时保持一致。</p><h3 id="Transformers层"><a href="#Transformers层" class="headerlink" title="Transformers层"></a><strong>Transformers层</strong></h3><p>将Transformer层视为传统神经网络层之后的独立层。实际上，Transformer层通<strong>常作为附加层添加到传统神经网络架构</strong>中，以提高LLM在自然语言文本中<strong>建模长距离依赖性的能力</strong>。Transformer层通过<strong>并行处理</strong>整个输入序列而不是顺序处理来工作。它由两个基本组件组成：自注意力机制和前馈神经网络。</p><ul><li><p><strong>自注意力机制（Self-Attention Mechanism）</strong></p><p>它允许模型在生成输出时，有效地在输入序列的不同位置进行交互和关注。自注意力机制的关键思想是<strong>计算输入序列中每个单词之间的相关性</strong>，并将这些相关性用于权衡模型在每个位置的关注程度。</p><p>具体来说，自注意力机制计算每个单词与其他单词之间的相似度，然后将这些相似度转化为<strong>注意力权重</strong>。这些权重决定了模型在生成输出时对不同位置的输入进行关注的程度。这种自注意力机制使得模型能够根据输入序列中的上下文信息灵活地调整输出的生成。</p><p>传统的递归神经网络在处理长序列时容易出现<strong>梯度消失或梯度爆炸</strong>问题，而自注意力机制使得Transformer模型能够更好地捕捉长距离依赖关系。</p></li><li><p><strong>前馈神经网络（Feed-forward Neural Network）</strong></p><p>前馈神经网络<strong>对每个位置的表示进行进一步的处理</strong>。前馈神经网络是由多个全连接层组成的，其中每个层都有一组参数，用于将输入进行<strong>非线性变换</strong>。这个过程可以帮助模型在生成输出时引入更多的复杂性和灵活性。</p></li></ul><h3 id="文本生成"><a href="#文本生成" class="headerlink" title="文本生成"></a><strong>文本生成</strong></h3><p>LLM模型执行的最后一步；LLM经过训练和微调之后，该模型可用于根据提示或问题生成高度复杂的文本。模型通常通过种子输入进行”预热”，种子输入可以是几个单词、一个句子，甚至是一个完整段落。然后，LLM利用其学到的模式生成一个连贯且与上下文相关的回答。</p><p>文本生成依赖于一种称为<strong>自回归</strong>的技术，即<strong>模型根据它已生成的先前单词逐个生成输出序列的每个单词或标记</strong>。模型利用在训练期间学到的参数来计算下一个单词或标记的概率分布，然后选择最有可能的选择作为下一个输出。</p>]]></content>
    
    
    <summary type="html">人工智能大模型（简称“大模型”）是指由人工神经网络构建的一类具有大量参数的人工智能模型，主要类别包括：大语言模型、视觉大模型、多模态大模型以及基础科学大模型等。</summary>
    
    
    
    <category term="large model" scheme="https://southernfish.github.io/categories/large-model/"/>
    
    
    <category term="large model" scheme="https://southernfish.github.io/tags/large-model/"/>
    
  </entry>
  
  <entry>
    <title>Spring上下文</title>
    <link href="https://southernfish.github.io/2025/06/24/framwork/spring-context/"/>
    <id>https://southernfish.github.io/2025/06/24/framwork/spring-context/</id>
    <published>2025-06-24T02:16:36.000Z</published>
    <updated>2025-06-26T04:00:20.235Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring框架中，上下文（Context）是一个非常重要的概念，它代表了Spring应用的核心，用于管理应用程序中的bean（组件）的生命周期，配置信息等。Spring框架提供了多种类型的上下文实现，其中最常用的是ApplicationContext接口及其实现类。</p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>ApplicationContext是Spring框架中的核心接口，它继承自BeanFactory接口，提供了更丰富的功能。ApplicationContext不仅管理bean的创建和依赖注入，还提供了其他高级功能，如国际化和资源加载等。</p><h2 id="ApplicationContext的实现类"><a href="#ApplicationContext的实现类" class="headerlink" title="ApplicationContext的实现类"></a>ApplicationContext的实现类</h2><ol><li><p><strong>ClassPathXmlApplicationContext</strong>：从类路径下的XML文件中加载配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>FileSystemXmlApplicationContext</strong>：从文件系统中的XML文件中加载配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;path/to/applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>AnnotationConfigApplicationContext</strong>：用于加载基于Java的配置类（使用<code>@Configuration</code>注解的类）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br></pre></td></tr></table></figure></li><li><p><strong>XmlWebApplicationContext</strong>：专门为Web应用设计的<code>ApplicationContext</code>实现，用于加载Web应用的XML配置文件。</p></li><li><p><strong>AnnotationConfigWebApplicationContext</strong>：用于Web应用，加载基于Java的配置类。</p></li></ol><h2 id="使用ApplicationContext"><a href="#使用ApplicationContext" class="headerlink" title="使用ApplicationContext"></a>使用ApplicationContext</h2><ol><li><p><strong>加载配置文件或类</strong></p><ul><li><p><strong>XML配置：</strong>通过<code>ClassPathXmlApplicationContext</code>或<code>FileSystemXmlApplicationContext</code>加载XML配置文件。  </p></li><li><p><strong>Java配置：</strong>通过<code>AnnotationConfigApplicationContext</code>加载使用<code>@Configuration</code>注解的类。   </p></li></ul></li><li><p><strong>获取Bean</strong></p><p>一旦上下文被创建，你可以通过它来获取需要的<code>bean</code>或者<code>使用名称</code>：。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> context.getBean(MyBean.class); <span class="comment">// 获取bean</span></span><br><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> (MyBean) context.getBean(<span class="string">&quot;myBean&quot;</span>); <span class="comment">// 获取使用名称</span></span><br></pre></td></tr></table></figure></li><li><p><strong>关闭上下文</strong></p><p>当Spring应用结束时，应该关闭上下文以释放资源或者使用自动关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((ConfigurableApplicationContext) context).close(); <span class="comment">// 关闭上下文</span></span><br><span class="line">((AbstractApplicationContext) context).registerShutdownHook(); <span class="comment">// 注册JVM关闭钩子，自动关闭上下文</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><ul><li><strong>国际化</strong>：通过<code>MessageSource</code>获取本地化消息。</li><li><strong>事件发布</strong>：发布和监听应用事件。</li><li><strong>资源管理</strong>：加载文件资源，如属性文件、XML文件等。</li><li><strong>环境抽象</strong>：提供对不同环境的抽象，如开发、测试、生产等。</li></ul>]]></content>
    
    
    <summary type="html">‌在Spring框架中，在处理上下文（Context）时，通常指的是Spring应用中的ApplicationContext。‌</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="Spring" scheme="https://southernfish.github.io/categories/Framwork/Spring/"/>
    
    
    <category term="Spring Boot" scheme="https://southernfish.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring注解</title>
    <link href="https://southernfish.github.io/2025/06/23/framwork/spring-annotation/"/>
    <id>https://southernfish.github.io/2025/06/23/framwork/spring-annotation/</id>
    <published>2025-06-23T13:10:36.000Z</published>
    <updated>2025-06-26T04:00:20.235Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring框架中，注解是一种非常重要的特性，它极大地简化了配置和开发过程。‌Spring注解是Spring框架中用于简化配置和开发的核心机制，主要分为组件管理、依赖注入、配置类、AOP、Web开发等类别‌。</p><h1 id="Spring注解的底层实现逻辑"><a href="#Spring注解的底层实现逻辑" class="headerlink" title="Spring注解的底层实现逻辑"></a>Spring注解的底层实现逻辑</h1><h2 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h2><p>Java注解的底层实现逻辑主要包括<strong>定义注解、使用注解和通过反射获取注解</strong>。具体源码分析转载自 <a href="https://blog.csdn.net/fk1778770286/article/details/148581060">Java注解底层实现原理 - 源码分析</a></p><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p>注解是通过<code>@interface</code>关键字定义的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 默认值</span></span><br><span class="line">    <span class="type">int</span>[] numbers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>@Target</code>和<code>@Retention</code>是元注解，分别指定了注解的应用目标和保留策略。<code>ElementType.TYPE</code>表示该注解可以应用于类、接口或枚举上，<code>RetentionPolicy.RUNTIME</code>表示注解在运行时可以通过反射获取‌</p><h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p>使用注解时，只需在声明处添加相应的注解即可。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> TestClass.class.getAnnotation(MyAnnotation.class);</span><br><span class="line">        System.out.println(annotation.value()); <span class="comment">// 输出: hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码通过反射获取了<code>TestClass</code>类上的<code>MyAnnotation</code>注解，并打印了其<code>value</code>属性的值‌。</p><h3 id="反射获取注解"><a href="#反射获取注解" class="headerlink" title="反射获取注解"></a>反射获取注解</h3><p>通过反射，可以在运行时获取类、方法、参数等上的注解信息。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = TestClass.class;</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line">System.out.println(annotation.value());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取所有methods</span></span><br><span class="line">    Method[] methods = MyAnnotation.class.getClassLoader()</span><br><span class="line">          .loadClass((<span class="string">&quot;com.pdai.java.annotation.TestMyAnnotation&quot;</span>))</span><br><span class="line">          .getMethods();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(MyAnnotation.class)) &#123; <span class="comment">// 方法上是否有MyAnnotation注解</span></span><br><span class="line">            <span class="type">MyAnnotation</span> <span class="variable">anno</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class); <span class="comment">// 获取MyAnnotation对象信息</span></span><br><span class="line">            System.out.println(anno.title()); <span class="comment">// 访问注解的属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="源码分析注解的底层实现"><a href="#源码分析注解的底层实现" class="headerlink" title="源码分析注解的底层实现"></a>源码分析注解的底层实现</h2><p>从 <code>MyAnnotation annotation = clazz.getAnnotation(MyAnnotation.class);</code> 开始分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#getAnnotation】</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; A <span class="title function_">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(annotationClass);</span><br><span class="line">    <span class="keyword">return</span> (A) annotationData().annotations.get(annotationClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>annotationData().annotations.get(annotationClass);</code>：调用 <code>annotationData()</code> 方法获取<strong>当前类的注解数据</strong>，然后从 annotations 映射中获取<strong>指定类型的注解实例</strong></li><li><code>(A)</code>：将获取到的<strong>注解实例强制转换为泛型类型 A</strong></li></ul><h3 id="获取注解数据集-annotationData"><a href="#获取注解数据集-annotationData" class="headerlink" title="获取注解数据集 annotationData"></a>获取注解数据集 annotationData</h3><p>使用 <code>Atomic.casAnnotationData</code> 方法（基于 CAS <a href="https://so.csdn.net/so/search?q=%E4%B9%90%E8%A7%82%E9%94%81&spm=1001.2101.3001.7020">乐观锁</a>机制）尝试将新的 AnnotationData 对象更新到当前类中。若更新成功，返回新的 AnnotationData 对象；若失败，循环会继续重试，直到成功为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#annotationData】</span></span><br><span class="line"><span class="comment">/* 获取当前类的注解数据对象。如果缓存的注解数据已过期或不存在，则创建新的注解数据对象并尝试更新到缓存中。</span></span><br><span class="line"><span class="comment"> * 该方法使用循环重试和 CAS 操作来保证数据的一致性和线程安全。</span></span><br><span class="line"><span class="comment"> * @return 当前类的注解数据对象  */</span></span><br><span class="line"><span class="keyword">private</span> AnnotationData <span class="title function_">annotationData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="comment">// 进入无限循环，实现重试机制，直到成功获取有效的注解数据</span></span><br><span class="line">        <span class="type">AnnotationData</span> <span class="variable">annotationData</span> <span class="operator">=</span> <span class="built_in">this</span>.annotationData; <span class="comment">// 获取当前缓存的注解数据对象</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">classRedefinedCount</span> <span class="operator">=</span> <span class="built_in">this</span>.classRedefinedCount; <span class="comment">// 获取当前类的重定义计数，该值在类被重新定义时会递增</span></span><br><span class="line">        <span class="keyword">if</span> (annotationData != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            annotationData.redefinedCount == classRedefinedCount) &#123; <span class="comment">// 检查缓存的注解数据是否存在且未过期</span></span><br><span class="line">            <span class="keyword">return</span> annotationData; <span class="comment">// 若注解数据有效，直接返回缓存的对象</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若缓存的注解数据为空或已过期，乐观地创建一个新的注解数据对象</span></span><br><span class="line">        <span class="type">AnnotationData</span> <span class="variable">newAnnotationData</span> <span class="operator">=</span> createAnnotationData(classRedefinedCount);</span><br><span class="line">        <span class="comment">// 尝试使用 CAS（Compare-And-Swap）操作将新的注解数据对象更新到缓存中</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic.casAnnotationData(<span class="built_in">this</span>, annotationData, newAnnotationData)) &#123;</span><br><span class="line">            <span class="keyword">return</span> newAnnotationData; <span class="comment">// 若 CAS 操作成功，说明新的注解数据已成功更新到缓存，返回该对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 CAS 操作失败，说明在创建新对象期间，其他线程已经更新了注解数据，进入下一次循环重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建注解数据集-createAnnotationData"><a href="#构建注解数据集-createAnnotationData" class="headerlink" title="构建注解数据集 createAnnotationData"></a>构建注解数据集 createAnnotationData</h3><ul><li>调用 <code>AnnotationParser.parseAnnotations</code> 方法，解析当前类的原始注解数据，将结果存储在 <code>declaredAnnotations</code> 映射中，<em>键为注解类，值为注解实例</em></li><li><strong>处理父类继承注解：</strong>父类存在，获取父类的注解数据中的注解映射 <code>superAnnotations</code>。遍历 superAnnotations，对于每个注解，检查其是否使用了<code>@Inherited</code>元注解（通过 <code>AnnotationType.getInstance(annotationClass).isInherited()</code> 判断）。若使用了 @Inherited 元注解，且 annotations 为 null，则进行懒初始化，创建一个 LinkedHashMap 来存储继承的注解。将继承的注解添加到 annotations 映射中</li><li><strong>合并注解：</strong>若 annotations 仍为 null，说明没有继承的注解，直接将 annotations 指向 declaredAnnotations。若存在继承的注解，将 declaredAnnotations 中的注解添加到 annotations 中，当前类声明的注解会覆盖继承的注解</li><li><strong>总结：</strong>该方法的核心逻辑是解析当前类的声明注解，若父类存在，获取父类中可继承的注解，将两者合并后创建 AnnotationData 对象。这样可以保证 AnnotationData 对象包含当前类完整的注解信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#createAnnotationData】</span></span><br><span class="line"><span class="keyword">private</span> AnnotationData <span class="title function_">createAnnotationData</span><span class="params">(<span class="type">int</span> classRedefinedCount)</span> &#123;</span><br><span class="line">    <span class="comment">// ------------------------ 处理父类继承注解 ----------------------------------</span></span><br><span class="line">    <span class="comment">// 解析当前类的原始注解数据，将结果存储在 declaredAnnotations 映射中</span></span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; declaredAnnotations =</span><br><span class="line">        AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), <span class="built_in">this</span>);</span><br><span class="line">        </span><br><span class="line">    Class&lt;?&gt; superClass = getSuperclass(); <span class="comment">// 父类获取</span></span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; annotations = <span class="literal">null</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (superClass != <span class="literal">null</span>) &#123; <span class="comment">// 若父类存在</span></span><br><span class="line">        Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; superAnnotations =</span><br><span class="line">            superClass.annotationData().annotations; <span class="comment">// 获取父类的注解数据中的注解映射</span></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; e : superAnnotations.entrySet()) &#123;</span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass = e.getKey();</span><br><span class="line">            <span class="comment">// 判断每个注解是否使用了元注解@Inherited</span></span><br><span class="line">            <span class="keyword">if</span> (AnnotationType.getInstance(annotationClass).isInherited()) &#123; </span><br><span class="line">                <span class="keyword">if</span> (annotations == <span class="literal">null</span>) &#123; <span class="comment">// lazy construction （懒初始化）</span></span><br><span class="line">                    <span class="comment">// 创建一个 LinkedHashMap 来存储继承的注解</span></span><br><span class="line">                    annotations = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;((Math.max(</span><br><span class="line">                            declaredAnnotations.size(),</span><br><span class="line">                            Math.min(<span class="number">12</span>, declaredAnnotations.size() + superAnnotations.size())</span><br><span class="line">                        ) * <span class="number">4</span> + <span class="number">2</span>) / <span class="number">3</span></span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将继承的注解添加到 annotations 映射中</span></span><br><span class="line">                annotations.put(annotationClass, e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------ 处理父类继承注解 --------------------------------</span></span><br><span class="line">    <span class="comment">// --------------------------- 合并注解 ----------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (annotations == <span class="literal">null</span>) &#123; <span class="comment">// annotations 仍为 null，说明没有继承的注解</span></span><br><span class="line">        <span class="comment">// no inherited annotations -&gt; share the Map with declaredAnnotations</span></span><br><span class="line">        annotations = declaredAnnotations;</span><br><span class="line">    <span class="comment">// --------------------------- 合并注解 ----------------------------------</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 存在继承的注解 添加后，当前类声明的注解会覆盖继承的注解</span></span><br><span class="line">        <span class="comment">// at least one inherited annotation -&gt; declared may override inherited</span></span><br><span class="line">        annotations.putAll(declaredAnnotations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationData</span>(annotations, declaredAnnotations, classRedefinedCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取当前类的原始注解数据-getRawAnnotations"><a href="#获取当前类的原始注解数据-getRawAnnotations" class="headerlink" title="获取当前类的原始注解数据 getRawAnnotations"></a>获取当前类的原始注解数据 getRawAnnotations</h3><ul><li><strong>native 关键字</strong>：在 Java 里，<code>native</code> 关键字用于声明本地方法。本地方法并非用 Java 实现，而是借助其他编程语言（像 C、C++）实现。Java 虚拟机（JVM）会负责加载并调用这些本地方法。通常，本地方法用于和底层系统交互，或实现对性能要求极高的操作。</li><li><strong>byte[] 返回类型</strong>：该方法返回一个字节数组 byte[]。这意味着<strong>方法会返回当前类原始注解数据的字节表示形式</strong>。原始注解数据是注解在字节码层面的存储形式，可能包含<strong>注解类型、注解属性值</strong>等信息。</li><li><strong>元注解</strong>：作用于自定义注解类型的注解类，在JDK 1.5中提供了4个标准的元注解：<code>@Target，@Retention，@Documented，@Inherited</code>，在JDK 1.8中提供了两个元注解 <code>@Repeatable</code>和<code>@Native</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#getRawAnnotations】</span></span><br><span class="line"><span class="keyword">native</span> <span class="type">byte</span>[] getRawAnnotations();</span><br></pre></td></tr></table></figure><h3 id="获取当前类对应的常量池-getConstantPool"><a href="#获取当前类对应的常量池-getConstantPool" class="headerlink" title="获取当前类对应的常量池 getConstantPool"></a>获取当前类对应的常量池 getConstantPool</h3><p><code>getConstantPool</code> 方法是一个本地方法，其作用是获取当前类对应的常量池对象。由于需要直接访问 JVM 内部的数据结构，所以采用本地方法实现。调用该方法后，能得到一个 <code>ConstantPool</code> 对象，进而访问常量池中的常量信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#getConstantPool】</span></span><br><span class="line"><span class="keyword">native</span> ConstantPool <span class="title function_">getConstantPool</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="解析当前类的原始注解数据-parseAnnotations"><a href="#解析当前类的原始注解数据-parseAnnotations" class="headerlink" title="解析当前类的原始注解数据 parseAnnotations"></a>解析当前类的原始注解数据 parseAnnotations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationParser#parseAnnotations】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; parseAnnotations(</span><br><span class="line">        <span class="type">byte</span>[] var0, ConstantPool var1, Class&lt;?&gt; var2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (var0 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parseAnnotations2(var0, var1, var2, (Class[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BufferUnderflowException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Unexpected end of annotations.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; parseAnnotations2(</span><br><span class="line">        <span class="type">byte</span>[] var0, ConstantPool var1, Class&lt;?&gt; var2, Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;[] var3) &#123;</span><br><span class="line">    <span class="type">LinkedHashMap</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">var5</span> <span class="operator">=</span> ByteBuffer.wrap(var0);</span><br><span class="line">    <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> var5.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var7</span> <span class="operator">=</span> <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">        <span class="type">Annotation</span> <span class="variable">var8</span> <span class="operator">=</span> parseAnnotation2(var5, var1, var2, <span class="literal">false</span>, var3);</span><br><span class="line">        <span class="keyword">if</span> (var8 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">var9</span> <span class="operator">=</span> var8.annotationType();</span><br><span class="line">            <span class="keyword">if</span> (AnnotationType.getInstance(var9).retention() == RetentionPolicy.RUNTIME &amp;&amp; var4.put(var9, var8) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Duplicate annotation for class: &quot;</span> + var9 + <span class="string">&quot;: &quot;</span> + var8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体会调用到下面的 <code>parseAnnotation2</code> 方法，该方法主要都是解析注解里面的信息，解析出来的值最终会给到我们去创建代理对象用。我们重点关注的是 <code>annotationForMap</code> 这个方法，该方法里面就是通过动态代理来创建注解实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationParser#parseAnnotation2】</span></span><br><span class="line"><span class="comment">/* 解析注解字节数据，生成注解实例。</span></span><br><span class="line"><span class="comment"> * @param var0 包含注解数据的字节缓冲区</span></span><br><span class="line"><span class="comment"> * @param var1 常量池对象，用于获取注解相关的常量信息</span></span><br><span class="line"><span class="comment"> * @param var2 注解所属的类</span></span><br><span class="line"><span class="comment"> * @param var3 若为 true，在遇到类型不存在异常时抛出异常；否则跳过该注解</span></span><br><span class="line"><span class="comment"> * @param var4 要解析的注解类型数组，若为 null 则解析所有注解</span></span><br><span class="line"><span class="comment"> * @return 解析得到的注解实例，若跳过解析则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Annotation <span class="title function_">parseAnnotation2</span><span class="params">(</span></span><br><span class="line"><span class="params">    ByteBuffer var0, ConstantPool var1, Class&lt;?&gt; var2, <span class="type">boolean</span> var3, Class&lt;? extends Annotation&gt;[] var4)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> var0.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>; <span class="comment">// 从字节缓冲区读取注解类型的常量池索引</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 用于存储临时对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">var7</span> <span class="operator">=</span> <span class="string">&quot;[unknown]&quot;</span>; <span class="comment">// 注解类型名称，初始为未知</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试获取注解类型的类对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var7 = var1.getUTF8At(var5); <span class="comment">// 从常量池中获取注解类型的名称</span></span><br><span class="line">            var21 = parseSig(var7, var2); <span class="comment">// 解析签名，获取注解类型的类对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var18) &#123;</span><br><span class="line">            var21 = var1.getClassAt(var5);  <span class="comment">// 若解析签名失败，直接从常量池中获取类对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError var19) &#123; <span class="comment">// 若找不到类定义</span></span><br><span class="line">        <span class="keyword">if</span> (var3) &#123; <span class="comment">// 若 var3 为 true，抛出类型不存在异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeNotPresentException</span>(var7, var19);</span><br><span class="line">        &#125;</span><br><span class="line">        skipAnnotation(var0, <span class="literal">false</span>); <span class="comment">// 跳过当前注解的解析</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TypeNotPresentException var20) &#123; <span class="comment">// 若类型不存在</span></span><br><span class="line">        <span class="keyword">if</span> (var3) &#123; <span class="comment">// 若 var3 为 true，抛出类型不存在异常</span></span><br><span class="line">            <span class="keyword">throw</span> var20;</span><br><span class="line">        &#125;</span><br><span class="line">        skipAnnotation(var0, <span class="literal">false</span>); <span class="comment">// 跳过当前注解的解析</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否只需要解析特定类型的注解</span></span><br><span class="line">    <span class="keyword">if</span> (var4 != <span class="literal">null</span> &amp;&amp; !contains(var4, var21)) &#123; <span class="comment">// 若当前注解类型不在需要解析的类型列表中，跳过解析</span></span><br><span class="line">        skipAnnotation(var0, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 用于存储临时对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var23 = AnnotationType.getInstance(var21); <span class="comment">// 获取注解类型的元数据</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var17) &#123; <span class="comment">// 若获取元数据失败，跳过当前注解的解析</span></span><br><span class="line">            skipAnnotation(var0, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">var9</span> <span class="operator">=</span> var23.memberTypes(); <span class="comment">// 获取注解类型的成员类型映射</span></span><br><span class="line">        <span class="type">LinkedHashMap</span> <span class="variable">var10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(var23.memberDefaults()); <span class="comment">// 初始化注解成员值映射，使用默认值填充</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">var11</span> <span class="operator">=</span> var0.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>; <span class="comment">// 从字节缓冲区读取注解成员的数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var12</span> <span class="operator">=</span> <span class="number">0</span>; var12 &lt; var11; ++var12) &#123;  <span class="comment">// 遍历所有注解成员</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">var13</span> <span class="operator">=</span> var0.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>; <span class="comment">// 从字节缓冲区读取成员名称的常量池索引</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">var14</span> <span class="operator">=</span> var1.getUTF8At(var13); <span class="comment">// 从常量池中获取成员名称</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">var15</span> <span class="operator">=</span> (Class)var9.get(var14); <span class="comment">// 获取成员的类型</span></span><br><span class="line">            <span class="keyword">if</span> (var15 == <span class="literal">null</span>) &#123; <span class="comment">// 若成员类型不存在，跳过该成员值的解析</span></span><br><span class="line">                skipMemberValue(var0);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">var16</span> <span class="operator">=</span> parseMemberValue(var15, var0, var1, var2); <span class="comment">// 解析成员值</span></span><br><span class="line">                <span class="comment">// 若成员值类型不匹配，设置异常代理的成员信息</span></span><br><span class="line">                <span class="keyword">if</span> (var16 <span class="keyword">instanceof</span> AnnotationTypeMismatchExceptionProxy) &#123;</span><br><span class="line"> ((AnnotationTypeMismatchExceptionProxy)var16).setMember((Method)var23.members().get(var14));</span><br><span class="line">                &#125;</span><br><span class="line">                var10.put(var14, var16); <span class="comment">// 将解析得到的成员值放入映射中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> annotationForMap(var21, var10); <span class="comment">// 根据注解类型和成员值映射生成注解实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过java动态代理实例化注解代理对象"><a href="#通过java动态代理实例化注解代理对象" class="headerlink" title="通过java动态代理实例化注解代理对象"></a>通过java动态代理实例化注解代理对象</h3><ul><li><code>AccessController.doPrivileged</code>：该方法用于在特权环境下执行特定操作。在 Java 安全模型里，有些操作需要特定权限才能执行，使用 <code>doPrivileged</code> 可确保代码在足够权限下运行</li><li><code>annotationForMap</code> 方法利用 Java 的反射和代理机制，根据给定的注解类型和成员值映射，动态创建一个注解实例。借助 <code>AccessController</code> 确保操作在特权环境下执行，最终返回一个实现了指定注解接口的代理对象（此处需要注意，用的代理类 <code>AnnotationInvocationHandler</code>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationParser#annotationForMap】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Annotation <span class="title function_">annotationForMap</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> Class&lt;? extends Annotation&gt; var0, <span class="keyword">final</span> Map&lt;String, Object&gt; var1)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (Annotation)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Annotation&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Annotation <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Annotation)Proxy.newProxyInstance(var0.getClassLoader(), </span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;var0&#125;, </span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">AnnotationInvocationHandler</span>(var0, var1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-AnnotationInvocationHandler"><a href="#实现-AnnotationInvocationHandler" class="headerlink" title="实现 AnnotationInvocationHandler"></a>实现 AnnotationInvocationHandler</h3><ul><li><code>AnnotationInvocationHandler</code> 类中的 invoke 方法，该类实现了 <code>InvocationHandler</code> 接口。<strong>在 Java 动态代理机制里，InvocationHandler 接口的 invoke 方法是核心</strong>，当调用代理对象的方法时，实际上会调用 invoke 方法来处理</li><li><strong>处理特殊方法调用：</strong><ul><li>若被调用方法是 toString，调用 <code>toStringImpl</code> 方法生成注解的字符串表示并返回</li><li>若被调用方法是 hashCode，调用 <code>hashCodeImpl</code> 方法计算注解的哈希码并返回</li><li>若被调用方法是 <code>annotationType</code>，返回注解的类型 <code>this.type</code></li></ul></li><li><strong>处理注解成员方法调用：</strong><ul><li>若被调用方法是注解的成员方法，从 <code>memberValues</code> 映射中获取对应的值</li><li>若值为 null，说明注解实例缺少该成员的值，抛出 <code>IncompleteAnnotationException</code> 异常</li><li>若值是 <code>ExceptionProxy</code> 类型，调用 <code>generateException</code> 方法抛出异常</li><li>若值是数组且不为空，调用 <code>cloneArray</code> 方法克隆数组，避免外部修改原始数组，最后返回该值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationInvocationHandler】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6182022883658399397L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Method[] memberMethods = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = var1;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = var2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">var4</span> <span class="operator">=</span> var2.getName();</span><br><span class="line">    Class[] var5 = var2.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (var4.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.equalsImpl(var3[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var5.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (var4) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.toStringImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.hashCodeImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.type;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.get(var4);</span><br><span class="line">                <span class="keyword">if</span> (var6 == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(<span class="built_in">this</span>.type, var4);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var6 <span class="keyword">instanceof</span> ExceptionProxy) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ((ExceptionProxy)var6).generateException();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != <span class="number">0</span>) &#123;</span><br><span class="line">                        var6 = <span class="built_in">this</span>.cloneArray(var6);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> var6;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="其他相关问题"><a href="#其他相关问题" class="headerlink" title="其他相关问题"></a>其他相关问题</h1><h2 id="注解如何生效"><a href="#注解如何生效" class="headerlink" title="注解如何生效"></a>注解如何生效</h2><p><strong>编译期扫描处理，运行期反射处理。编译期扫描处理一般只有Java内置注解会用到</strong>，比如<code>@Override</code>修饰的方法，编译器会检查父类是否有相同的方法。大部分自定义的注解，都是在运行期通过反射拿到并处理。</p><h2 id="运行期如何获取注解"><a href="#运行期如何获取注解" class="headerlink" title="运行期如何获取注解"></a>运行期如何获取注解</h2><p>运行时注解<strong>存放在class文件中的<code>attributes属性表</code>中</strong>。<br><strong>反射获取注解的核心</strong>在：<code>java.lang.reflect</code>下的 <strong><code>AnnotatedElement</code><strong>接口，而</strong><code>AnnotatedElement</code></strong> 接口是所有程序元素（<code>Class</code>、<code>Method</code>和<code>Constructor</code>）的父接口。</p><h2 id="Spring加与不加注解的区别"><a href="#Spring加与不加注解的区别" class="headerlink" title="Spring加与不加注解的区别"></a>Spring加与不加注解的区别</h2><ol><li>‌<strong>配置方式</strong>‌：<ul><li>‌<strong>不加注解</strong>‌：可以<strong>通过XML配置文件来定义bean</strong>，这种方式更加直观，但需要编写XML文件。</li><li>‌<strong>加注解</strong>‌：通过使用<code>@Configuration</code>和<code>@Bean</code>注解来定义bean，这种方式更加灵活，代码更加简洁，且易于维护和修改。</li></ul></li><li>‌<strong>管理方式</strong>‌：<ul><li>‌<strong>不加注解</strong>‌：需要手动编写XML配置文件，并通过XML配置文件来管理bean的创建和依赖关系。</li><li>‌<strong>加注解</strong>‌：通过注解来定义bean，Spring框架在启动时会扫描这些注解并自动创建和管理bean，减少了手动配置的工作量。</li></ul></li></ol><hr><h1 id="常用注解及解释"><a href="#常用注解及解释" class="headerlink" title="常用注解及解释"></a>常用注解及解释</h1><h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><ul><li>‌**<code>@Component</code>**‌：用于把当前类对象存入Spring容器中。<code>@Controller、@Service、@Repository</code>都可以称为@Component，它们分别用于控制层、业务层和数据访问层。</li><li>‌**<code>@Autowired</code>**‌：自动按照类型注入Spring容器中的bean。它可以作用在变量、setter方法或构造函数上。</li><li>‌**<code>@Qualifier</code>**‌：在按照类型注入的基础上，通过名称进行注入。通常与<code>@Autowired</code>一起使用，用于解决相同类型bean的注入冲突。</li><li>‌**<code>@Inject</code>**‌：由<code>JSR-330</code>提供，用法与<code>@Autowired</code>相似，但它是Java标准的一部分，而@Autowired是Spring特有的。</li><li>‌**<code>@Resource</code>**‌：由<code>JSR-250</code>提供，按照bean的id进行注入，可以独立使用。</li><li>‌**<code>@Primary</code>**‌：当存在多个相同类型的bean时，标记首选的bean进行注入。</li></ul><h2 id="Java配置类相关注解"><a href="#Java配置类相关注解" class="headerlink" title="Java配置类相关注解"></a>Java配置类相关注解</h2><ul><li>‌**<code>@Configuration</code>**‌：声明当前类为配置类，相当于传统的XML配置文件。</li><li>‌**<code>@Bean</code>**‌：注解在方法上，声明当前方法的返回值为一个bean，替代XML中的<code>&lt;bean&gt;</code>标签。</li><li>‌**<code>@ComponentScan</code>**‌：用于指定Spring在创建容器时要扫描的包，以找到带有<code>@Component、@Repository、@Service、@Controller</code>等注解的类，并注册为bean。</li></ul><h2 id="切面（AOP）相关注解"><a href="#切面（AOP）相关注解" class="headerlink" title="切面（AOP）相关注解"></a>切面（AOP）相关注解</h2><ul><li>‌**<code>@Aspect</code>**‌：声明一个切面。</li><li>‌**<code>@After</code>**‌：在目标方法执行之后执行。</li><li>‌**<code>@Before</code>**‌：在目标方法执行之前执行。</li><li>‌**<code>@Around</code>**‌：在目标方法执行之前和之后执行，可以围绕目标方法创建一个“拦截器”。</li><li>‌**<code>@PointCut</code>**‌：声明一个切点，即指定哪些方法将被增强。</li></ul><h2 id="配置和环境相关注解"><a href="#配置和环境相关注解" class="headerlink" title="配置和环境相关注解"></a>配置和环境相关注解</h2><ul><li>‌**<code>@Value</code>**‌：用于注入基本类型和String类型的数据，支持使用<code>Spring EL</code>表达式。</li><li>‌**<code>@Profile</code>**‌：指定组件在哪个环境的情况下才能被注册到容器中。</li><li>‌**<code>@Conditional</code>**‌：通过实现Condition接口，并重写<code>matches</code>方法，从而决定该bean是否被实例化。</li></ul><h2 id="其他常用注解"><a href="#其他常用注解" class="headerlink" title="其他常用注解"></a>其他常用注解</h2><ul><li>‌**<code>@Lazy</code>**‌：用于延迟初始化bean，即只有在第一次使用时才会创建和初始化。</li><li>‌**<code>@Scope</code><strong>‌：用于指定bean的作用范围，如</strong>单例（singleton）或多例（prototype）**。</li><li>‌**<code>@EnableAsync</code>**‌：在配置类中通过此注解开启对异步任务的支持。</li><li>‌**<code>@Async</code>**‌：在实际执行的bean方法使用该注解来声明其是一个异步任务。</li><li>‌**<code>@EnableScheduling</code>**‌：在配置类上使用，开启计划任务的支持。</li><li>‌**<code>@Scheduled</code>**‌：用于声明一个定时任务。</li></ul>]]></content>
    
    
    <summary type="html">在Spring框架中，注解是一种非常重要的特性，它极大地简化了配置和开发过程。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="Spring" scheme="https://southernfish.github.io/categories/Framwork/Spring/"/>
    
    
    <category term="Spring Boot" scheme="https://southernfish.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>使用多线程解决问题</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-thread-impl/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-thread-impl/</id>
    <published>2025-06-23T12:25:36.000Z</published>
    <updated>2025-06-26T04:00:20.237Z</updated>
    
    <content type="html"><![CDATA[<p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同<a href="https://baike.baidu.com/item/%E4%B8%80%E6%97%B6%E9%97%B4/3618565?fromModule=lemma_inlink">一时间</a>执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括<a href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA/10375153?fromModule=lemma_inlink">对称多处理机</a>、<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%A0%B8%E5%BF%83/1013410?fromModule=lemma_inlink">多核心</a>处理器以及<a href="https://baike.baidu.com/item/%E8%8A%AF%E7%89%87%E7%BA%A7%E5%A4%9A%E5%A4%84%E7%90%86/924724?fromModule=lemma_inlink">芯片级多处理</a>或<a href="https://baike.baidu.com/item/%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B/22689341?fromModule=lemma_inlink">同时多线程</a>处理器。在一个程序中，这些独立运行的程序片段叫作“<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fromModule=lemma_inlink">线程</a>”（Thread），利用它编程的概念就叫作“多线程处理” 。本文简单记录一些关于线程、多线程的问题。本文记录了关于一些常见多线程业务问题处理。</p><h2 id="多线程问题-1"><a href="#多线程问题-1" class="headerlink" title="多线程问题 1"></a>多线程问题 1</h2><p><strong>问题：</strong>100个线程并发向1个银行账户中存入1元钱,并在全部完成后，打印银行账户的金额。</p><p><strong>思路：</strong>创建100个线程（<code>线程池</code>）；保证线程安全，同一时刻只有一个线程对账户进行操作（<code>Lock</code> 或者 <code>synchronized</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种加锁 synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="comment">// 获得账户余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁 存钱方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> <span class="built_in">this</span>.balance + money;</span><br><span class="line">        <span class="built_in">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种锁 lock</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="comment">// 获得账户余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁 存钱方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        reentrantLock.lock;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newBalance = balance + money;</span><br><span class="line">            balance = newBalance;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">          reentrantLock.unlock();  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存钱的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadSaveAccount</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TheadSaveAccount</span><span class="params">(Account account, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁 整个账户</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            account.deposit(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadSave</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            service.execute( <span class="keyword">new</span> <span class="title class_">TheadSaveAccount</span>(account, <span class="number">1</span>) );</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">        <span class="keyword">if</span> (service.isTerminated()) &#123;</span><br><span class="line">            System.out.println(account.getBalance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多线程是并行化的一种形式，或者是拆分工作以便同时进行处理。线程化的程序将工作拆分到多个软件线程，而不是将大量工作交给单个内核。这些线程由不同的 CPU 内核并行处理，以节省时间。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>RestfulApi</title>
    <link href="https://southernfish.github.io/2025/06/23/framwork/RestfulApi/"/>
    <id>https://southernfish.github.io/2025/06/23/framwork/RestfulApi/</id>
    <published>2025-06-23T08:16:36.000Z</published>
    <updated>2025-06-26T04:00:20.234Z</updated>
    
    <content type="html"><![CDATA[<p>RESTful（Representational State Transfer，表述性状态转移）是一种基于HTTP协议的架构风格，利用URI、HTTP方法（如GET、POST、PUT、DELETE等）以及表示层数据格式（如JSON）来创建具有高度可扩展性的服务‌。其核心原则包括资源导向设计、无状态通信、标准HTTP方法使用（GET/POST/PUT/DELETE）以及统一接口规范，广泛应用于微服务、移动应用和物联网等领域。</p><h2 id="什么是-RESTful-API"><a href="#什么是-RESTful-API" class="headerlink" title="什么是 RESTful API"></a>什么是 RESTful API</h2><ul><li><code>REST API</code>是<strong>一种应用程序编程接口</strong>（API 或 Web API），遵循一组关于应用程序如何使用 HTTP 方法相互通信的架构规则。 <code>RESTful Web</code> 服务使用 REST API 协议，因此有时也称为 RESTful API。</li><li>REST 通常用于构建 Web API，<strong>允许客户端与服务器之间通过 HTTP 协议进行交互</strong>。</li><li><code>REST</code> 并不是一种协议或标准，而是一组指导原则，旨在帮助开发人员创建可扩展、性能良好且易于维护的 Web 服务。</li><li><strong>REST 的核心思想</strong>是通过一组简单、统一的接口来管理和操作服务器上的资源。</li></ul><h2 id="资源Resource"><a href="#资源Resource" class="headerlink" title="资源Resource"></a><strong>资源</strong>Resource</h2><p>资源可以被视为 Web 服务中的“实体”或“对象”，它可以是用户、订单、文件等任何<strong>具有唯一标识符的事物</strong>。每个资源都由一个 URI（<code>Uniform Resource Identifier</code>，统一资源标识符）标识。<br><strong>资源的表示（Representations）</strong><br>资源可以有多种不同的表示形式，例如 <code>JSON、XML、HTML</code> 等。当客户端请求资源时，<strong>服务器会以特定的表示形式返回资源</strong>。表示形式通常通过 <code>HTTP</code> 头中的 <code>Content-Type</code> 指定，例如 <code>application/json</code> 表示 JSON 格式。</p><h2 id="URI（统一资源标识符）"><a href="#URI（统一资源标识符）" class="headerlink" title="URI（统一资源标识符）"></a>URI（统一资源标识符）</h2><p><code>URI(Uniform Resource Identifier)</code>，URI既可以看成是资源的地址，也可以看成是资源的名称，它是<strong>用于标识资源的唯一地址，每个资源都应该有一个唯一的 URI</strong>，这个 URI 可以看作是资源的“地址“，如<code>api/user/profile/get</code>：表示获取用户信息。<br>URI 应该是<strong>稳定的</strong>，不应该因为资源内部状态的变化而发生变化。URI 应该是<strong>自解释的</strong>，即可以从 URI 大致了解所表示的资源。</p><h2 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h2><p>在 REST 中，HTTP 方法<strong>用于指定对资源执行的操作</strong>。每种方法都应该在其相应的上下文中使用。<strong>常用的 HTTP 方法包括</strong>：</p><ul><li><code>GET</code>：检索资源。请求不会改变服务器状态。</li><li><code>POST</code>：创建资源或在现有资源中执行子资源的创建操作。</li><li><code>PUT</code>：更新资源。通常用于更新整个资源。</li><li><code>PATCH</code>：部分更新资源。通常用于更新资源的部分字段。</li><li><code>DELETE</code>：删除资源。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250624142317574.png" alt="image-20250624142317574"></p><h2 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h2><p>在<strong>非RESTful风格的API</strong>中，查询和删除一般使用<code>GET</code>方式请求，更新和插入一般使用<code>POST</code>请求。从请求方式上无法知道API具体是干嘛的，所有<strong>在URL上都会有操作的动词</strong>来表示API进行的动作，例如：<code>query，add，update，delete</code>等。而<strong>RESTful风格的API</strong>则要求<strong>在URL上都以名词的方式出现</strong>，从几种请求方式上就可以看出想要进行的操作，这点与非RESTful风格的API形成鲜明对比。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /collection：从服务器查询资源的列表（数组）</span><br><span class="line">GET /collection/resource：从服务器查询单个资源</span><br><span class="line">POST /collection：在服务器创建新的资源</span><br><span class="line">PUT /collection/resource：更新服务器资源</span><br><span class="line">DELETE /collection/resource：从服务器删除资源</span><br></pre></td></tr></table></figure><table><thead><tr><th>HTTP Method</th><th>安全性</th><th>幂等性</th><th>解释</th></tr></thead><tbody><tr><td>GET</td><td>安全</td><td>幂等</td><td>读操作安全，查询一次多次结果一致</td></tr><tr><td>POST</td><td>非安全</td><td>非幂等</td><td>写操作非安全，每多插入一次都会出现新结果</td></tr><tr><td>PUT</td><td>非安全</td><td>幂等</td><td>写操作非安全，一次和多次更新结果一致</td></tr><tr><td>DELETE</td><td>非安全</td><td>幂等</td><td>写操作非安全，一次和多次删除结果一致</td></tr></tbody></table><p><strong>安全性</strong>是指方法不会修改资源状态，即<strong>读的为安全的，写的操作为非安全的</strong>。而<strong>幂等性</strong>的意思是<strong>操作一次和操作多次的最终效果相同</strong>，客户端重复调用也只返回同一个结果。</p><h2 id="RESTful-API设计规范"><a href="#RESTful-API设计规范" class="headerlink" title="RESTful API设计规范"></a>RESTful API设计规范</h2><h3 id="URL设计规范"><a href="#URL设计规范" class="headerlink" title="URL设计规范"></a>URL设计规范</h3><p>URL为统一资源定位器，接口属于服务端资源，首先要通过URL这个定位到资源才能访问，一个完整的<code>URL</code>组成由以下几个部分构成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">URI</span> = scheme <span class="string">&quot;://&quot;</span> host  <span class="string">&quot;:&quot;</span>  port <span class="string">&quot;/&quot;</span> path [ <span class="string">&quot;?&quot;</span> query ][ <span class="string">&quot;#&quot;</span> fragment ]</span><br></pre></td></tr></table></figure><ul><li><code>scheme</code>：指底层用的协议，如<code>http</code>、<code>https</code>、<code>ftp</code></li><li><code>host</code>：服务器的IP地址或者域名</li><li><code>port</code>： 端口，http默认为<code>80</code>端口</li><li><code>path</code>：访问资源的路径，就是各种web 框架中定义的<code>route</code>路由</li><li><code>query</code>： 查询字符串，为发送给服务器的参数，在这里更多发送数据分页、排序等参数。</li><li><code>fragment</code>： 锚点，定位到页面的资源</li></ul><p>在设计API时URL的path是需要认真考虑的，而RESTful对path的设计做了一些规范，通常一个<code>RESTful API</code>的path组成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;</span><br></pre></td></tr></table></figure><ul><li><code>version</code>：API版本号，有些版本号放置在头信息（<code>headers</code>）中也可以，通过控制版本号有利于应用迭代。</li><li><code>resources</code>：资源，RESTful API推荐用小写英文单词的复数形式。</li><li><code>resource_id</code>：资源的id，访问或操作该资源。</li></ul><p>有时候可能资源级别较大，其下还可细分很多<code>子资源</code>也可以灵活设计URL的path，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/&#123;subresources&#125;/&#123;subresource_id&#125;</span><br></pre></td></tr></table></figure><p>有时可能增删改查无法满足业务要求，可以在URL末尾加上<code>action</code>，其中action就是对资源的操作。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/action</span><br></pre></td></tr></table></figure><h3 id="RESTful-API的URL具体设计规范"><a href="#RESTful-API的URL具体设计规范" class="headerlink" title="RESTful API的URL具体设计规范"></a>RESTful API的URL具体设计规范</h3><ul><li><p>不用大写字母，所有单词使用英文且小写。</p></li><li><p>连字符用中杠<code>&quot;-&quot;</code>而不用下杠<code>&quot;_&quot;</code></p></li><li><p>正确使用 <code>&quot;/&quot;</code>表示层级关系，URL的层级不要过深，并且越靠前的层级应该相对越稳定</p></li><li><p>结尾不要包含正斜杠分隔符<code>&quot;/&quot;</code></p></li><li><p>URL中不出现动词，用请求方式表示动作</p></li><li><p>资源表示用复数不要用单数</p></li><li><p>不要使用文件扩展名</p></li></ul><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a><strong>返回结果</strong></h2><h3 id="请求的处理执行结果"><a href="#请求的处理执行结果" class="headerlink" title="请求的处理执行结果"></a>请求的处理执行结果</h3><p>使用各类状态码来表示，状态码主要分为五大类：</p><table><thead><tr><th>状态码</th><th>表示意义</th></tr></thead><tbody><tr><td>1xx</td><td>相关信息</td></tr><tr><td>2xx</td><td>操作成功</td></tr><tr><td>3xx</td><td>重定向</td></tr><tr><td>4xx</td><td>客户端错误</td></tr><tr><td>5xx</td><td>服务器错误</td></tr></tbody></table><h3 id="响应的返回结果"><a href="#响应的返回结果" class="headerlink" title="响应的返回结果"></a>响应的返回结果</h3><p>响应结果包含<strong>状态码</strong>和<strong>返回数据</strong>两个部分。状态码同请求结果一致，<strong>返回结果</strong>针对不同操作，服务器向用户返回数据，基本都是返回<code>JSON</code>格式数据给客户端</p><p>参考原文链接：<a href="https://blog.csdn.net/weixin_46598480/article/details/142847343">Restful API</a></p>]]></content>
    
    
    <summary type="html">‌RESTful API是一种基于HTTP协议的架构风格，用于构建高效、可扩展的Web服务接口。‌</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="RestfulApi" scheme="https://southernfish.github.io/categories/Framwork/RestfulApi/"/>
    
    
    <category term="RestfulApi" scheme="https://southernfish.github.io/tags/RestfulApi/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务</title>
    <link href="https://southernfish.github.io/2025/06/23/framwork/spring-transaction/"/>
    <id>https://southernfish.github.io/2025/06/23/framwork/spring-transaction/</id>
    <published>2025-06-23T07:52:36.000Z</published>
    <updated>2025-06-26T04:00:20.235Z</updated>
    
    <content type="html"><![CDATA[<p>事务是一组操作的集合，是一个不可分割的操作。事务会把所有的操作作为一个整体，一起向数据库提交或者是撤销操作请求。所以这组操作要么同时成功，要么同时失败。我们在进行程序开发时，也会有事务的需求。</p><h1 id="Spring事务基本信息"><a href="#Spring事务基本信息" class="headerlink" title="Spring事务基本信息"></a>Spring事务基本信息</h1><h2 id="Spring事务在解决什么问题"><a href="#Spring事务在解决什么问题" class="headerlink" title="Spring事务在解决什么问题"></a>Spring事务在解决什么问题</h2><ol><li><strong>‌数据一致性‌：</strong>在分布式系统中，多个服务或组件可能需要同时操作同一数据，事务确保这些操作要么全部成功，要么全部失败，从而保持数据的一致性。</li><li><strong>并发控制‌：</strong>在多用户并发访问的情况下，事务可以控制对共享资源的访问，避免数据冲突和损坏。</li><li><strong>故障恢复‌：</strong>当操作过程中发生错误时，事务可以回滚到操作前的状态，确保系统不会处于不一致的状态。</li></ol><h2 id="Spring事务的实现原理"><a href="#Spring事务的实现原理" class="headerlink" title="Spring事务的实现原理"></a>Spring事务的实现原理</h2><p>Spring事务的实现<strong>基于<code> AOP</code> （面向切面编程）和 动态代理</strong> 。Spring通过代理机制对目标对象进行包装，插入事务管理的逻辑，包括开启事务、提交事务和回滚事务等。具体来说：</p><ul><li>‌<strong>动态代理</strong>‌：Spring使用 <code>JDK动态代理</code> 或 <code>CGLIB动态代理</code> 来创建代理对象。</li><li>‌<strong>AOP</strong>‌：通过切面编程，在方法调用前后插入事务管理的逻辑。</li></ul><h2 id="Spring事务的配置和使用"><a href="#Spring事务的配置和使用" class="headerlink" title="Spring事务的配置和使用"></a>Spring事务的配置和使用</h2><p>在Spring中配置事务主要通过注解<code>@Transactional</code>来实现。该注解可以应用于类或方法上，指示该方法需要事务管理。</p><hr><h1 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h1><h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><p><code>@Transactional</code>是Spring框架中用于<strong>声明式事务管理的关键注解</strong>，其<em>核心功能</em>是确保标注的方法或类在数据库操作中遵循ACID原则（原子性、一致性、隔离性、持久性），实现要么全部成功提交，要么全部回滚的机制。通过AOP（面向切面编程）实现，在方法执行前开启事务，执行后根据结果提交或回滚。‌‌参考文章 <a href="https://juejin.cn/post/7473315367490781195">深入解析 @Transactional——Spring 事务管理的核心</a></p><h2 id="Spring-事务默认的回滚规则"><a href="#Spring-事务默认的回滚规则" class="headerlink" title="Spring 事务默认的回滚规则"></a>Spring 事务默认的回滚规则</h2><p>只有未捕获的 <code>RuntimeException</code>（运行时异常）或 <code>Error</code> 才会触发回滚，而普通的 <code>Exception</code>（检查异常）不会触发回滚。</p><p>若你希望所有异常都能回滚，可加上 <code>rollbackFor = Exception.class</code>，避免出现“事务看起来生效了，但并没有真正回滚”的情况。</p><h2 id="常见属性配置"><a href="#常见属性配置" class="headerlink" title="常见属性配置"></a>常见属性配置</h2><table><thead><tr><th>属性</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>propagation</td><td>控制事务传播行为（如REQUIRED、REQUIRES_NEW）</td><td>@Transactional(propagation = Propagation.REQUIRED)</td></tr><tr><td>isolation</td><td>设置事务隔离级别（如READ_COMMITTED）</td><td>@Transactional(isolation = Isolation.READ_COMMITTED)</td></tr><tr><td>rollbackFor</td><td>指定触发回滚的异常类型</td><td>@Transactional(rollbackFor = Exception.class)</td></tr><tr><td>timeout</td><td>定义事务超时时间（秒）</td><td>@Transactional(timeout = 30)</td></tr></tbody></table><h2 id="Spring事务为什么会失效"><a href="#Spring事务为什么会失效" class="headerlink" title="Spring事务为什么会失效"></a>Spring事务为什么会失效</h2><ol><li><p><strong>try-catch导致的事务失效</strong></p><p>Spring 只有在方法抛出异常时，才会触发回滚。如果你在 catch 里吞掉了异常，那事务也就不会回滚了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePersonById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 业务处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// 触发异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">//  catch 里吞掉了异常，Spring 感知不到异常的发生</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发生异常，但事务未回滚&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 手动抛出异常</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePersonById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 业务处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// 触发异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;手动抛出异常，确保事务回滚&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异常自然传播</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePersonById</span><span class="params">(Long id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 业务处理</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// 事务会回滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方法不是public</strong></p><p><code>@Transactional</code> 只会作用于 <strong>public 方法</strong>，如果你加在 <code>private</code> 或 <code>protected</code> 方法上，事务不会生效。因为Spring 事务是通过 <strong>代理机制</strong> 实现的，而 JDK 动态代理只能代理 <code>public</code> 方法，所以其他访问级别的方法都不行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteDept</span><span class="params">(Long id)</span> &#123; &#125; <span class="comment">// 事务不会生效</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">deleteDept</span><span class="params">(Long id)</span> &#123; &#125; <span class="comment">// 事务不会生效</span></span><br></pre></td></tr></table></figure></li><li><p><strong>同一类里，方法互相调用</strong></p><p>这里 <code>deleteDept</code> 方法调用了 <code>deleteEmp</code>，但 <code>deleteEmp</code> 上的 <code>@Transactional</code> <strong>不会生效</strong>！原因是：Spring 的事务是基于<strong>代理</strong>的，<code>this.deleteEmp(id)</code> 直接调用了本类的方法，没有经过 Spring 代理，所以事务不会生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper deptMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDept</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.deleteEmp(id); <span class="comment">// 事务不会生效！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteEmp</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        empMapper.delByDeptId(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的处理方法应是<strong>通过 Spring 管理的 Bean 调用</strong>(如下)，或者使用 <code>ApplicationContext</code> 获取代理对象，再调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptServiceImpl self;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDept</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        self.deleteEmp(id); <span class="comment">// 事务生效！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteEmp</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        empMapper.delByDeptId(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>数据库引擎不支持事务</strong></p><p>如果你用的 MySQL <strong>表引擎是 MyISAM</strong>，事务是不可能生效的，因为 MyISAM <strong>根本不支持事务</strong>！要确保你的表是 InnoDB：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">WHERE</span> Name <span class="operator">=</span> <span class="string">&#x27;dept&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dept ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Transactional的传播机制"><a href="#Transactional的传播机制" class="headerlink" title="@Transactional的传播机制"></a>@Transactional的传播机制</h2><p>@Transactional注解<strong>支持多种事务传播机制</strong>，这些机制定义了事务的行为方式。通过<code>Propagation</code>配置，主要的传播机制及含义如下： </p><table><thead><tr><th>传播类型</th><th>含义</th></tr></thead><tbody><tr><td>Propagation.REQUIRED</td><td>如果当前已有事务则加入当前事务，否则开启新的事务</td></tr><tr><td>Propagation.REQUIRED_NEW</td><td>无论当前是否有事务都开启新的事务；如果当前存在事务，则把当前事务挂起。</td></tr><tr><td>Propagation.SUPPORTED</td><td>如果当前事务存在就加入事务，否则以非事务运行</td></tr><tr><td>Propagation.NOT_SUPPORTED</td><td>始终以非事务方式执行；如果当前存在事务，则挂起当前事务</td></tr><tr><td>Propagation.NEVER</td><td>不使用事务，如果当前事务存在，则抛出异常</td></tr><tr><td>Propagation.MANDATORY</td><td>当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</td></tr><tr><td>Propagation.NESTED</td><td>父子（嵌套）事务，父提交子提交，父回滚全回滚，子回滚不影响父事务</td></tr></tbody></table><p>这些传播机制提供了灵活的事务控制选项，可以根据不同的业务需求选择合适的事务行为，避免事务的方法过于长，一个事务里面调用的库表越多，就越有可能造成死锁，所以我们要根据具体的需要拆分使用。例如:</p><ul><li>在需要<em>确保操作完全独立于其他事务时，可以使用REQUIRES_NEW</em>；</li><li>在<em>不需要事务时，可以使用NOT_SUPPORTED或NEVER</em>；</li><li>在<em>需要嵌套事务时，可以使用NESTED</em>等</li></ul><p>避免事务的方法过于长，一个事务里面调用的库表越多，就越有可能造成死锁，所以我们要根据具体的需要拆分使用</p><h2 id="高吞吐量下使用-Transactional注解导致性能降低"><a href="#高吞吐量下使用-Transactional注解导致性能降低" class="headerlink" title="高吞吐量下使用@Transactional注解导致性能降低"></a>高吞吐量下使用<code>@Transactional</code>注解导致性能降低</h2><ol><li><p><strong>批量处理</strong></p><p>尽可能将多个数据库操作合并到单个事务中。例如，可以使用JDBC的<code>batch updates</code>或者在<code>ORM框架</code>（如Spring Data JPA, Hibernate）中利用其批量操作功能。 示例（<code>Spring Data JPA</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchSave</span><span class="params">(List&lt;Entity&gt; entities)</span> &#123;</span><br><span class="line">    entityRepository.saveAll(entities);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>减少事务范围</strong> </p><p>尽量减小@Transactional注解覆盖的方法范围。只在确实需要事务控制的代码块上使用@Transactional。例如，只在服务层而非控制器层使用事务。 </p></li><li><p> <strong>异步事务处理</strong> </p></li></ol><p>   对于非阻塞操作，可以考虑将事务逻辑移至异步处理中。例如，使用<code>@Async</code>注解来异步执行事务操作，但这通常需要额外的配置来确保事务的正确管理。示例（Spring <code>@Async</code>）：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncTransactionalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行事务操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>优化数据库配置</strong></p><ul><li><p><strong>索引优化</strong>：确保数据库表上有适当的索引，以加快查询和插入速度。</p></li><li><p><strong>连接池优化</strong>：使用高效的数据库连接池（如<code>HikariCP</code>），并合理配置其参数（如最大连接数、连接超时时间等）。</p></li><li><p><strong>读写分离</strong>：对于读多写少的应用，可以考虑实现数据库的读写分离。</p></li></ul></li><li><p><strong>避免大事务</strong></p><ul><li>避免在单个事务中处理大量数据。如果可能，将大事务拆分成多个小事务。</li></ul></li><li><p><strong>使用乐观锁或悲观锁</strong></p><ul><li>在高并发场景下，使用乐观锁或悲观锁可以减少锁的竞争，提高并发性能。乐观锁通常用于写操作较少的情况，而悲观锁则适用于写操作较多的情况。</li></ul></li></ol><hr><h1 id="Transactional大事务处理"><a href="#Transactional大事务处理" class="headerlink" title="@Transactional大事务处理"></a>@Transactional大事务处理</h1><p> 此处转载自原文 <a href="https://blog.csdn.net/huangchong0107/article/details/136652281">Springboot @Transactional大事务处理的几点建议</a></p><h2 id="什么是大事务"><a href="#什么是大事务" class="headerlink" title="什么是大事务"></a><strong>什么是大事务</strong></h2><p>总体任务对应的事务<a href="https://so.csdn.net/so/search?q=%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4&spm=1001.2101.3001.7020">运行时间</a>比较长，长时间未提交的事务</p><h2 id="大事务的危害"><a href="#大事务的危害" class="headerlink" title="大事务的危害"></a><strong>大事务的危害</strong></h2><ul><li>并发情况下，数据库连接池资源占满。大事务提交不及时，导致连接资源释放缓慢。</li><li>数据库死锁和锁等待。<code>innodb</code>引擎背景下，事务如果占用了排他锁，会容易导致并发情况下数据死锁或者锁等待。</li><li>大事务Rt时间长，容易导致接口超时。</li><li>大事务回滚时间长。</li><li>数据库主从架构下，数据同步延迟</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><ul><li><p><strong>将声明式事务的@Transactional方式 合理的替换为 编程式事务TransactionTemplate 的方式</strong><br>声明式事务的粒度最小是整个方法，可能会导致业务里不必要的逻辑都加了事务。编程式事务细化需要加事务的逻辑上，形成实际有用的事务块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// ....  业务代码</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="comment">//回滚</span></span><br><span class="line">                transactionStatus.setRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>将查询放在事务方法外</strong><br>使用@Transactional 又想避免产生大事务，需对方法进行拆分，将不需要事务管理的逻辑与事务操作分开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionTestService</span>&#123;</span><br><span class="line">    <span class="comment">// 避免同一个类内部方法相互调用，实例方法调用代理方法而导致事务失效</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TransactionTestService service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(ParamDto dto)</span>&#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        service.save(dto);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//事务操作</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(ParamDto dto)</span>&#123;</span><br><span class="line">        paramDao.insert(dto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>避免跨服务间的远程调用</strong><br>服务间的通讯及服务之间的调用时间 受网络环境和远端接口Rt时间的影响，可能会比较耗时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反例：</span></span><br><span class="line"><span class="comment">// 事务操作</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(ParamDto dto)</span>&#123;</span><br><span class="line">    <span class="comment">// 调用了其他服务</span></span><br><span class="line">    otherRemoteApi();</span><br><span class="line">    paramDao.insert(dto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改为：</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(ParamDto dto)</span>&#123;</span><br><span class="line">    <span class="comment">// 调用了其他服务</span></span><br><span class="line">    otherRemoteApi();</span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                  paramDao.insert(dto);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="comment">//回滚</span></span><br><span class="line">                transactionStatus.setRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>事务中不应该一次性处理太多的数据，可以使用分批执行</strong></p></li><li><p><strong>事务中的方法可以根据业务使用异步执行</strong></p></li></ul>]]></content>
    
    
    <summary type="html">Spring事务是一组操作的集合，是一个不可分割的操作。事务会把所有的操作作为一个整体，一起向数据库提交或者是撤销操作请求。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="Spring" scheme="https://southernfish.github.io/categories/Framwork/Spring/"/>
    
    
    <category term="Spring Boot" scheme="https://southernfish.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>并发编程</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-concurrency/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-concurrency/</id>
    <published>2025-06-23T06:29:36.000Z</published>
    <updated>2025-06-26T04:00:20.236Z</updated>
    
    <content type="html"><![CDATA[<p>并发，在<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192?fromModule=lemma_inlink">操作系统</a>中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA/128842?fromModule=lemma_inlink">处理机</a>上运行，但任一个时刻点上只有一个程序在处理机上运行。本文转载自<a href="https://blog.csdn.net/linxiaosongXXDDDGS/article/details/147779420">Java并发编程详解</a>。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="线程的本质"><a href="#线程的本质" class="headerlink" title="线程的本质"></a>线程的本质</h3><p><strong>线程是轻量级进程：</strong>在同一个进程中，多个线程共享内存空间（堆、方法区），但每个线程拥有独立的栈和程序计数器（PC）。<br>并发 vs 并行：</p><ul><li><strong>并发：</strong>线程在单核CPU上交替执行（时间片轮转）。</li><li><strong>并行：</strong>多核CPU上线程真正同时运行</li></ul><h3 id="创建线程的两种方式"><a href="#创建线程的两种方式" class="headerlink" title="创建线程的两种方式"></a>创建线程的两种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：继承Thread类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running by extending Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：实现Runnable接口（推荐，避免单继承限制，在Java中，类只能继承一个父类（单继承），但可以实现多个接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running by implementing Runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式1 启动线程（调用start()，而非run()！直接调用run()只是普通方法调用，不会创建新线程）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">        <span class="comment">// 方式2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()).start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Runnable</code>优势总结：</p><ul><li><strong>解耦任务与线程：</strong>Runnable表示任务逻辑，<code>Thread</code>表示线程载体，符合面向对象的职责分离原则。</li><li><strong>资源共享：</strong>多个线程可共享同一个Runnable实例（例如售票系统的共享票池）。</li><li><strong>灵活组合：</strong>可与线程池（<code>ExecutorService</code>）、<code>Lambda表达式</code>等现代特性无缝结合。</li></ul><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><ol><li>新建（<code>New</code>）：线程对象已创建，但未调用<code>start()</code>。</li><li>就绪（<code>Runnable</code>）：调用<code>start()</code>后，等待CPU调度。</li><li>运行（<code>Running</code>）：获得CPU时间片，执行<code>run()</code>方法。</li><li>阻塞（<code>Blocked</code>）：因等待锁、I/O操作或<code>sleep()</code>等暂停执行。</li><li>终止（<code>Terminated</code>）：<code>run()</code>执行完毕或发生未捕获异常。</li></ol><h2 id="线程同步锁机制"><a href="#线程同步锁机制" class="headerlink" title="线程同步锁机制"></a>线程同步锁机制</h2><h3 id="1、竞态条件（Race-Condition）"><a href="#1、竞态条件（Race-Condition）" class="headerlink" title="1、竞态条件（Race Condition）"></a>1、竞态条件（Race Condition）</h3><p>当多个线程同时访问共享资源且未正确同步时，结果依赖于线程执行顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 典型竞态条件示例：不安全的计数器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 非原子操作（实际为 read-modify-write）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、同步解决方案"><a href="#2、同步解决方案" class="headerlink" title="2、同步解决方案"></a>2、同步解决方案</h3><ul><li><p><code>synchronized</code> 关键字：</p><ul><li><strong>同步方法</strong>：锁对象为当前实例（<code>this</code>）或类对象（静态方法）。</li><li><strong>同步代码块</strong>：显式指定锁对象（任意对象）。</li></ul></li><li><p><strong>Lock 接口</strong>（更灵活，支持超时、公平锁）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeCounterWithLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、volatile-关键字"><a href="#3、volatile-关键字" class="headerlink" title="3、volatile 关键字"></a>3、volatile 关键字</h3><ul><li><strong>保证可见性</strong>：对<code>volatile</code>变量的修改立即对其他线程可见。</li><li><strong>禁止指令重排序</strong>：防止编译器和CPU优化导致的执行顺序错乱。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toggleFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = !flag; <span class="comment">// 非原子操作，volatile仅保证可见性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程间的协作"><a href="#线程间的协作" class="headerlink" title="线程间的协作"></a>线程间的协作</h2><h3 id="1、-wait-、notify-、notifyAll"><a href="#1、-wait-、notify-、notifyAll" class="headerlink" title="1、 wait()、notify()、notifyAll()"></a>1、 wait()、notify()、notifyAll()</h3><ul><li><p>Object类的核心方法：</p><ul><li><p><code>wait()</code>：释放锁并进入等待状态。</p></li><li><p><code>notify()</code>：随机唤醒一个等待线程。</p></li><li><p><code>notifyAll()</code>：唤醒所有等待线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者线程逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> item)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">            wait(); <span class="comment">// 缓冲区满，等待消费者消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(item);</span><br><span class="line">        System.out.println(<span class="string">&quot;生产: &quot;</span> + item + <span class="string">&quot;，当前队列大小: &quot;</span> + queue.size());</span><br><span class="line">        notifyAll(); <span class="comment">// 通知消费者可以消费</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者线程逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            wait(); <span class="comment">// 缓冲区空，等待生产者生产</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;消费: &quot;</span> + item + <span class="string">&quot;，剩余队列大小: &quot;</span> + queue.size());</span><br><span class="line">        notifyAll(); <span class="comment">// 通知生产者可以生产</span></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SharedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.produce(i);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>); <span class="comment">// 模拟生产耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Producer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.consume();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟消费耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Consumer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2、Condition-接口"><a href="#2、Condition-接口" class="headerlink" title="2、Condition 接口"></a>2、Condition 接口</h3><ul><li>与<code>Lock</code>配合使用，提供更精细的线程等待与唤醒。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> item)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                notFull.await(); <span class="comment">// 等待&quot;非满&quot;条件</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(item);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产: &quot;</span> + item + <span class="string">&quot;，队列大小: &quot;</span> + queue.size());</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 触发&quot;非空&quot;条件</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                notEmpty.await(); <span class="comment">// 等待&quot;非空&quot;条件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费: &quot;</span> + item + <span class="string">&quot;，剩余队列大小: &quot;</span> + queue.size());</span><br><span class="line">            notFull.signal(); <span class="comment">// 触发&quot;非满&quot;条件</span></span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AdvancedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdvancedBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建生产者线程（Lambda实现Runnable）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.produce(i);</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.consume();</span><br><span class="line">                    Thread.sleep(<span class="number">800</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a><a href="https://so.csdn.net/so/search?q=%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">并发编程</a></h1><h2 id="并发工具类-java-util-concurrent"><a href="#并发工具类-java-util-concurrent" class="headerlink" title="并发工具类(java.util.concurrent)"></a>并发工具类(java.util.concurrent)</h2><h3 id="1、Executor-框架"><a href="#1、Executor-框架" class="headerlink" title="1、Executor 框架"></a>1、Executor 框架</h3><ul><li><p><strong>线程池管理</strong>：避免频繁创建/销毁线程的开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建固定大小的线程池（4个线程）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交10个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由 &quot;</span> </span><br><span class="line">                    + Thread.currentThread().getName() + <span class="string">&quot; 执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池（不再接受新任务）</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、并发集合"><a href="#2、并发集合" class="headerlink" title="2、并发集合"></a>2、并发集合</h3><ul><li><p><strong>线程安全容器</strong>：避免手动同步。</p><ul><li><p><code>CopyOnWriteArrayList</code>：读多写少场景。</p></li><li><p><code>ConcurrentHashMap</code>：高并发哈希表。</p></li><li><p><code>BlockingQueue</code>：阻塞队列（如<code>LinkedBlockingQueue</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap 示例</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个写线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key-&quot;</span> + threadId + <span class="string">&quot;-&quot;</span> + j;</span><br><span class="line">                    map.put(key, j);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;写线程 &quot;</span> + threadId + <span class="string">&quot; 完成&quot;</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建读线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前Map大小: &quot;</span> + map.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3、原子类（Atomic）"><a href="#3、原子类（Atomic）" class="headerlink" title="3、原子类（Atomic）"></a>3、原子类（Atomic）</h3><ul><li><p>基于CAS（Compare-And-Swap）保证原子性，实现无锁线程安全。</p></li><li><p>性能优于<code>synchronized</code>，适用于高并发场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count.incrementAndGet(); <span class="comment">// 原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count.get()); <span class="comment">// 正确输出20000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、CountDownLatch-与-CyclicBarrier"><a href="#4、CountDownLatch-与-CyclicBarrier" class="headerlink" title="4、CountDownLatch 与 CyclicBarrier"></a>4、CountDownLatch 与 CyclicBarrier</h3><ul><li><p><strong>CountDownLatch</strong>：等待多个任务完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TASK_COUNT</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(TASK_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动多个任务线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= TASK_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 开始执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 完成&quot;</span>);</span><br><span class="line">                latch.countDown(); <span class="comment">// 计数器减1    多个线程调用 latch.countDown()</span></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待所有任务完成</span></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务已完成，继续主线程逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>CyclicBarrier</strong>：多个线程相互等待至屏障点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; System.out.println(<span class="string">&quot;All threads reached barrier&quot;</span>));</span><br><span class="line"><span class="comment">// 每个线程调用 barrier.await()</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="典型陷阱"><a href="#典型陷阱" class="headerlink" title="典型陷阱"></a>典型陷阱</h2><h3 id="1、死锁（Deadlock）"><a href="#1、死锁（Deadlock）" class="headerlink" title="1、死锁（Deadlock）"></a>1、死锁（Deadlock）</h3><p>四个必要条件：</p><ol><li><strong>互斥</strong>：资源只能被一个线程持有。</li><li><strong>占有且等待</strong>：线程持有资源并等待其他资源。</li><li><strong>不可抢占</strong>：资源不能被强制释放。</li><li><strong>循环等待</strong>：多个线程形成环形等待链。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 死锁示例</span></span><br><span class="line"><span class="comment">// Thread 1: lock A → try lock B</span></span><br><span class="line"><span class="comment">// Thread 2: lock B → try lock A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程1：先获取lockA，再请求lockB</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1 持有lockA&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟操作耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1 获取lockB&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2：先获取lockB，再请求lockA</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2 持有lockB&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2 获取lockA&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：破坏任一条件，如按固定顺序获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免死锁（统一锁顺序）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockSolution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 所有线程按相同顺序获取锁（先lockA后lockB）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; acquireLocks(lockA, lockB, <span class="string">&quot;线程1&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; acquireLocks(lockA, lockB, <span class="string">&quot;线程2&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">acquireLocks</span><span class="params">(Object firstLock, Object secondLock, String threadName)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (firstLock) &#123;</span><br><span class="line">            System.out.println(threadName + <span class="string">&quot; 持有 &quot;</span> + firstLock);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (secondLock) &#123;</span><br><span class="line">                System.out.println(threadName + <span class="string">&quot; 获取 &quot;</span> + secondLock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、活锁（Livelock）"><a href="#2、活锁（Livelock）" class="headerlink" title="2、活锁（Livelock）"></a>2、活锁（Livelock）</h3><p>线程不断重试失败的操作（如谦让式资源释放），但无法推进。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 活锁示例：两个线程互相让出CPU</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryLock(lockA)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryLock(lockB)) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; unlock(lockA); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.yield(); <span class="comment">// 让出CPU但未解决问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LivelockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">active</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(Runnable task, Worker otherWorker)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!active) &#123;</span><br><span class="line">                <span class="keyword">if</span> (otherWorker.active) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;让出执行权...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    active = <span class="literal">true</span>;</span><br><span class="line">                    task.run();</span><br><span class="line">                    active = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    active = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Worker</span> <span class="variable">worker1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Worker</span> <span class="variable">worker2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; worker1.work(() -&gt; System.out.println(<span class="string">&quot;Worker1执行任务&quot;</span>), worker2)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; worker2.work(() -&gt; System.out.println(<span class="string">&quot;Worker2执行任务&quot;</span>), worker1)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、资源竞争与性能问题"><a href="#3、资源竞争与性能问题" class="headerlink" title="3、资源竞争与性能问题"></a>3、资源竞争与性能问题</h3><p>资源竞争和性能问题是并发编程中的核心挑战之一。以下通过具体示例展示资源竞争导致的数据错误，以及不同锁策略对性能的影响，并给出优化方案。</p><ul><li><strong>锁粒度</strong>：粗粒度锁（简单但低效） vs 细粒度锁（复杂但高效）。</li><li><strong>锁分离</strong>：如<code>ReadWriteLock</code>分离读锁与写锁。</li></ul><p><strong>示例1：资源竞争导致数据错误（未同步的计数器）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeCounterExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count++; <span class="comment">// 非原子操作：read → modify → write</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动两个线程同时修改count</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预期结果：20000，实际结果可能小于20000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count); <span class="comment">// 结果不确定，因线程竞争而异</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题分析</strong>：</p><ul><li><p><code>count++</code> 是非原子操作，实际包含以下步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int tmp = count;  // Step 1: 读取当前值</span><br><span class="line">tmp = tmp + 1;    // Step 2: 修改值</span><br><span class="line">count = tmp;      // Step 3: 写回新值</span><br></pre></td></tr></table></figure></li><li><p>当两个线程同时执行时，可能出现以下时序：</p><ul><li>线程A读取<code>count=100</code> → 线程B读取<code>count=100</code> → 线程A写入<code>101</code> → 线程B写入<code>101</code></li><li>最终结果为<code>101</code>，而非预期的<code>102</code>。</li></ul></li></ul><p><strong>示例2：粗粒度锁的性能问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoarseLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 粗粒度锁：锁住整个循环</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时: &quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Final count: <span class="number">200000</span></span><br><span class="line">耗时: 120ms  <span class="comment">// 实际时间因机器性能而异，但明显较长</span></span><br></pre></td></tr></table></figure><p><strong>问题分析</strong>：</p><ul><li><strong>粗粒度锁</strong>：将整个循环包裹在<code>synchronized</code>块内，每次循环都会获取/释放锁。</li><li><strong>性能问题</strong>：频繁的锁竞争导致大量线程上下文切换，CPU时间浪费在锁管理而非实际计算。</li></ul><p><strong>示例3：细粒度锁优化（减少锁范围）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FineGrainedLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">localCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                localCount++; <span class="comment">// 先在线程本地累加</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 仅对最终合并操作加锁</span></span><br><span class="line">                count += localCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时: &quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Final count: <span class="number">200000</span></span><br><span class="line">耗时: 5ms  <span class="comment">// 性能显著提升</span></span><br></pre></td></tr></table></figure><p><strong>优化分析</strong>：</p><ul><li><strong>细粒度锁</strong>：线程先在本地变量<code>localCount</code>中累加，最后仅对合并操作加锁。</li><li><strong>性能提升</strong>：锁竞争频率从每次循环减少到每线程一次，大幅降低同步开销。</li></ul><p><strong>示例4：锁分离（读写锁优化）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 写线程（频繁修改数据）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">writer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                rwLock.writeLock().lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    value++;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>); <span class="comment">// 模拟写操作耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    rwLock.writeLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读线程（频繁读取数据）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">reader</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                rwLock.readLock().lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;读取 value: &quot;</span> + value);</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>); <span class="comment">// 模拟读操作耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    rwLock.readLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动2个写线程和4个读线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(writer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(writer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化分析</strong>：</p><ul><li><strong>读写锁分离：</strong><ul><li><strong>读锁（共享锁）</strong>：允许多个线程同时读数据。</li><li><strong>写锁（独占锁）</strong>：仅允许单个线程写数据，且与读锁互斥。</li></ul></li><li><strong>适用场景</strong>：读多写少（如缓存系统），通过减少锁竞争提升吞吐量。</li></ul><hr><h1 id="关键性总结"><a href="#关键性总结" class="headerlink" title="关键性总结"></a>关键性总结</h1><ol><li><strong>资源竞争问题</strong>：<ul><li><strong>表现</strong>：多线程同时修改共享数据导致结果错误（如计数器值不准确）。</li><li><strong>解决方案</strong>：使用同步机制（<code>synchronized</code>、<code>Lock</code>）保证原子性。</li></ul></li><li><strong>性能优化策略</strong>：<ul><li><strong>减少锁粒度</strong>：仅对必要代码块加锁（如示例3的本地累加优化）。</li><li><strong>锁分离</strong>：读写锁（<code>ReadWriteLock</code>）区分读写操作，提升并发度。</li><li><strong>无锁编程</strong>：使用原子类（<code>AtomicInteger</code>）或并发容器（<code>ConcurrentHashMap</code>）。</li></ul></li><li><strong>性能测试建议</strong>：<ul><li>对比不同锁策略的耗时（如示例2和示例3的耗时差异）。</li><li>使用性能分析工具（如<code>JProfiler</code>、<code>VisualVM</code>）定位瓶颈。</li></ul></li></ol><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ol><li>**优先使用高层并发工具:**如<code>Executor</code>、<code>ConcurrentHashMap</code>。</li><li><strong>避免过早优化：</strong>仅在性能瓶颈出现时考虑低层同步。</li><li><strong>测试并发代码：</strong>使用压力测试工具（如<code>JMeter</code>）和静态分析工具（如<code>FindBugs</code>）。</li><li><strong>遵循不变性（Immutability）：</strong>使用<code>final</code>字段和不可变对象（如<code>String</code>）。</li></ol>]]></content>
    
    
    <summary type="html">并发，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>List</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-list/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-list/</id>
    <published>2025-06-23T06:15:36.000Z</published>
    <updated>2025-06-26T04:00:20.237Z</updated>
    
    <content type="html"><![CDATA[<p>List 是 Java 集合框架中的有序列表，元素按插入顺序存储，支持通过索引（从 0 开始）访问。类似数组，但提供动态增删功能，避免数组手动扩容和元素移动的繁琐。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="List的接口方法"><a href="#List的接口方法" class="headerlink" title="List的接口方法"></a>List的接口方法</h2><p>List接口继承自<code>Collection</code>接口，提供了额外的功能来处理索引位置上的元素。与Set、Map不同，List允许包含重复的元素，并且可以通过索引来访问或修改特定位置的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 核心接口方法 */</span></span><br><span class="line">add(E e) <span class="comment">// 添加指定元素到列表末尾。</span></span><br><span class="line">add(<span class="type">int</span> index, E element)<span class="comment">// 在指定索引处插入指定元素。</span></span><br><span class="line">remove(<span class="type">int</span> index) <span class="comment">// 移除指定索引处的元素。</span></span><br><span class="line">get(<span class="type">int</span> index) <span class="comment">// 获取指定索引处的元素。</span></span><br><span class="line">set(<span class="type">int</span> index, E element) <span class="comment">// 替换指定索引处的元素。</span></span><br><span class="line">size() <span class="comment">// 返回列表中的元素数量。</span></span><br><span class="line"><span class="comment">/* 其他常用方法 */</span> </span><br><span class="line">isEmpty() <span class="comment">// 判断列表是否为空。</span></span><br><span class="line">contains(Object o) <span class="comment">// 检查列表是否包含指定元素。</span></span><br><span class="line">indexOf(Object o) <span class="comment">// 返回指定元素首次出现的索引，如果不存在则返回-1。</span></span><br><span class="line">lastIndexOf(Object o) <span class="comment">// 返回指定元素最后一次出现的索引，如果不存在则返回-1。</span></span><br><span class="line">subList(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex) <span class="comment">// 获取从fromIndex（包括）到toIndex（不包括）之间的子列表</span></span><br></pre></td></tr></table></figure><h2 id="主要实现类"><a href="#主要实现类" class="headerlink" title="主要实现类"></a>主要实现类</h2><ol><li><p><code>ArrayList</code></p><p>ArrayList是最常用的List实现之一，它基于动态数组实现，支持随机访问，查询效率高，但插入和删除效率较低。<br><strong>特点</strong>：支持快速随机访问。非线程安全。初始容量为10，每次扩容时增长50%。<br><strong>使用场景</strong>：适用于频繁读取而不经常修改的数据集合。</p></li><li><p><code>LinkedList</code></p><p>LinkedList是另一个重要的List实现，它基于双向链表实现，对于插入和删除操作具有较高的性能，但对于随机访问效率较低。<br><strong>特点</strong>：支持高效的插入和删除操作。非线程安全。可以作为堆栈、队列或双端队列使用。<br><strong>使用场景</strong>：适用于频繁进行插入和删除操作的数据集合。</p></li><li><p><code>Vector</code></p><p>早期线程安全集合类，通过方法级<code>synchronized</code>实现同步。默认扩容增长一倍。<br><strong>特点</strong>：线程安全同步锁导致并发效率低下（方法都使用了 synchronized）。性能低（主要用于同步开销）。遗留类，不推荐使用</p></li><li><p>三者对比</p><table><thead><tr><th></th><th>ArrayList</th><th>LinkedList</th><th>Vector</th></tr></thead><tbody><tr><td>底层结构</td><td>动态数组</td><td>双向链表</td><td>动态数组</td></tr><tr><td>线程安全</td><td>不安全</td><td>不安全</td><td>安全，方法都加了<code>Synchronized</code></td></tr><tr><td>是否允许重复元素</td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td>是否有序</td><td>是</td><td>是</td><td>是</td></tr><tr><td>随机访问</td><td>快O(1)，索引访问</td><td>慢O(n)，需遍历链表</td><td>快O(1)，但因同步影响性能较低</td></tr><tr><td>插入/删除</td><td>慢O(n)，需移动元素</td><td>快O(1)，只需修改指针</td><td>慢，同步开销大</td></tr><tr><td>扩容机制</td><td>默认增长50%</td><td>无需扩容，动态添加节点</td><td>默认翻倍容量</td></tr><tr><td>加载因子</td><td>1</td><td>无</td><td>1</td></tr></tbody></table></li></ol><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><ol><li><p><code>for</code>循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：可以灵活控制索引。支持随机访问（适合 ArrayList）。</span></span><br><span class="line"><span class="comment">// 缺点：对于 LinkedList 来说效率较低（因为每次都要从头开始查找元素）。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Index: &quot;</span> + i + <span class="string">&quot;, Value: &quot;</span> + list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：简洁易读。适用于所有实现了 Iterable 接口的集合类。</span></span><br><span class="line"><span class="comment">// 缺点：无法获取索引。不能修改集合结构（如删除元素会抛出异常）。</span></span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Item: &quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Iterator</code>。可以安全地在遍历时进行删除操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;B&quot;</span>.equals(item)) &#123;</span><br><span class="line">        iterator.remove();  <span class="comment">// 安全删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="去重方式"><a href="#去重方式" class="headerlink" title="去重方式"></a>去重方式</h2><ol><li><p>利用 <code>HashSet</code> 或 <code>LinkedHashSet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet 不保留顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出顺序可能不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashSet 保留插入顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Stream.distinct()</code>，Java 8+ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; uniqueList = list.stream().distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(uniqueList);</span><br></pre></td></tr></table></figure></li></ol><h2 id="List-与数组的转换"><a href="#List-与数组的转换" class="headerlink" title="List 与数组的转换"></a>List 与数组的转换</h2><ul><li><p>List 转数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无类型参数：丢失类型信息</span></span><br><span class="line">Object[] array = list.toArray();</span><br><span class="line"><span class="comment">// 带类型参数：推荐，自动匹配类型</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 函数式写法</span></span><br><span class="line">String[] array = list.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></li><li><p>数组转 List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(array);（只读）</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));（可修改）</span><br></pre></td></tr></table></figure></li></ul><h2 id="List-的元素判断机制"><a href="#List-的元素判断机制" class="headerlink" title="List 的元素判断机制"></a>List 的元素判断机制</h2><p>List的 <code>contains(Object o)</code> 和 <code>indexOf(Object o)</code> 方法通过 <code>equals()</code>而非 <code>==</code> 判断元素是否相等。</p><hr><h1 id="List的安全类"><a href="#List的安全类" class="headerlink" title="List的安全类"></a>List的安全类</h1><p>在单线程应用中，通常采取<code>new ArrayList()</code>，指定一个List集合，用于存放可重复的数据。但<code>ArrayList</code>是不安全的集合。多线程操作同一集合对象信息，往往会出现<code>java.util.ConcurrentModificationException</code>异常报错信息。</p><h2 id="Java的安全类Vector"><a href="#Java的安全类Vector" class="headerlink" title="Java的安全类Vector"></a>Java的安全类Vector</h2><p>java提供了<code>java.util.Vector</code>类，多线程下不会出现<code>java.util.ConcurrentModificationException</code>报错信息。因为采取了 <code>synchronized</code> 针对方法执行调用者加锁，保证add操作的多线程安全性！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建lists集合</span></span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JUC下的安全List集合"><a href="#JUC下的安全List集合" class="headerlink" title="JUC下的安全List集合"></a>JUC下的安全List集合</h2><ol><li><code>Collections.synchronizedList(new ArrayList&lt;&gt;());</code>。该方法返回具有同步包装器的List，保证了对List的操作是安全的。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">( <span class="meta">@NotNull</span> List&lt;T&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(list <span class="keyword">instanceof</span> RandomAccess ? </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list) : </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">synchronizedList</span>&lt;&gt;(list));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断传入的 list 集合类型，判断类型是否为 java.util.RandomAccess，如果是则采取java.util.Collections.SynchronizedRandomAccessList构造集合，如果不是则采取java.util.Collections.SynchronizedList构造集合。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码中对应的add操作逻辑如下所示。采取synchronized同步代码块的方式，对数据的add操作实现加锁！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>&#123; </span><br><span class="line">    synchron1zed (mutex) &#123;</span><br><span class="line">        list.add(index, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>new CopyOnWriteArrayList();</code>。该类中所有修改操作都在一个独立的副本上进行，不会影响原始数据，保证了线程安全。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&quot;</span>+lists);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates an empty list</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyonWriteArrayList</span><span class="params">()</span>&#123; setArray(<span class="keyword">new</span> <span class="title class_">object</span>[<span class="number">0</span>]); &#125;</span><br><span class="line"><span class="comment">// add 逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[]elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copy0f(elements, len +<span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong><code>add</code>逻辑如下所示</strong><br>  1、调用add方法后，拿到<code>java.util.concurrent.locks.ReentrantLock</code>对象信息。<br>  2、调用 <code>lock.lock()</code> 拿到锁！<br>  3、将原数组对象<code>copy</code>操作，并创建<code>原数组大小+1</code>的新数组。<br>  4、将新数据放入新数组中。<br>  5、任何操作<code>finally</code>，都进行锁的释放！</p><p>原文链接：<a href="https://blog.csdn.net/qq_47980550/article/details/148012216">java基础——java集合list详解</a>、<a href="https://blog.csdn.net/qq_38322527/article/details/114703142">JUC中的List安全类集合</a></p>]]></content>
    
    
    <summary type="html">List是 Java 集合框架中的有序列表，元素按插入顺序存储，支持通过索引（从 0 开始）访问。类似数组，但提供动态增删功能，避免数组手动扩容和元素移动的繁琐。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="集合框架" scheme="https://southernfish.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Set</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-set/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-set/</id>
    <published>2025-06-23T05:49:36.000Z</published>
    <updated>2025-06-26T04:00:20.237Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的Set是集合框架（Collection Framework）的核心接口之一，用于存储无序且唯一的元素。主要实现类包括HashSet（基于哈希表）、LinkedHashSet（维护插入顺序）和TreeSet（基于红黑树排序），三者分别适用于快速查找、保持插入顺序和自然排序的场景。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>List是有序集合的根接口，Set是无序集合的根接口，无序也就意味着元素不重复。更严格地说，Set集合不包含一对元素e1和e2 ，使得e1.equals(e2) ，并且最多一个空元素。<br>使用Set存储的特点与List相反：<strong>元素无序、不可重复</strong>。常用的实现方式：HashSet、LinkedHashSet和TreeSet。</p><table><thead><tr><th>具体实现</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>HashSet</td><td>底层数据结构是哈希表，可以存储null元素，效率高</td><td>线程不安全，需要重写hashCode()和equals()来保证元素唯一性</td></tr><tr><td>LinkedHashSet</td><td>底层数据结构是链表和哈希表(链表保证了元素的顺序与存储顺序一致，哈希表保证了元素的唯一性)，效率高</td><td>线程不安全</td></tr><tr><td>TreeSet</td><td>底层数据结构是二叉树，元素唯一且已经排好序</td><td>需要重写hashCode和equals()来保证元素唯一性</td></tr></tbody></table><p>当向HashSet结合中存入一个元素时，HashSet会调用该对象的<code>hashCode()</code>方法来得到该对象的hashCode值，然后根据hashCode值来决定该对象在HashSet中存储位置。简单的说，<strong>HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等</strong>。<br>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p><p>在使用Set存储数据时，为保障元素唯一性，常常要重写hashCode。重写hashCode方法时，尽量遵循以下原则：</p><ul><li>相同的对象返回相同的hashCode值。</li><li>不同的对象返回不同的hashCode值，否则，就会增加冲突的概率。</li><li>尽量的让hashCode值散列开（用异或运算可使结果的范围更广）。</li></ul><p>原文链接：<a href="https://blog.csdn.net/m0_37741420/article/details/112407684">Java集合（四）Set的常用实现类</a></p><hr><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>HashSet是一个无序集合，其底层结构是HashMap，简单来说，HashSet是value是固定值（<code>Object PRESENT = new Object()</code>）的HashMap。HashSet的特点(<strong>底层是HashMap/元素无序且不能重复/线程不安全</strong>)：</p><ul><li><p>HashSet的<strong>底层实现是HashMap</strong>（HashSet的值存放于HashMap的key上，HashMap的value是一个统一的值）。</p></li><li><p>HashSet中的<strong>元素无序且不能重复</strong>（从插入HashSet元素的顺序和遍历HashSet的顺序对比可以看出：遍历顺序和存入到Set的顺序并不一致）。</p></li><li><p>HashSet是<strong>线程不安全</strong>的。如果要保证线程安全，其中一种方法是将其改造成线程安全的类，示例：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>(...));</span><br></pre></td></tr></table></figure></li><li><p>HashSet<code>允许存入null</code></p></li></ul><h2 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h2><p>把对象加入HashSet时，HashSet会<strong>先计算对象的hashcode值来判断对象加入的位置</strong>，同时也会与Set中其他元素的hashcode值作比较，如果没有相同的hashcode，HashSet会假设对象没有重复出现。如果发现有相同hashcode值的对象，这时会调用<code>equals</code>方法来检查<strong>hashcode相等的对象是否真的相同</strong>。如果两者相同，HashSet就不再存储该元素。<code>hashCode()</code>与 <code>equals()</code>的相关规定：</p><ul><li>如果两个对象相等，则hashcode一定也是相同的；</li><li>两个对象相等，对两个equals方法返回true；</li><li>两个对象有相同的hashcode值，它们也不一定是相等的；</li><li>如果equals方法被覆盖过，则hashCode方法也必须被覆盖；</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该 class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ul><h2 id="HashSet的使用"><a href="#HashSet的使用" class="headerlink" title="HashSet的使用"></a>HashSet的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> <span class="comment">// 默认初始容量为16，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> <span class="comment">// 指定初始容量，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> <span class="comment">// 指定初始容量和负载因子</span></span><br><span class="line"><span class="comment">/* 增、删、包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断Set是否为空    </span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> <span class="comment">//获取迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 返回此集合中的元素数        </span></span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>LinkedHashSet是有序集合，其底层是通过LinkedHashMap来实现的，LinkedHashMap其实也就是value是固定值的LinkedHashMap。因此LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。LinkedHashSet继承了HashSet。LinkedHashSet的特点(<strong>底层是LinkedHashMap/线程不安全/元素有序</strong>)：</p><ul><li><p>底层是用LinkedHashMap来实现的。</p></li><li><p>线程不安全 。</p></li><li><p>元素有序，是按照插入的顺序排序的。</p></li><li><p>最多只能存一个null。</p></li><li><p>不支持按访问顺序对元素排序</p><p>LinkedHashSet所有的构造方法都是调用HashSet的同一个构造方法：（accessOrder = false）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>TreeSet是一个有序集合，基于TreeMap实现。TreeSet特点(支持元素排序/线程不安全/):</p><ul><li><p>TreeSet支持元素的自然排序和按照在创建时指定的Comparator比较器(外比较器)进行排序</p><ul><li><p>TreeSet使用二叉树原理对新增对象按照指定顺序排序，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</p></li><li><p>TreeSet中存储自定义类的对象时， 自定义的类必须实现Comparable接口，并且覆写相应<code>compareTo()</code>函数。</p></li><li><p>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的。自己定义的类必须实现Comparable接口，并且覆写相应的compareTo()函数，才可以正常使用。</p></li><li><p>在重写compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>  <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(student s)</span> &#123;</span><br><span class="line">        <span class="comment">// 主要条件：按照年龄从小到大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="built_in">this</span>.age - s.age;</span><br><span class="line">        <span class="comment">//次要条件：年龄相同时，按照姓名的字母顺序排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num == <span class="number">0</span> ? <span class="built_in">this</span>.name.compareTo(s.name) : num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comparabledemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;student&gt; tree = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;student&gt;();</span><br><span class="line">        <span class="type">student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;wuer&quot;</span>,<span class="number">27</span>);</span><br><span class="line">        <span class="type">student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;weuers&quot;</span>,<span class="number">250</span>);</span><br><span class="line">        tree.add(s1);</span><br><span class="line">        tree.add(s2);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>TreeSet的基本操作（增删）的时间复杂度是log(n) 。</p></li><li><p>TreeSet是非线程安全的。</p></li><li><p>TreeSet的迭代器是fail-fast策略的。</p></li><li><p>TreeSet中元素不允许为null，不允许重复值。</p></li></ul><h2 id="TreeSet的使用"><a href="#TreeSet的使用" class="headerlink" title="TreeSet的使用"></a>TreeSet的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> <span class="comment">// 创建一个空的 TreeSet，使用自然排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> <span class="comment">// 指定比较器，如果比较器是 null 将使用自然排序</span></span><br><span class="line"><span class="comment">/* 增 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> <span class="comment">// 添加一个元素</span></span><br><span class="line"><span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> <span class="comment">// 添加集合中的元素</span></span><br><span class="line"><span class="comment">/* 删 */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> <span class="comment">// 检索和删除最小（第一个）元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> <span class="comment">// 检索和删除最大（最后）元素</span></span><br><span class="line"><span class="comment">/* 包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 获取特殊元素 */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">last</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">first</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">floor</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中小于或者等于给定元素的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">ceiling</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中大于或者等于给定元素的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">higher</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中大于某个元素的最小的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">lower</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中小于某个元素的最大的元素   </span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 获取TreeSet元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断TreeSet是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空TreeSet</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java中的Set是集合框架（Collection Framework）的核心接口之一，用于存储无序且唯一的元素。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="集合框架" scheme="https://southernfish.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Map</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-map/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-map/</id>
    <published>2025-06-23T02:45:36.000Z</published>
    <updated>2025-06-26T04:00:20.237Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap是基于哈希表实现的键值对存储结构，提供高效的插入和查询操作（平均时间复杂度O(1)），允许null键/值，非线程安全，且不保证元素顺序。其核心实现包括数组+链表（JDK1.7及之前）或数组+链表+红黑树（JDK1.8及之后），通过哈希冲突解决机制（链地址法）和动态扩容优化性能。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><a href="https://so.csdn.net/so/search?q=Collection%E6%8E%A5%E5%8F%A3&spm=1001.2101.3001.7020">Collection接口</a>的实现类中存储的是具体的单个元素，Map中存储的是键值对。常用的Map实现类有：HashMap、LinkedHashMap、TreeMap、HashTable和ConcurrentHashMap。</p><table><thead><tr><th>实现类</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>HashMap</td><td>基于哈希表实现，查询快，效率高</td><td>元素存储时无序，非线程安全</td></tr><tr><td>LinkedHashMap</td><td>基于哈希表和链表实现，可以保留元素插入时的顺序</td><td>非线程安全</td></tr><tr><td>TreeMap</td><td>存储的元素有序</td><td>非线程安全</td></tr><tr><td>HashTable</td><td>线程安全，不允许null值</td><td>效率低</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>线程安全，性能较好</td><td></td></tr></tbody></table><p>原文链接：<a href="https://blog.csdn.net/m0_37741420/article/details/112424663">Java集合（三）Map的常用实现类</a></p><hr><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><code>HashMap</code>是基于哈希表实现的键值对存储结构，HashMap的核心实现结合了<code>数组</code>、<code>链表</code>和<code>红黑树</code>。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>数组</code>：默认初始容量为16，数组的每个位置称为一个桶(<code>Bucket</code>)。容量始终为<strong>2的幂次方</strong>(如16、32)，便于通过位运算快速定位索引。<br><code>链表</code>：当多个键的哈希值冲突时，这些键值对以链表形式存储在同一个桶中（链地址法）。<br><code>红黑树</code>：当链表长度超过阈值（默认8）且数组容量≥64时，链表会转换为<code>红黑树</code>，以提高查找效率（从<code>O(n)</code>优化为<code>O(log n)</code>）。</p><h3 id="哈希函数与索引定位"><a href="#哈希函数与索引定位" class="headerlink" title="哈希函数与索引定位"></a>哈希函数与索引定位</h3><p>HashMap通过哈希函数将键映射到数组的索引位置。具体步骤如下：</p><ol><li><p>调用键的<code>hashCode()</code>方法获取哈希值。</p></li><li><p><strong>扰动处理：</strong>将高16位与低16位异或<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，减少哈希碰撞概率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>(n-1) &amp; hash</code>计算桶位置，等价于<code>hash % n</code>，但性能更高‌。</p></li></ol><h3 id="冲突处理机制"><a href="#冲突处理机制" class="headerlink" title="冲突处理机制"></a>冲突处理机制</h3><ol><li><p><strong>链地址法：</strong>冲突的键值对以链表形式链接。在JDK 8之前采用头插法，JDK 8之后采用尾插法以避免多线程下的死循环问题‌</p></li><li><p><strong>红黑树转换：</strong></p><ol><li><p>当链表长度≥8且数组容量≥64时，链表会转换为红黑树‌。</p></li><li><p>红黑树节点数≤6时，退化为链表</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250623125725272.png" alt="image-20250623125725272"></p></li></ol></li></ol><h3 id="动态扩容机制"><a href="#动态扩容机制" class="headerlink" title="动态扩容机制"></a>动态扩容机制</h3><p>HashMap的扩容机制基于负载因子（默认值为0.75）。当元素数量超过<code>容量乘以负载因子</code>时，比如<strong>当数组添加到16*0.75=12时</strong>，HashMap会自动触发扩容，扩容为自身的两倍：16*2=32。扩容步骤如下：</p><ol><li>创建一个新的数组，<code>容量为原容量的两倍</code>（保持2的幂次方）。</li><li>重新计算所有元素的位置并放入新数组的对应位置，利用高位快速判断元素是否需要移动（如原索引为<code>oldIndex</code>，新索引可能为<code>oldIndex</code>或<code>oldIndex + oldCapacity</code>）。</li><li>扩容后，链表或红黑树可能会被拆分到不同的桶中‌</li></ol><h2 id="关键操作"><a href="#关键操作" class="headerlink" title="关键操作"></a>关键操作</h2><ol><li><strong>插入（put</strong>）<ol><li>计算键的哈希值并定位桶索引。</li><li>桶为空：直接插入新节点。</li><li>桶非空：遍历链表或红黑树，若存在相同键（通过<code>equals</code>判断），则更新值；否则追加节点。</li><li>触发扩容：插入后检查元素总数是否超过阈值。</li></ol></li><li><strong>查询（get）</strong>：根据哈希值定位桶，遍历链表或红黑树，通过<code>equals</code>匹配键。</li></ol><h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><ul><li><p><strong>遍历EntrySet（键值对）</strong>：支持通过<code>iterator.remove()</code>安全删除元素(优点)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;K, V&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>遍历KeySet（仅键）</strong>：性能低于<code>EntrySet</code>遍历，需多次调用<code>get()</code>（缺点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;K&gt; keyIterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key); <span class="comment">// 需要额外查询值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for-each循环"></a>for-each循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历EntrySet</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历键</span></span><br><span class="line"><span class="keyword">for</span> (K key : map.keySet()) &#123; ... &#125;</span><br><span class="line"><span class="comment">// 遍历值</span></span><br><span class="line"><span class="keyword">for</span> (V value : map.values()) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式遍历（Java-8-）"><a href="#Lambda表达式遍历（Java-8-）" class="headerlink" title="Lambda表达式遍历（Java 8+）"></a>Lambda表达式遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach( (key, value) -&gt; System.out.println(key + <span class="string">&quot; : &quot;</span> + value) );</span><br></pre></td></tr></table></figure><h3 id="Stream-API遍历（Java-8-）"><a href="#Stream-API遍历（Java-8-）" class="headerlink" title="Stream API遍历（Java 8+）"></a>Stream API遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单线程遍历</span></span><br><span class="line">map.entrySet().stream().forEach(entry -&gt; ...);</span><br><span class="line"><span class="comment">// 多线程遍历</span></span><br><span class="line">map.entrySet().parallelStream().forEach(entry -&gt; ...);</span><br></pre></td></tr></table></figure><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><table><thead><tr><th><strong>遍历方式</strong></th><th><strong>时间复杂度</strong></th><th><strong>适用场景</strong></th><th><strong>线程安全</strong></th></tr></thead><tbody><tr><td>EntrySet迭代器</td><td>O(n)</td><td>需要删除元素</td><td>需手动同步</td></tr><tr><td>EntrySet for-each</td><td>O(n)</td><td>常规遍历</td><td>需手动同步</td></tr><tr><td>KeySet遍历</td><td>O(n)（性能较低）</td><td>仅需键</td><td>需手动同步</td></tr><tr><td>Lambda表达式</td><td>O(n)</td><td>代码简洁性优先</td><td>需手动同步</td></tr><tr><td>Stream API</td><td>O(n)</td><td>大数据量处理或并行计算</td><td>需手动同步</td></tr></tbody></table><p><strong>推荐选择</strong>：</p><ul><li><strong>需键值对</strong>：优先使用<code>entrySet()</code>（迭代器或for-each）。</li><li><strong>仅需键或值</strong>：直接遍历<code>keySet()</code>或<code>values()</code>。</li><li><strong>代码简洁性</strong>：Java 8+环境下推荐Lambda表达式。</li><li><strong>线程安全</strong>：改用<code>ConcurrentHashMap</code>或使用同步包装类。</li></ul><h2 id="HashMap安全"><a href="#HashMap安全" class="headerlink" title="HashMap安全"></a>HashMap安全</h2><h3 id="HashMap线程不安全的表现"><a href="#HashMap线程不安全的表现" class="headerlink" title="HashMap线程不安全的表现"></a>HashMap线程不安全的表现</h3><ol><li><strong>数据覆盖（丢失）</strong><br> <strong>场景：</strong>多线程同时调用 <code>put()</code> 方法插入数据。<br> <strong>原因：</strong>两个线程同时计算哈希值并定位到同一个桶(bucket)时，若该位置为空，可能发生数据覆盖。<strong>无锁导致复合操作非原子性</strong>。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设线程A和线程B同时执行以下代码</span></span><br><span class="line"><span class="keyword">if</span> (table[bucket] == <span class="literal">null</span>) &#123;</span><br><span class="line">    table[bucket] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value); <span class="comment">// 可能被覆盖</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK 1.8 的数据覆盖问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapUnsafeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;Map size: &quot;</span> + map.size()); <span class="comment">// 结果可能小于 1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>链表成环</strong>（JDK 1.7 的经典问题）<br> <strong>场景：</strong>多线程同时触发 <code>resize()</code>（扩容）。<br> <strong>原因：</strong>JDK 1.7 的 HashMap 使用<strong>头插法</strong>迁移链表，<strong>并发扩容时可能导致链表成环</strong>，后续的 <code>get()</code>操作触发死循环</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.7 的扩容代码（简化）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程A执行到这里挂起</span></span><br><span class="line">            e.next = newTable[bucket]; <span class="comment">// 线程B先执行，导致链表成环</span></span><br><span class="line">            newTable[bucket] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>size 不准确</strong><br> <strong>场景：</strong>多线程同时调用 <code>put()</code> 或 <code>remove()</code>。<br> <strong>原因：</strong>size 变量是非原子操作（如 size++），并发修改可能导致最终值错误。<strong>非原子操作 + 无可见性保证</strong>。</li></ol><h3 id="HashMap线程不安全的根本原因"><a href="#HashMap线程不安全的根本原因" class="headerlink" title="HashMap线程不安全的根本原因"></a>HashMap线程不安全的根本原因</h3><ol><li><strong>无同步机制</strong><br>HashMap 的设计目标是单线程高性能，未对多线程操作进行同步（如 <code>synchronized</code> 或 <code>CAS</code>）。<br>关键操作（<code>put()、get()、resize()</code>）没有锁保护。</li><li><strong>可见性问题</strong><br>多线程修改共享变量（如 <code>table、size</code>）时，未使用 <code>volatile</code> 关键字，可能导致一个线程的修改对其他线程不可见。</li><li><strong>复合操作非原子性</strong><br>例如 <code>put()</code> 操作包含多个步骤（计算哈希、定位桶、插入节点），多线程交叉执行时可能破坏内部结构。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>使用线程安全的替代类<pre><code>`Collections.synchronizedMap()`：通过包装类对所有方法加锁（性能较差）。`ConcurrentHashMap`：分段锁（JDK 1.7）或 CAS + synchronized（JDK 1.8），高并发性能更好。</code></pre></li><li>避免多线程直接操作 HashMap<br>  限制为单线程使用，或通过副本、消息队列等方式隔离并发访问。</li></ol><hr><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>在<code>jdk1.7</code>版本<ul><li>ConcurrentHashMap的数据结构是由一个<code>Segment</code>数组和多个<code>HashEntry</code>组成。</li><li>主要实现原理是实现了<strong>锁分离</strong>的思路，采用<strong>分段锁的机制</strong>，实现并发的更新操作。</li><li>底层采用<strong>数组+链表</strong>的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。</li><li>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到 的锁分离技术。每一个Segment元素存储的是HashEntry 数组+链表（若干个桶），这个和HashMap的数据存储结构一样。</li><li>HashEntry用来封装映射表的键值对，每个桶是由若干个HashEntry对象链接起来的链表。</li></ul></li><li>在<code>jdk1.8</code>后<ul><li>取消了Segment类，直接用table数组存储键值对。采用<code>Node + CAS + Synchronized</code>来保证并发安全。</li><li>Node数据结构比较简单，就是一个链表，但是只允许对数据进行查找，不允许进行修改。</li><li>当HashEntry对象组成的链表长度超过8时，或数组长度小于64 就会扩容，则链表转换为红黑树，提升性能。底层变更为<strong>数组＋链表＋红黑树</strong>。</li></ul></li></ul><h2 id="底层原理（jdk1-8）"><a href="#底层原理（jdk1-8）" class="headerlink" title="底层原理（jdk1.8）"></a>底层原理（jdk1.8）</h2><ol><li><p>Node节点数字用的是<code>volatile</code>修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap使用volatile修饰节点数组，保证其可见性，禁止指令重排。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p>ConcurrentHashMap的<code>put()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put()方法直接调用putVal()方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以直接看putVal()方法。</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            tab = initTable();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;                  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法并未用synchronized修饰。<strong>put过程如下：</strong><br>（1）根据 key 计算出 hashcode，然后开始遍历 table；<br>（2）判断是否需要初始化；<br>（3）f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。<br>（4）如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。<br>（5）如果都不满足，则利用 synchronized 锁写入数据。<br>（6）如果数量大于 TREEIFY_THRESHOLD ，则要转换为红黑树。</p></li><li><p>ConcurrentHashMap的<code>get()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap的get()方法是不加锁的，方法内部也没加锁。</span></span><br><span class="line"><span class="comment">// 因为table有`volatile`关键字修饰，保证每次获取值都是最新的。</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span></span><br></pre></td></tr></table></figure><p>get方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头节点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果头节点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get过程如下：</strong><br>（1）首先根据key计算出来的 hashcode 寻址，如果就在桶上那么直接返回值，<br>（2）如果是红黑树那就按照树的方式获取值，<br>（3）都不满足那就按照链表的方式遍历获取值。</p></li></ol><p>原文链接：<a href="https://blog.csdn.net/FAQEW/article/details/146542959">HashMap底层原理</a>、<a href="https://blog.csdn.net/winterPassing/article/details/148248794">HashMap安全性问题</a>、<a href="https://blog.csdn.net/qq_42077317/article/details/138009817">Java中的ConcurrentHashMap原理详解</a></p>]]></content>
    
    
    <summary type="html">HashMap是基于哈希表实现的键值对存储结构，提供高效的插入和查询操作（平均时间复杂度O(1)），允许null键/值，非线程安全，且不保证元素顺序。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="集合框架" scheme="https://southernfish.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的较难题</title>
    <link href="https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-hard/"/>
    <id>https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-hard/</id>
    <published>2025-06-22T13:30:36.000Z</published>
    <updated>2025-06-26T04:00:20.233Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集了一些<a href="https://leetcode.cn/">LeetCode</a>的一些较难的题目。</p><h2 id="找出两个正序数组的中位数"><a href="#找出两个正序数组的中位数" class="headerlink" title="找出两个正序数组的中位数"></a>找出两个正序数组的中位数</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 (归并、快速排序 n.log(n))。假设 nums1 和 nums2 不会同时为空。<br>示例 1: nums1 = [1, 3]   nums2 = [2]       则中位数是 2.0<br>示例 2: nums1 = [1, 2]   nums2 = [3, 4]   则中位数是 (2 + 3)/2 = 2.5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">problem1</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 偶数个 排序后 找下标 (nums1.length + nums2.length) / 2 和 (nums1.length + nums2.length) / 2 - 1</span></span><br><span class="line">    <span class="keyword">if</span>((nums1.length + nums2.length) % <span class="number">2</span> == <span class="number">0</span> )&#123; </span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 相同长度部分</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt;= nums2[j])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// right</span></span><br><span class="line">                    right = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot; -&gt;&quot;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// right</span></span><br><span class="line">                    right = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组1 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// right</span></span><br><span class="line">                right = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组2 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// right</span></span><br><span class="line">                right = nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left + right) <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 奇数个 找下标 (nums1.length + nums2.length - 1) / 2        </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;   </span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 相同长度部分</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt;= nums2[j])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组1 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组2 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支持’-’和’-’的正则表达式匹配"><a href="#支持’-’和’-’的正则表达式匹配" class="headerlink" title="支持’.’和’*’的正则表达式匹配"></a>支持’.’和’*’的正则表达式匹配</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持<code> &#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。<code>&#39;.&#39; </code>匹配任意单个字符；<code>&#39;*&#39; </code>匹配零个或多个前面的那一个元素所谓匹配，是要涵盖整个字符串 s的，而不是部分字符串。<br>说明：s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 <em>。<br>示例 1：输入: s = “aa”    p = “a”   输出: false。解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2：输入: s = “aa”    p = “a</em>“   输出: true。<br>    解释: ‘<em>‘ 代表可匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。<br>示例 3：输入: s = “ab”    p = “.</em>“   输出: true。解释: “.<em>“ 表示可匹配零个或多个（’</em>‘）任意字符（’.’）。<br>示例 4：输入: s = “aab”    p = “c<em>a</em>b”  输出: true。<br>    解释: 因为 ‘<em>‘ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。<br>示例 5：输入:s = “mississippi”  p = “mis</em>is<em>p</em>.”  输出: false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">problem2</span><span class="params">(String s, String p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((s.length() == <span class="number">0</span> || s == <span class="literal">null</span>) &amp;&amp; (p.length() == <span class="number">0</span> || p == <span class="literal">null</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">if</span>((p == <span class="literal">null</span> &amp;&amp; s != <span class="literal">null</span>) || (p != <span class="literal">null</span> &amp;&amp; s == <span class="literal">null</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode hard</summary>
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的中等难度题</title>
    <link href="https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-medium/"/>
    <id>https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-medium/</id>
    <published>2025-06-22T12:30:36.000Z</published>
    <updated>2025-06-26T04:00:20.233Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集了一些<a href="https://leetcode.cn/">LeetCode</a>的一些中等难度的题目。</p><h2 id="基础数据类型定义"><a href="#基础数据类型定义" class="headerlink" title="基础数据类型定义"></a>基础数据类型定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode1</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode1 next;</span><br><span class="line"></span><br><span class="line">    ListNode1(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode1</span><span class="params">(<span class="type">int</span> val , ListNode1 next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode1 <span class="title function_">reverseLink</span><span class="params">(ListNode1 head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode1</span> <span class="variable">head1</span> <span class="operator">=</span> head, next1 = head.next, prev1 = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            head1.next = prev1;</span><br><span class="line">            prev1 = head1;</span><br><span class="line">            head1 = next1;</span><br><span class="line">            next1 = head1.next;  <span class="comment">// next1 = next1.next;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>给出两个非空链表来表示两个非负的整数。其中，它们各自的位数是按照<code>逆序</code>的方式存储的，并且它们的每个节点只能存储一位数字。<br>如果我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。假设除了数字 0 之外，这两个数都不会以 0 开头。<br>示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)；输出：7 -&gt; 0 -&gt; 8。原因：342 + 465 = 807</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem</span><span class="params">(ListNode1 l1, ListNode1 l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2, re = head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span> || temp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            re.val = (p1.val + p2.val + temp) % <span class="number">10</span>;</span><br><span class="line">            temp = (p1.val + p2.val + temp) / <span class="number">10</span>;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1 == <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;     <span class="comment">// p2 长</span></span><br><span class="line">            re.val = (p2.val + temp) % <span class="number">10</span>;</span><br><span class="line">            temp = (p2.val + temp) / <span class="number">10</span>;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 == <span class="literal">null</span>) &#123;   <span class="comment">// p1 长</span></span><br><span class="line">            re.val = (p1.val + temp) % <span class="number">10</span>;</span><br><span class="line">            temp = (p1.val + temp) / <span class="number">10</span>;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">            re.val = temp;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span> || temp != <span class="number">0</span>) &#123;</span><br><span class="line">            re.next = <span class="keyword">new</span> <span class="title class_">ListNode1</span>(<span class="number">0</span>);</span><br><span class="line">            re = re.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            re.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem_pre</span><span class="params">(ListNode1 l1, ListNode1 l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2, re = head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span> || temp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (p1 != <span class="literal">null</span> ? p1.val : <span class="number">0</span>)  + (p2 != <span class="literal">null</span> ? p2.val : <span class="number">0</span>) + temp;</span><br><span class="line">        temp = sum / <span class="number">10</span>;</span><br><span class="line">        re.next = <span class="keyword">new</span> <span class="title class_">ListNode1</span>(sum % <span class="number">10</span>);</span><br><span class="line">        p1 = p1 != <span class="literal">null</span> ?  p1.next : <span class="literal">null</span>;</span><br><span class="line">        p2 = p2 != <span class="literal">null</span> ?  p2.next : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不含重复字符的最长子串长度"><a href="#不含重复字符的最长子串长度" class="headerlink" title="不含重复字符的最长子串长度"></a>不含重复字符的最长子串长度</h2><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。  请注意，你的答案必须是子串的长度。<br>示例 1: 输入: “abcabcbb”。输出: 3。解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2: 输入: “bbbbb”。输出: 1。解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3: 输入: “pwwkew”。输出: 3。解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(String strSrc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strSrc.equals(<span class="string">&quot;&quot;</span>) || strSrc.length() == <span class="number">0</span> || strSrc.length() == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;源字符串&lt;&quot;</span> + strSrc + <span class="string">&quot;&gt;的最长子串&lt;&quot;</span> + strSrc + <span class="string">&quot;&gt;长度为 &gt;&gt; &quot;</span> + strSrc.length());</span><br><span class="line">        <span class="keyword">return</span> strSrc.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + strSrc.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> subStr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> maxStr.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strSrc.length(); ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; subStr.length(); j++) &#123;  <span class="comment">// 和子串的全部字符比较</span></span><br><span class="line">            <span class="keyword">if</span> (strSrc.charAt(i) == subStr.charAt(j)) &#123; <span class="comment">// 有重复字符 回退 子串长度-1 位 当前字符为新子串 指针下一位</span></span><br><span class="line">                count++;</span><br><span class="line">                i = i - subStr.length() + <span class="number">1</span>;</span><br><span class="line">                subStr = <span class="string">&quot;&quot;</span> + strSrc.charAt(i);</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == subStr.length() &amp;&amp; flag &amp;&amp; i &lt; strSrc.length()) &#123; <span class="comment">// 比完没有重复字符  当前字符串加入字符集</span></span><br><span class="line">            subStr = subStr + strSrc.charAt(i);</span><br><span class="line">            maxStr = maxStr.length() &lt; subStr.length() ? subStr : maxStr;</span><br><span class="line">            maxLen = maxStr.length();</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;源字符串&lt;&quot;</span> + strSrc + <span class="string">&quot;&gt;的最长子串&lt;&quot;</span> + maxStr + <span class="string">&quot;&gt;长度为 &gt;&gt; &quot;</span> + maxLen);</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>) || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + s.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> subStr.length();</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; subStr.length(); j++) &#123;  <span class="comment">// 和子串的全部字符比较</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == subStr.charAt(j)) &#123; <span class="comment">// 有重复字符 回退 子串长度-1个位置 取当前字符为新子串 指针下一位</span></span><br><span class="line">                i = i - subStr.length() + <span class="number">1</span>;</span><br><span class="line">                subStr = <span class="string">&quot;&quot;</span> + s.charAt(i);</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == subStr.length() &amp;&amp; flag &amp;&amp; i &lt; s.length()) &#123; <span class="comment">// 比完没有重复字符  当前字符串加入字符集</span></span><br><span class="line">            subStr = subStr + s.charAt(i);</span><br><span class="line">            maxLen = maxLen &gt; subStr.length() ? maxLen : subStr.length();</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找出字符串中最长回文子串"><a href="#找出字符串中最长回文子串" class="headerlink" title="找出字符串中最长回文子串"></a>找出字符串中最长回文子串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：输入: “babad”。输出: “bab”。注意: “aba” 也是一个有效答案。<br>示例 2：输入: “cbbd”。输出: “bb”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> dp[][] = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s.length(); j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 枚举所有子串长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; s.length(); l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123; <span class="comment">// 枚举子串的起始位置 i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + l; <span class="comment">// 通过 j=i+l 得到子串的结束位置</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= s.length()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = (s.charAt(i) == s.charAt(j));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s.charAt(i) == s.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断回文串长度</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; l + <span class="number">1</span> &gt; result.length())&#123;</span><br><span class="line">                result = s.substring(i, j + <span class="number">1</span>); <span class="comment">// 取值为左闭右开区间 [ start, end )</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将给定字符串按给定行数Z字排列"><a href="#将给定字符串按给定行数Z字排列" class="headerlink" title="将给定字符串按给定行数Z字排列"></a>将给定字符串按给定行数Z字排列</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。具体示例如下图所示。请你实现这个将字符串进行指定行数变换的函数： <code>string convert(string s, int numRows);</code></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250622221010005.png" alt="image-20250622221010005"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*官方解答</span></span><br><span class="line"><span class="comment">按顺序遍历字符串 s；</span></span><br><span class="line"><span class="comment">res[i] += c： 把每个字符 c 填入对应行s_i；</span></span><br><span class="line"><span class="comment">i += flag： 更新当前字符 c 对应的行索引；</span></span><br><span class="line"><span class="comment">flag = - flag： 在达到 ZZ 字形转折点时，执行反向*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;StringBuilder&gt;();  <span class="comment">// 每一行的字符数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        rows.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, flag = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray()) &#123; <span class="comment">// 所有字符串</span></span><br><span class="line">        rows.get(i).append(c); <span class="comment">// 实际上 遍历了rows数组</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || i == numRows - <span class="number">1</span>)&#123; <span class="comment">// 转折点 反向遍历</span></span><br><span class="line">            flag = -flag;</span><br><span class="line">        &#125;</span><br><span class="line">        i += flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(StringBuilder row : rows) &#123;</span><br><span class="line">        res.append(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串转整数的实现函数-atoi"><a href="#字符串转整数的实现函数-atoi" class="headerlink" title="字符串转整数的实现函数 atoi"></a>字符串转整数的实现函数 atoi</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的<strong>转化规则如下</strong>：<br>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。在任何情况下，若函数不能进行有效的转换时，请返回 0 。<br>提示：本题中的空白字符只包括空格字符 ‘ ‘ 。假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。<br>示例 1: 输入: “42”。输出: 42。<br>示例 2: 输入: “   -42”。输出: -42<br>    解释: 第一个非空白字符为 ‘-‘是一个负号。尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3: 输入: “4193 with words”  输出: 4193。解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4: 输入: “words and 987”。输出: 0。解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。<br>示例 5: 输入: “-91283472332”。输出: -2147483648。解释: 数字”-91283472332”超过32位有符号整数范围。返回 INT_MIN (−231) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span> || str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, flag = <span class="number">0</span>; <span class="comment">// flag 表示有没有数字</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">numStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27; &#x27;</span> &amp;&amp; numStr.length() == <span class="number">0</span>) &#123; <span class="comment">// 忽略有效字符前面的空格</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; (str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span> || str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">            &amp;&amp; (str.charAt(i) != <span class="string">&#x27;-&#x27;</span> &amp;&amp; str.charAt(i) != <span class="string">&#x27;+&#x27;</span>)) &#123; <span class="comment">// 排除第一个有效字符不是 + - 0到9的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; numStr.length() == <span class="number">1</span> &amp;&amp; (str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>)) &#123; </span><br><span class="line">            <span class="comment">// + - 后面不是0-9的数字</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span> &amp;&amp; (str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>)) &#123; <span class="comment">// 一串有效值后遇到了非数字字符</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; (str.charAt(i) == <span class="string">&#x27;-&#x27;</span> || str.charAt(i) == <span class="string">&#x27;+&#x27;</span>)) &#123; <span class="comment">// 第一个字符是 + -</span></span><br><span class="line">            numStr = numStr + str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            numStr = numStr + str.charAt(i);</span><br><span class="line">            target = target <span class="number">10</span> + (str.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!numStr.equals(<span class="string">&quot;&quot;</span>) &amp;&amp; numStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        target = <span class="number">0</span> - target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; Math.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span> || target &lt; Math.pow(-<span class="number">2</span>, <span class="number">31</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> numStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span> ? (<span class="type">int</span>) Math.pow(-<span class="number">2</span>, <span class="number">31</span>) : (<span class="type">int</span>) Math.pow(<span class="number">2</span>, <span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大容量的容器"><a href="#最大容量的容器" class="headerlink" title="最大容量的容器"></a>最大容量的容器</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code>。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。<br>示例：输入：[1,8,6,2,5,4,8,3,7]。输出：49</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="literal">null</span> || height.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> bottomLen, target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            bottomLen = j - i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> bottomLen Math.min(height[i], height[j]);</span><br><span class="line">            target = Math.max(target, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>罗马数字包含以下七种字符:I，V，X，L，C，D和M。<br>字符（数值）对应关系：I（1）、V（5）、X（10）、L（50）、C（100）、D（500）、M（1000）<br>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：<br>I可以放在V(5)        和X(10)       的左边，来表示 4        和9。<br>X可以放在L(50)     和C(100)     的左边，来表示 40     和90。<br>C可以放在D(500)  和M(1000)  的左边，来表示 400  和900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1到 3999 的范围内<br>示例 1: 输入:”III”            输出: 3<br>示例 2: 输入:”IV”            输出: 4<br>示例 3: 输入:”IX”                输出: 9<br>示例 4: 输入:”LVIII”            输出: 58         解释: L = 50, V= 5, III = 3。<br>示例 5: 输入:”MCMXCIV”      输出: 1994         解释: M = 1000, CM = 900, XC = 90, IV = 4。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String sub[] = &#123;<span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;M&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> cons[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">90</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">500</span>, <span class="number">900</span>, <span class="number">1000</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cons.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num / cons[i] == <span class="number">0</span>) &#123; <span class="comment">// 不能匹配当前了 则匹配较小的</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num / cons[i] != <span class="number">0</span>) &#123; <span class="comment">// 减去已经匹配的</span></span><br><span class="line">            target = target + sub[i];</span><br><span class="line">            num -= cons[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中三数之和为0的三元组"><a href="#数组中三数之和为0的三元组" class="headerlink" title="数组中三数之和为0的三元组"></a>数组中三数之和为0的三元组</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。<br>示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2] ]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;Integer&gt;&gt; problem8(int[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; re = new ArrayList&lt;&gt;();</span><br><span class="line">    // 找出所有的三元组 [a, b, c] 对应的指针分别为 i j k</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    Arrays.<span class="built_in">sort</span>(nums);  // 从小到大排序</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;//  跳过数组中的重复元素</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = n - 1; // c对应的指针初始指向数组的最右端</span><br><span class="line">        <span class="keyword">for</span> (int j = i + 1; j &lt; nums.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;//  跳过数组中的重复元素</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k &gt; j &amp;&amp; nums[i] + nums[j] + nums[k] &gt; 0) &#123;  // 保证 b 的指针在 c 的指针的左侧</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果指针重合，随着 b增大 不再存在满足 a+b+c=0 并且 b &lt; c 的 c</span><br><span class="line">            <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == 0) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                list.add(nums[j]);</span><br><span class="line">                list.add(nums[k]);</span><br><span class="line">                re.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中与给定值最接近的三数之和"><a href="#数组中与给定值最接近的三数之和" class="headerlink" title="数组中与给定值最接近的三数之和"></a>数组中与给定值最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。<br>示例：输入：nums = [-1,2,1,-4], target = 1    输出：2。解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。<br>提示：3 &lt;= nums.length &lt;= 10^3；-10^3 &lt;= nums[i] &lt;= 10^3；-10^4 &lt;= target &lt;= 10^4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 每个三元组 [a, b, c] 对应的指针分别为 i j k</span></span><br><span class="line">    Arrays.sort(nums);  <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">3</span>) &#123; <span class="comment">// 只有三位数</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res - target == <span class="number">0</span>) &#123; <span class="comment">// 前三位之和为target</span></span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 跳过数组中的重复元素</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// c对应的指针初始指向数组的最右端</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; j) &#123; <span class="comment">// 保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k];</span><br><span class="line">            <span class="keyword">if</span> (temp == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(res - target) &gt;= Math.abs(temp - target)) &#123;</span><br><span class="line">                res = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (temp &gt; target) &#123; <span class="comment">// 当前和比目标值较大 第三个数减小 右往左</span></span><br><span class="line">                k = k - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) &#123; <span class="comment">// 跳过数组中的重复元素</span></span><br><span class="line">                    k = k - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; target) &#123; <span class="comment">// 当前和比目标值较小 第二个数增大 左往右</span></span><br><span class="line">                j = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123; <span class="comment">// 跳过数组中的重复元素</span></span><br><span class="line">                    j = j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拼音九键中给定两数字对应字符串列表"><a href="#拼音九键中给定两数字对应字符串列表" class="headerlink" title="拼音九键中给定两数字对应字符串列表"></a>拼音九键中给定两数字对应字符串列表</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话(拼音九键)按键相同）。<br>注意： 1 不对应任何字母。示例：输入：”23”。输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">problem</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">    List&lt;String&gt; re = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (digits.length() == <span class="number">0</span> || digits.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> digit[] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    String corr[] = &#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;!@#&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    re = findCombination(re, corr, digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findCombination</span><span class="params">(List&lt;String&gt; re, String[] corr, String digits, <span class="type">int</span> index, String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">        re.add(s);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">    <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> corr[c - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; letters.length(); i++) &#123;</span><br><span class="line">        findCombination(re, corr, digits, index + <span class="number">1</span>, s + letters.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转每对括号间的子串"><a href="#反转每对括号间的子串" class="headerlink" title="反转每对括号间的子串"></a>反转每对括号间的子串</h2><p>给出一个字符串 s（仅含有小写英文字母和括号）。请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。注意，结果中不应包含任何括号。<br>示例 1：输入：s = “(abcd)”。输出：”dcba”<br>示例 2：输入：s = “(u(love)i)”。输出：”iloveu”。解释：先反转子字符串 “love” ，然后反转整个字符串。<br>示例 3：输入：s = “(ed(et(oc))el)”。输出：”leetcode”。解释：先反转子字符串 “oc” ，接着反转 “etco” ，然后反转整个字符串。<br>提示：1 &lt;= s.length &lt;= 2000；s 中只有小写英文字母和括号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            reverse(arr, stack.pop() + <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="string">&#x27;)&#x27;</span> &amp;&amp; arr[i] != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            sb.append(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = tmp;</span><br><span class="line">        right--;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode medium</summary>
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的简单题</title>
    <link href="https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-easy/"/>
    <id>https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-easy/</id>
    <published>2025-06-22T11:58:36.000Z</published>
    <updated>2025-06-26T04:00:20.233Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集了一些<a href="https://leetcode.cn/">LeetCode</a>的一些简单的题目</p><h2 id="基础数据类型定义"><a href="#基础数据类型定义" class="headerlink" title="基础数据类型定义"></a>基础数据类型定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode1</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode1 next;</span><br><span class="line">    ListNode1() &#123;&#125;</span><br><span class="line">    ListNode1(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode1(<span class="type">int</span> val, ListNode1 next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode1</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode1 left;</span><br><span class="line">     TreeNode1 right;</span><br><span class="line">    </span><br><span class="line">     TreeNode1(<span class="type">int</span> x) &#123;</span><br><span class="line">         val = x;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和为目标值的两数在数组中的下标"><a href="#和为目标值的两数在数组中的下标" class="headerlink" title="和为目标值的两数在数组中的下标"></a>和为目标值的两数在数组中的下标</h2><p>给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br>示例: nums = [2, 7, 11, 15], target = 9。因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] problem(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> result[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32位整数反转"><a href="#32位整数反转" class="headerlink" title="32位整数反转"></a>32位整数反转</h2><p>给出一个 <code>32位</code>的有符号整数，你需要将这个整数中每位上的数字进行反转。注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为<code>[−231, 231− 1]</code>。请根据这个假设，如果反转后整数溢出那么就返回 0。<br>示例 1: 输入: 123   输出: 321<br>示例 2: 输入: -123  输出: -321<br>示例 3: 输入: 120   输出: 21</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;     </span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// int  溢出问题</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;        <span class="comment">// 1534236469</span></span><br><span class="line">        len = (x + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        len = (x + <span class="string">&quot;&quot;</span>).length() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        target += tempMath.pow(<span class="number">10</span>, len - <span class="number">1</span>);</span><br><span class="line">        len = len - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println((<span class="type">int</span>)Math.pow(<span class="number">2</span>, <span class="number">31</span>) + <span class="string">&quot; --- &quot;</span> + Math.pow(<span class="number">2</span>, <span class="number">31</span>));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) target == target ? <span class="type">int</span>(target) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        target = target10 + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((target &gt; Math.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) || (target &lt; Math.pow(-<span class="number">2</span>, <span class="number">31</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((target &gt; Math.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) || (target &lt; Math.pow(-<span class="number">2</span>, <span class="number">31</span>))) ? <span class="number">0</span> : (<span class="type">int</span>) target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回文数判断"><a href="#回文数判断" class="headerlink" title="回文数判断"></a>回文数判断</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>示例 1: 输入: 121  输出: true<br>示例 2: 输入: -121 输出: false  解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3: 输入: 10    输出: false  解释: 从右向左读, 为 01 。因此它不是一个回文数。<br><strong>进阶:</strong> 能不将整数转为字符串来解决这个问题吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)) &#123; <span class="comment">// 负数都不是回文数  除0以外的整十数都不是回文数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> x + <span class="string">&quot;&quot;</span>; </span><br><span class="line">    System.out.println(src.length());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = src.length() - <span class="number">1</span>; i &lt;= src.length() / <span class="number">2</span> &amp;&amp; j &gt;= src.length() / <span class="number">2</span>; i++, j--) &#123;</span><br><span class="line">        System.out.println(src.charAt(i) + <span class="string">&quot;&lt;----&gt;&quot;</span> + src.charAt(j));</span><br><span class="line">        <span class="keyword">if</span> (src.charAt(i) != src.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不使用字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)) &#123; <span class="comment">// 负数都不是回文数  除0以外的整十数都不是回文数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (x + <span class="string">&quot;&quot;</span>).length() / <span class="number">2</span>, target = <span class="number">0</span>, isEven = (x + <span class="string">&quot;&quot;</span>).length() % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        target += (<span class="type">int</span>) tempMath.pow(<span class="number">10</span>, count - <span class="number">1</span>);</span><br><span class="line">        count = count - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;--&gt;&quot;</span> + target);</span><br><span class="line">    <span class="keyword">if</span> (isEven == <span class="number">0</span> &amp;&amp; target != x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEven == <span class="number">1</span> &amp;&amp; target != (x / <span class="number">10</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>罗马数字包含以下七种字符:I，V，X，L，C，D和M。<br>字符（数值）对应关系：I（1）、V（5）、X（10）、L（50）、C（100）、D（500）、M（1000）<br>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：<br>I可以放在V(5)        和X(10)       的左边，来表示 4        和9。<br>X可以放在L(50)     和C(100)     的左边，来表示 40     和90。<br>C可以放在D(500)  和M(1000)  的左边，来表示 400  和900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1到 3999 的范围内<br>示例 1: 输入:”III”            输出: 3<br>示例 2: 输入:”IV”            输出: 4<br>示例 3: 输入:”IX”                输出: 9<br>示例 4: 输入:”LVIII”            输出: 58         解释: L = 50, V= 5, III = 3。<br>示例 5: 输入:”MCMXCIV”      输出: 1994         解释: M = 1000, CM = 900, XC = 90, IV = 4。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        char constant[] = &#123;&#x27;I&#x27;,&#x27;V&#x27;,&#x27;X&#x27;,&#x27;L&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;M&#x27;&#125;;</span></span><br><span class="line">    <span class="type">int</span> cons[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">1000</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">SRC</span> <span class="operator">=</span> <span class="string">&quot;IVXLCDM&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s.charAt(i) == <span class="string">&#x27;I&#x27;</span> &amp;&amp; (s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;V&#x27;</span> || s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;X&#x27;</span>)) ||</span><br><span class="line">                (s.charAt(i) == <span class="string">&#x27;X&#x27;</span> &amp;&amp; (s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;L&#x27;</span> || s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;C&#x27;</span>)) ||</span><br><span class="line">                (s.charAt(i) == <span class="string">&#x27;C&#x27;</span> &amp;&amp; (s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;D&#x27;</span> || s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;M&#x27;</span>))) &#123;</span><br><span class="line">            target += cons[SRC.indexOf(s.charAt(i + <span class="number">1</span>))] - cons[SRC.indexOf(s.charAt(i))];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target += cons[SRC.indexOf(s.charAt(i))];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="keyword">if</span> (i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        target += cons[SRC.indexOf(s.charAt(i))];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串数组的最长公共前缀"><a href="#字符串数组的最长公共前缀" class="headerlink" title="字符串数组的最长公共前缀"></a>字符串数组的最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。 说明: 所有输入只包含小写字母a-z。<br>如果不存在公共前缀，返回空字符串””。<br>示例 1: 输入: [“flower”,”flow”,”flight”]  输出: “fl”<br>示例 2: 输入: [“dog”,”racecar”,”car”]     输出: “” 解释: 输入不存在公共前缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.min(strs[i].length(), prefix.length()); <span class="comment">// 比较直到较小长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 字符比较 下标</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; len &amp;&amp; prefix.charAt(index) == strs[i].charAt(index)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        prefix = prefix.substring(<span class="number">0</span>, index); <span class="comment">// 取公共前缀</span></span><br><span class="line">        <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123; <span class="comment">// 前缀已经为空 则退出比较</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效字符串判定"><a href="#有效字符串判定" class="headerlink" title="有效字符串判定"></a>有效字符串判定</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>    左括号必须用相同类型的右括号闭合。<br>    左括号必须以正确的顺序闭合。<br>    注意空字符串可被认为是有效字符串。<br>示例 1: 输入: “()”  输出: true<br>示例 2: 输入: “()[]{}”    输出: true<br>示例 3: 输入: “(]”   输出: false<br>示例 4: 输入: “([)]”   输出: false<br>示例 5: 输入: “{[]}” 输出: true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">problem</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 空串合法</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个字符为右括号 或者 串长为奇数 非法</span></span><br><span class="line">    <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">&#x27;)&#x27;</span> || s.charAt(<span class="number">0</span>) == <span class="string">&#x27;]&#x27;</span> || s.charAt(<span class="number">0</span>) == <span class="string">&#x27;&#125;&#x27;</span> || s.length() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//左括号进栈  右括号出栈 判断是否合法</span></span><br><span class="line">    <span class="type">char</span> stack[] = <span class="keyword">new</span> <span class="title class_">char</span>[s.length()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span> || s.charAt(i) == <span class="string">&#x27;[&#x27;</span> || s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack[top++] = s.charAt(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--top];</span><br><span class="line">            <span class="keyword">if</span> ((temp == <span class="string">&#x27;(&#x27;</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) || (temp == <span class="string">&#x27;[&#x27;</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27;]&#x27;</span>) ||</span><br><span class="line">                        (temp == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27;&#125;&#x27;</span>)) &#123;</span><br><span class="line">                </span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top != <span class="number">0</span>) &#123;  <span class="comment">// 栈不空 非法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个升序链表"><a href="#合并两个升序链表" class="headerlink" title="合并两个升序链表"></a>合并两个升序链表</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过 拼接给定的两个链表的所有节点 组成的。<br>示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4; 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem</span><span class="params">(ListNode1 l1, ListNode1 l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span> &amp;&amp; l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1 == <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2, h;</span><br><span class="line">    <span class="keyword">if</span> (p1.val &lt; p2.val) &#123;</span><br><span class="line">        h = p1;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        h = p2;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">head</span> <span class="operator">=</span> h;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt; p2.val) &#123;</span><br><span class="line">            h.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span>) &#123; <span class="comment">// l1剩下的</span></span><br><span class="line">        h.next = p1;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span>) &#123; <span class="comment">// l2 剩下的</span></span><br><span class="line">        h.next = p2;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序数组原地去重"><a href="#排序数组原地去重" class="headerlink" title="排序数组原地去重"></a>排序数组原地去重</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 【原地】修改输入数组 并在使用 O(1) 额外空间的条件下完成。<br>示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>      不需要考虑数组中超出新长度后面的元素。<br>示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。       不需要考虑数组中超出新长度后面的元素。<br>说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:<br>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br><code>int len = removeDuplicates(nums);</code><br>// 在函数里修改输入数组对于调用者是可见的。根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br><code>for (int i = 0; i &lt; len; i++) &#123; print(nums[i]); &#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] != nums[i]) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            nums[index] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原地删除数组中特定值"><a href="#原地删除数组中特定值" class="headerlink" title="原地删除数组中特定值"></a>原地删除数组中特定值</h2><p>给你一个数组 nums和一个值 val，你需要 原地 移除所有数值等于val的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>       你不需要考虑数组中超出新长度后面的元素。<br>示例2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>       注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。<br>说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:<br>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br><code>int len = removeElement(nums, val);</code><br>// 在函数里修改输入数组对于调用者是可见的。根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br><code>for (int i = 0; i &lt; len; i++) &#123; print(nums[i]); &#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现strStr-函数"><a href="#实现strStr-函数" class="headerlink" title="实现strStr()函数"></a>实现strStr()函数</h2><p>给定一个haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。<br>示例 1: 输入: haystack = “hello”, needle = “ll”   输出: 2<br>示例 2: 输入: haystack = “aaaaa”, needle = “bba”  输出: -1<br>说明: 当needle是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当needle是空字符串时我们应当返回 0 。这与C语言的<code>strstr()</code>以及 Java的<code>indexOf()</code>定义相符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem10</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.length() == <span class="number">0</span> || needle.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haystack.length() &lt; needle.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> haystack.length() - needle.length() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; diff; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; needle.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123; <span class="comment">// 不匹配 退出比较</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.length()) &#123; <span class="comment">// 比完 第一次找到匹配的needle  退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == diff) &#123; <span class="comment">// 比完 没找到</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在排序数组中找目标值"><a href="#在排序数组中找目标值" class="headerlink" title="在排序数组中找目标值"></a>在排序数组中找目标值</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。<br>示例 1: 输入: [1,3,5,6], 5      输出: 2<br>示例 2: 输入: [1,3,5,6], 2      输出: 1<br>示例 3: 输入: [1,3,5,6], 7      输出: 4<br>示例 4: 输入: [1,3,5,6], 0      输出: 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target || (i == <span class="number">0</span> &amp;&amp; nums[i] &gt; target)) &#123; <span class="comment">// 原数组中找到了  target 或者比第一个还小</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] &lt; target &amp;&amp; nums[i + <span class="number">1</span>] &gt; target) &#123;  </span><br><span class="line">            <span class="comment">// 插在数组的第 2 到第 nums.length-1个位置</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.length; <span class="comment">// 插到第 nums.length 个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h2><p>外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：<br><code>1（1）、2（11）、3（21）、4（1211）、5（111221）</code><br><code>1</code>读作”one 1”(“一个一”),即11。<code>11</code>读作”two 1”(“两个一”）,即21。<code>21</code>读作”one 2”,”one 1”（”一个二”,”一个一”), 即1211。<br>给定一个正整数 n（1 ≤n≤ 30），输出外观数列的第 n 项。<strong>注意：</strong>整数序列中的每一项将表示为一个字符串。<br>示例 1: 输入: 1 输出: “1”        解释：这是一个基本样例。<br>示例 2: 输入: 4  输出: “1211”<br>解释：当 n = 3 时，序列是 “21”，其中我们有 “2” 和 “1” 两组，”2” 可以读作 “12”，也就是出现频次 = 1 而 值 = 2；类似 “1” 可以读作 “11”。所以答案是 “12” 和 “11” 组合在一起，也就是 “1211”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;  <span class="comment">// 首项</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123; <span class="comment">// 第二项</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 推导</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">nextStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>, index = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; str.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str.charAt(index) == str.charAt(j)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextStr = nextStr + count + str.charAt(index);</span><br><span class="line">                    index = j;</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == str.length()) &#123; <span class="comment">// 比到了最后</span></span><br><span class="line">                nextStr = nextStr + count + str.charAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">            str = nextStr;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; ---&gt;&gt; &quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大连续数组"><a href="#最大连续数组" class="headerlink" title="最大连续数组"></a>最大连续数组</h2><p>给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6。解释:连续子数组[4,-1,2,1] 的和最大，为6。<br>进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> nums[<span class="number">0</span>], max = target, index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        target += nums[i];</span><br><span class="line">        max = max &gt; target ? max : target;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.length - <span class="number">1</span> &amp;&amp; index &lt; nums.length) &#123; <span class="comment">// 已经最后 回退</span></span><br><span class="line">            System.out.println(index + <span class="string">&quot; --&gt; &quot;</span> + max);</span><br><span class="line">            i = index++ - <span class="number">1</span>; <span class="comment">// 执行完后 i会加1;</span></span><br><span class="line">            target = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    <span class="comment">/*考虑分治的方法*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算字符串中最后一个单词的长度"><a href="#计算字符串中最后一个单词的长度" class="headerlink" title="计算字符串中最后一个单词的长度"></a>计算字符串中最后一个单词的长度</h2><p>给定一个仅包含大小写字母和空格’ ‘的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。如果不存在最后一个单词，请返回 0。说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。<br>示例: 输入: “Hello World”  输出: 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem14</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// 从后往前看第一个单词的长度</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组代表一个数字，做加一计算"><a href="#数组代表一个数字，做加一计算" class="headerlink" title="数组代表一个数字，做加一计算"></a>数组代表一个数字，做加一计算</h2><p>给定一个由整数组成的 【非空数组】 所表示的 【非负整数】 ，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。<br>示例1: 输入: [1,2,3]       输出: [1,2,4]        解释: 输入数组表示数字 123。<br>示例2: 输入: [4,3,2,1]    输出: [4,3,2,2]     解释: 输入数组表示数字 4321。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] problem(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == digits.length - <span class="number">1</span> &amp;&amp; (digits[i] + <span class="number">1</span> &lt; <span class="number">10</span>)) &#123; <span class="comment">// 最后一位没有进位</span></span><br><span class="line">            digits[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> digits[i];</span><br><span class="line">            <span class="keyword">if</span> (i == digits.length - <span class="number">1</span>) &#123; <span class="comment">// 最后一位有进位</span></span><br><span class="line">                digits[i] = (digits[i] + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                digits[i] = (pre + temp) % <span class="number">10</span>;</span><br><span class="line">                temp = (pre + temp) / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123;  <span class="comment">// 最后一位数有进位</span></span><br><span class="line">        <span class="type">int</span>[] re = <span class="keyword">new</span> <span class="title class_">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        re[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; digits.length; i++) &#123;</span><br><span class="line">            re[i + <span class="number">1</span>] = digits[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二进制相加"><a href="#二进制相加" class="headerlink" title="二进制相加"></a>二进制相加</h2><p>给你两个二进制字符串，返回它们的和（用二进制表示）。输入为 【非空】 字符串且只包含数字1和0。<br>示例 1: 输入: a = “11”, b = “1”              输出: “100”<br>示例 2: 输入: a = “1010”, b = “1011”   输出: “10101”<br>提示：每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。 <code>1 &lt;= a.length, b.length &lt;= 10^4</code>。字符串如果不是 “0” ，就都不含前导零。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">re</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>, temp = <span class="number">0</span>; <span class="comment">// temp 是进位</span></span><br><span class="line">    <span class="comment">// char型的数字 转 int：  char - &#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        re = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + (b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) % <span class="number">2</span> + re;</span><br><span class="line">        temp = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + (b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) / <span class="number">2</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;  <span class="comment">// a 剩下的</span></span><br><span class="line">        re = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + temp) % <span class="number">2</span> + re;</span><br><span class="line">        temp = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + temp) / <span class="number">2</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123; <span class="comment">// b 剩下的</span></span><br><span class="line">        re = ((b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) % <span class="number">2</span> + re;</span><br><span class="line">        temp = ((b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) / <span class="number">2</span>;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123; <span class="comment">// 最后还有进位</span></span><br><span class="line">        re = temp + re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现int-sqrt-int-x-函数"><a href="#实现int-sqrt-int-x-函数" class="headerlink" title="实现int sqrt(int x)函数"></a>实现int sqrt(int x)函数</h2><p>计算并返回x的平方根，其中x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。<br>示例 1: 输入: 4   输出: 2<br>示例 2: 输入: 8   输出: 2。说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> (<span class="type">int</span>)Math.exp(<span class="number">0.5</span> Math.log(x));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>)(ans + <span class="number">1</span>) (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种 二分查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, e = x;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e) &#123;     <span class="comment">// 二分查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> i + (e - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>)mid mid &lt;= x) &#123; <span class="comment">// 右边  (long long)mid  mid</span></span><br><span class="line">            target = mid;</span><br><span class="line">            i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 左边</span></span><br><span class="line">            e = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三种 牛顿迭代</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">C</span> <span class="operator">=</span> x, x0 = x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="comment">// 牛顿迭代   比二分快</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">xi</span> <span class="operator">=</span> <span class="number">0.5</span> (x0 + C / x0);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(x0 - xi) &lt; <span class="number">1e-7</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x0 = xi;</span><br><span class="line">    &#125;</span><br><span class="line">    target = (<span class="type">int</span>) x0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="爬楼梯算法"><a href="#爬楼梯算法" class="headerlink" title="爬楼梯算法"></a>爬楼梯算法</h2><p>假设你正在爬楼梯。需要n阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。有多少种不同方法可以爬到楼顶？注意：给定 n 是正整数。<br>示例 1：输入： 2  输出： 2。解释： 有两种方法可以爬到楼顶。（1 阶 + 1 阶）、（2 阶）<br>示例 2：输入： 3  输出： 3。解释： 有三种方法可以爬到楼顶。（1 阶 + 1 阶 + 1 阶）、（1 阶 + 2 阶）、（2 阶 + 1 阶）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        target = test_math(n);       // 排列组合</span></span><br><span class="line">    target = test_dynamicProgram(n); <span class="comment">// 滚动数组</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test_math</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 排列组合中的排列  排列： A(n,m)=n×（n-1）...（n-m+1）=n!/（n-m）!(n为下标,m为上标）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> n, count2 = <span class="number">0</span>, target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count1 - <span class="number">2</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count1 - <span class="number">2</span> == <span class="number">0</span>) &#123;<span class="comment">// 全2</span></span><br><span class="line">            target += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count2++; <span class="comment">// 2的个数</span></span><br><span class="line">            count1 = count1 - <span class="number">2</span>;</span><br><span class="line">            target += combination(count1 + count2, count2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target + <span class="number">1</span>; <span class="comment">// 加一个全 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合   C(n,m) = A(n,m) / m!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">combination</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (n - m + <span class="number">1</span>); i &lt;= n; i++) &#123; <span class="comment">// A(n,m)=n*(n-1)...(n-m+1)=n! / (n-m)!</span></span><br><span class="line">        target *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &gt;= <span class="number">1</span>; i--) &#123; <span class="comment">// C(n,m) = A(n,m) / m!</span></span><br><span class="line">        target /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态规划的转移方程：</strong>用 <code>f(x)</code> 表示爬到<code>第 x 级台阶</code>的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，故可列出如下式子：<code>f(x) = f(x−1) + f(x−2)</code>。它意味着爬到第 x级台阶的方案数是爬到<code>第 x−1 级台阶</code>的方案数和爬到<code>第 x−2 级台阶</code>的方案数的和。因为每次只能爬 11 级或 22 级，所以 <code>f(x)</code>只能从 <code>f(x−1) </code>和 <code>f(x−2)</code> 转移过来，要统计方案总数，就需要对这两项的贡献求和。<br><strong>边界条件：</strong>从第 0 级开始爬，从第 0 级爬到第 0 级可以看作只有一种方案，即 <code>f(0)=1</code>；从第 0 级到第 1 级也只有一种方案，即爬一级，<code>f(1)=1</code>。这两个作为边界条件就可以继续向后推导出第 n 级的正确结果。<br>不妨写几项来验证一下，根据转移方程得到 <code>f(2)=2</code>，<code>f(3)=3</code>，<code>f(4)=5</code>……把这些情况都枚举出来，发现计算的结果是正确的。<br>不难通过转移方程和边界条件给出一个时间复杂度和空间复杂度都是 O(n) 的实现，但由于这里的 <code>f(x)</code> 只和 <code>f(x−1)</code> 与 <code>f(x−2)</code> 有关，所以可以用「<strong>滚动数组思想</strong>」把空间复杂度优化成 <code>O(1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test_dynamicProgram</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序链表去重"><a href="#排序链表去重" class="headerlink" title="排序链表去重"></a>排序链表去重</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。<br>示例1: 输入: 1-&gt;1-&gt;2             输出: 1-&gt;2<br>示例2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3  输出: 1-&gt;2-&gt;3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem</span><span class="params">(ListNode1 head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p</span> <span class="operator">=</span> head.next, pre = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val == pre.val) &#123;</span><br><span class="line">            pre.next = p.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两无序数组为一个有序数组"><a href="#合并两无序数组为一个有序数组" class="headerlink" title="合并两无序数组为一个有序数组"></a>合并两无序数组为一个有序数组</h2><p>给你两个有序整数数组nums1 和 nums2，请你将 nums2 合并到nums1中，使 nums1 成为一个有序数组。<br>说明：初始化nums1 和 nums2 元素数量分别为m 和 n 。设nums1有足够的空间（空间大小大于或等于m + n）保存 nums2 中元素。<br>示例：输入: nums1 = [1,2,3,0,0,0], m = 3；nums2 = [2,5,6], n = 3。输出:[1,2,2,3,5,6]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] num1, <span class="type">int</span> m, <span class="type">int</span>[] num2, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m + j &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1[i] &gt; num2[j])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> m + j; k &gt;= i; k--)&#123; <span class="comment">// 第i+1个元素到第m+j个元素依次后移</span></span><br><span class="line">                <span class="keyword">if</span>(k == i)&#123;</span><br><span class="line">                    num1[i] = num2[j]; <span class="comment">// 插入元素</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    num1[k] = num1[k - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n)&#123;  <span class="comment">// num2 还有剩</span></span><br><span class="line">        num1[i++] = num2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断两个二叉树是否相同"><a href="#判断两个二叉树是否相同" class="headerlink" title="判断两个二叉树是否相同"></a>判断两个二叉树是否相同</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250622221035975.png" alt="image-20250622221035975"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">problem</span><span class="params">(TreeNode1 p, TreeNode1 q)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode1 p, TreeNode1 q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="comment">// 两棵树同时为 null 则相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) <span class="comment">// 其中一棵树为 null 则不同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p.val != q.val) <span class="comment">// 根节点不同 则不同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); <span class="comment">// 左子树 右子树都相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode easy</summary>
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Linux备份数据到本地</title>
    <link href="https://southernfish.github.io/2025/06/21/linux/linux-database-backup/"/>
    <id>https://southernfish.github.io/2025/06/21/linux/linux-database-backup/</id>
    <published>2025-06-21T11:23:36.000Z</published>
    <updated>2025-06-26T04:00:20.238Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单记录了将Linux中数据库数据备份到本地是实现流程。</p><h2 id="安装下载命令"><a href="#安装下载命令" class="headerlink" title="安装下载命令"></a>安装下载命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装下载命令</span><br><span class="line">sudo yum install lrzsz</span><br><span class="line">sz filename  下载</span><br><span class="line">rz filename  上传</span><br></pre></td></tr></table></figure><h2 id="登录到MySQL"><a href="#登录到MySQL" class="headerlink" title="登录到MySQL"></a>登录到MySQL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h2 id="查看所有用户及权限"><a href="#查看所有用户及权限" class="headerlink" title="查看所有用户及权限"></a>查看所有用户及权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT User, Host FROM mysql.user;</span><br></pre></td></tr></table></figure><h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line">USE your_database_name;</span><br><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><h2 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p mysql &gt; mysql_dump.sql</span><br><span class="line">mysqldump -u username -p mydatabase &gt; mydatabase_dump.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中：</span></span><br><span class="line"><span class="comment"># username 是你的MySQL用户名。</span></span><br><span class="line"><span class="comment"># -p 选项会提示你输入密码。</span></span><br><span class="line"><span class="comment"># mydatabase 是要导出的数据库名称。</span></span><br><span class="line"><span class="comment"># mydatabase_dump.sql 是导出的文件名。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux备份数据到本地</summary>
    
    
    
    <category term="Linux" scheme="https://southernfish.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://southernfish.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker命令</title>
    <link href="https://southernfish.github.io/2025/06/21/docker/docker-commands/"/>
    <id>https://southernfish.github.io/2025/06/21/docker/docker-commands/</id>
    <published>2025-06-21T08:20:36.000Z</published>
    <updated>2025-06-26T04:00:20.234Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一个用于创建、部署和管理容器的开源平台。在使用Docker时，有效地管理和监控容器是非常重要的，其中查看和解析Docker命令(command)是基本且关键的一步。本文将介绍一些关于Docker的命令。</p><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="Docker命令的格式"><a href="#Docker命令的格式" class="headerlink" title="Docker命令的格式"></a>Docker命令的格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker &lt;<span class="built_in">command</span>&gt;[options] [arguments]</span><br></pre></td></tr></table></figure><h2 id="Docker基础命令"><a href="#Docker基础命令" class="headerlink" title="Docker基础命令"></a>Docker基础命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker version           <span class="comment">#显示版本信息</span></span><br><span class="line">docker info              <span class="comment">#显示docker系统信息，包括容器、镜像</span></span><br><span class="line">docker stats             <span class="comment">#cpu/内存使用情况</span></span><br><span class="line">docker  [<span class="built_in">command</span>] --<span class="built_in">help</span>       <span class="comment">#帮助命令</span></span><br></pre></td></tr></table></figure><hr><h1 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h1><h2 id="查看本地镜像-images"><a href="#查看本地镜像-images" class="headerlink" title="查看本地镜像 images"></a>查看本地镜像 images</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">    -a, --all             <span class="comment"># 列出所有的镜像</span></span><br><span class="line">    -q, --quiet           <span class="comment"># 只显示的镜像的id</span></span><br><span class="line"><span class="comment"># 举例说明</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID           CREATED        SIZE</span><br><span class="line">centos              7         8652b9f0cb4c   2 months ago   204MB</span><br><span class="line"><span class="comment"># 解释</span></span><br><span class="line">    REPOSITORY  镜像仓库源</span><br><span class="line">    TAG         标签（版本）</span><br><span class="line">    IMAGE ID    镜像ID</span><br><span class="line">    CREATED     创建时间</span><br><span class="line">    SIZE        大小</span><br></pre></td></tr></table></figure><h2 id="搜索镜像-search"><a href="#搜索镜像-search" class="headerlink" title="搜索镜像 search"></a>搜索镜像 search</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker search [镜像名]</span><br><span class="line">    --filter=STARS=3000                            <span class="comment"># 列出收藏数不小于指定值的镜像</span></span><br><span class="line">docker search centos                            <span class="comment"># 搜索centos镜像</span></span><br><span class="line">docker search --filter=STARS=3000 centos        <span class="comment"># 搜索收藏大于3000的centos镜像</span></span><br></pre></td></tr></table></figure><h2 id="下载镜像-pull"><a href="#下载镜像-pull" class="headerlink" title="下载镜像 pull"></a>下载镜像 pull</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull [镜像名]:[版本号]</span><br><span class="line">      -a, --all-tags                <span class="comment"># 下载所有镜像名的镜像</span></span><br><span class="line">docker pull nginx                    <span class="comment"># 下载nginx镜像，默认最新版</span></span><br><span class="line">docker pull nginx:1.14.0            <span class="comment"># 下载nginx镜像，版本为1.14.0</span></span><br><span class="line">docker pull -a nginx                <span class="comment"># 下载REPOSITORY为nginx的所有镜像</span></span><br></pre></td></tr></table></figure><h2 id="删除镜像-rmi"><a href="#删除镜像-rmi" class="headerlink" title="删除镜像 rmi"></a>删除镜像 rmi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">删除镜像 rmi</span><br><span class="line">docker rmi [镜像名或者镜像<span class="built_in">id</span>]</span><br><span class="line">    -f                                       <span class="comment"># 强制删除</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span>                        <span class="comment"># 删除指定的镜像</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span>    镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span>  <span class="comment"># 删除多个镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)         <span class="comment"># 删除全部的镜像</span></span><br></pre></td></tr></table></figure><h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [镜像名或者镜像<span class="built_in">id</span>]                  <span class="comment"># 将镜像推送至远程仓库</span></span><br></pre></td></tr></table></figure><hr><h1 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h1><h2 id="启动容器-rmi"><a href="#启动容器-rmi" class="headerlink" title="启动容器 rmi"></a>启动容器 rmi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">启动容器 run</span><br><span class="line">docker run [镜像名]</span><br><span class="line">-d                                            <span class="comment"># 后台运行容器，并返回容器ID</span></span><br><span class="line">-i                                            <span class="comment"># 以交互模式运行容器，通常与 -t 同时使用；</span></span><br><span class="line">-P                                            <span class="comment"># 随机端口映射，容器内部端口随机映射到主机的端口</span></span><br><span class="line">-p                                            <span class="comment"># 指定端口映射，格式为：主机(宿主)端口:容器端口</span></span><br><span class="line">    -p ip:主机端口:容器端口</span><br><span class="line">    -p 主机端口:容器端口</span><br><span class="line">    -p 容器端口</span><br><span class="line">-t                                            <span class="comment"># 为容器重新分配一个伪输入终端，通常与 -i 同时使用（-it    交互模式运行）</span></span><br><span class="line">--name=<span class="string">&quot;nginx-lb&quot;</span>                            <span class="comment"># 为容器指定一个名称</span></span><br><span class="line">--dns 8.8.8.8                                <span class="comment"># 指定容器使用的DNS服务器，默认和宿主一致</span></span><br><span class="line">--dns-search example.com                    <span class="comment"># 指定容器DNS搜索域名，默认和宿主一致</span></span><br><span class="line">-h <span class="string">&quot;hostname&quot;</span>                                <span class="comment"># 指定容器的hostname</span></span><br><span class="line">-e username=<span class="string">&quot;ritchie&quot;</span>                        <span class="comment"># 设置环境变量</span></span><br><span class="line">--env-file=[]                                <span class="comment"># 从指定文件读入环境变量；</span></span><br><span class="line">--cpuset=<span class="string">&quot;0-2&quot;</span> or --cpuset=<span class="string">&quot;0,1,2&quot;</span>            <span class="comment"># 绑定容器到指定CPU运行；</span></span><br><span class="line">-m                                             <span class="comment"># 设置容器使用内存最大值；</span></span><br><span class="line">--net=<span class="string">&quot;bridge&quot;</span>                                 <span class="comment"># 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</span></span><br><span class="line">--<span class="built_in">link</span>=[]                                    <span class="comment"># 添加链接到另一个容器</span></span><br><span class="line">--expose=[]                                 <span class="comment"># 开放一个端口或一组端口；</span></span><br><span class="line">--volume , -v                                 <span class="comment"># 绑定一个卷</span></span><br><span class="line">docker run -it centos /bin/bash               <span class="comment"># 启动并进入容器</span></span><br><span class="line">docker run -it -v 主机目录：容器内目录           <span class="comment"># 挂载目录</span></span><br></pre></td></tr></table></figure><h2 id="查看容器信息-ps"><a href="#查看容器信息-ps" class="headerlink" title="查看容器信息 ps"></a>查看容器信息 ps</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps [CONTAINER ID or CONTAINER NAME]</span><br><span class="line">-a                        <span class="comment"># 列出当前正在运行的容器+历史运行过的容器</span></span><br><span class="line">-n=?                    <span class="comment"># 显示最近创建的容器</span></span><br><span class="line">-q                        <span class="comment"># 只显示容器的ID</span></span><br><span class="line">docker ps                <span class="comment"># 显示正在运行的容器</span></span><br><span class="line">docker ps -n=3          <span class="comment"># 显示最近三个创建的容器</span></span><br></pre></td></tr></table></figure><h2 id="退出容器-exit"><a href="#退出容器-exit" class="headerlink" title="退出容器 exit"></a>退出容器 exit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">退出容器 <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span>            <span class="comment"># 直接容器停止并退出</span></span><br><span class="line">Ctrl + P + Q    <span class="comment"># 容器不停止退出</span></span><br></pre></td></tr></table></figure><h2 id="删除容器-rm"><a href="#删除容器-rm" class="headerlink" title="删除容器 rm"></a>删除容器 rm</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> 容器<span class="built_in">id</span>                          <span class="comment"># 删除指定容器，不能删除正在运行的容器   </span></span><br><span class="line">docker <span class="built_in">rm</span> --f 容器<span class="built_in">id</span>                     <span class="comment"># 删除正在运行的容器    </span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)            <span class="comment"># 删除全部的容器</span></span><br><span class="line">docker ps -q -a|xargs docker <span class="built_in">rm</span>         <span class="comment"># 删除全部的容器</span></span><br></pre></td></tr></table></figure><h2 id="启动和停止容器的操作"><a href="#启动和停止容器的操作" class="headerlink" title="启动和停止容器的操作"></a>启动和停止容器的操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动和停止容器的操作</span><br><span class="line">docker start 容器<span class="built_in">id</span>        <span class="comment"># 启动容器</span></span><br><span class="line">docker restart 容器<span class="built_in">id</span>      <span class="comment"># 重启容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>         <span class="comment"># 停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span>         <span class="comment"># 强制停止当前的容器</span></span><br></pre></td></tr></table></figure><h2 id="查看容器日志-logs"><a href="#查看容器日志-logs" class="headerlink" title="查看容器日志 logs"></a>查看容器日志 logs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --<span class="built_in">tail</span> 10 8e633673e3c2     <span class="comment"># 查看容器id为8e633673e3c2的容器，最新10条日志</span></span><br><span class="line">    -f                 <span class="comment"># 跟踪日志输出</span></span><br><span class="line">    --since         <span class="comment"># 显示某个开始时间的所有日志</span></span><br><span class="line">    -t                 <span class="comment"># 显示时间戳</span></span><br><span class="line">    --<span class="built_in">tail</span>             <span class="comment"># 仅列出最新N条容器日志</span></span><br><span class="line">docker logs -tf --<span class="built_in">tail</span> 10 8e633673e3c2</span><br></pre></td></tr></table></figure><h2 id="查看容器中的进程信息-top"><a href="#查看容器中的进程信息-top" class="headerlink" title="查看容器中的进程信息 top"></a>查看容器中的进程信息 top</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [容器<span class="built_in">id</span>]        <span class="comment"># 显示容器的进程信息</span></span><br></pre></td></tr></table></figure><h2 id="查看镜像的元数据-inspect"><a href="#查看镜像的元数据-inspect" class="headerlink" title="查看镜像的元数据 inspect"></a>查看镜像的元数据 inspect</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [容器<span class="built_in">id</span>]</span><br><span class="line">    -f             <span class="comment"># 指定返回值的模板文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器ip</span></span><br><span class="line">[root@layman ~]<span class="comment"># docker inspect -f  &#x27;&#123;&#123;.NetworkSettings.Networks.redis.IPAMConfig.IPv4Address&#125;&#125;&#x27; 0233</span></span><br><span class="line">172.31.38.16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器环境变量</span></span><br><span class="line">[root@layman ~]<span class="comment"># docker inspect -f &#x27;&#123;&#123;.Config.Env&#125;&#125;&#x27; 0233</span></span><br><span class="line">[PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin REDIS_VERSION=5.0.9 REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-5.0.9.tar.gz REDIS_DOWNLOAD_SHA=53d0ae164cd33</span><br><span class="line">536c3d4b720ae9a128ea6166ebf04ff1add3b85f1242090cb85]</span><br></pre></td></tr></table></figure><h2 id="进入容器-exec-attach"><a href="#进入容器-exec-attach" class="headerlink" title="进入容器 exec attach"></a>进入容器 exec attach</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/bash        <span class="comment"># 进入容器后开启一个新的终端，可以在里面操作（常用）</span></span><br><span class="line">docker attach 容器<span class="built_in">id</span>                    <span class="comment"># 进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure><hr><h1 id="其他相关命令"><a href="#其他相关命令" class="headerlink" title="其他相关命令"></a>其他相关命令</h1><h2 id="docker-run-与-docker-start区别"><a href="#docker-run-与-docker-start区别" class="headerlink" title="docker run 与 docker start区别"></a>docker run 与 docker start区别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run 只在第一次运行时使用，将镜像放到容器中，以后再次启动这个容器时，只需要使用命令docker start 即可；</span><br><span class="line">docker run相当于执行两步操作：将镜像放入容器（docker create）,然后将容器启动，变成运行时容器（docker start）；</span><br><span class="line">docker start的作用是，重新启动已存在的镜像。</span><br></pre></td></tr></table></figure><h2 id="Docker-run的基本流程"><a href="#Docker-run的基本流程" class="headerlink" title="Docker run的基本流程"></a>Docker run的基本流程</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621155307829.png" alt="image-20250621155307829"></p><h2 id="挂载卷-v"><a href="#挂载卷-v" class="headerlink" title="挂载卷 -v"></a>挂载卷 -v</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span>                      <span class="comment"># 查看所有的volume的情况</span></span><br><span class="line">-v 容器内路径                           <span class="comment"># 匿名挂载</span></span><br><span class="line">-v 卷名：容器内路径                       <span class="comment"># 具名挂载</span></span><br><span class="line">-v /宿主机路径：容器内路径               <span class="comment"># 指定路径挂载</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx     <span class="comment"># 只读权限</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx     <span class="comment"># 可读可写</span></span><br><span class="line"><span class="comment"># 没有指定目录的情况下都是在“/var/lib/docker/volumes/xxxx/_data&quot;下</span></span><br><span class="line"></span><br><span class="line">构建 build</span><br><span class="line">docker build -f /home/docker-test-volume/dockerfile1 -t layman/dockerfile .</span><br><span class="line">-f     <span class="comment"># 指定要使用的Dockerfile路径</span></span><br><span class="line">-t     <span class="comment"># 镜像的名字及标签</span></span><br><span class="line"></span><br><span class="line">查看docker网络 network</span><br><span class="line"><span class="comment"># 查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span>                            <span class="comment"># 查看所有容器的网络状态</span></span><br><span class="line">docker network inspect [NETWORK ID]        <span class="comment"># 查看一个详细信息</span></span><br><span class="line">docker network <span class="built_in">rm</span> [NETWORK ID]            <span class="comment"># 可以移除一个网络</span></span><br><span class="line"><span class="comment"># 创建网络</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">--driver bridge                自定义网络模式，使用桥接</span><br><span class="line">--subnet 192.168.0.0/16        设置子网地址</span><br><span class="line">--gateway 192.168.0.1        设置出口网关</span><br><span class="line">mynet                        自己定义的一个网络名字</span><br><span class="line"><span class="comment"># 查看网络详细信息</span></span><br><span class="line">docker network inspect mynet</span><br><span class="line"></span><br><span class="line">加入网络 connect</span><br><span class="line">docker network connect mynet tomcat01</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建-build"><a href="#构建-build" class="headerlink" title="构建 build"></a>构建 build</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /home/docker-test-volume/dockerfile1 -t layman/dockerfile .</span><br><span class="line">-f     <span class="comment"># 指定要使用的Dockerfile路径</span></span><br><span class="line">-t     <span class="comment"># 镜像的名字及标签</span></span><br></pre></td></tr></table></figure><h2 id="查看docker网络-network"><a href="#查看docker网络-network" class="headerlink" title="查看docker网络 network"></a>查看docker网络 network</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span>                            <span class="comment"># 查看所有容器的网络状态</span></span><br><span class="line">docker network inspect [NETWORK ID]        <span class="comment"># 查看一个详细信息</span></span><br><span class="line">docker network <span class="built_in">rm</span> [NETWORK ID]            <span class="comment"># 可以移除一个网络</span></span><br><span class="line"><span class="comment"># 创建网络</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">--driver bridge                自定义网络模式，使用桥接</span><br><span class="line">--subnet 192.168.0.0/16        设置子网地址</span><br><span class="line">--gateway 192.168.0.1        设置出口网关</span><br><span class="line">mynet                        自己定义的一个网络名字</span><br><span class="line"><span class="comment"># 查看网络详细信息</span></span><br><span class="line">docker network inspect mynet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入网络 connect</span></span><br><span class="line">docker network connect mynet tomcat01</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Docker</summary>
    
    
    
    <category term="Containerization Platform" scheme="https://southernfish.github.io/categories/Containerization-Platform/"/>
    
    
    <category term="Docker" scheme="https://southernfish.github.io/tags/Docker/"/>
    
  </entry>
  
</feed>
