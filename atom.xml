<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Southern Fish</title>
  
  
  <link href="https://southernfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://southernfish.github.io/"/>
  <updated>2025-09-17T07:51:48.699Z</updated>
  <id>https://southernfish.github.io/</id>
  
  <author>
    <name>Southern Fish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>其他简单算法</title>
    <link href="https://southernfish.github.io/pages/algorithm/simple_algorithm/"/>
    <id>https://southernfish.github.io/pages/algorithm/simple_algorithm/</id>
    <published>2025-08-07T07:30:36.000Z</published>
    <updated>2025-09-17T07:51:48.699Z</updated>
    
    <content type="html"><![CDATA[<p>与树相关的一些问题。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/2402_83476639/article/details/149788621">优先级队列（堆）</a></p><p><a href="https://blog.csdn.net/2302_79577794/article/details/139581587">【算法笔记】二分查找 &amp;&amp; 二分答案</a></p><p><a href="https://blog.csdn.net/cj13106811623/article/details/136358329">数据结构 -栈和队列(Java实现)</a></p><p><a href="https://blog.csdn.net/m0_64450656/article/details/149851595">第3章栈、队列、数组和矩阵</a></p><p><a href="https://blog.csdn.net/2301_76779875/article/details/146417751">双指针（java）</a></p><p><a href="https://blog.csdn.net/mybook201314/article/details/117589533">算法题 - 求数组的子集合</a></p></blockquote><h1 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h1><p>队列是一种先进先出(FIFO)的数据结构，但有些情况下，操作的数据可能带有优先级，一般出队列时，可能需要优先级高的元素先出队列，该场景下，使用队列显然不合适，比如：在手机上玩游戏的时候，如果有来电，那么系统应该优先处理打进来的电话；初中那会班主任排座位时可能会让成绩好的同学先挑座位。</p><p>这种情况下，数据结构应该提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新的对象。这种数据结构就是优先级队列(Priority Queue)。</p><h2 id="PriorityQueue常用接口"><a href="#PriorityQueue常用接口" class="headerlink" title="PriorityQueue常用接口"></a>PriorityQueue常用接口</h2><h3 id="PriorityQueue的特性"><a href="#PriorityQueue的特性" class="headerlink" title="PriorityQueue的特性"></a>PriorityQueue的特性</h3><p>Java集合框架中提供了PriorityQueue和PriorityBlockingQueue两种类型的优先级队列，PriorityQueue是线程不安全的，PriorityBlockingQueue是线程安全的，此处主要介绍PriorityQueue。</p><p>关于PriorityQueue的使用要注意：</p><ol><li><p>使用时必须导入 PriorityQueue 所在的包，即：<code>import java.util.PriorityQueue;</code></p></li><li><p>PriorityQueue 中放置的元素必须要能够比较大小，不能插入无法比较大小的对象，否则会抛出 ClassCastException 异常</p></li><li><p>不能插入 null 对象，否则会抛出 NullPointerException</p></li><li><p>没有容量限制，可以插入任意多个元素，其内部可以自动扩容。优先级队列的<strong>扩容说明</strong>：</p><ol><li>如果容量小于64时，是按照oldCapacity的2倍方式扩容的</li><li>如果容量大于等于64，是按照oldCapacity的1.5倍方式扩容的</li><li>如果容量超过MAX_ARRAY_SIZE，按照MAX_ARRAY_SIZE来进行扩容</li></ol></li><li><p>插入和删除元素的时间复杂度为O（logN）</p></li><li><p>PriorityQueue 底层使用了堆数据结构</p></li><li><p>PriorityQueue 默认情况下是小堆，即每次获取到的元素都是最小的元素</p></li></ol><h3 id="优先级队列的构造"><a href="#优先级队列的构造" class="headerlink" title="优先级队列的构造"></a>优先级队列的构造</h3><table><thead><tr><th>构造器</th><th>功能介绍+H4:021H4:H4:013</th></tr></thead><tbody><tr><td>PriorityQueue()</td><td>创建一个空的优先级队列，默认容量是11</td></tr><tr><td>PriorityOueue(int initialCapacity)</td><td>创建一个初始容量为initialCapacity的优先级队列<br>注意：<code>initialCapacity</code>不能小于1，否则会抛lllegalArgumentException异常</td></tr><tr><td>PriorityQueue(Collection&lt;? extends E&gt; c)</td><td>用一个集合来创建优先级队列</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">TestPriorityQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的优先级队列，底层默认容量是11</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; q1 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 创建一个空的优先级队列，底层的容量为initialCapacity</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; q2 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用ArrayList对象来构造一个优先级队列的对象</span></span><br><span class="line">    <span class="comment">// q3中已经包含了三个元素</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">4</span>);list.add(<span class="number">3</span>);list.add(<span class="number">2</span>);list.add(<span class="number">1</span>);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; q3 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(list);</span><br><span class="line">    System.out.println(q3.size());</span><br><span class="line">    System.out.println(q3.peek());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：默认情况下，PriorityQueue队列是小堆，如果需要大堆需要用户提供比较器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户自己定义的比较器：直接实现Comparator接口，然后重写该接口中的compare方法即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntCmp</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2-o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPriorityQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">IntCmp</span>());</span><br><span class="line">        <span class="comment">// 或者Lambda 写法</span></span><br><span class="line">        <span class="comment">// PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a,b) -&gt; b - a);</span></span><br><span class="line">        p.offer(<span class="number">4</span>); p.offer(<span class="number">3</span>); p.offer(<span class="number">2</span>);  p.offer(<span class="number">1</span>); p.offer(<span class="number">5</span>);</span><br><span class="line">        System.out.println(p.peek());</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="插入-删除-获取优先级最高的元素"><a href="#插入-删除-获取优先级最高的元素" class="headerlink" title="插入/删除/获取优先级最高的元素"></a>插入/删除/获取优先级最高的元素</h3><table><thead><tr><th>函数名</th><th>功能介绍</th></tr></thead><tbody><tr><td>boolean offer(E e)</td><td>插入元素e，插入成功返回true，如果e对象为空，抛出NulIPointerException异常，时间复杂度<br>注意：空间不够时候会进行扩容</td></tr><tr><td>E peek()</td><td>获取优先级最高的元素，如果优先级队列为空，返回null</td></tr><tr><td>E poll())</td><td>移除优先级最高的元素并返回，如果优先级队列为空，返回null</td></tr><tr><td>int size()</td><td>获取有效元素的个数</td></tr><tr><td>void clear()</td><td>清空</td></tr><tr><td>boolean isEmpty()</td><td>检测优先级队列是否为空，空返回true</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">TestPriorityQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 一般在创建优先级队列对象时，如果知道元素个数，建议就直接将底层容量给好</span></span><br><span class="line">    <span class="comment">// 否则在插入时需要不多的扩容</span></span><br><span class="line">    <span class="comment">// 扩容机制：开辟更大的空间，拷贝元素，这样效率会比较低</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(arr.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> e: arr) &#123;</span><br><span class="line">        q.offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(q.size());   <span class="comment">// 打印优先级队列中有效元素个数</span></span><br><span class="line">    System.out.println(q.peek());   <span class="comment">// 获取优先级最高的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从优先级队列中删除两个元素之后，再次获取优先级最高的元素</span></span><br><span class="line">    q.poll();</span><br><span class="line">    q.poll();</span><br><span class="line">    System.out.println(q.size());   <span class="comment">// 打印优先级队列中有效元素个数</span></span><br><span class="line">    System.out.println(q.peek());   <span class="comment">// 获取优先级最高的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将优先级队列中的有效元素删除掉，检测其是否为空</span></span><br><span class="line">    q.clear();</span><br><span class="line">    <span class="keyword">if</span>(q.isEmpty())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;优先级队列已经为空!!!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;优先级队列不为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h2><h3 id="PriorityQueue的实现"><a href="#PriorityQueue的实现" class="headerlink" title="PriorityQueue的实现"></a>PriorityQueue的实现</h3><p>用堆作为底层结构封装优先级队列</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序即利用堆的思想来进行排序，总共分为两个步骤：</p><ol><li><p>建堆：升序，建大堆；降序，建小堆    </p></li><li><p>利用堆删除思想来进行排序</p></li></ol><p>建堆和堆删除中都用到了向下调整，因此掌握了向下调整，就可以完成堆排序。</p><h3 id="Top-k问题"><a href="#Top-k问题" class="headerlink" title="Top-k问题"></a>Top-k问题</h3><p>TOP-K问题：即求数据集合中前K个最大的元素或者最小的元素，一般情况下数据量都比较大。</p><p>比如：专业前10名、世界500强、富豪榜、游戏中前100的活跃玩家等。</p><p>对于Top-K问题，能想到的最简单直接的方式就是排序，但是：如果数据量非常大，排序就不太可取了(可能数据都 不能一下子全部加载到内存中)。最佳的方式就是用堆来解决，基本思路如下：</p><ol><li><p>用数据集合中前K个元素来建堆 前k个最大的元素，则建小堆前k个最小的元素，则建大堆</p></li><li><p>用剩余的N-K个元素依次与堆顶元素来比较，不满足则替换堆顶元素</p></li></ol><p>将剩余N-K个元素依次与堆顶元素比完之后，堆中剩余的K个元素就是所求的前K个最小或者最大的元素。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>例题参见 <a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0">数组中的第K个最大元素</a></p><hr><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找，也称为折半查找（Binary Search），是一种在有序数组中高效查找特定元素的搜索算法，时间复杂度为O(log⁡n)<em>O</em>(log<em>n</em>)，通过不断缩小搜索范围实现快速定位。它的基本思想是将目标值与数组中间的元素进行比较，如果目标值小于中间元素，则在数组的左半部分继续查找，否则在右半部分查找，不断缩小搜索范围，直到找到目标值或确定目标值不存在为止。</p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>二分查找的核心思想是<strong>分治策略</strong>，具体步骤如下</p><ol><li><strong>有序数组前提</strong>：仅适用于已排序的数组，利用顺序性快速排除无效区间。</li><li><strong>中间元素比较</strong>：每次取中间位置元素与目标值比较，若相等则返回位置:</li><li>缩小搜索范围<ol><li>若目标值小于中间元素，则在左半区间继续查找;</li><li>若目标值大于中间元素，则在右半区间继续查找。</li></ol></li><li><strong>终止条件</strong>：当搜索区间缩小至空(即左边界超过右边界)时，判定元素不存在。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;  <span class="comment">// 防止整数溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码关键点：</p><ul><li><strong>循环条件</strong>：<code>left &lt;= right</code>确保单个元素时仍能执行判断。</li><li><strong>中间值计算</strong>：使用<code>mid = left + (right - left) / 2</code>避免整数溢出风险。</li></ul><p><strong>时间复杂度与空间复杂度</strong></p><ul><li><strong>时间复杂度</strong>：O(log⁡n)<em>O</em>(log<em>n</em>)，每次迭代将搜索范围减半。</li><li><strong>空间复杂度</strong>：迭代实现为O(1)<em>O</em>(1)，递归实现因调用栈深度为O(log⁡n)<em>O</em>(log<em>n</em>)。</li></ul><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><p>例题参见 <a href="#%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">寻找两个正序数组的中位数</a></p><hr><h1 id="栈-amp-矩阵-amp-队列"><a href="#栈-amp-矩阵-amp-队列" class="headerlink" title="栈&amp;矩阵&amp;队列"></a>栈&amp;矩阵&amp;队列</h1><h2 id="矩阵（Matrix）"><a href="#矩阵（Matrix）" class="headerlink" title="矩阵（Matrix）"></a>矩阵（Matrix）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>矩阵是一个多维数组，其元素以行和列的形式排列。在计算机内存中，矩阵通常被实现为向量中的向量。一个3x3的矩阵有9个位置，每个位置可以通过一对索引（行号和列号）来访问。例如，一个元素 <code>M </code>可能位于 <code>[0][0] </code>的位置，而另一个元素 <code>O </code>可能位于 <code>[2][2] </code>的位置。矩阵可以是任意维度的，比如四维矩阵、五维矩阵等，但它们通常用于处理复杂的科学计算和图形渲染。</p><p>矩阵是数据科学、图像处理、机器学习、计算机图形学等领域最基础、最常用的数据结构之一。在现实世界中，数据往往以二维或多维数组的形式存在。</p><h3 id="矩阵转置（Transpose）"><a href="#矩阵转置（Transpose）" class="headerlink" title="矩阵转置（Transpose）"></a>矩阵转置（Transpose）</h3><p>矩阵转置（Transpose）是指将矩阵的行与列互换，通常记作 $A^T$。例如，$A$ 为 $m×n$ 矩阵，则 $A^T$ 为 $n×m$ 矩阵，满足 $A^T[i][j] = A[j][i]$。重要性如下：</p><ul><li><strong>数据变换</strong>：在高效存储或算法实现时，经常需要将行主序（row-major）与列主序（column-major）格式互换；</li><li><strong>线性代数</strong>：在求解矩阵方程、特征值分解等算法中，转置操作会频繁出现；</li><li><strong>并行加速</strong>：对大规模矩阵做转置时，合理的分块策略和优化手段能大幅提升缓存命中率和并行效率。</li></ul><h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>栈是一种特殊的列表，其添加和删除元素的操作仅限于一端，即栈顶。栈的基本操作包括入栈（push）和出栈（pop），遵循后进先出（LIFO）或先进后出（FILO）的原则。栈在程序中用于存储函数调用的上下文、保存局部变量、实现递归函数等。</p><p><strong>压栈</strong>：栈的插入操作叫做进栈/压栈/入栈，<strong>入数据在栈顶。</strong></p><p><strong>出栈</strong>：栈的删除操作叫做出栈。<strong>出数据在栈顶。</strong></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>new Stack()</td><td>创建一个新的空白的栈</td></tr><tr><td>push(a)</td><td>将元素a插入栈中，实现压栈</td></tr><tr><td>pop()</td><td>将栈顶元素进行出栈</td></tr><tr><td>peek()</td><td>获取栈顶元素</td></tr><tr><td>int size()</td><td>获取栈中元素的个数</td></tr><tr><td>boolean isEmpty()</td><td>判断栈中元素是否为空</td></tr></tbody></table><h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p><strong>队列：</strong>只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有<strong>先进先出</strong>，</p><p><strong>入队列：</strong>进行插入操作的一端称为<strong>队尾</strong></p><p><strong>出队列：</strong>进行删除操作的一端称为<strong>队头</strong></p><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p>在Java中，<strong>Queue是个接口，底层是通过链表实现的。</strong></p><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>boolean offer(E e)</td><td>入队列</td></tr><tr><td>E poll()</td><td>出队列</td></tr><tr><td>peek()</td><td>获取队头元素</td></tr><tr><td>int size()</td><td>获取队列中有效元素个数</td></tr><tr><td>boolean isEmpty()</td><td>检测队列是否为空</td></tr></tbody></table><p><strong>注意</strong>：Queue是个接口，在实例化时必须实例化<code>LinkedList</code>的对象，因为<code>LinkedList</code>实现了Queue接口。</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>解决假溢出的方法就是后面满了，就再从头开始，也就是头尾相接的循环。<strong>我们把队列的这种头尾相接的顺序存储结构称为循环队列。</strong>当队首指针**<code>Q-&gt;front = maxsize-1</code>**后，再前进一个位置就自动到0，这可以利用除法取余运算（%）来实现。</p><ul><li>初始时：Q-&gt;front = Q-&gt;rear=0</li><li>队首指针进1：Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE</li><li>队尾指针进1：Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE</li><li>队列长度：(Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE</li></ul><p>判断队列为空的条件是：<strong>Q-&gt;front == Q-&gt;rear</strong></p><p>为了区分队列还是队满的情况，有三种处理方式： (<strong>重点是第一种</strong>)</p><ol><li>牺牲一个单元来判断队空还是队满,入队时少用一个单元. 约定以“<strong>队头指针在队尾指针的下一位置作为队满的标志</strong>”<ul><li><strong>队满条件</strong>： (Q-&gt;rear + 1)%Maxsize == Q-&gt;front</li><li><strong>队空条件</strong>： Q-&gt;front == Q-&gt;rear</li><li><strong>队列中元素的个数</strong>： (Q-&gt;rear - Q -&gt;front + Maxsize)% Maxsize</li></ul></li><li>使用计数的方法来判断队列是否已满</li><li>增设一个boolean flag标记,以区分队满还是队空,flag等于false,若因删除导致 <code>Q-&gt;front == Q-&gt;rear</code> ，则为队空；flag 等于 true 时，若因插入导致 <code>Q -&gt;front == Q-&gt;rear</code> ，则为队满 </li></ol><h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><p>例题参见 <a href="#%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2">最大矩形</a>、<a href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2">柱状图中最大的矩形</a></p><hr><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>双指针算法通过维护两个指针（索引或节点引用）在数据结构中协同移动，以优化时间复杂度。其核心在于减少不必要的遍历次数，将原本需要嵌套循环的问题转化为单次遍历，时间复杂度通常从 O(n²) 降低至 O(n) 或 O(n log&gt; n)，适用于数组、链表、字符串等线性结构 。</p><h2 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h2><blockquote><p><strong>双指针协同</strong>：两指针根据规则同步或异步移动，覆盖问题解空间。<br><strong>单调性依赖</strong>：多数问题需数据结构具备有序性或其他规律，例如排序后的数组或特定约束的子串。<br><strong>高效性</strong>：通过剪枝或跳过无效区间，避免重复计算。</p></blockquote><h2 id="分类与应用场景"><a href="#分类与应用场景" class="headerlink" title="分类与应用场景"></a>分类与应用场景</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p><strong>原理</strong>：两个指针以不同速度移动，常用于 链表操作 和 循环检测。<br><strong>应用场景</strong>：</p><ul><li>链表环检测：快指针每次移动两步，慢指针移动一步，若相遇则存在环 。</li><li>链表中点查找：快指针到末尾时，慢指针指向中点 。</li><li>删除重复元素：慢指针标记唯一元素位置，快指针遍历数组（如有序数组去重）</li></ul><h3 id="对撞指针（左右指针）"><a href="#对撞指针（左右指针）" class="headerlink" title="对撞指针（左右指针）"></a>对撞指针（左右指针）</h3><p><strong>原理</strong>：两指针从两端向中间移动，适用于 有序数组查找 或 对称性问题。<br><strong>应用场景</strong>：</p><ul><li>两数之和：在排序数组中找和为目标值的两个数（指针调整方向基于当前和与目标值的比较） 。</li><li>盛水容器：计算最大容积时，移动高度较小的指针以寻求更大可能 。</li><li>反转数组/字符串：交换左右指针元素直至相遇</li></ul><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><strong>原理</strong>：维护动态窗口，通过调整窗口边界寻找最优解，常用于 子串/子数组问题。<br><strong>应用场景</strong>：</p><ul><li>最小覆盖子串：窗口覆盖目标字符集时收缩左边界以优化长度 。</li><li>最长无重复子串：右指针扩展窗口，左指针在重复时跳跃 。</li></ul><h2 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h2><p>例题参见 <a href="#%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0">好子数组的最大分数</a></p><hr><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>例题参见 <a href="#%E8%B6%85%E7%BA%A7%E5%9B%9E%E6%96%87%E6%95%B0">超级回文数</a></p><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><p>例题参见 <a href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5">螺旋矩阵</a></p><h1 id="子集合"><a href="#子集合" class="headerlink" title="子集合"></a>子集合</h1><p>例题参见 <a href="#%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E9%9B%86%E5%90%88">求数组的子集合</a></p><hr><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><p>题目链接：<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">LeetCode_215. 数组中的第K个最大元素</a></p><blockquote><p><strong>问题描述：</strong><br>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。<br>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。<br>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6], k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        minHeap.offer(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; minHeap.peek()) &#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">            minHeap.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h2><p>题目链接：<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">LeetCode_4. 寻找两个正序数组的中位数</a></p><blockquote><p>**问题描述：<br>**给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。<br>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6</code></li></ul><p><strong>思路</strong>：<br>两个有序数组的长度分别为m和n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。</p><p>为简化代码，不分情况讨论，使用一个小技巧：分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。假如 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。</p><p>定义一个函数用于在两个有序数组中找到第K个元素，下面重点来看如何实现<strong>找到第 <code>K</code> 个元素</strong>。</p><ol><li>首先，为了避免产生新的数组从而增加时间复杂度，使用两个变量 i 和 j 分别来标记数组 nums1 和 nums2 的起始位置。</li><li>然后，处理边界问题，比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。还有如果 K=1 ，那么只要比较 nums1 和 nums2 的起始位置 i 和 j 上的数字就可以了。</li><li>难点在于一般的情况怎么处理？因为需要在两个有序数组中找到第K个元素，为了加快搜索的速度，要使用二分法，对 K 二分，意思是要分别在 nums1 和 nums2 中查找第 K/2 个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第 K/2 个数字，所以需要先检查数组中到底存不存在第 K/2 个数字，如果存在就取出来，否则就赋值上一个整型最大值。如果某个数组没有第 K/2 个数字，那么淘汰另一个数字的前K/2个数字。有没有可能两个数组都不存在第 K/2 个数字呢，这道题里是不可能的，因为K是给的m+n的中间值，所以必定至少会有一个数组是存在第K/2个数字的。</li><li>最后就是二分法的核心，比较这两个数组的第 K/2 小的数字 midVal1 和 midVal2 的大小，如果第一个数组的第 K/2 个数字小的话，那么说明要找的数字肯定不在 nums1 中的前 K/2 个数字，所以可以将其淘汰，将 nums1 的起始位置向后移动 K/2 个，并且此时的K也自减去K/2，调用递归。反之，淘汰nums2中的前K/2个数字，并将 nums2 的起始位置向后移动 K/2 个，并且此时的 K 也自减去K/2，调用递归。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, left) + findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, right)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i: nums1的起始位置 j: nums2的起始位置,k 表示 第 k 个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> i, <span class="type">int</span>[] nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( i &gt;= nums1.length) &#123; <span class="comment">// nums1为空数组</span></span><br><span class="line">            <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( j &gt;= nums2.length) &#123; <span class="comment">// nums2为空数组</span></span><br><span class="line">            <span class="keyword">return</span> nums1[i + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(nums1[i], nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal1</span> <span class="operator">=</span> (i + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums1.length) ? nums1[i + k / <span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal2</span> <span class="operator">=</span> (j + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums2.length) ? nums2[j + k / <span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(midVal1 &lt; midVal2) &#123; <span class="comment">// 淘汰 nums1的前 k/2个</span></span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, i + k / <span class="number">2</span>, nums2, j , k - k / <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 淘汰 nums2的前 k/2个</span></span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, i, nums2, j + k / <span class="number">2</span> , k - k / <span class="number">2</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a>最大矩形</h2><p>题目链接：<a href="https://leetcode.cn/problems/maximal-rectangle/">85. 最大矩形</a></p><blockquote><p><strong>问题描述：</strong>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p><strong>示例 1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：6</span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[&quot;0&quot;]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>rows == matrix.length</code></li><li><code>cols == matrix[0].length</code></li><li><code>1 &lt;= row, cols &lt;= 200</code></li><li><code>matrix[i][j]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length, area = <span class="number">0</span>, min;</span><br><span class="line">    <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">1</span> &amp;&amp; matrix[i - <span class="number">1</span>][j - <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = dp[i][j - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">1</span> &amp;&amp; matrix[i - <span class="number">2</span>][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                min = dp[i][j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= dp[i][j][<span class="number">1</span>]; k++) &#123;</span><br><span class="line">                    min = Math.min(min, dp[i - k + <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">                    area = Math.max(area, min * k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2><p>题目链接：<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p><blockquote><p><strong>问题描述：</strong>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例 1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： heights = [2,4]</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;=10^5</code></li><li><code>0 &lt;= heights[i] &lt;= 10^4</code></li></ul><p><strong>思路</strong>：使用单调增栈可以 O(1) 的获取柱体 i 左边第一个比它小的柱体，因为对于栈中的柱体来说，栈中的下一个柱体就是其「左边第一个小于自身的柱体」。遍历每个柱体，若当前的柱体 i 高度大于等于栈顶柱体的高度，就直接将当前柱体入栈，否则若当前柱体 i 高度小于栈顶柱体的高度，说明 i 是栈顶柱体的「右边第一个小于栈顶柱体的柱体」，以栈顶柱体为高的矩形的左右宽度边界就确定了，那么就可以将栈顶柱体出栈来计算以其为高的矩形的面积了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="comment">// 在柱体数组的头和尾加了两个高度为 0 的柱体</span></span><br><span class="line">    <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">    System.arraycopy(heights, <span class="number">0</span>, tmp, <span class="number">1</span>, heights.length); </span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; tmp[i] &lt; tmp[stack.peek()]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> tmp[stack.pop()]; <span class="comment">// 栈顶柱体高度，注意是出栈</span></span><br><span class="line">            area = Math.max(area, (i - stack.peek() - <span class="number">1</span>) * h); <span class="comment">// 栈顶元素计算左右宽度边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="好子数组的最大分数"><a href="#好子数组的最大分数" class="headerlink" title="好子数组的最大分数"></a>好子数组的最大分数</h2><p>题目链接：<a href="https://leetcode.cn/problems/maximum-score-of-a-good-subarray/">LeetCode_1793. 好子数组的最大分数</a></p><blockquote><p><strong>问题描述：</strong><br>给你一个整数数组 <code>nums</code> <strong>（下标从 0 开始）</strong>和一个整数 <code>k</code> 。一个子数组 <code>(i, j)</code> 的 <strong>分数</strong> 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code> 。一个 <strong>好</strong> 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。请你返回 <strong>好</strong> 子数组的最大可能 <strong>分数</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,4,3,7,4,5], k = 3</span><br><span class="line">输出：15</span><br><span class="line">解释：最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,5,4,5,4,1,1,1], k = 0</span><br><span class="line">输出：20</span><br><span class="line">解释：最优子数组的左右端点下标是 (0, 4) ，分数为 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 10^4</code></li><li><code>0 &lt;= k &lt; nums.length</code></li></ul><p><strong>思路</strong>：判断左右指针对应的数组值哪个比较大，移动到大的一端即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumScore</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, ret = nums[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k, j = k, mn = nums[k]; i &gt; <span class="number">0</span> || j &lt; n - <span class="number">1</span>; ) &#123;</span><br><span class="line">        <span class="comment">// mn 表示 Math.min(nums[i], nums[i+1], ..., nums[j]) </span></span><br><span class="line">        <span class="keyword">if</span> (j == n - <span class="number">1</span> || i &gt; <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            mn = Math.min(mn, nums[--i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mn = Math.min(mn, nums[++j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = Math.max(ret, mn * (j - i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="超级回文数"><a href="#超级回文数" class="headerlink" title="超级回文数"></a>超级回文数</h2><p>题目链接：<a href="https://leetcode.cn/problems/super-palindromes/">LeetCode_906. 超级回文数</a></p><blockquote><p><strong>问题描述：</strong><br>如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为 <strong>超级回文数</strong> 。现在，给你两个以字符串形式表示的正整数 left 和 right ，统计并返回区间 <code>[left, right]</code> 中的 <strong>超级回文数</strong> 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：left = &quot;4&quot;, right = &quot;1000&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：4、9、121 和 484 都是超级回文数。</span><br><span class="line">注意 676 不是超级回文数：26 * 26 = 676 ，但是 26 不是回文数。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：left = &quot;1&quot;, right = &quot;2&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= left.length, right.length &lt;= 18</code></li><li><code>left</code> 和 <code>right</code> 仅由数字（0 - 9）组成。</li><li><code>left</code> 和 <code>right</code> 不含前导零。</li><li><code>left</code> 和 <code>right</code> 表示的整数在区间 <code>[1, 10^18 - 1]</code> 内。</li><li><code>left</code> 小于等于 <code>right</code> 。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">superpalindromesInRange</span><span class="params">(String left, String right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;1&quot;</span>+<span class="string">&quot;0&quot;</span>.repeat(</span><br><span class="line">            String.valueOf((<span class="type">int</span>)Math.sqrt(Double.parseDouble(left))).length() - <span class="number">1</span>),<span class="number">3</span>); ; a++)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">check</span> <span class="operator">=</span> Integer.toString(a,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(check).reverse().toString().equals(check)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Integer.parseInt(check) &lt; (<span class="type">int</span>)Math.sqrt(Double.parseDouble(left))) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Integer.parseInt(check) &gt; (<span class="type">int</span>)Math.sqrt(Double.parseDouble(right))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(check.chars().map(b -&gt; ((<span class="type">char</span>)b - <span class="string">&#x27;0&#x27;</span>) * ((<span class="type">char</span>)b - <span class="string">&#x27;0&#x27;</span>)).sum() &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left.length() == <span class="number">1</span> &amp;&amp; Integer.parseInt(left) &lt;= <span class="number">9</span> </span><br><span class="line">            &amp;&amp; (right.length() &gt; <span class="number">1</span> || Integer.parseInt(right) &gt;= <span class="number">9</span>)) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><p>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></p><blockquote><p><strong>问题描述：</strong>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><p><strong>思路</strong>：模拟矩形的顺时针旋转，所以核心依然是依然是坚持循环不变量，按照左闭右开的原则。模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>设置四个边界，注意状态改变后要增加条件限制，比如后面两个for循环，这个解题是比较好记的，注意每次都是左开右闭就可以了，不要随意更改，其实就是二分查找的区间不变量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> matrix.length-<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123; <span class="comment">// 上行从左到右</span></span><br><span class="line">            result.add(matrix[top][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= bottom; i++) &#123; <span class="comment">// 右列从上到下</span></span><br><span class="line">            result.add(matrix[i][right]);</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left &amp;&amp; top &lt;= bottom; i--) &#123; <span class="comment">// 下行从右到左</span></span><br><span class="line">            result.add(matrix[bottom][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        bottom--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt;= top &amp;&amp; left &lt;= right; i--) &#123; <span class="comment">// 左列从下到上</span></span><br><span class="line">            result.add(matrix[i][left]);</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求数组的子集合"><a href="#求数组的子集合" class="headerlink" title="求数组的子集合"></a>求数组的子集合</h2><blockquote><p><strong>题目一</strong>：给出一个数组 list = [1,2,3,4,5,6]，求此数组的所有子集合<br><strong>输出</strong>：[1]，[1,2]，[1,2,3]…</p><p><strong>题目二</strong>：给出一个数组 list = [1,2,3,4,5,6]，求此数组的所有子集合中和为6的子集<br><strong>输出</strong>：[6，[2,4]，[1,5]，[1,2,3]</p><p><strong>解题思路：</strong><br>方式一：递归<br>方式二：全排列方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归方式 求数组的子集合，子数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] list = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">// 测试数组</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 保存结果集</span></span><br><span class="line">    List&lt;Integer&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    subList(list, <span class="number">0</span>, resultList, subList); <span class="comment">// 递归调用</span></span><br><span class="line">    <span class="comment">// 求数组的子集</span></span><br><span class="line">    System.out.println(<span class="string">&quot;数组的所有子集合：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; sub : resultList) &#123;</span><br><span class="line">        System.out.println(Arrays.toString(sub.toArray()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求各个子集中 和 为6的集合</span></span><br><span class="line">    System.out.println(<span class="string">&quot;输出和为：6&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; sub : resultList) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sub.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">6</span>) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(sub.toArray()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">subList</span><span class="params">(<span class="type">int</span>[] list , <span class="type">int</span> index, </span></span><br><span class="line"><span class="params">        List&lt;List&lt;Integer&gt;&gt; resultList, List&lt;Integer&gt; subList)</span> &#123;</span><br><span class="line">    resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(subList));</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.length ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; size; ) &#123;</span><br><span class="line">        subList.add(list[i]);</span><br><span class="line">        subList(list, ++i, resultList, subList);</span><br><span class="line">        subList.remove(subList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求数组的子集合，子数组 方式二：全排列方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] list = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">// 测试数组</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 保存结果集 </span></span><br><span class="line">    <span class="comment">// 全排列 循环</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.length ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(list[i])));  <span class="comment">// 保存单个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">            List&lt;Integer&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            subList.add(list[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j; k &lt; size; k++) &#123;</span><br><span class="line">                subList.add(list[k]);</span><br><span class="line">                resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(subList)); <span class="comment">// 重新保存一个数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;数组的所有子集合：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; sub : resultList) &#123;</span><br><span class="line">        System.out.println(Arrays.toString(sub.toArray()));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;输出和为：6&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; sub : resultList) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sub.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">6</span>) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(sub.toArray()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;与树相关的一些问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/2402_83476639/article/details/149788621&quot;&gt;优先级队列（堆）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="https://southernfish.github.io/pages/algorithm/backtrack-algorithm/"/>
    <id>https://southernfish.github.io/pages/algorithm/backtrack-algorithm/</id>
    <published>2025-08-06T10:30:36.000Z</published>
    <updated>2025-09-17T07:51:48.698Z</updated>
    
    <content type="html"><![CDATA[<p>回溯算法是一种通过系统性试探和回退策略搜索问题解的通用方法，适用于组合优化、约束满足等复杂问题，其核心特征是“能进则进，不进则退”的深度优先搜索机制。</p><blockquote><p>参考文章：</p><p><a href="https://cloud.tencent.com/developer/article/2477018">回溯算法详解</a></p><p><a href="https://c.biancheng.net/view/9lsh1qb.html">什么是回溯算法</a></p><p><a href="https://cloud.tencent.com/developer/article/2410719">图论基础及深度优先遍历（DFS）、广度优先遍历（BFS）</a></p></blockquote><h1 id="回溯算法详解"><a href="#回溯算法详解" class="headerlink" title="回溯算法详解"></a>回溯算法详解</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>回溯算法，又称为“试探法”。是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>基本思想：从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p><p><strong>八皇后问题</strong>就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。<strong>回溯算法说白了就是穷举法</strong>。不过回溯算法使用<strong>剪枝函数</strong>，<strong>剪去一些不可能到达 <code>最终状态（即答案状态）</code>的节点，从而减少状态空间树节点的生成</strong>。</p><p>回溯算法求解问题时，按深度优先搜索策略对解空间树进行搜索，在搜索至解空间树中的任一结点时，先判断该结点是否包含问题的解：</p><ul><li>若包含问题的解，则沿着该分支继续进行深度优先搜索遍历；</li><li>否则，跳过该结点的分支沿着该结点向上一个结点回溯。</li></ul><p>回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而<strong>回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束</strong>。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。</p><h2 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h2><p>深度优先遍历算法采用了回溯思想，从起始节点开始，沿着一条路径尽可能深入地访问节点，直到无法继续前进时为止，然后回溯到上一个未访问的节点，继续深入搜索，直到完成整个搜索过程。</p><p>因为遍历到的节点顺序符合「先进后出」的特点，所以深度优先搜索遍历可以通过「栈/递归」来实现。</p><p><strong>特点</strong>：一路到底，逐层回退。</p><p><strong>用途</strong>：解决找到所有解问题（找到起始–终点的所有路径，此时 DFS 空间占用少）。</p><p>例题参见 <a href="#%E7%AE%97%E6%B3%95%E9%A2%98%E4%BA%8C%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89">算法题二（二叉树）</a></p><h2 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h2><p>广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外扩张。以此类推，直到完成整个搜索过程。</p><p>因为遍历到的节点顺序符合「先进先出」的特点，所以广度优先遍历可以通过「队列」来实现。</p><p><strong>特点</strong>：全面扩散，逐层递进。</p><p><strong>用途</strong>：解决找到最优解的问题（找到的第一个起始–终点路径，即是最短路径）。</p><p>例题参见 <a href="#%E7%AE%97%E6%B3%95%E9%A2%98%E4%B8%89">算法题三</a></p><h2 id="回溯VS递归"><a href="#回溯VS递归" class="headerlink" title="回溯VS递归"></a>回溯VS递归</h2><p>在回溯法中可以看到有递归的身影，但两者有区别。  回溯法从问题本身出发，寻找可能实现的所有情况。和穷举法的思想相近，不同在于穷举法是将所有的情况都列举出来以后再一一筛选，而回溯法在列举过程如果发现当前情况根本不可能存在，就停止后续的所有工作，返回上一步进行新的尝试。</p><p><strong>递归</strong>是从问题的结果出发，例如求 n！，要想知道 n！的结果，就需要知道 n*(n-1)! 的结果，而要想知道 (n-1)! 结果，就需要提前知道 (n-1)*(n-2)!。这样不断地向自己提问，不断地调用自己的思想就是递归。 </p><p> 回溯和递归唯一的联系就是，<strong>回溯法可以用递归思想实现。</strong></p><h2 id="回溯算法的实现过程"><a href="#回溯算法的实现过程" class="headerlink" title="回溯算法的实现过程"></a>回溯算法的实现过程</h2><p>使用回溯法解决问题的过程，实际上是建立一棵“状态树”的过程。例如，在解决列举集合{1,2,3}所有子集的问题中，对于每个元素，都有两种状态，取还是舍，所以构建的状态树为：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807143329560.png" alt="image-20250807143329560"></p><p>回溯算法的求解过程实质上是先序遍历“状态树”的过程。树中每一个叶子结点，都有可能是问题的答案。图中的状态树是满二叉树，得到的叶子结点全部都是问题的解。  </p><p>在某些情况下，回溯算法解决问题的过程中创建的状态树并不都是满二叉树，因为在试探的过程中，有时会发现此种情况下，再往下进行没有意义，所以会放弃这条死路，回溯到上一步。在树中的体现，就是在树的最后一层不是满的，即不是满二叉树，需要自己判断哪些叶子结点代表的是正确的结果。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>用回溯算法解决问题的一般步骤：</p><ol><li>针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。</li><li>确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。</li><li>以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</li></ol><h3 id="问题的解空间"><a href="#问题的解空间" class="headerlink" title="问题的解空间"></a>问题的解空间</h3><p>问题的解空间至少包含一个最优解。例如，对于装载问题，若有 n 个集装箱要装上一艘载重量为 c 的轮船，其中集装箱 i 的重量为 wi，要求在不超过轮船载重量的前提下，将尽可能多的集装箱装上轮船。</p><p>当 n=3 时，解空间是由长度为 3 的向量组成的，每个向量的元素取值为 0 或 1，解空间为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;(0,0,0),(0,0,1),(0,1,0),(1,0,0),(0,1,1),(1,0,1),(1,1,0),(1,1,1)&#125;</span><br></pre></td></tr></table></figure><p>其中，0 表示不装入轮船，1 表示装入轮船。若 c=50，W={18, 25, 25}，则解空间可用一棵二叉树表示，左分支用 1 表示，右分支用 0 表示，如下图所示。其中，解向量 (1,1,1) 表示将重量为 18、25、25 的集装箱都装入轮船，总重量为 68。解向量 (0,1,1) 表示将重量为 25 和 25 的集装箱装入轮船，总重量为 50。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807144158991.png" alt="image-20250807144158991"></p><p>解空间树一般分为两种：<strong>子集树和排列树</strong>。当所给的问题是从 n 个元素的集合 S 中找出满足某种性质的子集时，相应的解空间树称为子集树。当所给问题是确定 n 个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有 n! 个叶子结点。因此，遍历排列树需要 O(n!) 的计算时间。</p><h3 id="算法的基本思想"><a href="#算法的基本思想" class="headerlink" title="算法的基本思想"></a>算法的基本思想</h3><p>在构造好解空间树之后，可以利用回溯算法对解空间树进行搜索，通过搜索求出问题的最优解。从解空间树的根结点出发，对解空间进行深度优先搜索遍历：</p><ul><li>初始时，根结点成为活结点，并成为当前的扩展结点，沿着扩展结点向纵深方向搜索，达到一个新的结点后，新的结点就成为活结点，并成为当前的扩展结点。</li><li>若当前的扩展结点不能继续向前搜索，则当前的扩展结点成为死结点，这时就会回溯到最近的活结点位置。</li><li>重复按以上方式搜索整个解空间树，直到程序结束。</li></ul><p>若已经生成一个结点或多个结点，而它的所有孩子结点还没有全部生成，则该结点称为活结点；扩展结点指的是当前正在生成孩子结点的活结点；死结点指的是不再继续扩展的结点或其孩子结点已经全部生成的结点。</p><h2 id="贪心算法实际应用"><a href="#贪心算法实际应用" class="headerlink" title="贪心算法实际应用"></a>贪心算法实际应用</h2><h3 id="解决装载问题"><a href="#解决装载问题" class="headerlink" title="解决装载问题"></a>解决装载问题</h3><p>已知有 n 个集装箱（重量分别为 w1,w2,…,wn）和 1 艘轮船，轮船的载重量为 c，要求在不超过轮船载重量的前提下，将尽可能多的集装箱装入轮船。其中，第 i 个集装箱的重量为 wi。</p><p>当 c=50、W={18, 25, 25} 时，装载问题的搜索过程可以表示成一棵子集树，如下图所示：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807144722069.png" alt="image-20250807144722069"></p><ol><li><p>初始时，根结点是唯一的活结点，也是当前的扩展结点，此时轮船的剩余容量为 cr=50，还未有集装箱装入轮船。</p></li><li><p>从根结点 A 出发对左分支结点 B 进行扩展，若将第 1 个集装箱装入轮船，则有 cr=50-18=32，此时结点 B 为当前的扩展结点，结点 A 和结点 B 为活结点。</p></li><li><p>从当前的扩展结点 B 继续沿深度方向扩展，若将第 2 个集装箱装入轮船，则有 cr=32-25=7，此时结点 D 为当前的扩展结点，结点 A、结点 B 和结点 D 为活结点。</p></li><li><p>从当前的扩展结点 D 沿着左分支继续扩展，由于 cr&lt;25，因此无法将第 3 个集装箱放入轮船，这是一个不可行的解，回溯到结点 D。</p></li><li><p>结点 D 成为活结点，并成为当前的扩展结点，从结点 D 沿着右分支进行扩展，扩展到结点 I，即不将第 3 个集装箱装入轮船，此时有第 1 个和第 2 个集装箱装入轮船，得到一个可行解，解向量为 {1,1,0}，装入轮船的集装箱总重量为 43。</p></li><li><p>结点 I 不能再扩展，成为死结点，回溯到结点 D，结点 D 已无可扩展结点，成为死结点，回溯到结点 B。</p></li><li><p>结点 B 成为当前的扩展结点，沿着结点 B 向右分支结点扩展，到达结点 E，结点 E 成为活结点，并成为当前的扩展结点，第 2 个集装箱不装入轮船，此时轮船上只有第 1 个集装箱，cr=32。</p></li><li><p>沿着结点 E 往左分支扩展，结点 J 成为活结点，并成为当前的扩展结点，将第 3 个集装箱装入轮船，此时有 cr=32-25=7，第 1 个和第 3 个集装箱装入轮船，解向量为 {1,0,1}，装入轮船的总重量为 43。</p></li><li><p>结点 J 不可扩展，成为死结点，回溯到结点 E，结点 E 成为当前的扩展结点，沿着结点 E 向右分支扩展，到达结点 K，结点 K 为活结点，即第 3 个集装箱不装入轮船，此时 cr=32，只有第 1 个集装箱装入轮船，解向量为 {1,0,0}，装入轮船的总重量为 18。<br>按照以上方式继续在解空间树上搜索，搜索完毕后，即可得到装载问题的最优解，最优解为 {0,1,1}。</p></li></ol><h3 id="解决旅行商问题"><a href="#解决旅行商问题" class="headerlink" title="解决旅行商问题"></a>解决旅行商问题</h3><p>旅行商问题（Traveling Salesman Problem，TSP）又称为旅行推销员问题、货郎担问题，是数学领域的著名问题之一。</p><p>一个旅行商要从 n 个城市的某一城市出发去往其他城市，每个城市经过且只经过一次，最后回到原来出发的城市。求在去往任何一个城市的所有路径中路径长度最短的一条。</p><p>为了方便描述该问题，可采用带权图表示 n 个城市之间的关系，顶点表示城市，顶点之间的权值表示城市之间的距离。例如，n=4 时的旅行商问题可用下图表示。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807144956840.png" alt="image-20250807144956840"></p><p>图中的回路有 (1,2,3,4,1)、(1,2,4,3,1)、(1,3,2,4,1)、(1,4,2,3,1)、(1,3,4,2,1) 等，其中 (1,3,4,2,1) 的路径长度最短，其路径长度为 29。旅行商人所走过的可能路线其实是所有路径的排列组合，这些方案可绘制成一棵排列树，也是该问题的解空间树，如下图所示。该树的深度为 5，两个结点之间的路径表示旅行商经过的城市。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807145028236.png" alt="image-20250807145028236"></p><hr><h1 id="算法题一"><a href="#算法题一" class="headerlink" title="算法题一"></a>算法题一</h1><h2 id="N-皇后"><a href="#N-皇后" class="headerlink" title="N 皇后"></a>N 皇后</h2><p>题目链接：<a href="https://leetcode.cn/problems/n-queens/">LeetCode_51. N 皇后</a></p><blockquote><p><strong>问题描述：</strong><br>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。<br>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例 1</strong><br><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807145358766.png" alt="image-20250807145358766"><br><strong>输入</strong>：n = 4<br><strong>输出</strong>：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br><strong>解释</strong>：如上图所示，4 皇后问题存在两个不同的解法。</p><p><strong>示例 2：</strong><br><strong>输入</strong>：n = 1<br><strong>输出</strong>：[[“Q”]]</p><p><strong>提示：</strong><code>1 &lt;= n &lt;= 9</code></p><p><strong>解释</strong>：n皇后和数独有异曲同工的方法。数独是每个横竖宫只有一个相同数字，皇后是横竖斜只有一个皇后。所以N*N矩阵皇后每行每列只有一个皇后。<br><strong>判断皇后位置正确</strong>：判断某位置是否可以放下皇后时，由于是从左往右从上往下的遍历顺序，因此只需要检索当前点的上方，左上方，右上方即可。此外，由于回溯内部的for循环是从左往右遍历的，所以可以肯定遍历到当前节点的时候，当前节点的左边肯定没有皇后， 因此可以不对左边节点进行检索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 结果集</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储一个结果子集</span></span><br><span class="line">    <span class="type">char</span> arr[][] = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 初始化全为空</span></span><br><span class="line">            arr[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(<span class="keyword">new</span> <span class="title class_">String</span>(arr[i])); <span class="comment">// 初始化结果子集</span></span><br><span class="line">    &#125;</span><br><span class="line">    dfs(n, path, <span class="number">0</span>); <span class="comment">// 深度优先搜索 </span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先搜索 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, List&lt;String&gt; q, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">    <span class="comment">// 遍历到底部，退出循环</span></span><br><span class="line">    <span class="keyword">if</span> (start == n)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(q));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRight(q, n, start, i)) &#123; <span class="comment">// 判断 [start][i] 位置是否可以放皇后</span></span><br><span class="line">            <span class="type">char</span>[] rows = q.get(start).toCharArray(); <span class="comment">// 第 start+1行</span></span><br><span class="line">            rows[i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            q.set(start, <span class="keyword">new</span> <span class="title class_">String</span>(rows)); <span class="comment">// 放置皇后</span></span><br><span class="line">            </span><br><span class="line">            dfs(n, q, start + <span class="number">1</span>); <span class="comment">// 深度优先搜索 开始横坐标 start+1 </span></span><br><span class="line">            rows = q.get(start).toCharArray();</span><br><span class="line">            rows[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            q.set(start, <span class="keyword">new</span> <span class="title class_">String</span>(rows));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断该位置是否可以放下,检索横竖斜</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRight</span><span class="params">(List&lt;String&gt; q, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="comment">// 检测当前节点上方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.get(i).charAt(y) == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测左上方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x - <span class="number">1</span>, j = y - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.get(i).charAt(j) == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测右上方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x - <span class="number">1</span>, j = y + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.get(i).charAt(j) == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>题目链接：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">LeetCode_17. 电话号码的字母组合</a></p><blockquote><p><strong>问题描述：</strong></p><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。给出数字到字母的映射与电话按键相同。注意 1 不对应任何字母。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; re = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 结果集</span></span><br><span class="line">String corr[] = &#123;<span class="string">&quot;_&quot;</span>,<span class="string">&quot;!@#&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;; <span class="comment">// 0 - 9 对应的字符</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(digits.length() == <span class="number">0</span> || digits.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    re = findCombination(re, corr, digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归 获取字符串组合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findCombination</span><span class="params">(String digits, <span class="type">int</span> index, String s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == digits.length())&#123;</span><br><span class="line">        re.add(s); <span class="comment">// 添加字符串</span></span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> digits.charAt(index); <span class="comment">// 当前字符数字</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> corr[c- <span class="string">&#x27;0&#x27;</span>]; <span class="comment">// 当前数字对应的字母集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; letters.length(); i++)&#123; <span class="comment">// 2-9 每个数字都对应了多个字符</span></span><br><span class="line">        findCombination(digits, index + <span class="number">1</span>,  s + letters.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算法题二（二叉树）"><a href="#算法题二（二叉树）" class="headerlink" title="算法题二（二叉树）"></a>算法题二（二叉树）</h1><h2 id="树节点定义"><a href="#树节点定义" class="headerlink" title="树节点定义"></a>树节点定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; </span><br><span class="line">        <span class="built_in">this</span>.val = val; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">char</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历  父 左 右</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);  <span class="comment">// 访问根节点</span></span><br><span class="line">    preOrder(root.left);               <span class="comment">// 递归左子树</span></span><br><span class="line">    preOrder(root.right);              <span class="comment">// 递归右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历 左 父 右</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历 左 右 父</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 创建一个队列，加入根节点</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 取出队首元素</span></span><br><span class="line">        System.out.print(cur.val + <span class="string">&quot;&quot;</span>);  <span class="comment">// 访问</span></span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left); <span class="comment">// 左节点入队</span></span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right); <span class="comment">// 右节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树还原"><a href="#二叉树还原" class="headerlink" title="二叉树还原"></a>二叉树还原</h2><p>公共代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> in.nextLine().trim();</span><br><span class="line">    String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] charsEnd = arr[<span class="number">0</span>].trim().toCharArray();</span><br><span class="line">    <span class="type">char</span>[] charsMid = arr[<span class="number">1</span>].trim().toCharArray();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> buildTree(charsMid, charsEnd); <span class="comment">// 构建树</span></span><br><span class="line">    List&lt;Character&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 层次遍历结果</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 根出队</span></span><br><span class="line">        res.add(node.val);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">        System.out.print(res.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="已知：后序-中序"><a href="#已知：后序-中序" class="headerlink" title="已知：后序 + 中序"></a>已知：后序 + 中序</h3><blockquote><p><strong>案例</strong>：<br>后序  ： C B E F D A<br>中序  ： C B A E D F</p><ol><li>后序 最后一个元素 A 为根节点</li><li>在中序中左子树在根节点左侧：拿着根节点 A 在中序中找</li><li>对照着后序：CB 为左子树的后序，EFD 为右子树的后序</li><li>还原 A 的左子树<pre><code>后序   CB      确定 B 为左子树的根节点，拿着 B 去中序中找，C 是 B 的左子树，B 的右子树为空中序   CB</code></pre></li><li>还原 A 的右子树<pre><code>后序   EFD    D 为右子树的根中序   EDF    D 的左子树是 E 右子树为 F </code></pre></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">char</span>[] charsMid, <span class="type">char</span>[] charsEnd)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (charsMid.length == <span class="number">0</span> ||  charsEnd.length == <span class="number">0</span> || charsEnd.length != charsMid.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character, Integer&gt; mapMid = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charsMid.length; i++) &#123;</span><br><span class="line">        mapMid.put(charsMid[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildTreeHelpPostMid(charsMid, <span class="number">0</span>, charsMid.length - <span class="number">1</span>, charsEnd, <span class="number">0</span>, charsEnd.length - <span class="number">1</span>, mapMid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTreeHelperPostMid</span><span class="params">(<span class="type">char</span>[] charsMid, <span class="type">int</span> minS, <span class="type">int</span> midE,</span></span><br><span class="line"><span class="params">                                     <span class="type">char</span>[] charsEnd, <span class="type">int</span> endS, <span class="type">int</span> endE, Map&lt;Character, Integer&gt; midMap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(endS &gt; endE || minS &gt; midE) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">rootVal</span> <span class="operator">=</span> charsEnd[endE];</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">midRootIndex</span> <span class="operator">=</span> midMap.get(rootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numsLeft</span> <span class="operator">=</span>  midRootIndex - minS; <span class="comment">// 左子树长度</span></span><br><span class="line">    <span class="comment">// 还原左子树</span></span><br><span class="line">    root.left = buildTreeHelperPostMid(charsMid, minS, midE - <span class="number">1</span>,</span><br><span class="line">                              charsEnd, endS, endS + numsLeft - <span class="number">1</span>, midMap);</span><br><span class="line">    <span class="comment">// 还原右子树</span></span><br><span class="line">    root.right = buildTreeHelperPostMid(charsMid, midRootIndex + <span class="number">1</span>, midE,</span><br><span class="line">                               charsEnd, endS + numsLeft, endE - <span class="number">1</span>, midMap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="已知：先序-中序"><a href="#已知：先序-中序" class="headerlink" title="已知：先序 + 中序"></a>已知：先序 + 中序</h3><blockquote><p><strong>案例</strong>：<br>先序  ： E F H I G J K<br>中序  ： H F I E J K G</p><ol><li>先序 第一个元素 E 为根节点</li><li>在中序中左子树在根节点左侧：拿着根节点 E 在中序中找</li><li>对照着先序：FHI 为左子树的先序，GJK 为右子树的先序</li><li>还原 E 的左子树<pre><code>先序  FHI      确定 F 为左子树的根节点，拿着 F 去中序中找，H 是 F 的左子树，I 为 F 的右子树中序  HFI</code></pre></li><li>还原 E 的右子树<pre><code>先序   GJK    G 为右子树的根中序   JKG    G 的左子树是 JK 右子树为空</code></pre></li><li>还原G的左子树<pre><code>先序   JK       J 为 G 的左子树的根中序   JK       J 为 G 的左子树的右子树</code></pre></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">char</span>[] charsMid, <span class="type">char</span>[] charsPre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (charsMid.length == <span class="number">0</span> || charsPre.length == <span class="number">0</span> || charsPre.length != charsMid.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character, Integer&gt; mapMid = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charsMid.length; i++) &#123;</span><br><span class="line">        mapMid.put(charsMid[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildTreeHelpPreMid(charsMid, <span class="number">0</span>, charsMid.length - <span class="number">1</span>, charsPre, <span class="number">0</span>, charsPre.length - <span class="number">1</span>, mapMid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTreeHelpPreMid</span><span class="params">(<span class="type">char</span>[] charsMid, <span class="type">int</span> midS, <span class="type">int</span> midE,</span></span><br><span class="line"><span class="params">                                     <span class="type">char</span>[] charsPre, <span class="type">int</span> preS, <span class="type">int</span> preE, Map&lt;Character, Integer&gt; midMap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(preS &gt; preE || midS &gt; midE) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">rootVal</span> <span class="operator">=</span> charsPre[preS];</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">midRootIndex</span> <span class="operator">=</span> midMap.get(rootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numsLeft</span> <span class="operator">=</span>  midRootIndex - midS; <span class="comment">// 左子树长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原左子树</span></span><br><span class="line">    root.left = buildTreeHelpPreMid(charsMid, midS, midE - <span class="number">1</span>,</span><br><span class="line">            charsPre, preS + <span class="number">1</span>, preS + numsLeft, midMap);</span><br><span class="line">    <span class="comment">// 还原右子树</span></span><br><span class="line">    root.right = buildTreeHelpPreMid(charsMid, midRootIndex + <span class="number">1</span>, midE,</span><br><span class="line">            charsPre, preS + numsLeft + <span class="number">1</span>, preE, midMap);</span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><p>题目链接：<a href="https://leetcode.cn/problems/diameter-of-binary-tree/">LeetCode_543. 二叉树的直径</a></p><blockquote><p><strong>问题描述：</strong><br>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 10^4]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 全局变量 最长路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> (root.left == <span class="literal">null</span>) ? <span class="number">0</span>: dfs(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightSize</span> <span class="operator">=</span> (root.right == <span class="literal">null</span>) ? <span class="number">0</span>: dfs(root.right) + <span class="number">1</span>;</span><br><span class="line">    max = Math.max(max, leftSize + rightSize);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftSize, rightSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h2><p>题目链接：<a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">LeetCode_124. 二叉树中的最大路径和</a></p><blockquote><p><strong>问题描述：</strong><br>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong>节点，且不一定经过根节点。 <strong>路径和</strong>是路径中各节点值的总和。给出二叉树的根节点 <code>root</code> ，返回其<strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE; <span class="comment">// 全局变量 最大路径和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先搜索</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Math.max(dfs(root.left), <span class="number">0</span>); <span class="comment">// 左子树最大路径和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Math.max(dfs(root.right), <span class="number">0</span>); <span class="comment">// 右子树最大路径和</span></span><br><span class="line">    res = Math.max(res, l + r + root.val); <span class="comment">// 左右子树最大路径和+根节点值</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(l, r) + root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相邻字符不同的最长路径"><a href="#相邻字符不同的最长路径" class="headerlink" title="相邻字符不同的最长路径"></a>相邻字符不同的最长路径</h2><p>题目链接：<a href="https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/">LeetCode_2246. 相邻字符不同的最长路径</a></p><blockquote><p><strong>问题描述：</strong><br>给你一棵 <strong>树</strong>（即一个连通、无向、无环图），根节点是节点 <code>0</code> ，这棵树由编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点组成。用下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>parent</code> 来表示这棵树，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点，由于节点 <code>0</code> 是根节点，所以 <code>parent[0] == -1</code> 。<br>另给你一个字符串 <code>s</code> ，长度也是 <code>n</code> ，其中 <code>s[i]</code> 表示分配给节点 <code>i</code> 的字符。<br>请你找出路径上任意一对相邻节点都没有分配到相同字符的 <strong>最长路径</strong> ，并返回该路径的长度。<br><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：parent = [-1,0,0,1,1,2], s = &quot;abacbe&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：任意一对相邻节点字符都不同的最长路径是：0 -&gt; 1 -&gt; 3 。该路径的长度是 3 ，所以返回 3 。</span><br><span class="line">可以证明不存在满足上述条件且比 3 更长的路径。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：parent = [-1,0,0,0], s = &quot;aabc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：任意一对相邻节点字符都不同的最长路径是：2 -&gt; 0 -&gt; 3 。该路径的长度为 3 ，所以返回 3 。</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807160857199.png" alt="image-20250807160857199"></p><p><strong>提示：</strong></p><ul><li><code>n == parent.length == s.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li>对所有 <code>i &gt;= 1</code> ，<code>0 &lt;= parent[i] &lt;= n - 1</code> 均成立</li><li><code>parent[0] == -1</code></li><li><code>parent</code> 表示一棵有效的树</li><li><code>s</code> 仅由小写英文字母组成</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPath</span><span class="params">(<span class="type">int</span>[] parent, String s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">        adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 构建类似多叉树：父节点包含多个子节点</span></span><br><span class="line">        adj.get(parent[i]).add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s, <span class="number">0</span>); <span class="comment">// 深度优先</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(String s, <span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj.get(root).isEmpty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> next : adj.get(root)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> dfs(s, next);</span><br><span class="line">        ans = Math.max(ans, now);</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(root) != s.charAt(next)) &#123;</span><br><span class="line">            q.offer(now);</span><br><span class="line">            <span class="comment">// 一个父节点在路径中最多保留两条子路径的和</span></span><br><span class="line">            <span class="keyword">if</span> (q.size() &gt; <span class="number">2</span>) q.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> q.isEmpty() ? <span class="number">0</span> : q.poll(), b = q.isEmpty() ? <span class="number">0</span> : q.poll();</span><br><span class="line">    ans = Math.max(ans, a + b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(a, b) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长同值路径"><a href="#最长同值路径" class="headerlink" title="最长同值路径"></a>最长同值路径</h2><p>题目链接：<a href="https://leetcode.cn/problems/longest-univalue-path/">LeetCode_687. 最长同值路径</a></p><blockquote><p><strong>问题描述：</strong><br>给定一个二叉树的 <code>root</code> ，返回 <em>最长的路径的长度</em> ，这个路径中的 <em>每个节点具有相同值</em> 。 这条路径可以经过也可以不经过根节点。<strong>两个节点之间的路径长度</strong> 由它们之间的边数表示。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,5,1,1,5]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,4,5,4,4,5]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>树的节点数的范围是 <code>[0, 10^4]</code> </li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li>树的深度将不超过 <code>1000</code> </li></ul><p><strong>思路：</strong>对于任意一个节点, 如果最长同值路径包含该节点, 那么只可能是两种情况：</p><pre><code>1. 其左右子树中加上该节点后所构成的同值路径中较长的那个继续向父节点回溯构成最长同值路径2. 左右子树加上该节点都在最长同值路径中, 构成了最终的最长同值路径</code></pre><p>需要注意因为要求同值, 所以在判断左右子树能构成的同值路径时要加入当前节点的值作为判断依据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    getMaxL(root, root.val);</span><br><span class="line">    <span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxL</span><span class="params">(TreeNode r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getMaxL(r.left, r.val);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getMaxL(r.right, r.val);</span><br><span class="line">    maxL = Math.max(maxL, left+right); <span class="comment">// 路径长度为节点数减1所以此处不加1</span></span><br><span class="line">    <span class="keyword">if</span>(r.val == val) &#123; <span class="comment">// 和父节点值相同才返回以当前节点所能构成的最长通知路径长度, 否则返回0</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算法题三"><a href="#算法题三" class="headerlink" title="算法题三"></a>算法题三</h1><h2 id="流浪地球"><a href="#流浪地球" class="headerlink" title="流浪地球"></a>流浪地球</h2><blockquote><p><strong>问题描述：</strong><br>流浪地球计划在赤道上均匀部署了N个转向发动机，按位置顺序编号为0~N。</p><ol><li>初始状态下所有的发动机都是未启动状态;</li><li>发动机启动的方式分为”手动启动”和”关联启动”两种方式;</li><li>如果在时刻1一个发动机被启动，下一个时刻2与之相邻的两个发动机就会被”关联启动”;</li><li>如果准备启动某个发动机时，它已经被启动了，则什么都不用做</li></ol><p>发动机0与发动机N-1是相邻的。地球联合政府准备挑选某些发动机在某些时刻进行“手动启动”。当然最终所有的发动机都会被启动。<br>哪些发动机最晚被启动呢?</p><p><strong>输入描述：</strong>第一行两个数字N和E，中间有空格，N代表部署发动机的总个数，E代表计划手动启动的发动机总个数 1&lt;N&lt;=1000,1&lt;=E&lt;=1000,E&lt;=N。接下来共E行，每行都是两个数字T和P，中间有空格 T 代表发动机的手动启动时刻，P代表此发动机的位置编号。 0&lt;=T&lt;=N.0&lt;=P&lt;N<br><strong>输出描述：</strong>第一行一个数字N，以回车结束 N代表最后被启动的发动机个数；第二行N个数字，中间有空格，以回车结束 每个数字代表发动机的位置编号，从小到大排序</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">8 2</span><br><span class="line">0 2</span><br><span class="line">0 6</span><br><span class="line">输出</span><br><span class="line">2</span><br><span class="line">0 4</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8个发动机;</span><br><span class="line">时刻0启动(2,6);</span><br><span class="line">时刻1启动(1,3.5,7)(其中1,3被2关联启动，5，7被6关联启动);</span><br><span class="line">时刻2启动(0,4)(其中0被1,7关联启动，4被3,5关联启动);</span><br><span class="line">至此所有发动机都被启动，最后被启动的有2个，分别是0和4。</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：模拟。枚举每一秒时间，用一个队列维护当前启动了哪些发动机。之后每一秒先遍历队列中的所有发动机，尝试向左右两侧扩展一次，如果扩展到没有启动的发动机就更新其启动时间，同时把发动机放入队列。之后再遍历所有手动启动的发动机，如果某个发动机没启动并且会在这一秒启动，就把他放入队列同时更新启动时间这样就能更新出所有发动机的最早启动时间，找出最大值并输出所有最晚启动的即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">problem28</span><span class="params">(<span class="type">int</span> n, List&lt;<span class="type">int</span>[]&gt; a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 存每个发动机最早启动时间</span></span><br><span class="line">    Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">// 用一个队列维护当前启动了哪些发动机</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t &lt;= <span class="number">5000</span>; ++t)&#123; <span class="comment">// 枚举每一秒时间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size(); <span class="comment">// 当前队列大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; sz; ++j)&#123; <span class="comment">// 循环队列大小次</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> q.poll(); <span class="comment">// 出队</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (f - <span class="number">1</span> + n) % n; <span class="comment">// 左侧相邻发动机</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (f + <span class="number">1</span>) % n; <span class="comment">// 右侧相邻发动机</span></span><br><span class="line">            <span class="keyword">if</span>(ans[x] == -<span class="number">1</span>)&#123; <span class="comment">// 未启动则启动并放入队列</span></span><br><span class="line">                q.add(x);</span><br><span class="line">                ans[x] = ans[f] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans[y] == -<span class="number">1</span>)&#123; <span class="comment">// 未启动则启动并放入队列</span></span><br><span class="line">                q.add(y);</span><br><span class="line">                ans[y] = ans[f] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.size(); ++i)&#123; <span class="comment">// 遍历所有手动启动的发动机</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> a.get(i)[<span class="number">0</span>]; <span class="comment">// 时间</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">P</span> <span class="operator">=</span> a.get(i)[<span class="number">1</span>]; <span class="comment">// 编号</span></span><br><span class="line">            <span class="keyword">if</span>(T == t &amp;&amp; ans[P] == -<span class="number">1</span>)&#123; <span class="comment">// 如果某个发动机没启动并且会在这一秒启动，就把他放入队列同时更新启动时间</span></span><br><span class="line">                q.add(P);</span><br><span class="line">                ans[P] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        max = Math.max(max, ans[i]); <span class="comment">// 找最晚时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max == ans[i])&#123; <span class="comment">// 找符合最晚时间的个数</span></span><br><span class="line">            c += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(c); <span class="comment">// 输出个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == max) &#123;<span class="comment">// 输出具体序号</span></span><br><span class="line">            <span class="keyword">if</span> (f != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Boss的收入"><a href="#Boss的收入" class="headerlink" title="Boss的收入"></a>Boss的收入</h2><blockquote><p><strong>问题描述：</strong><br>一个XX产品行销总公司，只有一个boss，其有若干一级分销，一级分销又有若干二级分销，每个分销只有唯一的上级分销。规定每个月，下级分销需要将自己的总收入(自己的+下级上交的)每满100元上交15元给自己的上级。现给出一组分销的关系，和每个分销的收入，请找出 boss并计算出这 boss 的收入。<br>比如：收入100元上交15元,收入199元(9元不够100)上交15元，收入200元，上交30元。<br>分销关系和收入:分销id 上级分销的id 收入；分销ID范围0…65535 ；收入范围:0…65535,单位元<br><strong>提示</strong>：输入的数据只存在1个 boss，不存在环路<br><strong>输入描述：</strong>第1行输入关系的总数量N；第2行开始，输入关系信息，格式：分销ID 上级分销ID 收入<br><strong>输出描述：</strong>boss的ID 总收入<br><strong>补充说明：</strong>给定的输入数据都是合法的，不存在重复</p><p><strong>示例 1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">5</span><br><span class="line">1 0 100</span><br><span class="line">2 0 200</span><br><span class="line">3 0 300</span><br><span class="line">4 0 200</span><br><span class="line">5 0 200</span><br><span class="line">输出 0 150</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">3</span><br><span class="line">1 0 223</span><br><span class="line">2 0 323</span><br><span class="line">3 2 1203</span><br><span class="line">输出 0 105</span><br><span class="line">说明：2的最终收入等于323+1203/100*15=323+180；0的最终收入等于(323+180+223)/100*15=105</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：使用一个队列进行广度优先搜索（BFS）。从队列中取出当前分销IDx，获取其上级分销IDy，更新收入并更新上级分销的下级计数器in。如果某个上级分销没有下级分销了，将其加入队列。重复此过程直至队列为空。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关系的总数量N, 关系信息列表（分销ID 上级分销ID 收入）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">problem63</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] arr)</span> &#123;</span><br><span class="line">    <span class="type">long</span>[] fa = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">100010</span>];  <span class="comment">// 记录每个分销的上级分销ID</span></span><br><span class="line">    <span class="type">long</span>[] mon = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">100010</span>];  <span class="comment">// 记录每个分销的收入</span></span><br><span class="line">    Arrays.fill(fa, -<span class="number">1</span>);  <span class="comment">// 初始化fa数组，全部设置为-1，表示未知上级</span></span><br><span class="line">    List&lt;Integer&gt; in = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Collections.nCopies(<span class="number">100010</span>, <span class="number">0</span>));  <span class="comment">// 记录每个分销被定义为上级的次数</span></span><br><span class="line">    Set&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();  <span class="comment">// 用于存储所有出现的分销ID</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[i][<span class="number">0</span>], y = arr[i][<span class="number">1</span>], z = arr[i][<span class="number">2</span>];</span><br><span class="line">        st.add(x);  <span class="comment">// 将分销ID x 加入集合</span></span><br><span class="line">        st.add(y);  <span class="comment">// 将上级分销ID y 加入集合</span></span><br><span class="line">        in.set(y, in.get(y) + <span class="number">1</span>);  <span class="comment">// 记录上级分销ID y 被定义为上级的次数</span></span><br><span class="line">        fa[x] = y;  <span class="comment">// 设置分销 x 的上级分销ID 为 y</span></span><br><span class="line">        mon[x] = z;  <span class="comment">// 设置分销 x 的收入为 z</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个队列用于处理没有下级的分销</span></span><br><span class="line">    Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : st) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in.get(x) == <span class="number">0</span>) &#123;</span><br><span class="line">            que.offer(x);  <span class="comment">// 如果某分销ID没有下级分销，将其加入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 最终输出的 boss 收入</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 最终输出的 boss ID</span></span><br><span class="line">    <span class="comment">// 广度优先</span></span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        x = que.poll();  <span class="comment">// 获取队列中的第一个元素</span></span><br><span class="line">        ans = mon[x];  <span class="comment">// 收入设置为当前的收入（会随程序运行最后是 boss 的收入）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) fa[x];  <span class="comment">// 获取分销 x 的上级分销ID</span></span><br><span class="line">        <span class="keyword">if</span> (y == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 如果上级分销ID是-1，跳过此次循环（可能是根节点）</span></span><br><span class="line">        &#125;</span><br><span class="line">        in.set(y, in.get(y) - <span class="number">1</span>);  <span class="comment">// 上级分销 y 的下级数量减1</span></span><br><span class="line">        <span class="keyword">if</span> (in.get(y) == <span class="number">0</span>) &#123;</span><br><span class="line">            que.offer(y);  <span class="comment">// 如果上级分销 y 没有下级分销了，将其加入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算并累加上级分销 y 的收入：当前收入的15%上交给上级</span></span><br><span class="line">        mon[y] += mon[x] / <span class="number">100</span> * <span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出最终的 boss ID 和 boss 的总收入</span></span><br><span class="line">    System.out.println(x + <span class="string">&quot; &quot;</span> + ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回溯算法是一种通过系统性试探和回退策略搜索问题解的通用方法，适用于组合优化、约束满足等复杂问题，其核心特征是“能进则进，不进则退”的深度优先搜索机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tence</summary>
      
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://southernfish.github.io/pages/algorithm/greedy-algorithm/"/>
    <id>https://southernfish.github.io/pages/algorithm/greedy-algorithm/</id>
    <published>2025-08-04T07:20:36.000Z</published>
    <updated>2025-09-17T07:51:48.699Z</updated>
    
    <content type="html"><![CDATA[<p>贪心算法是一种在每一步选择中都采取当前状态下最优（即最有利）的选择，从而希望导致结果是全局最优的算法策略。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/weixin_67868534/article/details/149097914">贪心算法（Greedy Algorithm）</a></p><p><a href="https://cloud.tencent.com/developer/article/2527732">【算法/训练】：贪心（算法理论学习及实践）</a></p><p><a href="https://blog.csdn.net/WandZ123/article/details/125019048">＜贪心算法＞学习及经典实例分析</a></p></blockquote><h1 id="贪心算法详解"><a href="#贪心算法详解" class="headerlink" title="贪心算法详解"></a>贪心算法详解</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>贪心算法（Greedy Algorithm）是一种<strong>分阶段决策策略</strong>：在对问题求解时，总是做出在当前看来是最好的选择的算法，也就是当前状态的局部最优解，通过迭代累积这些局部最优解，期望得到全局最优解。其核心特征是 “<strong>无后效性</strong>”（当前决策不影响后续状态）和 “<strong>贪心选择性质</strong>”（局部最优可推导全局最优）。贪心算法的核心在于<strong>贪心策略的选择</strong>，即每一步的最优选择是否能推导出全局最优解。</p><p>贪心算法的价值在于其<strong>简洁性与高效性</strong>，但必须警惕其局限性——<strong>局部最优未必全局最优</strong>。掌握其适用条件（贪心选择性质+最优子结构）和证明方法，方能灵活应用于任务调度、图论、组合优化等场景。</p><h2 id="核心性质"><a href="#核心性质" class="headerlink" title="核心性质"></a>核心性质</h2><p><strong>贪心算法采用自顶向下，以迭代的方法做出相继的贪心选择</strong>，每做一次贪心选择就将所求问题简化为一个规模更小的子问题，通过每一步贪心选择，可得到问题的一个最优解，虽然每一步上都要保证能获得局部最优解，但由此产生的全局解有时不一定是最优的，所以贪婪法不要回溯。能够用贪心算法求解的问题一般具有两个重要特性：<strong>贪心选择性质和最优子结构性质</strong></p><ul><li><strong>贪心选择性质</strong>：每一步的最优解不依赖于未来决策或子问题的解。<ul><li><strong>所求问题的整体最优解可以通过一系列局部最优的选择</strong>，即贪心选择来达到。这是贪心算法可行的第一个基本要素。</li><li>对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。</li><li><strong>证明的大致过程如下：</strong><ul><li>首先考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始。</li><li>做了贪心选择后，原问题简化为规模更小的类似子问题。</li><li>然后用数学归纳法证明通过每一步做贪心选择，最终可得到问题的整体最优解。</li><li>其中，证明贪心选择后的问题简化为规模更小的类似子问题的关键在于利用该问题的<strong>最优子结构性质</strong></li></ul></li></ul></li><li><strong>最优子结构</strong>：问题的最优解包含其子问题的最优解，与动态规划共享此性质，但贪心算法<strong>无需回溯或存储子问题解</strong>。</li><li><strong>无后效性</strong>：决策一旦做出，不可更改，后续状态仅由当前状态决定。</li></ul><h2 id="贪心算法与动态规划的差异"><a href="#贪心算法与动态规划的差异" class="headerlink" title="贪心算法与动态规划的差异"></a>贪心算法与动态规划的差异</h2><ul><li>动态规划和贪心算法都是一种递推算法，均有最优子结构性质，通过局部最优解来推导全局最优解。</li><li>两者之间的区别在于：<ul><li>贪心算法中作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一步之前的最优解则不作保留，贪心算法每一步的最优解一定包含上一步的最优解。</li><li>动态规划算法中全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解。    </li></ul></li></ul><h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><p>贪心算法的通用实现步骤：</p><blockquote><ol><li>定义问题目标与约束条件</li><li>设计贪心选择策略（如排序、优先队列）</li><li>迭代选择局部最优解</li><li>验证并合并解到全局解</li><li>终止条件：问题规模归零或约束满足</li></ol></blockquote><p><strong>算法思路</strong>：</p><ol><li>建立数学模型来描述问题；</li><li>把求解的问题分成若干个子问题；</li><li>对每个子问题进行求解，得到子问题的局部最优解；</li><li>把子问题的解（局部最优解）合成原来问题的解；</li></ol><p><strong>算法实现</strong>：</p><ol><li>从问题的某个初始解出发；</li><li>采用循环语句，当可以向求解目标前进一步时，就根据局部最优策略，得到一个部分解，缩小问题的范围或规模；</li><li>将所有部分解综合起来，得到问题的最终解；</li></ol><p><strong>使用情况</strong></p><blockquote><p> <strong>举个例子：</strong>  有 6 张纸币，面额分别为 100，70，50， 20，20，10，现在我们可以拿走 3 张纸币，要求总金额最大，该怎么拿 </p></blockquote><ul><li>一看到这个问题，肯定就会想着拿最大的那三张就行了，其实这个想法是没错的，但可以把这个想法分解一下：</li><li>不考虑拿 3 张，只考虑拿走一张的最大值（局部最优），那这个问题就可以拆解为拿三次的情况，第一次拿 100，第二次拿 70，第三次拿 50，那我们最多可以拿 220</li></ul><h2 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h2><ol><li><p><strong>任务调度与区间问题</strong></p><ul><li><p><strong>活动选择</strong>：最大化不重叠活动数量（按结束时间排序）。</p></li><li><p><strong>会议室安排</strong>：最小化会议室使用数量（转化为区间重叠计数）。</p></li></ul></li><li><h5 id="图论问题"><a href="#图论问题" class="headerlink" title="图论问题"></a><strong>图论问题</strong></h5><ul><li><strong>最小生成树</strong><ul><li><strong>Prim算法</strong>：从单点出发，每次选择与树相连的最小边。</li><li><strong>Kruskal算法</strong>：按边权升序排序，选择不形成环的边。</li></ul></li><li><strong>最短路径</strong><ul><li><strong>Dijkstra算法</strong>：从源点出发，每次选择距离最小的未处理节点。</li></ul></li></ul></li><li><h5 id="组合优化问题"><a href="#组合优化问题" class="headerlink" title="组合优化问题"></a><strong>组合优化问题</strong></h5><ul><li><strong>分数背包</strong>：按单位价值排序，优先装入高价值物品。</li><li><strong>找零问题</strong>：硬币面额满足贪心性质时（如人民币面额），优先使用大面额硬币。</li></ul></li></ol><h2 id="经典例题详解"><a href="#经典例题详解" class="headerlink" title="经典例题详解"></a>经典例题详解</h2><ul><li><p><strong>最小合并代价</strong><br>​<strong>​问题​</strong>​：合并n个部落，每次合并代价为两部落人数之和，求最小总代价。<br>​<strong>​解法​</strong>​：优先队列（最小堆）每次合并最小的两个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">min_cost</span>(<span class="params">nums</span>):</span><br><span class="line">    heapq.heapify(nums)</span><br><span class="line">    cost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(nums) &gt; <span class="number">1</span>:</span><br><span class="line">        a = heapq.heappop(nums)</span><br><span class="line">        b = heapq.heappop(nums)</span><br><span class="line">        cost += a + b</span><br><span class="line">        heapq.heappush(nums, a + b)</span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure></li><li><p><strong>纪念品分组</strong><br><strong>问题</strong>：将物品两两分组，每组和不超过W，求最少组数。<br><strong>解法</strong>：排序后双指针配对（最大与最小配对）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">min_groups</span>(<span class="params">items, W</span>):</span><br><span class="line">    items.sort()</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(items) - <span class="number">1</span></span><br><span class="line">    groups = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> items[left] + items[right] &lt;= W:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">        groups += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> groups</span><br></pre></td></tr></table></figure></li><li><h5 id="变种与挑战问题"><a href="#变种与挑战问题" class="headerlink" title="变种与挑战问题"></a><strong>变种与挑战问题</strong></h5><ol><li><strong>加油站问题</strong><ul><li>环形路线上，每个加油站有油量gas[i]，从第i站到下一站耗油cost[i]，求可行起点。</li><li><strong>贪心策略</strong>：若当前剩余油量&lt;0，则起点设为下一站，重置油量。</li></ul></li><li><strong>数列极差问题</strong><ul><li>操作：每次擦去两数a、b，加入a×b+1，求最终数的极差（max-min）。</li><li><strong>解法</strong>：最小化时合并最大数，最大化时合并最小数。</li></ul></li></ol></li><li><p><strong>实战训练建议</strong></p><ul><li><strong>入门题库</strong>：LeetCode “Assign Cookies”（分配问题）、”Best Time to Buy and Sell Stock II”（股票买卖）。</li><li><strong>进阶挑战</strong>：蓝桥杯 “答疑”（按s+a升序排序减少等待时间）、HackerRank “Greedy Florist”。</li><li><strong>竞赛考点</strong>：贪心常与排序、堆、双指针结合，需重点训练边界条件处理。</li></ul></li></ul><hr><h1 id="贪心策略的代码实现范式"><a href="#贪心策略的代码实现范式" class="headerlink" title="贪心策略的代码实现范式"></a>贪心策略的代码实现范式</h1><h2 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h2><ul><li><strong>优先队列（堆）</strong>：用于快速获取最小值/最大值（如合并果子问题）。</li><li><strong>排序预处理</strong>：为贪心选择创造条件（如区间调度需按结束时间排序）。</li></ul><h2 id="经典问题实现"><a href="#经典问题实现" class="headerlink" title="经典问题实现"></a>经典问题实现</h2><h3 id="区间调度（最大不重叠区间）"><a href="#区间调度（最大不重叠区间）" class="headerlink" title="区间调度（最大不重叠区间）"></a>区间调度（最大不重叠区间）</h3><p><strong>问题描述</strong>：从一组区间中选择最多数量的互不重叠区间。<br><strong>贪心策略</strong>：按结束时间升序排序，优先选择结束早的区间。<br><strong>时间复杂度</strong>：O(n log n)，主要来自排序操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_non_overlapping</span>(<span class="params">intervals</span>):</span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])  <span class="comment"># 按结束时间排序</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    last_end = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> start, end <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">if</span> start &gt;= last_end:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            last_end = end</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="哈夫曼编码（数据压缩）"><a href="#哈夫曼编码（数据压缩）" class="headerlink" title="哈夫曼编码（数据压缩）"></a>哈夫曼编码（数据压缩）</h3><p><strong>问题描述</strong>：构造字符的最优前缀编码树，使带权路径长度最小。<br><strong>贪心策略</strong>：每次合并频率最小的两个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_huffman_tree</span>(<span class="params">data</span>):</span><br><span class="line">    freq = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> data:</span><br><span class="line">        freq[char] = freq.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    heap = [[weight, [char, <span class="string">&quot;&quot;</span>]] <span class="keyword">for</span> char, weight <span class="keyword">in</span> freq.items()]</span><br><span class="line">    heapq.heapify(heap)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(heap) &gt; <span class="number">1</span>:</span><br><span class="line">        lo = heapq.heappop(heap)</span><br><span class="line">        hi = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> lo[<span class="number">1</span>:]:</span><br><span class="line">            pair[<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span> + pair[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> hi[<span class="number">1</span>:]:</span><br><span class="line">            pair[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span> + pair[<span class="number">1</span>]</span><br><span class="line">        heapq.heappush(heap, [lo[<span class="number">0</span>] + hi[<span class="number">0</span>]] + lo[<span class="number">1</span>:] + hi[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="正确性证明与复杂度分析"><a href="#正确性证明与复杂度分析" class="headerlink" title="正确性证明与复杂度分析"></a>正确性证明与复杂度分析</h2><h3 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h3><ul><li><strong>数学归纳法</strong>：证明每一步贪心选择均保持最优子结构。</li><li><strong>反证法</strong>：假设存在更优解，通过替换操作证明贪心解更优（如区间调度问题）。</li><li><strong>构造法</strong>：展示贪心解可逐步扩展为全局最优解（如哈夫曼树构造）。</li></ul><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th align="left">问题类型</th><th align="left">时间复杂度</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">区间调度</td><td align="left">O(n log n)</td><td align="left">O(1)</td></tr><tr><td align="left">哈夫曼编码</td><td align="left">O(n log n)</td><td align="left">O(n)</td></tr><tr><td align="left">最小生成树（Prim）</td><td align="left">O(E log V)</td><td align="left">O(V)</td></tr></tbody></table><h3 id="适用条件判断"><a href="#适用条件判断" class="headerlink" title="适用条件判断"></a>适用条件判断</h3><p>贪心算法<strong>仅适用于满足以下性质的问题</strong>：</p><ul><li><strong>贪心选择性质</strong>：局部最优可推导全局最优。</li><li><strong>最优子结构</strong>：子问题最优解可组合为原问题最优解。</li><li><strong>不适用场景</strong>：当前选择影响未来状态（如0-1背包问题需用动态规划）。</li></ul><hr><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>题目链接：<a href="https://leetcode.cn/problems/candy/">LeetCode_135. 分发糖果</a></p><blockquote><p><strong>问题描述：</strong><br><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。需要按照以下要求，给这些孩子分发糖果：<br>每个孩子至少分配到 <code>1</code> 个糖果；相邻两个孩子中，评分更高的那个会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p><strong>示例 1：</strong><br><strong>输入</strong>：ratings = [1,0,2]<br><strong>输出</strong>：5<br><strong>解释</strong>：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</p><p><strong>示例 2：</strong><br><strong>输入</strong>：ratings = [1,2,2]<br><strong>输出</strong>：4<br><strong>解释</strong>：可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</p><p><strong>提示：</strong><br><code>n == ratings.length</code><br><code>1 &lt;= n &lt;= 2 * 10^4</code><br><code>0 &lt;= ratings[i] &lt;= 2 * 10^4</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] candyVec = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length]; <span class="comment">// 每个小孩分的糖果</span></span><br><span class="line">    Arrays.fill(candyVec, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 从左往右遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ratings.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>])&#123;</span><br><span class="line">            candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右往左遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) &#123;</span><br><span class="line">            candyVec[i] = Math.max(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; candyVec.length; i++) &#123;</span><br><span class="line">        result += candyVec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>题目链接：<a href="https://leetcode.cn/problems/container-with-most-water/">LeetCode_11. 盛最多水的容器</a></p><blockquote><p><strong>问题描述：</strong><br>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。<br>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。<br><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong><br><strong>输入</strong>：[1,8,6,2,5,4,8,3,7]<br><strong>输出</strong>：49<br><strong>解释</strong>：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807133603378.png" alt="image-20250807133603378"></p><p><strong>示例 2：</strong><br><strong>输入</strong>：height = [1,1]<br><strong>输出</strong>：1</p><p><strong>提示：</strong><br><code>n == height.length</code><br><code>2 &lt;= n &lt;= 10^5</code><br><code>0 &lt;= height[i] &lt;= 10^4</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> height.length - <span class="number">1</span>, max = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; r; ) &#123;</span><br><span class="line">       max = Math.max(max, Math.min(height[l], height[r]) * (r - l));</span><br><span class="line">       <span class="keyword">if</span> (height[l] &lt; height[r]) &#123;</span><br><span class="line">            l++;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           r--;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><blockquote><p><strong>问题描述：</strong><br>有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。<br>物品：A    B    C    D    E     F    G<br>重量：35  30  60  50  40  10  25<br>价值：10  40  30  50  35  40  30</p><p><strong>问题分析：</strong></p><ol><li><strong>目标函数</strong>：<code>∑pi</code> 求和，最大，使得装入背包中的所有物品 <code>pi</code> 的价值加起来最大；</li><li><strong>约束条件</strong>：装入的物品总重量不超过背包容量：<code>∑wi &lt;= M( M=150)</code>；</li><li>贪心策略：<ul><li>选择价值最大的物品。</li><li>选择重量最小的物品。</li><li>选择单位重量价值最大的物品。</li></ul></li></ol><p>1、值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。<br>2、贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。<br>3、可惜的是，它需要证明后才能真正运用到题目的算法中。</p></blockquote><p>一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。对于背包问题中的 3 种贪心策略，都是 <strong>无法成立（无法被证明）</strong> 的，解释如下：</p><ol><li><p><strong>选取价值最大者</strong>：W=30</p><table><thead><tr><th>物品</th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>A</td><td>28</td><td>30</td></tr><tr><td>B</td><td>12</td><td>20</td></tr><tr><td>C</td><td>12</td><td>20</td></tr></tbody></table><p>根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B和C一起，则更好。</p></li><li><p><strong>选取重量最小者</strong>：选取重量最小。它的反例与第一种策略的反例差不多。</p></li><li><p>选取单位重量价值最大者：W=30</p><table><thead><tr><th>物品</th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>A</td><td>28</td><td>28</td></tr><tr><td>B</td><td>20</td><td>20</td></tr><tr><td>C</td><td>10</td><td>10</td></tr></tbody></table></li></ol><p>根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。但是<strong>如果在条件中加一句当遇见单位价值相同的时候，优先装重量小的，这样的问题就可以解决。</strong></p><p>以下这个算法里面就是采用的贪心第三方案，一般这个方案是成功率最大的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// n：物品个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// m：背包容量</span></span><br><span class="line">    List&lt;Package&gt; p = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 输入物品的重量和价值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> value / weight * <span class="number">1.0</span>;</span><br><span class="line">        p.add(<span class="keyword">new</span> <span class="title class_">Package</span>(weight, value, average));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序默认升序，需要自定义为降序</span></span><br><span class="line">    Collections.sort(p, (pac1, pac2) -&gt; Double.compare(pac2.avg, pac1.avg));</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt;= p.get(i).weight) &#123;</span><br><span class="line">            m -= p.get(i).weight;</span><br><span class="line">            maxValue = maxValue + p.get(i).value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(maxValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Package</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;         <span class="comment">// 重量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;          <span class="comment">// 价值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> avg;         <span class="comment">// 单位价值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Package</span><span class="params">(<span class="type">int</span> weight, <span class="type">int</span> value, <span class="type">double</span> avg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight=weight;</span><br><span class="line">        <span class="built_in">this</span>.value=value;</span><br><span class="line">        <span class="built_in">this</span>.avg=avg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="购物清单（带条件的背包问题）"><a href="#购物清单（带条件的背包问题）" class="headerlink" title="购物清单（带条件的背包问题）"></a>购物清单（带条件的背包问题）</h2><p>题目链接：<a href="https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4">牛客网_HJ16 购物单</a></p><blockquote><p><strong>问题描述：</strong>王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件。</p><ul><li>主件可以没有附件，至多有 22 个附件。附件不再有从属于自己的附件。</li><li>若要购买某附件，必须先购买该附件所属的主件，且每件物品只能购买一次。</li></ul><p>王强查到了 m 件物品的价格，而他只有 n 元的预算。为了先购买重要的物品，他给每件物品规定了一个重要度，用整数 1∼5 表示。他希望在不超过预算的前提下，使满意度最大。满意度定义为所购每件物品价格与重要度乘积之和。</p><p><strong>输入描述</strong>：第一行输入两个整数 n,m代表预算、查询到的物品总数。<br>此后 m 行，第 i 行输入三个整数 vi, wi, qi 分别代表价格、重要度、主件编号。特别地， qi = 0,代表该物品为主件，否则表示该附件从属于主件 。编号即输入顺序，从1开始。保证全部物品的价格 v 均为 10 的倍数；且每个主件的附件数不超过 2 个。</p><p><strong>输出描述</strong>：在一行上输出一个整数，代表王强可获得的最大满意度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">50 5</span><br><span class="line">20 3 5</span><br><span class="line">20 3 5</span><br><span class="line">10 3 0</span><br><span class="line">10 2 0</span><br><span class="line">10 1 0</span><br><span class="line">输出 130</span><br><span class="line">说明：在这个样例中，第三、四、五件物品为主件，第一、二件物品为第五件物品的附件。这就意味着，如果购买了第一件物品或第二件物品，则必须购买第五件物品；但是特别地，如果同时购买了第一件物品和第二件物品，则只需要购买一次第五件物品。</span><br><span class="line">我们可以证明，购买一、二、五件商品，获得的满意度最大，为 20×3+20×3+10×1=130。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// 预算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// 物品数</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span> || m &lt;= <span class="number">0</span>) System.out.println(<span class="number">0</span>);</span><br><span class="line">    Package[] p = <span class="keyword">new</span> <span class="title class_">Package</span>[m + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[][] appendix =  <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][<span class="number">2</span>]; <span class="comment">// 附件 最多2个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123; <span class="comment">// 输入物品 价格、重要度、主件编号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// weight</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wi</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// value</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">qi</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        p[i] = <span class="keyword">new</span> <span class="title class_">Package</span>(vi, wi, qi);</span><br><span class="line">        <span class="keyword">if</span> (qi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (appendix[qi][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                appendix[qi][<span class="number">0</span>] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                appendix[qi][<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>]; <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">Package</span> <span class="variable">item</span> <span class="operator">=</span> p[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> p[i].vi;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> p[i].wi * vi; <span class="comment">// 只有主件</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> <span class="number">0</span>, dp2 = <span class="number">0</span>, dp3 = <span class="number">0</span>, v1 = <span class="number">0</span>, v2 = <span class="number">0</span>, v3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (appendix[i][<span class="number">0</span>] != <span class="number">0</span>) &#123; <span class="comment">// 附件1</span></span><br><span class="line">            v1 = vi + p[appendix[i][<span class="number">0</span>]].vi;</span><br><span class="line">            dp1 = dp0 + p[appendix[i][<span class="number">0</span>]].wi * p[appendix[i][<span class="number">0</span>]].vi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (appendix[i][<span class="number">1</span>] != <span class="number">0</span>) &#123; <span class="comment">// 附件2</span></span><br><span class="line">            v2 = vi + p[appendix[i][<span class="number">1</span>]].vi;</span><br><span class="line">            dp2 = dp0 + p[appendix[i][<span class="number">1</span>]].wi * p[appendix[i][<span class="number">1</span>]].vi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (appendix[i][<span class="number">0</span>] != <span class="number">0</span> &amp;&amp; appendix[i][<span class="number">1</span>] != <span class="number">0</span>) &#123; <span class="comment">// 附件1, 2</span></span><br><span class="line">            v3 = vi + p[appendix[i][<span class="number">0</span>]].vi + p[appendix[i][<span class="number">1</span>]].vi;</span><br><span class="line">            dp3 = dp0 + p[appendix[i][<span class="number">0</span>]].wi * p[appendix[i][<span class="number">0</span>]].vi + </span><br><span class="line">                p[appendix[i][<span class="number">1</span>]].wi * p[appendix[i][<span class="number">1</span>]].vi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (p[i].qi == <span class="number">0</span>) &#123; <span class="comment">// 主件</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= vi &amp;&amp; vi != <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - vi] + dp0);</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v1 &amp;&amp; v1 != <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - v1] + dp1);</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v2 &amp;&amp; v2 != <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - v2] + dp2);</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v3 &amp;&amp; v3 != <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - v3] + dp3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(dp[m][n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Package</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> vi;         <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> wi;          <span class="comment">// 重要性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> qi;      <span class="comment">// 0 为主件 否则为为从属主件parent - 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Package</span><span class="params">(<span class="type">int</span> vi, <span class="type">int</span> wi, <span class="type">int</span> qi)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vi=vi;</span><br><span class="line">        <span class="built_in">this</span>.wi=wi;</span><br><span class="line">        <span class="built_in">this</span>.qi=qi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="活动时间安排问题"><a href="#活动时间安排问题" class="headerlink" title="活动时间安排问题"></a>活动时间安排问题</h2><p><strong>问题描述</strong>：</p><p>设有 <code>n</code>个活动的集合 <code>E=&#123;1,2,…,n&#125;</code>，其中每个活动都<strong>要求使用同一资源</strong>，如：演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 i 都有一个要求使用该资源的起始时间 <code>si</code> 和一个结束时间 fi ,且 <code>si &lt; fi</code> 。<strong>要求设计程序，使得安排的活动最多</strong>。<br>注：活动结束时间从小到大排序</p><table><thead><tr><th>i</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>S[i]</td><td>1</td><td>3</td><td>0</td><td>5</td><td>3</td><td>5</td><td>6</td><td>8</td><td>8</td><td>2</td><td>12</td></tr><tr><td>f[i]</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td></tr></tbody></table><p><strong>问题分析：</strong></p><p>活动安排问题要求安排一系列争用某一公共资源的活动。贪心算法可提供一个简单、漂亮的方法，使尽可能多的活动能兼容的使用公共资源。设有 <code>n</code> 个活动的集合<code>｛0，1，2，…，n-1｝</code>，其中每个活动都要求使用同一资源，如会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 <code>i</code> 都有一个要求使用该资源的起始时间 <code>starti</code> 和一个结束时间 <code>endi</code> ，且 <code>starti &lt; endi</code>。如选择了活动 <code>i</code>，则它在半开时间区间 [starti, endi) 内占用资源。若区间 <code>[starti,endi)</code> 与区间 <code>[startj,endj)</code> 不相交，称活动 <code>i</code> 与活动 <code>j</code> 是<strong>相容的</strong>。即，当 <code>startj ≥ endi</code> 或 <code>starti ≥ endj</code> 时，活动 i 与活动 j 相容。<strong>活动安排问题就是在所给的活动集合中选出最多的不相容活动</strong>。</p><p><strong>算法设计：</strong></p><p>若被检查的 <code>活动 i</code> 的开始时间 <code>starti</code> 小于最近选择的 <code>活动 j</code> 的结束时间 <code>endj</code>，则不选择 <code>活动 i</code>，否则选择 <code>活动 i</code> 加入集合中。运用该算法解决活动安排问题的效率极高。当输入的活动已按结束时间的非减序排列，算法只需 <code>O(n)</code> 的时间安排 <code>n</code> 个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用 <code>O(nlogn)</code> 的时间重排。</p><p><strong>代码实现一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();     <span class="comment">// n：活动个数</span></span><br><span class="line">    List&lt;Active&gt; act = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 输入开始和结束</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">finish</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        act.add(<span class="keyword">new</span> <span class="title class_">Active</span>(start, finish));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将活动按活动结束时间从小到大排序</span></span><br><span class="line">    Collections.sort(act, (o1, o2) -&gt; o1.finish - o2.finish);</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// t：与各个活动的起始时间相比较</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// total：最后的活动的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//循环访问所有活动</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt;= act.get(i).start) &#123;</span><br><span class="line">            total ++;</span><br><span class="line">            t = act.get(i).finish;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(total);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Active</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> start;     <span class="comment">// 开始时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> finish;    <span class="comment">// 结束时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Active</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> finish)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start=start;</span><br><span class="line">        <span class="built_in">this</span>.finish=finish;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码实现二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">11</span>; <span class="comment">// 活动数</span></span><br><span class="line">    <span class="comment">// 将活动时间进行静态数组直接存储</span></span><br><span class="line">    <span class="type">int</span>[] s = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">12</span>&#125;; <span class="comment">// 下标从1开始,存储活动开始时间</span></span><br><span class="line">    <span class="type">int</span>[] f = &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>&#125;; <span class="comment">//下标从1开始,存储活动结束时间</span></span><br><span class="line">    <span class="type">boolean</span>[] A = <span class="keyword">new</span> <span class="title class_">boolean</span>[N + <span class="number">1</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;各活动的开始时间,结束时间分别为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + i + <span class="string">&quot;]:&quot;</span> + <span class="string">&quot;(&quot;</span> + s[i] + <span class="string">&quot;,&quot;</span> + f[i] + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    GreedySelector(N, s, f, A);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i]) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span> + i + <span class="string">&quot;]:&quot;</span> + <span class="string">&quot;(&quot;</span> + s[i] + <span class="string">&quot;,&quot;</span> + f[i] + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">GreedySelector</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] s, <span class="type">int</span>[] f, <span class="type">boolean</span>[] A)</span> &#123;</span><br><span class="line">    A[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 记录最近一次加入A中的活动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123; <span class="comment">// 依次检查活动i是否与当前已选择的活动相容</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= f[j]) &#123;</span><br><span class="line">            A[i] = <span class="literal">true</span>;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：虽然贪心算法不是一定可以得到最好的解 ，但是对于这种活动时间的问题，他却得到的总是最优解，这点可用数学归纳法证明。在这里，体现出来的贪心策略是：每一个活动时间的挑选总是选择最优的，就是刚好匹配的，这样得出的结果也就是最优的了。</p><h2 id="最小生成树（克鲁斯卡尔算法）"><a href="#最小生成树（克鲁斯卡尔算法）" class="headerlink" title="最小生成树（克鲁斯卡尔算法）"></a>最小生成树（克鲁斯卡尔算法）</h2><p>在连通网中查找最小生成树的常用方法有两个，分别称为普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法。</p><blockquote><p><strong>克鲁斯卡尔算法</strong> 查找最小生成树的方法是：将连通网中所有的边按照权值大小做升序排序，从权值最小的边开始选择，<strong>只要此边不和已选择的边一起构成环路，就可以选择它组成最小生成树</strong>。<strong>对于 <code>N</code> 个顶点的连通网，挑选出 <code>N-1</code> 条符合条件的边，这些边组成的生成树就是最小生成树</strong>。</p></blockquote><p><strong>问题描述：</strong>求一个连通无向图的最小生成树的代价（图边权值为正整数）。</p><p><strong>输入</strong>：第一行是一个整数N（1&lt;=N&lt;=20），表示有多少个图需要计算。以下有N个图，第i图的第一行是一个整数M（1&lt;=M&lt;=50），表示图的顶点数，第i图的第2行至1+M行为一个M*M的二维矩阵，其元素ai,j表示图的i顶点和j顶点的连接情况，如果ai,j=0，表示i顶点和j顶点不相连；如果ai,j&gt;0，表示i顶点和j顶点的连接权值。</p><p><strong>输出：</strong>每个用例，用一行输出对应图的最小生成树的代价。</p><p><strong>样例输入：</strong></p><blockquote><p>1<br>6<br>0 6 1 5 0 0<br>6 0 5 0 3 0<br>1 5 0 5 6 4<br>5 0 5 0 0 2<br>0 3 6 0 0 6<br>0 0 4 2 6 0</p></blockquote><p><strong>样例输出：</strong>15</p><p><strong>问题分析：</strong></p><ol><li>边的选择要求从小到大选择，则开始显然要对边进行升序排序；</li><li>选择的边是否需要，则从判断该边加入后是否构成环；</li></ol><p><strong>算法设计：</strong></p><ol><li><strong>对边进行升序排序</strong>：在此采用链式结构，通过插入排序完成。每一结点存放一条边的左右端点序号、权值及后继结点指针；</li><li><strong>边的加入后，是否会构成环</strong>：最开始假定各顶点分别为一组，其组号为端点序号。选择某边后看其两端点是否在同一组中，即所在组号是否相同，若是，表示构成了环，则舍去。若两个端点所在的组不同，则表示可以加入，则将该边两端的组合并成同一组。</li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// V是顶点数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">E</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// E是边数</span></span><br><span class="line">    Edge[] edge = <span class="keyword">new</span> <span class="title class_">Edge</span>[E]; <span class="comment">// 存储边的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">        edge[i] = <span class="keyword">new</span> <span class="title class_">Edge</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    kruskal(V, edge);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行克鲁斯卡尔算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">(<span class="type">int</span> V, Edge[] edge)</span> &#123;</span><br><span class="line">    Edge result[] = <span class="keyword">new</span> <span class="title class_">Edge</span>[V]; <span class="comment">// 存储结果的数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示result数组中的下标</span></span><br><span class="line">    Arrays.sort(edge);  <span class="comment">// 将边按照权重从小到大排序</span></span><br><span class="line">    Subset subsets[] = <span class="keyword">new</span> <span class="title class_">Subset</span>[V]; <span class="comment">// 创建V个子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; ++i) &#123; <span class="comment">// 初始化每个子集的父节点和秩</span></span><br><span class="line">        subsets[i] = <span class="keyword">new</span> <span class="title class_">Subset</span>(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取E-1条边</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (e &lt; V - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">Edge</span> <span class="variable">next_edge</span> <span class="operator">=</span> edge[i++];</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> findParentNode(subsets, next_edge.src);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> findParentNode(subsets, next_edge.dest);</span><br><span class="line">        <span class="comment">// 如果两个节点不在同一个集合中，合并它们</span></span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            result[e++] = next_edge;</span><br><span class="line">            unionSubsets(subsets, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Following are the edges in the constructed MST&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e; ++i)&#123;</span><br><span class="line">        System.out.println(result[i].src + <span class="string">&quot; - &quot;</span> + result[i].dest + <span class="string">&quot; - &quot;</span> + result[i].weight);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找父节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findParentNode</span><span class="params">(Subset subsets[], <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (subsets[i].parent != i)</span><br><span class="line">        subsets[i].parent = findParentNode(subsets, subsets[i].parent);</span><br><span class="line">    <span class="keyword">return</span> subsets[i].parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个子集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unionSubsets</span><span class="params">(Subset subsets[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xroot</span> <span class="operator">=</span> findParentNode(subsets, x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yroot</span> <span class="operator">=</span> findParentNode(subsets, y);</span><br><span class="line">    <span class="keyword">if</span> (subsets[xroot].rank &lt; subsets[yroot].rank)&#123;</span><br><span class="line">        subsets[xroot].parent = yroot;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subsets[xroot].rank &gt; subsets[yroot].rank) &#123;</span><br><span class="line">        subsets[yroot].parent = xroot;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subsets[yroot].parent = xroot;</span><br><span class="line">        subsets[xroot].rank++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义边的数据结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Edge&gt; &#123;</span><br><span class="line">    <span class="type">int</span> src, dest, weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Edge edge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - edge.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集数据结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Subset</span> &#123;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    <span class="type">int</span> rank;</span><br><span class="line">    Subset(<span class="type">int</span> parent, <span class="type">int</span> rank) &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent=parent;</span><br><span class="line">        <span class="built_in">this</span>.rank=rank;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------------------- 无用 --------------------------</span></span><br><span class="line"><span class="comment">// 定义一个辅助函数，用于查找结点所在的集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[i] == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> findNode(parent, parent[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个辅助函数，用于合并两个集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unionNode</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xset</span> <span class="operator">=</span> findNode(parent, x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yset</span> <span class="operator">=</span> findNode(parent, y);</span><br><span class="line">    parent[xset] = yset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段覆盖（Lines-cover）"><a href="#线段覆盖（Lines-cover）" class="headerlink" title="线段覆盖（Lines cover）"></a>线段覆盖（Lines cover）</h2><p><strong>问题描述：</strong>在一维空间中告诉你N条线段的起始坐标与终止坐标，要求求出这些线段一共覆盖了多大的长度。</p><p><strong>解题思路：</strong>上述的表格中的数据代表10条线段的起始点和终点，对他们的起始点从小到大按顺序排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] start = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;  <span class="comment">// 起始点</span></span><br><span class="line">    <span class="type">int</span>[] end = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>&#125;; <span class="comment">// 终点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total_len</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">//至少的长度为：3-2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start[i] &gt;= end[j]) &#123; <span class="comment">// 不相交</span></span><br><span class="line">            total_len = total_len + end[i] - start[i];</span><br><span class="line">            j = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (end[i] &lt;= end[j]) &#123; <span class="comment">// 重叠</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 相交</span></span><br><span class="line">                total_len = total_len + end[i] - end[j];</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(total_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数字组合问题"><a href="#数字组合问题" class="headerlink" title="数字组合问题"></a>数字组合问题</h2><p><strong>问题描述</strong>：设有N个正整数，现在需要你设计一个程序，使他们连接在一起成为最大的数字。</p><p><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">12 456 342</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：45634212</p><p><strong>程序要求</strong>：输入整数N 接下来一行输入N个数字，最后一行输出最大的那个数字。</p><p><strong>题目解析</strong>：</p><ol><li><p>首先想到如何使两个数连接在一起最大，例如 12 和 456 ，连接在一起有两种情况分别为 12456 和 45612 ，显然后者比前者大。</p></li><li><p>如果是多个正整数连在一起，我们则需要对元素进行比较，很显然这是一个排序的过程，而且 需要相邻的元素两两比较，由此可以想到 <code>冒泡排序</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用冒泡排序来实现升序序列</span></span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// 开始冒泡排序 总共排序轮数为：元素个数 - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 内层对比循环 次数 = 元素个数 - 排序轮数 - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果第一个数字比第二个数字大，实现交换这两个数字</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>若有四个数字：456、12、342、78<br>1、先进行比较 456 和 12，发现 45612 比 12456 更大，此时交换两个数字的位置：12、456、342、78<br>2、再进行比较 456 和 342，发现 456342 比 342456 更大，再次进行位置的交换：12、342、456、78<br>3、在进行比较 456 和 78，发现 78456 比 45678 更大，无需进行交换；<br>4、最后顺序：12 、342 、456 、78</p><p>分析到这其实发现要想连接到一起的数字最大，其实需要排序的是每个数字的第一位，最终每个数字的第一位排序得到： <code>1,3,4,7;</code></p><p><strong>综上所述，解题思路：就是在相邻两个正整数连接起来比较大小的基础上再对所有数字冒泡排序，即可完成题目要求</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        arr[i] = scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; num - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//如果 arr[j] 大于 arr[j+1]，则交换，否则，不交换</span></span><br><span class="line">            <span class="keyword">if</span>(compare(arr[j], arr[j+<span class="number">1</span>])) &#123;</span><br><span class="line">                 <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                 arr[j]   = arr[j+<span class="number">1</span>];</span><br><span class="line">                 arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">               <span class="comment">// Collections.swap(list, i, j); //交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        System.out.print(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义排序  num1：:12，num2：456</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nm1</span> <span class="operator">=</span> num1, nm2 = num2;</span><br><span class="line">    <span class="keyword">while</span> (nm1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count1++;   <span class="comment">//用来得到 num1 的位数：2</span></span><br><span class="line">        nm1 /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (nm2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count2++;   <span class="comment">//用来得到 num2 的位数：3</span></span><br><span class="line">        nm2 /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Math.pow(a, b)：求 a 的 b 次方，这里用作将两个数连接起来进行下一步的比较</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> num1 * Math.pow(<span class="number">10.0</span>, count2) + num2; <span class="comment">// 表示组合数：num1 num2：12  * 1000 + 456 = 12456</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> num2 * Math.pow(<span class="number">10.0</span>, count1) + num1; <span class="comment">// 表示组合数：num2 num1：456 * 100  + 12  = 45612</span></span><br><span class="line">    <span class="keyword">return</span> Double.compare(a, b) == <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// true表示组合数(num1 num2)大于组合数(num2 num1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拼数"><a href="#拼数" class="headerlink" title="拼数"></a>拼数</h2><p>题目链接：<a href="https://ac.nowcoder.com/acm/problem/16783">牛客网_拼数</a></p><blockquote><p><strong>描述</strong>：设有n个正整数（n ≤ 20），将它们联接成一排，组成一个最大的多位整数。例如：n=3时，3个整数13，312，343联接成的最大整数为：34331213。又如：n=4时，4个整数7，13，4，246联接成的最大整数为：7424613<br><strong>输入描述</strong>：第一行，一个正整数n。第二行，n个正整数。<br><strong>输出描述</strong>: 一个正整数，表示最大的整数</p><p><strong>示例1</strong><br><strong>输入：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">13 312 343</span><br></pre></td></tr></table></figure><p><strong>输出：</strong>34331213</p><p><strong>示例2</strong><br><strong>输入：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">921650139 925571586 931563581 923960668 870548039 358493469 371229218 737101511 514654859 185379933 19421244 117259400 301947570 48520742 79303948 222979736 153546206 250582036 106394401 198125223</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">931563581925571586923960668921650139870548039793039487371015115146548594852074237122921835849346930194757025058203622297973619812522319421244185379933153546206117259400106394401</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p>先把<strong>整数化成字符串</strong>，然后再比较<strong>a+b和b+a</strong>，如果<strong>a+b&gt;b+a，就把a排在b的前面，反之则把a排在b的后面，最后输出排序后的字符串，即可得到最大的整数</strong>（如果求最小的整数，则从小到大排序）。</p><p><strong>举例说明：a=‘123’，b=‘71’，a+b=’12371’，b+a=‘71123’，所以a+b&lt;b+a，将b排在前面** 注意：正常的字符串存在比较缺陷，**如：A=’321’，B=’32’，按照标准的字符串比较规则因为A&gt;B，所以A+B &gt; B+A ，而实际上’32132’ &lt; ’32321’。</strong> 具体步骤如下：</p><ol><li>获取n   </li><li>依次获取n个正整数，<strong>将整数转换为字符串</strong>：声明字符串数组a[n]，将获取到的正整数存入数组a中，即可实现正整数到字符串的转换  </li><li><strong>自定义排序函数：</strong>若a+b &gt; b+a，则把a排在前面，否则将b排在前面（对字符串a、b，a+b表示连接两个字符串形成一个新串）</li><li><strong>从大到小输出排序后的字符串</strong>即可得到最大的整数</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">    sc.nextLine();</span><br><span class="line">    String[] strArray = sc.nextLine().split(<span class="string">&quot; &quot;</span>); <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 自定义排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>; m &lt; n-<span class="number">1</span>-k; m++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!sortStr(strArray[m], strArray[m + <span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> strArray[m];</span><br><span class="line">                strArray[m] = strArray[m + <span class="number">1</span>];</span><br><span class="line">                strArray[m + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">        System.out.print(strArray[i]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序函数实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">sortStr</span><span class="params">(String str1,String str2)</span>&#123;</span><br><span class="line">    <span class="type">char</span>[] char1 = (str1 + str2).toCharArray();</span><br><span class="line">    <span class="type">char</span>[] char2 = (str2 + str1).toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; char1.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(char1[i] &gt; char2[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(char1[i] &lt; char2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找零钱问题"><a href="#找零钱问题" class="headerlink" title="找零钱问题"></a>找零钱问题</h2><p>在贪心算法里面最常见的莫过于找零钱的问题了。</p><p><strong>问题描述</strong>：对于人民币的面值有1元 、5元 、10元 、20元 、50元 、100元，下面要求设计一个程序，输入找零的钱，输出找钱方案中最少张数的方案，比如： 123元，最少是 1 张100 的，1 张 20 的，3 张 1 元的，一共5张。</p><p><strong>问题解析</strong>：运用的贪心策略是每次选择最大的钱，如果最后超过了，再选择次大的面值，然后次次大的面值，一直到最后与找的钱相等。</p><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> scanner.nextInt();                  <span class="comment">// money：需要的交换的钱数</span></span><br><span class="line">    <span class="type">int</span>[] moneyClass = &#123;<span class="number">100</span>,<span class="number">50</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;          <span class="comment">// 记录钱的面值</span></span><br><span class="line">    <span class="type">int</span>[] moneyNum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];                    <span class="comment">// 记录各种面值的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">moneyCount</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= moneyClass.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (moneyCount + moneyClass[i] &gt; money) &#123;   <span class="comment">// 如果需要的钱数小于最大的面值</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;                               <span class="comment">// 换用更小的面值，继续去判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        moneyCount += moneyClass[i];</span><br><span class="line">        moneyNum[i] ++;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">while</span> (moneyCount == money) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;一共需要：&quot;</span> + count + <span class="string">&quot;张纸钱。&quot;</span> );</span><br><span class="line">    <span class="comment">// 输出张数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (moneyNum[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: System.out.println(<span class="string">&quot;面值为100的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: System.out.println(<span class="string">&quot;面值为50的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: System.out.println(<span class="string">&quot;面值为20的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: System.out.println(<span class="string">&quot;面值为10的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>: System.out.println(<span class="string">&quot;面值为5的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>: System.out.println(<span class="string">&quot;面值为1的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最好时机-二"><a href="#买卖股票的最好时机-二" class="headerlink" title="买卖股票的最好时机(二)"></a>买卖股票的最好时机(二)</h2><p>题目链接：<a href="https://www.nowcoder.com/practice/fbc5dad3e215457fb82a3ae688eb7281?tpld=230&tpld=39768&ru=/exam/oj">牛客网_买卖股票的最好时机(二)</a></p><blockquote><p><strong>描述</strong>：假设数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益</p><ol><li>可以多次买卖该只股票，但是再次购买前必须卖出之前的股票</li><li>如果不能获取收益，请返回0</li><li>假设买入卖出均无手续费</li></ol><p><strong>输入描述</strong>：<br>第一行输入一个正整数 n ，表示数组 prices 的长度<br>第二行输入 n 个正整数，表示数组中prices的值<br><strong>输出描述</strong>：输出最大收益</p><p><strong>示例1</strong><br><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">&gt;8 9 2 5 4 7 1</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：7<br><strong>说明</strong>：<br>在第1天(股票价格=8)买入，第2天(股票价格=9)卖出，获利9-8=1<br>在第3天(股票价格=2)买入，第4天(股票价格=5)卖出，获利5-2=3<br>在第5天(股票价格=4)买入，第6天(股票价格=7)卖出，获利7-4=3<br>总获利1+3+3=7，返回7  </p><p><strong>示例2</strong><br><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">&gt;5 4 3 2 1</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：0<br><strong>说明</strong>：由于每天股票都在跌，因此不进行任何交易最优。最大收益为0。</p><p><strong>示例3</strong><br><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">&gt;1 2 3 4 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：4<br><strong>说明</strong>：第一天买进，最后一天卖出最优。中间的当天买进当天卖出不影响最终结果。最大收益为4。</p><p><strong>思路</strong>： 只要当天价格比上一天价格大，就累加，然后算出最大利润即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span>[] prices = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        prices[i] = in.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>]) &#123; <span class="comment">// 如果任何一天比前一天价格高，就在前一天买入今天卖</span></span><br><span class="line">            sum += (prices[i]-prices[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &lt; prices[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            total += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组队竞赛"><a href="#组队竞赛" class="headerlink" title="组队竞赛"></a>组队竞赛</h2><p>题目链接：<a href="https://www.nowcoder.com/questionTerminal/6736cc3ffd1444a4a0057dee89be789b">牛客网_组队竞赛</a></p><blockquote><p><strong>描述</strong>：牛牛举办了一次编程比赛，参加比赛的有3*n个选手，每个选手都有一个水平值a_i。现在要将这些选手进行组队，一共组成n个队伍，即每个队伍3人。牛牛发现队伍的水平值等于该队伍队员中第二高水平值。例如:<br>一个队伍三个队员的水平值分别是3，3，3。那么队伍的水平值是3<br>一个队伍三个队员的水平值分别是3，2，3。那么队伍的水平值是3<br>一个队伍三个队员的水平值分别是1，5，2。那么队伍的水平值是2<br>为了让比赛更有看点，牛牛想安排队伍使所有队伍的水平值总和最大。<br>如样例所示：如果牛牛把6个队员划分到两个队伍<br>如果方案为：team1:{1,2,5}, team2:{5,5,8}, 这时候水平值总和为7.<br>而如果方案为：team1:{2,5,8}, team2:{1,5,5}, 这时候水平值总和为10.<br>没有比总和为10更大的方案,所以输出10.<br><strong>输入描述：</strong>输入的第一行为一个正整数n(1 ≤ n ≤ 10^5)。第二行包括3*n个整数a_i(1 ≤ a_i ≤ 10^9),表示每个参赛选手的水平值。<br><strong>输出描述：</strong>输出一个整数表示所有队伍的水平值总和最大值</p><p><strong>示例1</strong><br><strong>输入：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 2 8 5 1 5</span><br></pre></td></tr></table></figure><p><strong>输出：</strong>10</p><p><strong>思路</strong>：先排序，比如排完序 1 2 3 4 5 6 7 8 9 这九个数；组队思路是这样的，第一个最后两个（1 8 9），剩下 2 3 4 5 6 7，第一个最后两个（2 6 7），剩下3 4 5一组。就是第一个和最后两个，再把已经组队的删掉，然后再循环，第一个最后两个。那么中位数可以看到是 8 6 4，找到中位数在整个排序后的素组和下标的规则是 data[data.length-(2*(i+1))]，再加在一起。最重要的是 result一定要是long，int会越界。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();;</span><br><span class="line">    <span class="type">long</span>[] data = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">3</span> * n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length ; i++) &#123;</span><br><span class="line">        data[i] = scanner.nextLong();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(data); <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result += data[data.length - (<span class="number">2</span> * (i + <span class="number">1</span>))];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">    ArrayList&lt;Long&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Long&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>*n; i++) &#123;</span><br><span class="line">        arr.add(scan.nextLong());</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(arr);</span><br><span class="line">    list = arr.subList(n,<span class="number">3</span>*n);</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            sum += list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p>题目链接：<a href="https://leetcode.cn/problems/merge-intervals/description/">LeetCode_56. 合并区间 </a></p><p><strong>贪心策略:</strong></p><ul><li>先按照区间的「左端点」排序:此时我们会发现，能够合并的区间都是连续的，b.然后从左往后，按照求「并集」的方式，合并区间。</li></ul><p><strong>如何求并集:</strong> 由于区间已经按照「左端点」排过序了，因此当两个区间「合并」的时候，合并后的区间：</p><ol><li>左端点就是「前一个区间」的左端点;</li><li>右端点就是两者「右端点的最大值」。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));  <span class="comment">// 升序排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &gt;= intervals[i+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">            intervals[i+<span class="number">1</span>][<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            intervals[i+<span class="number">1</span>][<span class="number">1</span>] = Math.max(intervals[i][<span class="number">1</span>], intervals[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.add(intervals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个对比完记得加入result数组中</span></span><br><span class="line">    result.add(intervals[intervals.length - <span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span>[][] reIntervals = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">        reIntervals[i] = result.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reIntervals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非重叠区间"><a href="#非重叠区间" class="headerlink" title="非重叠区间"></a>非重叠区间</h3><p>题目链接：<a href="https://leetcode.cn/problems/non-overlapping-intervals/description/">LeetCode_435. 无重叠区间</a></p><p><strong>贪心策略:</strong></p><ol><li>按照「左端点」排序;</li><li>当两个区间「重叠」的时候，为了能够「在移除某个区间后，保留更多的区间」，我们应该把「区间范围较大」的区间移除。</li></ol><p>如何移除区间范围较大的区间：由于已经按照「左端点」排序了，因此两个区间重叠的时候，应该移除「右端点较大」的区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">    Arrays.sort(intervals, (a,b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>])); <span class="comment">// 升序排列</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 统计需要移除的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &gt; intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123; <span class="comment">// 代表存在重复</span></span><br><span class="line">            count++;</span><br><span class="line">            intervals[i+<span class="number">1</span>][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>], intervals[i + <span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// 修改下一段区间起点位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重叠区间数量"><a href="#重叠区间数量" class="headerlink" title="重叠区间数量"></a>重叠区间数量</h3><p>题目链接：<a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">LeetCode_452. 用最少数量的箭引爆气球</a></p><p><strong>贪心策略:</strong></p><ul><li>按照左端点排序，我们发现，排序后有这样一个性质:「互相重叠的区间都是连续的」;</li><li>这样，我们在射箭的时候，要发挥每一支箭「最大的作用」，应该把「互相重叠的区间」统一引爆。</li></ul><p><strong>如何求互相重叠区间?</strong></p><p>由于我们是按照「左端点」排序的，因此对于两个区间，我们求的是它们的「交集」:</p><ol><li>左端点为两个区间左端点的「最大值」(但是左端点不会影响我们的合并结果，所以可以忽略)</li><li>右端点为两个区间右端点的「最小值」。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以用 合并区间的代码，只需要改三个字母即可，其中要注意安全比较</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> merge(points); <span class="comment">// 返回列表大小即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123; <span class="comment">// 合并区间代码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>])); <span class="comment">// 安全比较</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>],R = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(merged.size() == <span class="number">0</span> || merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L)&#123;</span><br><span class="line">            merged.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L,R&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 注意就是这里，把max换成min即可</span></span><br><span class="line">            merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.min(merged.get(merged.size() -<span class="number">1</span>)[<span class="number">1</span>],R);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间套娃"><a href="#区间套娃" class="headerlink" title="区间套娃"></a>区间套娃</h3><p>题目链接：<a href="https://leetcode.cn/problems/russian-doll-envelopes/description/">Leetcode_354. 俄罗斯套娃信封问题</a></p><p><strong>思路：重写排序 + 贪心 + 二分</strong></p><p>当我们把整个信封按照「下面的规则」排序之后:</p><ol><li>左端点不同的时候:按照「左端点从小到大」排序;</li><li>左端点相同的时候:按照「右端点从大到小」排序</li></ol><p>此时问题就变成了仅考虑信封的「右端点」，完全变成「最长上升子序列」模型。就可以用「贪心+二分」优化算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先按长排序, 然后按照O(N^2)的最长递增子序列的思想来做</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEnvelopes</span><span class="params">(<span class="type">int</span>[][] envelopes)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> envelopes.length;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    Arrays.sort(envelopes, (a,b) -&gt; (a[<span class="number">0</span>]-b[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(envelopes[i][<span class="number">0</span>] &gt; envelopes[j][<span class="number">0</span>] &amp;&amp; envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>])</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(NlogN)的做法, 按照长度升序, 同长则宽度降序排列, 然后使用O(logN)的最长递增子序列解法(链接在评论中)来做即可. 排序后等于把在二维(长、宽)上的最长递增子序列问题转换成一维(宽)上的最长递增子序列的查找, 因为对于长度来说已经满足递增, 只需要在宽度上也递增即为递增序列, 同长时按宽度降序排列的原因是避免同长时宽度小的也被列入递增序列中, 例如[3,3], [3,4],如果宽度也按升序来排列, [3,3]和[3,4]会形成递增序列, 而实际上不行.</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEnvelopes</span><span class="params">(<span class="type">int</span>[][] envelopes)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[envelopes.length];</span><br><span class="line">    Arrays.sort(envelopes, (a, b) -&gt; (a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] - a[<span class="number">1</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] env : envelopes) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = maxL;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[mid] &lt; env[<span class="number">1</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[lo] = env[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(lo == maxL) maxL++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整数问题"><a href="#整数问题" class="headerlink" title="整数问题"></a>整数问题</h2><h3 id="坏了的计算器"><a href="#坏了的计算器" class="headerlink" title="坏了的计算器"></a>坏了的计算器</h3><p>题目链接：<a href="https://leetcode.cn/problems/broken-calculator/description/">LeetCode_991. 坏了的计算器 </a></p><p><strong>贪心策略：【正难则反】</strong></p><p>当「反着」来思考的时候，我们发现</p><ol><li>当 end&lt;= begin 的时候，只能执行「加法」操作;</li><li>当 end &gt; begin 的时候，对于「奇数」来说，只能执行「加法」操作;对于「偶数」来说，最好的方式就是执行「除法」操作</li></ol><p>这样的话，每次的操作都是「固定唯一」的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">brokenCalc</span><span class="params">(<span class="type">int</span> startValue, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(startValue &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">return</span> startValue - target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + brokenCalc(startValue, target / <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + brokenCalc(startValue, target + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数替换"><a href="#整数替换" class="headerlink" title="整数替换"></a>整数替换</h3><p>题目链接：<a href="https://leetcode.cn/problems/integer-replacement/description/">LeetCode_397. 整数替换</a></p><p><strong>贪心策略:</strong>  我们的任何选择，应该让这个数尽可能快的变成1</p><p>对于偶数：只能执行除 2操作，没有什么分析的;</p><p>对于奇数：    </p><ul><li>当 n == 1 的时候，不用执行任何操作;</li><li>当 n == 3 的时候，变成 1 的最优操作数是 2;</li><li>当 n &gt; 1 &amp;&amp; n%4 == 1 的时候，那么它的二进制表示是……01，最优的方式应该选择 -1，这样就可以把末尾的1干掉，接下来执行除法操作，能够更快的变成</li><li>当 n &gt; 3 &amp;&amp; n%4 == 3 的时候，那么它的二进制表示是……11，此时最优的策略应该是 +1，这样可以把一堆连续的1转换成 0，更快的变成 1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerReplacement</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>)func((<span class="type">long</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">func</span><span class="params">(<span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> + func(n / <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>  &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> + Math.min(func(n + <span class="number">1</span>), func(n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可被三整除的最大和"><a href="#可被三整除的最大和" class="headerlink" title="可被三整除的最大和"></a>可被三整除的最大和</h3><p>题目链接：<a href="https://leetcode.cn/problems/greatest-sum-divisible-by-three/description/">LeetCode_1262. 可被三整除的最大和</a></p><p><strong>思路</strong>：正难则反 + 贪心 + 分类讨论</p><p><strong>正难则反：</strong>可以先把所有的数累加在一起，然后根据累加和的结果，贪心的删除一些数。</p><p><strong>分类讨论：</strong>设累加和为 sum，用 x 标记 %3 == 1 的数，用 y 标记 %3 == 2 的数。那么根据 sum 的余数，可以分为下面三种情况:</p><ol><li><p>sum %3 == 0，此时所有元素的和就是满足要求的，那么我们一个也不用删除;，</p></li><li><p>sum %3 == 1，此时数组中要么存在一个 x，要么存在两个 y。因为我们要的是最大值，所以应该选择 x 中最小的那么数，记为x1，或者是y 中最小以及次小的两个数，记为 y1，y2。    </p><p>那么，我们应该选择两种情况下的最大值：max(sum-x1，sum - y1 -y2）；</p></li><li><p>sum %3 == 2，此时数组中要么存在一个 y，要么存在两个 x。因为我们要的是最大值，所以应该选择 y 中最小的那么数，记为y1，或者是x 中最小以及次小的两个数，记为 x1，x2。    </p><p>那么，我们应该选择两种情况下的最大值：max(sum-y1，sum - x1 -x2）；</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumDivThree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>]; <span class="comment">// dp[i][j]表示前i个数，模3=j时的最大值</span></span><br><span class="line">    dp[<span class="number">0</span>][nums[<span class="number">0</span>] % <span class="number">3</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//先将上一个状态转移过来</span></span><br><span class="line">            dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            <span class="comment">//转移每个模3=j的数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j] + nums[i];</span><br><span class="line">            dp[i][sum % <span class="number">3</span>] = Math.max(dp[i][sum % <span class="number">3</span>],sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h3><p>题目链接：<a href="https://leetcode.cn/problems/monotone-increasing-digits/submissions/650566325/">LeetCode_738. 单调递增的数字</a></p><p><strong>解法(贪心)</strong></p><ol><li>为了方便处理数中的每一位数字，可以先讲整数转换成字符串</li><li>从左往右扫描，找到第一个递减的位置</li><li>从这个位置向前推，推到相同区域的最左端</li><li>该点的值 -1，后面的所有数统一变成 9</li></ol><p><strong>思路</strong>：从右向左扫描数字，若发现当前数字比其左边一位（较高位）小， 则把其左边一位数字减1，并将该位及其右边的所有位改成9</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[i] &lt; chars[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            flag = i;</span><br><span class="line">            chars[i - <span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> flag; i &lt; length; i++) &#123;</span><br><span class="line">        chars[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(chars));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><h3 id="排列数字使相邻数字不等"><a href="#排列数字使相邻数字不等" class="headerlink" title="排列数字使相邻数字不等"></a>排列数字使相邻数字不等</h3><p>题目链接：<a href="https://leetcode.cn/problems/distant-barcodes/description/">LeetCode_1054. 距离相等的条形码 </a></p><p><strong>贪心策略:</strong></p><ol><li>每次处理一批相同的数字，往n个空里面摆放;</li><li>每次摆放的时候，隔一个格子摆放一个数;</li><li>优先处理出现次数最多的那个数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] rearrangeBarcodes(<span class="type">int</span>[] barcodes) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> barcodes.length,temp;</span><br><span class="line">    <span class="comment">// 从左边开始找到相邻条形码相同，将后一个条形码与后面不同的条形码交换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(barcodes[i] == barcodes[i-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(barcodes[j] != barcodes[i])&#123;</span><br><span class="line">                    swap(barcodes,i,j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右边再来一次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(barcodes[i] == barcodes[i + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(barcodes[j] != barcodes[i])&#123;</span><br><span class="line">                    swap(barcodes,i,j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从左边不能保证[2,1,1]、[2,3,1,1,1]，从右边不能保证[1,1,2]等，但左右都来一次就能保证结果满足      </span></span><br><span class="line">    <span class="keyword">return</span> barcodes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] barcodes, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> barcodes[i];</span><br><span class="line">    barcodes[i] = barcodes[j];</span><br><span class="line">    barcodes[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排列字符串使相邻字符不等"><a href="#排列字符串使相邻字符不等" class="headerlink" title="排列字符串使相邻字符不等"></a>排列字符串使相邻字符不等</h3><p>题目链接：<a href="https://leetcode.cn/problems/reorganize-string/description/">LeetCode_767. 重构字符串</a></p><p>Java大根堆，每次取出现频率最多的2个字符组合，重点对于剩1个元素时情况的讨论</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reorganizeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        cnt[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1,o2) -&gt; (o2[<span class="number">1</span>]-o1[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i] != <span class="number">0</span>) pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i,cnt[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> !pq.isEmpty();</span><br><span class="line">    <span class="keyword">if</span> (pq.peek()[<span class="number">1</span>] &gt; n/<span class="number">2</span> + <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span>[] a = pq.poll(), b = pq.poll();</span><br><span class="line">        <span class="keyword">assert</span> b != <span class="literal">null</span>;</span><br><span class="line">        sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span>+a[<span class="number">0</span>]));</span><br><span class="line">        sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span>+b[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">if</span> (--a[<span class="number">1</span>] &gt; <span class="number">0</span>) pq.add(a);</span><br><span class="line">        <span class="keyword">if</span> (--b[<span class="number">1</span>] &gt; <span class="number">0</span>) pq.add(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pq.isEmpty()) <span class="keyword">return</span> sb.toString();</span><br><span class="line">    <span class="keyword">if</span> (pq.peek()[<span class="number">1</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span>+pq.peek()[<span class="number">0</span>])).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="行驶问题"><a href="#行驶问题" class="headerlink" title="行驶问题"></a>行驶问题</h2><h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><p>题目链接：<a href="https://leetcode.cn/problems/gas-station/description/">LeetCode_134. 加油站 </a></p><p><strong>暴力解法:</strong></p><ul><li>依次枚举所有的起点:</li><li>从起点开始，模拟一遍加油的流程</li></ul><p><strong>贪心优化:</strong></p><ul><li>当从 i位置出发，走了 step 步之后，如果失败了。那么[i，i+ step]这个区间内任意一个位置作为起点，都不可能环绕一圈。</li><li>因此我们枚举的下一个起点，应该是 i + step + 1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 只要sumOfCost &lt;= sumOfGas 就代表者一定是可以到达的</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>, minBalance = <span class="number">0</span>; <span class="comment">// 具体从哪里出发的话就是从欠债最多的那个加油站就可以的</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class="line">       balance += gas[i] - cost[i];</span><br><span class="line">       <span class="keyword">if</span> (balance &lt; minBalance) &#123;</span><br><span class="line">           minBalance = balance;</span><br><span class="line">           minIndex = i + <span class="number">1</span>; <span class="comment">// 这里是问的第几个加油站</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> balance &gt;= <span class="number">0</span> ? minIndex : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列问题"><a href="#序列问题" class="headerlink" title="序列问题"></a>序列问题</h2><h3 id="递增的三元子序列"><a href="#递增的三元子序列" class="headerlink" title="递增的三元子序列"></a>递增的三元子序列</h3><p>题目链接：<a href="https://leetcode.cn/problems/increasing-triplet-subsequence/description/">LeetCode_334. 递增的三元子序列</a></p><p><strong>贪心策略:</strong></p><ul><li>最长递增子序列的简化版。</li><li>不用一个数组存数据，仅需两个变量即可。也不用二分插入位置，仅需两次比较就可以找到插入位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">increasingTriplet</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2147483647</span>, b = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n: nums) </span><br><span class="line">        <span class="keyword">if</span> (n &lt;= a) a = n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= b) b = n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>题目链接：<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://leetcode.cn/problems/longest-increasing-subsequence/&objectId=2527732&objectType=1&isNewArticle=undefined">LeetCode_300. 最长递增子序列</a></p><p><strong>贪心策略:</strong></p><ul><li>在考虑最长递增子序列的长度的时候，其实并不关心这个序列长什么样子，我们只是关心最后一个元素是谁。</li><li>这样新来一个元素之后，我们就可以判断是否可以拼接到它的后面。</li><li>因此，我们可以创建一个数组，统计长度为 x的递增子序列中，最后一个元素是谁。</li><li>为了尽可能的让这个序列更长，我们仅需统计长度为 x的所有递增序列中最后一个元素的「最小值」。</li><li>统计的过程中发现，数组中的数呈现「递增」趋势，因此可以使用「二分」来查找插入位置。</li></ul><p><strong>思路</strong>：</p><p>dp[i]: 所有长度为i+1的递增子序列中, 最小的那个序列尾数。由定义知dp数组必然是一个递增数组, 可以用 maxL 来表示最长递增子序列的长度。对数组进行迭代, 依次判断每个数num将其插入dp数组相应的位置:</p><ol><li>num &gt; dp[maxL], 表示num比所有已知递增序列的尾数都大, 将num添加入dp数组尾部, 并将最长递增序列长度maxL加1</li><li>dp[i - 1] &lt; num &lt;= dp[i], 只更新相应的dp[i]</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;  <span class="comment">// 二分法查找, 也可以调用库函数如binary_search</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = maxL;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid] &lt; num) &#123;</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hi = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[lo] = num;</span><br><span class="line">            <span class="keyword">if</span>(lo == maxL) &#123;</span><br><span class="line">                maxL++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;贪心算法是一种在每一步选择中都采取当前状态下最优（即最有利）的选择，从而希望导致结果是全局最优的算法策略。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_67868534/art</summary>
      
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>动态规划算法</title>
    <link href="https://southernfish.github.io/pages/algorithm/dynamic-programming/"/>
    <id>https://southernfish.github.io/pages/algorithm/dynamic-programming/</id>
    <published>2025-08-02T06:20:36.000Z</published>
    <updated>2025-09-17T07:51:48.699Z</updated>
    
    <content type="html"><![CDATA[<p>滑动窗口算法可以将嵌套的循环问题，转换为单循环问题，降低<a href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1001.2101.3001.7020">时间复杂度</a>。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/m0_46208463/article/details/141429458">【算法】动态规划</a></p><p><a href="https://blog.csdn.net/qq_43466788/article/details/109628158">【算法】备忘录法（记忆化搜索）</a></p><p><a href="https://blog.csdn.net/qq_43466788/article/details/109627650">【算法】动态规划（Dynamic Programming）</a></p></blockquote><h1 id="动态规划详解"><a href="#动态规划详解" class="headerlink" title="动态规划详解"></a>动态规划详解</h1><p>动态规划（Dynamic Programming，简称DP）是一种广泛应用于数学、计算机科学和经济学等领域的方法论。其核心思想是通过将复杂问题分解为相对简单的子问题，并存储子问题的解以避免冗余计算，从而显著提高计算效率。</p><p>动态规划作为运筹学的一个分支，专注于解决决策过程的最优化问题。20世纪50年代初，美国数学家贝尔曼（R. Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，并基于此创立了动态规划。动态规划的应用范围极为广泛，包括工程技术、经济、工业生产、军事以及自动化控制等多个领域。在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等实际问题中，动态规划均展现出了显著的效果。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>动态规划常常适用于具有重叠子问题和最优子结构性质的问题。其基本思想是将待求解的问题分解为若干个相关联的子问题，先求解子问题，然后利用这些子问题的解来构造原问题的解。对于重复出现的子问题，只在第一次遇到的时候对他进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。</p><p><strong>总体思想</strong><br>（1）动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题<br>（2）经分解得到的子问题往往不是互相独立的，有些子问题被重复计算多次<br>（3）若能保存已解决子问题的答案，而在需要时再找出已求得的答案，就可避免大量重复计算，从而得到多项式时间算法（备忘录法）</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806113808720.png" alt="image-20250806113808720"></p><p>动态规划的基本过程包括定义子问题，解决子问题，合并子问题的解来求解原问题。动态规划通常采用自底向上的方式进行，通过迭代计算子问题并存储子问题的解，逐步求解更大规模的问题，直到求解出原问题。</p><p>动态规划主要包括两个要素：<code>最优子结构</code>和<code>重叠子问题</code>。</p><p><strong>重复子问题</strong></p><ul><li>递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次，这种性质称为子问题的重叠性质</li><li>动态规划算法对每个子问题只解一次，并将其解保存在一个表格中，当再次需要解此子问题时，只是简单用常数时间查看一下结果</li><li>通常不同的子问题个数随问题的大小呈多项式增长，用动态规划算法只需要多项式时间，从而获得较高的解题效率</li></ul><p><strong>最优子结构</strong></p><ul><li>一个问题的最优解包含着其子问题的最优解，这种性质称为最优子结构性质</li><li>分析问题的最优子结构性质：首先假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾</li><li>利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解</li><li>最优子结构是一个问题能用动态规划算法求解的前提</li></ul><p><strong>动态规划算法与分治算法的异同点</strong></p><ul><li>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题</li><li>分治算法经分解得到的子问题往往是独立的</li><li>动态规划算法经分解得到的子问题往往不是独立的，有些子问题被重复计算多次</li></ul><p><strong>动态规划求解的基本步骤</strong></p><ol><li>找出最优解的性质，并刻划其结构特征</li><li>递归地定义最优值</li><li>以自底向上的方式计算出最优值</li><li>根据计算最优值时得到的信息，构造最优解</li></ol><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>动态规划算法的基本步骤通常包括：划分阶段、定义状态、建立状态转移方程以及确定边界条件等。</p><p><strong>划分阶段</strong>：按照时间或空间特征，将问题划分为若干个阶段，每个阶段对应一个决策过程。这些阶段需要满足无后效性，即某个阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响。这是动态规划方法应用的前提，也是保证算法有效性的基础。</p><p><strong>定义状态</strong>：对每个阶段定义状态变量，状态变量应该能够表示出该阶段所有可能的信息，且能从中推导出下一阶段的状态。在定义状态时，要考虑到问题的具体特征，使得状态变量能够简洁明了地反映问题的本质。</p><p><strong>状态转移方程</strong>：根据问题的性质，建立从一个阶段到下一个阶段的递推关系式，即状态转移方程。状态转移方程是动态规划算法的核心部分，它描述了问题在不同阶段之间的转移关系。在建立状态转移方程时，需要仔细分析问题的特征，找到正确的状态转移方式。同时，要注意避免重复计算，提高算法的效率。</p><p><strong>边界条件</strong>：确定状态转移方程中的起始状态，即问题的初始条件。边界条件是动态规划算法的重要组成部分，它决定了算法的起点和范围。在确定边界条件时，要根据问题的具体要求进行设定，确保算法的正确性和有效性。</p><p><strong>求解最优解</strong>：利用状态转移方程和边界条件，从初始状态开始逐步求解问题，最终得到问题的最优解。在求解过程中，要注意保存中间结果，以便后续使用。同时，要注意算法的时间复杂度和空间复杂度，确保算法在实际应用中的可行性。</p><p><strong>优化与改进</strong>：在得到基本解决方案后，可以对算法进行优化和改进。例如，可以采用更高效的数据结构来存储中间结果，或者采用更合理的状态转移方式来减少计算量。此外，还可以结合其他算法和技术来进一步提高算法的性能和适用范围。</p><p><strong>算法实现与测试</strong>：将优化后的算法用具体的编程语言实现，并进行测试以验证其正确性和有效性。在实现过程中，要注意代码的可读性和可维护性，以便后续修改和扩展。同时，要进行充分的测试以确保算法在各种情况下的正确性。</p><h2 id="动态规划优缺点"><a href="#动态规划优缺点" class="headerlink" title="动态规划优缺点"></a>动态规划优缺点</h2><p><strong>优点</strong></p><ul><li><p>对于具有重叠子问题和最优子结构性质的问题，动态规划可以显著提高求解效率，避免不必要的重复计算。通过存储和复用子问题的解，动态规划算法能够避免重复计算相同的子问题，从而大大减少计算量。</p></li><li><p>动态规划算法的代码通常比较简洁，易于理解和实现。一旦确定了问题的状态转移方程和边界条件，动态规划算法的代码实现往往非常直观和简洁。</p></li></ul><p><strong>缺点</strong></p><ul><li>对于没有重叠子问题和最优子结构性质的问题，动态规划算法可能并不适用，此时需要考虑其他算法。动态规划算法的有效性建立在问题的重叠子问题和最优子结构性质上，如果问题不具备这些性质，那么动态规划算法就无法发挥其优势。</li><li>动态规划算法的空间复杂度通常较高，需要存储所有子问题的解，以便后续使用。这可能导致算法在处理大规模问题时需要消耗大量的内存空间。在某些情况下，可能需要考虑使用滚动数组或其他优化技巧来降低空间复杂度。滚动数组是一种常用的优化方法，它只保留当前需要使用的子问题解，从而避免了存储所有子问题的解。</li></ul><hr><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>动态规划是求多阶段决策过程最优化的一种数学方法，它将问题的整体按时间或空间的特征分成若干个前后衔接的时空阶段，把多个阶段决策问题表示为前后有关的一系列单阶段决策问题，然后逐个求解，从而求出整个问题的最有决策序列。动态规划的十大经典问题：</p><blockquote><ol><li>最长公共子序列</li><li>背包问题</li><li>矩阵链路乘法</li><li>编辑距离</li><li>硬币找零问题</li><li>最大子段和</li><li>最长递增子序列</li><li>0-1背包问题</li><li>划分问题</li><li>合并排序问题</li></ol></blockquote><h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><p>有一只小兔子站在一片三角形的胡萝卜地的入口（数字1处），如下所示，图中的数字表示每一个坑中胡萝卜的数量，小兔子每次只能跳到左下角或者右下角的坑中，请问小兔子怎么跳才能得到最多数量的胡萝卜？</p><blockquote><p>1<br>3 2<br>4 10 1<br>4 3 2 20</p></blockquote><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806114712772.png" alt="image-20250806114712772"></p><h3 id="经典递归解法"><a href="#经典递归解法" class="headerlink" title="经典递归解法"></a>经典递归解法</h3><p>采用暴力法解决这个问题，从第一层开始，每次有两个选择，左下角和右下角，也就是n层的话，有2^{n-1}条路径，T（n） = 2^n 。</p><h4 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h4><p>把上面的三角形放到一个二维数组中，没有放数的地方都为0<br>从二位数组的a[i][j] 开始，最多的胡萝卜数为a[i][j]加上以右下角为起点和左下角为起点路径中的胡萝卜最大数的路径，循坏递归，因为每个点都有两条路径选择，每次选择路径中胡萝卜最多的路径。递归的结束条件是 i = n+1时结束，因为有n层，到n+1层时自然就结束。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] a = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>&#125;,&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">20</span>&#125;&#125;;</span><br><span class="line">    System.out.println(solve(a,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span>[][] a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="comment">// 第 n+1 层结束  ===》从0层开始计算 ，那么 i = n 时结束</span></span><br><span class="line">    <span class="keyword">if</span> (i == a.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[i][j]+ Math.max(solve(a,i+<span class="number">1</span>,j),solve(a,i+<span class="number">1</span>,j+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="备忘录法"><a href="#备忘录法" class="headerlink" title="备忘录法"></a>备忘录法</h3><h4 id="什么是备忘录法"><a href="#什么是备忘录法" class="headerlink" title="什么是备忘录法"></a>什么是备忘录法</h4><ul><li>备忘录法是为了解决避免递归算法中相同子问题的重复求解。</li><li>备忘录法为每个解过的子问题建立备忘录以备需要时查看，所以也称搜表法。</li><li>备忘录法的控制与直接使用递归方法的控制结构相同。</li><li>备忘录法又称记忆化搜索，自顶向下的方式解决问题。</li></ul><h4 id="备忘录法的实现"><a href="#备忘录法的实现" class="headerlink" title="备忘录法的实现"></a>备忘录法的实现</h4><p>避免子问题重复被求解，可以定义一个数组，每次要计算一个子问题时，首先从数组中查询这个子问题的解，子问题解没有在数组中，说明没有计算过该子问题，那么计算该子问题，并将解放到数组中去，以便下次计算该子问题时，可以直接从数组中拿。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>上面递归时候，我们solve(a,2,1)被重复计算过两次。此时可用备忘录法，即利用一个二维数组记录每次子问题计算的值（例如a(6，3)的解就放到 d [6] [3]中），每次需要计算子问题时，先判断数组中是否计算过保存了，有则直接取用，没有就计算并把结果保存到数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] a = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>&#125;,&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">20</span>&#125;&#125;;</span><br><span class="line">    System.out.println(solve(a, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">int</span>[a.length][a.length]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span>[][] a,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span>[][] p)</span>&#123;</span><br><span class="line">    <span class="comment">//第 n+1 层结束  ===》从0层开始计算 ，那么 i = n 时结束</span></span><br><span class="line">    <span class="keyword">if</span> (i == a.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        p[i][j] = a[i][j] + Math.max(solve(a, i + <span class="number">1</span>, j, p), solve(a, i + <span class="number">1</span>, j + <span class="number">1</span>, p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ol><li><p><code>p[i][j]</code>表示(i, j)的达到最后一层的最大路径和，那么p[i][j]的最优解包含了子问题<code>p[i+1][j]</code>或<code>p[i+1][j+1]</code>的最优解</p></li><li><p>状态转移方程（递归方程）及图解</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806120324792.png" alt="image-20250806120324792"></p></li><li><p>最终结果是<code>p[0][0]</code>（从表的最后一层开始填）</p></li><li><p>动态规划法又叫填表法，填完上面那张表结果就出来了</p></li></ol><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] a = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>&#125;,&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">20</span>&#125;&#125;;</span><br><span class="line">    System.out.println(solve(a));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span>[][] a)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[][] p = a.clone();</span><br><span class="line">    <span class="comment">// 最后一层的数不需要修改 ，从倒数第二次开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            p[i][j] = a[i][j] + Math.max(p[i+<span class="number">1</span>][j],p[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ol><li><p><code>p[i][j]</code>表示从(1,1)到达(i, j) 的最大路径和，那么<code>p[i][j]</code>的最优解包含了子问题<code>p[i-1][j-1]</code>或<code>p[i-1][j]</code>的最优解</p></li><li><p>状态转移方程（递归方程）和图解</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806120733577.png" alt="image-20250806120733577"></p></li><li><p>最终结果是<code>p[4][4]</code>（从表的第一层开始填）</p></li></ol><h2 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>最长公共子序列（Longest Common Subsequence，简称LCS）。其基本思想是寻找两个字符串中都存在的最长子序列，该最长子序列可以不连续，但要保证其相对顺序一样。（注意，这里是子序列，而不是子串，子序列可以不连续，而子串是连续的）。具有特征如下：</p><blockquote><p><strong>长度</strong>：最长公共子序列的长度最大为两个序列的最小长度，如果两个序列完全相同，则它们的最长公共子序列即为它们本身。</p><p><strong>顺序</strong>：最长公共子序列中的子序列在原序列中的顺序一致。</p><p><strong>相同元素</strong>：最长公共子序列中的子序列所包含的元素必须在两个原序列中都存在。</p><p><strong>不连续性</strong>：最长公共子序列不需要在原序列中连续出现。</p></blockquote><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>​    求解LCS问题，不能使用暴力搜索方法。一个长度为n的序列拥有 2的n次方个子序列，它的时间复杂度是指数阶，太恐怖了。解决LCS问题，需要借助动态规划的思想。</p><p>  动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。</p><h3 id="特征分析"><a href="#特征分析" class="headerlink" title="特征分析"></a>特征分析</h3><p>  <strong>设A=“a0，a1，…，am”，B=“b0，b1，…，bn”，且Z=“z0，z1，…，zk”为它们的最长公共子序列。不难证明有以下性质：</strong></p><blockquote><p>如果am=bn，则zk=am=bn，且“z0，z1，…，z(k-1)”是“a0，a1，…，a(m-1)”和“b0，b1，…，b(n-1)”的一个最长公共子序列；<br>如果am!=bn，则若zk!=am，蕴涵“z0，z1，…，zk”是“a0，a1，…，a(m-1)”和“b0，b1，…，bn”的一个最长公共子序列；<br>如果am!=bn，则若zk!=bn，蕴涵“z0，z1，…，zk”是“a0，a1，…，am”和“b0，b1，…，b(n-1)”的一个最长公共子序列。</p></blockquote><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806105617464.png" alt="image-20250806105617464"></p><p>案例说明：S1 = {1,3,4,5,6,7,7,8} 和 S2 = {3,5,7,4,8,6,7,8,2}），结合上图：<br>  假如S1的最后一个元素 与 S2的最后一个元素相等，那么S1和S2的LCS就等于 {S1减去最后一个元素} 与 {S2减去最后一个元素} 的 LCS 再加上 S1和S2相等的最后一个元素。</p><p>  假如S1的最后一个元素 与 S2的最后一个元素不等（本例子就是属于这种情况），那么S1和S2的LCS就等于 ： {S1减去最后一个元素} 与 S2 的LCS， {S2减去最后一个元素} 与 S1 的LCS 中的最大的那个序列。</p><h3 id="递归公式"><a href="#递归公式" class="headerlink" title="递归公式"></a>递归公式</h3><p>​    根据LCS的特征，假设需要求 a1 … am 和 b1 … b(n-1)的LCS 和 a1 … a(m-1) 和 b1 … bn的LCS，一定会递归地并且重复地把如a1… a(m-1) 与 b1 … b(n-1) 的 LCS 计算几次。所以我们需要一个数据结构来记录中间结果，避免重复计算。</p><p>  假设用c[i,j]表示Xi 和 Yj 的LCS的长度（直接保存最长公共子序列的中间结果不现实，需要先借助LCS的长度）。其中X = {x1 … xm}，Y ={y1…yn}，Xi = {x1 … xi}，Yj={y1… yj}。可得递归公式如下：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/wps1.jpg" alt="img"></p><h3 id="计算LSC的长度"><a href="#计算LSC的长度" class="headerlink" title="计算LSC的长度"></a>计算LSC的长度</h3><p>以表格的形式表示整个过程如下：</p><table><thead><tr><th>下标</th><th>j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>i</td><td></td><td>S2j</td><td>3</td><td>5</td><td>7</td><td>4</td><td>8</td><td>6</td><td>7</td><td>8</td><td>2</td></tr><tr><td>0</td><td>S1i</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>3</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>3</td><td>4</td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>4</td><td>5</td><td>0</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>5</td><td>6</td><td>0</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>6</td><td>7</td><td>0</td><td>1</td><td>2</td><td>3</td><td>3</td><td>3</td><td>3</td><td>4</td><td>4</td><td>4</td></tr><tr><td>7</td><td>7</td><td>0</td><td>1</td><td>2</td><td>3</td><td>3</td><td>3</td><td>3</td><td>4</td><td>4</td><td>4</td></tr><tr><td>8</td><td>8</td><td>0</td><td>1</td><td>2</td><td>3</td><td>3</td><td>4</td><td>4</td><td>4</td><td>5</td><td>5</td></tr></tbody></table><p>填表的过程就相当于解题的过程（第0行、第0列初始值都为0），以第0行为参照，先从左到右填满第1行；再以第1行为参照，从左到右填满第2行；以此类推，当表格填完后，答案就出来了（即为L[n][n]）。根据性质，c[8,9] = S1 和 S2 的 LCS的长度，即为5。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>参见下文 <a href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">最长公共子序列</a></p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>给定n种物品（每种物品只有一件）和一个背包：物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</li><li>对于每种物品，只有两种选择：装(1)或者不装(0)，不允许装物品的一部分</li></ul><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li><p>n=5, c=10, w={2, 2, 6, 5, 4}, v={6, 3, 5, 4, 6}</p></li><li><p>选中1，2，5三件物品，最高价值15，总重8</p></li><li><p>填表，物品的种类为表行，背包容量+1为行，从后面填到前面，j表示背包容量。</p></li><li><p>最后一行</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806121725952.png" alt="image-20250806121725952"></p></li><li><p>前面的行</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806121833004.png" alt="image-20250806121833004"></p></li><li><p>最大值为右上角</p></li></ul><h3 id="代码实现一"><a href="#代码实现一" class="headerlink" title="代码实现一"></a>代码实现一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 浪费数组的第一个</span></span><br><span class="line">    <span class="type">int</span>[] w = &#123;<span class="number">0</span>,<span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] v = &#123;<span class="number">0</span>,<span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    System.out.println(fun(<span class="number">5</span>, <span class="number">10</span>, v, w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> c,<span class="type">int</span>[] v,<span class="type">int</span>[] w)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[][] m = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][c+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 防止数组越界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">jMax</span> <span class="operator">=</span> Math.min(w[n]-<span class="number">1</span>,c);</span><br><span class="line">    <span class="comment">// Step1:填最后一行</span></span><br><span class="line">    <span class="comment">// j&lt;w[n] ==&gt;m[n][j]=0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= jMax; j++) &#123;</span><br><span class="line">        m[n][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// j&gt;=w[n] ==&gt;m[n][j]=v[n]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> w[n]; j &lt;= c; j++) &#123;</span><br><span class="line">        m[n][j] = v[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Step2: 从倒数第二行往前面填</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        jMax = Math.min(w[i]-<span class="number">1</span>,c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= jMax; j++) &#123;</span><br><span class="line">            m[i][j] = m[i+<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> w[i]; j &lt;= c; j++) &#123;</span><br><span class="line">            m[i][j] = Math.max(m[i+<span class="number">1</span>][j],m[i+<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一行最后一个元素</span></span><br><span class="line">    m[<span class="number">1</span>][c] = m[<span class="number">2</span>][c];</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= w[<span class="number">1</span>])&#123;</span><br><span class="line">        m[<span class="number">1</span>][c] = Math.max(m[<span class="number">1</span>][c],m[<span class="number">2</span>][c-w[<span class="number">1</span>]]+v[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m[<span class="number">1</span>][c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码实现二"><a href="#代码实现二" class="headerlink" title="代码实现二"></a>代码实现二</h3><p>知道选择了哪些物品使得价值最大，选择了物品用1表示，没选择用0表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据填的表格推断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traceback</span><span class="params">(<span class="type">int</span>[][] m,<span class="type">int</span> n,<span class="type">int</span> c,<span class="type">int</span>[] w)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] x = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//没有选择</span></span><br><span class="line">        <span class="keyword">if</span> (m[i][c] == m[i+<span class="number">1</span>][c] )&#123;</span><br><span class="line">            x[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            x[i] = <span class="number">1</span>;</span><br><span class="line">            c -= w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    x[n] = (m[n][c]&gt;<span class="number">0</span>) ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span> ; i &lt; x.length; i++) &#123;</span><br><span class="line">        System.out.print(x[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p><a href="https://leetcode.cn/problems/regular-expression-matching/">LeetCode 10 正则表达式匹配</a></p><blockquote><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><ul><li><code>&#39;.&#39;</code> 匹配任意单个字符</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code> 的，而不是部分字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;, p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;, p = &quot;a*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ab&quot;, p = &quot;.*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code>，<code>1 &lt;= p.length &lt;= 20</code></li><li><code>s</code> 只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li><li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), pLen = p.length();</span><br><span class="line">    <span class="type">boolean</span>[][] memory = <span class="keyword">new</span> <span class="title class_">boolean</span>[sLen+<span class="number">1</span>][pLen+<span class="number">1</span>]; <span class="comment">// i,j是否匹配</span></span><br><span class="line">    memory[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= sLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= pLen; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">// 用例保证了第一个字符不可能是 *</span></span><br><span class="line">                memory[i][j] = memory[i][j-<span class="number">2</span>] || </span><br><span class="line">                    (i &gt; <span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">2</span>) || p.charAt(j-<span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; memory[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                memory[i][j] = i &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">                    (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; memory[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[sLen][pLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/description/">LeetCode 53 最大子数组和</a></p><blockquote><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) sum += num;</span><br><span class="line">        <span class="keyword">else</span> sum = num;</span><br><span class="line">        res = Math.max(res, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">LeetCode 1143 最长公共子序列</a></p><blockquote><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义dp[i][j]表示[0,i-1]的子串text1与[0,j-1]的子串text2的最长公共长度</span></span><br><span class="line">    <span class="comment">// 假如两者text1[i]=text2[j]，当前长度就是dp[i-1][j-1]+1</span></span><br><span class="line">    <span class="comment">// 假如两者不等，当前长度可以从[i-1][j]推出，也可以从[i][j-1]推出</span></span><br><span class="line">    <span class="comment">// 当前值可以从左上角、左边、上方3个方向推导</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> text1.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> text2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))</span><br><span class="line">                dp[i][j] = dp[i -<span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找终点"><a href="#找终点" class="headerlink" title="找终点"></a>找终点</h2><p><a href="https://www.nowcoder.com/discuss/679138988615020544">牛客网_找终点</a></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数数组，设为nums，最大为100个成员，求从第一个成员开始，正好走到数组最后一个成员，所使用的最少步骤数。要求:</span><br><span class="line">1、第一步必须从第一元素开始，且1&lt;=第一步的步长&lt;len/2;(len为数组的长度，需要自行解析)。</span><br><span class="line">2、从第二步开始，只能以所在成员的数字走相应的步数，不能多也不能少,如果目标不可达返回-1，只输出最少的步骤数量。</span><br><span class="line">3、只能向数组的尾部走，不能往回走。</span><br><span class="line">输入描述：由正整数组成的数组，以空格分隔， 数组长度 小于100，请自行解析数据数量。</span><br><span class="line">输出描述：正整数，表示最少的步数，如果不存在输出-1</span><br><span class="line">示例1</span><br><span class="line">输入 7 5 9 4 2 6 8 3 5 4 3 9</span><br><span class="line">输出  2</span><br><span class="line">说明：</span><br><span class="line">第一步:第一个可选步长选择2，从第一个成员7开始走2步，到达9;</span><br><span class="line">第二步:从9开始，经过自身数字9对应的9个成员到最后。</span><br><span class="line">示例2</span><br><span class="line">输入 1 2 3 7 1 5 9 3 2 1</span><br><span class="line">输出 -1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findTheEnd</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化动态规划数组，dp[i]表示到达第i个位置所需的最少步骤数</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">999999</span>); <span class="comment">// 初始化填充较大值</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一个位置的步骤数为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n / <span class="number">2</span>; i++) &#123; <span class="comment">// 初始化从第一个位置开始的步长，步长范围为1到len/2</span></span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历数组，更新动态规划数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + a[i] &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i + a[i]] = Math.min(dp[i + a[i]], dp[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果，如果最后一个位置的步数仍为无穷大，表示不可达，输出-1</span></span><br><span class="line">    System.out.println(dp[n - <span class="number">1</span>] == <span class="number">999999</span> ? -<span class="number">1</span> : dp[n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StepTo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Input input;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> <span class="title class_">Input</span>(<span class="string">&quot;7 5 9 4 2 6 8 3 5 4 3 9&quot;</span>);</span><br><span class="line">        input = <span class="keyword">new</span> <span class="title class_">Input</span>(<span class="string">&quot;1 2 3 7 1 5 9 3 2 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        String[] split = input.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[split.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; split.length; i++) &#123;</span><br><span class="line">            array[i] = Integer.parseInt(split[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后一脚 迈到终点 则说明该这一步的起脚点 下标 + 对应的之恰好是中调的坐标</span></span><br><span class="line">        <span class="comment">// 依次递归个逻辑即可找到路径 计算该路径的步数即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> array.length - <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] + i == array.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">steps1</span> <span class="operator">=</span> getSteps(array, i);</span><br><span class="line">                <span class="keyword">if</span> (steps1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    steps = Math.min(steps, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (steps == <span class="number">1000</span>) &#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(steps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSteps</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> step)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这一步落在数组的前半部分， 第一步迈到这里即可以到达终点</span></span><br><span class="line">        <span class="keyword">if</span> ( step &gt;= <span class="number">1</span> &amp;&amp; step &lt; (array.length - <span class="number">1</span>)/<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果起脚点小于 1 说明没有合适的起脚点</span></span><br><span class="line">        <span class="keyword">if</span> (step &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextStep</span> <span class="operator">=</span> -<span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 找到上一脚的起脚点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> step - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] + i == step) &#123;</span><br><span class="line">                nextStep = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  getSteps(array, nextStep) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;滑动窗口算法可以将嵌套的循环问题，转换为单循环问题，降低&lt;a href=&quot;https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;spm=1001.2101.3001.702</summary>
      
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口算法</title>
    <link href="https://southernfish.github.io/pages/algorithm/sliding-window/"/>
    <id>https://southernfish.github.io/pages/algorithm/sliding-window/</id>
    <published>2025-08-02T02:00:36.000Z</published>
    <updated>2025-09-17T07:51:48.700Z</updated>
    
    <content type="html"><![CDATA[<p>滑动窗口算法可以将嵌套的循环问题，转换为单循环问题，降低<a href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1001.2101.3001.7020">时间复杂度</a>。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/mengyoufengyu/article/details/145620833">算法07-滑动窗⼝算法</a></p><p><a href="https://blog.csdn.net/qq_39559641/article/details/122793321">滑动窗口算法精讲（Sliding Window Algorithm）</a></p><p><a href="https://blog.csdn.net/guihunkun/article/details/109266185">滑动窗口相关算法题总结</a></p></blockquote><h1 id="详细讲解"><a href="#详细讲解" class="headerlink" title="详细讲解"></a>详细讲解</h1><h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p><strong>滑动窗口算法</strong>是一种通过维护一个动态窗口来解决问题的技巧，窗口在数据上“滑动”，逐步找到最优解。</p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>滑动窗口算法的本质是双指针法中的左右指针法，所谓滑动窗口，就像描述的那样，可以理解成是一个会滑动的窗口，每次记录下窗口的状态，再找出符合条件的适合的窗口。它可以将双层嵌套的循环问题，转换为单层遍历的循环问题。使用两个指针一左一右构成一个窗口，就可以将二维循环的问题转化成一维循环一次遍历，相当于通过旧有的计算结果对搜索空间进行剪枝，使时间复杂度从O（n²）降低至O（n），比如经典字符串查找算法Rabin-Karp 指纹字符串查找算法，它本质上也使用了滑动窗口的思想，通过公式推导降低窗口滑动时计算子串哈希值的复杂度。</p><p>滑动窗口算法更多的是一种思想或技巧，按照窗口大小是否固定分为固定滑动窗口和变长滑动窗口，可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。往往类似于“请找到满足xx的最x的区间（子串、子数组等）的xx”这类问题都可以使用该方法进行解决。</p><p>想象你在看一列火车，火车窗口只能看到一部分车厢。滑动窗口算法就是通过调整窗口的起点和终点，找到你感兴趣的部分（比如最长的连续车厢、最短的覆盖范围等）。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>滑动窗口算法通常用于解决以下问题：</p><ol><li><strong>子数组/子字符串问题</strong>：比如找最长的无重复字符子串、最短的覆盖子串等。</li><li><strong>连续区间问题</strong>：比如找满足条件的连续子数组。</li><li><strong>优化问题</strong>：比如在固定窗口大小内找最大值、最小值或平均值。</li></ol><h2 id="滑动窗口的两种类型"><a href="#滑动窗口的两种类型" class="headerlink" title="滑动窗口的两种类型"></a>滑动窗口的两种类型</h2><h3 id="固定大小的窗口"><a href="#固定大小的窗口" class="headerlink" title="固定大小的窗口"></a>固定大小的窗口</h3><ul><li>窗口大小固定，比如每次只看连续的 3 个元素。</li><li>例子：计算数组中每个长度为 k 的子数组的平均值。</li></ul><h3 id="可变大小的窗口"><a href="#可变大小的窗口" class="headerlink" title="可变大小的窗口"></a>可变大小的窗口</h3><ul><li>窗口大小不固定，根据条件动态调整。</li><li>例子：找最长的无重复字符子串。</li></ul><h2 id="滑动窗口的基本步骤"><a href="#滑动窗口的基本步骤" class="headerlink" title="滑动窗口的基本步骤"></a>滑动窗口的基本步骤</h2><ol><li><p><strong>初始化窗口</strong>：</p><ul><li>定义窗口的起点（<code>left</code>）和终点（<code>right</code>），通常初始化为 0，把索引闭区间 [left, right] 称为一个「窗口」。</li><li>定义一些辅助变量（比如当前窗口的和、最大值、最小值等）。</li></ul></li><li><p><strong>滑动窗口</strong>：</p><ul><li><p>移动右边界（<code>right</code>），扩大窗口 [left, right]，直到满足某个条件。（找可行解）</p></li><li><p>移动左边界（<code>left</code>），缩小窗口 [left, right]，直到不满足条件。同时每次增加 left 都要更新一轮结果。（优化可行解）</p></li><li><p>在滑动过程中，记录需要的结果（比如最大长度、最小长度等）。</p></li></ul></li><li><p><strong>滑动窗口</strong>，直至一次遍历结束：重复第 2 步，直到 right 到达到的尽头。</p></li><li><p><strong>返回结果</strong>：根据滑动过程中记录的结果，返回最终答案。</p></li></ol><h2 id="关键特点"><a href="#关键特点" class="headerlink" title="关键特点"></a>关键特点</h2><ol><li><strong>高效</strong>：通过滑动窗口，避免了重复计算，时间复杂度通常为 (O(n))。</li><li><strong>灵活</strong>：适用于多种问题，尤其是需要处理连续区间的问题。</li><li><strong>双指针</strong>：滑动窗口通常用双指针（<code>left</code> 和 <code>right</code>）来实现。</li></ol><hr><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="模板一"><a href="#模板一" class="headerlink" title="模板一"></a>模板一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">slideWindowTemplate</span><span class="params">(String nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;        <span class="comment">//[初始化窗口]</span></span><br><span class="line">    <span class="comment">//codes...               [其他初始化信息,定义一些维护数据的数据结构]</span></span><br><span class="line">    <span class="keyword">while</span>(r &lt; nums.length)&#123;</span><br><span class="line">        <span class="comment">//codes.....         [维护窗口中的数据] </span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; check(xxx) == <span class="literal">false</span>)&#123;   <span class="comment">//[窗口不满足某种性质]</span></span><br><span class="line">            <span class="comment">//codes...       [维护窗口中的数据] </span></span><br><span class="line">            l++;             <span class="comment">//[缩小窗口]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//codes..            [更新结果]</span></span><br><span class="line">        r++;                 <span class="comment">//[增大窗口]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板二"><a href="#模板二" class="headerlink" title="模板二"></a>模板二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">slideWindowTemplate</span><span class="params">(String nums)</span>&#123;</span><br><span class="line">    <span class="comment">//codes...               [其他初始化信息,定义一些维护数据的数据结构]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.length; r++)&#123;</span><br><span class="line">        <span class="comment">//codes.....         [维护窗口中的数据] </span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; check(xxx) == <span class="literal">false</span>)&#123;   <span class="comment">//[窗口不满足某种性质]</span></span><br><span class="line">            <span class="comment">//codes...       [维护窗口中的数据] </span></span><br><span class="line">            l++;             <span class="comment">//[缩小窗口]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//codes..            [更新结果]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="补种未成活胡杨"><a href="#补种未成活胡杨" class="headerlink" title="补种未成活胡杨"></a>补种未成活胡杨</h2><blockquote><p>近些年来，我国防沙治沙取得显著成果。某沙漠新种植N棵胡杨(编号1-N)，排成一排。一个月后，有M棵胡杨未能成活。<br>现可补种胡杨K棵，请问如何补种(只能补种，不能新种)，可以得到最多的连续胡杨树?<br>输入描述<br>N 总种植数量<br>M 未成活胡杨数量<br>M 个空格分隔的数，按编号从小到大排列<br>K 最多可以补种的数量<br>其中:<br>1&lt;=N&lt;=100000<br>1&lt;=M&lt;=N<br>0&lt;=K&lt;=M<br>输出描述：最多的连续胡杨棵树<br>示例1<br>输入<br>5<br>2<br>2 4<br>1<br>输出 3<br>说明：补种到2或4结果一样，最多的连续胡杨棵树都是3<br>示例2<br>输入<br>10<br>3<br>2 4 7<br>1<br>输出 6<br><strong>说明</strong>：补种第7棵树，最多的连续胡杨棵树为6(5,6,7,8,9,10)<br><strong>解析</strong><br><strong>初始化</strong>：首先读取总种植数量N，并初始化一个长度为N的数组tree，所有初始值为0，表示所有胡杨都成活。读取未成活胡杨的数量M，然后读取未成活胡杨的编号，将相应位置的tree值设为1，表示该胡杨未成活。读取最多可以补种的数量K。</p><p><strong>滑动窗口算法</strong>：遍历每棵树的位置，如果当前树未成活（tree[i]为1），则将其加到tot中。如果未成活树的总数tot超过K，说明当前窗口的未成活树数超过了补种数量，需要调整窗口大小，从左侧逐次减少未成活树数，直到tot不超过K。每次调整窗口之后，计算当前窗口的大小（i - j + 1），如果大于之前记录的最大连续成活树数，则更新最大值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// 读入总种植数量N</span></span><br><span class="line">    <span class="type">int</span> tree[] = <span class="keyword">new</span> <span class="title class_">int</span>[N];  <span class="comment">// 创建一个长度为N的数组用于存储每棵树的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// 读入未成活胡杨数量M</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// 读入每棵未成活胡杨的编号</span></span><br><span class="line">        tree[x - <span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 将对应位置的值设为1，表示未成活</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 读入最多可以补种的数量K</span></span><br><span class="line">    <span class="comment">// 初始化变量:总未成活树数、最大连续胡杨数、滑动窗口起始位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历所有树的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">        <span class="comment">// 每次遍历都将当前树的状态加到tot，如果未成活则+1，成活则+0</span></span><br><span class="line">        tot += tree[r];</span><br><span class="line">        <span class="comment">// 如果未成活树的总数超过了补种限制</span></span><br><span class="line">        <span class="keyword">while</span> (tot &gt; cnt) &#123;</span><br><span class="line">            tot -= tree[l]; <span class="comment">// 减去窗口起始位置的树的状态</span></span><br><span class="line">            l++;         <span class="comment">// 滑动窗口的起始位置右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算当前滑动窗口的大小，如果比之前的最大连续数大则更新</span></span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; ans) &#123;</span><br><span class="line">            ans = r - l + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(ans); <span class="comment">// 输出最大连续胡杨数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LeetCode 3 无重复字符的最长子串</a></p><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(s.charAt(right)) &amp;&amp; map.get(s.charAt(right)) &gt;= left) &#123;</span><br><span class="line">            max = Math.max(max, right - left);</span><br><span class="line">            left = map.get(s.charAt(right)) + <span class="number">1</span>; <span class="comment">// 左边设置为重复字符的下一位</span></span><br><span class="line">            map.put(s.charAt(right), right);<span class="comment">// 已存在字符更新最新下标</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(s.charAt(right), right); <span class="comment">// 添加字符 及下标</span></span><br><span class="line">            max = Math.max(max, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(string s)</span> s&#123;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt; record;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>,left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(record.find(s[right]) == record.end()) &#123;</span><br><span class="line">            record.insert(s[right++]);</span><br><span class="line">            res = max(res,(<span class="type">int</span>)record.size());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            record.erase(s[left++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">LeetCode 76 最小覆盖子串</a></p><blockquote><p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。<br>示例：<br>输入：S = “ADOBECODEBANC”, T = “ABC”<br>输出：“BANC”<br>提示：<br>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>]; <span class="comment">// ASCII码  0-9：48-57； a-z:97-122  A-Z：65-90</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) cnt[t.charAt(i)]++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, ansL = <span class="number">0</span>, ansR = <span class="number">0</span>, ans = Integer.MAX_VALUE, cntT = t.length();</span><br><span class="line">    <span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[s.charAt(r++)]-- &gt; <span class="number">0</span>) cntT--;</span><br><span class="line">        <span class="keyword">while</span> (cntT == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l &lt; ans) &#123;</span><br><span class="line">                ans = r - l;</span><br><span class="line">                ansL = l;</span><br><span class="line">                ansR = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt[s.charAt(l++)]++ == <span class="number">0</span>) cntT++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(ansL, ansR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大连续1的个数-III"><a href="#最大连续1的个数-III" class="headerlink" title="最大连续1的个数 III"></a>最大连续1的个数 III</h2><p><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">LeetCode 1004 最大连续1的个数 III</a></p><blockquote><p>给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。<br>返回仅包含 1 的最长（连续）子数组的长度。<br>示例 1：<br>输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2<br>输出：6<br>解释：<br>[1,1,1,0,0,1,1,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 6。<br>示例 2：<br>输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3<br>输出：10<br>解释：<br>[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 10。<br>提示：<br>1 &lt;= A.length &lt;= 20000<br>0 &lt;= K &lt;= A.length<br>A[i] 为 0 或 1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestOnes</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] == <span class="number">0</span>) &#123;</span><br><span class="line">            k--; <span class="comment">// 0变成1，消耗一个1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] == <span class="number">0</span>) &#123;</span><br><span class="line">                k++; <span class="comment">// 1变成0，归还一个1</span></span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, right - left + <span class="number">1</span>); <span class="comment">// 把 right++语句在后面，所以这里是 right-left+1</span></span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可获得的最大点数"><a href="#可获得的最大点数" class="headerlink" title="可获得的最大点数"></a>可获得的最大点数</h2><p><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/">LeetCode 1423 可获得的最大点数</a></p><blockquote><p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。你的点数就是你拿到手中的所有卡牌的点数之和。<br>给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。<br>示例 1：<br>输入：cardPoints = [1,2,3,4,5,6,1], k = 3<br>输出：12<br>解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。<br>示例 2：<br>输入：cardPoints = [2,2,2], k = 2<br>输出：4<br>解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。<br>示例 3：<br>输入：cardPoints = [9,7,7,9,7,7,9], k = 7<br>输出：55<br>解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。<br>示例 4：<br>输入：cardPoints = [1,1000,1], k = 1<br>输出：1<br>解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。<br>示例 5：<br>输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3<br>输出：202<br>提示：<br>1 &lt;= cardPoints.length &lt;= 10^5<br>1 &lt;= cardPoints[i] &lt;= 10^4<br>1 &lt;= k &lt;= cardPoints.length</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScore</span><span class="params">(<span class="type">int</span>[] cardPoints, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cardPoints.length, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cardPoint: cardPoints) &#123;</span><br><span class="line">        sum += cardPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> len - k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        temp += cardPoints[i];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= length) &#123;</span><br><span class="line">            temp -= cardPoints[i - length];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= length - <span class="number">1</span>)</span><br><span class="line">            min = Math.min(min, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绝对差不超过限制的最长连续子数组"><a href="#绝对差不超过限制的最长连续子数组" class="headerlink" title="绝对差不超过限制的最长连续子数组"></a>绝对差不超过限制的最长连续子数组</h2><p><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">LeetCode 1438 绝对差不超过限制的最长连续子数组</a></p><blockquote><p>给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。<br>如果不存在满足条件的子数组，则返回 0 。<br>示例 1：<br>输入：nums = [8,2,4,7], limit = 4<br>输出：2<br>解释：所有子数组如下：<br>[8] 最大绝对差 |8-8| = 0 &lt;= 4.<br>[8,2] 最大绝对差 |8-2| = 6 &gt; 4.<br>[8,2,4] 最大绝对差 |8-2| = 6 &gt; 4.<br>[8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4.<br>[2] 最大绝对差 |2-2| = 0 &lt;= 4.<br>[2,4] 最大绝对差 |2-4| = 2 &lt;= 4.<br>[2,4,7] 最大绝对差 |2-7| = 5 &gt; 4.<br>[4] 最大绝对差 |4-4| = 0 &lt;= 4.<br>[4,7] 最大绝对差 |4-7| = 3 &lt;= 4.<br>[7] 最大绝对差 |7-7| = 0 &lt;= 4.<br>因此，满足题意的最长子数组的长度为 2 。<br>示例 2：<br>输入：nums = [10,1,2,4,7,2], limit = 5<br>输出：4<br>解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。<br>示例 3：<br>输入：nums = [4,2,2,2,4,4,2,2], limit = 0<br>输出：3<br>提示：<br>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i] &lt;= 10^9<br>0 &lt;= limit &lt;= 10^9</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑窗+红黑树 极简解法，时间复杂度O(n*logn)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(); <span class="comment">// 默认升序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">        treeMap.compute(nums[right++], (k, v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (treeMap.lastKey() - treeMap.firstKey() &gt; limit) &#123;</span><br><span class="line">            treeMap.compute(nums[left++], (k, v) -&gt; v == <span class="number">1</span> ? <span class="literal">null</span> : v - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下解法会超时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.naturalOrder());</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length &amp;&amp; left &lt; nums.length) &#123;</span><br><span class="line">        minQueue.add(nums[right]);</span><br><span class="line">        maxQueue.add(nums[right]);</span><br><span class="line">        <span class="keyword">if</span> (maxQueue.peek() - minQueue.peek() &lt;= limit) &#123;</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxQueue.remove((Integer) nums[left]);</span><br><span class="line">        minQueue.remove((Integer) nums[left]);</span><br><span class="line">        left++;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;滑动窗口算法可以将嵌套的循环问题，转换为单循环问题，降低&lt;a href=&quot;https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;spm=1001.2101.3001.702</summary>
      
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>RuoYi</title>
    <link href="https://southernfish.github.io/pages/framwork/ruoyi/"/>
    <id>https://southernfish.github.io/pages/framwork/ruoyi/</id>
    <published>2025-07-31T05:20:36.000Z</published>
    <updated>2025-09-17T07:51:48.703Z</updated>
    
    <content type="html"><![CDATA[<p>若依框架（RuoYi）是一套基于Java开发的快速开发框架，它提供了许多常用的功能模块和工具，包括用户管理、部门管理、角色管理、菜单管理、字典管理、系统监控、定时任务等。若依框架采用了MVC（Model-View-Controller）的架构模式，使用了Spring Boot、MyBatis等流行的开源框架，可以帮助开发者快速搭建企业级的后台管理系统。若依框架还提供了许多可视化的操作界面，使得开发者可以方便地进行系统配置和管理。</p><blockquote><p>官网地址：<a href="https://doc.ruoyi.vip/">若依框架</a></p><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_20143059/article/details/131337812">ruoyi架构那点事</a></p><p><a href="https://blog.csdn.net/2302_76927249/article/details/149039117">若依框架（前后端分离版）</a></p></blockquote><h1 id="若依介绍"><a href="#若依介绍" class="headerlink" title="若依介绍"></a>若依介绍</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>若依（<a href="https://so.csdn.net/so/search?q=RuoYi&spm=1001.2101.3001.7020">RuoYi</a>）是一款基于Spring Boot和MyBatis的Java快速开发框架，主要用于企业级应用系统的开发。它提供了一套完整的后台管理系统解决方案，包括用户权限管理、菜单配置、数据监控等功能，同时支持代码生成器，显著提升开发效率。</p><h2 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h2><ul><li><strong>模块化设计</strong>：前后端分离架构，前端可选Vue2/Vue3版本，后端基于Spring Boot。</li><li><strong>代码生成器</strong>：通过可视化配置自动生成CRUD代码，减少重复劳动。</li><li><strong>权限控制</strong>：基于RBAC（角色基于访问控制）模型，精细化管理菜单、按钮权限。</li><li><strong>多数据源支持</strong>：轻松配置动态数据源，适应复杂业务场景。</li></ul><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li><strong>后端</strong>：Spring Boot、MyBatis、Shiro（安全框架）、Redis（缓存）。</li><li><strong>前端</strong>：Vue.js、Element UI（Vue2版本）或Ant Design Vue（Vue3版本）。</li><li><strong>数据库</strong>：支持MySQL、Oracle、SQL Server等主流数据库</li></ul><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>JDK8 以上，mysql，Redis（<a href="https://www.redis.net.cn/tutorial/3504.html">Redis 配置_redis教程</a>），Maven，Vue</p><h2 id="提供的功能"><a href="#提供的功能" class="headerlink" title="提供的功能"></a>提供的功能</h2><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><p>用户管理：用户是系统操作者，该功能主要完成系统用户配置。<br>部门管理：配置系统组织机构（公司、部门、小组），树结构展现支持数据权限。<br>岗位管理：配置系统用户所属担任职务。<br>菜单管理：配置系统菜单，操作权限，按钮权限标识等。<br>角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。<br>字典管理：对系统中经常使用的一些较为固定的数据进行维护。<br>参数管理：对系统动态配置常用参数。<br>通知公告：系统通知公告信息发布维护。</p><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。<br>登录日志：系统登录日志记录查询包含登录异常。</p><h3 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h3><p>在线用户：当前系统中活跃用户状态监控。<br>服务监控：监视当前系统CPU、内存、磁盘、堆栈等相关信息。<br>缓存监控：对系统的缓存查询，查看、清理等操作。<br>在线构建器：拖动表单元素生成相应的HTML代码。<br>连接池监视：监视当期系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈。</p><h3 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h3><p>定时任务：在线（添加、修改、删除)任务调度包含执行结果日志。<br>代码生成：前后端代码的生成（java、html、xml、sql)支持CRUD下载 。<br>系统接口：根据业务代码自动生成相关的api接口文档。</p><hr><h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis（Remote Dictionary Server）是一个开源的高性能键值存储系统，支持多种数据结构（如字符串、哈希、列表、集合等）。它以内存存储为主，兼具持久化功能，常用于缓存、消息队列、实时数据分析等场景。</p><h2 id="核心特点-1"><a href="#核心特点-1" class="headerlink" title="核心特点"></a>核心特点</h2><p><strong>内存存储</strong>：数据主要存储在内存中，读写速度极快（可达10万次/秒以上）。</p><p><strong>持久化支持</strong>：提供RDB（快照）和AOF（日志）两种方式将数据保存到磁盘。</p><p><strong>数据结构丰富</strong>：支持字符串、哈希、列表、集合、有序集合等，适应不同业务需求。</p><p><strong>高可用性</strong>：通过哨兵（Sentinel）和集群（Cluster）模式实现故障自动转移与横向扩展。</p><h2 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h2><ul><li><strong>缓存加速</strong>：减轻数据库压力，提升网站响应速度。</li><li><strong>会话存储</strong>：分布式系统中共享用户会话信息。</li><li><strong>实时排行榜</strong>：利用有序集合实现分数排序。</li><li><strong>消息队列</strong>：通过列表或Stream结构实现异步任务处理。</li></ul><h2 id="与其他数据库对比"><a href="#与其他数据库对比" class="headerlink" title="与其他数据库对比"></a>与其他数据库对比</h2><ul><li><strong>Redis vs MySQL</strong>：Redis基于内存，适合高速读写；MySQL基于磁盘，适合复杂查询与事务。</li><li><strong>Redis vs Memcached</strong>：Redis支持数据持久化和更多数据结构，Memcached仅支持简单键值且无持久化。</li></ul><p>Redis的灵活性和高性能使其成为现代分布式系统中的重要组件。</p><h1 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h1><p>Nginx（发音为“engine-x”）是一款高性能的开源Web服务器、反向代理服务器、负载均衡器及HTTP缓存工具。最初由俄罗斯开发者Igor Sysoev设计，于2004年首次公开发布，现已成为全球最流行的Web服务器之一。</p><h2 id="Nginx的核心功能"><a href="#Nginx的核心功能" class="headerlink" title="Nginx的核心功能"></a>Nginx的核心功能</h2><p><strong>Web服务器</strong>：Nginx可以高效地处理静态内容（如HTML、CSS、图片），支持高并发连接，资源占用低，适合高流量场景。</p><p><strong>反向代理</strong>：作为反向代理服务器，Nginx可将客户端请求转发至后端多台服务器，隐藏真实服务器信息，提升安全性和可扩展性。</p><p><strong>负载均衡</strong>：支持多种负载均衡算法（如轮询、加权轮询、IP哈希），将流量分配到多台后端服务器，提高系统可用性和性能。</p><p><strong>HTTP缓存</strong>：通过缓存静态或动态内容，减少后端服务器压力，加速响应速度。</p><h2 id="Nginx的特点"><a href="#Nginx的特点" class="headerlink" title="Nginx的特点"></a>Nginx的特点</h2><ul><li><p><strong>事件驱动架构</strong>：基于异步非阻塞模型，支持高并发连接（单机可处理数万并发请求）。</p></li><li><p><strong>模块化设计</strong>：通过模块扩展功能（如支持SSL、gzip压缩、HTTP/2）。</p></li><li><p><strong>低资源消耗</strong>：内存和CPU占用率远低于传统服务器（如Apache）。</p></li><li><p><strong>跨平台</strong>：支持Linux、Windows、macOS等操作系统。</p></li></ul><h2 id="登录验证码流程"><a href="#登录验证码流程" class="headerlink" title="登录验证码流程"></a>登录验证码流程</h2><p>首先通过后端生成一个表达式上传到前端，并且将验证码答案存放在Redis中，用户通过前端登录时将key值和输入答案一起传入数据库。</p><p>登录操作将内容保存在表中 <code>sys_logininfor</code></p><h2 id="进行增删该查操作"><a href="#进行增删该查操作" class="headerlink" title="进行增删该查操作"></a>进行增删该查操作</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801170733602.png" alt="image-20250801170733602"></p><p>单应用在<code>resources</code>目录下的<code>application.yml</code>，多模块<code>ruoyi-generator</code>中的<code>resources</code>目录下的<code>generator.yml</code>，可以自己根据实际情况调整默认配置。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 代码生成</span></span><br><span class="line">gen: </span><br><span class="line">  <span class="meta"># 开发者姓名，生成到类注释上</span></span><br><span class="line">  author: ruoyi</span><br><span class="line">  <span class="meta"># 默认生成包路径 system 需改成自己的模块名称 如 system monitor tool</span></span><br><span class="line">  packageName: com.ruoyi.system</span><br><span class="line">  <span class="meta"># 自动去除表前缀，默认是false</span></span><br><span class="line">  autoRemovePre: <span class="literal">false</span></span><br><span class="line">  <span class="meta"># 表前缀（生成类名不会包含表前缀，多个用逗号分隔）</span></span><br><span class="line">  tablePrefix: sys_</span><br></pre></td></tr></table></figure><h3 id="代码生成使用"><a href="#代码生成使用" class="headerlink" title="代码生成使用"></a>代码生成使用</h3><p>1、登录系统（系统工具 -&gt; 代码生成 -&gt; 导入对应表）</p><p>2、代码生成列表中找到需要表（可预览、编辑、同步、删除生成配置）</p><p>3、点击生成代码会得到一个<code>ruoyi.zip</code>执行<code>sql</code>文件，按照包内目录结构复制到自己的项目中即可</p><p>代码生成支持编辑、预览、同步</p><p>预览：对生成的代码提前预览，防止出现一些不符合预期的情况。</p><p>同步：对原表的字段进行同步，包括新增、删除、修改的字段处理。</p><p>修改：对生成的代码基本信息、字段信息、生成信息做一系列的调整。</p><p>另外多模块所有代码生成的相关业务逻辑代码在<code>ruoyi-generator</code>模块，不需要可以自行删除模块。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="后端部署"><a href="#后端部署" class="headerlink" title="后端部署"></a>后端部署</h4><p>打包工程文件：在工程文件下打开执行bin/package.bat文件进行打包，生成war/jar文件</p><h4 id="前端部署"><a href="#前端部署" class="headerlink" title="前端部署"></a>前端部署</h4><p>当项目开发完毕，只需要运行一行命令就可以打包应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包正式环境</span></span><br><span class="line">npm run build:prod</span><br><span class="line"><span class="comment"># 打包预发布环境</span></span><br><span class="line">npm run build:stage</span><br></pre></td></tr></table></figure><p>构建打包成功之后，会在根目录生成 dist 文件夹，里面就是构建打包好的文件，通常是 <em><strong>.js 、</strong></em>.css、index.html 等静态文件。</p><p>通常情况下 dist 文件夹的静态文件发布到你的 nginx 或者静态服务器即可，其中的 index.html 是后台服务的入口页面。</p><h1 id="快速搭建若依"><a href="#快速搭建若依" class="headerlink" title="快速搭建若依"></a>快速搭建若依</h1><h2 id="前端搭建"><a href="#前端搭建" class="headerlink" title="前端搭建"></a>前端搭建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="后端搭建"><a href="#后端搭建" class="headerlink" title="后端搭建"></a>后端搭建</h2><p>修改数据库和redis的配置。</p><h2 id="代码介绍"><a href="#代码介绍" class="headerlink" title="代码介绍"></a>代码介绍</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801163351287.png" alt="image-20250801163351287"></p><h3 id="ruoyi-quartz"><a href="#ruoyi-quartz" class="headerlink" title="ruoyi-quartz"></a>ruoyi-quartz</h3><p>使用quartz作为定时任务管理，这里不多说，老生常谈的问题。如果想了解可以参考文章：<a href="https://baocl.blog.csdn.net/article/details/106075216">quartz实现定时任务</a></p><h3 id="ruoyi-generator"><a href="#ruoyi-generator" class="headerlink" title="ruoyi-generator"></a>ruoyi-generator</h3><p>该包为代码生成器，主要的流程如下。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801163413997.png" alt="image-20250801163413997"></p><p><strong>GenTableServiceImpl/generatorCode代码生成</strong></p><p>核心代码为该类的方法。主要使用<strong>org.apache.velocity.app</strong>的API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generatorCode</span><span class="params">(String tableName)</span>&#123;</span><br><span class="line">    <span class="comment">// 查询表信息</span></span><br><span class="line">    <span class="type">GenTable</span> <span class="variable">table</span> <span class="operator">=</span> genTableMapper.selectGenTableByName(tableName);</span><br><span class="line">    <span class="comment">// 设置主子表信息</span></span><br><span class="line">    setSubTable(table);</span><br><span class="line">    <span class="comment">// 设置主键列信息</span></span><br><span class="line">    setPkColumn(table);</span><br><span class="line">    VelocityInitializer.initVelocity();</span><br><span class="line">    <span class="type">VelocityContext</span> <span class="variable">context</span> <span class="operator">=</span> VelocityUtils.prepareContext(table);</span><br><span class="line">    <span class="comment">// 获取模板列表</span></span><br><span class="line">    List&lt;String&gt; templates = VelocityUtils.getTemplateList(table.getTplCategory());</span><br><span class="line">    <span class="keyword">for</span> (String template : templates) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.containsAny(template, <span class="string">&quot;sql.vm&quot;</span>, <span class="string">&quot;api.js.vm&quot;</span>, <span class="string">&quot;index.vue.vm&quot;</span>, <span class="string">&quot;index-tree.vue.vm&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// 渲染模板</span></span><br><span class="line">            <span class="type">StringWriter</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">            <span class="type">Template</span> <span class="variable">tpl</span> <span class="operator">=</span> Velocity.getTemplate(template, Constants.UTF8);</span><br><span class="line">            tpl.merge(context, sw);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> getGenPath(table, template);</span><br><span class="line">                FileUtils.writeStringToFile(<span class="keyword">new</span> <span class="title class_">File</span>(path), sw.toString(), CharsetKit.UTF_8);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;渲染模板失败，表名：&quot;</span> + table.getTableName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ruoyi-system"><a href="#ruoyi-system" class="headerlink" title="ruoyi-system"></a>ruoyi-system</h3><p>标准的增删改查方法。没有什么多说的。但是ruoyi项目将controller与service部分隔离开来。</p><h3 id="ruoyi-common"><a href="#ruoyi-common" class="headerlink" title="ruoyi-common"></a>ruoyi-common</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801163603079.png" alt="image-20250801163603079"></p><h4 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h4><p>自定义注解，注解的功能在下方。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801163631130.png" alt="image-20250801163631130"></p><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>获取application.yml中的配置信息，并注入项目bean中。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801163728304.png" alt="image-20250801163728304"></p><h4 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h4><p>为项目提供常量池。</p><h4 id="core"><a href="#core" class="headerlink" title="core"></a>core</h4><p><strong>1.controller</strong>：所有接口层的基类，提供了分页，排序等方法，其他接口类直接继承即可。架构的常用做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseController</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line">    <span class="comment">// 将前台传递过来的日期格式的字符串，自动转化为Date类型</span></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder binder)</span>&#123;</span><br><span class="line">        <span class="comment">// Date 类型转换</span></span><br><span class="line">        binder.registerCustomEditor(Date.class, <span class="keyword">new</span> <span class="title class_">PropertyEditorSupport</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAsText</span><span class="params">(String text)</span>&#123;</span><br><span class="line">                setValue(DateUtils.parseDate(text));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置请求分页数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startPage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PageDomain</span> <span class="variable">pageDomain</span> <span class="operator">=</span> TableSupport.buildPageRequest();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageNum</span> <span class="operator">=</span> pageDomain.getPageNum();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageSize</span> <span class="operator">=</span> pageDomain.getPageSize();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotNull(pageNum) &amp;&amp; StringUtils.isNotNull(pageSize)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">orderBy</span> <span class="operator">=</span> SqlUtil.escapeOrderBySql(pageDomain.getOrderBy());</span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">reasonable</span> <span class="operator">=</span> pageDomain.getReasonable();</span><br><span class="line">            PageHelper.startPage(pageNum, pageSize, orderBy).setReasonable(reasonable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置请求排序数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startOrderBy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PageDomain</span> <span class="variable">pageDomain</span> <span class="operator">=</span> TableSupport.buildPageRequest();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(pageDomain.getOrderBy())) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">orderBy</span> <span class="operator">=</span> SqlUtil.escapeOrderBySql(pageDomain.getOrderBy());</span><br><span class="line">            PageHelper.orderBy(orderBy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 响应请求分页数据</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">protected</span> TableDataInfo <span class="title function_">getDataTable</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">TableDataInfo</span> <span class="variable">rspData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableDataInfo</span>();</span><br><span class="line">        rspData.setCode(HttpStatus.SUCCESS);</span><br><span class="line">        rspData.setMsg(<span class="string">&quot;查询成功&quot;</span>);</span><br><span class="line">        rspData.setRows(list);</span><br><span class="line">        rspData.setTotal(<span class="keyword">new</span> <span class="title class_">PageInfo</span>(list).getTotal());</span><br><span class="line">        <span class="keyword">return</span> rspData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>domain</strong>：权限等架构查询使用的实体类集合，其中<code>BaseEntity、AjaxResult</code>为架构设计经常使用的。BaseEntity需要其他实体类继承，提供了页码、总数等通用字段。AjaxResult是统一返回的实体类，能与前台约定固定的返回格式。<code>&#123;code: message: data&#125;</code>格式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AjaxResult</span> <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;String, Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/** 状态码 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CODE_TAG</span> <span class="operator">=</span> <span class="string">&quot;code&quot;</span>;</span><br><span class="line">    <span class="comment">/** 返回内容 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MSG_TAG</span> <span class="operator">=</span> <span class="string">&quot;msg&quot;</span>;</span><br><span class="line">    <span class="comment">/** 数据对象 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DATA_TAG</span> <span class="operator">=</span> <span class="string">&quot;data&quot;</span>;</span><br><span class="line">    <span class="comment">// 初始化一个新创建的 AjaxResult 对象，使其表示一个空消息。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AjaxResult</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化一个新创建的 AjaxResult 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AjaxResult</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(CODE_TAG, code);</span><br><span class="line">        <span class="built_in">super</span>.put(MSG_TAG, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化一个新创建的 AjaxResult 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AjaxResult</span><span class="params">(<span class="type">int</span> code, String msg, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(CODE_TAG, code);</span><br><span class="line">        <span class="built_in">super</span>.put(MSG_TAG, msg);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotNull(data)) &#123;</span><br><span class="line">            <span class="built_in">super</span>.put(DATA_TAG, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEntity</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/** 搜索值 */</span></span><br><span class="line">    <span class="keyword">private</span> String searchValue;</span><br><span class="line">    <span class="comment">/** 创建者 */</span></span><br><span class="line">    <span class="keyword">private</span> String createBy;</span><br><span class="line">    <span class="comment">/** 创建时间 */</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="comment">/** 更新者 */</span></span><br><span class="line">    <span class="keyword">private</span> String updateBy;</span><br><span class="line">    <span class="comment">/** 更新时间 */</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="comment">/** 备注 */</span></span><br><span class="line">    <span class="keyword">private</span> String remark;</span><br><span class="line">    <span class="comment">/** 请求参数 */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h4><p>封装了一系列的异常，在特定时期使用即可。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801164106581.png" alt="image-20250801164106581"></p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>过滤器，通用写法，如果有使用直接复制即可。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801164146902.png" alt="image-20250801164146902"></p><h4 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h4><p>提供了一大波工具类。如果需要可以直接复制使用。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801164221975.png" alt="image-20250801164221975"></p><h3 id="ruoyi-framework"><a href="#ruoyi-framework" class="headerlink" title="ruoyi-framework"></a>ruoyi-framework</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801164236304.png" alt="image-20250801164236304"></p><h4 id="DataScopeAspect"><a href="#DataScopeAspect" class="headerlink" title="DataScopeAspect"></a>DataScopeAspect</h4><p><strong>1.DataScopeAspect数据权限</strong>：在执行接口时，将当前用户的组织机构等查询条件利用AOP拼接上，可以看到根据在菜单页面维护的数据权限类别进行动态的拼接sql语句。核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dataScopeFilter</span><span class="params">(JoinPoint joinPoint, SysUser user, String deptAlias, String userAlias)</span>&#123;</span><br><span class="line">    <span class="comment">// 拼接sql</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sqlString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (SysRole role : user.getRoles()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dataScope</span> <span class="operator">=</span> role.getDataScope();</span><br><span class="line">        <span class="keyword">if</span> (DATA_SCOPE_ALL.equals(dataScope)) &#123;</span><br><span class="line">            sqlString = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DATA_SCOPE_CUSTOM.equals(dataScope)) &#123; <span class="comment">// 自定义权限拼接</span></span><br><span class="line">            sqlString.append(StringUtils.format(</span><br><span class="line">                <span class="string">&quot; OR &#123;&#125;.dept_id IN ( SELECT dept_id FROM sys_role_dept WHERE role_id = &#123;&#125; ) &quot;</span>,</span><br><span class="line">                deptAlias, role.getRoleId()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DATA_SCOPE_DEPT.equals(dataScope)) &#123; <span class="comment">// 部门权限拼接</span></span><br><span class="line">            sqlString.append(StringUtils.format(<span class="string">&quot; OR &#123;&#125;.dept_id = &#123;&#125; &quot;</span>, deptAlias, user.getDeptId()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DATA_SCOPE_DEPT_AND_CHILD.equals(dataScope)) &#123; <span class="comment">// 部门及以下权限拼接</span></span><br><span class="line">            sqlString.append(StringUtils.format(</span><br><span class="line"><span class="string">&quot; OR &#123;&#125;.dept_id IN ( SELECT dept_id FROM sys_dept WHERE dept_id = &#123;&#125; or find_in_set( &#123;&#125; , ancestors ) )&quot;</span>,</span><br><span class="line">                deptAlias, user.getDeptId(), user.getDeptId()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.DataSourceAspect多数据源</strong>：利用上文DataSource注解动态的切换数据源，如果有需求可以直接使用，固定写法。</p><p><strong>3.LogAspect日志</strong>：全局日志收集，如用户姓名、接口方法、调用ip等，并插入数据库，比较通用功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLog</span><span class="params">(<span class="keyword">final</span> JoinPoint joinPoint, Log controllerLog, </span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> Exception e, Object jsonResult)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前的用户</span></span><br><span class="line">            <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> SecurityUtils.getLoginUser();</span><br><span class="line">            <span class="comment">// *========数据库日志=========*//</span></span><br><span class="line">            <span class="type">SysOperLog</span> <span class="variable">operLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysOperLog</span>();</span><br><span class="line">            operLog.setStatus(BusinessStatus.SUCCESS.ordinal());</span><br><span class="line">            <span class="comment">// 请求的地址</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> IpUtils.getIpAddr(ServletUtils.getRequest());</span><br><span class="line">            operLog.setOperIp(ip);</span><br><span class="line">            operLog.setOperUrl(ServletUtils.getRequest().getRequestURI());</span><br><span class="line">            <span class="comment">//获取用户姓名</span></span><br><span class="line">            <span class="keyword">if</span> (loginUser != <span class="literal">null</span>) &#123;</span><br><span class="line">                operLog.setOperName(loginUser.getUsername());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                operLog.setStatus(BusinessStatus.FAIL.ordinal());</span><br><span class="line">                operLog.setErrorMsg(StringUtils.substring(e.getMessage(), <span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置方法名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">            operLog.setMethod(className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot;()&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置请求方式</span></span><br><span class="line">            operLog.setRequestMethod(ServletUtils.getRequest().getMethod());</span><br><span class="line">            <span class="comment">// 处理设置注解上的参数</span></span><br><span class="line">            getControllerMethodDescription(joinPoint, controllerLog, operLog, jsonResult);</span><br><span class="line">            <span class="comment">// 保存数据库</span></span><br><span class="line">            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exp) &#123;</span><br><span class="line">            <span class="comment">// 记录本地异常日志</span></span><br><span class="line">            log.error(<span class="string">&quot;==前置通知异常==&quot;</span>);</span><br><span class="line">            log.error(<span class="string">&quot;异常信息:&#123;&#125;&quot;</span>, exp.getMessage());</span><br><span class="line">            exp.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RateLimiterAspect限流</strong>：将每一次的调用的ip存放在redis中，然后判断本次调用和上次调用的相隔时间。短时间调用会阻止调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;@annotation(rateLimiter)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint point, RateLimiter rateLimiter)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//redis固定的参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> rateLimiter.key();</span><br><span class="line">    <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> rateLimiter.time();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rateLimiter.count();</span><br><span class="line">    <span class="comment">//获取ip+调用的方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">combineKey</span> <span class="operator">=</span> getCombineKey(rateLimiter, point);</span><br><span class="line">    List&lt;Object&gt; keys = Collections.singletonList(combineKey);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取一定时间内的调用次数</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">number</span> <span class="operator">=</span> redisTemplate.execute(limitScript, keys, count, time);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNull(number) || number.intValue() &gt; count) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;访问过于频繁，请稍候再试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;限制请求&#x27;&#123;&#125;&#x27;,当前请求&#x27;&#123;&#125;&#x27;,缓存key&#x27;&#123;&#125;&#x27;&quot;</span>, count, number.intValue(), key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServiceException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;服务器限流异常，请稍候再试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="config-1"><a href="#config-1" class="headerlink" title="config"></a>config</h4><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801164708417.png" alt="image-20250801164708417"></p><p><strong>1.DruidProperties</strong>：从application.yml中获取数据源信息。固定写法不详细描述。</p><p><strong>2.ApplicationConfig</strong>：配置时区信息这里不详细描述。</p><p><strong>3.CaptchaConfig</strong>：验证码配置，配置文字文本框格式等，固定写法。</p><p><strong>4.DruidConfig</strong>：多数据源配置，固定写法。</p><p><strong>5.FastJson2JsonRedisSerializer</strong>：redis序列化配置，固定写法。</p><p><strong>6.FilterConfig</strong>：过滤器配置，<code>@ConditionalOnProperty(value = &quot;xss.enabled&quot;, havingValue = &quot;true&quot;)</code>根据application.yml是否配置xss.enabled值决定是否加载该类，也就是是否开启xss拦截器。</p><p><strong>7.KaptchaTextCreator</strong>：验证码验证的规则，这里是计算验证码，逻辑在此类中，不详细讲解。</p><p><strong>8.MyBatisConfig</strong>：从application.yml动态获取mybatis包的地址。并重新封装SqlSessionFactory。实现mybatis路径的可配置化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//从application.yml获取配置</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">typeAliasesPackage</span> <span class="operator">=</span> env.getProperty(<span class="string">&quot;mybatis.typeAliasesPackage&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">mapperLocations</span> <span class="operator">=</span> env.getProperty(<span class="string">&quot;mybatis.mapperLocations&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> env.getProperty(<span class="string">&quot;mybatis.configLocation&quot;</span>);</span><br><span class="line">    <span class="comment">//获取实体类的包</span></span><br><span class="line">    typeAliasesPackage = setTypeAliasesPackage(typeAliasesPackage);</span><br><span class="line">    VFS.addImplClass(SpringBootVFS.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">    <span class="comment">//加入数据源</span></span><br><span class="line">    sessionFactory.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">//加入实体类地址</span></span><br><span class="line">    sessionFactory.setTypeAliasesPackage(typeAliasesPackage);</span><br><span class="line">    <span class="comment">//加入mapper</span></span><br><span class="line">    sessionFactory.setMapperLocations(resolveMapperLocations(StringUtils.split(mapperLocations, <span class="string">&quot;,&quot;</span>)));</span><br><span class="line">    <span class="comment">//加入配置文件地址</span></span><br><span class="line">    sessionFactory.setConfigLocation(<span class="keyword">new</span> <span class="title class_">DefaultResourceLoader</span>().getResource(configLocation));</span><br><span class="line">    <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9.RedisConfig</strong>：redis配置固定写法，如果整合redis可以参考。</p><p><strong>10.ResourcesConfig</strong>：通用配置，其中包括拦截器生效配置，跨域配置等 可以直接使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcesConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RepeatSubmitInterceptor repeatSubmitInterceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">/** 本地文件上传路径 */</span></span><br><span class="line">        registry.addResourceHandler(Constants.RESOURCE_PREFIX + <span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;file:&quot;</span> + RuoYiConfig.getProfile() + <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">/** swagger配置 */</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/swagger-ui/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/springfox-swagger-ui/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置拦截器生效</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span>&#123;   <span class="comment">//此处配置了上文点击重复的拦截器</span></span><br><span class="line">        registry.addInterceptor(repeatSubmitInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跨域配置</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        config.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 设置访问源地址</span></span><br><span class="line">        config.addAllowedOriginPattern(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置访问源请求头</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置访问源请求方法</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 有效期 1800秒</span></span><br><span class="line">        config.setMaxAge(<span class="number">1800L</span>);</span><br><span class="line">        <span class="comment">// 添加映射路径，拦截一切请求</span></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">        <span class="comment">// 返回新的CorsFilter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>11.SecurityConfig</strong>：Security的配置，如果想详细了解，请访问博主专栏：<a href="https://blog.csdn.net/qq_20143059/category_11001830.html?spm=1001.2014.3001.5482">Security入门到精通。</a></p><p><strong>12.ServerConfig</strong>：获取请求信息，包括：域名，端口，上下文访问路径</p><p><strong>13.ThreadPoolConfig</strong>：线程池配置，固定配置，其中下文的manager使用了异步线程池。</p><h4 id="datasource"><a href="#datasource" class="headerlink" title="datasource"></a>datasource</h4><p>多数据源固定配置，与DataSourceAspect配合使用。</p><h4 id="interceptor"><a href="#interceptor" class="headerlink" title="interceptor"></a>interceptor</h4><p>主要功能为不允许重复点击，主要实现为将每一次的调用信息组装为key值存放到redis中，每一次调用从redis获取该key数据验证相隔时间，核心代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRepeatSubmit</span><span class="params">(HttpServletRequest request, RepeatSubmit annotation)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">nowParams</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (request <span class="keyword">instanceof</span> RepeatedlyRequestWrapper)&#123;</span><br><span class="line">        <span class="type">RepeatedlyRequestWrapper</span> <span class="variable">repeatedlyRequest</span> <span class="operator">=</span> (RepeatedlyRequestWrapper) request;</span><br><span class="line">        nowParams = HttpHelper.getBodyString(repeatedlyRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// body参数为空，获取Parameter的数据</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(nowParams)) &#123;</span><br><span class="line">        nowParams = JSONObject.toJSONString(request.getParameterMap());</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Object&gt; nowDataMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    nowDataMap.put(REPEAT_PARAMS, nowParams);</span><br><span class="line">    nowDataMap.put(REPEAT_TIME, System.currentTimeMillis());</span><br><span class="line">    <span class="comment">// 请求地址（作为存放cache的key值）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">    <span class="comment">// 唯一值（没有消息头则使用请求地址）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">submitKey</span> <span class="operator">=</span> request.getHeader(header);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(submitKey)) &#123;</span><br><span class="line">        submitKey = url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组装成加入redis的key值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheRepeatKey</span> <span class="operator">=</span> Constants.REPEAT_SUBMIT_KEY + submitKey;</span><br><span class="line">    <span class="comment">//根据key值查询redsi</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sessionObj</span> <span class="operator">=</span> redisCache.getCacheObject(cacheRepeatKey);</span><br><span class="line">    <span class="comment">//如果能够查询到</span></span><br><span class="line">    <span class="keyword">if</span> (sessionObj != <span class="literal">null</span>) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; sessionMap = (Map&lt;String, Object&gt;) sessionObj;</span><br><span class="line">        <span class="keyword">if</span> (sessionMap.containsKey(url)) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; preDataMap = (Map&lt;String, Object&gt;) sessionMap.get(url);</span><br><span class="line">            <span class="comment">// 比对参数，同时比对时间</span></span><br><span class="line">            <span class="keyword">if</span> (compareParams(nowDataMap, preDataMap) </span><br><span class="line">                &amp;&amp; compareTime(nowDataMap, preDataMap, annotation.interval())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Object&gt; cacheMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    cacheMap.put(url, nowDataMap);</span><br><span class="line">    redisCache.setCacheObject(cacheRepeatKey, cacheMap, annotation.interval(), TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h4><p><code>AsyncManager、ShutdownManager</code>为异步工厂提供方法，AsyncFactory为如何使用异步，如果需要使用可以直接在类中参考编写。</p><h4 id="security"><a href="#security" class="headerlink" title="security"></a>security</h4><p><strong>1.JwtAuthenticationTokenFilter</strong>：主要为验证token是否正确，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenService tokenService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                                    HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">                                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 验证用户信息</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> tokenService.getLoginUser(request);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotNull(loginUser) &amp;&amp; StringUtils.isNull(SecurityUtils.getAuthentication()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 刷新token</span></span><br><span class="line">            tokenService.verifyToken(loginUser);</span><br><span class="line">            <span class="comment">// 获取用户权限对象</span></span><br><span class="line">            <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">                <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line">            authenticationToken.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">            <span class="comment">// 将用户权限等信息存放在SecurityContext中</span></span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.AuthenticationEntryPointImpl、LogoutSuccessHandlerImpl</strong>：将调用信息转换为json返回的固定写法。如果有需要可以参考。</p><h4 id="web"><a href="#web" class="headerlink" title="web"></a>web</h4><p><strong>1.server</strong>：获取服务器信息，如cpu等，都是固定写法，如需参考直接复制即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setCpuInfo</span><span class="params">(CentralProcessor processor)</span> &#123;</span><br><span class="line">    <span class="comment">// CPU信息</span></span><br><span class="line">    <span class="type">long</span>[] prevTicks = processor.getSystemCpuLoadTicks();</span><br><span class="line">    Util.sleep(OSHI_WAIT_SECOND);</span><br><span class="line">    <span class="type">long</span>[] ticks = processor.getSystemCpuLoadTicks();</span><br><span class="line">    <span class="type">long</span> <span class="variable">nice</span> <span class="operator">=</span> ticks[TickType.NICE.getIndex()] - prevTicks[TickType.NICE.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">irq</span> <span class="operator">=</span> ticks[TickType.IRQ.getIndex()] - prevTicks[TickType.IRQ.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">softirq</span> <span class="operator">=</span> ticks[TickType.SOFTIRQ.getIndex()] - prevTicks[TickType.SOFTIRQ.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">steal</span> <span class="operator">=</span> ticks[TickType.STEAL.getIndex()] - prevTicks[TickType.STEAL.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">cSys</span> <span class="operator">=</span> ticks[TickType.SYSTEM.getIndex()] - prevTicks[TickType.SYSTEM.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">user</span> <span class="operator">=</span> ticks[TickType.USER.getIndex()] - prevTicks[TickType.USER.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">iowait</span> <span class="operator">=</span> ticks[TickType.IOWAIT.getIndex()] - prevTicks[TickType.IOWAIT.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">idle</span> <span class="operator">=</span> ticks[TickType.IDLE.getIndex()] - prevTicks[TickType.IDLE.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">totalCpu</span> <span class="operator">=</span> user + nice + cSys + idle + iowait + irq + softirq + steal;</span><br><span class="line">    cpu.setCpuNum(processor.getLogicalProcessorCount());</span><br><span class="line">    cpu.setTotal(totalCpu);</span><br><span class="line">    cpu.setSys(cSys);</span><br><span class="line">    cpu.setUsed(user);</span><br><span class="line">    cpu.setWait(iowait);</span><br><span class="line">    cpu.setFree(idle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置内存信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMemInfo</span><span class="params">(GlobalMemory memory)</span> &#123;</span><br><span class="line">    mem.setTotal(memory.getTotal());</span><br><span class="line">    mem.setUsed(memory.getTotal() - memory.getAvailable());</span><br><span class="line">    mem.setFree(memory.getAvailable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.exception</strong>：<code>@RestControllerAdvice、@ExceptionHandler</code>全局的拦截异常，当系统中有异常时，该类会直接获取异常并输出，很多类就不用特意try catch了。架构的常用写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line">    <span class="comment">// 权限校验异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(AccessDeniedException.class)</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">handleAccessDeniedException</span><span class="params">(AccessDeniedException e, HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.error(<span class="string">&quot;请求地址&#x27;&#123;&#125;&#x27;,权限校验失败&#x27;&#123;&#125;&#x27;&quot;</span>, requestURI, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> AjaxResult.error(HttpStatus.FORBIDDEN, <span class="string">&quot;没有权限，请联系管理员授权&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求方式不支持</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(HttpRequestMethodNotSupportedException.class)</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">handleHttpRequestMethodNotSupported</span><span class="params">(HttpRequestMethodNotSupportedException e,</span></span><br><span class="line"><span class="params">            HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.error(<span class="string">&quot;请求地址&#x27;&#123;&#125;&#x27;,不支持&#x27;&#123;&#125;&#x27;请求&quot;</span>, requestURI, e.getMethod());</span><br><span class="line">        <span class="keyword">return</span> AjaxResult.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.service</strong>：权限相关的service。大部分都是curd的业务，这里详细说TokenService。TokenService使用jwt生成token、从token中获取数据等。大部分为jwt固定写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从数据声明生成令牌 @param claims 数据声明 @return 令牌</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">createToken</span><span class="params">(Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">            .setClaims(claims)</span><br><span class="line">            .signWith(SignatureAlgorithm.HS512, secret).compact();</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从令牌中获取数据声明 @param token 令牌 @return 数据声明</span></span><br><span class="line"><span class="keyword">private</span> Claims <span class="title function_">parseToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">            .setSigningKey(secret)</span><br><span class="line">            .parseClaimsJws(token)</span><br><span class="line">            .getBody();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ruoyi-admin"><a href="#ruoyi-admin" class="headerlink" title="ruoyi-admin"></a>ruoyi-admin</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801165556243.png" alt="image-20250801165556243"></p><h4 id="common通用方法"><a href="#common通用方法" class="headerlink" title="common通用方法"></a>common通用方法</h4><p><strong>CaptchaController</strong>：获取验证码通过API生成验证码。详细代码不进行讲解。</p><p><strong>CommonController</strong>：通用的上传下载接口，如果需要直接使用即可。</p><h4 id="monitor监控"><a href="#monitor监控" class="headerlink" title="monitor监控"></a>monitor监控</h4><p><strong>1.CacheController监控redis</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;monitor:cache:list&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping()</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">getInfo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// redis的常用信息</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> (Properties) redisTemplate.execute(</span><br><span class="line">            (RedisCallback&lt;Object&gt;) connection -&gt; connection.info()</span><br><span class="line">        );</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">commandStats</span> <span class="operator">=</span> (Properties) redisTemplate.execute(</span><br><span class="line">            (RedisCallback&lt;Object&gt;) connection -&gt; connection.info(<span class="string">&quot;commandstats&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// rediskey数量</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">dbSize</span> <span class="operator">=</span> redisTemplate.execute((RedisCallback&lt;Object&gt;) connection -&gt; connection.dbSize());</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        result.put(<span class="string">&quot;info&quot;</span>, info);</span><br><span class="line">        result.put(<span class="string">&quot;dbSize&quot;</span>, dbSize);</span><br><span class="line">        <span class="comment">// key的详细信息</span></span><br><span class="line">        List&lt;Map&lt;String, String&gt;&gt; pieList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        commandStats.stringPropertyNames().forEach(key -&gt; &#123;</span><br><span class="line">            Map&lt;String, String&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> commandStats.getProperty(key);</span><br><span class="line">            data.put(<span class="string">&quot;name&quot;</span>, StringUtils.removeStart(key, <span class="string">&quot;cmdstat_&quot;</span>));</span><br><span class="line">            data.put(<span class="string">&quot;value&quot;</span>, StringUtils.substringBetween(property, <span class="string">&quot;calls=&quot;</span>, <span class="string">&quot;,usec&quot;</span>));</span><br><span class="line">            pieList.add(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        result.put(<span class="string">&quot;commandStats&quot;</span>, pieList);</span><br><span class="line">        <span class="keyword">return</span> AjaxResult.success(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.ServerController服务器监控</strong>：主要监控正在运行服务器的信息，核心代码如下，如果需要使用直接复制即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyTo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">SystemInfo</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemInfo</span>();</span><br><span class="line">    <span class="type">HardwareAbstractionLayer</span> <span class="variable">hal</span> <span class="operator">=</span> si.getHardware();</span><br><span class="line">    setCpuInfo(hal.getProcessor());</span><br><span class="line">    setMemInfo(hal.getMemory());</span><br><span class="line">    setSysInfo();</span><br><span class="line">    setJvmInfo();</span><br><span class="line">    setSysFiles(si.getOperatingSystem());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置CPU信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setCpuInfo</span><span class="params">(CentralProcessor processor)</span> &#123;</span><br><span class="line">    <span class="comment">// CPU信息</span></span><br><span class="line">    <span class="type">long</span>[] prevTicks = processor.getSystemCpuLoadTicks();</span><br><span class="line">    Util.sleep(OSHI_WAIT_SECOND);</span><br><span class="line">    <span class="type">long</span>[] ticks = processor.getSystemCpuLoadTicks();</span><br><span class="line">    <span class="type">long</span> <span class="variable">nice</span> <span class="operator">=</span> ticks[TickType.NICE.getIndex()] - prevTicks[TickType.NICE.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">irq</span> <span class="operator">=</span> ticks[TickType.IRQ.getIndex()] - prevTicks[TickType.IRQ.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">softirq</span> <span class="operator">=</span> ticks[TickType.SOFTIRQ.getIndex()] - prevTicks[TickType.SOFTIRQ.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">steal</span> <span class="operator">=</span> ticks[TickType.STEAL.getIndex()] - prevTicks[TickType.STEAL.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">cSys</span> <span class="operator">=</span> ticks[TickType.SYSTEM.getIndex()] - prevTicks[TickType.SYSTEM.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">user</span> <span class="operator">=</span> ticks[TickType.USER.getIndex()] - prevTicks[TickType.USER.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">iowait</span> <span class="operator">=</span> ticks[TickType.IOWAIT.getIndex()] - prevTicks[TickType.IOWAIT.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">idle</span> <span class="operator">=</span> ticks[TickType.IDLE.getIndex()] - prevTicks[TickType.IDLE.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">totalCpu</span> <span class="operator">=</span> user + nice + cSys + idle + iowait + irq + softirq + steal;</span><br><span class="line">    cpu.setCpuNum(processor.getLogicalProcessorCount());</span><br><span class="line">    cpu.setTotal(totalCpu);</span><br><span class="line">    cpu.setSys(cSys);</span><br><span class="line">    cpu.setUsed(user);</span><br><span class="line">    cpu.setWait(iowait);</span><br><span class="line">    cpu.setFree(idle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置内存信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMemInfo</span><span class="params">(GlobalMemory memory)</span> &#123;</span><br><span class="line">    mem.setTotal(memory.getTotal());</span><br><span class="line">    mem.setUsed(memory.getTotal() - memory.getAvailable());</span><br><span class="line">    mem.setFree(memory.getAvailable());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置服务器信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setSysInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> System.getProperties();</span><br><span class="line">    sys.setComputerName(IpUtils.getHostName());</span><br><span class="line">    sys.setComputerIp(IpUtils.getHostIp());</span><br><span class="line">    sys.setOsName(props.getProperty(<span class="string">&quot;os.name&quot;</span>));</span><br><span class="line">    sys.setOsArch(props.getProperty(<span class="string">&quot;os.arch&quot;</span>));</span><br><span class="line">    sys.setUserDir(props.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置Java虚拟机</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setJvmInfo</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> System.getProperties();</span><br><span class="line">    jvm.setTotal(Runtime.getRuntime().totalMemory());</span><br><span class="line">    jvm.setMax(Runtime.getRuntime().maxMemory());</span><br><span class="line">    jvm.setFree(Runtime.getRuntime().freeMemory());</span><br><span class="line">    jvm.setVersion(props.getProperty(<span class="string">&quot;java.version&quot;</span>));</span><br><span class="line">    jvm.setHome(props.getProperty(<span class="string">&quot;java.home&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置磁盘信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setSysFiles</span><span class="params">(OperatingSystem os)</span> &#123;</span><br><span class="line">    <span class="type">FileSystem</span> <span class="variable">fileSystem</span> <span class="operator">=</span> os.getFileSystem();</span><br><span class="line">    List&lt;OSFileStore&gt; fsArray = fileSystem.getFileStores();</span><br><span class="line">    <span class="keyword">for</span> (OSFileStore fs : fsArray)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">free</span> <span class="operator">=</span> fs.getUsableSpace();</span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> fs.getTotalSpace();</span><br><span class="line">        <span class="type">long</span> <span class="variable">used</span> <span class="operator">=</span> total - free;</span><br><span class="line">        <span class="type">SysFile</span> <span class="variable">sysFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysFile</span>();</span><br><span class="line">        sysFile.setDirName(fs.getMount());</span><br><span class="line">        sysFile.setSysTypeName(fs.getType());</span><br><span class="line">        sysFile.setTypeName(fs.getName());</span><br><span class="line">        sysFile.setTotal(convertFileSize(total));</span><br><span class="line">        sysFile.setFree(convertFileSize(free));</span><br><span class="line">        sysFile.setUsed(convertFileSize(used));</span><br><span class="line">        sysFile.setUsage(Arith.mul(Arith.div(used, total, <span class="number">4</span>), <span class="number">100</span>));</span><br><span class="line">        sysFiles.add(sysFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.SysLogininforController，SysOperlogController 登录日志、操作日志</strong>：主要查询前文AOP生成的日志表，普通的增删改查。</p><p><strong>4.SysUserOnlineController在线用户管理</strong>：主要功能为在线用户监控与强踢下线。通过查询和删除redis缓存即可实现。</p><h4 id="system业务代码"><a href="#system业务代码" class="headerlink" title="system业务代码"></a>system业务代码</h4><p>这里都是系统管理业务代码，写法比较统一，但是在编写过程中有部分架构的规定，下面一一说明。</p><p>**1.@PreAuthorize(“@ss.hasPermi(‘system:dict:list’)”)**：权限注解，上文已经详解</p><p><strong>2.AjaxResult</strong>：提供了 结果编码/调用信息/数据的返回格式，为前台提供了统一的返回格式。架构的基础组成部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AjaxResult</span> <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;String, Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/** 状态码 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CODE_TAG</span> <span class="operator">=</span> <span class="string">&quot;code&quot;</span>;</span><br><span class="line">    <span class="comment">/** 返回内容 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MSG_TAG</span> <span class="operator">=</span> <span class="string">&quot;msg&quot;</span>;</span><br><span class="line">    <span class="comment">/** 数据对象 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DATA_TAG</span> <span class="operator">=</span> <span class="string">&quot;data&quot;</span>;</span><br><span class="line">    <span class="comment">// 初始化一个新创建的 AjaxResult 对象，使其表示一个空消息。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AjaxResult</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 初始化一个新创建的 AjaxResult 对象 @param code 状态码 @param msg 返回内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AjaxResult</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(CODE_TAG, code);</span><br><span class="line">        <span class="built_in">super</span>.put(MSG_TAG, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化一个新创建的 AjaxResult 对象 @param code 状态码 @param msg 返回内容 @param data 数据对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AjaxResult</span><span class="params">(<span class="type">int</span> code, String msg, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(CODE_TAG, code);</span><br><span class="line">        <span class="built_in">super</span>.put(MSG_TAG, msg);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotNull(data)) &#123;</span><br><span class="line">            <span class="built_in">super</span>.put(DATA_TAG, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回成功消息 @return 成功消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AjaxResult <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AjaxResult.success(<span class="string">&quot;操作成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.extends BaseController</strong>：上文介绍了<code>BaseController</code>，在这里使用就可以直接调用分页、排序等方法了。不用每个类都编写。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ruoyi框架搭建方便，依赖组件非常少。同时提供了基本的业务功能，如用户管理、部门管理、代码生成器等，但是对于技术的深度还是不太到位，如mq的使用，安全框架等技术都没有特多的涉及。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;若依框架（RuoYi）是一套基于Java开发的快速开发框架，它提供了许多常用的功能模块和工具，包括用户管理、部门管理、角色管理、菜单管理、字典管理、系统监控、定时任务等。若依框架采用了MVC（Model-View-Controller）的架构模式，使用了Spring Boo</summary>
      
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    
    <category term="RuoYi" scheme="https://southernfish.github.io/tags/RuoYi/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis-Plus</title>
    <link href="https://southernfish.github.io/pages/framwork/mybatis-plus/"/>
    <id>https://southernfish.github.io/pages/framwork/mybatis-plus/</id>
    <published>2025-07-30T05:20:36.000Z</published>
    <updated>2025-09-17T07:51:48.702Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis-Plus和MyBatis是共生的，而非替代品。MyBatis-Plus只做增强不做改变，引入它不会对现有工程产生影响。其会在启动时自动注入基本CRUD(增删改查)，性能基本无损耗，直接面向对象操作，使得开发人员能够更加方便地进行数据库操作。</p><blockquote><p>官网地址：<a href="https://baomidou.com/">Mybatis-Plus</a></p><p>参考文章：<a href="https://blog.csdn.net/NingMaoKing/article/details/147305430">Mybtis和Mybatis-Plus区别</a>、<a href="https://blog.csdn.net/qq_40991313/article/details/126470047">MyBatisPlus基础</a></p><p>推荐文章：<a href="https://blog.csdn.net/a370300020/article/details/112461506">MyBatis Plus 讲解</a></p></blockquote><h1 id="Mybatis-Plus-简介"><a href="#Mybatis-Plus-简介" class="headerlink" title="Mybatis-Plus 简介"></a>Mybatis-Plus 简介</h1><h2 id="MP架构"><a href="#MP架构" class="headerlink" title="MP架构"></a>MP架构</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250731220225906.png" alt="image-20250731220225906"></p><h2 id="MP的特性"><a href="#MP的特性" class="headerlink" title="MP的特性"></a>MP的特性</h2><ul><li><strong>无侵入：只做增强不做改变</strong>，不会对现有工程产生影响</li><li><strong>强大的 CRUD 操作：</strong>内置通用 Mapper，少量配置即可实现单表CRUD 操作</li><li>支持 Lambda：编写查询条件无需担心字段写错</li><li><strong>支持主键五种自动生成策略</strong></li><li><strong>内置分页插件、代码生成器、全局拦截插件、sql注入剥离器</strong>（支持sql注入剥离，防止SQL注入攻击）</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li><p><strong>导入mybatis-plus-boot-starter依赖</strong>，dao继承BaseMapper&lt;实体类名&gt;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>说明:</strong></p><ul><li>druid数据源可以加也可以不加，SpringBoot有内置的数据源，可以配置成使用Druid数据源</li><li>从MP的依赖关系可以看出，通过依赖传递已经<strong>将MyBatis与MyBatis整合Spring的jar包导入，我们不需要额外在添加MyBatis的相关jar包</strong></li></ul></blockquote></li><li><p><strong>加MP的相关配置信息</strong></p><p>resources默认生成的是properties配置文件，可以将其<strong>替换成yml文件</strong>，并在文件中配置<strong>数据库连接的相关信息</strong>:<code>application.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment">#serverTimezone是用来设置时区，UTC是标准时区，和咱们的时间差8小时，所以可以将其修改为Asia/Shanghai</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC</span> </span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：如果需要导入druid专有属性，就必须换依赖和配置方法了：</strong>pom.xml</p><p>导入了druid-spring-boot-starter依赖，就<strong>不用再导入druid依赖了</strong>，它里面包含了与druid相关的配置超过200条以上</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"> <span class="attr">druid:</span></span><br><span class="line">   <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">   <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">   <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">   <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>mp在实体类的注解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注解了lombok的@Data会自动生成getter,setter,toString方法</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">// 一般数据库表名tbl_user，这里注解@TableName(&quot;tbl_user&quot;)，就可以对应上表名</span></span><br><span class="line"><span class="comment">// 毕竟mp的语句里没有指定表名，都是在数据库中搜索和首字母小的的实体类名对应的表的。</span></span><br><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 设置主键自增策略为auto，mp默认自增策略是ASSIGN_ID，分布式、雪花算法。自增策略也可以在yml中全局配置。</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// value属性起别名，select设置该字段是否参与查询，针对于一些密码等隐私数据不希望被查出来</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;password&quot;,select = false)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String tel;</span><br><span class="line">    <span class="comment">// exist属性设置是否在数据库中存在该字段</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String online;</span><br><span class="line">    <span class="comment">// 乐观锁注解版本，需要搭配乐观拦截器</span></span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">    <span class="comment">// 逻辑删除，本质是更新，数据库内该字段默认是0，通过标记为1来判定删除。</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer delete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Lombok常见的注解有</strong>:</p><p><code>@Setter</code>：为模型类的属性提供setter方法<br><code>@Getter</code>：为模型类的属性提供getter方法<br><code>@ToString</code>：为模型类的属性提供toString方法<br><code>@EqualsAndHashCode</code>：为模型类的属性提供equals和hashcode方法<br><code>@Data</code>：是个组合注解，包含Setter、Getter、ToString、EqualsAndHashCode<br><code>@NoArgsConstructor</code>：提供一个无参构造函数<br><code>@AllArgsConstructor</code>：提供一个包含所有参数的构造函数</p></li><li><p>**创建Dao接口，继承 基础mapper：BaseMapper<User>**。继承之后dao类多出了很多方法如selectById……</p></li><li><p><strong>编写引导类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//@MapperScan(&quot;com.itheima.dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mybatisplus01QuickstartApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Mybatisplus01QuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Dao接口要想被容器扫描到，有两种解决方案:</p><ol><li>在Dao接口上添加@Mapper注解，并且确保Dao处在引导类所在包或其子包中。需要在每一Dao接口中添加注解</li><li>在引导类上添加@MapperScan注解，其属性为所要扫描的Dao所在包。只需要写一次，则指定包下的所有Dao接口都能被扫描到，@Mapper就可以不写。</li></ol></blockquote></li></ol><p><strong>userDao注入的时候下面有红线提示的原因是什么?</strong></p><p>UserDao是一个接口，不能实例化对象，只有在服务器启动IOC容器初始化后，由框架创建DAO接口的代理对象来注入。服务器并未启动，代理对象也未创建，IDEA查找不到对应的对象注入就会提示报红。一旦服务启动，就能注入其代理对象，故该提示不影响正常运行。</p><p>跟之前整合MyBatis相比，<strong>不需要在DAO接口中编写方法和SQL语句了，只需要继承<code>BaseMapper</code>接口即可。</strong>整体来说简化很多。</p><hr><h1 id="DQL编程控制"><a href="#DQL编程控制" class="headerlink" title="DQL编程控制"></a>DQL编程控制</h1><h2 id="条件查询的Wrapper包装器类"><a href="#条件查询的Wrapper包装器类" class="headerlink" title="条件查询的Wrapper包装器类"></a>条件查询的Wrapper包装器类</h2><p>MyBatisPlus将书写复杂的SQL查询条件进行了封装，使用编程的形式完成查询条件的组合。<strong>包装器Wrapper<T>是接口</strong>，实际开发中主要使用它的两个实现类：<strong>QueryWrapper和LambdaQueryWrapper</strong>。两种方式各有优劣：</p><ul><li><strong>QueryWrapper存在属性名写错的危险，但是支持聚合、分组查询；</strong></li><li><strong>LambdaQueryWrapper没有属性名写错的危险，但不支持聚合、分组查询；</strong></li></ul><h2 id="基本比较操作"><a href="#基本比较操作" class="headerlink" title="基本比较操作"></a>基本比较操作</h2><table><thead><tr><th>方法</th><th>说明</th><th>方法</th><th>说明</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>eq</td><td>等于 =</td><td>ge</td><td>大于等于 &gt;=</td><td>notBetween</td><td>NOT BETWEEN 值1 AND 值2</td></tr><tr><td>alleq</td><td>全部<a href="https://www.baomidou.com/pages/10c804/#eq">eq</a>(或个别<a href="https://www.baomidou.com/pages/10c804/#isnull">isNull</a>)</td><td>It</td><td>小于 &lt;</td><td>in</td><td>字段 IN (value.get(0), value.get(1), …)**</td></tr><tr><td>ne</td><td>不等于 &lt;&gt;</td><td>le</td><td>小于等于 &lt;=</td><td>notIn</td><td>字段 NOT IN (v0, v1, …)</td></tr><tr><td>gt</td><td>大于 &gt;</td><td>between</td><td>BETWEEN 值1 AND 值2</td><td></td><td></td></tr></tbody></table><h2 id="构建条件查询"><a href="#构建条件查询" class="headerlink" title="构建条件查询"></a>构建条件查询</h2><ol><li><p>查询包装器QueryWrapper（不建议）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建QueryWrapper对象</span></span><br><span class="line"><span class="type">QueryWrapper</span> <span class="variable">qw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line"><span class="comment">//lt代表小于，大于是gt</span></span><br><span class="line">qw.lt(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>); <span class="comment">// 属性名写错就错了</span></span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(qw);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,password,age,tel <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> (age <span class="operator">&lt;</span> ?)</span><br></pre></td></tr></table></figure></li><li><p>QueryWrapper的基础上使用lambda（不建议）。可以<strong>防止数据库属性名写错</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda，QueryWrapper&lt;User&gt;必须加泛型</span></span><br><span class="line">QueryWrapper&lt;User&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">qw.lambda().lt(User::getAge, <span class="number">10</span>);<span class="comment">// 添加条件，使用Lambda不容易写错属性名</span></span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(qw);</span><br></pre></td></tr></table></figure><p>User::getAget,为lambda表达式中的，类名::方法名，最终的sql语句为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,password,age,tel <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> (age <span class="operator">&lt;</span> ?)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>构建LambdaQueryWrapper的时候泛型不能省。</p></li><li><p><strong>LambdaQueryWrapper（推荐）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">lqw.lt(User::getAge, <span class="number">30</span>);</span><br><span class="line">lqw.gt(User::getAge, <span class="number">10</span>);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,password,age,tel <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> (age <span class="operator">&lt;</span> ? <span class="keyword">AND</span> age <span class="operator">&gt;</span> ?)</span><br></pre></td></tr></table></figure></li></ol><h2 id="多条件构建，链式编程"><a href="#多条件构建，链式编程" class="headerlink" title="多条件构建，链式编程"></a>多条件构建，链式编程</h2><p>构建多条件的时候，可以支持<strong>链式编程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line"><span class="comment">// 多条件查询默认是and，or要用.or() </span></span><br><span class="line">lqw.lt(User::getAge, <span class="number">30</span>).gt(User::getAge, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// lqw.lt(User::getAge, 30).or().gt(User::getAge, 10);</span></span><br><span class="line"><span class="comment">// SELECT id,name,password,age,tel FROM user WHERE (age &lt; ? OR age &gt; ?)</span></span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure><h2 id="条件查询null值处理"><a href="#条件查询null值处理" class="headerlink" title="条件查询null值处理"></a>条件查询null值处理</h2><p><strong>针对问题</strong>：区间条件查询，例如某宝筛选价格范围，用户只填最高价，最低价为null不算在查询条件里。 </p><p><strong>解决办法</strong>：新建实体类继承原实体类，多出属性范围，使用<code>lqw.lt(null!=uq.getAge2(),User::getAge, uq.getAge2());</code>判定。</p><p><strong>后台如果想接收前端的两个数据，该如何接收?</strong></p><p>一般使用的参数类只有一个age属性，接收页面上的两个值有两个解决方案：</p><ol><li><p><strong>添加属性age2</strong>,这种做法可以但是会影响到原模型类的属性内容（不推荐）</p></li><li><p><strong>在domain.query下新建一个模型类继承User类</strong>，并为其添加age2属性，UserQuery在拥有User属性和age2属性。（推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟页面传递过来的查询数据</span></span><br><span class="line"><span class="type">UserQuery</span> <span class="variable">uq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserQuery</span>();</span><br><span class="line">uq.setAge(<span class="number">10</span>);</span><br><span class="line">uq.setAge2(<span class="number">30</span>);</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line"><span class="comment">// lt(boolean condition, SFunction&lt;User,?&gt;column, Object val)</span></span><br><span class="line"><span class="comment">// 第一个参数为判断条件condition为boolean类型，返回true，则添加条件，返回false则不添加条件</span></span><br><span class="line">lqw.lt(<span class="literal">null</span>!=uq.getAge2(), User::getAge, uq.getAge2());</span><br><span class="line">lqw.gt(<span class="literal">null</span>!=uq.getAge(), User::getAge, uq.getAge());</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br></pre></td></tr></table></figure></li></ol><h2 id="查询投影"><a href="#查询投影" class="headerlink" title="查询投影"></a>查询投影</h2><h3 id="查询指定字段"><a href="#查询指定字段" class="headerlink" title="查询指定字段"></a>查询指定字段</h3><p><strong>查询投影：</strong>不查询所有字段，**只查询出指定字段的数据。查询指定字段lqw.select()**。</p><ol><li><p><strong>使用Lambda（推荐）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">lqw.select(User::getId,User::getName,User::getAge);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br></pre></td></tr></table></figure><p>select(…)方法用来设置查询的字段列，可以设置多个，最终的sql语句为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,age <span class="keyword">FROM</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure></li><li><p>不用Lambda（不推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">lqw.select(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;tel&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,age,tel <span class="keyword">FROM</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><p><strong>聚合查询不能用Lambda，只能用QueryWrapper。方法qw.select(“count(*) as count”);和userDao.selectMaps(qw)</strong></p><blockquote><p>聚合函数查询</p><p>count：总记录数，max：最大值，min：最小值，avg：平均值，sum：求和</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line"><span class="comment">//lqw.select(&quot;count(*) as count&quot;);</span></span><br><span class="line"><span class="comment">//SELECT count(*) as count FROM user</span></span><br><span class="line"><span class="comment">//lqw.select(&quot;max(age) as maxAge&quot;);</span></span><br><span class="line"><span class="comment">//SELECT max(age) as maxAge FROM user</span></span><br><span class="line"><span class="comment">//lqw.select(&quot;min(age) as minAge&quot;);</span></span><br><span class="line"><span class="comment">//SELECT min(age) as minAge FROM user</span></span><br><span class="line"><span class="comment">//lqw.select(&quot;sum(age) as sumAge&quot;);</span></span><br><span class="line"><span class="comment">//SELECT sum(age) as sumAge FROM user</span></span><br><span class="line">lqw.select(<span class="string">&quot;avg(age) as avgAge&quot;</span>);</span><br><span class="line"><span class="comment">//SELECT avg(age) as avgAge FROM user</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; userList = userDao.selectMaps(lqw);</span><br></pre></td></tr></table></figure><h3 id="分组查询-group-by"><a href="#分组查询-group-by" class="headerlink" title="分组查询(group by)"></a>分组查询(group by)</h3><blockquote><p><strong>注意：分组查询一定是要配合聚合函数的</strong></p><ul><li>聚合与分组查询，无法使用lambda表达式来完成</li><li>MP只是对MyBatis的增强，<strong>如果MP实现不了，可以直接在DAO接口中使用MyBatis的方式实现</strong></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">lqw.select(<span class="string">&quot;count(*) as count,tel&quot;</span>);</span><br><span class="line">lqw.groupBy(<span class="string">&quot;tel&quot;</span>);</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; list = userDao.selectMaps(lqw);</span><br></pre></td></tr></table></figure><p>groupBy为分组，最终的sql语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> count,tel <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> tel</span><br></pre></td></tr></table></figure><h2 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h2><p>除了 lt() 和 gt() 这两个方法外，MP的查询条件有很多，使用方法参见<a href="https://baomidou.com/guides/wrapper/">条件构造器</a></p><ul><li>等值匹配（eq）：<strong>eq()： equal的缩小，相当于 <code>=</code></strong></li><li>范围匹配（&gt; 、 = 、between）</li><li>模糊匹配（like）:<ul><li><strong>like()：前后加百分号</strong>，如 %J%</li><li><strong>likeLeft()：左边加百分号</strong>，如 %J</li><li>likeRight()：后面加百分号，如 J%</li></ul></li><li>空判定（null）</li><li>包含性匹配（in）</li><li>分组（group）</li><li>排序（order）<ul><li><strong>orderBy排序</strong><ul><li>condition:条件，true则添加排序，false则不添加排序</li><li>isAsc:是否为升序，true升序，false降序</li><li>columns:排序字段，可以有多个</li></ul></li><li>**orderByAsc/Desc(单个column):**按照指定字段进行升序/降序</li><li>**orderByAsc/Desc(多个column):**按照多个字段进行升序/降序</li><li><strong>orderByAsc/Desc</strong><ul><li>condition:条件，true添加排序，false不添加排序</li><li>多个columns：按照多个字段进行排序</li></ul></li></ul></li></ul><p>MP的查询结果形式：</p><ul><li><strong>selectList：</strong>查询结果为多个或者单个</li><li>**selectOne:**查询结果为单个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.等值查询</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">lqw.eq(User::getName, <span class="string">&quot;Jerry&quot;</span>).eq(User::getPassword, <span class="string">&quot;jerry&quot;</span>);</span><br><span class="line"><span class="comment">// SELECT id,name,password,age,tel FROM user WHERE (name = ? AND password = ?)</span></span><br><span class="line"><span class="type">User</span> <span class="variable">loginUser</span> <span class="operator">=</span> userDao.selectOne(lqw);</span><br><span class="line"><span class="comment">// 2.范围查询</span></span><br><span class="line">lqw.between(User::getAge, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">// SELECT id,name,password,age,tel FROM user WHERE (age BETWEEN ? AND ?)</span></span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line"><span class="comment">// 3.模糊查询</span></span><br><span class="line">lqw.likeLeft(User::getName, <span class="string">&quot;J&quot;</span>);</span><br><span class="line"><span class="comment">// SELECT id,name,password,age,tel FROM user WHERE (name LIKE ?)</span></span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line"><span class="comment">// 4.排序查询</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * condition ：条件，返回boolean，当condition为true，进行排序，如果为false，则不排序</span></span><br><span class="line"><span class="comment"> * isAsc:是否为升序，true为升序，false为降序</span></span><br><span class="line"><span class="comment"> * columns：需要操作的列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">lwq.orderBy(<span class="literal">true</span>,<span class="literal">false</span>, User::getId);</span><br><span class="line">userDao.selectList(lwq);</span><br></pre></td></tr></table></figure><h2 id="映射匹配兼容性"><a href="#映射匹配兼容性" class="headerlink" title="映射匹配兼容性"></a>映射匹配兼容性</h2><p>属性起别名、可见性、权限、表明和实体类名不匹配。</p><p><strong>问题1:表字段与编码属性设计不同步</strong></p><p>表的列名和模型类的属性名发生不一致，就会导致数据封装不到模型对象</p><p><strong>解决：<code>@TableField字段注解</code>里的value属性起别名</strong></p><p><strong>问题2:编码中添加了数据库中未定义的属性</strong></p><p>当模型类中多了一个数据库表不存在的字段，就会导致生成的sql语句中在select的时候查询了数据库不存在的字段，程序运行就会报错，错误信息为：Unknown column ‘多出来的字段名称’ in ‘field list’</p><p><strong>解决：<code>@TableField</code>注解里的exist属性设置其是否在数据库存在</strong>，设置为false则不存在，生成sql查询时，不会再查询该字段。</p><p><strong>问题3：采用默认查询开放了更多的字段查看权限</strong></p><p>查询表中所有的列的数据时可能把敏感数据查询到返回给前端，这时候就需要限制哪些字段默认不要进行查询。</p><p><strong>解决：<code>@TableField</code>注解里的select属性，设置属性是否参与查询</strong>，该属性设置默认是否需要查询该字段的值，true(默认值)表示默认查询该字段，false表示默认不查询该字段。</p><p><strong>问题4:表名与编码开发设计不同步</strong></p><p>表的名称和模型类的名称不一致，导致查询失败，因为mybatisplus的语句中没有表名，不像sql能select * form xxx，只能根据实体类名和表明匹配。这个时候通常会报如下错误信息：<strong>Table ‘databaseName.tableNaem’ doesn’t exist</strong>，译为数据库中的表不存在。</p><p><strong>解决方案一：</strong>是使用MP提供的另外一个<strong>注解<code>@TableName</code>来设置表与模型类之间的对应关系。</strong></p><p>解决方法二：配置统一给实体类名加前缀：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">        <span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br></pre></td></tr></table></figure><h3 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a>@TableField</h3><table><thead><tr><th align="left">名称</th><th align="left">@TableField</th></tr></thead><tbody><tr><td align="left">类型</td><td align="left"><strong>属性注解</strong></td></tr><tr><td align="left">位置</td><td align="left">模型类属性定义上方</td></tr><tr><td align="left">作用</td><td align="left">设置当前属性对应的数据库表中的字段关系</td></tr><tr><td align="left">相关属性</td><td align="left">value(默认)：设置数据库表字段名称<br/>exist:设置属性在数据库表字段中是否存在，默认为true，此属性不能与value合并使用<br/>select:设置属性是否参与查询，此属性与select()映射配置不冲突</td></tr></tbody></table><h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><table><thead><tr><th align="left">名称</th><th align="left">@TableName</th></tr></thead><tbody><tr><td align="left">类型</td><td align="left"><strong>类注解</strong></td></tr><tr><td align="left">位置</td><td align="left">模型类定义上方</td></tr><tr><td align="left">作用</td><td align="left">设置当前类对应于数据库表关系</td></tr><tr><td align="left">相关属性</td><td align="left">value(默认)：设置数据库表名称</td></tr></tbody></table><hr><h1 id="DML编程控制"><a href="#DML编程控制" class="headerlink" title="DML编程控制"></a>DML编程控制</h1><h2 id="id生成策略控制"><a href="#id生成策略控制" class="headerlink" title="id生成策略控制"></a>id生成策略控制</h2><p>前面我们在新增的时候留了一个问题，就是新增成功后，<strong>主键ID是一个很长串的内容</strong>，我们更想要的是按照数据库表字段进行自增长。</p><p><strong>ID该如何选择:</strong></p><ul><li><strong>不同的表应用不同的id生成策略</strong><ul><li>日志：自增（1,2,3,4，……）</li><li>购物订单：特殊规则（FQ23948AK3843）</li><li>外卖单：关联地区日期等信息（10 04 20200314 34 91）</li><li>关系表：可省略id</li></ul></li></ul><h3 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h3><table><thead><tr><th align="left">名称</th><th align="left">@TableId</th></tr></thead><tbody><tr><td align="left">类型</td><td align="left"><strong>属性注解</strong></td></tr><tr><td align="left">位置</td><td align="left">模型类中用于表示主键的属性定义上方</td></tr><tr><td align="left">作用</td><td align="left">设置当前类中主键属性的生成策略</td></tr><tr><td align="left">相关属性</td><td align="left"><strong>value(默认)：设置数据库表主键名称 type:设置主键属性的生成策略，值查照IdType的枚举值</strong></td></tr></tbody></table><h3 id="五种id策略代码实现"><a href="#五种id策略代码实现" class="headerlink" title="五种id策略代码实现"></a>五种id策略代码实现</h3><p><strong>概述：</strong> </p><ul><li><p><strong>AUTO策略：数据库默认自增策略</strong></p></li><li><p><strong>NONE: 不设置id生成策略</strong></p></li><li><p><strong>INPUT：用户手工输入id</strong>，如果id为null会报错</p></li><li><p>**ASSIGN_ID:雪花算法生成id(可兼容数值型与字符串型)**，mp默认id策略</p></li><li><p><strong>ASSIGN_UUID:以UUID生成算法作为id生成策略</strong></p></li><li><p><strong>其他的几个策略均已过时，都将被ASSIGN_ID和ASSIGN_UUID代替掉。</strong></p></li></ul><blockquote><p><strong>注意：除了INPUT策略，其他策略即使指定id为null会自动生成，不为null会用指定的id。</strong></p><p><strong>分布式ID是什么?</strong></p><ul><li>当数据量足够大的时候，一台数据库服务器存储不下，这个时候就需要<strong>多台数据库服务器进行存储</strong></li><li>比如订单表就有可能被存储在不同的服务器上</li><li><strong>如果用数据库表的自增主键，因为在两台服务器上所以会出现冲突</strong></li><li>这个时候就需要一个<strong>全局唯一ID,这个ID就是分布式ID。</strong></li></ul></blockquote><ol><li><p><strong>AUTO策略：数据库默认自增策略</strong>，使用该策略的时候一定要确保对应的数据库表设置了ID主键自增，否则无效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.AUTO)</span> <span class="comment">// 给实体类id属性，设置生成策略为AUTO</span></span><br></pre></td></tr></table></figure></li><li><p><strong>设置生成策略为INPUT</strong>，这种ID生成策略，需要将表的自增策略删除掉，添加数据手动设置ID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.INPUT)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="comment">// 使用 设置主键ID的值</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">666L</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>设置生成策略为ASSIGN_ID</strong>，这种生成策略，不需要手动设置ID，如果手动设置ID，则会使用自己设置的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.ASSIGN_ID)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>设置生成策略为ASSIGN_UUID</strong>，主键的类型应该改成String，表字段类型设置为varchar，长度要大于32，因为UUID生成的主键为32位，如果长度小的话就会导致插入失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure><p>雪花算法(SnowFlake)，是Twitter官方给出的算法实现 是用Scala写的。其生成的结果是一个64bit大小整数，它的结构如下图:</p><ul><li>1bit，不用，因为二进制中最高位是符号位，1表示负数，<strong>0表示正数</strong>。生成的id一般都是用整数，所以<strong>最高位固定为0</strong>。</li><li>41bit-<strong>时间戳</strong>，用来记录时间戳，毫秒级</li><li>10bit-<strong>工作机器id</strong>，用来记录工作机器id,其中高位5bit是数据中心ID其取值范围0-31，低位5bit是工作节点ID其取值范围0-31，两个组合起来最多可以容纳1024个节点</li><li><strong>序列号</strong>占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID</li></ul></li></ol><h3 id="ID生成策略对比"><a href="#ID生成策略对比" class="headerlink" title="ID生成策略对比"></a>ID生成策略对比</h3><ul><li><strong>NONE: 不设置id生成策略</strong>，MP不自动生成，<strong>约等于INPUT</strong>,所以这两种方式都<strong>需要用户手动设置</strong>，但是手动设置第一个问题是容易出现相同的ID造成主键冲突，为了保证主键不冲突就需要做很多判定，实现起来比较复杂</li><li>**AUTO:**数据库ID自增,这种策略适合在数据库服务器只有1台的情况下使用,不可作为分布式ID使用</li><li><strong>ASSIGN_UUID:<strong>可以在</strong>分布式的情况下使用</strong>，而且能够<strong>保证唯一</strong>，但是生成的主键是<strong>32位的字符串，长度过长占用空间而且还不能排序，查询性能也慢</strong></li><li><strong>ASSIGN_ID:<strong>可以在</strong>分布式</strong>的情况下使用，生成的是<strong>Long类型的数字</strong>，可以<strong>排序性能也高</strong>，但是<strong>生成的策略和服务器时间有关，如果修改了系统时间就有可能导致出现重复主键</strong></li></ul><h3 id="配置方法设置id策略和实体类前缀tbl"><a href="#配置方法设置id策略和实体类前缀tbl" class="headerlink" title="配置方法设置id策略和实体类前缀tbl_"></a>配置方法设置id策略和实体类前缀tbl_</h3><p><strong>模型类主键策略设置</strong></p><p>但是如果要在项目中的每一个模型类上都需要使用相同的生成策略，只需要在配置文件中添加如下内容，就能让所有的模型类都可以使用该主键ID策略：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">        <span class="attr">id-type:</span> <span class="string">assign_id</span></span><br></pre></td></tr></table></figure><p><strong>配置方法设置数据库表与模型类的映射关系</strong></p><p><strong>MP会默认将模型类的类名名首字母小写作为表名使用</strong>，假如数据库表的名称都以<code>tbl_</code>开头，那么我们就需要将所有的模型类上添加**<code>@TableName</code>**，简化方式为在配置文件中配置如下内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">        <span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br></pre></td></tr></table></figure><h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><p>根据传入的ID集合批量操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br></pre></td></tr></table></figure><h2 id="逻辑删除，-TableLogic"><a href="#逻辑删除，-TableLogic" class="headerlink" title="逻辑删除，@TableLogic"></a>逻辑删除，@TableLogic</h2><ul><li><strong>物理删除：</strong>业务数据从数据库中丢弃，执行的是delete操作。</li><li><strong>逻辑删除：</strong>为数据设置是否可用状态字段<strong>，</strong>删除时设置状态字段为不可用状态，数据保留在数据库中，执行的是update操作。</li></ul><ol><li><p><strong>修改数据库表添加<code>deleted</code>列</strong></p></li><li><p><strong>实体类设置逻辑删除成员</strong></p><ol><li><p><strong>单个实体类注解<code>@TableLogic</code></strong></p><p>标识新增的字段为逻辑删除字段，使用<strong>注解<code>@TableLogic，value属性是默认值，delval是删除后修改的值</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic(value=&quot;0&quot;,delval=&quot;1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure></li><li><p><strong>yml全局配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">       <span class="comment">#逻辑删除字段名</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span></span><br><span class="line">       <span class="comment">#逻辑删除字面值：未删除为0</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br><span class="line">       <span class="comment">#逻辑删除字面值：删除为1</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>执行查询操作默认给sql语句后面加where deleted=0</strong></p><p>MP的逻辑删除会将所有的查询都添加一个未被删除的条件，也就是已经被删除的数据是不应该被查询出来的。</p></li></ol><h3 id="TableLogic"><a href="#TableLogic" class="headerlink" title="@TableLogic"></a>@TableLogic</h3><table><thead><tr><th align="left">名称</th><th align="left">@TableLogic</th></tr></thead><tbody><tr><td align="left">类型</td><td align="left"><strong>属性注解</strong></td></tr><tr><td align="left">位置</td><td align="left">模型类中用于表示删除字段的属性定义上方</td></tr><tr><td align="left">作用</td><td align="left">标识该字段为进行逻辑删除的字段</td></tr><tr><td align="left">相关属性</td><td align="left">value：逻辑未删除值<br/>delval：逻辑删除值</td></tr></tbody></table><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><strong>乐观锁通过版本号控制事务的并发。</strong></p><ol><li>给数据加版本号</li><li><strong>保存数据时判断版本号是否取出时的版本，如果是则说明数据没有改动，直接保存并且版本号加1，否则回退。</strong></li></ol><p><strong>悲观锁：</strong>就是锁定你想要使用的资源，其他请求想要使用这个资源就必须排队，等这个资源释放了才能继续。</p><p><strong>乐观锁使用案例：</strong></p><p>业务并发现象带来的问题：<strong>秒杀</strong>。假如有100个商品或者票在出售，为了能保证每个商品或者票只能被一个人购买，如何保证不会出现超买或者重复卖。</p><ul><li>第一个想到的就是锁，锁在一台服务器中是可以解决的，但是如果在多台服务器下锁就没有办法控制，比如12306有两台服务器在进行卖票，在两台服务器上都添加锁的话，那也有可能会导致在同一时刻有两个线程在进行卖票，还是会出现并发问题</li><li>接下来介绍的这种方式是针对于小型企业的解决方案，因为数据库本身的性能就是个瓶颈，如果对其并发量超过2000以上的就需要考虑其他的解决方案了。</li></ul><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul><li>数据库表中<strong>添加version列</strong>，比如默认值给1</li><li>第一个线程要修改数据之前，取出记录时，获取当前数据库中的version=1</li><li>第二个线程要修改数据之前，取出记录时，获取当前数据库中的version=1</li><li>第一个线程执行更新时，set version = newVersion where version = oldVersion<ul><li>newVersion = version+1 [2]</li><li>oldVersion = version [1]</li></ul></li><li>第二个线程执行更新时，set version = newVersion where version = oldVersion<ul><li>newVersion = version+1 [2]</li><li>oldVersion = version [1]</li></ul></li><li>假如这两个线程都来更新数据，第一个和第二个线程都可能先执行<ul><li><strong>假如第一个线程先执行更新，乐观锁发现version依然为1，就把version改为2，第二个线程再更新</strong>的时候，set version = 2 where version = 1，此时<strong>乐观锁发现数据库表version已经为2，所以第二个线程会修改失败</strong></li><li>假如第二个线程先执行更新，会把version改为2，第一个线程再更新的时候，set version = 2 where version = 1,此时数据库表的数据version已经为2，所以第一个线程会修改失败</li><li><strong>不管谁先执行都会确保只能有一个线程更新数据，这就是MP提供的乐观锁的实现原理分析。</strong></li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol><li><p><strong>数据库表添加列，默认值1</strong>。列名可以任意，比如使用<code>version</code>,给列设置默认值为<code>1</code></p></li><li><p><strong>在模型类中添加对应的属性，@Version</strong>。根据添加的字段列名，在模型类中添加对应的属性值version，并注解@Version</p></li><li><p><strong>添加乐观锁的拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MpConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mpInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.定义Mp拦截器</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mpInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 2.添加乐观锁拦截器</span></span><br><span class="line">        mpInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">         <span class="comment">// 分页拦截器 </span></span><br><span class="line">        <span class="comment">//mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());   </span></span><br><span class="line">        <span class="keyword">return</span> mpInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>先查询version再更新操作</strong> </p><p><strong>要想实现乐观锁，首先第一步应该是拿到表中的version，然后拿version当条件在将version加1更新回到数据库表中</strong>，所以我们在修改的时候，需要对其进行查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.先通过要修改的数据id将当前数据查询出来</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDao.selectById(<span class="number">3L</span>);</span><br><span class="line"><span class="comment">// 2.将要修改的属性逐一设置进去</span></span><br><span class="line">user.setName(<span class="string">&quot;Jock888&quot;</span>);</span><br><span class="line">userDao.updateById(user);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>注意：必须先查询再修改，修改后系统自动给version属性加1。手动加和不查不加都是步行的。</strong>如果手动加version，提交后系统还会加一次1.</p></blockquote><hr><h1 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h1><h2 id="代码生成器实现"><a href="#代码生成器实现" class="headerlink" title="代码生成器实现"></a>代码生成器实现</h2><ol><li><p><strong>创建一个Maven项目</strong>，<strong>导入对应的jar包</strong>mybatis-plus,druid,lombok，代码生成器mybatis-plus-generator和模板引擎velocity-engine-core依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatisplus_04_generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--spring webmvc--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatisplus--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--druid--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--test--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--代码生成器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--velocity模板引擎--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写引导类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisplusGeneratorApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MybatisplusGeneratorApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建代码生成类CodeGenerator</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取代码生成器的对象</span></span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">autoGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line">        <span class="comment">// 创建DataSourceConfig 对象设置数据库相关配置</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dataSource.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        autoGenerator.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">// 设置全局配置</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">globalConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">      globalConfig.setOutputDir(System.getProperty(<span class="string">&quot;user.dir&quot;</span>)</span><br><span class="line">                                + <span class="string">&quot;/mybatisplus_04_generator/src/main/java&quot;</span>);   </span><br><span class="line">        <span class="comment">// 设置代码生成位置</span></span><br><span class="line">        globalConfig.setOpen(<span class="literal">false</span>);                     <span class="comment">// 设置生成完毕后是否打开生成代码所在的目录</span></span><br><span class="line">        globalConfig.setAuthor(<span class="string">&quot;黑马程序员&quot;</span>);             <span class="comment">// 设置作者</span></span><br><span class="line">        globalConfig.setFileOverride(<span class="literal">true</span>);             <span class="comment">// 设置是否覆盖原始生成的文件</span></span><br><span class="line">        globalConfig.setMapperName(<span class="string">&quot;%sDao&quot;</span>);            <span class="comment">// 设置数据层接口名，%s为占位符，指代模块名称</span></span><br><span class="line">        globalConfig.setIdType(IdType.ASSIGN_ID);       <span class="comment">// 设置Id生成策略</span></span><br><span class="line">        autoGenerator.setGlobalConfig(globalConfig);</span><br><span class="line">        <span class="comment">// 设置包名相关配置</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">packageInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        packageInfo.setParent(<span class="string">&quot;com.aaa&quot;</span>);   <span class="comment">// 设置生成的包名，与代码所在位置不冲突，二者叠加组成完整路径</span></span><br><span class="line">        packageInfo.setEntity(<span class="string">&quot;domain&quot;</span>);    <span class="comment">// 设置实体类包名</span></span><br><span class="line">        packageInfo.setMapper(<span class="string">&quot;dao&quot;</span>);       <span class="comment">// 设置数据层包名</span></span><br><span class="line">        autoGenerator.setPackageInfo(packageInfo);</span><br><span class="line">        <span class="comment">// 策略设置</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">strategyConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        strategyConfig.setInclude(<span class="string">&quot;tbl_user&quot;</span>);  <span class="comment">//设置当前参与生成的表名，参数为可变参数</span></span><br><span class="line">        strategyConfig.setTablePrefix(<span class="string">&quot;tbl_&quot;</span>);  <span class="comment">//设置数据库表的前缀名称，模块名 = 数据库表名-前缀名。</span></span><br><span class="line">        <span class="comment">// 如：User = tbl_user-tbl_</span></span><br><span class="line">        strategyConfig.setRestControllerStyle(<span class="literal">true</span>);    <span class="comment">//设置是否启用Rest风格</span></span><br><span class="line">        strategyConfig.setVersionFieldName(<span class="string">&quot;version&quot;</span>);  <span class="comment">//设置乐观锁字段名</span></span><br><span class="line">        strategyConfig.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);  <span class="comment">//设置逻辑删除字段名</span></span><br><span class="line">        strategyConfig.setEntityLombokModel(<span class="literal">true</span>);  <span class="comment">//设置是否启用lombok</span></span><br><span class="line">        autoGenerator.setStrategy(strategyConfig);</span><br><span class="line">        <span class="comment">// 2.执行代码生成器</span></span><br><span class="line">        autoGenerator.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以参考<a href="https://baomidou.com/guides/new-code-generator/">代码生成器</a></p></li><li><p><strong>运行生成器类的main方法</strong>，运行成功后会在当前项目中生成很多代码，代码包含<code>controller</code>，<code>service</code>，<code>mapper</code>和<code>entity</code></p></li></ol><h2 id="MP中Service的CRUD"><a href="#MP中Service的CRUD" class="headerlink" title="MP中Service的CRUD"></a>MP中Service的CRUD</h2><h3 id="IService和ServiceImpl-lt-UserDao-User-gt"><a href="#IService和ServiceImpl-lt-UserDao-User-gt" class="headerlink" title="IService和ServiceImpl&lt;UserDao, User&gt;"></a>IService<User>和ServiceImpl&lt;UserDao, User&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.selectList(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MP提供了一个Service接口和实现类，分别是：**<code>IService</code>和<code>ServiceImpl</code>**，后者是对前者的一个具体实现。自定义Service可修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt;&#123;&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserDao, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>修改以后的好处是，MP已经帮我们把业务层的一些基础的增删改查都已经实现了，可以直接进行使用。</p><blockquote><p>在MP封装的Service层都有哪些方法可以用，可以查看官方文档<a href="https://baomidou.com/guides/data-interface/">持久层接口</a>，这些提供的方法大家可以参考官方文档进行学习使用，方法的名称可能有些变化，但是方法对应的参数和返回值基本类似。</p></blockquote><hr><h1 id="ActiveRecord简介"><a href="#ActiveRecord简介" class="headerlink" title="ActiveRecord简介"></a>ActiveRecord简介</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>ActiveRecord属于ORM（对象关系映射）层</strong>，由Rails最早提出，遵循标准的<strong>ORM模型：表映射到记录，记录映射到对象，字段映射到对象属性。</strong>配合遵循的命名和配置惯例，能够很大程度的快速实现模型的操作，而且简洁易懂。</p><p><strong>主要思想是：</strong></p><ul><li><strong>每一个数据库表对应创建一个类，类的每一个对象实例对应于数据库中表的一行记录；通常表的每个字段在类中都有相应的Field；</strong></li><li>ActiveRecord同时负责把自己<strong>持久化</strong>，在ActiveRecord中封装了对数据库的访问，即CURD;</li><li>ActiveRecord是一种领域模型(Domain Model)，封装了部分业务逻辑；</li></ul><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>在MP中，开启AR非常简单，只需要将**实体对象继承Model&lt;实体类&gt;**即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;User&gt;&#123;</span><br><span class="line">    <span class="comment">// fields...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li><strong>之后增删改查就可以不用自动注入dao接口，直接实体类对象就能调用mp的各种方法。</strong></li><li><strong>但dao还不能删除，因为ar底层还是dao。</strong></li></ul></blockquote><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    System.out.println(user.selectById(<span class="number">2L</span>));    <span class="comment">//或者给user设置id后user.selectById()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者给user设置id后user.selectById()</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">QueryWrapper&lt;User&gt; userQueryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">userQueryWrapper.le(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">List&lt;User&gt; users = user.selectList(userQueryWrapper);</span><br><span class="line"><span class="keyword">for</span> (User user1 : users) &#123;</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;刘备&quot;</span>);</span><br><span class="line">user.setAge(<span class="number">30</span>);</span><br><span class="line">user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">user.setUserName(<span class="string">&quot;liubei&quot;</span>);</span><br><span class="line">user.setEmail(<span class="string">&quot;liubei@itcast.cn&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">insert</span> <span class="operator">=</span> user.insert();</span><br><span class="line">System.out.println(insert);</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">7L</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">delete</span> <span class="operator">=</span> user.deleteById();</span><br><span class="line">System.out.println(delete);</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">8L</span>);</span><br><span class="line">user.setAge(<span class="number">35</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> user.updateById();</span><br><span class="line">System.out.println(update);</span><br></pre></td></tr></table></figure><hr><h1 id="Mybtis和Mybatis-Plus区别"><a href="#Mybtis和Mybatis-Plus区别" class="headerlink" title="Mybtis和Mybatis-Plus区别"></a>Mybtis和Mybatis-Plus区别</h1><p><strong>MyBatis-Plus 是在 MyBatis 基础上增强的工具包</strong>，让开发更便捷、高效。<a href="https://baomidou.com/">MyBatis-Plus官网地址</a>。</p><h2 id="核心区别总结"><a href="#核心区别总结" class="headerlink" title="核心区别总结"></a>核心区别总结</h2><table><thead><tr><th>特性</th><th>MyBatis</th><th>MyBatis-Plus</th></tr></thead><tbody><tr><td>配置复杂度</td><td>需要手写大量 XML 或注解</td><td>极简配置，自动生成 SQL</td></tr><tr><td>CRUD 操作</td><td>手写 Mapper 方法 + SQL</td><td>内置通用 CRUD 方法</td></tr><tr><td>分页功能</td><td>需要手写分页逻辑或第三方插件</td><td>内置分页插件，开箱即用</td></tr><tr><td>条件构造器</td><td>无，需要手写 where 条件</td><td>内置 Lambda 条件构造器</td></tr><tr><td>代码生成</td><td>无</td><td>提供代码生成器（Code Generator）</td></tr><tr><td>主键策略</td><td>需要手动配置</td><td>内置多种主键生成策略</td></tr><tr><td>乐观锁</td><td>自己实现</td><td>提供内置乐观锁插件</td></tr><tr><td>审计字段（如创建时间、修改时间）</td><td>自行维护</td><td>提供自动填充功能</td></tr><tr><td>性能分析</td><td>需要额外工具</td><td>内置 SQL 性能分析插件</td></tr><tr><td>兼容性</td><td>灵活、手动控制高</td><td>完全兼容 MyBatis，可随时退回</td></tr></tbody></table><h2 id="配置复杂度"><a href="#配置复杂度" class="headerlink" title="配置复杂度"></a>配置复杂度</h2><p><strong>MyBatis：</strong></p><ul><li>需要创建 <code>Mapper 接口</code> + <code>Mapper.xml</code> 文件</li><li>SQL 都需要手动写，配置较繁琐</li><li>实体类、字段和表结构需要手动映射（resultMap 或 @Results）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyBatis 的 select 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>MyBatis-Plus：</strong></p><ul><li>只需配置数据库连接、扫描 Mapper 包</li><li>不需要写 XML，自动完成 SQL 拼接</li><li>实体类字段与表字段名称一致可自动映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简洁调用</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure><h2 id="CRUD-操作"><a href="#CRUD-操作" class="headerlink" title="CRUD 操作"></a>CRUD 操作</h2><p><strong>MyBatis：</strong></p><ul><li>所有 CRUD 方法都需要手写</li><li>如果实体类字段多，SQL 写起来冗长，易出错</li></ul><p><strong>MyBatis-Plus：</strong></p><ul><li>提供 <code>BaseMapper&lt;T&gt;</code>，自动拥有 20+ 个通用 CRUD 方法</li><li>例如：<ul><li><code>selectById</code>, <code>insert</code>, <code>updateById</code>, <code>deleteById</code></li><li>批量插入、分页查询、条件查询等也支持</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span> <span class="params">(T t)</span></span><br></pre></td></tr></table></figure><ul><li>T：泛型，新增用来保存新增数据</li><li>int：返回值，新增成功后返回1，没有新增成功返回的是0</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据多个ID 批量删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 批量删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 不常用</span></span><br><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="comment">//int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);</span></span><br></pre></td></tr></table></figure><p><strong>Serializable：</strong>参数类型</p><ul><li><p><strong>思考：</strong>参数类型为什么是一个序列化类?</p><p>String和Number是Serializable的子类，Number又是Float,Double,Integer等类的父类，能作为主键的数据类型都已经是Serializable的子类，MP使用Serializable作为参数类型，就类似java中Object接收任何数据类型一样。</p></li><li><p><strong>int：</strong>返回值类型，数据删除成功返回1，未删除数据返回0。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T t)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;</span><br></pre></td></tr></table></figure><ul><li>T：泛型，<strong>需要修改的数据内容</strong>，注意因为是根据ID进行修改，所以传入的对象中需要有ID属性值</li><li>int：返回值，修改成功后返回1，未修改数据返回0</li></ul><p><strong>根据条件更改</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setAge(<span class="number">22</span>); <span class="comment">//更新的字段</span></span><br><span class="line"><span class="comment">// 更新的条件</span></span><br><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(<span class="string">&quot;id&quot;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">//执行更新操作</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.userMapper.update(user, wrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>修改的时候，只修改实体对象中有值的字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>Serializable：</strong>参数类型,主键ID的值</li><li><strong>T：</strong>根据ID查询只会返回一条数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span><br></pre></td></tr></table></figure><ul><li><strong>Wrapper：</strong>用来构建条件查询的条件，目前我们没有可直接传为Null</li><li><strong>List：</strong>因为查询的是所有，所以返回的数据是一个集合</li></ul><h2 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h2><p><strong>MyBatis：</strong></p><ul><li>需要自己拼接分页 SQL（LIMIT/OFFSET）</li><li>或接入第三方分页插件如 PageHelper</li></ul><p><strong>MyBatis-Plus：</strong></p><ul><li>提供 <code>分页插件</code>，配置一次后，使用非常方便</li><li>统一使用 <code>Page&lt;T&gt;</code> 对象传参</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span></span><br></pre></td></tr></table></figure><ul><li><strong>IPage<T>：</strong>用来<strong>构建分页查询条件</strong></li><li><strong>Wrapper：</strong>译为包装器，封装器。用来构建<strong>条件查询的条件</strong>，目前我们没有可直接传为Null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方法传入参数获取返回值</span></span><br><span class="line">Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 页码1，每页10条</span></span><br><span class="line">Page&lt;User&gt; result = userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageUtils <span class="title function_">queryPage</span><span class="params">(Map&lt;String, Object&gt; params, Long categoryId)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (String) params.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    LambdaQueryWrapper&lt;AttrGroupEntity&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 先根据检索查</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(key))&#123;</span><br><span class="line"><span class="comment">//wrapper.eq(AttrGroupEntity::getAttrGroupId,key).or().like(AttrGroupEntity::getAttrGroupName,key);//也可以</span></span><br><span class="line">        wrapper.and(</span><br><span class="line">                obj -&gt; obj.eq(AttrGroupEntity::getAttrGroupId,key)</span><br><span class="line">                        .or().like(AttrGroupEntity::getAttrGroupName,key)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(categoryId!=<span class="number">0</span>) &#123;</span><br><span class="line">        wrapper.eq(AttrGroupEntity::getCatelogId,categoryId);</span><br><span class="line">    &#125;</span><br><span class="line">    IPage&lt;AttrGroupEntity&gt; page = <span class="built_in">this</span>.page(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Query</span>&lt;AttrGroupEntity&gt;().getPage(params),</span><br><span class="line">            wrapper</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageUtils</span>(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在config包下创建分页拦截器类</strong>：分页拦截器类代码是通用的，可以直接复制粘贴。可以查看<a href="https://baomidou.com/plugins/pagination/">官方文档类配置</a></p><p>配置拦截器MP，并将其配置成Spring管理的bean对象即可。需要用到MybatisPlusInterceptor 对象的addInnerInterceptor方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注解为配置类@Configuration，也可以在引导类@Import(&#123;MybatisPlusConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 被Spring容器管理    </span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1 创建mp拦截器对象MybatisPlusInterceptor</span></span><br><span class="line">        MybatisPlusInterceptor mpInterceptor=<span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//2 添加内置拦截器，参数为分页内置拦截器对象PaginationInnerInterceptor</span></span><br><span class="line">        mpInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> mpInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h2><p><strong>MyBatis</strong>：条件查询时需要手写 SQL 中的 where 子句</p><p><strong>MyBatis-Plus：</strong></p><ul><li>提供 <code>QueryWrapper</code> 和 <code>LambdaQueryWrapper</code></li><li>可链式编程、支持条件组合、动态拼接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(User::getAge, <span class="number">20</span>).like(User::getName, <span class="string">&quot;张&quot;</span>);</span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p><strong>MyBatis：</strong>没有自带代码生成工具，通常需要借助 MyBatis Generator 插件，且配置复杂</p><p><strong>MyBatis-Plus：</strong></p><ul><li>自带 <code>Code Generator</code>，支持通过数据库自动生成：<ul><li>实体类、Mapper 接口、XML、Service、Controller 等</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速生成一整套文件，只需配置数据库和模板路径</span></span><br><span class="line"><span class="type">AutoGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"><span class="comment">// 配置略...</span></span><br><span class="line">generator.execute();</span><br></pre></td></tr></table></figure><h2 id="主键策略"><a href="#主键策略" class="headerlink" title="主键策略"></a>主键策略</h2><p><strong>MyBatis：</strong>插入数据时需要手动指定主键或配置主键返回策略（如 useGeneratedKeys）</p><p><strong>MyBatis-Plus：</strong></p><ul><li>支持多种主键生成方式：<ul><li>自增、UUID、雪花算法（默认使用雪花）</li></ul></li><li>只需在实体类中加注解即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.ASSIGN_ID)</span> <span class="comment">// 使用雪花算法生成主键</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><h2 id="乐观锁-1"><a href="#乐观锁-1" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><strong>MyBatis：</strong>需要手动实现版本字段逻辑和 SQL 拼接</p><p><strong>MyBatis-Plus：</strong>提供内置插件支持乐观锁，自动对 <code>version</code> 字段进行比较和更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version; <span class="comment">// 更新时会自动加入 version=... 的判断</span></span><br></pre></td></tr></table></figure><h2 id="审计字段（如创建时间、修改时间）"><a href="#审计字段（如创建时间、修改时间）" class="headerlink" title="审计字段（如创建时间、修改时间）"></a>审计字段（如创建时间、修改时间）</h2><p><strong>MyBatis：</strong>需要手动在 insert/update 语句中维护 <code>createTime</code>, <code>updateTime</code></p><p><strong>MyBatis-Plus：</strong></p><ul><li><p>提供自动填充功能，支持插入/更新时自动填充字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime updateTime;</span><br></pre></td></tr></table></figure></li><li><p>需要配置 <code>MetaObjectHandler</code>，一次性设置全局规则</p></li></ul><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><strong>MyBatis：</strong>需要自己接入日志框架或 SQL 监控工具（如 P6Spy）</p><p><strong>MyBatis-Plus：</strong>内置 SQL 执行分析插件（dev/test 环境下很实用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启性能分析插件</span></span><br><span class="line">interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PerformanceInterceptor</span>());</span><br></pre></td></tr></table></figure><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><strong>MyBatis：</strong>灵活度高，自由度大，但需要手动控制 SQL</p><p><strong>MyBatis-Plus：</strong></p><ul><li>100% 兼容原生 MyBatis</li><li>可以只使用通用功能，特殊需求时照样写 XML、注解 SQL</li></ul><h2 id="使用场景建议"><a href="#使用场景建议" class="headerlink" title="使用场景建议"></a>使用场景建议</h2><ul><li><strong>MyBatis</strong>：适合 SQL 极度复杂、强定制化的项目，想完全控制 SQL。</li><li><strong>MyBatis-Plus</strong>：适合大多数通用业务，追求开发效率、简洁的项目，尤其适合中后台管理系统。</li></ul>]]></content>
    
    
    <summary type="html">MyBatis-Plus是一个MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为简化开发、提高效率而生。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="MyBatis" scheme="https://southernfish.github.io/categories/Framwork/MyBatis/"/>
    
    
    <category term="MyBatis" scheme="https://southernfish.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 组件</title>
    <link href="https://southernfish.github.io/pages/middleware/rabbitmq-component/"/>
    <id>https://southernfish.github.io/pages/middleware/rabbitmq-component/</id>
    <published>2025-07-30T01:45:36.000Z</published>
    <updated>2025-09-17T07:51:48.710Z</updated>
    
    <content type="html"><![CDATA[<p><strong>RabbitMQ</strong>是实现了高级<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4751675?fromModule=lemma_inlink">消息队列</a>协议（<a href="https://baike.baidu.com/item/AMQP/8354716?fromModule=lemma_inlink">AMQP</a>）的开源消息代理软件（亦称面向消息的<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240?fromModule=lemma_inlink">中间件</a>）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang/0?fromModule=lemma_inlink">Erlang</a>语言编写的，而集群和<a href="https://baike.baidu.com/item/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/14768924?fromModule=lemma_inlink">故障转移</a>是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0/15696499?fromModule=lemma_inlink">开放电信平台</a>框架上的，支持高并发处理和分布式部署。所有主要的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131?fromModule=lemma_inlink">编程语言</a>均有与代理接口通讯的客户端库。RabbitMQ本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，更适合于企业级的开发。它还实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队，通过队列机制实现应用程序间的异步通信与数据传输，常用于流量削峰、系统解耦及异步处理场景。对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。多用于进行企业级的ESB整合。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/u011488477/article/details/146038779">5.RabbitMQ交换机详解</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146039356">7.RabbitMQ延时交换机</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146038909">6.RabbitMQ死信队列</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146039416">8.RabbitMQ队列详解</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146042593">9.RabbitMQ消息的可靠性</a></p></blockquote><h1 id="RabbitMQ-交换机"><a href="#RabbitMQ-交换机" class="headerlink" title="RabbitMQ 交换机"></a>RabbitMQ 交换机</h1><p>Exchange(X) 可翻译成交换机/交换器/路由器</p><h2 id="RabbitMQ交换器-Exchange-类型"><a href="#RabbitMQ交换器-Exchange-类型" class="headerlink" title="RabbitMQ交换器 (Exchange)类型"></a>RabbitMQ交换器 (Exchange)类型</h2><ol><li><code>Fanout Exchange</code>（扇形交换机）：广播，<strong>分发模式</strong>，把消息<strong>分发给所有订阅者</strong>。广播，将消息交给所有绑定到交换机的队列</li><li><code>Direct Exchange</code>（直连交换机）：定向，把消息交给符合指定routing key 的队列。<strong>发送方把消息发送给订阅方</strong>，针对多个订阅者，<strong>默认采取轮询方式进行消息发送</strong>。</li><li><code>Topic Exchange</code>（主题交换机）：通配符，<strong>匹配订阅模式</strong>，使用<strong>正则匹配</strong>到消息队列，把消息交给符合routing pattern（路由模式） 的队列</li><li><code>Headers Exchange</code>（头部交换机）：与 <code>direct</code> 类似，只是性能很差，此类型几乎用不到。</li><li>x-local-random Exchange</li><li>自定义交换机</li></ol><blockquote><p>使用流程：引入依赖 → 配置MQ（yaml）→ 定义常量 →  定义MQ → 定义生产者 →  定义消费者 →  发送消息 → 测试结果</p><p>引入依赖，配置MQ（yaml）都一样，根据不同类型，不同情况。定义常量、MQ、生产者、消费者略有差别。</p></blockquote><h3 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h3><p>扇形交换机会将消息投递到所有绑定的队列，不需要路由键，不需要进行路由键的匹配，相当于广播、群发；消息发送流程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 可以有多个消费者</span><br><span class="line">2. 每个消费者有自己的queue（队列）</span><br><span class="line">3. 每个队列都要绑定到Exchange（交换机）</span><br><span class="line">4. 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。</span><br><span class="line">5. 交换机把消息发送给绑定过的所有队列</span><br><span class="line">6. 队列的消费者都能拿到消息。实现一条消息被多个消费者消费</span><br></pre></td></tr></table></figure><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_FANOUT</span> <span class="operator">=</span> <span class="string">&quot;exchange.fanout&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_FANOUT_A</span> <span class="operator">=</span> <span class="string">&quot;queue.fanout.a&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_FANOUT_B</span> <span class="operator">=</span> <span class="string">&quot;queue.fanout.B&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// rabbitmq 三部曲</span></span><br><span class="line">    <span class="comment">// 1、定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(RabbitMQConstant.EXCHANGE_FANOUT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2 定义队列a</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(RabbitMQConstant.QUEUE_FANOUT_A);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2 定义队列b</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(RabbitMQConstant.QUEUE_FANOUT_B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 绑定交换机和队列a</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bingingA</span><span class="params">(FanoutExchange fanoutExchange, Queue queueA)</span> &#123;</span><br><span class="line">        <span class="comment">// 将队列A绑定到扇形交换机</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 绑定交换机和队列b</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bingingB</span><span class="params">(FanoutExchange fanoutExchange, Queue queueB)</span> &#123;</span><br><span class="line">        <span class="comment">// 将队列B绑定到扇形交换机</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 生产者发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 定义要发送的消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息封装成Message对象</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(msg.getBytes());</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_FANOUT, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 接收两个队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_FANOUT_A,RabbitMQConstant.QUEUE_FANOUT_B&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;&quot;</span>,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Wed Jul 30 22:01:46 GMT+08:00 2025</span><br><span class="line">接收到的消息为:hello world</span><br><span class="line">接收到的消息为:hello world</span><br></pre></td></tr></table></figure><h3 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h3><p>在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key），消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。路由键与队列名完全匹配的交换机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</span><br><span class="line">X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</span><br><span class="line">C1：消费者，其所在队列指定了需要routing key 为 error 的消息</span><br><span class="line">C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</span><br></pre></td></tr></table></figure><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_DIRECT</span> <span class="operator">=</span> <span class="string">&quot;exchange.direct&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DIRECT_A</span> <span class="operator">=</span> <span class="string">&quot;queue.direct.a&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DIRECT_B</span> <span class="operator">=</span> <span class="string">&quot;queue.direct.b&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_WARNING_KEY</span> <span class="operator">=</span> <span class="string">&quot;warn&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 1、定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用建造者模式创建</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_DIRECT).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用建造者模式创建</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DIRECT_A).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DIRECT_B).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、交换机和队列进行绑定</span></span><br><span class="line">    <span class="comment">// 队列A绑定info</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingA</span><span class="params">(DirectExchange directExchange, Queue queueA)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用建造者模式创建</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(directExchange).with(RabbitMQConstant.ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列B绑定info</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingB1</span><span class="params">(DirectExchange directExchange, Queue queueB)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(directExchange).with(RabbitMQConstant.ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列B绑定warn</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingB2</span><span class="params">(DirectExchange directExchange, Queue queueB)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(directExchange).with(RabbitMQConstant.ROUTING_WARNING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 发送一个两个队列都能接收的消息</span></span><br><span class="line">        <span class="comment">// 使用建造者模式创建消息</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        <span class="comment">// 参数1 交换机, 参数2 路由key, 参数3 消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_DIRECT, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_KEY, message);</span><br><span class="line">        <span class="comment">// 发送一个只有队列B能接收的消息</span></span><br><span class="line">        <span class="comment">// 使用建造者模式创建消息</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">error_message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;error world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_DIRECT,</span><br><span class="line">                                      RabbitMQConstant.ROUTING_WARNING_KEY, error_message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 接收A队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_DIRECT_A&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgA</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到A的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收B队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_DIRECT_B&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgB</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到B的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Wed Jul 30 22:01:46 GMT+08:00 2025</span><br><span class="line">接收到B的消息为:hello world</span><br><span class="line">接收到A的消息为:hello world</span><br><span class="line">接收到B的消息为:error world</span><br></pre></td></tr></table></figure><h3 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Topic 类型的 Exchange 与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过 Topic 类型 Exchange 可以让队列在绑定 Routing key 的时候使用通配符！即direct是完全匹配，topic模式是模糊匹配。</span><br><span class="line">通配符匹配(相当于模糊匹配)，Topic模式中路由键通过<span class="string">&quot;.&quot;</span>分为多个部分。</span><br></pre></td></tr></table></figure><p>通配符规则：用”.”隔开的为一个单词。</p><p>#：匹配一个或多个词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beijing.# == beijing.queue.abc, beijing.queue.xyz.xxx</span><br></pre></td></tr></table></figure><p>*：匹配不多不少恰好 1 个词。必须有一个而且只有一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beijing.* == beijing.queue, beijing.xyz</span><br></pre></td></tr></table></figure><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_TOPIC</span> <span class="operator">=</span> <span class="string">&quot;exchange.topic&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_TOPIC_A</span> <span class="operator">=</span> <span class="string">&quot;queue.topic.a&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_TOPIC_B</span> <span class="operator">=</span> <span class="string">&quot;queue.topic.b&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">topicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(RabbitMQConstant.EXCHANGE_TOPIC).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_TOPIC_A).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_TOPIC_B).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingA</span><span class="params">(TopicExchange topicExchange, Queue queueA)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(topicExchange).with(<span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingB1</span><span class="params">(TopicExchange topicExchange, Queue queueB)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(topicExchange).with(<span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingB2</span><span class="params">(TopicExchange topicExchange, Queue queueB)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(topicExchange).with(<span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        <span class="comment">// 参数1 交换机,参数2 发送路由key, 参数3 消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_TOPIC, <span class="string">&quot;lazy.orange.rabbit&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 接收A队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_TOPIC_A&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgA</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到A的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收B队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_TOPIC_B&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgB</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到B的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接收到A的消息为:hello world</span><br><span class="line">接收到B的消息为:hello world</span><br></pre></td></tr></table></figure><h3 id="Headers-Exchange"><a href="#Headers-Exchange" class="headerlink" title="Headers Exchange"></a>Headers Exchange</h3><p>基于消息内容中的headers属性进行匹配，不是根据路由键匹配。headers交换器和direct交换器完全一致，但性能差很多，几乎不用了。</p><p>消费方指定的headers中必须包含一个”x-match”键，”x-match”键的值有两个</p><ul><li><p>x-match=all:表示所有的键值对都匹配才能接受消息</p></li><li><p>x-match=any:表示只要有键值对匹配就能接受消息</p></li></ul><p>发消息时可以指定消息属性(MessageProperties)，如果heanders中包含多个消息属性，则所有属性都匹配上才算匹配上。</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_HEADERS</span> <span class="operator">=</span> <span class="string">&quot;exchange.headers&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_HEADERS_A</span> <span class="operator">=</span> <span class="string">&quot;queue.headers.a&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_HEADERS_B</span> <span class="operator">=</span> <span class="string">&quot;queue.headers.b&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HeadersExchange <span class="title function_">headersExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.headersExchange(RabbitMQConstant.EXCHANGE_HEADERS).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_HEADERS_A).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_HEADERS_B).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定队列与交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingA</span><span class="params">(HeadersExchange headersExchange, Queue queueA)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; headerValues = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headerValues.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        headerValues.put(<span class="string">&quot;status&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(headersExchange).whereAll(headerValues).match();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingB</span><span class="params">(HeadersExchange headersExchange, Queue queueB)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; headerValues = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headerValues.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;s&quot;</span>);</span><br><span class="line">        headerValues.put(<span class="string">&quot;status&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(headersExchange).whereAll(headerValues).match();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 消息属性</span></span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">        Map&lt;String, Object&gt; headers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headers.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;s&quot;</span>);</span><br><span class="line">        headers.put(<span class="string">&quot;status&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置消息头</span></span><br><span class="line">        messageProperties.setHeaders(headers);</span><br><span class="line">        <span class="comment">// 添加了消息属性</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .andProperties(messageProperties).build();</span><br><span class="line">        <span class="comment">// 头部交换机,路由key无所谓</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_HEADERS, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 接收A队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_HEADERS_A&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgA</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到A的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收B队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_HEADERS_B&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgB</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到B的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕！</span><br><span class="line">接收到B的消息为:hello world</span><br></pre></td></tr></table></figure><h3 id="自定义交换机"><a href="#自定义交换机" class="headerlink" title="自定义交换机"></a>自定义交换机</h3><p>参考：延时交换机使用方式</p><h2 id="交换机属性"><a href="#交换机属性" class="headerlink" title="交换机属性"></a>交换机属性</h2><h3 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h3><ol><li><p>name：交换机名称，就是一个字符串</p></li><li><p>Type：交换机类型(direct、topic、fanout、headers、x-local-random)五种</p></li><li><p>durable：持久化，声明交换机是否持久化，代表交换机在服务器重启后是否还存在</p></li><li><p>autoDelete：是否自动删除，曾经有队列绑定到该交换机，后来解绑了，那就会自动删除该交换机</p></li><li><p>internal：内部使用的，如果是yes表示客户端无法直接发消息到此交换机，它只能用于交换机与交换机的绑定</p></li><li><p>arguments：只有一个取值alternate-exchange，表示备用交换机</p></li><li><p>alternate：设置备用交换机</p></li></ol><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_DIRECT</span> <span class="operator">=</span> <span class="string">&quot;exchange.direct&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DIRECT</span> <span class="operator">=</span> <span class="string">&quot;queue.direct&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 1、定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder <span class="comment">// 默认为持久化的</span></span><br><span class="line">                .directExchange(RabbitMQConstant.EXCHANGE_DIRECT) <span class="comment">// 交换机的名字</span></span><br><span class="line">                .autoDelete() <span class="comment">// 是否自动删除,默认不自动删除,调用该方法则表示自动删除</span></span><br><span class="line">                .durable(<span class="literal">false</span>) <span class="comment">// false表示不持久化,服务器重启会丢失;true表示持久化</span></span><br><span class="line">                <span class="comment">// 是否是内部使用(如果是yes表示客户端无法直接发消息到此交换机,它只能用于交换机与交换机的绑定)</span></span><br><span class="line">                .internal() <span class="comment">// 调用此方法表示设置为true</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DIRECT).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  3、绑定交换机与队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(DirectExchange directExchange, Queue queue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(directExchange).with(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_DIRECT, <span class="string">&quot;info&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_DIRECT, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 接收队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_DIRECT&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgA</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><ol><li><p>不加条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Wed Jul <span class="number">30</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">46</span> GMT+08:<span class="number">00</span> <span class="number">2025</span></span><br><span class="line">消息发送完毕！</span><br><span class="line">接收到的消息为:hello world</span><br></pre></td></tr></table></figure></li><li><p>当配置属性internal时报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Wed Jul 30 22:01:46 GMT+08:00 2025</span><br><span class="line">Shutdown Signal: channel error; protocol method: #method&lt;channel.close&gt;(reply-code:403 reply-text:ACCESS_REFUSED....</span><br></pre></td></tr></table></figure></li><li><p>测试持久化按上</p><p>设置持久化为false，重启rabbitmq-server，则交换机丢失</p></li><li><p>测试配置autoDelete</p><p>自动删除为 true，从控制台上手动解绑，会发现自动删除</p></li></ol><h2 id="备用交换机"><a href="#备用交换机" class="headerlink" title="备用交换机"></a>备用交换机</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当消息经过交换器准备路由给队列的时候，发现没有对应的队列可以投递信息，在rabbitmq中会默认丢弃消息。如果想要监测哪些消息被投递到没有对应的队列，可以用备用交换机来实现，然后接收备用交换机的消息从而记录日志或发送报警信息。</p><h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><p>注意：备用交换机一般使用fanout交换机</p><p>测试时：指定一个错误路由</p><p>重点：普通交换机设置参数绑定到备用交换机</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.normal.backup&quot;</span>;</span><br><span class="line">    <span class="comment">// 备用交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_BACKUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.backup&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.normal.backup&quot;</span>;</span><br><span class="line">    <span class="comment">// 备用队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_BACKUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.backup&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_WARNING_KEY</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 定义正常交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/*//指定当前正常的交换机的备用交换机是谁</span></span><br><span class="line"><span class="comment">        arguments.put(&quot;alternate-exchange&quot;, RabbitMQConstant.EXCHANGE_BACKUP_NAME);</span></span><br><span class="line"><span class="comment">        return new DirectExchange(RabbitMQConstant.EXCHANGE_NORMAL_NAME, true, false, arguments);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder <span class="comment">// 默认为持久化的,默认不自动删除</span></span><br><span class="line">                .directExchange(RabbitMQConstant.EXCHANGE_NORMAL_NAME) <span class="comment">// 交换机的名字</span></span><br><span class="line">                .alternate(RabbitMQConstant.EXCHANGE_BACKUP_NAME) <span class="comment">//设置备用交换机 alternate-exchange</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueNormal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定正常交换机和队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(DirectExchange normalExchange, Queue queueNormal)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueNormal).to(normalExchange)</span><br><span class="line">            .with(RabbitMQConstant.ROUTING_WARNING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义备用交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">alternateExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(RabbitMQConstant.EXCHANGE_BACKUP_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义备用队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">alternateQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_BACKUP_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定备用交换机和队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingAlternate</span><span class="params">(FanoutExchange alternateExchange, Queue alternateQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(alternateQueue).to(alternateExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        Message message= MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NORMAL_NAME,<span class="string">&quot;test&quot;</span>,message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 接收备用队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_BACKUP_NAME&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到备用的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>发送消息</strong></p><p>故意写错路由key，由于正常交换机设置了备用交换机，所以该消息就会进入备用交换机从而进入备用队列。可以写一个程序接收备用对列的消息，接收到后通知相关人员进行处理。如果正常交换机没有设置备用交换机，则该消息会被抛弃。</p><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Wed Jul 30 22:01:46 GMT+08:00 2025</span><br><span class="line">接收到备用的消息为:hello world</span><br></pre></td></tr></table></figure><hr><h1 id="RabbitMQ-延时交换机"><a href="#RabbitMQ-延时交换机" class="headerlink" title="RabbitMQ 延时交换机"></a>RabbitMQ 延时交换机</h1><h2 id="延时问题"><a href="#延时问题" class="headerlink" title="延时问题"></a>延时问题</h2><p><strong>场景</strong>：有一个订单，15分钟内如果不支付，就把该订单设置为交易关闭，那么就不能支付了。</p><p><strong>解决方式</strong>：</p><ul><li><p><strong>定时任务方式</strong>：每隔3秒扫描一次数据库，查询过期的订单然后进行处理；</p><p><strong>优点：</strong>简单,容易实现；</p><p><strong>缺点：</strong></p><ul><li>存在延迟(延迟时间不准确)，如果你每隔1分钟扫一次，那么就有可能延迟1分钟；</li><li>性能较差,每次扫描数据库，如果订单量很大会影响性能</li></ul></li><li><p><strong>被动取消</strong>：当用户查询订单的时候,判断订单是否超时,超时了就取消(交易关闭)；</p><p><strong>优点：</strong>对服务器而言，压力小；</p><p><strong>缺点：</strong></p><ul><li>用户不查询订单，将永远处于待支付状态，会对数据统计等功能造成影响；</li><li>用户打开订单页面，有可能比较慢，因为要处理大量订单，用户体验少稍差；</li></ul></li><li><p>JDK延迟队列(单体应用，不能分布式下)：DelayedQueue。无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素</p><p><strong>优点：</strong>实现简单，任务延迟低</p><p><strong>缺点：</strong></p><ul><li>服务重启、宕机，数据丢失；</li><li>只适合单机版，不适合集群；</li><li>订单量大，可能内存不足而发生异常；</li></ul></li><li><p>采用消息中间件(rabbitmq)</p><p>RabbitMQ本身不支持延迟队列，可以使用TTL结合DLX的方式来实现消息的延迟投递，即把DLX跟某个队列绑定，到了指定时间，消息过期后，就会从DLX路由到这个队列，消费者可以从这个队列取走消息。</p><p>不同延迟时间的消息要发到不同的队列上，同一个队列的消息，它的延迟时间应该一样。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250730224552796.png" alt="image-20250730224552796"></p></li></ul><h2 id="延时交换机"><a href="#延时交换机" class="headerlink" title="延时交换机"></a>延时交换机</h2><h3 id="死信队列实现"><a href="#死信队列实现" class="headerlink" title="死信队列实现"></a>死信队列实现</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>给正常队列绑定一个死信交换机和设置死信路由key；给正常队列设置消息过期时间，过期时间用于模拟延时操作，当消息过期后没有被消费就会转到死信队列。</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机(</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.delay.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.delay.dlx.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.delay.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.delay.dlx.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME</span> <span class="operator">=</span> <span class="string">&quot;order1&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;error1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 重点:设置这两个参数</span></span><br><span class="line">        <span class="comment">// 设置队列的死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);</span><br><span class="line">        <span class="comment">// 设置死信路由key,要和死信交换机和死信队列绑定key一模一样,因为死信交换机是直连交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.ROUTING_DLX_NAME);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME)</span><br><span class="line">                .ttl(<span class="number">25000</span>)                 <span class="comment">// 队列的过期时间</span></span><br><span class="line">                .withArguments(arguments)     <span class="comment">// 设置对列的参数</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常交换机和正常队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlxExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机和死信队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDlx</span><span class="params">(DirectExchange dlxExchange, Queue dlxQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(dlxQueue).to(dlxExchange).with(RabbitMQConstant.ROUTING_DLX_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250730224414884.png" alt="image-20250730224414884"></p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>如果不设置队列的过期时间，在发送消息时设置消息的过期时间会存在以下问题</p><ul><li>若队头的消息过期时间长，后面的消息过期时间短，但因为队头的消息没有被消费，因此后面已过期的消息也无法到达死信队列中</li></ul><h4 id="多队列解决过期时间问题"><a href="#多队列解决过期时间问题" class="headerlink" title="多队列解决过期时间问题"></a>多队列解决过期时间问题</h4><p>对于上面存在的问题，可以将不同过期时间的消息发送到不同的队列上，过期后再转到死信队列上</p><p><strong>定义MQ</strong></p><p>注意：正常队列不要设置过期时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 重点:设置这两个参数</span></span><br><span class="line">        <span class="comment">// 设置队列的死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);</span><br><span class="line">        <span class="comment">// 设置死信路由key,要和死信交换机和死信队列绑定key一模一样,因为死信交换机是直连交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.ROUTING_DLX_NAME);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME)</span><br><span class="line">                <span class="comment">//.ttl(5000)                 // 队列的过期时间</span></span><br><span class="line">                .withArguments(arguments)     <span class="comment">// 设置对列的参数</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="comment">// 正常交换机和正常队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlxExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机和死信队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDlx</span><span class="params">(DirectExchange dlxExchange, Queue dlxQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(dlxQueue).to(dlxExchange).with(RabbitMQConstant.ROUTING_DLX_NAME);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><p>发送消息时先发送一条过期时间长的，再发送一条过期时间短的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            messageProperties.setExpiration(<span class="string">&quot;25000&quot;</span>); <span class="comment">// 第一条消息 过期时间</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world 1&quot;</span>.getBytes())</span><br><span class="line">                    .andProperties(messageProperties)</span><br><span class="line">                    .build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            messageProperties.setExpiration(<span class="string">&quot;15000&quot;</span>); <span class="comment">// 第二条消息 过期时间</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world 2&quot;</span>.getBytes())</span><br><span class="line">                    .andProperties(messageProperties)</span><br><span class="line">                    .build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><p>消费者监听死信队列的消息来查看消息接收的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 延迟队列一定要接收死信队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = RabbitMQConstant.QUEUE_DLX_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;,接收时间为:&#123;&#125;&quot;</span>, body, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：先接收到的是队头的消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Wed Jul 30 22:01:46 GMT+08:00 2025</span><br><span class="line">消息发送完毕，发送时间为:Wed Jul 30 22:01:46 GMT+08:00 2025</span><br><span class="line">接收到的消息为:hello world 1,接收时间为:Wed Jul 30 22:02:16 GMT+08:00 2025</span><br><span class="line">接收到的消息为:hello world 2,接收时间为:Wed Jul 30 22:02:16 GMT+08:00 2025</span><br></pre></td></tr></table></figure><h3 id="使用延时插件"><a href="#使用延时插件" class="headerlink" title="使用延时插件"></a>使用延时插件</h3><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><ol><li><p><strong>下载</strong></p><p>选择对应的版本下载 <a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">rabbitmq_delayed_message_exchange</a> 插件。官网下载地址<a href="http://www.rabbitmq.com/community-plugins.html">community-plugins</a>。</p></li><li><p><strong>插件拷贝到 RabbitMQ 服务器plugins目录下</strong></p></li><li><p>解压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install unzip -y <span class="comment"># 如果unzip没有安装,先安装一下</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/rabbitmq_server-4.0.7/plugins</span><br><span class="line">unzip rabbitmq_delayed_message_exchange-v4.0.7.ez</span><br></pre></td></tr></table></figure></li><li><p><strong>启用插件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/rabbitmq_server-4.0.7/sbin/</span><br><span class="line">./rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_delayed_message_exchange </span><br></pre></td></tr></table></figure></li><li><p><strong>查询安装情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rabbitmq-plugins list <span class="comment"># 查询安装的所有插件</span></span><br></pre></td></tr></table></figure></li><li><p>重启Rabbitmq使其生效</p></li></ol><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>消息发送后不会直接投递到队列，而是先存储到内嵌的 Mnesia数据库中，然后会检查 x-delay 时间(消息头部)，将过期的消息放到死信队列中。延迟插件在 RabbitMQ 3.5.7 及以上的版本才支持，依赖 Erlang/OPT 18.0 及以上运行环境；</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250730225956046.png" alt="image-20250730225956046"></p><p>Mnesia 是一个小型数据库，不适合于大量延迟消息的实现。解决了消息过期时间不一致出现的问题。</p><h4 id="实现延时队列"><a href="#实现延时队列" class="headerlink" title="实现延时队列"></a>实现延时队列</h4><p>消息只要发送到延时交换机即可，延时交换机绑定死信路由的key</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机(死信交换机)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.delay.4&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.delay.4&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME</span> <span class="operator">=</span> <span class="string">&quot;plugin4&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><p>注意延时交换机需要使用自定义类型定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 创建自定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">customExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>); <span class="comment">// 放一个参数</span></span><br><span class="line">        <span class="comment">// CustomExchange(String name, String type, boolean durable, boolean autoDelete, </span></span><br><span class="line">        <span class="comment">// Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                  <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(RabbitMQConstant.QUEUE_NAME) <span class="comment">// 队列名称</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(CustomExchange customExchange, Queue queue)</span> &#123;</span><br><span class="line">        <span class="comment">//绑定也指定路由key,加noargs 方法</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(customExchange).with(RabbitMQConstant.ROUTING_NAME).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><p>生产者发送消息时要在headers中添加过期时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            messageProperties.setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">25000</span>);<span class="comment">// 第一条消息 延迟时间</span></span><br><span class="line">            <span class="comment">//messageProperties.setExpiration(&quot;25000&quot;); // 不要用这个</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world 1&quot;</span>.getBytes())</span><br><span class="line">                    .andProperties(messageProperties)</span><br><span class="line">                    .build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            messageProperties.setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">15000</span>); <span class="comment">// 第二条消息 延迟时间</span></span><br><span class="line">            <span class="comment">//messageProperties.setExpiration(&quot;15000&quot;); // 不要用这个</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world 2&quot;</span>.getBytes())</span><br><span class="line">                    .andProperties(messageProperties)</span><br><span class="line">                    .build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 延迟队列一定要接收死信队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = RabbitMQConstant.QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;,接收时间为:&#123;&#125;&quot;</span>, body, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="RabbitMQ-死信队列"><a href="#RabbitMQ-死信队列" class="headerlink" title="RabbitMQ 死信队列"></a>RabbitMQ 死信队列</h1><h2 id="过期消息（Time-To-Live，TTL）"><a href="#过期消息（Time-To-Live，TTL）" class="headerlink" title="过期消息（Time To Live，TTL）"></a>过期消息（Time To Live，TTL）</h2><p>消息的过期时间有两种设置方式：(过期消息)</p><ol><li><strong>单条消息过期</strong>：单条消息的过期时间决定了在没有任何消费者消费时,消息可以存活多久；</li><li><strong>队列属性设置所有消息过期</strong>：队列的过期时间决定了在没有任何消费者的情况下，队列中的消息可以存活多久；</li></ol><p>如果消息和对列都设置过期时间，则消息的TTL以两者之间较小的那个数值为准。</p><h3 id="设置消息过期时间"><a href="#设置消息过期时间" class="headerlink" title="设置消息过期时间"></a>设置消息过期时间</h3><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.ttl.a&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_TNAME</span> <span class="operator">=</span> <span class="string">&quot;queue.ttl.a&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 1、定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_TNAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、绑定交换机与队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(DirectExchange directExchange, Queue queue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(directExchange).with(RabbitMQConstant.ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 设置单条消息的过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">        messageProperties.setExpiration(<span class="string">&quot;35000&quot;</span>); <span class="comment">//过期的毫秒</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .andProperties(messageProperties).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_KEY, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：发送消息后查看 <code>queue.ttl.a</code> 有一条数据，35秒后查看发现数据丢失。</p><h3 id="设置队列消息过期时间"><a href="#设置队列消息过期时间" class="headerlink" title="设置队列消息过期时间"></a>设置队列消息过期时间</h3><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.ttl.b&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_TNAME</span> <span class="operator">=</span> <span class="string">&quot;queue.ttl.b&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 1、定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 方式1 new Queue 的方式</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">15000</span>); <span class="comment">// 消息过期时间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(RabbitMQConstant.QUEUE_TNAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">        <span class="comment">// 方式2 建造者</span></span><br><span class="line">        <span class="comment">//return QueueBuilder.durable(RabbitMQConstant.QUEUE_TNAME).withArguments(arguments).build();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、绑定交换机与队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(DirectExchange directExchange, Queue queue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(directExchange).with(RabbitMQConstant.ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_KEY, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：先后发送两条消息，发送消息后查看 queue.ttl.b 有2条数据，第1条消息到期后消失，第2条消息到期后消失</p><h2 id="死信队列（Dead-Letter-Exchange，DLX）"><a href="#死信队列（Dead-Letter-Exchange，DLX）" class="headerlink" title="死信队列（Dead Letter Exchange，DLX）"></a>死信队列（Dead Letter Exchange，DLX）</h2><h3 id="单条消息过期"><a href="#单条消息过期" class="headerlink" title="单条消息过期"></a>单条消息过期</h3><p>消息设置了过期时间，在到达过期时间后消息没有被消费：可能是因为消息积压太多，消息消费不过来；也可能是没有对应的消费者。</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常队列,没有消费者,设置过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.dlx.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.dlx.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_KEY</span> <span class="operator">=</span> <span class="string">&quot;order1&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DLX_KEY</span> <span class="operator">=</span> <span class="string">&quot;error1&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 示例中，各个示例的编号分别顺次为1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NORMAL_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 重点:设置这两个参数</span></span><br><span class="line">        <span class="comment">// 设置队列的死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);</span><br><span class="line">        <span class="comment">// 设置死信路由key,要和死信交换机和死信队列绑定key一模一样,因为死信交换机是直连交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.DLX_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME)</span><br><span class="line">                .withArguments(arguments)     <span class="comment">// 设置对列的参数</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常交换机和正常队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.NORMAL_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlxExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机和死信队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDlx</span><span class="params">(DirectExchange dlxExchange, Queue dlxQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(dlxQueue).to(dlxExchange).with(RabbitMQConstant.DLX_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 生产者发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 消息属性</span></span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">        <span class="comment">// 设置单条消息的过期时间,单位为毫秒,数据类型为字符串</span></span><br><span class="line">        messageProperties.setExpiration(<span class="string">&quot;15000&quot;</span>);</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .andProperties(messageProperties).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NORMAL_NAME, </span><br><span class="line">                                      RabbitMQConstant.NORMAL_KEY, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕:发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：发送的消息先出现在正常队列，待过期后消息会出现在死信队列</p><h3 id="队列设置过期"><a href="#队列设置过期" class="headerlink" title="队列设置过期"></a>队列设置过期</h3><p>队列设置了过期时间，在到达过期时间后消息没有被消费：可能是因为消息积压太多，消息消费不过来；也可能是没有对应的消费者。</p><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置队列的过期时间为20秒</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">20000</span>);</span><br><span class="line">        <span class="comment">// 设置这两个参数</span></span><br><span class="line">        <span class="comment">// 重点:给正常队列绑定死信交换机和设置死信路由的key,也就是消息过期后发送到哪个死信交换机,发送时设置死信路由的key</span></span><br><span class="line">        <span class="comment">// 设置对列的死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME); </span><br><span class="line">         <span class="comment">// 设置死信路由key,要和死信交换机和死信队列绑定key一模一样</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.DLX_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NORMAL_NAME, </span><br><span class="line">                                      RabbitMQConstant.NORMAL_KEY, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕:发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：发送的消息先出现在正常队列，待过期后消息会出现在死信队列</p><h3 id="队列到达最大长度"><a href="#队列到达最大长度" class="headerlink" title="队列到达最大长度"></a>队列到达最大长度</h3><p>先入队的消息会被发送到DLX</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.normal.2&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常队列:没有消费者、设置过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.normal.2&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.dlx.2&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.dlx.2&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_KEY</span> <span class="operator">=</span> <span class="string">&quot;order2&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DLX_KEY</span> <span class="operator">=</span> <span class="string">&quot;error2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置对列的最大长度</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 重点:设置这两个参数</span></span><br><span class="line">        <span class="comment">// 设置队列的死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);</span><br><span class="line">        <span class="comment">// 设置死信路由key,要和死信交换机和死信队列绑定key一模一样,因为死信交换机是直连交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.DLX_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME)</span><br><span class="line">                .withArguments(arguments) <span class="comment">// 设置对列过期时间</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world &quot;</span> + i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(str.getBytes()).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NORMAL_NAME,</span><br><span class="line">                                          RabbitMQConstant.NORMAL_KEY, message);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕:发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：超过正常队列的长度后先入队的消息会放入死信队列</p><h3 id="消费消息不进行重新投递"><a href="#消费消息不进行重新投递" class="headerlink" title="消费消息不进行重新投递"></a>消费消息不进行重新投递</h3><ul><li>从正常的队列接收消息，但对消息不进行确认并且不对消息进行重新投递，此时消息就进入死信队列</li><li>业务处理过程中出现异常也会变成死信，因为消费者没有进行确认</li></ul><p><strong>配置MQ</strong></p><p>需要开启消费者手动确认模式，否则默认是消息消费后自动确认的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dlx-learn4</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="comment"># 开启消费者手动确认</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">15000</span>); <span class="comment">//设置对列的过期时间</span></span><br><span class="line">        <span class="comment">// 重点:设置这两个参数</span></span><br><span class="line">        <span class="comment">// 设置对列的死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);</span><br><span class="line">        <span class="comment">// 设置死信路由key,要和死信交换机和死信队列绑定key一模一样,因为死信交换机是直连交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.DLX_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME)</span><br><span class="line">                .withArguments(arguments) <span class="comment">// 设置对列的参数</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(str.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NORMAL_NAME, </span><br><span class="line">                                      RabbitMQConstant.NORMAL_KEY, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕:发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听正常的那个队列的名字,不是监听那个死信队列</span></span><br><span class="line"><span class="comment">     * 从正常的队列接收消息,但是对消息不进行确认,并且不对消息进行重新投递,此时消息就进入死信队列</span></span><br><span class="line"><span class="comment">     * channel 消息信道(是连接下的一个消息信道,一个连接下有多个消息信息,发消息/接消息都是通过信道完成的)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NORMAL_NAME&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message, Channel channel)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的消息:&quot;</span> + message);</span><br><span class="line">        <span class="comment">//对消息不确认,ack单词是 确认 的意思</span></span><br><span class="line">        <span class="comment">// void basicNack(long deliveryTag, boolean multiple, boolean requeue)</span></span><br><span class="line">        <span class="comment">// deliveryTag:消息的一个数字标签</span></span><br><span class="line">        <span class="comment">// multiple:true表示对小于deliveryTag标签下的消息都进行Nack不确认;false表示只对当前deliveryTag标签的消息Nack</span></span><br><span class="line">        <span class="comment">// requeue:true表示消息被Nack后重新发送到队列;false表示消息被Nack后不会重新发送到队列</span></span><br><span class="line">        <span class="comment">// 获取消息属性</span></span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> message.getMessageProperties();</span><br><span class="line">        <span class="comment">// 获取消息的唯一标识,类似身份证或者学号</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> messageProperties.getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">            log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;,接收时间为:&#123;&#125;&quot;</span>, str, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="comment">//TODO 业务逻辑处理</span></span><br><span class="line">            <span class="comment">// 这里模拟一个异常,出现异常后进行手动不确认并且不重新投递设置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 消费者的手动确认:false表示只确认当前消息;改成true为批量确认标志号小于当前标志号的所有消息</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;接收着出现问题:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 消费者的手动不确认:参数3为false表示不重新入队(不重新投递),就会变成死信;为true表示是重新入队</span></span><br><span class="line">                channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：模拟异常，发现消息未重新入队，而是进入了死信队列</p><h3 id="消费者拒绝消息"><a href="#消费者拒绝消息" class="headerlink" title="消费者拒绝消息"></a>消费者拒绝消息</h3><p>开启手动确认模式并拒绝消息，不重新投递，则进入死信队列</p><p>配置<code>yaml</code>时需要开启消费者手动确认模式，配置同上述消息不进行重新投递</p><p><strong>定义MQ</strong></p><p>这里的队列无需设置队列的过期时间，因为消费者拒绝后如果不重新投递就直接进入死信队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.QUEUE_DLX_NAME);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(str.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NORMAL_NAME, </span><br><span class="line">                                      RabbitMQConstant.NORMAL_KEY, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕:发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><p>消费者拒绝消息后不进行重新投递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听正常的那个队列的名字,不是监听那个死信队列</span></span><br><span class="line"><span class="comment">     * 我们从正常的队列接收消息,但是对消息不进行确认,并且不对消息进行重新投递,此时消息就进入死信队列</span></span><br><span class="line"><span class="comment">     * channel 消息信道(是连接下的一个消息信道,一个连接下有多个消息信息,发消息/接消息都是通过信道完成的)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NORMAL_NAME&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message, Channel channel)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的消息:&quot;</span> + message);</span><br><span class="line">        <span class="comment">// 获取消息属性</span></span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> message.getMessageProperties();</span><br><span class="line">        <span class="comment">// 获取消息的唯一标识,类似身份证或者学号</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> messageProperties.getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">            log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;,接收时间为:&#123;&#125;&quot;</span>, str, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="comment">// TODO 业务逻辑处理</span></span><br><span class="line">            <span class="comment">// 这里模拟一个业务异常,出现异常后进入消费者拒绝设置,不进行重新投递</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 消费者的手动确认:false是只确认当前消息;改成true为批量确认标志号小于当前标志号的所有消息</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;接收着出现问题:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 拒绝消息:参数1是消息的标识,参数2是否重新入队(false表示拒绝后不重新入队),不可以批量处理</span></span><br><span class="line">                channel.basicReject(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：拒绝后的消息不再入队，正常和死信队列都没有了</p><h3 id="死信应用场景"><a href="#死信应用场景" class="headerlink" title="死信应用场景"></a>死信应用场景</h3><ul><li>监听死信消息以便查找问题</li><li>可以实现延时队列业务</li></ul><hr><h1 id="RabbitMQ-队列"><a href="#RabbitMQ-队列" class="headerlink" title="RabbitMQ 队列"></a>RabbitMQ 队列</h1><h2 id="队列属性"><a href="#队列属性" class="headerlink" title="队列属性"></a>队列属性</h2><ol><li><p>Type：设置队列的队列类型;</p></li><li><p>Name：队列名称，就是一个字符串，随便一个字符串就可以；</p></li><li><p>Durability：声明队列是否持久化，代表队列在服务器重启后是否还存在；</p></li><li><p>Auto delete：是否自动删除。true表示当没有消费者连接到这个队列时，队列会自动删除；</p></li><li><p>Exclusive：该属性的队列只对第一个连接它的消费者可见（之后其它消费者无法访问该队列），连接断开时自动删除。基本设置成false</p></li><li><p>Arguments：队列的其他属性，例如指定DLX(死信交换机等)；</p><ol><li><p><code>x-expires:Number</code>：当Queue(队列)在指定的时间未被访问则队列将被自动删除</p></li><li><p><code>x-message-ttl:Number</code>：发布的消息在队列中存在多长时间后被取消(单位毫秒)</p></li><li><p><code>x-overflow:String</code>：设置队列溢出行为，当达到队列的最大长度时消息的处理方式</p><ol><li><code>drop-head</code>：删除头部消息</li><li><code>reject-publish</code>：超过队列长度后，后面发布的消息会被拒绝接收</li><li><code>reject-publish-dlx</code>：超过队列长度后，后面发布的消息会被拒绝接收并发布到死信交换机</li></ol><p>仲裁队列类型仅支持:drop-head and reject-publish两种</p></li><li><p><code>x-max-length:Number</code>：队列所能容下消息的最大长度，当超出长度后新消息将会覆盖最前面的消息</p></li><li><p><code>x-max-length-bytes:Number</code>：队列在开始从头部删除就绪消息之前可以包含的总正文大小。受限于内存大小，超过该阈值则从队列头部开始删除消息</p></li><li><p><code>x-single-active-consumer</code>：表示队列是否是只能有一个消费者。设置为true时注册的消费组内只有一个消费者消费消息，其他被忽略设置为false时消息循环分发给所有消费者(默认false)</p></li><li><p><code>x-dead-letter-exchange:String</code>：指定队列关联的死信交换机。队列消息达上限后溢出消息不被删掉，而保存到另一队列；</p></li><li><p><code>x-dead-letter-routing-key:String</code>：指定死信交换机的路由键，一般和7一起定义</p></li><li><p><code>x-queue-mode:String</code>：队列类型<code>x-queue-mode=lazy</code>懒队列，在磁盘上尽可能多地保留消息以减少RAM使用。如果未设置则队列将保留内存缓存以尽可能快地传递消息；如果设置则队列消息将保存在磁盘上，消费时从磁盘上读取消费</p></li><li><p><code>x-queue-master-locator:String</code>(用的较少)：在集群模式下设置队列分配到的主节点位置信息；</p><p>每个queue都有一个master节点，所有对于queue的操作都是事先在master上完成，之后再slave上进行相同的操作；</p><p>每个不同的queue可以坐落在不同的集群节点上，这些queue如果配置了镜像队列，那么会有1个master和多个slave</p><p>基本上所有的操作都落在master上，那么如果这些queues的master都落在个别的服务节点上，而其他的节点又很空闲，这样就无法做到负载均衡，那么势必会影响性能；</p><p>关于master queue host 的分配有几种策略，可以在queue声明的时候使用x-queue-master-locator参数，或者在policy上设置queue-master-locator，或者直接在rabbitmq的配置文件中定义queue_master_locator有三种可供选择的策略</p><ol><li><code>min-masters</code>：选择master queue数最少的那个服务节点host；</li><li><code>client-local</code>：选择与client相连接的那个服务节点host；</li><li><code>random</code>:随机分配；</li></ol></li></ol></li></ol><h2 id="属性测试"><a href="#属性测试" class="headerlink" title="属性测试"></a>属性测试</h2><h3 id="非持久化属性测试"><a href="#非持久化属性测试" class="headerlink" title="非持久化属性测试"></a>非持久化属性测试</h3><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.properties.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME1</span> <span class="operator">=</span> <span class="string">&quot;queue.properties.test1.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME2</span> <span class="operator">=</span> <span class="string">&quot;queue.properties.test1.2&quot;</span>;</span><br><span class="line">    <span class="comment">// 路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME1</span> <span class="operator">=</span> <span class="string">&quot;key.properties.test1.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME2</span> <span class="operator">=</span> <span class="string">&quot;key.properties.test1.2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例中，各个示例的编号分别顺次为1,2,3,4,5...</span></span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列 不持久化、不设置名字</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列 不持久化、设置名字</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(RabbitMQConstant.QUEUE_NAME1).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal1</span><span class="params">(DirectExchange normalExchange, Queue normalQueue1)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue1).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal2</span><span class="params">(DirectExchange normalExchange, Queue normalQueue2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue2).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world1&quot;</span>.getBytes()).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world2&quot;</span>.getBytes()).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME2, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发行消息查看控制台发现。设置了名字的会使用自定义名字，未设置名字的队列会自动生成名字</span><br><span class="line">不持久化的队列在服务器重启后队列会消失</span><br></pre></td></tr></table></figure><h3 id="持久化测试"><a href="#持久化测试" class="headerlink" title="持久化测试"></a>持久化测试</h3><p>是否自动删除。如果为true，当没有消费者连接到这个队列的时候，队列会自动删除</p><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机同上</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正常队列 持久化、不设置名字</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列 持久化、设置名字</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发行消息查看控制台发现。设置了名字的会使用自定义名字，未设置名字的队列会自动生成名字</span><br><span class="line">持久化的队列在服务器重启后队列依然存在</span><br></pre></td></tr></table></figure><h3 id="自动删除测试"><a href="#自动删除测试" class="headerlink" title="自动删除测试"></a>自动删除测试</h3><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机同上</span></span><br><span class="line">    <span class="comment">// 正常队列 持久化、不设置名字</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1)</span><br><span class="line">            .autoDelete()<span class="comment">// 设置自动删除</span></span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列 持久化、设置名字</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME2)</span><br><span class="line">            <span class="comment">// .autoDelete()// 设置不自动删除,默认就是不自动删除</span></span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceivemessageService</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME1&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg1</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;1接收到的消息为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME2&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg2</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;2接收到的消息为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：设置为自动删除的队列1在没有消费者连接后被自动删除</p><h3 id="可见性测试"><a href="#可见性测试" class="headerlink" title="可见性测试"></a>可见性测试</h3><p>普通队列允许的消费者没有限制，多个消费者绑定到同一个队列时，RabbitMQ会采用轮询进行投递。如果需要消费者独占队列，在队列创建的时候，设定属性exclusive为true。</p><p>exclusive有两个作用</p><ul><li><p>当连接关闭时connection.close()该队列是否会自动删除；</p></li><li><p>该队列是否是私有的private</p></li></ul><p>如果设置为false则可以使用两个消费者都访问同一个队列，没有任何问题；如果设置为true则会对当前队列加锁,其他连接connection是不能访问的，同一个连接的不同channel是可以访问的。如果强制访问会报如下异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">It could be originally declared on another connection or the exclusive property value does not match that of the original declaration., class-id=60, method-id=20)</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1)</span><br><span class="line">                .exclusive()<span class="comment">//声明只有第一个连接的消费者可见,(之后其它消费者无法访问该队列),并且在连接断开时自动删除</span></span><br><span class="line">                <span class="comment">//.autoDelete()// 设置自动删除</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal1</span><span class="params">(DirectExchange normalExchange, Queue normalQueue1)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue1).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><p>这里的消费者表示在同一个Connection中消费消息的多个消费者，测试是否同一个Connection中的多个消费者可以消费。代码同上。</p><p><strong>发送消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rabbitmq08Properties04Application</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Rabbitmq08Properties04Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SendMessageService sendMessageService;</span><br><span class="line">    <span class="comment">// 程序一启动就会运行该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sendMessageService.sendMsg();</span><br><span class="line"></span><br><span class="line">        &#123;    <span class="comment">// 1.创建连接工厂</span></span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            <span class="comment">// 2.设置工厂参数</span></span><br><span class="line">            factory.setHost(<span class="string">&quot;192.168.1.101&quot;</span>);</span><br><span class="line">            factory.setPort(<span class="number">5672</span>);</span><br><span class="line">            factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            factory.setVirtualHost(<span class="string">&quot;longdidi&quot;</span>);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.创建channel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">                <span class="comment">// 回调方法 当收到信息 自动执行该方法consumerTag</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, </span></span><br><span class="line"><span class="params">                                           AMQP.BasicProperties properties, </span></span><br><span class="line"><span class="params">                                           <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接1接收到信息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            channel.basicConsume(RabbitMQConstant.QUEUE_NAME1, <span class="literal">true</span>, consumer);</span><br><span class="line">            <span class="comment">// 6.释放资源</span></span><br><span class="line">            channel.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1.创建连接工厂</span></span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            <span class="comment">// 2.设置工厂参数</span></span><br><span class="line">            factory.setHost(<span class="string">&quot;192.168.1.101&quot;</span>);</span><br><span class="line">            factory.setPort(<span class="number">5672</span>);</span><br><span class="line">            factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            factory.setVirtualHost(<span class="string">&quot;longdidi&quot;</span>);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">            <span class="comment">// 3.创建channel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">                <span class="comment">// 回调方法 当收到信息 自动执行该方法 consumerTag</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span><br><span class="line"><span class="params">                                           AMQP.BasicProperties properties, </span></span><br><span class="line"><span class="params">                                           <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接2接收到信息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            channel.basicConsume(RabbitMQConstant.QUEUE_NAME1, <span class="literal">true</span>, consumer);</span><br><span class="line">            <span class="comment">// 6.释放资源</span></span><br><span class="line">            channel.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.启动程序，如果有多个Connection连接会报错：channel error;protocol method:#method...</span><br><span class="line">2.注释掉主程序中的两个Connection连接代码重启测试，发现同一Connection内的多个消费者可以连接消费，输出如下</span><br><span class="line">消息发送完毕，发送时间为:Thu Jul 31 14:20:30 GMT+08:00 2025</span><br><span class="line">消息发送完毕，发送时间为:Thu Jul 31 14:20:30 GMT+08:00 2025</span><br><span class="line">消费者1接收到的消息为:hello world2</span><br><span class="line">消费者2接收到的消息为:hello world1</span><br><span class="line">3.停止程序运行查看队列是否自动删除：当连接关闭时队列自动删除</span><br></pre></td></tr></table></figure><h3 id="Arguments测试"><a href="#Arguments测试" class="headerlink" title="Arguments测试"></a>Arguments测试</h3><h4 id="删除属性测试"><a href="#删除属性测试" class="headerlink" title="删除属性测试"></a>删除属性测试</h4><p><code>x-expires</code>属性：当Queue(队列)在指定的时间未被访问则队列将被自动删除。</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.properties.normal.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.properties.dlx.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME1</span> <span class="operator">=</span> <span class="string">&quot;queue.properties.normal.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DLX_NAME1</span> <span class="operator">=</span> <span class="string">&quot;queue.properties.dlx.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME1</span> <span class="operator">=</span> <span class="string">&quot;key.properties.normal.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_DLX_NAME1</span> <span class="operator">=</span> <span class="string">&quot;key.properties.dlx.1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-expires&quot;</span>, <span class="number">10000L</span>); <span class="comment">// 当Queue(队列)在指定的时间未被访问则队列将被自动删除</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常交换机和正常队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：启动应用查看控制台,生成了队列，等待10s之后刷新控制台，队列被删除</p><h4 id="设置队列过期时间"><a href="#设置队列过期时间" class="headerlink" title="设置队列过期时间"></a>设置队列过期时间</h4><p>发布的消息在队列中存在多长时间后被取消(单位毫秒)，参考 <a href="#%E9%98%9F%E5%88%97%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F">队列设置过期</a></p><h4 id="设置队列长度"><a href="#设置队列长度" class="headerlink" title="设置队列长度"></a>设置队列长度</h4><p><code>x-max-length:Number</code>：队列所能容下消息的最大长度，当超出长度后新消息将会覆盖最前面的消息。参考 <a href="#%E9%98%9F%E5%88%97%E5%88%B0%E8%BE%BE%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6">队列到达最大长度</a></p><h4 id="设置队列溢出行为"><a href="#设置队列溢出行为" class="headerlink" title="设置队列溢出行为"></a>设置队列溢出行为</h4><p>当达到队列的最大长度时消息的处理方式：有效值为drop-head(删除头部消息)、reject-publish(拒绝发布)或reject-publish-dlx(拒绝发布到死信交换机)。仲裁队列类型仅支持<code>drop-head</code> and <code>reject-publish</code>两种。</p><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, </span></span><br><span class="line">        <span class="comment">// @Nullable Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">5</span>);<span class="comment">// 队列的溢出行为,删除头部</span></span><br><span class="line">        <span class="comment">// 队列的溢出行为,删除头部(默认行为)</span></span><br><span class="line">        <span class="comment">// arguments.put(&quot;x-overflow&quot;, &quot;drop-head&quot;);</span></span><br><span class="line">        <span class="comment">// 队列的溢出行为,拒绝发布</span></span><br><span class="line">        <span class="comment">//arguments.put(&quot;x-overflow&quot;, &quot;reject-publish&quot;);</span></span><br><span class="line">        <span class="comment">// 队列的溢出行为,拒绝接收消息,超过长度的消息会被发送到死信交换机而不是拒绝接收</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-overflow&quot;</span>, <span class="string">&quot;reject-publish-dlx&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1)</span><br><span class="line">                .withArguments(arguments)</span><br><span class="line">                .deadLetterExchange(RabbitMQConstant.EXCHANGE_DLX_NAME)</span><br><span class="line">                .deadLetterRoutingKey(RabbitMQConstant.ROUTING_DLX_NAME1)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常交换机和正常队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlxExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DLX_NAME1).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机和死信队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDlx</span><span class="params">(DirectExchange dlxExchange, Queue dlxQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(dlxQueue).to(dlxExchange).with(RabbitMQConstant.ROUTING_DLX_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.当属性设置为drop-head时</span><br><span class="line">如果超过队列长度,先入队的消息会被先删除(如果配置了死信交换机则会移至死信交换机)</span><br><span class="line">2.当属性设置为reject-publish时</span><br><span class="line">该模式下当队列达到最天长度后会拒绝收消息,也不会将队头的消息移至死信队列(如果配置了死信队列的话),超长的消息未被接收</span><br><span class="line">3.当属性设置为reject-publish-dlx时</span><br><span class="line">拒绝接收后面的消息并将拒绝的消息放到死信交换机中，后面发送的消息会存储到死信队列中</span><br></pre></td></tr></table></figure><h4 id="设置队列内存大小"><a href="#设置队列内存大小" class="headerlink" title="设置队列内存大小"></a>设置队列内存大小</h4><p><code>x-max-length-bytes:Number</code>：队列在开始从头部删除就绪消息之前可以包含的总正文大小。受限于内存大小，超过该阈值则从队列头部开始删除消息</p><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-max-length-bytes&quot;</span>, <span class="number">30</span>); <span class="comment">// 队列的内存大小</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;你好我好大家好&quot;</span> + i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(str.getBytes()).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(str.getBytes()).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：队列中只剩3条信息，先入队的超过内存的限制的消息被删除了</p><h4 id="设置单一消费者"><a href="#设置单一消费者" class="headerlink" title="设置单一消费者"></a>设置单一消费者</h4><p>表示队列是否是只能有一个消费者。设置为true时注册的消费组内只有一个消费者消费消息，其他被忽略；设置为false时消息循环分发给所有消费者(默认false)。</p><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-single-active-consumer&quot;</span>, <span class="literal">true</span>);<span class="comment">//队列的最大长度</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceivemessageService</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME1&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg1</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;消费者1接收到的消息为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME1&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg2</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;消费者2接收到的消息为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：只有消费者1收到了消息</p><h4 id="设置死信交换机"><a href="#设置死信交换机" class="headerlink" title="设置死信交换机"></a>设置死信交换机</h4><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机同上</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);<span class="comment">//死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.ROUTING_DLX_NAME1);<span class="comment">//死信路由key</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1)</span><br><span class="line">                .ttl(<span class="number">5000</span>) <span class="comment">// 设置超时时间</span></span><br><span class="line">                .withArguments(arguments)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：超时的消息放入了死信队列</p><hr><h1 id="RabbitMQ-消息可靠性"><a href="#RabbitMQ-消息可靠性" class="headerlink" title="RabbitMQ 消息可靠性"></a>RabbitMQ 消息可靠性</h1><h2 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h2><h3 id="Confirm模式简介"><a href="#Confirm模式简介" class="headerlink" title="Confirm模式简介"></a>Confirm模式简介</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250731150818210.png" alt="image-20250731150818210"></p><ol><li>代表消息从生产者发送到Exchange;</li><li>代表消息从Exchange路由到Queue；</li><li>代表消息在Queue中存储；</li><li>代表消费者监听Queue并消费消息；</li></ol><p>可能因为网络或者Broker的问题导致①失败，而此时应该让生产者知道消息是否正确发送到了Broker的exchange中；</p><p>有两种解决方案：</p><ul><li>开启Confirm(确认)模式；(异步)</li><li>开启Transaction(事务)模式；(性能低，实际项目中很少用)</li></ul><p>消息的confirm确认机制,是指生产者投递消息后，到达了消息<a href="https://so.csdn.net/so/search?q=%E6%9C%8D%E5%8A%A1%E5%99%A8&spm=1001.2101.3001.7020">服务器</a>Broker里面的exchange交换机，则会给生产者一个应答生产者接收到应答，用来确定这条消息是否正常的发送到Broker的exchange中，这也是消息可靠性投递的重要保障；</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250731150944952.png" alt="image-20250731150944952"></p><h3 id="Confirm模式实现"><a href="#Confirm模式实现" class="headerlink" title="Confirm模式实现"></a>Confirm模式实现</h3><ul><li><p>开启生产者确认模式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启生产者的确认模式,设置关联模式</span></span><br></pre></td></tr></table></figure></li><li><p>实现RabbitTemplate.ConfirmCallback交界口,重写confirm()方法</p><p>判断成功和失败的ack结果,可以根据具体的结果,如果ack为false,对消息进行重新发送或记录日志等处理</p></li><li><p>设置rabbitTemplate的确认回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setConfirmCallback(messageConfirmCallBack);</span><br></pre></td></tr></table></figure></li></ul><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.confirm.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME1</span> <span class="operator">=</span> <span class="string">&quot;queue.confirm.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME1</span> <span class="operator">=</span> <span class="string">&quot;key.confirm.normal.1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外部类实现"><a href="#外部类实现" class="headerlink" title="外部类实现"></a>外部类实现</h4><p><strong>生产者</strong>：设置回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MyConfirmCallBack confirmCallBack;</span><br><span class="line">    <span class="comment">// 构造方法执行后会调用一次该方法,只调用一次,起到初始化的作用</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(confirmCallBack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        <span class="comment">// 关联数据对象</span></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(); <span class="comment">//关联数据</span></span><br><span class="line">        <span class="comment">// 比如设置一个订单ID,到时候在confirm回调里面就可以知道是哪个订单没有发送到交换机上去</span></span><br><span class="line">        correlationData.setId(<span class="string">&quot;order_123456&quot;</span>); <span class="comment">// 发送订单信息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME + <span class="string">&quot;error&quot;</span>, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1, message, correlationData);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfirmCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机收到消息后,会回调该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 相关联的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack 有两个取值,true和false,true表示成功：消息正确地到达交换机,反之false就是消息没有正确地到达交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause 消息没有正确地到达交换机的原因是什么</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;关联id为：&#123;&#125;&quot;</span>, correlationData.getId() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息正确的达到交换机&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ack =false 没有到达交换机</span></span><br><span class="line">            log.error(<span class="string">&quot;消息没有到达交换机,原因为：&#123;&#125;&quot;</span>, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者实现"><a href="#生产者实现" class="headerlink" title="生产者实现"></a>生产者实现</h4><p><strong>生产者</strong>：生产者直接实现<code>RabbitTemplate.ConfirmCallback</code>接口，重写confirm()方法并设置回调函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(); <span class="comment">//关联数据</span></span><br><span class="line">        correlationData.setId(<span class="string">&quot;order_123456&quot;</span>); <span class="comment">// 发送订单信息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME + <span class="string">&quot;error&quot;</span>,</span><br><span class="line">                                      RabbitMQConstant.QUEUE_NAME1, message, correlationData);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;关联id为：&#123;&#125;&quot;</span>, correlationData.getId() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息正确的达到交换机&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.error(<span class="string">&quot;消息没有到达交换机,原因为：&#123;&#125;&quot;</span>, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部内实现"><a href="#匿名内部内实现" class="headerlink" title="匿名内部内实现"></a>匿名内部内实现</h4><p><strong>生产者</strong>：生产者使用匿名内部类实现<code>RabbitTemplate.ConfirmCallback</code>接口,重写confirm()方法并设置回调函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;关联id为：&#123;&#125;&quot;</span>, correlationData.getId() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">                            log.info(<span class="string">&quot;消息正确的达到交换机&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        log.error(<span class="string">&quot;消息没有到达交换机,原因为：&#123;&#125;&quot;</span>, cause);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(); <span class="comment">//关联数据</span></span><br><span class="line">        correlationData.setId(<span class="string">&quot;order_123456&quot;</span>); <span class="comment">//发送订单信息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME + <span class="string">&quot;error&quot;</span>, </span><br><span class="line">                                      RabbitMQConstant.QUEUE_NAME1, message, correlationData);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambad-实现"><a href="#Lambad-实现" class="headerlink" title="Lambad 实现"></a>Lambad 实现</h4><p><strong>生产者</strong>：生产者使用lambda实现<code>RabbitTemplate.ConfirmCallback</code>接口，重写confirm()方法并设置回调函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(</span><br><span class="line">            <span class="comment">// 使用lambda 表达式</span></span><br><span class="line">            (correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;关联id为：&#123;&#125;&quot;</span>, correlationData.getId() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;消息正确的达到交换机&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                log.error(<span class="string">&quot;消息没有到达交换机,原因为：&#123;&#125;&quot;</span>, cause);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(); <span class="comment">//关联数据</span></span><br><span class="line">        correlationData.setId(<span class="string">&quot;order_123456&quot;</span>); <span class="comment">//发送订单信息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME + <span class="string">&quot;error&quot;</span>,</span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1, message, correlationData);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：写错交换机的名字，查看日志输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关联id为:order_123456</span><br><span class="line">消息没有到达交换机，原因为:channel error;protocol method:#method&lt;channel</span><br></pre></td></tr></table></figure><h2 id="交换机确认"><a href="#交换机确认" class="headerlink" title="交换机确认"></a>交换机确认</h2><p>可能因为路由关键字错误，或者队列不存在，或者队列名称错误导致②失败；</p><p>使用return模式可以实现消息无法路由的时候返回给生产者，消息从 exchange –&gt; queue 投递失败则会返回一个 returnCallback，利用这个callback控制消息的可靠性投递；</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250731150818210.png" alt="image-20250731150818210"></p><h3 id="return模式实现"><a href="#return模式实现" class="headerlink" title="return模式实现"></a>return模式实现</h3><ul><li><p>开启return确认模式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启生产者的确认模式,设置关联模式</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#开启return模式</span></span><br></pre></td></tr></table></figure></li><li><p>实现RabbitTemplate.ReturnsCallback接口并重写returnedMessage()方法</p></li><li><p>设置回调</p><p>使用rabbitTemplate.setReturnCallback设置退回函数</p><p>当消息从exchange路由到queue失败后,则会将消息退回给producer,并执行回调函数returnedMessage；</p></li></ul><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.return.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME1</span> <span class="operator">=</span> <span class="string">&quot;queue.return.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME1</span> <span class="operator">=</span> <span class="string">&quot;key.return.normal.1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外部类实现-1"><a href="#外部类实现-1" class="headerlink" title="外部类实现"></a>外部类实现</h4><p><strong>生产者</strong>：设置回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MyReturnCallBack myReturnCallBack;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(myReturnCallBack); <span class="comment">//设置回调</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1 + <span class="string">&quot;error&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>外部实现接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReturnCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当消息从交换机 没有正确地 到达队列,则会触发该方法</span></span><br><span class="line"><span class="comment">     * 如果消息从交换机 正确地 到达队列了,那么就不会触发该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnedMessage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息从交换机没有正确的路由到(投递到)队列,原因为：&#123;&#125;&quot;</span>, returnedMessage.getReplyText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者实现-1"><a href="#生产者实现-1" class="headerlink" title="生产者实现"></a>生产者实现</h4><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="built_in">this</span>); <span class="comment">// 设置回调</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1 + <span class="string">&quot;error&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息从交换机没有正确的路由到(投递到)队列,原因为：&#123;&#125;&quot;</span>, returnedMessage.getReplyText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类实现"><a href="#匿名内部类实现" class="headerlink" title="匿名内部类实现"></a>匿名内部类实现</h4><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">                <span class="comment">// 匿名内部类 实现了接口</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;消息从交换机没有正确的路由到(投递到)队列,原因为：&#123;&#125;&quot;</span>, </span><br><span class="line">                                  returnedMessage.getReplyText());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        ); <span class="comment">// 设置回调</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1 + <span class="string">&quot;error&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lambda实现"><a href="#lambda实现" class="headerlink" title="lambda实现"></a>lambda实现</h4><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">                message -&gt; &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;消息从交换机没有正确的路由到(投递到)队列,原因为：&#123;&#125;&quot;</span>, message.getReplyText());</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1 + <span class="string">&quot;error&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Thu Jul 31 15:32:48 GMT+08:00 2025</span><br><span class="line">消息从交换机没有正确的路由到(投递到)队列，原因为:NO_ROUTE</span><br></pre></td></tr></table></figure><h3 id="使用备用交换机"><a href="#使用备用交换机" class="headerlink" title="使用备用交换机"></a>使用备用交换机</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250731150818210.png" alt="image-20250731150818210"></p><p>使用备份交换机(alternate-exchange)，无法路由的消息会发送到这个备用交换机上；</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.normal.backup.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 备用交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_BACKUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.backup.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.normal.backup.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 备用队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_BACKUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.backup.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_WARNING_KEY</span> <span class="operator">=</span> <span class="string">&quot;info1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder <span class="comment">// 默认为持久化的,默认不自动删除</span></span><br><span class="line">                .directExchange(RabbitMQConstant.EXCHANGE_NORMAL_NAME) <span class="comment">// 交换机的名字</span></span><br><span class="line">                .alternate(RabbitMQConstant.EXCHANGE_BACKUP_NAME) <span class="comment">// 设置备用交换机 alternate-exchange</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueNormal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意 ROUTING_WARNING_KEY</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(DirectExchange normalExchange, Queue queueNormal)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueNormal)</span><br><span class="line">            .to(normalExchange)</span><br><span class="line">            .with(RabbitMQConstant.ROUTING_WARNING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">alternateExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(RabbitMQConstant.EXCHANGE_BACKUP_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">alternateQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_BACKUP_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingAlternate</span><span class="params">(FanoutExchange alternateExchange, Queue alternateQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(alternateQueue).to(alternateExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：消息存储到了备用队列</p><h2 id="消息持久化存储"><a href="#消息持久化存储" class="headerlink" title="消息持久化存储"></a>消息持久化存储</h2><p>消息的可靠性投递就是要保证消息投递过程中每一个环节都要成功，那么这肯定会牺牲一些性能，性能与可靠性是无法兼得的；</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250731150818210.png" alt="image-20250731150818210"></p><p>可能因为系统宕机、重启、关闭等等情况导致存储在队列的消息丢失，即③出现问题；</p><p>解决方案：</p><ol><li><p>队列持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueBuilder.durable(<span class="string">&quot;队列名称&quot;</span>).build();</span><br></pre></td></tr></table></figure></li><li><p>交换机持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExchangeBuilder.directExchange(<span class="string">&quot;交换机名称&quot;</span>).durable(<span class="literal">true</span>).build();</span><br></pre></td></tr></table></figure></li><li><p>消息持久化，默认就是持久化的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line"><span class="comment">// 设置消息持久化,当然它默认就是持久化,所以可以不用设置</span></span><br><span class="line">messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br></pre></td></tr></table></figure></li></ol><h2 id="消费者手动确认"><a href="#消费者手动确认" class="headerlink" title="消费者手动确认"></a>消费者手动确认</h2><h3 id="手动确认消息"><a href="#手动确认消息" class="headerlink" title="手动确认消息"></a>手动确认消息</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250731150818210.png" alt="image-20250731150818210"></p><p>采用消息消费时的<code>手动ack确认机制</code>来保证；如果消费者收到消息后未来得及处理即发生异常，或者处理过程中发生异常，会导致④失败。为了保证消息从队列可靠地达到消费者，RabbitMQ提供了<strong>消息确认机制</strong>(<code>message acknowledgement</code>)；</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启生产者的确认模式,设置关联模式</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#开启return模式</span></span><br><span class="line">    <span class="comment"># 开启消费者手动确认</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><p>消费者在订阅队列时,通过上面的配置，不自动确认，采用手动确认，RabbitMQ会等待消费者显式地回复确认信号后才从队列中删除消息；如果消息消费失败，也可以调用basicReject()或者basicNack()来拒绝当前消息而不是确认。如果requeue参数设置为true，可以把这条消息重新存入队列，以便发给下一个消费者(当然只有一个消费者的时候，这种方式可能会出现无限循环重复消费的情况，可以投递到新的队列中，或者只打印异常日志)；</p><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 开启生产者的确定模式</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(</span><br><span class="line">                (correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;消息没有到达交换机,原因为：&#123;&#125;&quot;</span>, cause);</span><br><span class="line">                        <span class="comment">// TODO 重发消息或者记录错误日志</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 开启交换机确认模式</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">                returnedMessage -&gt; &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;消息没有从交换机正确的投递(路由)到队列,原因为：&#123;&#125;&quot;</span>, returnedMessage.getReplyText());</span><br><span class="line">                    <span class="comment">// TODO 记录错误日志,给程序员发短信或者或者邮件</span></span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">        <span class="comment">// 设置单条消息的持久化,默认就是持久化</span></span><br><span class="line">        messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .andProperties(messageProperties).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1+<span class="string">&quot;1&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME1&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message, Channel channel)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取消息的唯一标识</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;接收到的消息为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">            <span class="comment">// TODO 插入订单等</span></span><br><span class="line">            <span class="comment">// int a=10/0;</span></span><br><span class="line">            <span class="comment">// 手动确认</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息处理出现问题&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息的幂等性（消息不被重复消费）"><a href="#消息的幂等性（消息不被重复消费）" class="headerlink" title="消息的幂等性（消息不被重复消费）"></a>消息的幂等性（消息不被重复消费）</h3><p>同一个消息，第一次接收，正常处理业务，如果该消息第二次再接收，那就不能再处理业务，否则就处理重复了；</p><p><strong>幂等性</strong>：对于一个资源，不管请求一次还是多次，对该资源本身造成的影响应该是相同的，不能因重复请求而对该资源重复造成影响；</p><p><strong>以接口幂等性举例</strong>：</p><p><strong>接口幂等性</strong>：一个接口用同样的参数反复调用，不会造成业务错误，那么这个接口就是具有幂等性的；</p><p>比如同一个订单我支付两次,但是只会扣款一次,第二次支付不会扣款,这说明这个支付接口是具有幂等性的；</p><p><strong>如何避免消息的重复消费问题?(消息消费时的幂等性)</strong></p><p>全局唯一ID + Redis：生产者在发送消息时，为每条消息设置一个全局唯一的messageId，消费者拿到消息后，使用setnx命令（<code>setnx(messageId, 1)</code>），将messageId作为key放到redis中，若返回1，说明之前没有消费过，正常消费；若返回0，说明这条消息之前已消费过，抛弃；</p><p><strong>实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal orderMoney;</span><br><span class="line">    <span class="keyword">private</span> Date orderTime; <span class="comment">// 下单时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 这个对象可以进行序列化和反序列化(json格式)</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 开启生产者的确定模式</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(</span><br><span class="line">                (correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;消息没有到达交换机,原因为：&#123;&#125;&quot;</span>, cause);</span><br><span class="line">                        <span class="comment">// TODO 重发消息或者记录错误日志</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">                returnedMessage -&gt; &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;消息没有从交换机正确的投递(路由)到队列,原因为：&#123;&#125;&quot;</span>, returnedMessage.getReplyText());</span><br><span class="line">                    <span class="comment">// TODO 记录错误日志,给程序员发短信或者或者邮件</span></span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建订单</span></span><br><span class="line">            <span class="type">Orders</span> <span class="variable">orders1</span> <span class="operator">=</span> Orders.builder()</span><br><span class="line">                    .orderId(<span class="string">&quot;order_12345&quot;</span>)</span><br><span class="line">                    .orderName(<span class="string">&quot;买的手机&quot;</span>)</span><br><span class="line">                    .orderMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">2356</span>))</span><br><span class="line">                    .orderTime(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">// 转成json</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">strOrders1</span> <span class="operator">=</span> objectMapper.writeValueAsString(orders1);</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            <span class="comment">// 设置单条消息的持久化,默认就是持久化</span></span><br><span class="line">            messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(strOrders1.getBytes())</span><br><span class="line">                    .andProperties(messageProperties).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Orders</span> <span class="variable">orders2</span> <span class="operator">=</span> Orders.builder()</span><br><span class="line">                    .orderId(<span class="string">&quot;order_12345&quot;</span>)</span><br><span class="line">                    .orderName(<span class="string">&quot;买的手机&quot;</span>)</span><br><span class="line">                    .orderMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">2356</span>))</span><br><span class="line">                    .orderTime(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="type">String</span> <span class="variable">strOrders2</span> <span class="operator">=</span> objectMapper.writeValueAsString(orders2);</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            <span class="comment">// 设置单条消息的持久化,默认就是持久化</span></span><br><span class="line">            messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(strOrders2.getBytes())</span><br><span class="line">                    .andProperties(messageProperties).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME1&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取消息的唯一标识</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="comment">// 使用objectmapper把字节数组反序列化成对象</span></span><br><span class="line">        <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> objectMapper.readValue(message.getBody(), Orders.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;接收到的消息为：&#123;&#125;&quot;</span>, orders.toString());</span><br><span class="line">            <span class="comment">// 如果不存在就在redis中存储</span></span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">setResult</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(<span class="string">&quot;idempotent:&quot;</span> + orders.getOrderId(), orders.getOrderId());</span><br><span class="line">            <span class="keyword">if</span> (setResult) &#123;</span><br><span class="line">                <span class="comment">// TODO 向数据库插入订单等</span></span><br><span class="line">                log.info(<span class="string">&quot;向数据库插入订单&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 手动确认</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息处理出现问题&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Thu Jul 31 16:04:07 GMT+08:00 2025</span><br><span class="line">接收到的消息为:0rders(orderId=order_12345,orderName=买的手机,rderMoney=2356...</span><br><span class="line">向数据库插入订单</span><br><span class="line">接收到的消息为:0rders(orderId=order_12345,orderName=买的手机,rderMoney=2356...</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;是实现了高级&lt;a href=&quot;https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4751675?fromModule=lemma_inlink</summary>
      
    
    
    
    <category term="Middleware" scheme="https://southernfish.github.io/categories/Middleware/"/>
    
    <category term="MQ" scheme="https://southernfish.github.io/categories/Middleware/MQ/"/>
    
    
    <category term="RabbitMQ" scheme="https://southernfish.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="https://southernfish.github.io/pages/middleware/rabbitmq/"/>
    <id>https://southernfish.github.io/pages/middleware/rabbitmq/</id>
    <published>2025-07-29T08:15:36.000Z</published>
    <updated>2025-09-17T07:51:48.710Z</updated>
    
    <content type="html"><![CDATA[<p><strong>RabbitMQ</strong>是实现了高级<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4751675?fromModule=lemma_inlink">消息队列</a>协议（<a href="https://baike.baidu.com/item/AMQP/8354716?fromModule=lemma_inlink">AMQP</a>）的开源消息代理软件（亦称面向消息的<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240?fromModule=lemma_inlink">中间件</a>）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang/0?fromModule=lemma_inlink">Erlang</a>语言编写的，而集群和<a href="https://baike.baidu.com/item/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/14768924?fromModule=lemma_inlink">故障转移</a>是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0/15696499?fromModule=lemma_inlink">开放电信平台</a>框架上的，支持高并发处理和分布式部署。所有主要的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131?fromModule=lemma_inlink">编程语言</a>均有与代理接口通讯的客户端库。RabbitMQ本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，更适合于企业级的开发。它还实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队，通过队列机制实现应用程序间的异步通信与数据传输，常用于流量削峰、系统解耦及异步处理场景。对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。多用于进行企业级的ESB整合。</p><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/qidaii/articles/17282475.html">RabbitMQ</a></p><p><a href="https://blog.csdn.net/weixin_64940494/article/details/126134203">RabbitMQ安装Erlang安装 windows</a></p><p><a href="https://blog.csdn.net/qq_42262444/article/details/121701485">【超级详细】RabbitMQ安装教程</a></p><p><a href="https://blog.csdn.net/qq_42262444/article/details/121854422">【详细步骤】Springboot整合RabbitMQ</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146038326">4.RabbitMQ工作模型</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146038909">6.RabbitMQ死信队列</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146042812">10.RabbitMQ集群</a></p><p><a href="https://blog.csdn.net/CYK_byte/article/details/133135103">RabbitMQ 集群 - 普通集群、镜像集群、仲裁队列</a></p></blockquote><h1 id="RabbitMQ-介绍"><a href="#RabbitMQ-介绍" class="headerlink" title="RabbitMQ 介绍"></a>RabbitMQ 介绍</h1><p>2007 年发布，是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。<br>RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue 高级消息队列协议 ）的开源实现，由于erlang 语言的高并发特性，性能较好，本质是个队列，FIFO 先入先出，里面存放的内容是message<br>RabbitMQ 是一个消息中间件：它接收消息并且转发，就类似于一个快递站，卖家把快递通过快递站，送到我们的手上，MQ也是这样，接收并存储消息，再转发。</p><h2 id="RabbitMQ的特点"><a href="#RabbitMQ的特点" class="headerlink" title="RabbitMQ的特点"></a>RabbitMQ的特点</h2><p>AMQP：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言灯条件的限制。</p><ul><li><code>可靠性(Reliablity)：</code>使用了一些机制来保证可靠性，比如持久化、传输确认、发布确认。</li><li><code>灵活的路由(Flexible Routing)：</code>在消息进入队列之前，通过Exchange来路由消息。对于典型的路由功能，Rabbit已经提供了一些内置的Exchange来实现。针对更复杂的路由功能，可以将多个Exchange绑定在一起，也通过插件机制实现自己的Exchange。</li><li><code>消息集群(Clustering)：</code>多个RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li><li><code>高可用(Highly Avaliable Queues)</code>：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li><li><code>多种协议(Multi-protocol)：</code>支持多种消息队列协议，如STOMP、MQTT等。</li><li><code>多种语言客户端(Many Clients)：</code>几乎支持所有常用语言，比如Java、.NET、Ruby等。</li><li><code>管理界面(Management UI)</code>：提供了易用的用户界面，使得用户可以监控和管理消息Broker的许多方面。</li><li><code>跟踪机制(Tracing)</code>：如果消息异常，RabbitMQ提供了消息的跟踪机制，使用者可以找出发生了什么。</li><li><code>插件机制(Plugin System)</code>：提供了许多插件，来从多方面进行扩展，也可以编辑自己的插件。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>抢购活动，削峰填谷，防止系统崩塌</strong>。<br><strong>延迟信息处理</strong>，比如 10 分钟之后给下单未付款的用户<strong>发送邮件提醒</strong>。<br><strong>解耦系统</strong>，对于<strong>新增的功能可以单独写模块扩展</strong>，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p><h3 id="流量消峰"><a href="#流量消峰" class="headerlink" title="流量消峰"></a>流量消峰</h3><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但比不能下单的体验要好。<br>简单来说： 就是在访问量剧增的情况下，但是应用仍然不能停，比如“双十一”下单的人多，但淘宝这个应用仍然要运行，所以就可以使用消息中间件采用队列的形式减少突然访问的压力</p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中间用户感受不到物流系统的故障，提升系统的可用性。</p><p>如图，把支付，库存，物流都交给MQ</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729152629973.png" alt="image-20250729152629973"></p><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。<br><strong>这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题</strong>，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729153106900.png" alt="image-20250729153106900"></p><ul><li><p>同步是阻塞的(会造成等待)</p><p>采用同步方式，用户从注册到响应成功，需要先保存注册信息，再发送邮件通知，邮件发送成功后再发送短信通知，短信发送成功后才通知用户成功，用户体验不好</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729191446438.png" alt="image-20250729191446438"></p></li><li><p>异步是非阻塞的(不会等待)</p><p>采用异步方式，保存用户信息后，短信通知和邮件通知消息写入MQ(耗时极短)，极大的缩短了响应时间</p></li></ul><p>大流量高并发请求、批量数据传递,就可以采用异步处理,提升系统吞吐量；</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729191621315.png" alt="image-20250729191621315"></p><h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><p>主要是用kafka这个服务器来做；日志处理是指将消息队列用于在日志处理中</p><ul><li><p>Kafka解决大量日志传输的问题</p></li><li><p>loger.info(…)</p></li><li><p>ELK 日志处理解决方案</p></li></ul><p>loger.error(…)  → logstash收集消息 → 发送消息的kafka → elastic search(es) → Kibana ELK日志处理平台</p><h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><h3 id="RabbitMQ-的重要角色"><a href="#RabbitMQ-的重要角色" class="headerlink" title="RabbitMQ 的重要角色"></a>RabbitMQ 的重要角色</h3><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p><ul><li><strong>生产者：</strong>消息的创建者，负责<strong>创建和推送数据</strong>到消息服务器；</li><li><strong>消费者：</strong>消息的接收方，用于<strong>处理数据和确认消息</strong>；</li><li><strong>代理(broker)：</strong>就是 <strong><code>RabbitMQ</code> 本身</strong>，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li></ul><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>产生数据发送消息的程序是生产者</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个由交换机类型决定。交换机类型：</p><ol><li><code>direct Exchange</code>(直接交换机)：匹配路由键，只有完全匹配消息才会被转发</li><li><code>Fanout Excange</code>(扇出交换机)：将消息发送至所有的队列</li><li><code>Topic Exchange</code>(主题交换机)：将路由按模式匹配，此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.” 只会匹配到“abc.def”。</li><li><code>Header Exchange</code>：在绑定Exchange和Queue的时候指定一组键值对，header为键，根据请求消息中携带的header进行路由</li></ol><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。</p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729153839738.png" alt="image-20250729153839738"></p><h3 id="RabbitMQ-的重要组件"><a href="#RabbitMQ-的重要组件" class="headerlink" title="RabbitMQ 的重要组件"></a>RabbitMQ 的重要组件</h3><ol><li><p><code>Producer</code>（生产者）：发送消息的应用；它将消息发送到 RabbitMQ 的交换器中</p></li><li><p><code>Consumer</code>（消费者）消费者是消息的接收方,它从 RabbitMQ 的队列中获取消息并进行处理</p></li><li><p><code>Broker</code>：标识消息队列服务器实体。接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p><ul><li><p>Broker = VHost1+Vhost2+Vhost3+…</p></li><li><p>Virtual Host = Exchange + Queue +Binding</p></li></ul></li><li><p><code>Message</code>（消息）：消息是不具名的，它是由消息头和消息体组成。消息体是不透明的，而消息头则是由一系列的可选属性组成。消息可以是任何数据(字符串、user对象，json串等)</p><ul><li><p>消息=消息头+消息体，根据routekey发送到指定的交换机 Exchange</p></li><li><p>消息头：含各种属性 routing-key(路由键)、priority(优先级)、delivery-mode(指出该消息可能需要持久性存储[路由模式])等。</p></li></ul></li><li><p><code>Connection</code>（网络连接）：publisher／consumer 和 broker 之间的 TCP 连接。</p><p>断开连接的操作只会在client端进行，Broker不会断开连接，除非出现网络故障或broker服务出现问题。</p></li><li><p><code>ConnectionFactory</code>（连接管理器）：<strong>应用程序与Rabbit之间建立连接的管理器</strong>，程序代码中使用。</p></li><li><p><code>Channel</code>（信道）：<strong>消息推送使用的通道</strong>，是多路复用连接中的一条独立的双向数据流通道。</p><ul><li>如果每次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。</li><li>Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，</li><li>AMQP method 包含了 channel id 帮助客户端和 message broker 识channel，所以 channel 之间是完全隔离的。</li><li>Channel 作为轻量级的Connection 极大减少了操作系统建立 TCP connection 的开销。</li></ul></li><li><p><code>Virtual host</code>（虚拟主机）：逻辑分组机制，类似nacos中的命名空间的概念(在代码中就是一个字符串)。出于多租户和安全因素设计，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同用户使用同一个RabbitMQ server提供的服务时，可划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等。</p><ul><li>Virtual 即 VHost</li><li>默认目录 /</li></ul></li><li><p><code>vHost</code>（虚拟主机）：每个 RabbitMQ 都能创建很多 <code>vhost</code>，每个虚拟主机其实都是 <strong>mini 版的RabbitMQ</strong>，它拥有自己的 “交换机exchange、绑定Binding、队列Queue”，更重要的是每一个vhost拥有独立的权限机制，这样就能安全地使用一个RabbitMQ服务器来服务多个应用程序，其中每个vhost服务一个应用程序。</p></li><li><p><code>Exchange</code>（交换机）：用于<strong>接受、分配消息</strong>。message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：<code>direct (point-to-point)</code>, <code>topic (publish-subscribe)</code> and <code>fanout (multicast)</code>。</p></li><li><p><code>Routing Key</code>（路由键）：用于把生成者的数据<strong>分配到交换器</strong>上。生产者将消息发送到交换机时会携带一个key，来指定路由规则。</p></li><li><p><code>Binding</code>（绑定）：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。在绑定Exchange和Queue时，会指定一个BindingKey，生产者发送消息携带的RoutingKey会和bindingKey对比，若一致就将消息分发至这个队列。</p></li><li><p><code>BindingKey</code>（绑定键）用于<strong>把交换器的消息绑定到队列</strong>上。</p></li><li><p><code>Queue</code>（队列）：用于<strong>存储</strong>生产者的消息。消息最终被送到这里等待 consumer 取走。一个message可被同时拷贝到多个queue。</p></li></ol><h3 id="RabbitMQ-的消息是怎么发送的"><a href="#RabbitMQ-的消息是怎么发送的" class="headerlink" title="RabbitMQ 的消息是怎么发送的"></a>RabbitMQ 的消息是怎么发送的</h3><p>首先客户端必须<strong>连接到 <code>RabbitMQ</code> 服务器</strong>才能发布和消费消息，<strong>客户端和 <code>rabbit server</code> 之间会创建一个 <code>tcp 连接</code><strong>，一旦 <strong><code>tcp</code> 打开并通过了认证</strong>（认证就是你发送给 rabbit 服务器的用户名和密码），你的</strong>客户端和 <code>RabbitMQ</code> 就创建了一条 <code>amqp 信道</code>（channel）</strong>，信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p><h2 id="工作模式（七种）"><a href="#工作模式（七种）" class="headerlink" title="工作模式（七种）"></a>工作模式（七种）</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180401408.png" alt="image-20250729180401408"></p><h3 id="simple-简单模式"><a href="#simple-简单模式" class="headerlink" title="simple (简单模式)"></a>simple (简单模式)</h3><p>一个消费者消费一个生产者生产的信息，消息只能被消费⼀次<br>RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。<br>RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。</p><h3 id="Work-queues-工作模式"><a href="#Work-queues-工作模式" class="headerlink" title="Work queues(工作模式)"></a>Work queues(工作模式)</h3><p>或者竞争消费者模式。工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多工人时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。<br><strong>总之</strong>：让多个消费者绑定到一个队列，共同消费队列中的消息。队列中的消息一旦消费，就会消失，消息不会重复分配给不同的消费者。</p><p><strong>适⽤场景</strong>：集群环境中做异步处理</p><h3 id="Publish-Subscribe（发布订阅模式）"><a href="#Publish-Subscribe（发布订阅模式）" class="headerlink" title="Publish/Subscribe（发布订阅模式）"></a>Publish/Subscribe（发布订阅模式）</h3><p>生产者首先投递消息到交换机，订阅了这个交换机的队列就会收到生产者投递的消息</p><p><strong>特点</strong>：</p><ul><li><p>Exchange(交换机)</p><p>只负责转发消息，不具备存储消息的能力，因此若没有任何队列与Exchange绑定，或者没有符合路由规则的队列，消息就会丢失</p></li><li><p>RoutingKey(路由键)</p><p>⽣产者将消息发给交换器时，指定的⼀个字符串，⽤来告诉交换机应该如何处理这个消息</p></li><li><p>Binding Key(绑定)</p><p>RabbitMQ中通过Binding(绑定)将交换器与队列关联起来，在绑定的时候⼀般会指定⼀个Binding Key，这样RabbitMQ就知道如何正确地将消息路由到队列了</p></li></ul><p><strong>适合场景</strong>：消息需要被多个消费者同时接收的场景(如: 实时通知或者⼴播消息)</p><h3 id="Routing（路由模式）"><a href="#Routing（路由模式）" class="headerlink" title="Routing（路由模式）"></a>Routing（路由模式）</h3><p>生产者生产消息投递到direct交换机中，扇出交换机会根据消息携带的routing Key匹配相应的队列</p><p>路由模式是发布订阅模式的变种，在发布订阅基础上，增加路由key。Exchange根据RoutingKey的规则，将数据筛选后发给对应的消费者队列。</p><p><strong>适合场景</strong>：需要根据特定规则分发消息的场景</p><p>比如系统打印日志(⽇志等级分为error, warning, info,debug)就可以通过该模式把不同⽇志发送到不同的队列, 最终输出到不同的⽂件</p><h3 id="Topics（主题模式）"><a href="#Topics（主题模式）" class="headerlink" title="Topics（主题模式）"></a>Topics（主题模式）</h3><p>生产者生产消息投递到topic交换机中，上面是完全匹配路由键，而主题模式是模糊匹配，只要有合适规则的路由就会投递给消费者。</p><p>路由模式的升级版，在routingKey的基础上，增加了通配符的功能，使之更加灵活。也称<strong>通配符模式</strong>。</p><p>Topics和Routing的基本原理相同，即⽣产者将消息发给交换机，交换机根据RoutingKey将消息转发给与RoutingKey匹配的队列，类似于正则表达式的⽅式来定义Routingkey的模式</p><p><strong>适合场景</strong>：需要灵活匹配和过滤消息的场景。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729160102405.png" alt="image-20250729160102405"></p><h3 id="RPC模式"><a href="#RPC模式" class="headerlink" title="RPC模式"></a>RPC模式</h3><p>在RPC通信的过程中, 没有⽣产者和消费者, ⽐较像咱们RPC远程调⽤, ⼤概就是通过两个队列实现了⼀个可回调的过程。</p><ul><li><p><strong>客户端：</strong></p><ol><li><p>发送请求（携带replyTo，correlationId）</p></li><li><p>接收响应（验证correlationId）</p></li></ol></li><li><p><strong>服务器：</strong></p><ol><li><p>接收请求 进行响应</p></li><li><p>发送响应（按客户端指定的replyTo，设置correlationId）</p></li></ol></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729194101402.png" alt="image-20250729194101402"></p><h3 id="发布确认模式"><a href="#发布确认模式" class="headerlink" title="发布确认模式"></a>发布确认模式</h3><p>消息丢失其中一种情况是⽣产者问题：因为应⽤程序故障、⽹络抖动等各种原因, ⽣产者没有成功向broker发送消息，可以采⽤发布确认(Publisher Confirms)机制实现。发送方确认机制好处在于它是异步的，⽣产者可以同时发布消息和等待信道返回确认消息。当消息最终得到确认之后，⽣产者可以通过回调⽅法来处理该确认消息。<br>如果RabbitMQ因自身内部错误导致消息丢失，就会发送⼀条nack(Basic.Nack)命令，⽣产者同样<strong>可以在回调方法中处理该nack命令</strong>使用发送确认机制必须要信道设置成confirm(确认)模式。发布确认有<strong>3种策略</strong>：</p><ul><li><p>单独确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Individually</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(Constants.HOST);</span><br><span class="line">        connectionFactory.setPort(Constants.PORT);                     <span class="comment">// 需要提前开放端口号</span></span><br><span class="line">        connectionFactory.setUsername(Constants.USER_NAME);            <span class="comment">// 账号</span></span><br><span class="line">        connectionFactory.setPassword(Constants.PASSWORD);          <span class="comment">// 密码</span></span><br><span class="line">        connectionFactory.setVirtualHost(Constants.VIRTUAL_HOST);     <span class="comment">// 虚拟主机</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">// 1.开启信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 2. 设置信道为confirm模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">// 3.声明队列</span></span><br><span class="line">        channel.queueDeclare(Constants.PUBLISHER_CONFIRMS_QUEUE1, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 4.发送消息，并等待确认</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Constants.MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello publisher confirms&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, Constants.PUBLISHER_CONFIRMS_QUEUE1, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">            <span class="comment">// 等待确认</span></span><br><span class="line">            channel.waitForConfirmsOrDie(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.printf(<span class="string">&quot;单独确认策略, 消息条数: %d, 耗时: %d ms \n&quot;</span>, </span><br><span class="line">                          Constants.MESSAGE_COUNT, end - start);</span><br><span class="line">        <span class="comment">// 5.关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>批量确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Batches</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 发送消息, 并进行确认</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">outstandingMessageCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Constants.MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello publisher confirms&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, Constants.PUBLISHER_CONFIRMS_QUEUE2, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">            outstandingMessageCount++;</span><br><span class="line">            <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">                channel.waitForConfirmsOrDie(<span class="number">5000</span>);</span><br><span class="line">                outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            channel.waitForConfirmsOrDie(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异步确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Asynchronously</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 4. 监听confirm</span></span><br><span class="line">        <span class="comment">// 集合中存储的是未确认的消息ID</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        SortedSet&lt;Long&gt; confirmSeqNo = Collections.synchronizedSortedSet(<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;());</span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> <span class="title class_">ConfirmListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                    confirmSeqNo.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    confirmSeqNo.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                    confirmSeqNo.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    confirmSeqNo.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 业务需要根据实际场景进行处理, 比如重发, 此处代码省略</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Constants.MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello publisher confirms&quot;</span> + i;</span><br><span class="line">            <span class="type">long</span> <span class="variable">seqNo</span> <span class="operator">=</span> channel.getNextPublishSeqNo();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, Constants.PUBLISHER_CONFIRMS_QUEUE3, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">            confirmSeqNo.add(seqNo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!confirmSeqNo.isEmpty()) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="RabbitMQ-保证消息的稳定性"><a href="#RabbitMQ-保证消息的稳定性" class="headerlink" title="RabbitMQ 保证消息的稳定性"></a>RabbitMQ 保证消息的稳定性</h1><p>提供了<strong>事务</strong>的功能。通过<strong>将 <code>channel</code> 设置为 <code>confirm</code>（确认）模式</strong>。</p><p><strong>RabbitMQ 怎么避免消息丢失</strong></p><ul><li><strong>把消息持久化磁盘</strong>，保证服务器重启消息不丢失。</li><li><strong>每个集群中至少有一个物理磁盘，保证消息落入磁盘</strong>。</li></ul><h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>RabbitMQ的消息默认存在内存中的，一旦服务器意外挂掉，消息就会丢失。消息持久化需做到三点：</p><blockquote><p>1.Exchange设置持久化：消息<strong>已经到达持久化交换器</strong>。<br>2.Queue设置持久化：<strong>声明队列</strong>必须<strong>设置持久化 <code>durable</code> 设置为 <code>true</code><strong>。消息</strong>已经到达持久化队列</strong>。<br>3.Message持久化发送：发送消息设置发送模式deliveryMode=2，代表持久化消息</p></blockquote><p><strong>RabbitMQ 持久化的缺点</strong></p><p><strong>降低了服务器的吞吐量</strong>，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可**尽量使用 <code>ssd 硬盘</code>**来缓解吞吐量的问题。</p><h2 id="ACK确认机制"><a href="#ACK确认机制" class="headerlink" title="ACK确认机制"></a>ACK确认机制</h2><p>多个消费者同时收取消息，收取消息到一半，突然某个消费者挂掉，要保证此条消息不丢失，就需要<code>acknowledgement</code>机制，就是消费者消费完成要通知服务端，服务端才将数据删除</p><p>这样就解决了，即使一个消费者出了问题，没有同步消息给服务端，还有其他的消费端去消费，保证了消息不丢的case。</p><h2 id="设置集群镜像模式"><a href="#设置集群镜像模式" class="headerlink" title="设置集群镜像模式"></a>设置集群镜像模式</h2><p>我们先来介绍下RabbitMQ三种部署模式：</p><blockquote><p>1.单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。</p><p>2.普通模式：默认的集群模式，某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。</p><p>3.镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案</p></blockquote><p>为什么设置镜像模式集群，因为队列的内容仅仅存在某一个节点上面，不会存在所有节点上面，所有节点仅仅存放消息结构和元数据。</p><h2 id="消息补偿机制"><a href="#消息补偿机制" class="headerlink" title="消息补偿机制"></a>消息补偿机制</h2><p><strong>持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？</strong></p><blockquote><p>产线网络环境太复杂，故未知数太多，消息补偿机制需要建立在消息要写入DB日志，发送日志，接受日志，两者的状态必须记录。</p><p>然后根据DB日志记录check 消息发送消费是否成功，不成功，进行消息补偿措施，重新发送消息处理。</p></blockquote><h1 id="RabbitMQ-如何实现延迟队列"><a href="#RabbitMQ-如何实现延迟队列" class="headerlink" title="RabbitMQ 如何实现延迟队列"></a>RabbitMQ 如何实现延迟队列</h1><p>RabbitMQ本身没有延迟队列，需要靠TTL和DLX模拟出延迟的效果。延迟队列的实现有两种方式：</p><ul><li>通过<strong>消息过期后进入死信交换器，再由交换器转发到延迟消费队列</strong>，实现延迟功能；</li><li>使用 <code>RabbitMQ-delayed-message-exchange</code> 插件实现延迟功能。</li></ul><h2 id="过期消息-TTL（Time-To-Live）"><a href="#过期消息-TTL（Time-To-Live）" class="headerlink" title="过期消息 TTL（Time To Live）"></a>过期消息 TTL（Time To Live）</h2><p>RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter</p><p>RabbitMQ针对队列中的消息过期时间有两种方法可以设置。</p><blockquote><ol><li><p>通过队列属性设置，队列中所有消息都有相同的过期时间。决定了在没有任何消费者的情况下，队列中的消息可以存活多久。</p></li><li><p>对消息进行单独设置，每条消息TTL可以不同。决定了在没有任何消费者消费时，消息可以存活多久。</p></li><li><p>如果消息和对列都设置过期时间，则消息的TTL以两者之间较小的那个数值为准。</p></li></ol></blockquote><h2 id="死信队列-DLX-Dead-Letter-Exchange"><a href="#死信队列-DLX-Dead-Letter-Exchange" class="headerlink" title="死信队列 DLX (Dead-Letter-Exchange)"></a>死信队列 DLX (Dead-Letter-Exchange)</h2><p>RabbitMQ的Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，如果队列内出现了dead letter，则按照这两个参数重新路由。</p><blockquote><ol><li><p>x-dead-letter-exchange：出现dead letter之后将dead letter重新发送到指定exchange</p></li><li><p>x-dead-letter-routing-key：指定routing-key发送</p></li></ol></blockquote><p>队列出现dead letter的情况有：</p><blockquote><p>1.消息或者队列的TTL过期。消息积压太多消费不过来；没有对应的消费者</p><p>2.队列达到最大长度，先到达的消息仍没有被消费</p><p>3.消息被消费端拒绝（basic.reject or basic.nack）并且requeue=false，没有让消息重新入队</p></blockquote><p>利用DLX，当消息在一个队列中变成死信后，它能被重新publish到另一个Exchange。这时候消息就可以重新被消费。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729195949777.png" alt="image-20250729195949777"></p><hr><h1 id="RabbitMQ实战（SpringBoot）"><a href="#RabbitMQ实战（SpringBoot）" class="headerlink" title="RabbitMQ实战（SpringBoot）"></a>RabbitMQ实战（SpringBoot）</h1><h2 id="Windows-环境安装"><a href="#Windows-环境安装" class="headerlink" title="Windows 环境安装"></a>Windows 环境安装</h2><p>首先可以进入rabbitMQ官网上查看 <a href="https://www.rabbitmq.com/which-erlang.html">RabbitMQ 版本要求</a> 。定位到<code>RabbitMQ and Erlang/OTP Compatibility Matrix</code>，发现当前RabbitMQ的最新版本是4.1.2，要求Erlang版本最低是26.2，最高是27.0。安装最新版RabbitMQ也就是4.1.2。</p><p>因为RabbitMQ 用Erlang 语音开发的，所以先安装Erlang 。</p><p><strong>下载安装Erlang</strong></p><ol><li><p>安装<a href="https://so.csdn.net/so/search?q=Erlang&spm=1001.2101.3001.7020">Erlang</a> （因为RabbitMQ 用Erlang 语音开发的，所已我们先安装Erlang ）。进入到Erlang官网下载 <a href="https://www.erlang.org/downloads">Erlang下载地址</a> 。选择Erlang27.0 windows 64位的<a href="https://so.csdn.net/so/search?q=%E5%AE%89%E8%A3%85%E5%8C%85&spm=1001.2101.3001.7020">安装包</a>，点击下载。</p></li><li><p>找到下载的Erlang安装包，右键以管理员身份运行。按照步骤next , 安装路径D:\IDEA\tools下，注意这里的路径<strong>不能包含中文</strong>。</p></li><li><p>安装完成后配置环境变量</p><blockquote><p>新建系统变量ERLANG_HOME，变量值为D:\IDEA\tools\Erlang OTP。</p><p>path中添加环境变量 %ERLANG_HOME%\bin 。</p></blockquote></li><li><p>验证Erlang是否安装成功，打开cmd 输入 erl 。出现版本信息则说明安装成功</p></li></ol><p><strong>安装RabbitMQ</strong></p><ol><li><p>进入到RabbitMQ官网下载安装包，<a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v4.1.2/rabbitmq-server-4.1.2.exe">RabbitMQ下载地址</a> ，或者GitHUb下载：<a href="https://github.com/rabbitmq/rabbitmq-server/releases">GitHub</a>。</p></li><li><p>找到下载的安装包右键以管理员身份运行。按照步骤next , 安装路径D:\IDEA\tools下</p></li><li><p>安装完成后，在win菜单下找到 RabbitMQ command prompt。</p></li><li><p>输入命令，激活rabbitmq的ui界面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins.bat <span class="built_in">enable</span> rabbitmq_management </span><br></pre></td></tr></table></figure></li><li><p>激活完成后，重启rabbitmq。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop RabbitMQ</span><br><span class="line">net start RabbitMQ</span><br></pre></td></tr></table></figure></li><li><p>重启完成后，验证是否成功，登录到 localhost:15672,出现如下图登录页面即安装成功。</p></li><li><p>RabbitMQ默认的登录用户和密码为 guest guest 。</p></li><li><p>登录成功后进入到页面，RabbitMQ的安装就算完成。</p></li></ol><h2 id="Linux-环境安装"><a href="#Linux-环境安装" class="headerlink" title="Linux 环境安装"></a>Linux 环境安装</h2><ol><li><p>进入到RabbitMQ官网下载安装包，<a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v4.1.2/rabbitmq-server-4.1.2-1.el8.noarch.rpm">RabbitMQ下载地址</a> 。</p></li><li><p>进入<a href="https://github.com/rabbitmq/erlang-rpm/releases">GitHub|rabbitmq|erlang-rpm</a>选择RabbitMQ支持的版本下载，或者进入到Erlang官网下载 <a href="https://www.erlang.org/downloads">Erlang下载地址</a> 。</p></li><li><p><strong>将下载好的安装文件 上传到服务器</strong>，上传在/root目录下</p></li><li><p>安装Erlang</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum -y install esl-erlang_23.0.2-1_centos_7_amd64.rpm </span><br><span class="line"><span class="comment"># 验证是否安装成功</span></span><br><span class="line">erl</span><br></pre></td></tr></table></figure></li><li><p>安装RabbitMQ</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum -y install rabbitmq-server-3.8.5-1.el7.noarch.rpm </span><br><span class="line"><span class="comment"># 安装RabbitMQ 可视化管理控制台 它是以插件的形式存在的。查看所有的插件列表</span></span><br><span class="line">rabbitmq-plugins list</span><br><span class="line"><span class="comment"># [ ] rabbitmq_management x.x.x 为管理系统的插件，安装命令如下</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure></li><li><p>启动RabbitMQ</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动RabbitMQ</span></span><br><span class="line">systemctl start rabbitmq-server.service</span><br><span class="line"><span class="comment"># 确认是否启动成功</span></span><br><span class="line">systemctl status rabbitmq-server.service</span><br></pre></td></tr></table></figure></li><li><p>访问RabbitMQ</p><p>端口为：15672，默认的用户名：guest 密码：guset。访问地址是：自己的服务器的ip+端口（如 <a href="http://192.168.10.11:15672）">http://192.168.10.11:15672）</a></p><p>如果不是在localhost本机登录会提示错误：User can only log in via localhost。<strong>解决办法： 让它可以进行远程登录，需要回到安装RabbitMQ的服务器</strong>进行如下操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /etc/rabbitmq/</span></span><br><span class="line">[root@localhost rabbitmq]<span class="comment"># ll</span></span><br><span class="line"><span class="comment"># 发现只有一个文件 enabled_plugins</span></span><br><span class="line"><span class="comment"># 编辑rabbitmq.config 添加[&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].</span></span><br><span class="line">[root@localhost rabbitmq]<span class="comment"># vi rabbitmq.config</span></span><br><span class="line"><span class="comment"># 添加[&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].后保存并退出，然后重启RabbitMQ</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl restart rabbitmq-server.service</span></span><br></pre></td></tr></table></figure><p>这时候再访问并登录就可以了</p></li></ol><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><h2 id="RabiitMQ-依赖引入"><a href="#RabiitMQ-依赖引入" class="headerlink" title="RabiitMQ 依赖引入"></a>RabiitMQ 依赖引入</h2><p>首先在已经搭建好的SpringBoot项目的pom.xml 中引入RabiitMQ的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- AMQO 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="RabbitMQ-配置"><a href="#RabbitMQ-配置" class="headerlink" title="RabbitMQ 配置"></a>RabbitMQ 配置</h2><ol><li><p>在application.yml配置文件中进行<a href="https://so.csdn.net/so/search?q=RabbitMQ&spm=1001.2101.3001.7020">RabbitMQ</a>的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment">#  服务器</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span></span><br><span class="line">    <span class="comment">#  用户名</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment">#  密码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment">#  虚拟主机</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="comment">#  端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="comment">#  监听相关配置</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="comment">#  消费者的最小数量</span></span><br><span class="line">        <span class="attr">concurrency:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment">#  消费者的最大数量</span></span><br><span class="line">        <span class="attr">max-concurrency:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment">#  限制消费者 每次只处理一条消息，处理完毕后再处理下一条消息</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#  启动时是否默认启动容器 默认true</span></span><br><span class="line">        <span class="attr">auto-startup:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">#  当消息被拒绝时，是否重新进入队列</span></span><br><span class="line">        <span class="attr">default-requeue-rejected:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">#  模板相关配置</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="comment">#  开启重试  默认false</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">#  重试时间 默认1000ms</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span></span><br><span class="line">        <span class="comment">#  重试的次数  默认是3</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span></span><br><span class="line">        <span class="comment">#  重试时间的最大间隔时间 默认10000ms</span></span><br><span class="line">        <span class="attr">max-interval:</span> <span class="string">10000ms</span></span><br><span class="line">        <span class="comment">#  重试的间隔乘数  比如配2.0 第一次就间隔10s 第二次 间隔20s 第三次间隔40s ****</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>创建配置类 RabbitMQConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;queue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>封装发送消息和接收消息的类：对消息的发送和消息的接受我们都分别进行封装</p><p>MqSender：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqSender</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;发送消息&quot;</span>+msg);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;queue&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MqReceiver：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqReceiver</span>&#123;</span><br><span class="line">    <span class="comment">//监听配置的队列</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(Object msg)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收消息：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="RabbitMQ-测试"><a href="#RabbitMQ-测试" class="headerlink" title="RabbitMQ 测试"></a>RabbitMQ 测试</h2><ol><li><p>随便在一个Contoller类中写一个测试方法。此处在TUserController中添加一个测试方法如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TUserController</span> &#123;</span><br><span class="line">      <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MqSender mqSender;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/mq&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mq</span><span class="params">()</span>&#123;</span><br><span class="line">        mqSender.send(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动项目进行测试</p><p>测试路径为 <a href="http://localhost:8080/user/mq%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0IEAR%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BC%9A%E8%BE%93%E5%87%BA%E6%88%91%E4%BB%AC%E7%9A%84%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%A6%82%E4%B8%8B">http://localhost:8080/user/mq，可以看到IEAR控制台会输出我们的测试数据如下</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... com.xxxxx.seckilldemo.rabbitmq.MqSender  : 发送消息Hello</span><br><span class="line">... com.xxxxx.seckilldemo.rabbitmq.MqReceiver  : 接收消息：(Body:<span class="string">&#x27;Hello&#x27;</span> MessageProperties [headers=&#123;&#125;, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=<span class="literal">false</span>, receivedExchange=, receivedRoutingKey=queue, deliveryTag=1, consumerTag=amq.ctag-IrqC4b7RL3mg1rMy8NefPQ, consumerQueue=queue])</span><br></pre></td></tr></table></figure><p>项目启动后RabiitMQ的控制台会显示有一个连接如下图</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180214185.png" alt="image-20250729180214185"></p></li></ol><hr><h1 id="RabbitMQ-集群"><a href="#RabbitMQ-集群" class="headerlink" title="RabbitMQ 集群"></a>RabbitMQ 集群</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RabbitMQ 的集群分两种模式，一种是默认集群模式，一种是镜像集群模式；</p><p>在RabbitMQ集群中所有的节点(一个节点就是一个RabbitMQ的broker服务器) 被归为两类：一类是磁盘节点,一类是内存节点； </p><p>磁盘节点会把集群的所有信息(比如交换机、绑定、队列等信息)持久化到磁盘中，而内存节点只会将这些信息保存到内存中，如果该节点宕机或重启，内存节点的数据会全部丢失，而磁盘节点的数据不会丢失；</p><p><strong>RabbitMQ 集群主要有以下两个用途：</strong></p><ul><li><strong>高可用：</strong>某个服务器出现问题，整个 <code>RabbitMQ</code> 还可以继续使用；</li><li><strong>高容量：</strong>集群可以承载更多的消息量。</li></ul><p><strong>RabbitMQ 集群搭建需要注意的问题</strong></p><p>各<strong>节点之间使用<code>“–link”</code>连接</strong>，此属性不能忽略。<br>各节点使用的 <strong><code>erlang cookie</code> 值必须相同</strong>，此值相当于“秘钥”的功能，<strong>用于各节点的认证</strong>。<br><strong>整个集群中必须包含一个磁盘节点</strong>。</p><h2 id="默认集群模式"><a href="#默认集群模式" class="headerlink" title="默认集群模式"></a>默认集群模式</h2><h3 id="默认集群简介"><a href="#默认集群简介" class="headerlink" title="默认集群简介"></a>默认集群简介</h3><p>默认集群模式也叫 <strong>普通集群模式</strong>、或者 <strong>内置集群模式</strong>；普通集群，也叫做标准集群（classic cluster）</p><p><strong>元数据</strong></p><p><strong>队列元数据</strong>：队列名称和属性(是否可持久化,是否自动删除)</p><p><strong>交换器元数据</strong>：交换器名称、类型和属性</p><p><strong>绑定元数据</strong>：交换器和队列的绑定列表</p><p><strong>vhost元数据</strong>：vhost内的相关属性，如安全属性等;</p><p>当用户访问其中任何一个RabbitMQ节点时，查询到的<code>queue／user／exchange/vhost</code>等信息都是相同的；</p><p><strong>数据同步特点</strong></p><p>RabbitMQ默认集群模式只会把交换机、队列、虚拟主机等元数据信息在各个节点同步，而具体队列中的消息内容不会在各个节点中同步，队列的具体信息数据只在队列的拥有者节点保存，其他节点只知道队列的元数据和指向该节点的指针，所以其他节点接收到不属于该节点队列的消息时会将该消息传递给该队列的拥有者节点上；</p><p>集群不复制队列内容和状态到所有节点的原因</p><ul><li><p>节省存储空间；</p></li><li><p>提升性能；</p></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180016020.png" alt="image-20250729180016020"></p><p>若消息需要复制到集群中每个节点，网络开销不可避免，持久化消息还需要写磁盘，占用磁盘空间。</p><p><strong>数据访问过程</strong></p><p>若有一个消息生产者或者消息消费者通过<code>amqp-client</code>的客户端连接到节点1进行消息的发送或接收，那么此时集群中的消息收发只与节点1相关，这个没有任何问题；</p><p>若消息生产者所连接的是节点2或者节点3，此时队列1的完整数据不在该两个节点上，那么在发送消息过程中这两个节点主要起了一个路由转发作用，根据这两个节点上的元数据（也就是<code>指向queue</code>的<code>owner node</code>的指针）转发至节点1上，最终发送的消息还是会存储至节点1的队列1上；</p><p>同样，若消息消费者所连接的节点2或者节点3，那这两节点也会作为路由节点起转发作用，将会从节点1的队列1中获取消息进行消费；</p><h3 id="默认集群特征"><a href="#默认集群特征" class="headerlink" title="默认集群特征"></a>默认集群特征</h3><ol><li><p>集群中的各个节点是可以共享数据的，比如交换机信息、队列元信息，但不包含队列中的消息。</p><p>什么是元信息？ 元信息，就是指队列的描述信息，队列名、队列在哪一个节点中，但是不包括消息本身。</p><p>不包括消息本身是什么意思？ 假设我现在两个节点 mq1 和 mq2，然后有一个消费者订阅了 mq2 中的一个队列，但该消费者在访问时，不想小心访问到了 mq1，不过由于在 mq1 上持有 mq2 的元信息，所以他知道 mq2 在哪，因此就可以通过这个元数据找到 mq2 这个节点，然后拿到我们想要的数据（这就类似于 mq1 上有 指向 mq2 的指针，通过指针就可以找到 mq2）。</p></li><li><p>基于第一个特点的元信息，可以在访问集群中的某个节点时，发现队列不在该节点，就可以通过要访问数据的所在节点的元信息，进一步的拿到这个节点的所有数据。</p></li><li><p>如果队列所在节点宕机，那么消息就会丢失。</p><p> 这里有点类似于 redis 集群中的分片处理，每一个集群上存储全集队列的一部分队列，因此这个节点挂了，消息必然会丢失.</p></li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>安装三台RabbitMQ机器：先安装一台MQ，然后克隆两台就行</p></li><li><p>设置IP地址：启动并设置三台机器的IP</p><p><strong>修改配置文件方式</strong></p></li><li><h5 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hostnamectl set-hostname rabbit11</span><br></pre></td></tr></table></figure></li><li><h5 id="修改-etc-hosts-文件"><a href="#修改-etc-hosts-文件" class="headerlink" title="修改/etc/hosts 文件"></a>修改/etc/hosts 文件</h5><p>首先需要配置一下hosts文件，因为RabbitMQ集群节点名称是读取hosts文件得到的；注意三台机机器都需要配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line">192.168.1.11 rabbit11</span><br><span class="line">192.168.1.12 rabbit12</span><br><span class="line">192.168.1.13 rabbit13</span><br></pre></td></tr></table></figure></li><li><h5 id="重启网络"><a href="#重启网络" class="headerlink" title="重启网络"></a>重启网络</h5><p>三台机器均重启网络,使节点名生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart NetworkManager</span><br><span class="line"><span class="comment"># 低版本CentOS使用如下命令</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure></li><li><h5 id="重新连接xshell"><a href="#重新连接xshell" class="headerlink" title="重新连接xshell"></a>重新连接xshell</h5><p>重启后三台机器的xshell均退出，然后再重新连接，这样才能刷新主机的名字</p></li><li><h5 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h5><p>三台机器均需关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld  <span class="comment">##关闭防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld  <span class="comment">##开机不启动防火墙</span></span><br><span class="line">systemctl status firewalld    <span class="comment">##查看防火墙状态</span></span><br></pre></td></tr></table></figure></li><li><h5 id="修改-erlang-cookie文件"><a href="#修改-erlang-cookie文件" class="headerlink" title="修改.erlang.cookie文件"></a>修改.erlang.cookie文件</h5><p>三台机器 .erlang.cookie文件保持一致。<strong>由于是clone出的三台机器，所以肯定是一样的</strong></p><ul><li><p>如果使用解压缩方式安装的RabbitMQ，那么该文件会在用户名目录下，也就是{用户名}/.erlang.cookie；</p></li><li><p>如果使用rpm安装包方式进行安装,那么这个文件会在/var/lib/rabbitmq目录下；</p></li><li><p><strong>注意 .erlang.cookie的权限为400，目前已经是400</strong></p></li></ul></li><li><h5 id="启动MQ"><a href="#启动MQ" class="headerlink" title="启动MQ"></a>启动MQ</h5><p>分别启动三台机器上的rabbitmq</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure></li><li><h5 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h5><ul><li><p><strong>查看rabbitmq状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl status</span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">Status of node rabbit@rabbit11...</span><br><span class="line">[]</span><br><span class="line">Runtime</span><br></pre></td></tr></table></figure></li><li><p><strong>查看集群状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br><span class="line"><span class="comment"># 输出如下： rabbit@rabbit11集群节点名称，Disk Nodes节点类型是磁盘节点</span></span><br><span class="line">Cluster status of node rabbit@rabbit11</span><br><span class="line">Basics</span><br><span class="line">rabbitarabbit11Cluster name:Total CPU cores available cluster-wide: 4</span><br><span class="line">Cluster Tags</span><br><span class="line">(none)</span><br><span class="line">Disk Nodes</span><br><span class="line">rabbitarabbit11</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="构建集群"><a href="#构建集群" class="headerlink" title="构建集群"></a>构建集群</h5><ul><li><p>加入节点1</p><p>在rabbitmq12机器上执行命令，让12的rabbitmq加入集群</p><p>注意：一定要先停止节点，将节点重置之后才能加入集群，否则数据同步会出现混乱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先停止rabbitmq</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="comment"># 重置rabbitmq</span></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"><span class="comment"># 节点加入集群:rabbit@rabbit11是主节点的节点名,在集群状态中可以查看到节点名称</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@rabbit11 --ram</span><br><span class="line"><span class="comment"># 启动节点</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></li><li><p>添加节点2</p><p>在rabbit13节点上也<strong>执行同样的命令</strong>，使rabbit13节点也加入到集群中。当然也可以让rabbit13作为一个磁盘节点</p></li></ul></li><li><h5 id="添加用户和权限"><a href="#添加用户和权限" class="headerlink" title="添加用户和权限"></a>添加用户和权限</h5><p>操作一个节点，添加用户和权限等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出用户</span></span><br><span class="line">rabbitmqctl list_users</span><br><span class="line"><span class="comment"># 添加用户</span></span><br><span class="line">rabbitmqctl add_user admin 123456</span><br><span class="line"><span class="comment"># 查看权限</span></span><br><span class="line">rabbitmqctl list_permissions</span><br><span class="line"><span class="comment"># 设置权限</span></span><br><span class="line">rabbitmqctl set_permissions admin <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span><br><span class="line"><span class="comment"># 设置角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure></li><li><h5 id="启动web控制台"><a href="#启动web控制台" class="headerlink" title="启动web控制台"></a>启动web控制台</h5><p>启动web控制台插件。注意：三台机器都要启动，因为插件不属于元数据，因此需要分别启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入插件目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/rabbitmq_server-4.0.7/plugins/</span><br><span class="line"><span class="comment"># 启动web端插件</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management </span><br></pre></td></tr></table></figure></li><li><h5 id="创建虚拟主机"><a href="#创建虚拟主机" class="headerlink" title="创建虚拟主机"></a>创建虚拟主机</h5><p>使用web浏览器添加一个虚拟主机：longdidi</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180621236.png" alt="image-20250729180621236"></p></li><li><h5 id="再次查看集群状态"><a href="#再次查看集群状态" class="headerlink" title="再次查看集群状态"></a>再次查看集群状态</h5><p>当执行完操作以后在浏览器访问web管控台来看看效果；随便在哪个节点打开web管控台都能看到集群环境各节点的信息；也可以使用”rabbitmqctl cluster_status”查看集群状态；</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180657444.png" alt="image-20250729180657444"></p></li><li><h5 id="验证集群"><a href="#验证集群" class="headerlink" title="验证集群"></a>验证集群</h5><ol><li><p>创建队列</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180728567.png" alt="image-20250729180728567"></p></li><li><p>创建交换机</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180804318.png" alt="image-20250729180804318"></p></li><li><p>绑定交换机与队列</p><ul><li><p>进入交换机</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181126120.png" alt="image-20250729181126120"></p></li><li><p>绑定交换机与队列</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181204097.png" alt="image-20250729181204097"></p></li></ul></li><li><p>发布消息</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181229138.png" alt="image-20250729181229138"></p></li><li><p>查看消息</p><p>在任意节点查看消息</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181259889.png" alt="image-20250729181259889"></p></li><li><p>停止主节点rabbit@rabbit11节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poweroff</span><br><span class="line"><span class="comment"># Connection Closing...socket close.</span></span><br><span class="line"><span class="comment"># Connection closed by foreign host.</span></span><br></pre></td></tr></table></figure></li><li><p>再在其它节点查看消息</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181458290.png" alt="image-20250729181458290"></p></li></ol></li><li><h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmgctl stop_app</span><br><span class="line">rabbitmgctl reset</span><br><span class="line">rabbitmgctl start_app</span><br><span class="line">rabbitmgctl cluster_status</span><br><span class="line">rabbitmgctl forget_cluster_node rabbit@node2 <span class="comment"># (node1节点上执行)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="节点原理"><a href="#节点原理" class="headerlink" title="节点原理"></a>节点原理</h3><p>RabbitMQ底层是通过Erlang架构来实现的，所以rabbitmqctl会启动Erlang节点，并基于Erlang节点来使用Erlang系统连接RabbitMQ节点，在连接过程中需要正确的Erlang Cookie和节点名称，Erlang节点通过交换Erlang Cookie以获得认证。</p><h2 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h2><h3 id="镜像集群模式简介"><a href="#镜像集群模式简介" class="headerlink" title="镜像集群模式简介"></a>镜像集群模式简介</h3><p>镜像模式是基于默认集群模式加上一定的配置得来的；在默认模式下的RabbitMQ集群，它会把所有节点的交换机、绑定、队列的元数据进行复制确保所有节点都有一份相同的元数据信息，但是队列数据分为两种：</p><ul><li><p>一种是队列的元数据信息(比如队列的最大容量,队列的名称等配置信息)</p></li><li><p>一种是队列里面的消息</p></li></ul><p>镜像模式则是把所有的队列数据完全同步，包括元数据信息和消息数据信息，当然这对性能肯定会有一定影响，当对数据可靠性要求较高时，可以使用镜像模式。</p><h3 id="镜像集群模式特征"><a href="#镜像集群模式特征" class="headerlink" title="镜像集群模式特征"></a>镜像集群模式特征</h3><p>镜像集群，本质上就是主从模式。主要有以下几个特性：</p><ol><li><p><strong>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份</strong></p><p>这里就和之前的普通交换机不一样了，不仅仅是交换机可以共享，队列中的消息大家也可以共享了。</p></li><li><p><strong>创建队列的节点被称为该队列的主节点，备份到的其它节点叫做该队列的镜像节点</strong></p><p>比如现在有三个节点，现在我再 mq1 上创建了一个队列 q1，因此 mq1 就是主节点，那么还可以给他挑一个镜像节点，比如我再 mq2 上做一个镜像，那么 mq2 就会去找 mq1 同步 q1 的所有数据。</p></li><li><p><strong>一个队列的主节点可能是另一个队列的镜像节点</strong></p><p>也就是说，主节点和镜像节点是可以相互备份的。比如 q1 在 mq1 上，给 mq2 备份了一份，q2 实在 mq2 上，给 mq3 备份了一份，q3 在 mq3 上的，给 mq1 备份了一份，那么这个时候，mq1 就是 q1 的主节点，同时也是 q3 的镜像节点。</p></li><li><p><strong>所有操作都是主节点完成，然后同步给镜像节点 。</strong></p></li><li><p>主节点宕机后，镜像节点会替代成新的主节点</p></li></ol><h3 id="镜像模式配置-3-X版本"><a href="#镜像模式配置-3-X版本" class="headerlink" title="镜像模式配置 3.X版本"></a>镜像模式配置 3.X版本</h3><p>在默认集群模式的基础上执行如下命令就可以把一个默认的集群模式变成镜像集群模式。镜像队列配置语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority]</span><br></pre></td></tr></table></figure><ul><li><p>rabbitmqctl set_policy：固定写法</p></li><li><p>-p Vhost：可选参数,设置虚拟主机的名字(针对指定vhost下的queue进行设置)</p></li><li><p>Name:：设置策略的名称(自己取个名字就可以)</p></li><li><p>Pattern:：queue的匹配模式(正则表达式)；^表示所有的队列都是镜像队列</p></li><li><p>Definition：镜像定义(json格式)，包括三个部分ha-mode、ha-params、ha-sync-mode</p><ul><li><p>ha-mode：指明镜像队列的模式，有效值为 all/exactly/nodes</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all：表示在集群中所有的节点上进行镜像</span><br><span class="line">exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span><br><span class="line">nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</span><br></pre></td></tr></table></figure></li><li><p>ha-params：ha-mode模式需要用到的参数</p></li><li><p>ha-sync-mode：队列中消息的同步方式,有效值为automatic(自动向master同步数据)和manual(手动向master同步数据)</p></li></ul></li><li><p>priority：可选参数，指的是policy策略的优先级；</p></li></ul><p>示例：比如想配置所有名字开头为policy_的队列进行镜像，镜像数量为2，那么命令如下(在任意节点执行如下命令)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy -p longdidi my_policy <span class="string">&quot;^policy_&quot;</span>  <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span>  </span><br></pre></td></tr></table></figure><ol><li><p><strong>同步所有数据</strong></p><p>所有节点、所有虚拟主机、所有队列 都进行镜像。如果要在所有节点所有队列上进行镜像则在任意节点执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy my-all <span class="string">&quot;^&quot;</span>  <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span>   </span><br></pre></td></tr></table></figure></li><li><p><strong>同步指定数据</strong></p><p>针对某个虚拟主机进行镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy -p longdidi my-all <span class="string">&quot;^&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;: &quot;exactly&quot;, &quot;ha-params&quot;: 2, &quot;ha-sync-mode&quot;: &quot;automatic&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="镜像模式配置-4-X版本"><a href="#镜像模式配置-4-X版本" class="headerlink" title="镜像模式配置 4.X版本"></a>镜像模式配置 4.X版本</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729182945585.png" alt="image-20250729182945585"></p><h2 id="仲裁队列"><a href="#仲裁队列" class="headerlink" title="仲裁队列"></a>仲裁队列</h2><p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p><ol><li>与镜像队列一样，都是主从模式，支持主从数据同步</li><li>使用非常简单，没有复杂的配置</li><li>主从同步基于Raft协议，强一致</li></ol><p>在 SpringAMQP 中创建仲裁队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">quorumQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;quorum.queue&quot;</span>)     <span class="comment">// 持久化 </span></span><br><span class="line">            .quorum()                     <span class="comment">// 仲裁队列</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringAMQP连接集群，只需要在yaml中配置即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8071,</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8072,</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8073</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">1111</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><h2 id="SpringBoot集成集群"><a href="#SpringBoot集成集群" class="headerlink" title="SpringBoot集成集群"></a>SpringBoot集成集群</h2><h3 id="重点连接配置"><a href="#重点连接配置" class="headerlink" title="重点连接配置"></a>重点连接配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment"># 连接单台rabbitmq 服务器的地址</span></span><br><span class="line">    <span class="comment"># host: 192.168.1.101</span></span><br><span class="line">    <span class="comment"># 连接单台rabbitmq 服务器的端口</span></span><br><span class="line">    <span class="comment"># port: 5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启生产者的确认模式,设置关联模式</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#开启return模式</span></span><br><span class="line">    <span class="comment"># 开启消费者手动确认</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span><span class="string">:5672,192.168.1.12:5672,192.1.13:5672</span></span><br></pre></td></tr></table></figure><p>测试模块:rabbitmq-10-cluster-01</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置MQ"><a href="#配置MQ" class="headerlink" title="配置MQ"></a>配置MQ</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cluster-learn01</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment"># 连接单台rabbitmq 服务器的地址</span></span><br><span class="line">    <span class="comment"># host: 192.168.1.101</span></span><br><span class="line">    <span class="comment"># 连接单台rabbitmq 服务器的端口</span></span><br><span class="line">    <span class="comment"># port: 5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启生产者的确认模式,设置关联模式</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#开启return模式</span></span><br><span class="line">    <span class="comment"># 开启消费者手动确认</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span><span class="string">:5672,192.168.1.12:5672,192.1.13:5672</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.4</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="comment">#password: 123456</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># 0号数据库</span></span><br></pre></td></tr></table></figure><h3 id="定义MQ队列"><a href="#定义MQ队列" class="headerlink" title="定义MQ队列"></a>定义MQ队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.longdidi.constants.RabbitMQConstant;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机,使用durable()方法设置持久化</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列,durable()方法就是持久化</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, @Nullable Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常交换机和正常队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建生产者、消费者"><a href="#创建生产者、消费者" class="headerlink" title="创建生产者、消费者"></a>创建生产者、消费者</h3><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.longdidi.constants.RabbitMQConstant;</span><br><span class="line"><span class="keyword">import</span> com.longdidi.vo.Orders;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageDeliveryMode;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 这个对象可以进行序列化和反序列化(json格式)</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法执行后自动执行</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 开启生产者的确定模式</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(</span><br><span class="line">                (correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;消息没有到达交换机,原因为:&#123;&#125;&quot;</span>, cause);</span><br><span class="line">                        <span class="comment">// TODO 重发消息或者记录错误日志</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">                returnedMessage -&gt; &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;消息没有从交换机正确的投递(路由)到队列,原因为:&#123;&#125;&quot;</span>, returnedMessage.getReplyText());</span><br><span class="line">                    <span class="comment">// TODO 记录错误日志,给程序员发短信或者或者邮件</span></span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建订单</span></span><br><span class="line">            <span class="type">Orders</span> <span class="variable">orders1</span> <span class="operator">=</span> Orders.builder()</span><br><span class="line">                    .orderId(<span class="string">&quot;order_12345&quot;</span>).orderName(<span class="string">&quot;买的手机&quot;</span>)</span><br><span class="line">                    .orderMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">2356</span>)).orderTime(<span class="keyword">new</span> <span class="title class_">Date</span>()).build();</span><br><span class="line">            <span class="comment">//转成json</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">strOrders1</span> <span class="operator">=</span> objectMapper.writeValueAsString(orders1);</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            <span class="comment">//设置单条消息的持久化,默认就是持久化</span></span><br><span class="line">            messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(strOrders1.getBytes())</span><br><span class="line">                    .andProperties(messageProperties).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Orders</span> <span class="variable">orders2</span> <span class="operator">=</span> Orders.builder() .orderId(<span class="string">&quot;order_12345&quot;</span>).orderName(<span class="string">&quot;买的手机&quot;</span>)</span><br><span class="line">                    .orderMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">2356</span>)).orderTime(<span class="keyword">new</span> <span class="title class_">Date</span>()).build();</span><br><span class="line">            <span class="type">String</span> <span class="variable">strOrders2</span> <span class="operator">=</span> objectMapper.writeValueAsString(orders2);</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            <span class="comment">//设置单条消息的持久化,默认就是持久化</span></span><br><span class="line">            messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(strOrders2.getBytes())</span><br><span class="line">                    .andProperties(messageProperties).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.longdidi.constants.RabbitMQConstant;</span><br><span class="line"><span class="keyword">import</span> com.longdidi.vo.Orders;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME1&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取消息的唯一标识</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="comment">// 使用objectmapper把字节数组反序列化成对象</span></span><br><span class="line">        <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> objectMapper.readValue(message.getBody(), Orders.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;&quot;</span>, orders.toString());</span><br><span class="line">            <span class="comment">// 如果不存在就在redis中存储</span></span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">setResult</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(<span class="string">&quot;idempotent:&quot;</span> + orders.getOrderId(), orders.getOrderId());</span><br><span class="line">            <span class="keyword">if</span> (setResult) &#123;</span><br><span class="line">                <span class="comment">// TODO 向数据库插入订单等</span></span><br><span class="line">                log.info(<span class="string">&quot;向数据库插入订单&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 手动确认</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息处理出现问题&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义常量、实体类"><a href="#定义常量、实体类" class="headerlink" title="定义常量、实体类"></a>定义常量、实体类</h3><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.idempotent.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME1</span> <span class="operator">=</span> <span class="string">&quot;queue.idempotent.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME1</span> <span class="operator">=</span> <span class="string">&quot;key.idempotent.normal.1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal orderMoney;</span><br><span class="line">    <span class="keyword">private</span> Date orderTime; <span class="comment">// 下单时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong>发送消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.longdidi.service.SendMessageService;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rabbitmq10Cluster01Application</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Rabbitmq10Cluster01Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SendMessageService sendMessageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序一启动就会运行该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sendMessageService.sendMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Tue Jul 29 18:41:22 GMT+08:00 2025</span><br><span class="line">接收到的消息为:0rders(orderId=order_12345,orderName=买的手机,orderMoney=2356....</span><br><span class="line">接收到的消息为:0rders(orderId=order_12345,orderName=买的手机,orderMoney=2356....</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ-节点的类型"><a href="#RabbitMQ-节点的类型" class="headerlink" title="RabbitMQ 节点的类型"></a>RabbitMQ 节点的类型</h2><p><strong>磁盘节点：</strong>消息会存储到磁盘。<br><strong>内存节点：</strong>消息都存储在内存中，<strong>重启服务器消息丢失，性能高于磁盘类型</strong>。</p><h2 id="RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h2><p>不是，原因有以下两个：</p><ul><li><strong>存储空间的考虑：</strong>若每个节点都拥有所有队列的完全拷贝，新增节点不但没有新增存储空间，反而<strong>增加了冗余数据</strong>；</li><li><strong>性能的考虑：</strong>若每条消息都需要完整拷贝到每一个集群节点，那新增节点并<strong>没有提升处理消息的能力</strong>，最多是保持和单节点相同的性能<strong>甚至是更糟</strong>。</li></ul><h2 id="RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么"><a href="#RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么" class="headerlink" title="RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么"></a>RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么</h2><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p><ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li></ul><p>唯一磁盘节点崩溃了，<strong>集群可以保持运行，但不能更改任何东西</strong></p><h2 id="RabbitMQ-对集群节点停止顺序有要求吗"><a href="#RabbitMQ-对集群节点停止顺序有要求吗" class="headerlink" title="RabbitMQ 对集群节点停止顺序有要求吗"></a>RabbitMQ 对集群节点停止顺序有要求吗</h2><p><code>RabbitMQ</code> 对集群的停止顺序是有要求的，应该<strong>先关闭内存节点，最后再关闭磁盘节点。若顺序恰好相反的话，可能会造成消息的丢失</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;是实现了高级&lt;a href=&quot;https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4751675?fromModule=lemma_inlink</summary>
      
    
    
    
    <category term="Middleware" scheme="https://southernfish.github.io/categories/Middleware/"/>
    
    <category term="MQ" scheme="https://southernfish.github.io/categories/Middleware/MQ/"/>
    
    
    <category term="RabbitMQ" scheme="https://southernfish.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="https://southernfish.github.io/pages/framwork/mybatis/"/>
    <id>https://southernfish.github.io/pages/framwork/mybatis/</id>
    <published>2025-07-29T05:25:36.000Z</published>
    <updated>2025-09-17T07:51:48.702Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis 是一款优秀的<a href="https://baike.baidu.com/item/%E6%8C%81%E4%B9%85%E5%B1%82/3584971?fromModule=lemma_inlink">持久层</a>框架，它支持定制化 <a href="https://baike.baidu.com/item/SQL/86007?fromModule=lemma_inlink">SQL</a>、<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1240317?fromModule=lemma_inlink">存储过程</a>以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取<a href="https://baike.baidu.com/item/%E7%BB%93%E6%9E%9C%E9%9B%86/11040011?fromModule=lemma_inlink">结果集</a>。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 <a href="https://baike.baidu.com/item/POJOs/6656035?fromModule=lemma_inlink">POJOs</a>(Plain Ordinary Java Object，普通的 Java对象)映射成数据库中的记录。本文简单记录一些关于MyBatis的问题。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/125818307">Maven基础&amp;MyBatis</a></p><p><a href="https://sayyy.blog.csdn.net/article/details/87878690">【spring boot】 mybatis配置双数据源/多数据源</a></p></blockquote><h1 id="Mybatis概述"><a href="#Mybatis概述" class="headerlink" title="Mybatis概述"></a>Mybatis概述</h1><h2 id="Mybatis、持久层、框架简介"><a href="#Mybatis、持久层、框架简介" class="headerlink" title="Mybatis、持久层、框架简介"></a>Mybatis、持久层、框架简介</h2><p><a href="https://mybatis.net.cn/">MyBatis中文网</a></p><ul><li>MyBatis 是一款优秀的<strong>持久层框架</strong>，用于<strong>简化 JDBC 开发</strong></li><li>MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github</li><li>官网：<a href="https://mybatis.org/mybatis-3/zh/index.html">mybatis – MyBatis 3 | 简介</a></li></ul><p><strong>持久层：</strong></p><ul><li><p>负责将数据保存到数据库的那一层代码。</p><p>以后开发我们会<strong>将操作数据库的Java代码作为持久层</strong>。而<strong>Mybatis就是对jdbc代码进行了封装</strong>。</p></li><li><p>JavaEE三层架构：表现层做页面展示、业务层做逻辑处理、持久层对数据持久化</p></li><li><p>下图是持久层框架的使用占比。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250728215016340.png" alt="image-20250728215016340"></p></li></ul><p><strong>框架：</strong></p><ul><li>框架就是一个半成品软件，是一套<strong>可重用的、通用的、软件基础代码模型</strong></li><li>在框架的基础之上构建软件编写更加高效、规范、通用、可扩展</li></ul><h2 id="Mybatis对比JDBC"><a href="#Mybatis对比JDBC" class="headerlink" title="Mybatis对比JDBC"></a>Mybatis对比JDBC</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250729124941788.png" alt="image-20250729124941788"></p><hr><h1 id="核心配置文件mybatis-config-xml"><a href="#核心配置文件mybatis-config-xml" class="headerlink" title="核心配置文件mybatis-config.xml"></a>核心配置文件mybatis-config.xml</h1><p>核心配置文件标签必须有向后顺序（相比之下，SQL映射配置文件的同级标签没有先后顺序），如下</p><ul><li>configuration(配置)<ul><li>properties(属性)</li><li>settings(设置)</li><li>typeAliases(类型别名)</li><li>typeHandlers(类型处理器)</li><li>objectFactory(对象工厂)</li><li>plugins(插件)</li><li>environments(环境配置)<ul><li>environment(环境变量)<ul><li>transactionManager(事务管理器)</li><li>dataSource(数据源)</li></ul></li></ul></li><li>databaseldProvider(数据库厂商标识)</li><li>mappers(映射器)</li></ul></li></ul><h2 id="configuration【根标签】"><a href="#configuration【根标签】" class="headerlink" title="configuration【根标签】"></a>configuration【根标签】</h2><p>所有子标签均需书写在当前根标签内部</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--根标签configuration--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    typeAliases类型别名--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;package1.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment</span></span><br><span class="line"><span class="comment">    尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    default是每个environment默认使用的环境 ID--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        指定每个 environment 元素定义的环境 ID--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        注意：环境可以随意命名，但务必保证默认的环境 ID 要匹配其中一个环境 ID。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            事务管理器transactionManager的配置，不用太在意，事务管理之后是用Spring接管--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            在 MyBatis 中有两种类型的事务管理器（也就是 type=&quot;[JDBC|MANAGED]&quot;）：--&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--            JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            数据源dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。--&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--            大多数 MyBatis 应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            有三种内建的数据源类型（也就是 type=&quot;[UNPOOLED|POOLED|JNDI]&quot;）：--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            POOLED– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            UNPOOLED– 这个数据源的实现会每次请求时打开和关闭连接。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            JNDI – 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--加载sql映射文件，告诉MyBatis 去哪寻找映射SQL 的语句。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        Maven项目编译后，java和resources下的目录和文件都在同一个跟目录下，所以路径是这样的，注意路径是/，不是.--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource=&quot;package1/mapper/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        扫描包指定name的包下所有mapper配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;package1.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="properties【属性标签】"><a href="#properties【属性标签】" class="headerlink" title="properties【属性标签】"></a>properties【属性标签】</h2><p>作用：<strong>将数据库配置属性从dataSource标签内部提取到外部</strong><br>属性：<br><code>resource</code>：设置外部属性文件类路径<br><code>url</code>：设置外部属性文件真实路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--    属性标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;druid.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    设置数据库环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置事务管理器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置数据源--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;initialSize&#125;&quot;/&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="settings【设置标签】"><a href="#settings【设置标签】" class="headerlink" title="settings【设置标签】"></a>settings【设置标签】</h2><p>作用： 是mybatis中极为重要的调整设置，他们会<strong>改变mybatis的运行时行为</strong></p><p>mapUnderscoreToCamelCase：开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。<br>默认值为false,当设置为true时开启驼峰命名<br>注意：只能将a_bc与aBc自动映射，不能将a_b与aBc自动映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启驼峰式命名自动映射--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="typeAliases【类型别名】"><a href="#typeAliases【类型别名】" class="headerlink" title="typeAliases【类型别名】"></a>typeAliases【类型别名】</h2><p><strong>alias译为别名</strong><br>作用 ：类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。<br>自定义别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Comment&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Comment&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Post&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Section&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Section&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Tag&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Tag&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以指定一个包名进行扫描，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    typeAliases类型别名--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    给指定name包下的所有类起一个别名，--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;package1.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样sql映射文件resultType属性就可以省略路径package1.pojo:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 映射配置文件 UserMapper.xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace名称空间，该命名空间和对应mapper接口的全限定名一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;package1.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType=&quot;User&quot;或&quot;user&quot;也可以，因为核心配置文件中有给package1.pojo起别名，且有别名后不区分大小写 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;package1.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="typeHandlers【类型处理器】"><a href="#typeHandlers【类型处理器】" class="headerlink" title="typeHandlers【类型处理器】"></a>typeHandlers【类型处理器】</h2><h2 id="objectFactory【对象工厂】"><a href="#objectFactory【对象工厂】" class="headerlink" title="objectFactory【对象工厂】"></a>objectFactory【对象工厂】</h2><h2 id="plugins（插件）"><a href="#plugins（插件）" class="headerlink" title="plugins（插件）"></a>plugins（插件）</h2><h2 id="environments【数据库环境设置】"><a href="#environments【数据库环境设置】" class="headerlink" title="environments【数据库环境设置】"></a>environments【数据库环境设置】</h2><p>作用：<strong>配置数据库连接环境信息。</strong></p><blockquote><ul><li>可以配置多个environment。</li><li>环境可以随意命名，但务必保证默认的环境 ID 要匹配其中一个环境 ID。这样通过default属性切换不同的environment环境<strong>。</strong></li><li>尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</li></ul></blockquote><p><strong>属性说明</strong>：</p><blockquote><p><strong>environments</strong>属性default是每个environment默认使用的环境 ID</p><p><strong>environment</strong>属性id是指定该 environment 元素定义的环境 ID。</p><p><strong>事务管理器transactionManager</strong>属性<strong>type有两种</strong>（type=”[JDBC|MANAGED]”））：<br>JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。<br>MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。</p><p><strong>数据源 dataSource 元素</strong>使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。<br><strong>type有三种</strong>（type=”[UNPOOLED|POOLED|JNDI]”）：<br>POOLED– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。<br>UNPOOLED– 这个数据源的实现会每次请求时打开和关闭连接。<br>JNDI – 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- default是每个environment默认使用的环境 ID--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定每个environment元素定义的环境ID，注意：环境可随意命名，但务必保证默认环境ID要匹配其中一个环境 ID。--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 事务管理器transactionManager的配置，不用太在意，事务管理之后是用Spring接管 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 大多 MyBatis 应用程序会按示例中例子配置数据源。数据源配置可选，但要启用延迟加载特性就必须配置数据源。--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 数据库连接信息 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="databaseIdProvider（数据库厂商标识）"><a href="#databaseIdProvider（数据库厂商标识）" class="headerlink" title="databaseIdProvider（数据库厂商标识）"></a>databaseIdProvider（数据库厂商标识）</h2><h2 id="mappers-【映射器】"><a href="#mappers-【映射器】" class="headerlink" title="mappers 【映射器】"></a>mappers 【映射器】</h2><p>作用：加载映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载sql映射文件，告诉MyBatis 去哪寻找映射SQL 的语句。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 或者也可以扫描包寻找sql映射文件文件，推荐这种方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;package1.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="Mybatis入门案例（不用mapper）"><a href="#Mybatis入门案例（不用mapper）" class="headerlink" title="Mybatis入门案例（不用mapper）"></a>Mybatis入门案例（不用mapper）</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>需求：查询user表中所有的数据</strong></p><ol><li><p><strong>创建user表，添加数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database mybatis;</span><br><span class="line">use mybatis;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    password <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">    addr <span class="type">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;234&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;天津&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;西安&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>创建模块，导入坐标</strong></p><p>在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis 依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql 驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加slf4j日志api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加logback-classic依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加logback-core依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实依赖<strong>只需要导入mybatis,mysql即可，其他是日志、测试之类的</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  CONSOLE ：表示当前的日志信息是可以输出到控制台的。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%level]  %cyan([%thread]) %boldGreen(%logger&#123;15&#125;) - %msg %n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里要改，包名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;package1&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF ， 默认debug</span></span><br><span class="line"><span class="comment">      &lt;root&gt;可以包含零个或多个&lt;appender-ref&gt;元素，标识这个输出位置将会被本日志级别控制。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>需要在项目的 resources 目录下创建logback的配置文件</p></blockquote><p>slf4j，simple logging facade for java的缩写，翻译为java的简单日志外观。slf4j是一个开源项目，它提供我们一个一致的API来使用不同的日志框架，比如： java.util.logging，logback，log4j等。slf4j使用户可以在运行时嵌入他们想使用的日志框架。从名字中可以看出，它其实使用的是facade设计模式来实现的。 </p><p>Logback是SpringBoot内置的日志处理框架，你会发现spring-boot-starter其中包含了spring-boot-starter-logging，该依赖内容就是 Spring Boot 默认的日志框架 logback。官方文档：<a href="http://logback.qos.ch/manual/">http://logback.qos.ch/manual/</a></p></li><li><p><strong>编写 MyBatis 核心配置文件</strong> – &gt; 替换连接信息 解决硬编码问题</p><p>在模块下的 resources 目录下创建mybatis的配置文件 <code>mybatis-config.xml</code>，内容如<a href="#configuration%E3%80%90%E6%A0%B9%E6%A0%87%E7%AD%BE%E3%80%91">configuration【根标签】</a>。</p></li><li><p><strong>编写 SQL 映射文件</strong> –&gt; 统一管理sql语句，解决硬编码问题</p><p>在模块的 <code>resources</code> 目录下创建映射配置文件 <code>UserMapper.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 映射配置文件 UserMapper.xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace名称空间，该命名空间和对应mapper接口的全限定名一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;package1.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>另外，可通过resultMap实现对数据库列名起别名</strong>，以解决数据库列名和User类属性命名法不对应问题（数据库标识符不区分大小写，采用下划线命名法，java标识符常用驼峰命名法）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 统一起别名，resultMap标签的id为自定义的唯一标识，type为package1.pojo.User，</span></span><br><span class="line"><span class="comment">    若核心配置有typeAliases扫描pojo包，user --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对数据库的指定列起别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;passWord&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 起别名了，resultType改成resultMap，值为上面resultMap的id--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>根标签</strong>【mapper】<br>作用：所用子标签均需书写在mapper内部<br>namespace与接口全路径类名【类的全限定名】一致</p><p><strong>八大子标签</strong>：</p><p>insert：定义增加SQL语句<br>delete：定义删除SQL语句<br>update：定义修改语句<br>select：定义查询SQL语句<br>sql：定义SQL语句块<br>resultMap：定义结果集映射【resultType解决不了时，使用resultMap】<br>cache：定义缓冲类<br>cache-ref：定义引用缓存</p></li><li><p><strong>在package1.pojo包下创建 User类</strong></p><p><a href="https://so.csdn.net/so/search?q=POJO&spm=1001.2101.3001.7020">POJO</a>(Plain Old Java Objects)译为，简单的Java对象，其实就是<strong>没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的，没有遵从特定的Java对象模型、约定或框架（如EJB）的不受任何限制的java对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">// 下面两个passWord改成password</span></span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String addr;</span><br><span class="line">    <span class="comment">// 省略了 setter 和 getter</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, passWord=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, addr=&#x27;&quot;</span> + addr + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在package1包下编写 MybatisDemo 测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 加载mybatis的核心配置文件，获取 SqlSessionFactory，session译为“会话”，factory译为“工厂”。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        <span class="comment">// 2. 获取SqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// sqlSession = sqlSessionFactory.openSession(true); // 设置自动提交事务，这种情况不需要手动提交事务了</span></span><br><span class="line">        <span class="comment">// 3. 执行sql，这步不用记，一般这步都是使用mapper代理开发       </span></span><br><span class="line">        sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">// 参数是一个字符串，该字符串必须是映射配置文件的namespace.id</span></span><br><span class="line">        List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;test.selectAll&quot;</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="comment">// 4.要手动提交，不然会回滚事务。如果前面sqlSessionFactory.openSession(true)，就不用再提交事务了  </span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        <span class="comment">// 5. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>第三步执行SQL前的代码在所有案例中都是一样的，直接复制粘贴即可。而且整合Spring后就只剩mapper优化后的执行方法</strong></p></blockquote></li><li><p><strong>回顾对比一下jdbc：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 注册驱动</span></span><br><span class="line">        <span class="comment">// Class.forName(&quot;com.mysql.jdbc.Driver&quot;);// 通过反射获取Driver实现类对象，从而加载驱动</span></span><br><span class="line">        <span class="comment">// 注册驱动语句DriverManager.registerDriver(driver)在Driver的静态代码块里做过了。</span></span><br><span class="line">        <span class="comment">// 此句仅在mysql可省略，其他数据库不能省略</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取连接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/db1?useSSL=false&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">passWord</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, passWord);</span><br><span class="line">        <span class="comment">// 3. 定义sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update student set age = 80 where name=&#x27;xiaohua&#x27;&quot;</span>;</span><br><span class="line">        <span class="comment">// 4. 获取执行sql的对象 Statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="comment">// 5. 执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);<span class="comment">//受影响的行数</span></span><br><span class="line">        <span class="comment">// 6. 处理结果</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">// 7. 释放资源</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="SqlSessionFactory工具类抽取"><a href="#SqlSessionFactory工具类抽取" class="headerlink" title="SqlSessionFactory工具类抽取"></a>SqlSessionFactory工具类抽取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure><p>第三步执行SQL前的代码在所有案例中都是一样的，这些重复代码就会造成一些问题:</p><ol><li><p>重复代码不利于后期的维护</p></li><li><p>SqlSessionFactory工厂类进行重复创建</p></li><li><p>资源消耗非常大但性能却非常低。</p></li></ol><p><strong>解决方案</strong></p><ul><li>代码重复可以<strong>抽取工具类</strong></li><li>对指定代码只需要执行一次可以使用<strong>静态代码块</strong> </li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">// sqlSession = sqlSessionFactory.openSession(true); // 设置自动提交事务，这种情况不需要手动提交事务了</span></span><br></pre></td></tr></table></figure><p>虽然上面语句也重复，但不能抽取到工具类里。因为SqlSession是一个连接、会话，每次连接数据库时候创建一次会话是合适，如果所有连接都共用一个会话会互相影响。</p><p>SqlSession是一个会话，相当于JDBC中的一个Connection对象，Mybatis中所有的数据库交互都由SqlSession来完成。</p></blockquote><p><strong>抽取工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代码块会随着类的加载而自动执行，且只执行一次，静态代码块不能抛异常，要用try-catch</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory <span class="title function_">getSqlSessionFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> SqlSessionFactoryUtils.getSqlSessionFactory();</span><br></pre></td></tr></table></figure><h2 id="IDEA连接数据库"><a href="#IDEA连接数据库" class="headerlink" title="IDEA连接数据库"></a>IDEA连接数据库</h2><p><strong>解决SQL映射文件的警告提示：</strong></p><p>在入门案例映射配置文件中存在报红的情况：数据表显示红色</p><ul><li>产生的原因：Idea和数据库没有建立连接，不识别表信息。但是大家一定要记住，它并不影响程序的执行。</li><li>解决方式：在Idea中配置MySQL数据库连接。</li></ul><p><strong>IDEA中配置MySQL数据库连接</strong></p><ul><li><p>点击IDEA右边框的 <code>Database</code> ，在展开的界面点击 <code>+</code> 选择 <code>Data Source</code> ，再选择 <code>MySQL</code></p></li><li><p>在弹出的界面进行基本信息的填写</p></li><li><p>点击完成后就能看到数据库编译器界面</p></li><li><p>而此界面就和 <code>navicat</code> 工具一样可以进行数据库的操作。也可以编写SQL语句</p></li></ul><p>如果发现写表名时没有提示：<strong>打开File的settings，把SQL Dialects选项的右边那个None改为你的默认数据库。</strong></p><hr><h1 id="Mapper代理开发"><a href="#Mapper代理开发" class="headerlink" title="Mapper代理开发"></a>Mapper代理开发</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>解决原生方式中的硬编码</li><li>简化后期执行SQL</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.执行sqL</span></span><br><span class="line">List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;test.selectAll&quot;</span>);</span><br><span class="line">System.out.println(users);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.获取接口代理对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="comment">// 4.执行方法，其实就是执行sql语句</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br></pre></td></tr></table></figure><h2 id="使用mapper实现查询"><a href="#使用mapper实现查询" class="headerlink" title="使用mapper实现查询"></a>使用mapper实现查询</h2><ol><li><p>定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下。如下图放就可以，因为编译Maven后java和resources下的目录和文件都在同一个根目录下。</p><blockquote><p>注意：在resources下建多层文件夹要用斜杠，例如aa/bb，不能aa.bb。如果直接建aa.bb，则只建了一个名为aa.bb的文件夹，而不是两个。</p></blockquote></li><li><p>设置SQL映射文件的namespace属性为Mapper接口全限定名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 映射配置文件 UserMapper.xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace名称空间，该命名空间和对应mapper接口的全限定名一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;package1.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;package1.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致</p></li><li><p>Mapper代理开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取SqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 3. 执行sql</span></span><br><span class="line">        <span class="comment">// 参数是一个字符串，该字符串必须是映射配置文件的namespace.id</span></span><br><span class="line">        <span class="comment">// List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;);</span></span><br><span class="line">        <span class="comment">// 3.1获取UserMapper接口的代理对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">// 3.2调用sql方法</span></span><br><span class="line">        List&lt;User&gt; users = userMapper.selectAll();</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用在核心配置文件mybatis-config.xml中用<strong>包扫描</strong>的方式简化SQL映射文件的加载。示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载sql映射文件，告诉MyBatis 去哪寻找映射SQL 的语句。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Maven项目编译后，java和resources下的目录和文件都在同一个跟目录下，所以路径是这样的，注意路径是/，不是.--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;package1/mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>简化成</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描包指定name的包下所有mapper配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;package1.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="配置文件实现增删改查"><a href="#配置文件实现增删改查" class="headerlink" title="配置文件实现增删改查"></a>配置文件实现增删改查</h1><h2 id="MybatisX插件、占位符、XML特殊字符转义"><a href="#MybatisX插件、占位符、XML特殊字符转义" class="headerlink" title="MybatisX插件、占位符、XML特殊字符转义"></a>MybatisX插件、占位符、XML特殊字符转义</h2><p><strong>安装MybatisX插件：</strong>Setting–Plugins–MybatisX</p><p>作用是通过小鸟图标，方便mapper接口和mapper配置文件之间代码的统一。</p><p><strong>参数占位符：</strong>参数占位符里的内容为传入的参数名，或者参数的成员变量名，或map的键名。</p><p>mybatis提供了两种参数占位符：</p><ul><li>#{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值。底层使用的是 <code>PreparedStatement</code></li><li>${} ：拼接SQL。底层使用的是 <code>Statement</code>，会存在SQL注入问题。  </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from tb_user where id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>#{}和 ${} 的区别</strong></p><p><code>\#&#123;&#125;</code>是预编译处理，<code>$&#123;&#125;</code>是字符替换。在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 <code>PreparedStatement</code> 的 set 方法赋值，这样可以有效防止 SQL 注入，保证程序的运行安全。</p><p><strong>特殊字符处理：</strong></p><ol><li><p>转义字符。XML中，需要转义的字符有： </p><blockquote><p>&amp;　　  <code>&amp;amp;</code> </p><p>&lt;　  　<code>&amp;lt;</code> </p><p>&gt;　  　<code>&amp;gt;</code> </p><p>＂　　<code>&amp;quot;</code> </p><p>＇　　<code>&amp;apos;</code> </p></blockquote></li><li><p>CDATA区</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from tb_user where id &lt;![CDATA[</span><br><span class="line">        &gt;        </span><br><span class="line">    ]]&gt; #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="resultMap给列起别名并查询所有"><a href="#resultMap给列起别名并查询所有" class="headerlink" title="resultMap给列起别名并查询所有"></a>resultMap给列起别名并查询所有</h2><blockquote><p> 适用于数据库字段名和实体类属性名不同的情况。 </p></blockquote><p>SQL语句下划线命名法的<strong>列名</strong>和java实体类驼峰命名法的<strong>成员变量不同</strong>，会导致数据库给成员变量无法赋值的问题。<strong>通过resultMap标签给数据库列名起别名，可以解决这个问题。</strong></p><h2 id="多条件动态查询（动态SQL）"><a href="#多条件动态查询（动态SQL）" class="headerlink" title="多条件动态查询（动态SQL）"></a>多条件动态查询（动态SQL）</h2><p><strong>动态SQL：</strong>SQL语句随着用户的输入或外部条件的变化而变化，称为动态SQL。</p><p>Mybatis关于动态SQL的<strong>标签</strong>：</p><blockquote><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul></blockquote><p><strong>if 标签</strong>的test 属性：逻辑表达式</p><p>为了防止出现SQL语句where 后直接跟and的情况，给所有条件加了and，并且where后跟了1=1。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from tb_brand</span><br><span class="line">    <span class="comment">&lt;!-- 这里1=1是防止where后直接跟and的情况发生，更好的办法是用where标签，根据语法动态去and或where关键字 --&gt;</span></span><br><span class="line">    where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">        and status = #&#123;status&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        and company_name like #&#123;companyName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        and brand_name like #&#123;brandName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>where 标签</strong>作用：</p><ul><li>替换where关键字</li><li>会动态的去掉第一个条件前的 and</li><li>如果所有的参数没有值则不加where关键字</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">     select * from tb_brand</span><br><span class="line">     <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  where标签下注意所有if都要加and--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">             and status = #&#123;status&#125;</span><br><span class="line">         <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">             and company_name like #&#123;companyName&#125;</span><br><span class="line">         <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">             and brand_name like #&#123;brandName&#125;</span><br><span class="line">         <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="单条件动态查询（动态SQL）"><a href="#单条件动态查询（动态SQL）" class="headerlink" title="单条件动态查询（动态SQL）"></a>单条件动态查询（动态SQL）</h2><p>先选择，再输入查询。</p><p><strong><code>choose（when，otherwise）</code><strong>标签</strong>类似于Java 中的switch</strong>语句，自带break。  </p><blockquote><p> <strong>注意：</strong></p><p>choose-when是多选一，一项<when>满足条件后其他就不判断了。</p><p><if>可以多层判断。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByConditionSingle&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from tb_brand</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 相当于switch --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 相当于case --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span> </span><br><span class="line">                status = #&#123;status&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">                company_name like #&#123;companyName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                brand_name like #&#123;brandName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p><strong>返回主键</strong>：在 insert 标签上添加如下属性</p><ul><li>useGeneratedKeys：是够获取自动增长的主键值。true表示获取</li><li>keyProperty ：指定将获取到的主键值封装到哪儿个属性里  </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line">    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brandMapper.add(brand);</span><br><span class="line">System.out.println(brand.getId());</span><br></pre></td></tr></table></figure><h2 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h2><p>获取到修改后的数据和id，修改此id对应的一行数据。在修改界面用户可能只修改部分属性， 所以加条件<if>判断每个属性修改框用户有没有填写，用<set>防止更新语句最后一行有逗号。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">    update tb_brand</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            brand_name = #&#123;brandName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            company_name = #&#123;companyName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ordered != null&quot;</span>&gt;</span></span><br><span class="line">            ordered = #&#123;ordered&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;description != null and description != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            description = #&#123;description&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">            status = #&#123;status&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><p>编写SQL时需要遍历数组来拼接SQL语句。Mybatis 提供了 <code>foreach</code> 标签供我们使用</p><p><strong>foreach 标签</strong></p><p>用来迭代任何可迭代的对象（如数组，集合）。</p><ul><li>collection 属性：指定遍历的数组<ul><li>mybatis会将数组参数，封装为一个Map集合。<ul><li>默认：array = 数组，key是array而不是数组名，如collection=”array”和void deleteByIds(int[] ids);</li><li>用@Param注解改变map集合的默认key的名称为数组名，如collection=”ids”和void deleteByIds(@Param(“ids”) int[] ids);</li></ul></li></ul></li><li>item 属性：本次迭代获取到的元素，如item=”id”。</li><li>separator 属性：集合项迭代之间的分隔符。<code>foreach</code> 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。如separator=”,”</li><li>open 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次。如open=”(“</li><li>close 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次。如close=”)”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(<span class="type">int</span>[] ids)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">    delete from tb_brand where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="Mybatis参数传递"><a href="#Mybatis参数传递" class="headerlink" title="Mybatis参数传递"></a>Mybatis参数传递</h1><p>Mybatis 接口方法中可以接收各种各样的参数，如下：</p><ul><li>多个参数</li><li>单个参数：单个参数又可以是如下类型<ul><li><strong>POJO 类型，传入对象</strong></li><li>Map 集合类型，传入map</li><li>Collection 集合类型</li><li>List 集合类型</li><li>Array 类型</li><li>其他类型</li></ul></li></ul><blockquote><p>注意：单个参数不用@Param注解起别名，会自动识别要传的参数。</p><p>mapper传参数，如果<strong>参数包括对象和散装参数</strong>，那么<strong>对象必须也注解</strong>，写SQL语句时候不能忘记<code>对象.属性</code>，例如brand.status.</p></blockquote><ol><li><p><strong>散装参数</strong>：使用 <code>@Param(&quot;参数名称&quot;)</code> 标记每一个参数，在映射配置文件中就需要使用 <code>#&#123;参数名称&#125;</code> 进行占位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByPageAndCondition</span><span class="params">(<span class="meta">@Param(&quot;begin&quot;)</span> <span class="type">int</span> begin,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@Param(&quot;size&quot;)</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@Param(&quot;brand&quot;)</span> Brand brand)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    where status = #&#123;brand.status&#125;</span><br><span class="line">    limit #&#123;begin&#125;, #&#123;size&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>实体类封装参数</strong>：将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，里面的<strong>内容必须和实体类属性名保持一致</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>map集合</strong>：将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，里面的<strong>内容必须和map集合中键的名称一致</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Map map)</span>;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注解底层，了解即可</strong> </p><p>我们在接口方法中定义多个参数，Mybatis 会将这些参数封装成 Map 集合对象，值就是参数值，而键在没有使用 <code>@Param</code> 注解时有以下命名规则：</p><ul><li><p>以 arg 开头 ：第一个参数就叫 arg0，第二个参数就叫 arg1，以此类推。如：</p><blockquote><p>map.put(“arg0”，参数值1);</p><p>map.put(“arg1”，参数值2);</p></blockquote></li><li><p>以 param 开头 ： 第一个参数就叫 param1，第二个参数就叫 param2，依次类推。如：</p><blockquote><p>map.put(“param1”，参数值1);</p><p>map.put(“param2”，参数值2);</p></blockquote></li><li><p>在映射配合文件的SQL语句中使用用 <code>arg</code> 开头的和 <code>param</code> 书写，代码的可读性会变的特别差，此时可以使用 <code>@Param</code> 注解。在接口方法参数上使用 <code>@Param</code> 注解，Mybatis 会将 <code>arg</code> 开头的键名替换为对应注解的属性值。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User <span class="title function_">select</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, String password)</span>;</span><br></pre></td></tr></table></figure><p>Mybatis 在封装 Map 集合时，键名就会变成如下：</p><p>map.put(“username”，参数值1);</p><p>map.put(“arg1”，参数值2);</p><p>map.put(“param1”，参数值1);</p><p>map.put(“param2”，参数值2);</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from tb_user where username=#&#123;username&#125; and password=#&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行程序结果没有报错。而如果将 <code>#&#123;&#125;</code> 中的 <code>username</code> 还是写成 <code>arg0</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from tb_user where username=#&#123;arg0&#125; and password=#&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行程序则可以看到报错：Parameter ‘arg0’ not found.</p></blockquote></li></ul><p><strong>结论：以后接口参数是多个时，在每个参数上都使用 <code>@Param</code> 注解。</strong></p><hr><h1 id="注解实现增删改查"><a href="#注解实现增删改查" class="headerlink" title="注解实现增删改查"></a>注解实现增删改查</h1><p>如果<strong>SQL语句简单</strong>，使用注解开发会比配置文件开发更加<strong>方便</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(value = &quot;select * from tb_user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">select</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li>注解后是没有分号的。</li><li>注解是用来替换映射配置文件方式配置的，所以使用了注解，就不需要再映射配置文件中书写对应的 <code>statement</code></li></ul></blockquote><p>Mybatis 针对 CURD 操作都提供了对应的注解，已经做到见名知意。如下：</p><ul><li>查询 ：@Select</li><li>添加 ：@Insert</li><li>修改 ：@Update</li><li>删除 ：@Delete</li></ul><p><strong>注意：</strong>在官方文档中 <code>入门</code> 中有这样的一段话：使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。</p><p>所以<strong>注解完成简单功能，配置文件完成复杂功能。</strong></p><p>而我们之前写的动态 SQL 就是复杂的功能，如果用注解，就需要使用到 Mybatis 提供的SQL构建器来完成，而对应的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">    SELECT(<span class="string">&quot;P.ID,P.USERNAME,P.PASSWORD, P.FIRST NAME, P.LAST NAME&quot;</span>)FROM(<span class="string">&quot;PERSON P&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="literal">null</span>) &#123;</span><br><span class="line">        WHERE(<span class="string">&quot;P.ID like #&#123;id&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (firstName != <span class="literal">null</span>) &#123;</span><br><span class="line">        WHERE(<span class="string">&quot;P.FIRST NAME like #&#123;firstName&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastName != <span class="literal">null</span>) &#123;</span><br><span class="line">        WHERE(<span class="string">&quot;P.LAST NAME like #&#123;lastName&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ORDER <span class="title function_">BY</span><span class="params">(<span class="string">&quot;P.LAST NAME&quot;</span>)</span>;</span><br><span class="line">&#125;&#125;.tostring();</span><br></pre></td></tr></table></figure><p>上述代码将java代码和SQL语句融到了一块，使得代码的可读性大幅度降低。</p><hr><h1 id="MyBatis-多数据源"><a href="#MyBatis-多数据源" class="headerlink" title="MyBatis 多数据源"></a>MyBatis 多数据源</h1><h3 id="一、配置双数据源"><a href="#一、配置双数据源" class="headerlink" title="一、配置双数据源"></a>一、配置双数据源</h3><ol><li><p>禁用Spring Boot数据源自动装配，在启动类@SpringBootApplication添加<code>exclude = &#123;DataSourceAutoConfiguration.class&#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, MybatisAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>application.properties配置文件添加两个数据源配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.db1.driverClassName</span> =<span class="string">oracle.jdbc.OracleDriver</span></span><br><span class="line"><span class="attr">spring.datasource.db1.jdbcUrl</span>=<span class="string">jdbc:oracle:thin:@&lt;db1 ip&gt;/db1</span></span><br><span class="line"><span class="attr">spring.datasource.db1.username</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.datasource.db1.password</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.datasource.db1.platform</span>=<span class="string">oracle</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.db2.driverClassName</span> =<span class="string">oracle.jdbc.OracleDriver</span></span><br><span class="line"><span class="attr">spring.datasource.db2.jdbcUrl</span>=<span class="string">jdbc:oracle:thin:@&lt;db2 ip&gt;/db2</span></span><br><span class="line"><span class="attr">spring.datasource.db2.username</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.datasource.db2.password</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.datasource.db2.platform</span>=<span class="string">oracle</span></span><br></pre></td></tr></table></figure></li><li><p>添加oracle数据源配置类PrimaryDataSourceConfig，下面的pg数据源配置类DmpDataSourceConfig，添加对应数据源的bean</p><ul><li><p>PrimaryDataSourceConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = &quot;primaryDataSource&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db1&quot;)</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;config primaryDataSource success.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DmpDataSourceConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = &quot;db2DataSource&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;config db2DataSource success.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="二、配置两个Mybatis"><a href="#二、配置两个Mybatis" class="headerlink" title="二、配置两个Mybatis"></a>二、配置两个Mybatis</h3><ol><li><p>禁用Mybatis自动装配，启动类@SpringBootApplication注解添加exclude = {DataSourceAutoConfiguration.class, MybatisAutoConfiguration.class}，如上</p></li><li><p>在application.properties配置文件添加两个Mybatis的配置和对应的配置类</p><ul><li><p>主数据源的mybatis配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.db1.extend.mybatisMapperLocations</span>=<span class="string">classpath:config/mybatis/mapper/*.xml</span></span><br></pre></td></tr></table></figure></li><li><p>主数据源的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db1.extend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimaryMybatisProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mybatisMapperLocations;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMybatisMapperLocations</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mybatisMapperLocations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMybatisMapperLocations</span><span class="params">(String mybatisMapperLocations)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mybatisMapperLocations = mybatisMapperLocations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数据源2的配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.db2.extend.mybatisMapperLocations</span>=<span class="string">classpath:config/mybatis/mapper2/*.xml</span></span><br></pre></td></tr></table></figure></li><li><p>数据源2的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db1.extend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DmpMybatisProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mybatisMapperLocations;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMybatisMapperLocations</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mybatisMapperLocations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMybatisMapperLocations</span><span class="params">(String mybatisMapperLocations)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mybatisMapperLocations = mybatisMapperLocations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置两个Mybatis的SqlSessionFactory</p><p>主数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123; &quot;xxx.db.mapper&quot; &#125;,sqlSessionFactoryRef=&quot;primarySqlSessionFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimaryMybatisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PrimaryMybatisProperties property;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;primaryDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db1&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;config primaryDataSource success.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;primarySqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;primaryDataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">            sessionFactory.setDataSource(dataSource);</span><br><span class="line">            sessionFactory.setMapperLocations(<span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>()</span><br><span class="line">                    .getResources(<span class="built_in">this</span>.property.getMybatisMapperLocations()));</span><br><span class="line">            log.info(<span class="string">&quot;config primarySqlSessionFactory success.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;config primarySqlSessionFactory failure.&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean(name = &quot;primarySqlSessionTemplate&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionTemplate <span class="title function_">testSqlSessionTemplate</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;primarySqlSessionFactory&quot;)</span> SqlSessionFactory sqlSessionFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean(name = &quot;primaryTransactionManager&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">transactionManager</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;primaryDataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据源2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123; &quot;xxx.db2.mapper&quot; &#125;,sqlSessionFactoryRef=&quot;db2SqlSessionFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Db2MybatisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Db2MybatisProperties property;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2DataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;config db2DataSource success.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2SqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;db2DataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">            sessionFactory.setDataSource(dataSource);</span><br><span class="line">            sessionFactory.setMapperLocations(<span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>()</span><br><span class="line">                    .getResources(<span class="built_in">this</span>.property.getMybatisMapperLocations()));</span><br><span class="line">            log.info(<span class="string">&quot;config db2SqlSessionFactory success.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;config db2SqlSessionFactory failure.&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2SqlSessionTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionTemplate <span class="title function_">testSqlSessionTemplate</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;db2SqlSessionFactory&quot;)</span> SqlSessionFactory sqlSessionFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2TransactionManager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">transactionManager</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;db2DataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="三、配置两个mybatis-PageHelper"><a href="#三、配置两个mybatis-PageHelper" class="headerlink" title="三、配置两个mybatis PageHelper"></a>三、配置两个mybatis PageHelper</h3><p>pagehelper spring boot AutoConfigure提供的PageHelperAutoConfiguration类，自动配置Mybatis的分页插件。因此，先禁用PageHelperAutoConfiguration类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123; </span></span><br><span class="line"><span class="meta">        DataSourceAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">        MybatisAutoConfiguration.class, </span></span><br><span class="line"><span class="meta">        PageHelperAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要配置两个mybatis的分页插件，需要做如下操作：</p><ol><li><p>在<code>application.properties</code>配置文件中添加如下两个mybatis分页插件的配置和对应的<code>@Configuration</code>类。<br>使用db1数据源的mybatis分页插件的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.db1.extend.pagehelperDialect=Oracle</span><br><span class="line">spring.datasource.db1.extend.pagehelperReasonable=true</span><br><span class="line">spring.datasource.db1.extend.pagehelperSupportMethodsArguments=true</span><br><span class="line">spring.datasource.db1.extend.pagehelperOffsetAsPageNum=true</span><br><span class="line">spring.datasource.db1.extend.pagehelperRowBoundsWithCount=true</span><br><span class="line">spring.datasource.db1.extend.pagehelperParams=count=countSql;pageNum=pageNumKey;pageSize=pageSizeKey;</span><br></pre></td></tr></table></figure><p>使用db1数据源的mybatis分页插件的@Configuration类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db1.extend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimaryMybatisProperties</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String mybatisMapperLocations;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperDialect;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperReasonable;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperSupportMethodsArguments;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperParams;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperOffsetAsPageNum;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperRowBoundsWithCount;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用db2数据源的mybatis分页插件的配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.db2.extend.pagehelperDialect</span>=<span class="string">Oracle</span></span><br><span class="line"><span class="attr">spring.datasource.db2.extend.pagehelperReasonable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.db2.extend.pagehelperSupportMethodsArguments</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.db2.extend.pagehelperOffsetAsPageNum</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.db2.extend.pagehelperRowBoundsWithCount</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.db2.extend.pagehelperParams</span>=<span class="string">count=countSql;pageNum=pageNumKey;pageSize=pageSizeKey;</span></span><br></pre></td></tr></table></figure><p>使用db2数据源的mybatis分页插件的@Configuration类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db2.extend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Db2MybatisProperties</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String mybatisMapperLocations;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperDialect;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperReasonable;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperSupportMethodsArguments;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperParams;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperOffsetAsPageNum;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperRowBoundsWithCount;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置两个mybatis的SqlSessionFactory，增加分页插件<br>PrimaryMybatisConfiguration，添加PageHelper，其余不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimaryMybatisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;primarySqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;primaryDataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">            sessionFactory.setDataSource(dataSource);</span><br><span class="line">            sessionFactory.setMapperLocations(<span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>()</span><br><span class="line">                    .getResources(<span class="built_in">this</span>.property.getMybatisMapperLocations()));</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">// 分页插件</span></span><br><span class="line">            <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageInterceptor</span>();</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.setProperty(<span class="string">&quot;helperDialect&quot;</span>, <span class="built_in">this</span>.property.getPagehelperDialect());</span><br><span class="line">            properties.setProperty(<span class="string">&quot;reasonable&quot;</span>, <span class="built_in">this</span>.property.getPagehelperReasonable());</span><br><span class="line">            properties.setProperty(<span class="string">&quot;supportMethodsArguments&quot;</span>,</span><br><span class="line">                                   <span class="built_in">this</span>.property.getPagehelperSupportMethodsArguments());</span><br><span class="line">            properties.setProperty(<span class="string">&quot;params&quot;</span>,<span class="built_in">this</span>.property.getPagehelperParams());</span><br><span class="line">            interceptor.setProperties(properties);</span><br><span class="line">            sessionFactory.setPlugins(<span class="keyword">new</span> <span class="title class_">Interceptor</span>[] &#123;interceptor&#125;);</span><br><span class="line">         </span><br><span class="line">            log.info(<span class="string">&quot;config primarySqlSessionFactory success.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;config primarySqlSessionFactory failure.&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Db2MybatisConfiguration，添加PageHelper，其余不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Db2MybatisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2SqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;db2DataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">            sessionFactory.setDataSource(dataSource);</span><br><span class="line">            sessionFactory.setMapperLocations(<span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>()</span><br><span class="line">                    .getResources(<span class="built_in">this</span>.property.getMybatisMapperLocations()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分页插件</span></span><br><span class="line">            <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageInterceptor</span>();</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.setProperty(<span class="string">&quot;helperDialect&quot;</span>, <span class="built_in">this</span>.property.getPagehelperDialect());</span><br><span class="line">            properties.setProperty(<span class="string">&quot;reasonable&quot;</span>, <span class="built_in">this</span>.property.getPagehelperReasonable());</span><br><span class="line">            properties.setProperty(<span class="string">&quot;supportMethodsArguments&quot;</span>,</span><br><span class="line">                                   <span class="built_in">this</span>.property.getPagehelperSupportMethodsArguments());</span><br><span class="line">            properties.setProperty(<span class="string">&quot;params&quot;</span>,<span class="built_in">this</span>.property.getPagehelperParams());</span><br><span class="line">            interceptor.setProperties(properties);</span><br><span class="line">            sessionFactory.setPlugins(<span class="keyword">new</span> <span class="title class_">Interceptor</span>[] &#123;interceptor&#125;);</span><br><span class="line">            </span><br><span class="line">            log.info(<span class="string">&quot;config db2SqlSessionFactory success.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;config db2SqlSessionFactory failure.&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="四、配置两个mybatis-generator"><a href="#四、配置两个mybatis-generator" class="headerlink" title="四、配置两个mybatis generator"></a>四、配置两个mybatis generator</h3><ol><li><p>在pom.xml中引入mybatis generator</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis generator 自动生成代码插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle.jdbc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc7<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>12.1.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置2个mybatis generator配置文件。<br>使用db1数据源的mybatis generator的配置文件generatorConfig.xml<br>使用db1数据源的mybatis generator的配置文件generatorConfig2.xml</p></li><li><p>使用mvn执行mybatis generator命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用db1数据源的mybatis generator生成代码命令</span></span><br><span class="line">mvn -Dmybatis.generator.configurationFile=src/main/resources/generatorConfig.xml mybatis-generator:generate</span><br><span class="line"><span class="comment"># 使用db2数据源的mybatis generator生成代码命令</span></span><br><span class="line">mvn -Dmybatis.generator.configurationFile=src/main/resources/generatorConfig2.xml mybatis-generator:generate</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="MyBatis-编写自定义插件"><a href="#MyBatis-编写自定义插件" class="headerlink" title="MyBatis 编写自定义插件"></a>MyBatis 编写自定义插件</h1><h2 id="MyBatis-分页插件的实现原理"><a href="#MyBatis-分页插件的实现原理" class="headerlink" title="MyBatis 分页插件的实现原理"></a>MyBatis 分页插件的实现原理</h2><p>分页插件的基本原理是使用 <code>MyBatis</code> 提供的插件接口，实现自定义插件，<strong>在插件的拦截方法内拦截待执行的 SQL</strong>，然后重写 SQL，根据 <code>dialect</code> 方言，<strong>添加对应的物理分页语句和物理分页参数</strong>。</p><h2 id="自定义插件实现原理"><a href="#自定义插件实现原理" class="headerlink" title="自定义插件实现原理"></a>自定义插件实现原理</h2><p>MyBatis 自定义插件针对 MyBatis 四大对象(<code>Executor</code>、<code>StatementHandler</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>)进行拦截：<br><strong>Executor：</strong>拦截<strong>内部执行器</strong>，它负责<strong>调用 <code>StatementHandler</code> 操作数据库，并把结果集通过 <code>ResultSetHandler</code> 进行自动映射，另外它还处理了二级缓存的操作</strong>；<br><strong>StatementHandler：</strong>拦截 <strong>SQL 语法构建的处理</strong>，它是MyBatis直接和数据库执行 <code>SQL脚本</code>的对象，它也<strong>实现了 MyBatis 的一级缓存</strong>；<br><strong>ParameterHandler：</strong>拦截<strong>参数的处理</strong>；<br><strong>ResultSetHandler：</strong>拦截<strong>结果集的处理</strong>。</p><h2 id="自定义插件实现关键"><a href="#自定义插件实现关键" class="headerlink" title="自定义插件实现关键"></a>自定义插件实现关键</h2><p><code>MyBatis插件</code>要实现 <code>Interceptor</code> 接口，接口包含的方法，如下代码所示：<br><strong><code>setProperties</code> 方法：</strong>在 MyBatis 进行配置插件的时候可配置自定义相关属性，即：<strong>接口实现对象的参数配置</strong>；<br><strong><code>plugin</code> 方法：</strong>插件用于<strong>封装目标对象</strong>的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：<code>return Plugin. wrap(target, this)</code>；<br><strong><code>intercept</code> 方法：</strong>是要<strong>进行拦截的时候要执行的方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interfaceInterceptor&#123;</span><br><span class="line">  object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">  object <span class="title function_">plugin</span><span class="params">(object target)</span>;</span><br><span class="line">  voidsetProperties(Properties properties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Intercepts(&#123;@signature(type = Executor.class, method = &quot;query&quot;, </span></span><br><span class="line"><span class="meta">    args = &#123;Mappedstatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span></span><br><span class="line">publicclassTestInterceptorimplementsInterceptor &#123;</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> invocation.getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> invocation.getMethod();<span class="comment">//代理方法</span></span><br><span class="line">    Object[] args = invocation.getArgs() <span class="comment">// 方法参数</span></span><br><span class="line">    <span class="comment">// do something ...... 方法拦截前执行代码块</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span>invocation.proceed():</span><br><span class="line">    <span class="comment">// do something ...... 方法拦截后执行代码块</span></span><br><span class="line">    <span class="keyword">return</span> result:</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> object <span class="title function_">plugin</span><span class="params">(object target)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><h2 id="MyBatis-的分页方式"><a href="#MyBatis-的分页方式" class="headerlink" title="MyBatis 的分页方式"></a>MyBatis 的分页方式</h2><p><strong>分页方式：</strong>逻辑分页和物理分页。</p><ul><li><strong>逻辑分页：</strong>使用 <code>MyBatis</code> 自带的 <code>RowBounds</code> 进行分页，它是<strong>一次性查询很多数据，然后在数据中再进行检索</strong>。</li><li><strong>物理分页：</strong>手写 SQL 分页或使用分页插件 <code>PageHelper</code>，去数据库<strong>查询指定条数的分页数据</strong>的形式。</li></ul><h2 id="MyBatis-逻辑分页和物理分页的区别"><a href="#MyBatis-逻辑分页和物理分页的区别" class="headerlink" title="MyBatis 逻辑分页和物理分页的区别"></a>MyBatis 逻辑分页和物理分页的区别</h2><p><strong>逻辑分页</strong>是一次性查询很多数据，然后在结果中检索分页的数据。这样<strong>需要消耗大量的内存、有内存溢出的风险、对数据库压力较大</strong>。<br><strong>物理分页</strong>是从数据库<strong>查询指定条数的数据</strong>，弥补了一次性全部查出的所有数据的缺点，如需要大量内存，数据库查询压力较大等问题。</p><h2 id="RowBounds-是一次性查询全部结果吗？为什么？"><a href="#RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="RowBounds 是一次性查询全部结果吗？为什么？"></a>RowBounds 是一次性查询全部结果吗？为什么？</h2><p><code>RowBounds</code> 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 <em>MyBatis 是对 jdbc 的封装</em>，<strong>在 jdbc 驱动中有一个 <code>Fetch Size</code> 的配置，它规定了每次最多从数据库查询多少条数据</strong>，假如你要查询更多数据，它会在你<strong>执行 next()的时候，去查询更多的数据</strong>。<br>就好比去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()时会自动完成查询工作。这样做的好处可以<strong>有效防止内存溢出</strong>。</p><h2 id="MyBatis-是否支持延迟加载及延迟加载的原理"><a href="#MyBatis-是否支持延迟加载及延迟加载的原理" class="headerlink" title="MyBatis 是否支持延迟加载及延迟加载的原理"></a>MyBatis 是否支持延迟加载及延迟加载的原理</h2><p><code>MyBatis</code> 支持延迟加载，设置 <code>lazyLoadingEnabled=true</code> 。<br><strong>延迟加载的原理</strong>是<strong>调用的时候触发加载</strong>，而不是在初始化的时候就加载信息。<br>比如调用 <code>a. getB(). getName()</code>，这个时候发现 <code>a. getB()</code> 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 <code>a. setB(b)</code>，而这时候再调用 <code>a. getB(). getName()</code> 就有值了，这就是延迟加载的基本原理。</p><h2 id="MyBatis-的一级缓存和二级缓存"><a href="#MyBatis-的一级缓存和二级缓存" class="headerlink" title="MyBatis 的一级缓存和二级缓存"></a>MyBatis 的一级缓存和二级缓存</h2><p><strong>一级缓存：基于<code>PerpetualCache</code>的<code>HashMap</code>本地缓存</strong>，其声明周期和 SQLSession 一致，有多个 SQLSession 或者分布式的环境中数据库操作，<strong>可能会出现脏数据</strong>。<strong>当 <code>Session flush 或 close</code> 之后，该 Session 中的所有 Cache 就将清空</strong>，默认一级缓存开启。<br><strong>二级缓存：</strong>也是<strong>基于 <code>PerpetualCache</code> 的 <code>HashMap</code> 本地缓存</strong>，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，**要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)**。<br><strong>开启二级缓存数据查询流程：</strong><code>二级缓存 -&gt; 一级缓存 -&gt; 数据库</code>。<br><strong>缓存更新机制：</strong>当某一作用域(一级缓存Session/二级缓存Mapper)<strong>进行C/U/D 操作后，默认该作用域下所有select中的缓存将被clear</strong>。</p><h2 id="MyBatis-和-hibernate-的区别"><a href="#MyBatis-和-hibernate-的区别" class="headerlink" title="MyBatis 和 hibernate 的区别"></a>MyBatis 和 hibernate 的区别</h2><p><strong>灵活性：</strong>MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。<br><strong>可移植性：</strong><code>MyBatis</code> 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以<strong>可移植性比较差</strong>。<br><strong>学习和使用门槛：</strong>MyBatis 入门比较简单，使用门槛也更低。<br><strong>二级缓存：</strong><code>hibernate 拥有更好的二级缓存，可以自行更换为第三方的二级缓存</code>。</p><h2 id="MyBatis-有哪些执行器（Executor）"><a href="#MyBatis-有哪些执行器（Executor）" class="headerlink" title="MyBatis 有哪些执行器（Executor）"></a>MyBatis 有哪些执行器（Executor）</h2><p>MyBatis 有<strong>三种</strong>基本的Executor执行器：<br><strong><code>SimpleExecutor：</code><strong>每执行一次 <code>update 或 select</code> 就开启一个 <code>Statement</code> 对象，</strong>用完立刻关闭</strong> Statement 对象；<br><strong><code>ReuseExecutor：</code><strong>执行 <code>update 或 select</code>，</strong>以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建</strong>，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是<strong>重复使用 Statement 对象</strong>；<br>**<code>BatchExecutor：</code>*<em>执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（<code>addBatch()</code>），等待统一执行（<code>executeBatch()</code>），它</em>缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理*，与 jdbc 批处理相同。</p>]]></content>
    
    
    <summary type="html">MyBatis是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="MyBatis" scheme="https://southernfish.github.io/categories/Framwork/MyBatis/"/>
    
    
    <category term="MyBatis" scheme="https://southernfish.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>构建工具Maven</title>
    <link href="https://southernfish.github.io/pages/java/java-maven/"/>
    <id>https://southernfish.github.io/pages/java/java-maven/</id>
    <published>2025-07-29T00:30:00.000Z</published>
    <updated>2025-09-17T07:51:48.708Z</updated>
    
    <content type="html"><![CDATA[<p>Maven项目<a href="https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/1772960?fromModule=lemma_inlink">对象模型</a>(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的<a href="https://baike.baidu.com/item/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/6854630?fromModule=lemma_inlink">项目管理工具</a>软件。</p><p>Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的<a href="https://baike.baidu.com/item/%E5%8F%AF%E9%87%8D%E7%94%A8%E6%80%A7/53650612?fromModule=lemma_inlink">可重用性</a>，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 <a href="https://baike.baidu.com/item/Apache/6265?fromModule=lemma_inlink">Apache</a> <a href="https://baike.baidu.com/item/Jakarta/15952232?fromModule=lemma_inlink">Jakarta</a> 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</p><blockquote><p>参考文章：<a href="https://blog.csdn.net/qq_40991313/article/details/125818307">Maven基础&amp;MyBatis</a></p></blockquote><h1 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h1><p><strong>Maven</strong>是专门用于<strong>管理和构建Java项目</strong>的工具。</p><p><strong>传统项目管理缺点：</strong></p><ul><li>jar包版本不统一、不兼容</li><li>工程升级维护过程操作繁琐</li></ul><p><strong>Maven介绍：</strong></p><p>Maven 的本质是一个<strong>项目管理工具</strong>，将项目开发和管理过程抽象成一个项目对象模型（POM）。</p><p>maven是用java语言写的，它管理的项目都以面对对象形式设计，最终<strong>把一个项目看成一个对象</strong>，即POM。</p><p>**POM:**（Project Object Model）：项目对象模型</p><h2 id="作用和功能"><a href="#作用和功能" class="headerlink" title="作用和功能"></a>作用和功能</h2><p><strong>作用：</strong></p><ul><li><strong>项目构建：</strong>提供标准的、<strong>跨平台</strong>的自动化项目构建方式</li><li><strong>依赖管理：</strong>方便快捷的管理项目依赖的资源（jar包），避免资源间的版本冲突问题</li><li><strong>统一开发结构：</strong>提供标准的、统一的项目结构</li></ul><p><strong>功能</strong>：Maven是专门用于管理和构建Java项目的工具，它的主要功能有：</p><ul><li><p>提供了一套标准化的项目结构</p><p>每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。</p><p>而Maven提供了一套标准化的项目结构，所有的IDE使用Maven构建的项目完全一样，所以IDE创建的Maven项目可以通用。</p></li><li><p><strong>提供了一套标准化的构建流程</strong></p><p>编译，测试，打包，发布……</p></li><li><p><strong>提供了一套依赖管理机制</strong></p><p>Maven使用标准的<strong>坐标</strong>配置来管理各种依赖， 只需要简单的配置就可以完成依赖管理</p></li></ul><h2 id="Maven模型"><a href="#Maven模型" class="headerlink" title="Maven模型"></a>Maven模型</h2><ul><li>项目对象模型pom (Project Object Model)</li><li>依赖管理模型(Dependency)</li><li>插件(Plugin)</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250728212853171.png" alt="image-20250728212853171"></p><p><strong>项目对象模型pom</strong>就是将我们自己抽象成一个对象模型，有自己专属的坐标，是唯一标识。</p><p>项目对象模型pom通过xml格式保存的pom.xml文件。该文件用于管理：源代码、配置文件、开发者的信息和角色、问题追踪系统、组织信息、项目授权、项目的url、项目的依赖关系等等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ReviewTest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>依赖管理模型</strong>则是使用坐标来描述当前项目依赖哪些第三方jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>项目管理模型和依赖管理模型结合起来，体现Maven方便的依赖管理。</p><p><strong>构建生命周期和插件部分</strong>用来完成 <strong><code>标准化构建流程</code></strong> 。</p><p>如我们需要<strong>编译</strong>，Maven提供了一个编译插件供我们使用。我们需要<strong>打包</strong>，Maven就提供了一个打包插件提供我们使用等。 </p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>Maven用坐标配置管理依赖。</p><p>依赖jar包则其实存储在本地仓库中，项目运行时从本地仓库中拿需要的依赖jar包。</p><ul><li><strong>本地仓库</strong>：自己电脑上存储资源的仓库（是个目录），连接远程仓库获取资源</li><li><strong>中央仓库</strong>：由Maven团队维护的全球唯一的仓库，Maven团队维护，存储所有资源的仓库<ul><li>地址： <a href="https://repo1.maven.org/maven2/">Central Repository:</a></li></ul></li><li>**远程仓库(私服)**：一般由公司团队搭建的私有仓库。部门/公司范围内存储资源的仓库，从中央仓库获取资源</li></ul><p><strong>私服的作用：</strong></p><ul><li>保存具有版权的资源，包含购买或自主研发的jar。中央仓库中的jar都是开源的，不能存储具有版权的资源</li><li>一定范围内共享资源，仅对内部开放，不对外共享</li></ul><p>当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包：</p><ul><li>如果有，则在项目直接引用;</li><li>如果没有，则去中央仓库中下载对应的jar包到本地仓库。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250728213201201.png" alt="image-20250728213201201"></p><p>如果还可以搭建远程仓库，将来jar包的查找顺序则变为：</p><blockquote><p>本地仓库 –&gt; 远程仓库–&gt; 中央仓库</p></blockquote><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250728213219867.png" alt="image-20250728213219867"></p><h3 id="Maven-坐标详解"><a href="#Maven-坐标详解" class="headerlink" title="Maven 坐标详解"></a>Maven 坐标详解</h3><p><strong>什么是坐标？</strong></p><ul><li>Maven 中的坐标是<strong>资源的唯一标识</strong></li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul><p><strong>所有坐标官网（需要梯子）：</strong><a href="https://mvnrepository.com/">Maven Repository</a></p><p>Maven 坐标主要组成</p><p>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</p><p>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）</p><p>version：定义当前项目版本号</p><p>scope：范围，像Servlet、jsp依赖都需要设置范围为provided</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      此处为什么需要添加该标签?</span></span><br><span class="line"><span class="comment">      provided指的是在编译和测试过程中有效,在运行时无效，最后生成的war包时不会加入</span></span><br><span class="line"><span class="comment">       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li>上面所说的资源可以是插件、依赖、当前项目。</li><li>我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</li></ul></blockquote><h1 id="Maven基本使用"><a href="#Maven基本使用" class="headerlink" title="Maven基本使用"></a>Maven基本使用</h1><h2 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h2><p>compile ：编译，生成target目录</p><p>clean：清理，删除target目录</p><p>test：测试，执行test文件下测试代码</p><p>package：打包，将当前项目打包成的jar包</p><p>install：安装，将当前项目打成jar包，并安装到本地仓库</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250728213443172.png" alt="image-20250728213443172"></p><p><strong>编译命令 mvn compile</strong></p><p>首次编译会先从阿里云（之前conf/settings.xml配置了阿里云私服）下载编译需要插件的jar包，在本地仓库（之前conf/settings.xml配置了本地仓库位置）也能看到下载好的插件。</p><p>在项目下会生成一个 <code>target</code> 目录，里面保存编译后的字节码文件。</p><p><strong>清理命令 mvn clean</strong></p><ul><li>从阿里云下载清理需要的插件jar包</li><li>删除项目下的 <code>target</code> 目录</li></ul><h2 id="Maven-生命周期"><a href="#Maven-生命周期" class="headerlink" title="Maven 生命周期"></a>Maven 生命周期</h2><blockquote><p><strong>简洁版：</strong></p><ul><li><strong>clean：</strong>清理上次构建结果</li><li><strong>valide：</strong>校验工程信息是否正确</li><li><strong>comple：</strong>编译工程</li><li><strong>test：</strong>执行工程测试流程(标注的test的程序)</li><li><strong>package：</strong>打包工程</li><li><strong>verify：</strong>验证包的有效性</li><li><strong>install：</strong>安装包到本地仓库</li><li><strong>deploy：</strong>推送包到远程仓库</li></ul></blockquote><p>Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件</p><p>Maven 对项目构建的生命周期划分为3套：</p><ul><li><strong>clean ：</strong>项目清理的处理，移除所有上一次构建生成的文件。</li><li><strong>default(或 build)</strong> ：核心工作，例如编译，测试，打包，安装等。</li><li><strong>site</strong> ： 产生报告，发布站点等。这套生命周期一般不会使用。</li></ul><p><strong>Clean 生命周期</strong></p><p>执行 mvn post-clean 命令时，Maven 调用 clean 生命周期，它包含以下阶段：</p><ul><li>pre-clean：执行一些需要在clean之前完成的工作</li><li>clean：移除所有上一次构建生成的文件</li><li>post-clean：执行一些需要在clean之后立刻完成的工作</li></ul><p><strong>default生命周期</strong> </p><table><thead><tr><th align="left">阶段</th><th align="left">处理</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">验证 validate</td><td align="left">验证项目</td><td align="left">验证项目是否正确且所有必须信息是可用的</td></tr><tr><td align="left">编译 compile</td><td align="left">执行编译</td><td align="left">源代码编译在此阶段完成</td></tr><tr><td align="left">测试 Test</td><td align="left">测试</td><td align="left">使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td align="left">包装 package</td><td align="left">打包</td><td align="left">创建JAR/WAR包如在 pom.xml 中定义提及的包</td></tr><tr><td align="left">检查 verify</td><td align="left">检查</td><td align="left">对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td align="left">安装 install</td><td align="left">安装</td><td align="left">安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td align="left">部署 deploy</td><td align="left">部署</td><td align="left">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr></tbody></table><blockquote><p><strong>注意：</strong></p><ul><li><strong>打包前先clean是好习惯，能够保证上一次构建的输出不会影响到本次构建。</strong></li><li><strong>同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如执行安装会先执行打包。</strong></li></ul></blockquote><p><strong>site构建生命周期：</strong></p><ul><li>pre-site：执行一些需要在生成站点文档之前完成的工作</li><li>site：生成项目的站点文档</li><li>post-site： 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li><li>site-deploy：将生成的站点文档部署到特定的服务器上</li></ul><h2 id="pom文件配置编码及JDK版本"><a href="#pom文件配置编码及JDK版本" class="headerlink" title="pom文件配置编码及JDK版本"></a><strong>pom文件配置编码及JDK版本</strong></h2><p> 在pom.xml配置如下代码，适用于项目要在不同项目移动：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">maven.compiler.encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Maven依赖管理"><a href="#Maven依赖管理" class="headerlink" title="Maven依赖管理"></a>Maven依赖管理</h1><h2 id="依赖概述"><a href="#依赖概述" class="headerlink" title="依赖概述"></a>依赖概述</h2><p><strong>依赖</strong>指当前项目运行所需的jar，一个项目可以设置多个依赖。</p><p>groupId：依赖所属群组id。</p><p>artifactId：依赖所属项目id。</p><p>version：依赖版本号。</p><p>scope：依赖生效范围。</p><p>optional：为true时是可选依赖，指对外隐藏当前所依赖的资源——不透明。设置后其他依赖引用本项目时候将无法看到这个依赖。控制别人能不能看到你用到你。</p><p>exclusions-exclusion：排除依赖指主动断开依赖的资源，被排除的资源无需指定版本。控制你引用的项目中需要排除的依赖。</p><p><strong>依赖范围scope</strong></p><p>依赖的jar默认在任何地方使用，通过scope便签设定其范围。</p><p>通过设置坐标的依赖范围(scope)，可以设置对应jar包的作用范围：编译环境、测试环境、运行环境。</p><p>如下图所示给 <code>junit</code> 依赖通过 <code>scope</code> 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>依赖范围scope可取值：</strong></p><table><thead><tr><th align="left"><strong>依赖范围</strong></th><th align="left">编译classpath</th><th align="left">测试classpath</th><th align="left">运行classpath</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left"><strong>compile</strong></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">logback</td></tr><tr><td align="left"><strong>test</strong></td><td align="left">-</td><td align="left">Y</td><td align="left">-</td><td align="left">Junit</td></tr><tr><td align="left"><strong>provided</strong></td><td align="left">Y</td><td align="left">Y</td><td align="left">-</td><td align="left">servlet-api</td></tr><tr><td align="left"><strong>runtime</strong></td><td align="left">-</td><td align="left">Y</td><td align="left">Y</td><td align="left">jdbc驱动</td></tr><tr><td align="left"><strong>system</strong></td><td align="left">Y</td><td align="left">Y</td><td align="left">-</td><td align="left">存储在本地的jar包</td></tr></tbody></table><p>配置后可以在依赖中看到：org.mybatis:mybatis:3.5.3 (runtime)</p><p><strong>依赖具有传递性</strong></p><p><strong>直接依赖</strong>：在当前项目中通过依赖配置建立的依赖关系</p><p><strong>间接依赖</strong>：被资源的资源如果依赖其他资源，当前项目间接依赖其他资源</p><p><strong>依赖传递冲突问题</strong></p><p><strong>路径优先：</strong>当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高</p><p><strong>声明优先：</strong>当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的</p><p><strong>特殊优先：</strong>当同级配置了相同资源的不同版本，<strong>后配置的覆盖先配置的</strong></p><p><strong>可选依赖</strong>optional</p><p>可选依赖指对外隐藏当前所依赖的资源——不透明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>排除依赖</strong>exclusions-exclusion</p><p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exClusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="依赖jar包引用，设置自动刷新"><a href="#依赖jar包引用，设置自动刷新" class="headerlink" title="依赖jar包引用，设置自动刷新"></a>依赖jar包引用，设置自动刷新</h2><p>使用坐标引入依赖的jar包</p><ol><li><p>在项目的 pom.xml 中编写 <code>&lt;dependencies&gt;</code> 标签</p></li><li><p>在 <code>&lt;dependencies&gt;</code> 标签中 使用 <code>&lt;dependency&gt;</code> 引入坐标</p></li><li><p>定义坐标的 groupId，artifactId，version</p></li></ol><blockquote><p><strong>groupId：</strong>定义当前<a href="https://so.csdn.net/so/search?q=Maven&spm=1001.2101.3001.7020">Maven</a>项目隶属的实际项目。</p><p>例如org.sonatype.nexus，此id前半部分org.sonatype代表此项目隶属的组织或公司，后部分代表项目的名称。</p><p>如果此项目多模块话开发的话就子模块可以分为org.sonatype.nexus.plugins和org.sonatype.nexus.utils等。特别注意的是groupId不应该对应项目隶属的组织或公司，也就是说groupId不能只有org.sonatype而没有nexus。</p><p><strong>artifactId：</strong>构件ID。该元素定义实际项目中的一个Maven项目或者是子模块，如上面官方约定中所说，<strong>构建名称必须小写字母，没有其他的特殊字符</strong>，推荐使用“<strong>实际项目名称－模块名称</strong>”的方式定义，例如：spirng-mvn、spring-core等。</p></blockquote><p><strong>快捷方式引入jar包</strong></p><ol><li>在 pom.xml 中 按 alt + insert，选择 Dependency</li><li>在弹出的面板中搜索对应坐标，然后双击选中对应坐标</li><li>点击刷新按钮，使坐标生效</li></ol><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能。</li><li>默认maven在各个生命周期上绑定有预设的功能。</li><li>通过插件可以自定义其他功能。</li></ul><p><strong>示例：Tomcat部署的插件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Maven项目&lt;a href=&quot;https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/1772960?fromModule=lemma_inlink&quot;&gt;对象模型&lt;/a&gt;(POM)，可以通过一小段描</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="maven" scheme="https://southernfish.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型模式</title>
    <link href="https://southernfish.github.io/pages/java/java-design-pattern-behavioral/"/>
    <id>https://southernfish.github.io/pages/java/java-design-pattern-behavioral/</id>
    <published>2025-07-28T12:00:00.000Z</published>
    <updated>2025-09-17T07:51:48.706Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p><p><strong>行为型模式</strong>（Behavioral Patterns）：主要<strong>用于描述对象之间的通信和责任分配</strong>，包括多个不同的模式，如“策略模式”、“模板方法模式”、“观察者模式”、“迭代器模式”、“职责链模式”、“命令模式”、“访问者模式”、“备忘录模式”和“解释器模式”等。这些模式通常用于实现不同的算法、流程和通信方式，以实现系统的更高灵活性和可维护性。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130448194">设计模式——模板模式</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130451520">设计模式——观察者模式</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130412327?spm=1001.2014.3001.5502">设计模式——责任链模式</a></p></blockquote><h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>模板方法模式（Template Method Pattern），又叫模板模式（Template Pattern），在一个<strong>抽象类</strong>公开<strong>定义了</strong>执行它的方法的<strong>模板</strong>。它的<strong>子类可以按需要重写方法实现</strong>，但调用将以抽象类中定义的方式进行</li><li>简单说，模板方法模式定义一个操作中的算法的骨架，而<strong>将一些步骤延迟到子类中</strong>，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</li></ul><p><strong>实现方式：</strong>抽象类有一个模板方法和其他行为方法，模板方法按流程调用各行为方法（抽象或非抽象）；具体子类重写抽象的行为方法。</p><p><strong>模板方法模式的角色和职责</strong></p><ul><li><p><code>AbstractClass</code>抽象类中实现了模板方法，定义了算法的骨架，具体子类需要去实现其抽象方法或重写其中方法</p></li><li><p><code>ConcreteClass</code>实现了抽象方法，已完成算法中特定子类的步骤</p></li></ul><p><strong>注意事项和细节</strong></p><ol><li><strong>基本思想</strong>：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改</li><li>实现了最大化<strong>代码复用</strong>。父类的模板方法和已实现的某些步骤会被子类继承而直接使用</li><li>既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现</li><li><strong>不足之处</strong>：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大</li><li>一般<strong>模板方法都加上final关键字</strong>，防止子类重写模板方法</li><li><strong>使用场景</strong>：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法模式来处理</li></ol><h2 id="模板模式解决豆浆制作问题"><a href="#模板模式解决豆浆制作问题" class="headerlink" title="模板模式解决豆浆制作问题"></a>模板模式解决豆浆制作问题</h2><p>编写制作豆浆的程序，说明如下：</p><ol><li>制作豆浆的流程选材 → 添加配料 → 浸泡  → 放到豆浆机打碎</li><li>通过添加不同的配料，可以制作出不同口味的豆浆</li><li>选材、浸泡和放到豆浆机打碎这几个步骤是一个模板方法，对于制作每种口味的豆浆都是一样的</li><li>请使用模板方法模式完成</li></ol><blockquote><p>说明：因为模板方法模式比较简单，很容易就想到这个方案，因此就直接使用，不再使用传统的方案来引出模板方法模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">    <span class="comment">// 模板方法，定义为final禁止覆写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;豆浆制作开始&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        useSoyBean();</span><br><span class="line">        addIngredients();</span><br><span class="line">        soak();</span><br><span class="line">        mash();</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;豆浆制作结束&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同包可见、对其他包下的子类可见。</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">useSoyBean</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Step1. 选用上好的黄豆.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加原材料是抽象方法，因为不同豆浆原材料不一样</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addIngredients</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">soak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Step3. 对黄豆和配料进行水洗浸泡.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">mash</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Step4. 将充分浸泡过的黄豆和配料放入豆浆机中，开始打豆浆.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 花生豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeanutSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PeanutSoyaMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============花生豆浆============&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addIngredients</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Step2. 加入上好的花生.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 红豆豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedBeanSoyaMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============红豆豆浆============&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addIngredients</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Step2. 加入上好的红豆.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 芝麻豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SesameSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SesameSoyaMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============芝麻豆浆============&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addIngredients</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Step2. 加入上好的芝麻.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端调用模板方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SoyaMilk</span> <span class="variable">peanutSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PeanutSoyaMilk</span>();</span><br><span class="line">peanutSoyaMilk.make();</span><br><span class="line"><span class="type">SoyaMilk</span> <span class="variable">redBeanSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedBeanSoyaMilk</span>();</span><br><span class="line">redBeanSoyaMilk.make();</span><br><span class="line"><span class="type">SoyaMilk</span> <span class="variable">sesameSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SesameSoyaMilk</span>();</span><br><span class="line">sesameSoyaMilk.make();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">============花生豆浆============</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt;&gt;&gt;&gt;豆浆制作开始&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment">Step1. 选用上好的黄豆.</span></span><br><span class="line"><span class="comment">Step2. 加入上好的花生.</span></span><br><span class="line"><span class="comment">Step3. 对黄豆和配料进行水洗浸泡.</span></span><br><span class="line"><span class="comment">Step4. 将充分浸泡过的黄豆和配料放入豆浆机中，开始打豆浆.</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt;&gt;&gt;&gt;豆浆制作结束&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment">============红豆豆浆============</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">============芝麻豆浆============</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h2><p>在模板方法模式的父类中，我们可以定义一个<strong>方法，它默认不做任何事，子类可以视情况要不要覆盖它</strong>，该方法称为“钩子”</p><p>用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，请使用钩子方法对前面的模板方法进行改造</p><p><strong>抽象类和具体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象模板类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 如果钩子方法决定加配料，就加配料；否则不执行加配料操作。</span></span><br><span class="line">        <span class="keyword">if</span> (customAddIngredients()) &#123;</span><br><span class="line">            addIngredients();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 钩子方法，决定是否需要添加配料。默认情况是加配料。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">customAddIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纯豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PureSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PureSoyaMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============纯豆浆============&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 空实现即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Boolean <span class="title function_">customAddIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端，测试钩子方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SoyaMilk</span> <span class="variable">pureSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PureSoyaMilk</span>();</span><br><span class="line">pureSoyaMilk.make();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">============纯豆浆============</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt;&gt;&gt;&gt;豆浆制作开始&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment">Step1. 选用上好的黄豆.</span></span><br><span class="line"><span class="comment">Step3. 对黄豆和配料进行水洗浸泡.</span></span><br><span class="line"><span class="comment">Step4. 将充分浸泡过的黄豆和配料放入豆浆机中，开始打豆浆.</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt;&gt;&gt;&gt;豆浆制作结束&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Spring-框架AbstractApplicationContext抽象类"><a href="#Spring-框架AbstractApplicationContext抽象类" class="headerlink" title="Spring 框架AbstractApplicationContext抽象类"></a>Spring 框架AbstractApplicationContext抽象类</h2><p>AbstractApplicationContext.java中有一个refresh()方法就是模板方法，它用于根据流程调用aop代理创建、bean生命周期初始化、属性注入等启动并初始化Spring应用上下文的方法。</p><blockquote><p><strong>AbstractApplicationContext</strong>抽象类是ApplicationContext接口的一种默认实现，提供了一些<strong>通用的应用上下文功能</strong>，同时也为其他具体的应用上下文实现类提供了一些可扩展的方法。</p><p><strong>应用上下文：</strong>负责管理各种bean以及它们之间的关系，并对它们进行生命周期的管理。 </p></blockquote><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250728171446139.png" alt="image-20250728171446139"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            postProcessBeanFactory(beanFactory);     <span class="comment">// 钩子方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            initMessageSource();</span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            onRefresh();                             <span class="comment">// 钩子方法</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            destroyBeans();</span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    refreshBeanFactory(); <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory(); <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JUC包下的AQS抽象队列同步器"><a href="#JUC包下的AQS抽象队列同步器" class="headerlink" title="JUC包下的AQS抽象队列同步器"></a>JUC包下的AQS抽象队列同步器</h2><p>AQS是基于模板方法模式进行设计的。锁的实现类需要继承AQS并重写它指定的方法。</p><p>AQS的模板方法将“<strong>管理同步状态的逻辑</strong>”提炼出来形成标准流程，这些方法主要包括：独占式获取同步状态、独占式释放同步状态、共享式获取同步状态、共享式释放同步状态。 </p><p><strong>AQS（AbstractQueuedSynchronizer抽象队列同步器）</strong>：</p><p>AQS是实现锁或者其他同步器（用于协调线程之间对共享资源的访问）的核心框架。AQS是一个抽象类，在<code>JUC.locks</code>包下，它通过内部的状态变量和同步队列来实现线程的同步（允许多个线程协作共享访问共享资源）。很多锁和同步器都是基于AQS实现的。ReentrantLock，ThreadPoolExecutor，CountDownLatch等都是基于AQS实现。</p><ul><li><p><strong>ReentrantLock：</strong>可重入锁，同一个线程在持有锁的情况下，可以重复地获取该锁，无需等待，只需记录重入次数。能防止死锁，因为不用线程自己等待自己释放锁。是Lock接口的实现类。可以通过构造参数true或false指定公平锁或非公平锁，可以通过newCondition()方法创建多个Condition对象分组唤醒等待线程。</p><ul><li><p><strong>公平锁：</strong>按加锁顺序获取锁。线程竞争锁时判断AQS队列里有没有等待线程，有就加入队尾。</p></li><li><p><strong>非公平锁（默认）：</strong>可能某个线程会不断获取锁，牺牲公平的情况下提高了效率。不管AQS队列里有没有等待线程，都会先尝试获取锁；如果抢占不到，再加入队尾。如果线程刚好在上个线程释放时拿到锁，就不用像公平锁那样还要阻塞等待、放队尾、唤醒，这些操作涉及到对内核的切换，对性能有影响。</p></li><li><p><strong>Condition对象：</strong>用于线程间通信，通过await()和signal(),signalAll()让线程等待或唤醒。通常用lock锁创建Condition对象，即lock.newCondition();</p></li></ul></li><li><p><strong>CountDownLatch：</strong>计数器，它允许一个或多个线程等待其他线程完成操作后再执行。countDown()方法让计数器减一，await()方法阻塞当前线程直到计数器减为0。</p></li><li><p><strong>ThreadPoolExecutor。</strong></p></li></ul><p><strong>state变量和等待队列：</strong></p><ul><li><strong>state变量：</strong>在AQS中，volatile类型的state变量表示锁的状态，通过CAS原子操作这个状态变量来保证线程安全。初始是0，代表没拿到锁，1代表拿到锁。</li><li><strong>同步队列：</strong>在AQS中，FIFO（先入先出）队列用来管理等待锁的线程，队列每个节点记录等待锁的线程的地址、状态、等待锁的条件。先入先出确保同步器的公平性，也就是先等待的线程先获得锁。队列底层是双向链表。</li></ul><p><strong>实现线程同步的原理：</strong>线程通过CAS原子性修改state变量，修改成功则获得锁，失败则插入队尾等待。  </p><p><strong>基于模板方法：</strong>AQS是基于模板方法模式进行设计的。锁的实现类需要继承AQS并重写它指定的方法。</p><p><strong>模板方法：</strong>抽象类有一个模板方法和其他行为方法，模板方法按流程调用各行为方法（抽象或非抽象）；具体子类重写抽象的行为方法。 </p><hr><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="天气预报需求"><a href="#天气预报需求" class="headerlink" title="天气预报需求"></a>天气预报需求</h2><p>具体要求如下：</p><ol><li>气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去（比如发布到自己的网站或第三方）</li><li>需要<strong>设计开放型 API</strong>，便于其他<strong>第三方也能接入气象站获取数据</strong></li><li>提供温度、气压和湿度的接口</li><li><strong>测量数据更新时，要能实时的通知给第三方</strong></li></ol><h2 id="天气预报需求方案之普通方案"><a href="#天气预报需求方案之普通方案" class="headerlink" title="天气预报需求方案之普通方案"></a>天气预报需求方案之普通方案</h2><p><strong>WeatherData类</strong></p><p>通过对气象站项目的分析，我们可以初步设计出一个天气数据类WeatherData类</p><ol><li>通过<code>getXxx</code>方法，可以让第三方接入，并得到相关信息</li><li>当数据有更新时，气象站通过调用<strong>dataChange()去更新数据</strong>，当第三方再次获取时，就能得到最新数据，当然也可以推送</li></ol><p>CurrentConditions（当前的天气情况）可以理解成是我们气象局的网站</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前的天气情况：可以理解成是气象局的网站</span></span><br><span class="line"><span class="comment">// 当前天气状况类，即气象网，用于展示天气数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentConditions</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Float temperature;</span><br><span class="line">    <span class="keyword">private</span> Float pressure;</span><br><span class="line">    <span class="keyword">private</span> Float humidity;</span><br><span class="line">    <span class="comment">// 更新天气情况，通过推送的方式，由 WeatherData 调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Float temperature, Float pressure, Float humidity)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新最新天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="comment">// 展示最新天气数据</span></span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公告板展示天气情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============最新天气============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 当前温度：&quot;</span> + <span class="built_in">this</span>.temperature + <span class="string">&quot; ℃ ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 当前气压：&quot;</span> + <span class="built_in">this</span>.pressure + <span class="string">&quot; kPa ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 当前湿度：&quot;</span> + <span class="built_in">this</span>.humidity + <span class="string">&quot; %RH ***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 天气数据类</span></span><br><span class="line"><span class="comment">// 包含最新的天气信息情况，含有 CurrentConditions 对象，当数据更新时，主动调用 CurrentConditions 的 update() 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Float temperature;</span><br><span class="line">    <span class="keyword">private</span> Float pressure;</span><br><span class="line">    <span class="keyword">private</span> Float humidity;</span><br><span class="line">    <span class="keyword">private</span> CurrentConditions conditions;</span><br><span class="line">    <span class="comment">// 传入 CurrentConditions 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">(CurrentConditions conditions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conditions = conditions;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temperature, pressure, humidity getter</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 推送天气数据到网站</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataChange</span><span class="params">()</span> &#123;</span><br><span class="line">        conditions.update(getTemperature(), getPressure(), getHumidity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当天气数据发生变化时进行更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Float temperature, Float pressure, Float humidity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        dataChange();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建气象网站对象</span></span><br><span class="line"><span class="type">CurrentConditions</span> <span class="variable">currentConditions</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CurrentConditions</span>();</span><br><span class="line"><span class="comment">// 创建气象数据对象，并传入气象网站对象</span></span><br><span class="line"><span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>(currentConditions);</span><br><span class="line"><span class="comment">// 天气发生变化时，更新最新的气象数据</span></span><br><span class="line">weatherData.setData(<span class="number">10f</span>, <span class="number">150f</span>, <span class="number">40f</span>);</span><br><span class="line"><span class="comment">//weatherData.setData(15f, 130f, 60f);</span></span><br><span class="line"><span class="comment">//weatherData.setData(13f, 160f, 20f);</span></span><br><span class="line"><span class="comment">// 结果输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">============最新天气============</span></span><br><span class="line"><span class="comment">*** 当前温度：10.0 ℃ ***</span></span><br><span class="line"><span class="comment">*** 当前气压：150.0 kPa ***</span></span><br><span class="line"><span class="comment">*** 当前湿度：40.0 %RH ***</span></span><br><span class="line"><span class="comment">============最新天气============</span></span><br><span class="line"><span class="comment">*** 当前温度：15.0 ℃ ***</span></span><br><span class="line"><span class="comment">*** 当前气压：130.0 kPa ***</span></span><br><span class="line"><span class="comment">*** 当前湿度：60.0 %RH ***</span></span><br><span class="line"><span class="comment">============最新天气============</span></span><br><span class="line"><span class="comment">*** 当前温度：13.0 ℃ ***</span></span><br><span class="line"><span class="comment">*** 当前气压：160.0 kPa ***</span></span><br><span class="line"><span class="comment">*** 当前湿度：20.0 %RH ***</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>问题分析</strong></p><ol><li>其他第三方接入气象站获取数据的问题</li><li>无法在运行时动态的添加第三方（如xx网站）</li><li>违反<code>OCP</code>原则 =&gt; <strong>观察者模式</strong></li></ol><p>在<code>WeatherData</code>中增加第三方时，都需要创建对应的第三方公台板对象并加入到<code>dataChange()</code>方法中，既不是动态加入，也不利于维护</p><h2 id="观察者模式介绍"><a href="#观察者模式介绍" class="headerlink" title="观察者模式介绍"></a>观察者模式介绍</h2><p>观察者模式是一种<strong>行为型设计模式（</strong>用于描述对象之间的通信和责任分配<strong>）</strong>，它定义了对象之间<strong>一对多</strong>的依赖关系，使得当主题对象状态发生改变时，所有依赖于它的观察者对象都能够<strong>得到通知并自动更新</strong>。该模式的核心是抽象对象与观察者之间的耦合度达到了最小化，从而使系统更加灵活且易于扩展。</p><p><strong>实现方法：</strong></p><ol><li>主题对象实现主题接口的注册、移除、通知方法，并管理资源和观察者列表；</li><li>观察者对象实现观察者接口的更新方法，并管理资源；</li><li>主题对象通知方法：遍历观察者列表执行更新方法。</li></ol><p>在观察者模式中，<strong>主题对象</strong>（也称为被观察者）<strong>维护一个观察者列表</strong>，并提供方法用于<strong>添加、删除和通知观察者</strong>。当主题状态发生改变时，它会遍历观察者列表并调用每个观察者的更新方法，从而通知它们状态已经改变。</p><ul><li>主题接口：有注册、移除和通知功能；</li><li>主题实现类：实现主题接口，管理资源和观察者列表；</li><li>观察者接口：发起更新资源请求；</li><li>观察者实现类：发起更新资源请求、使用资源</li></ul><p><strong>优点：</strong></p><ol><li><strong>降低了对象之间的耦合度</strong>，因为主题对象不需要知道观察者的具体实现，只需要知道观察者实现了一个特定接口即可。</li><li>可以<strong>动态扩展观察者列表</strong>，方便灵活。</li><li>实现了对象之间的<strong>一对多</strong>依赖关系，提高了系统的<strong>可维护性和可重用性</strong>。遵守了<strong>ocp原则（开闭原则</strong>：对扩展开放，对修改关闭）。</li></ol><p><strong>缺点</strong>：</p><ol><li>当观察者过多时，通知过程需要花费较多的时间，会影响系统的性能。</li><li>如果观察者与主题对象之间存在<strong>循环依赖</strong>，可能会出现<strong>死循环</strong>。</li></ol><p>观察者模式在Java中的应用非常广泛，例如Swing中的Listener、Servlet中的Listener、Spring中的事件监听、JDK的Observable等等。</p><h2 id="观察者模式优化天气预报案例"><a href="#观察者模式优化天气预报案例" class="headerlink" title="观察者模式优化天气预报案例"></a>观察者模式优化天气预报案例</h2><p>Subject接口：主体接口，有注册、移除和通知功能；</p><p>WeatherData类：主体实现类，实现Subject接口，聚合观察者列表，管理天气信息和观察者列表；</p><p>Observer接口：观察者接口，发起更新天气信息请求；</p><p>CurrentCondition类：观察者实现类，发起更新天气信息请求和使用天气</p><p><strong>主题Subject</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主体对象接口，有注册、移除和通知功能；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>;    <span class="comment">// 注册某观察者</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;    <span class="comment">// 移除某观察者</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;                <span class="comment">// 通知</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主体对象实现，聚合观察者列表，管理天气信息和观察者列表；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherData</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Float temperature;</span><br><span class="line">    <span class="keyword">private</span> Float pressure;</span><br><span class="line">    <span class="keyword">private</span> Float humidity;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observerList;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span> &#123;</span><br><span class="line">        observerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temperature, pressure, humidity getter</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 推送天气数据到网站</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataChange</span><span class="params">()</span> &#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当天气数据发生变化时进行更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Float temperature, Float pressure, Float humidity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        dataChange();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册某观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        observerList.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除某观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o!= <span class="literal">null</span> &amp;&amp; observerList.contains(o)) &#123;</span><br><span class="line">            observerList.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observerList) &#123;</span><br><span class="line">            observer.update(temperature, pressure, humidity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>观察者对象Observer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者接口，发起更新天气信息请求；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Float temperature, Float pressure, Float humidity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者实现，发起更新天气信息请求和使用天气</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentConditions</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Float temperature;</span><br><span class="line">    <span class="keyword">private</span> Float pressure;</span><br><span class="line">    <span class="keyword">private</span> Float humidity;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Float temperature, Float pressure, Float humidity)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新最新天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="comment">// 展示最新天气数据</span></span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公告板展示天气情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============最新天气============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 当前温度：&quot;</span> + <span class="built_in">this</span>.temperature + <span class="string">&quot; ℃ ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 当前气压：&quot;</span> + <span class="built_in">this</span>.pressure + <span class="string">&quot; kPa ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 当前湿度：&quot;</span> + <span class="built_in">this</span>.humidity + <span class="string">&quot; %RH ***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建气象网站对象</span></span><br><span class="line"><span class="type">CurrentConditions</span> <span class="variable">currentConditions</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CurrentConditions</span>();</span><br><span class="line"><span class="comment">// 创建气象数据对象</span></span><br><span class="line"><span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>();</span><br><span class="line"><span class="comment">// 注册气象网站对象</span></span><br><span class="line">weatherData.registerObserver(currentConditions);</span><br><span class="line"><span class="comment">// 天气发生变化时，更新最新的气象数据</span></span><br><span class="line">weatherData.setData(<span class="number">10f</span>, <span class="number">150f</span>, <span class="number">40f</span>);</span><br><span class="line"><span class="comment">//============最新天气============</span></span><br><span class="line"><span class="comment">//*** 当前温度：10.0 ℃ ***</span></span><br><span class="line"><span class="comment">//*** 当前气压：150.0 kPa ***</span></span><br><span class="line"><span class="comment">//*** 当前湿度：40.0 %RH ***</span></span><br></pre></td></tr></table></figure><p><strong>观察者模式的好处</strong></p><ul><li>观察者模式设计后，会以集合的方式来管理用户<code>Observer</code>，包括注册、移除和通知</li><li>这样<strong>增加观察者</strong>（新的公告板）时，就不需要去修改核心类<code>WeatherData</code>不会修改代码，遵守了 OCP 原则（开闭原则）</li></ul><p>新增<code>SinaWebSite</code>和<code>BaiDuWebSite</code>两个三方网站，接口气象局。此时三方只需实现相应接口即可，<code>WeatherData</code>不需要有任何的改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增的三方观察者对象——新浪网</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinaWebSite</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Float temperature;</span><br><span class="line">    <span class="keyword">private</span> Float pressure;</span><br><span class="line">    <span class="keyword">private</span> Float humidity;</span><br><span class="line">    <span class="comment">// 更新天气情况，通过推送的方式，由 WeatherData 调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Float temperature, Float pressure, Float humidity)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新最新天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="comment">// 展示最新天气数据</span></span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公告板展示天气情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============新浪网-最新天气============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 新浪网-当前温度：&quot;</span> + <span class="built_in">this</span>.temperature + <span class="string">&quot; ℃ ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 新浪网-当前气压：&quot;</span> + <span class="built_in">this</span>.pressure + <span class="string">&quot; kPa ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 新浪网-当前湿度：&quot;</span> + <span class="built_in">this</span>.humidity + <span class="string">&quot; %RH ***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增的三方观察者对象——百度网</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaiDuWebSite</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Float temperature;</span><br><span class="line">    <span class="keyword">private</span> Float pressure;</span><br><span class="line">    <span class="keyword">private</span> Float humidity;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 更新天气情况，通过推送的方式，由 WeatherData 调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Float temperature, Float pressure, Float humidity)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新最新天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="comment">// 展示最新天气数据</span></span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 公告板展示天气情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============百度网-最新天气============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 百度网-当前温度：&quot;</span> + <span class="built_in">this</span>.temperature + <span class="string">&quot; ℃ ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 百度网-当前气压：&quot;</span> + <span class="built_in">this</span>.pressure + <span class="string">&quot; kPa ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 百度网-当前湿度：&quot;</span> + <span class="built_in">this</span>.humidity + <span class="string">&quot; %RH ***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>调用测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增三方气象网站，只需注册即可</span></span><br><span class="line">weatherData.registerObserver(<span class="keyword">new</span> <span class="title class_">SinaWebSite</span>());</span><br><span class="line">weatherData.registerObserver(<span class="keyword">new</span> <span class="title class_">BaiDuWebSite</span>());</span><br><span class="line"><span class="comment">// 天气发生变化时，更新最新的气象数据</span></span><br><span class="line">weatherData.setData(<span class="number">15f</span>, <span class="number">120f</span>, <span class="number">80f</span>);</span><br><span class="line"><span class="comment">//============最新天气============</span></span><br><span class="line"><span class="comment">//*** 当前温度：15.0 ℃ ***</span></span><br><span class="line"><span class="comment">//*** 当前气压：120.0 kPa ***</span></span><br><span class="line"><span class="comment">//*** 当前湿度：80.0 %RH ***</span></span><br><span class="line"><span class="comment">//============新浪网-最新天气============</span></span><br><span class="line"><span class="comment">//*** 新浪网-当前温度：15.0 ℃ ***</span></span><br><span class="line"><span class="comment">//*** 新浪网-当前气压：120.0 kPa ***</span></span><br><span class="line"><span class="comment">//*** 新浪网-当前湿度：80.0 %RH ***</span></span><br><span class="line"><span class="comment">//============百度网-最新天气============</span></span><br><span class="line"><span class="comment">//*** 百度网-当前温度：15.0 ℃ ***</span></span><br><span class="line"><span class="comment">//*** 百度网-当前气压：120.0 kPa ***</span></span><br><span class="line"><span class="comment">//*** 百度网-当前湿度：80.0 %RH ***</span></span><br></pre></td></tr></table></figure><p>当三方网站不再需要时，只要做相应的移除即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除气象网站</span></span><br><span class="line">weatherData.removeObserver(currentConditions);</span><br><span class="line">weatherData.setData(<span class="number">20f</span>, <span class="number">160f</span>, <span class="number">30f</span>);</span><br><span class="line"><span class="comment">//============新浪网-最新天气============</span></span><br><span class="line"><span class="comment">//*** 新浪网-当前温度：20.0 ℃ ***</span></span><br><span class="line"><span class="comment">//*** 新浪网-当前气压：160.0 kPa ***</span></span><br><span class="line"><span class="comment">//*** 新浪网-当前湿度：30.0 %RH ***</span></span><br><span class="line"><span class="comment">//============百度网-最新天气============</span></span><br><span class="line"><span class="comment">//*** 百度网-当前温度：20.0 ℃ ***</span></span><br><span class="line"><span class="comment">//*** 百度网-当前气压：160.0 kPa ***</span></span><br><span class="line"><span class="comment">//*** 百度网-当前湿度：30.0 %RH ***</span></span><br></pre></td></tr></table></figure><h2 id="JDK-的Observable类和Observer类"><a href="#JDK-的Observable类和Observer类" class="headerlink" title="JDK 的Observable类和Observer类"></a>JDK 的Observable类和Observer类</h2><p>JDK提供观察者模式基础功能的主题抽象类和观察者接口：</p><p><strong>Observable抽象类</strong> </p><p>JDK中的Observable抽象类可<strong>作为实现观察者模式的一种工具</strong>，<strong>用于构建主题</strong>（被观察者）<strong>对象</strong>，并且可将多个观察者对象添加到主题。主题发生变化时，调用Observable类的notifyObservers()方法，可以通知所有观察者对象进行更新，从而实现一对多依赖关系。</p><p>Observable类的主要作用是<strong>简化</strong>观察者模式的实现过程，<strong>将观察者模式的基础部分已经实现</strong>，程序员只需要编写具体的业务逻辑即可。addObserver()、deleteObserver()和notifyObservers()。</p><p>但需要注意，JDK中的Observable类并<strong>不是非常灵活和易于扩展</strong>，它<strong>只提供了简单的实现方式</strong>。因此，在实际的项目中有时会采用其他方案实现观察者模式，例如使用事件模型、Spring框架中的<code>ApplicationEvent</code>等。</p><p>总之，JDK中的Observable类可以作为一种工具来支持观察者模式的实现，它简化了观察者模式的编写，提高了代码的可读性和可维护性。但实际应用中需要根据实际情况选择最适合的实现方案。</p><p><strong>Observer类</strong></p><p>Observer即观察者接口，具有update()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs = <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Observable</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer var1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (var1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.obs.contains(var1)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.obs.addElement(var1);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deleteObserver</span><span class="params">(Observer var1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obs.removeElement(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.notifyObservers((Object)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>责任链模式类似一个链表，每个具体处理人层层判断对请求的处理权限，没权限的话把请求交给下一个具体处理人。</p><p><strong>抽象处理人：</strong>成员变量是资源和下一个抽象处理人，通过setNext()设置下一个抽象处理人（后面会多态形式传参具体处理人），通过process()方法处理资源。</p><p><strong>具体处理人：</strong>层层判断处理权限，没权限的话把请求交给下一个具体处理人，有权限就process()方法处理资源。</p><p><strong>测试方法：</strong>创建每个具体处理人对象，通过setNext()按处理人权限把每个对象串起来。</p><h2 id="传统方案，OA系统的采购审批项目"><a href="#传统方案，OA系统的采购审批项目" class="headerlink" title="传统方案，OA系统的采购审批项目"></a>传统方案，OA系统的采购审批项目</h2><p>学校 OA 系统的采购审批项目，需求是</p><ol><li><p>采购员采购教学器材</p></li><li><p>如果金额小于等于 5000，由教学主任审批（0 &lt; x ≤ 5000）</p></li><li><p>如果金额小于等于 10000，由院长审批（5000 &lt; x ≤ 10000）</p></li><li><p>如果金额小于等于 30000，由副校长审批（10000&lt; x ≤ 30000）</p></li><li><p>如果金额超过 30000 以上，有校长审批（30000  &lt; x）</p></li></ol><p><strong>传统方案解决 OA 系统审批问题分析</strong></p><p><strong>传统方式是：</strong>接收到一个<strong>采购请求</strong>后，<strong>根据采购金额来调用</strong>对应的<code>Approver</code>（审批人）完成审批</p><p><strong>传统方式的问题分析：</strong>客户端这里会使用到分支判断（比如<code>switch</code>）来对不同的采购请求处理，这样就存在如下问题</p><ol><li>如果<strong>各个级别的人员审批金额发生变化</strong>，在客户端的也需要变化</li><li>客户端必须明确的知道有多少个审批级别和访问</li></ol><p>这样对一个采购请求进行处理和<code>Approver</code>（审批人）就存在<strong>强耦合</strong>关系，不利于代码的扩展和维护</p><p><strong>解决方案：职责链模式</strong></p><h2 id="职责链模式基本介绍"><a href="#职责链模式基本介绍" class="headerlink" title="职责链模式基本介绍"></a>职责链模式基本介绍</h2><p>职责链模式（Chain of Responsibility Pattern），又叫责任链模式：<strong>为请求创建了一个接收者对象的链</strong>。</p><ol><li>这种模式对请求的发送者和接收者进行<strong>解耦</strong></li><li>职责链模式通常<strong>每个接收者都包含对另一个接收者的引用</strong>。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。如果最后接收者也无法处理，就返回“无法处理”，或者抛出异常。</li></ol><p><strong>原理类图</strong></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250728174508547.png" alt="image-20250728174508547"></p><p>职责链模式使<strong>多个对象都有机会处理请求</strong>，从而避免请求的发送者和接收者之间的耦合关系</p><p>将这个<strong>对象连成一条链</strong>，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><ul><li><strong>Handler抽象处理者：</strong>是一个抽象类或接口，里面包含一个处理请求的抽象方法，和另外一个Handler作为成员变量。Handler依赖请求，客户端把请求发给Handler。上面案例里每个审批者抽象的接口是Handler。</li><li><strong>ConcreteHandler具体处理者：</strong>是Handler的实现类，处理自己负责的请求，同时可以访问它的<strong>后继者</strong>（即下一个处理者） ；如果可以处理请求，则进行处理，否则交给后继者去处理，从而形成一个职责链。上面案例里每个审批者都是一个具体处理者。</li><li><strong>Request请求：</strong>含有很多属性，表示一个请求。上面案例里采购员采购是一个请求。</li></ul><p><strong>注意事项和细节</strong></p><ul><li>将<strong>请求和处理分开</strong>，实现解耦，提高系统的灵活性</li><li>简化了对象，使对象不需要知道链的结构，<strong>对象自己不知道下一个结点是谁</strong>（迪米特法则/最少知道原则）</li><li><strong>性能会受到影响</strong>，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在<code>Handler</code>中设置一个最大节点数量，在<code>setNext()</code>方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</li><li><strong>调试不方便</strong>。采用了类似递归的方式，调试时逻辑可能比较复杂</li><li><strong>最佳应用场景：</strong>有多个对象可以处理同一个请求时，比如：<strong>多级请求、请假 / 加薪等审批流程</strong>、Java Web 中 Tomcat 对<code>Encoding</code>的处理、拦截器</li></ul><h2 id="职责链模式解决-OA-系统采购审批项目"><a href="#职责链模式解决-OA-系统采购审批项目" class="headerlink" title="职责链模式解决 OA 系统采购审批项目"></a>职责链模式解决 OA 系统采购审批项目</h2><p><strong>购买请求类：</strong>有id和价格两个成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采购申请类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PurchaseRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Float price;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PurchaseRequest</span><span class="params">(Integer id, Float price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// id,price getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象审批人类：</strong>成员变量有姓名和下一个抽象审批人，方法有处理请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象审批人对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Approver nextApprover;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Approver</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置后继者,@param nextApprover</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextApprover</span><span class="params">(Approver nextApprover)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextApprover = nextApprover;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理请求的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体审批人对象：</strong>主任、院长等具体审批人，继承抽象审批人，实现处理请求的方法，如果请求中金额自己能审批则审批，如果金额不能审批则把请求交给下一个具体人。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 教学主任审批人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeachDirectorApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TeachDirectorApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (purchaseRequest.getPrice() &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求编号：&quot;</span> + purchaseRequest.getId() + <span class="string">&quot;，处理人：&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextApprover.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 院长审批人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartmentHeadApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepartmentHeadApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (purchaseRequest.getPrice() &gt; <span class="number">5000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求编号：&quot;</span> + purchaseRequest.getId() + <span class="string">&quot;，处理人：&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextApprover.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 副校长审批人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViceChancellorApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViceChancellorApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (purchaseRequest.getPrice() &gt; <span class="number">10000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="number">30000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求编号：&quot;</span> + purchaseRequest.getId() + <span class="string">&quot;，处理人：&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextApprover.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 校长审批人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChancellorApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChancellorApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (purchaseRequest.getPrice() &gt; <span class="number">30000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求编号：&quot;</span> + purchaseRequest.getId() + <span class="string">&quot;，处理人：&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextApprover.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个请求。id是1，价格是31000.0f</span></span><br><span class="line"><span class="type">PurchaseRequest</span> <span class="variable">purchaseRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PurchaseRequest</span>(<span class="number">1</span>, <span class="number">31000.0f</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建相关的审批人</span></span><br><span class="line"><span class="type">TeachDirectorApprover</span> <span class="variable">teachDirectorApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeachDirectorApprover</span>(<span class="string">&quot;童主任&quot;</span>);</span><br><span class="line"><span class="type">DepartmentHeadApprover</span> <span class="variable">departmentHeadApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DepartmentHeadApprover</span>(<span class="string">&quot;王院长&quot;</span>);</span><br><span class="line"><span class="type">ViceChancellorApprover</span> <span class="variable">viceChancellorApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViceChancellorApprover</span>(<span class="string">&quot;钱副校长&quot;</span>);</span><br><span class="line"><span class="type">ChancellorApprover</span> <span class="variable">chancellorApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChancellorApprover</span>(<span class="string">&quot;郑校长&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置后继者（处理人形成环形）</span></span><br><span class="line">teachDirectorApprover.setNextApprover(departmentHeadApprover);</span><br><span class="line">departmentHeadApprover.setNextApprover(viceChancellorApprover);</span><br><span class="line">viceChancellorApprover.setNextApprover(chancellorApprover);</span><br><span class="line">chancellorApprover.setNextApprover(teachDirectorApprover);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 发起一个请求</span></span><br><span class="line">teachDirectorApprover.processRequest(purchaseRequest); <span class="comment">// 请求编号：1，处理人：郑校长</span></span><br></pre></td></tr></table></figure><h2 id="职责链模式在-SpringMVC-框架应用的源码分析"><a href="#职责链模式在-SpringMVC-框架应用的源码分析" class="headerlink" title="职责链模式在 SpringMVC 框架应用的源码分析"></a>职责链模式在 SpringMVC 框架应用的源码分析</h2><p><code>SpringMVC</code>中<code>HandlerExecutionChain</code>类就使用到了职责链模式</p><p>首先，需要回顾下<code>SpringMVC</code>基本的请求流程，如下图所示</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250728175219902.png" alt="image-20250728175219902"></p><p>首先，当用户会发起一个request请求到后台，这个request请求首先会经过DispatcherServlet，DispatcherServlet对象首先会遍历接收到的HandlerMapping集合，然后再找到对应的HandlerMapping集合，并得到HandlerExecutionChain对象。这个HandlerExecutionChain对象内部包含了一些拦截器。拿到HandlerInterceptor拦截器过后，有以下几个操作</p><ul><li><p>首先会调用<code>HandlerInterceptor</code>中的<code>preHandle()</code>方法</p></li><li><p>然后会调用<code>HandlerInterceptor</code>中的<code>postHandle()</code>方法</p></li><li><p>最后会调用<code>HandlerInterceptor</code>中的<code>afterCompletion()</code>方法</p></li></ul><p>现在对<code>SpringMVC</code>进行源码分析，首先需要引入<code>SpringMVC</code>相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">org.springframework.version</span>&gt;</span>4.3.7.RELEASE<span class="tag">&lt;/<span class="name">org.springframework.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，探究其如何调用<code>HandlerInterceptor</code>拦截器中的这三个方法</p><ol><li><p><strong>在DispatcherServlet中找到doDispatch()方法，发现该方法中定义了一个HandlerExecutionChain对象</strong></p><p>源码分析mappedHandler是如何调用preHandle()、postHandle()和afterCompletion()三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!mappedHandler.applyPreHandle(processedRequest, response))&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span>(asyncManager.isConcurrentHandlingStarted())&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">applyDefaultViewName(processedRequest，mv);</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest,response, mv);</span><br></pre></td></tr></table></figure><p>在后续的代码逻辑中，调用了getHandler()方法，接收一个processedRequest请求对象作为参数，得到初始化的HandlerExecutionChain对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    processedRequest =checkMultipart(request);</span><br><span class="line">    multipartRequestParsed =(processedRequest !=request);</span><br><span class="line">    <span class="comment">// Determine handler for the current request</span></span><br><span class="line">    mappedHandler = getHandler(processedRequest);</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler == nulll mappedHandler.getHandler()== <span class="literal">null</span>) &#123;</span><br><span class="line">        noHandlerFound(processedRequest,response);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终找到两段代码，很像上述所说的preHandle()和postHandle()两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br></pre></td></tr></table></figure><p>首先会执行mappedHandler的applyPreHandle()方法：如果返回为false，则判断成立，后续代码不再执行；否则继续往下执行，调用mappedHandler的applyPostHandle()方法</p></li><li><p><strong>先看下<code>applyPreHandle()</code>方法的源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line"> <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">         <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">         <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">             triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">this</span>.interceptorIndex = i;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>applyPreHandle</code>方法内部首先会拿到一组<code>interceptors</code>拦截器，当拦截器数组不为空时，进行如下处理：</p><ul><li>首先对<code>interceptors</code>拦截器进行了<code>for</code>循环遍历，拿到每一个具体的<code>interceptor</code>拦截器</li><li>接着调用了<code>interceptor</code>的<code>preHandle()</code>方法，如果返回<code>false</code>，则执行<code>triggerAfterCompletion()</code>方法并进行<code>return</code>，此方法结束；否则继续执行相关处理</li></ul></li><li><p><strong>接着看下<code>triggerAfterCompletion()</code>方法的源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Exception ex)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, ex2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中逻辑跟applyPreHandle()方法很相似：先对一组interceptors拦截器进行遍历，再执行interceptor单个拦截器的afterCompletion()方法</p></li><li><p><strong>最后看下applyPostHandle()方法的源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, ModelAndView mv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">            interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中逻辑跟上述方法也基本一致：先对一组interceptors拦截器进行遍历，再执行interceptor单个拦截器的postHandle()方法。</p></li></ol><p><strong>总结</strong></p><ul><li>SpringMVC请求的流程图中，执行了拦截器相关方法，如interceptor.preHandler()</li><li>在处理SpringMVC请求时，使用到职责链模式和适配器模式</li><li>HandlerExecutionChain：主要负责请求拦截器的执行和请求处理，但是本身不处理请求，只是将请求分配给 链上注册处理器 执行。这是职责链实现方式，减少职责链本身与处理逻辑之间的耦合，规范了处理流程</li><li>HandlerExecutionChain：维护了Handlerlnterceptor的集合，可以向其中注册相应的拦截器</li></ul><h2 id="职责链模式在Sentinel中的应用"><a href="#职责链模式在Sentinel中的应用" class="headerlink" title="职责链模式在Sentinel中的应用"></a>职责链模式在Sentinel中的应用</h2><p><strong>责任链模式：</strong>sentinel在内部创建了一个责任链，责任链是由一系列ProcessorSlot接口的实现类组成的，每个ProcessorSlot对象负责不同的功能，外部请求想要访问资源需要责任链层层校验和处理。每个具体处理人有权限（例如配置过降级规则DegradeSlot有权限）则校验，没权限则交给下一个具体处理人。只有校验通过才可以访问资源，如果校验失败，会抛出BlockException异常。</p><p><strong>校验顺序：</strong>降级、黑白名单、构建ClusterNode对象（统计QPS,RT等）、校验QPS,RT等、流控、打印日志</p><p><strong>ProcessorSlot接口（抽象处理人）：</strong>是一个基于责任链模式的接口，定义了一个entry()方法，用于处理入口参数和出口参数的限流和降级逻辑；一个exit()方法，用于将权限交给下一个抽象处理人（实际会传参具体处理人）。</p><p><strong>ProcessorSlot实现类（具体处理人）：</strong></p><ul><li><strong>DegradeSlot：</strong>用于服务降级。如果发现服务超时次数或者报错次数超过限制，DegradeSlot将禁止再次访问服务，等待一段时间后，DegradeSlot试探性的放过一个请求，然后根据该请求的处理情况，决定是否再次降级。</li><li><strong>AuthoritySlot：</strong>黑白名单校验，按照字符串匹配，如果在黑名单，则禁止访问。</li><li><strong>ClusterBuilderSlot：</strong>构建ClusterNode对象，该对象用于统计访问资源的QPS、线程数、异常、响应时间等，每个资源对应一个ClusterNode对象。</li><li><strong>SystemSlot：</strong>校验QPS、并发线程数、系统负载、CPU使用率、平均响应时间是否超过限制，使用滑动窗口算法统计上述数据。</li><li><strong>StatisticSlot：</strong>用于多维度（入口流量、调用者、当前被访问资源）统计响应时间、并发线程数、处理失败个数、处理成功个数等。</li><li><strong>FlowSlot：</strong>用于流控，可以根据QPS或者每秒并发线程数控制，当QPS或者并发线程数超过设定值，便会抛出FlowException异常。FlowSlot依赖于StatisticSlot的统计数据。</li><li><strong>NodeSelectorSlot：</strong>收集资源路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级、数据统计。</li><li><strong>LogSlot：</strong>打印日志。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 &lt;em&gt;Gang of Four&lt;/em&gt; (&lt;em&gt;GoF&lt;/em&gt;) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="system" scheme="https://southernfish.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型模式</title>
    <link href="https://southernfish.github.io/pages/java/java-design-pattern-structural/"/>
    <id>https://southernfish.github.io/pages/java/java-design-pattern-structural/</id>
    <published>2025-07-28T07:56:36.000Z</published>
    <updated>2025-09-17T07:51:48.707Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p><p><strong>结构型模式</strong>（Structural Patterns）：主要<strong>用于描述对象之间的组合关系</strong>，包括多个不同的模式，如“代理模式”、“适配器模式”、“桥接模式”、“装饰者模式”、“外观模式”、“享元模式”和“组合模式”等。这些模式可以帮助我们更好地设计程序结构，提高代码灵活性和可维护性。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130440147">设计模式——代理模式</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/143056317">【设计模式】结合Tomcat源码，分析外观模式/门面模式的特性和应用场景</a></p></blockquote><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="代理模式的基本介绍"><a href="#代理模式的基本介绍" class="headerlink" title="代理模式的基本介绍"></a>代理模式的基本介绍</h2><p>代理模式：为一个对象提供一个<strong>替身</strong>，以控制对这个对象的访问。即<strong>通过代理对象访问目标对象</strong></p><p>代理模式是结构型设计模式（用于描述对象之间的组合关系）。</p><p><strong>好处：</strong>可以在目标对象实现的基础上，增强额外的功能操作，即<strong>扩展目标对象的功能</strong></p><p>被代理的对象可以是<strong>远程对象</strong>、创建开销大的对象或需要<strong>安全控制</strong>的对象（代理时对目标对象进行安全控制）</p><p>我们并不希望客户端直接调用目标对象，而是通过代理对象对目标对象实现安全控制或增强功能。所以客户端直接依赖代理对象，代理对象依赖目标对象.</p><p>代理模式有不同的形式，主要有三种：<strong>静态代理、JDK动态代理、Cglib 代理</strong></p><p><strong>静态代理：</strong></p><p>目标对象与代理对象实现租同的接口或继承相同的父类，在编译时生成代理对象。</p><p>目标对象实现代理接口，代理对象实现并聚合代理接口，重写方法编写增强后逻辑。</p><p><strong>JDK动态代理：</strong></p><p>通过Java<strong>反射机制</strong>在运行时动态地在内存中生成代理对象。 目标对象需要实现代理接口。目标对象实现代理接口，<strong>代理工厂</strong>通过Proxy类的静态方法<code>newProxyInstance()</code>，利用反射机制返回代理对象实例。 </p><p><strong><code>newProxyInstance()</code>三个参数</strong>：目标对象的类加载器、目标对象的接口、实现<code>InvocationHandler</code>接口并重写<code>invoke()</code>方法，编写代理对象逻辑。</p><p><strong>应用</strong>：<strong>Spring AOP</strong>采用了动态代理的方式，在运行时动态的创建代理对象来实现增强。</p><p><strong>Cglib 代理：</strong></p><p>在<strong>内存</strong>中构建一个<strong>子类对象</strong>以实现对目标对象功能扩展。目标对象不需要实现代理接口。底层通过ASM框架转换字节码并生成新的类。</p><p>代理工厂类实现<code>MethodInterceptor</code>接口并重写<code>intercept()</code>方法编写代理逻辑，通过<code>cglib包</code>的<code>Enhancer</code>类设置父类字节码文件和创建子类对象来返回代理对象实例。</p><p>ASM框架是一个强大的Java字节码操作框架，可以让程序员通过代码生成和转换现有字节码来操作Java类。ASM可以直接生成字节码，也可以通过访问现有字节码来修改它。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理在使里时，需要定义接口或者父类，<strong>目标对象与代理对象实现租同的接口</strong>或继承相同的<strong>父类</strong>。</p><p><strong>实现方式：</strong>目标对象实现代理接口，代理对象实现并聚合代理接口，重写方法编写增强后逻辑。</p><p><strong>优缺点</strong></p><ul><li><p><strong>优点</strong>：在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展</p></li><li><p><strong>缺点</strong>：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类。<strong>耦合性较高</strong>，一旦<strong>接口增加方法，目标对象与代理对象都要维护</strong></p></li></ul><p><strong>案例</strong></p><ol><li>定义一个<strong>接口：ITeacherDao</strong></li><li><strong>目标对象TeacherDao</strong>实现接口ITeacherDao</li><li>使用静态代理方式，就需要在代理对象TeacherDaoProxy中也实现ITeacherDao</li><li>调用的时候通过调用代理对象的方法来调用目标对象</li><li><strong>特别提醒</strong>：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;                        <span class="comment">// 代理对象和原始对象重写这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 目标对象，即被代理对象。实现代理借口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师授课中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理对象。实现代理借口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ITeacherDao iTeacherDao;    <span class="comment">// 接口引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TeacherDaoProxy</span><span class="params">(ITeacherDao iTeacherDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.iTeacherDao = iTeacherDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备授课...&quot;</span>);</span><br><span class="line">        iTeacherDao.teach();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束授课...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建被代理对象</span></span><br><span class="line"><span class="type">TeacherDao</span> <span class="variable">teacherDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();</span><br><span class="line"><span class="comment">//创建代理对象，聚合被代理对象</span></span><br><span class="line"><span class="type">TeacherDaoProxy</span> <span class="variable">teacherDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDaoProxy</span>(teacherDao);</span><br><span class="line"><span class="comment">//通过代理对象，调用被代理对象的方法</span></span><br><span class="line">teacherDaoProxy.teach();</span><br></pre></td></tr></table></figure><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>Java中的动态代理是一种机制，它通过<strong>在程序运行时动态地生成代理对象</strong>，并在代理对象上进行方法调用，实现对目标对象方法的拦截与控制。动态代理是代理设计模式的一种实现方式，与静态代理不同的是，它<strong>不需要显示地编写代理类</strong>来代理被代理对象，而是通过<strong>Java反射机制</strong>在运行时动态生成代理类和代理对象。 </p><p><strong>实现方法：</strong></p><p>目标对象实现代理接口，<strong>代理工厂</strong>通过Proxy类的静态方法newProxyInstance()，利用反射机制返回代理对象实例。 </p><p>newProxyInstance()三个参数：目标对象的类加载器、目标对象的接口、实现InvocationHandler接口并重写invoke()方法，编写代理对象逻辑。</p><ul><li><strong>代理对象不需要实现接口</strong>，但是<strong>目标对象要实现接口</strong>，否则不能用动态代理</li><li>代理对象的生成，是利用 JDK 的 APl，动态的在<strong>内存中构建代理对象</strong></li><li>动态代理也叫做：JDK 代理、接口代理</li></ul><p>JDK提供了<code>java.lang.reflect.Proxy</code>类，可以通过它创建基于接口的动态代理对象。使用Proxy类的newProxyInstance静态方法，该方法需要接收三个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object <span class="title function_">newProxylnstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理接口和目标对象同上，目标对象需要实现代理接口</span></span><br><span class="line"><span class="comment">// ITeacherDao与TeacherDao同上</span></span><br><span class="line"><span class="comment">// 代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TeacherFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">newProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">                                      target.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;JDK代理授课开始...&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;JDK代理授课结束...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> returnVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建目标对象</span></span><br><span class="line"><span class="type">ITeacherDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();</span><br><span class="line"><span class="comment">//给目标对象，创建代理对象，可以转成 ITeacherDao</span></span><br><span class="line"><span class="type">ITeacherDao</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (ITeacherDao)<span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line"><span class="comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());</span><br><span class="line"><span class="comment">//通过代理对象，调用目标对象的方法</span></span><br><span class="line">proxyInstance.teach();</span><br></pre></td></tr></table></figure><blockquote><p>其中几个参数</p><p>1）ClassLoader loader：指定当前目标对象使用的类加载器，获取加载器的方法固定<br>2）Class&lt;?&gt;[] interfaces：目标对象实现的接口类型，使用泛型方法确认类型<br>3）InvocationHandler h：事情处理，执行目标对象的方法时触发事情处理器方法，把当前执行的目标对象方法作为参数传入</p></blockquote><h2 id="Cglib-代理"><a href="#Cglib-代理" class="headerlink" title="Cglib 代理"></a>Cglib 代理</h2><p><strong>Cglib 代理</strong></p><p>静态 代理和 JDK 代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可<strong>使用目标对象子类来实现代理</strong>——这就是 Cglib 代理</p><p>Cglib 代理也叫作<strong>子类代理</strong>，它是<strong>在内存中构建一个子类对象从而实现对目标对象功能扩展</strong>，有些书也将 Cglib 代理归属到动态代理。</p><p><strong>使用方法：</strong></p><p>代理工厂类实现MethodInterceptor接口并重写intercept()方法编写代理逻辑，通过cglib包的Enhancer类设置父类字节码文件和创建子类对象来返回代理对象实例。</p><p><strong>Cglib包</strong></p><p>是一个强大的高性能的<strong>代码生成包</strong>，它可以在<strong>运行期扩展 java 类与实现 java 接口</strong>。它广泛的被许多 AOP 的框架使用，例如 Spring AOP，实现方法拦截。</p><p>Cglib 包的<strong>底层</strong>是通过使用<strong>ASM框架</strong>来<strong>转换字节码并生成新的类</strong></p><p><strong>ASM框架</strong></p><p>一个强大的Java字节码操作框架，可以让程序员通过代码生成和转换现有字节码来操作Java类。ASM可以直接生成字节码，也可以通过访问现有字节码来修改它。我们可以使用ASM来生成新的类、新的方法、字段、注解等。同时，ASM还允许我们在运行时改变现有的Java类的字节码，从而实现动态的Java类修改，例如添加方法、添加字段等。</p><blockquote><p>在 AOP 编程中如何选择代理模式：</p><ul><li>目标对象需要实现接口，用 JDK 代理</li><li>目标对象不需要实现接口，用 Cglib 代理</li></ul></blockquote><p><strong>案例：</strong></p><ol><li>引入<code>cglib</code>的 jar 文件（asm.jar，asm-commons.jar，asm-tree.jar，cglib-2.2jar）</li><li>在内存中动态构建子类，注意**代理的类不能为<code>final</code>**，否则报错<code>java.lang.IllegalArgumentException</code></li><li>标对象的方法如果为<code>final</code>/<code>static</code>，那么就不会被拦截，即不会执行目标对象额外的业务方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师授课中...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Good&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理工厂类，实现MethodInterceptor 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回代理对象实例。不是静态方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();         <span class="comment">// 1、创建工具类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());     <span class="comment">// 2、设置父类</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);                    <span class="comment">// 3、设置回调函数</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();                    <span class="comment">// 4、创建子类对象，即代理对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> </span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cglib代理开始...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;cglib代理结束...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代理模式的变体（应用场景）"><a href="#代理模式的变体（应用场景）" class="headerlink" title="代理模式的变体（应用场景）"></a>代理模式的变体（应用场景）</h2><p>几种常见的代理模式一<strong>几种变体</strong></p><ul><li><strong>防火墙代理</strong>：内网通过代理穿透防火墙，实现对公网的访问</li><li><strong>缓存代理：</strong>比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok；如果取不到资源，再到公网或者数据库取，然后缓存</li><li><strong>远程代理：</strong>远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息（RPC）</li><li><strong>同步代理：</strong>主要使用在多线程编程中，完成多线程间同步工作</li></ul><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="经典的组建家庭影院流程"><a href="#经典的组建家庭影院流程" class="headerlink" title="经典的组建家庭影院流程"></a>经典的组建家庭影院流程</h2><p><strong>问题描述：</strong></p><ul><li>组建家庭影院过程：<ol><li>直接用遥控器：统筹各设备开关</li><li>开爆米花机</li><li>放下屏幕</li><li>开投影仪</li><li>开音响</li><li>开DVD，选dvd</li><li>去拿爆米花</li><li>调暗灯光</li><li>播放</li><li>观影结束后，关闭各种设备</li></ol></li><li><strong>需求</strong>：组建一个电影院，要求完成上述流程</li></ul><h2 id="传统方式解决影院管理"><a href="#传统方式解决影院管理" class="headerlink" title="传统方式解决影院管理"></a>传统方式解决影院管理</h2><h3 id="实现方案：客户端直接调用各流程"><a href="#实现方案：客户端直接调用各流程" class="headerlink" title="实现方案：客户端直接调用各流程"></a>实现方案：客户端直接调用各流程</h3><p>客户端直接使用各个子系统</p><p><strong>各个电器类（子系统）</strong>：包括打开、关闭等功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DVD类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DVDPlayer</span>&#123;</span><br><span class="line">    <span class="comment">// 播放</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123; System.out.println(<span class="string">&quot;播放DVD&quot;</span>); &#125;</span><br><span class="line">    <span class="comment">// 打开</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123; System.out.println(<span class="string">&quot;打开DVD&quot;</span>); &#125;</span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>&#123; System.out.println(<span class="string">&quot;关闭DVD&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 投影仪</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Projector</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开投影仪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><strong>客户端</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 1、创建对象：创建各电器类对象</span></span><br><span class="line">        <span class="comment">// 2、打开电器：调用各对象的on()方法</span></span><br><span class="line">        <span class="comment">// 3、放映：调用DVDPlayer对象的play方法</span></span><br><span class="line">        <span class="comment">// 4.关闭：关闭所有电器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点和改进思路"><a href="#优缺点和改进思路" class="headerlink" title="优缺点和改进思路"></a>优缺点和改进思路</h3><p><strong>优点：</strong>比较好理解，简单易操作</p><p><strong>缺点：</strong></p><ul><li><strong>调用过程混乱</strong>：客户端创建各个子系统的对象，并直接去调用子系统（对象）相关方法，会造成调用过程混乱，没有清晰的过程</li><li><strong>无法直接维护子系统</strong>：不利于在 ClientTest 中去维护对子系统的操作</li></ul><p><strong>改进思路分析：</strong> 抽取界面类，定义一个高层接口（界面类），给子系统接口提供一致的界面（例如ready，play，pause，end等方法），屏蔽内部子系统的细节。</p><h2 id="外观模式-1"><a href="#外观模式-1" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="外观模式-门面模式"><a href="#外观模式-门面模式" class="headerlink" title="外观模式/门面模式"></a>外观模式/门面模式</h3><p><strong>外观模式（Facade）</strong>：也叫过程模式/门面模式，是一种结构型设计模式。外观模式通常创建一个外观类，将子系统类的多个流程方法组装起来。</p><p>外观模式通过封装复杂的子系统接口，提供一个简化的统一接口，减少了客户端与子系统的直接依赖，降低了耦合性。</p><blockquote><p> <strong>结构型模式</strong>（Structural Patterns）：<br>主要用于描述对象之间的<strong>组合</strong>关系<strong>。</strong>包括“代理模式”、“适配器模式”、“桥接模式”、“装饰者模式”、“外观模式”、“享元模式”和“组合模式”等。这些模式可以帮助我们更好地<strong>设计程序结构</strong>，提高代码的灵活性和可维护性。<br>外观模式将多个子系统通过界面接口统一访问，改变了各个子系统与客户端之间的组合关系，所以是结构型设计模式。</p></blockquote><h3 id="外观类、子系统和客户端"><a href="#外观类、子系统和客户端" class="headerlink" title="外观类、子系统和客户端"></a>外观类、子系统和客户端</h3><p><strong>外观模式的三个角色</strong>：</p><ul><li><strong>外观类</strong>（Facade）：提供统一的界面类，组装子系统的各个流程。例如软件安装外观类有个“一键安装”方法，组装了选择安装目录、选择组件、开启开机自启动等子流程。</li><li><strong>子系统</strong>：各功能的实际执行者。例如系统服务类设置开机自启动。</li><li><strong>客户端</strong>（Client）：调用者。客户端通过调用外观类提供的简化接口，与各子系统交互，从而实现功能。例如点击外观对象的“一键安装”方法，一键安装软件。</li></ul><p><strong>举例</strong>：</p><ul><li><strong>一键安装</strong>：在 PC 上安装软件的时候经常有一键安装选项，省去选择安装目录、安装的组件、选择开机自启动、选择是否生成快捷方式等步骤</li><li><strong>重启手机</strong>：手机的关机选项，就是把关机和启动组合为一个操作</li></ul><h3 id="优缺点和适用场景"><a href="#优缺点和适用场景" class="headerlink" title="优缺点和适用场景"></a>优缺点和适用场景</h3><p><strong>优点：</strong></p><ul><li><p><strong>简化用户操作</strong>：将具体的各个流程组装到外观类中，这样客户端调用时，直接调用外观类的方法即可。</p></li><li><p><strong>高内聚低耦合</strong>：将子系统的实现细节隐藏在外观类之后，客户端只与外观类交互，降低了系统各部分之间的耦合性。</p></li><li><p><strong>分层结构</strong>：外观模式可以作为上层系统与下层子系统交互的中间层，简化每一层之间的依赖。</p></li><li><p><strong>性能高</strong>：将各个子系统流程的分别调用，改为外观类一次性调用，减少网络通信成本，提高 了客户端的响应速度。</p></li><li><p><strong>易于维护</strong>：当需要修改流程时，只需要维护外观类的方法，调换各个流程，不需要关注各个子系统的具体实现。</p></li></ul><p><strong>缺点：</strong></p><ul><li><strong>掩盖子系统复杂性</strong>：将子系统的实现细节隐藏在外观类之后，开发者可能对各个子系统的具体实现细节了解不够深刻。 </li><li><strong>过度设计</strong>：一些场景子系统并不多，而且流程简单，未来也不需要扩展新的流程，用外观模式就会有些过度设计。这也是众多设计模式的缺点，需要充分考虑适用场景</li></ul><p><strong>使用场景：</strong></p><ul><li><strong>子系统各流程复杂</strong>：当子系统很多时，为了防止遗留流程，并且方便管理各个流程的前后顺序，可以使用外观模式</li><li><strong>兼容旧系统功能</strong>：在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个 Facade 类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性</li><li><strong>三层架构</strong>：Java项目中，我们常常将Dao注入到Service，Service将多个Dao组合在一起，这其实也用到了外观模式。</li></ul><h2 id="外观模式解决影院管理"><a href="#外观模式解决影院管理" class="headerlink" title="外观模式解决影院管理"></a>外观模式解决影院管理</h2><h3 id="实现方案：将各流程组装到外观类"><a href="#实现方案：将各流程组装到外观类" class="headerlink" title="实现方案：将各流程组装到外观类"></a>实现方案：将各流程组装到外观类</h3><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a><strong>核心代码</strong></h3><h4 id="子系统：投影仪、DVD等类"><a href="#子系统：投影仪、DVD等类" class="headerlink" title="子系统：投影仪、DVD等类"></a>子系统：投影仪、DVD等类</h4><p>子系统类主要包括投影仪、DVD等类，拥有打开、关闭等功能（普通方法） ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 投影仪</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Projector</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Projector</span> <span class="variable">projector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Projector</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Projector <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> projector;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;打开投影仪...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;关闭投影仪...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">focus</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;投影仪聚焦...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">zoom</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;投影仪放大...&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DVD类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DVDPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DVDPlayer</span> <span class="variable">player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DVDPlayer</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DVDPlayer <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> player;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;打开DVD播放器...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;关闭DVD播放器...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;播放DVD播放器...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pause</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;暂停DVD播放器...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDvd</span><span class="params">(String dvd)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;选dvd：&quot;</span> + dvd + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 荧幕类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Screen</span> <span class="variable">screen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Screen</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Screen <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> screen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;升起荧幕...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;拉下荧幕...&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 音响类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stereo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Stereo</span> <span class="variable">stereo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stereo</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stereo <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stereo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;打开立体声...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;关闭立体声...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVolume</span><span class="params">(Integer volume)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;立体声音量+&quot;</span> + volume + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 灯光类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheaterLights</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">TheaterLights</span> <span class="variable">lights</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TheaterLights</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TheaterLights <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lights;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;打开灯光...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;关闭灯光...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dim</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;调暗灯光...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bright</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;调亮灯光...&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 爆米花机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Popcorn</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Popcorn</span> <span class="variable">popcorn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Popcorn</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Popcorn <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> popcorn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;打开爆米花机器...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;关闭爆米花机器...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;取出爆米花...&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外观类：家庭影院外观类"><a href="#外观类：家庭影院外观类" class="headerlink" title="外观类：家庭影院外观类"></a>外观类：家庭影院外观类</h4><p>外观类包括一个或多个组装方法，将各个流程（子系统类的方法）组装起来。 </p><p>家庭影院 Facade</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外观类：家庭影院外观类，包括准备、观看、暂停、结束等大流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeTheaterFacade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">    <span class="keyword">private</span> Screen screen;</span><br><span class="line">    <span class="keyword">private</span> Stereo stereo;</span><br><span class="line">    <span class="keyword">private</span> TheaterLights lights;</span><br><span class="line">    <span class="keyword">private</span> Projector projector;</span><br><span class="line">    <span class="keyword">private</span> DVDPlayer player;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HomeTheaterFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.popcorn = Popcorn.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.screen = Screen.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.stereo = Stereo.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.lights = TheaterLights.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.projector = Projector.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.player = DVDPlayer.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备看电影：调用开灯、放屏幕、开投影仪、调暗灯等流程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ready</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 打开灯光</span></span><br><span class="line">        lights.on();</span><br><span class="line">        <span class="comment">// 开爆米花机</span></span><br><span class="line">        popcorn.on();</span><br><span class="line">        <span class="comment">// 放下屏幕</span></span><br><span class="line">        screen.down();</span><br><span class="line">        <span class="comment">// 开投影仪，聚焦、放大</span></span><br><span class="line">        projector.on();</span><br><span class="line">        projector.focus();</span><br><span class="line">        projector.zoom();</span><br><span class="line">        <span class="comment">// 开音响，设置音量</span></span><br><span class="line">        stereo.on();</span><br><span class="line">        stereo.setVolume(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 开DVD，选dvd</span></span><br><span class="line">        player.on();</span><br><span class="line">        player.setDvd(<span class="string">&quot;坦塔尼克号&quot;</span>);</span><br><span class="line">        <span class="comment">// 取爆米花，关闭爆米花机器</span></span><br><span class="line">        popcorn.pop();</span><br><span class="line">        popcorn.off();</span><br><span class="line">        <span class="comment">// 调暗灯光</span></span><br><span class="line">        lights.dim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看电影</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        player.play();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暂停电影</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pause</span><span class="params">()</span> &#123;</span><br><span class="line">        player.pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭电影：调用关投影仪、关音响、开灯、收屏幕等流程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        player.off();</span><br><span class="line">        projector.off();</span><br><span class="line">        stereo.off();</span><br><span class="line">        lights.bright();</span><br><span class="line">        screen.up();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端：家庭影院的准备、观看、结束"><a href="#客户端：家庭影院的准备、观看、结束" class="headerlink" title="客户端：家庭影院的准备、观看、结束"></a>客户端：家庭影院的准备、观看、结束</h4><p>客户端类创建外观类对象，调用各个组装方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端：调用影院外观类的准备、观看、结束等流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HomeTheaterFacade</span> <span class="variable">homeTheaterFacade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HomeTheaterFacade</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;===========家庭影院初始化============&quot;</span>);</span><br><span class="line">        homeTheaterFacade.ready();</span><br><span class="line">        System.out.println(<span class="string">&quot;===========家庭影院沉浸式播放============&quot;</span>);</span><br><span class="line">        homeTheaterFacade.play();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========家庭影院暂停============&quot;</span>);</span><br><span class="line">        homeTheaterFacade.pause();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========家庭影院沉浸式播放============&quot;</span>);</span><br><span class="line">        homeTheaterFacade.play();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========家庭影院结束============&quot;</span>);</span><br><span class="line">        homeTheaterFacade.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观模式在三层架构中的应用"><a href="#外观模式在三层架构中的应用" class="headerlink" title="外观模式在三层架构中的应用"></a>外观模式在三层架构中的应用</h2><h3 id="三层架构和MVC设计模式"><a href="#三层架构和MVC设计模式" class="headerlink" title="三层架构和MVC设计模式"></a>三层架构和MVC设计模式</h3><h4 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h4><p>开发过程中，我们把后端服务器Servlet拆分成三层，分别是web、service和dao，这也是程序员常提到的<strong>“Java味”</strong>：</p><ul><li><strong>web层（表现层）</strong>：直接与用户交互，负责接收用户输入和呈现数据</li><li><strong>service层（业务层）</strong>：处理具体的业务逻辑。也称为服务层或应用层。</li><li><strong>dao层（数据访问层）</strong>：负责与数据库交互，执行数据的增删改查</li></ul><p><strong>优点</strong>：</p><ul><li><strong>低耦合</strong>：各层的职责明确，页面交互、业务逻辑、数据库操作三层分离，降低了系统模块间的耦合。并且各个类功能一目了然，例如OrderController可以直接看出它是控制器。</li><li><strong>易维护</strong>：每层的功能独立，业务逻辑更改后只需修改Service，数据库更改后只需修改dao。</li><li><strong>可扩展</strong>：当增加新功能后，可以在各层扩展相关功能的类。</li></ul><h4 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a><strong>MVC设计模式</strong></h4><p><strong>MVC设计模式</strong>：将后端Servlet设计为控制器controller、视图view、业务模型Model。</p><ul><li><strong>视图（View）</strong>：显示UI页面数据，并与用户交互。前后端分离项目中视图就是前端代码，一体化项目中视图是JSP、Thymeleaf 等框架渲染成的HTML。</li><li><strong>控制器（Controller）</strong>：负责接收浏览器发送过来的请求，然后响应给浏览器</li><li><strong>模型（Model）</strong>：封装后端业务逻辑和应用的核心数据，与数据层交互。</li></ul><p><strong>流程</strong>：</p><ol><li>控制器（例如serlvlet）用来接收浏览器发送过来的请求</li><li>控制器调用模型（例如JavaBean）来获取数据，比如从数据库查询数据；</li><li>控制器获取到数据后再交由视图（例如JSP）进行数据展示。 </li></ol><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250728170118400.png" alt="image-20250728170118400"></p><p><strong>优点</strong>：</p><ul><li><strong>低耦合</strong>：将数据、UI 和控制逻辑分离，便于开发、维护和扩展。</li><li><strong>可扩展性</strong>：将逻辑处理和视图渲染分开，各个小组件能直接复用。</li></ul><h3 id="外观模式在三层架构中的应用-1"><a href="#外观模式在三层架构中的应用-1" class="headerlink" title="外观模式在三层架构中的应用"></a>外观模式在三层架构中的应用</h3><p>外观模式像模板模式一样，都是很通用的设计模式，不只是JDK和常用框架的源码，我们开发过程中也会经常用到他们。</p><p>例如写Service时候，将Dao注入到Service，然后调用Dao的各个方法，这其实也用到外观模式的思想。</p><p>下面订单Service，注入了订单dao、商品dao和客户dao，然后对流程进行组装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单业务实现</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;             <span class="comment">// 订单dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductDao productDao;         <span class="comment">// 商品dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomerDao customerDao;     <span class="comment">// 客户dao</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">placeOrder</span><span class="params">(Customer customer, Product product)</span> &#123;</span><br><span class="line">        <span class="comment">// 外观模式思想：调用多个DAO方法，完成下单业务逻辑</span></span><br><span class="line">        <span class="comment">// 1.保存客户信息</span></span><br><span class="line">        customerDao.save(customer);</span><br><span class="line">        <span class="comment">// 2.更新商品库存</span></span><br><span class="line">        productDao.updateStock(product);</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(customer, product);</span><br><span class="line">        <span class="comment">// 3.保存订单</span></span><br><span class="line">        orderDao.save(order);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观模式在Tomcat源码中的应用"><a href="#外观模式在Tomcat源码中的应用" class="headerlink" title="外观模式在Tomcat源码中的应用"></a>外观模式在Tomcat源码中的应用</h2><p>Tomcat源码使用了外观模式，以<code>ApplicationContextFacade</code>为例</p><h3 id="外观类：ApplicationContextFacade"><a href="#外观类：ApplicationContextFacade" class="headerlink" title="外观类：ApplicationContextFacade"></a>外观类：ApplicationContextFacade</h3><p>ApplicationContextFacade 是 Apache Tomcat 框架中的外观类，位于 org.apache.catalina.core 包下。是 ApplicationContext 的代理接口，主要用于屏蔽 ApplicationContext 的复杂内部实现。</p><p>其中，initClassCache()方法用于初始化classCache变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.catalina.core;</span><br><span class="line"><span class="comment">// 外观类：用于屏蔽 ApplicationContext 的复杂内部实现。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextFacade</span> <span class="keyword">implements</span> <span class="title class_">ServletContext</span> &#123;</span><br><span class="line">    <span class="comment">// ---------------------------------------------------------- Attributes</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;[]&gt; classCache; <span class="comment">// 缓存类对象：用于后续通过反射获取类的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Method&gt; objectCache; <span class="comment">// 缓存方法对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----------------------------------------------------------- Constructors</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法：构造一个新对象实例，并初始化类对象缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context The associated Context instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApplicationContextFacade</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">        classCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        objectCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        initClassCache();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化类缓存：将ApplicationContext各方法加入类缓存中，value统一初始化成String类对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initClassCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建String的类对象</span></span><br><span class="line">        Class&lt;?&gt;[] clazz = <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;;</span><br><span class="line">        <span class="comment">// 2.将该类对象作为value，key是ApplicationContext各方法，统一存到类缓存中</span></span><br><span class="line">        <span class="comment">// 获取上下文</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getContext&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取 MIME 类型</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getMimeType&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取资源路径</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getResourcePaths&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取资源</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getResource&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取资源的输入流</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getResourceAsStream&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取请求分发器</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getRequestDispatcher&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取指定名称的分发器</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getNamedDispatcher&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取 Servlet</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getServlet&quot;</span>, clazz);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 设置初始化参数</span></span><br><span class="line">        classCache.put(<span class="string">&quot;setInitParameter&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, String.class &#125;);</span><br><span class="line">        <span class="comment">// 创建 Servlet 实例</span></span><br><span class="line">        classCache.put(<span class="string">&quot;createServlet&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.class &#125;);</span><br><span class="line">        <span class="comment">// 添加 Servlet</span></span><br><span class="line">        classCache.put(<span class="string">&quot;addServlet&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, String.class &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 创建过滤器实例</span></span><br><span class="line">        classCache.put(<span class="string">&quot;createFilter&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.class &#125;);</span><br><span class="line">        <span class="comment">// 添加过滤器</span></span><br><span class="line">        classCache.put(<span class="string">&quot;addFilter&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, String.class &#125;);</span><br><span class="line">        <span class="comment">// 创建监听器</span></span><br><span class="line">        classCache.put(<span class="string">&quot;createListener&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.class &#125;);</span><br><span class="line">        <span class="comment">// 添加监听器</span></span><br><span class="line">        classCache.put(<span class="string">&quot;addListener&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取过滤器注册信息</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getFilterRegistration&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取 Servlet 注册信息</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getServletRegistration&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取初始化参数</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getInitParameter&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 设置属性</span></span><br><span class="line">        classCache.put(<span class="string">&quot;setAttribute&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, Object.class &#125;);</span><br><span class="line">        <span class="comment">// 移除属性</span></span><br><span class="line">        classCache.put(<span class="string">&quot;removeAttribute&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取资源的真实路径</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getRealPath&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取属性</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getAttribute&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">        classCache.put(<span class="string">&quot;log&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 设置会话跟踪模式</span></span><br><span class="line">        classCache.put(<span class="string">&quot;setSessionTrackingModes&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Set.class &#125;);</span><br><span class="line">        <span class="comment">// 添加 JSP 文件</span></span><br><span class="line">        classCache.put(<span class="string">&quot;addJspFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, String.class &#125;);</span><br><span class="line">        <span class="comment">// 声明角色</span></span><br><span class="line">        classCache.put(<span class="string">&quot;declareRoles&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String[].class &#125;);</span><br><span class="line">        <span class="comment">// 设置会话超时时间</span></span><br><span class="line">        classCache.put(<span class="string">&quot;setSessionTimeout&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; <span class="type">int</span>.class &#125;);</span><br><span class="line">        <span class="comment">// 设置请求字符编码</span></span><br><span class="line">        classCache.put(<span class="string">&quot;setRequestCharacterEncoding&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;);</span><br><span class="line">        <span class="comment">// 设置响应字符编码</span></span><br><span class="line">        classCache.put(<span class="string">&quot;setResponseCharacterEncoding&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tomcat和Spring的ApplicationContext区别"><a href="#Tomcat和Spring的ApplicationContext区别" class="headerlink" title="Tomcat和Spring的ApplicationContext区别"></a>Tomcat和Spring的ApplicationContext区别</h3><p><strong>相同点：</strong> 两者都是应用程序上下文，用于管理和获取容器的环境信息。</p><p><strong>不同点：</strong></p><ul><li><strong>Tomcat的ApplicationContext</strong>：Web容器相关的应用上下文，用于获取和管理Web容器的环境信息；</li><li><strong>Spring的ApplicationContext</strong>：Spring的IOC容器相关的应用上下文，用于获取和管理IOC容器的环境信息；</li></ul><blockquote><p><strong>IOC容器</strong>：</p><ul><li><strong>IOC控制反转思想：</strong>创建对象的控制权由内部（即new实例化）反转到外部（即IOC容器）。</li><li><strong>Bean：</strong>IOC容器中存放的一个个对象</li><li><strong>DI依赖注入：</strong>绑定IOC容器中bean与bean之间的依赖关系。例如将dao层对象注入到service层对象。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">// web容器：ApplicationContext是ServletContext接口的实现类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line">    <span class="comment">// 获取所有Bean</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">            System.out.println(beanDefinitionName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取所有web容器的属性</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">servletTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取所有web容器的属性</span></span><br><span class="line">        Enumeration&lt;String&gt; attributeNames = servletContext.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attributeNames.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> attributeNames.nextElement();</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 &lt;em&gt;Gang of Four&lt;/em&gt; (&lt;em&gt;GoF&lt;/em&gt;) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="system" scheme="https://southernfish.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型模式</title>
    <link href="https://southernfish.github.io/pages/java/java-design-pattern-creational/"/>
    <id>https://southernfish.github.io/pages/java/java-design-pattern-creational/</id>
    <published>2025-07-28T06:10:36.000Z</published>
    <updated>2025-09-17T07:51:48.707Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p><p><strong>创建型模式</strong>（Creational Patterns）：主要<strong>用于对象的创建</strong>，包括多个不同的模式，如工厂方法模式、抽象工厂模式、建造者模式、单例模式和原型模式等。这些模式都有助于降低系统耦合度，并提高代码的可重用性和可扩展性。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130423855?spm=1001.2014.3001.5502">设计模式——设计模式介绍和单例设计模式</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130433828?spm=1001.2014.3001.5502">设计模式——工厂模式</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/133910728">设计模式——原型模式</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/134162179">【设计模式】结合StringBuilder源码，探析建造者模式的特性和应用场景</a></p></blockquote><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对<strong>某个类只能存在一个对象实例</strong>，并且<strong>该类只提供一个取得其对象实例的方法</strong>（静态方法）</p><blockquote><p>比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，<strong>一个项目通常只需要一个 SessionFactory</strong> 就够，这是就会使用到单例模式</p></blockquote><p><strong>优点：</strong></p><ul><li><p>节省资源：单例模式实例只有一个，可以<strong>避免重复创建对象</strong>，从而节省了资源，提高了系统性能。</p></li><li><p>管理全局变量：单例模式可以用于管理全局状态和变量，方便在整个系统中<strong>共享数据</strong>。</p></li><li><p>简化系统架构：使用单例模式可以简化系统架构，减少类的数量和接口的复杂度。</p></li></ul><p><strong>缺点：</strong></p><ol><li><strong>可能引发并发问题</strong>：单例模式在多线程中使用时，需要保证线程安全，否则可能会引发并发问题。</li><li><strong>可能增加系统复杂性</strong>：过度使用单例模式可能会增加系统复杂性，导致代码难以维护。</li><li><strong>难以调试</strong>：由于单例模式全局共享状态，可能会导致调试过程中的问题难以定位和测试。</li></ol><p><strong>注意事项和使用场景</strong></p><ul><li>单例模式保证了系统内存中该类只存在一个对象，<strong>节省系统资源</strong>，对一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li><li>当想实例化一个单例类的时候，必须要记住<strong>使用相应的获取对象的方法</strong>，而不是使用 new</li><li><strong>单例模式使用的场景</strong>：需要<strong>频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多但又经常用到的对象</strong>（即：重量级对象）、工具类对象、频繁访问数据库或文件的对象（比如数据源、session 工厂等）</li></ul><h2 id="八种单例模式的创建方式"><a href="#八种单例模式的创建方式" class="headerlink" title="八种单例模式的创建方式"></a>八种单例模式的创建方式</h2><ol><li><strong>饿汉式（静态常量）：线程安全，没用到会浪费内存。</strong></li><li><strong>饿汉式（静态代码块）：线程安全，没用到会浪费内存。</strong></li><li>懒汉式（线程不安全）：懒加载，线程不安全。即用到时候再实例化，多线程时可能创建多个实例。不要用这种方式。</li><li>懒汉式（线程安全，同步方法）：线程安全，但效率低（每次获取实例都要加锁），不推荐。</li><li>懒汉式（线程不安全，同步代码块）：线程不安全，不要用这种方式。</li><li><strong>双重检查</strong></li><li><strong>静态内部类</strong></li><li><strong>枚举</strong></li></ol><h3 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h3><p>线程安全，可用，但如果没用到会浪费内存。</p><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 2、类的内部创建 私有静态常对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 3、向外暴露一个静态的公共方法 getInstance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li><strong>优点：</strong>写法简单，就是在<strong>类装载的时候就完成实例化</strong>（类变量在JVM类加载的准备、初始化阶段会赋值）。<strong>避免了线程同步问题</strong></li><li><strong>缺点：</strong>在类装载的时候就完成实例化，<strong>没有达到 Lazy Loading 的效果</strong>。若从始至终从未使用过这个实例，则会造成<strong>内存的浪费。</strong></li></ul><p>这种方式基于 classloder 机制避免了多线程的同步问题。不过，instance 在类装载时就实例化，在单例模式中大多数都是调用getlnstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 Lazy loading 的效果。</p><h3 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h3><p>线程安全，可用，但是可能造成内存浪费</p><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 2、类的内部声明对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 3、在静态代码块中创建对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4、向外暴露一个静态的公共方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong>：这种方式和上面静态常量的方式其实类似，只不过<strong>将类实例化的过程放在了静态代码块中</strong>，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。<strong>优缺点和上面是一样的。</strong></p><h3 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h3><p>懒加载，线程不安全。即用到时候再实例化，多线程时可能创建多个实例。<strong>不要用这种方式</strong>。</p><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、构造器私有化</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 2、类的内部声明对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="comment">// 3、向外暴露一个静态的公共方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li>起到了 <strong>Lazy Loading</strong> 的效果，但是只能在单线程下使用</li><li>如果在<strong>多线程</strong>下，一个线程进入了判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，便<strong>会产生多个实例</strong></li></ul><h3 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h3><p>线程安全，但效率低（每次获取实例都要加锁），不推荐。</p><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 2、类的内部声明对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 3、向外暴露一个静态的公共方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">    <span class="comment">// 向外暴露一个公共静态synchronized方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li>解决了线程不安全问题</li><li><strong>效率太低了</strong>，每个线程在想获得类的实例时候，执行<code>getlnstance()</code>方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接<code>return</code>就行了。方法进行同步效率太低</li></ul><h3 id="懒汉式（线程不安全，同步代码块）"><a href="#懒汉式（线程不安全，同步代码块）" class="headerlink" title="懒汉式（线程不安全，同步代码块）"></a>懒汉式（线程不安全，同步代码块）</h3><p>线程不安全，在实际开发中，<strong>不能使用这种方式</strong></p><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 2、类的内部声明对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 3、向外暴露一个静态的公共方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;    <span class="comment">// 可能有多个线程同时通过检查，多次执行下面代码，产生多个实例</span></span><br><span class="line">            <span class="comment">// 类级别的锁对象，锁对象是全局的，对该类的所有实例均有效。回顾锁对象是this时仅限于锁当前实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li>这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的的代码块</li><li>但这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了判断语句块，还未来得及往下执行，<strong>另一个线程也通过了这个判断语句</strong>，这时便会产生多个实例</li></ul><h3 id="双重检查（推荐，线程安全、懒加载）"><a href="#双重检查（推荐，线程安全、懒加载）" class="headerlink" title="双重检查（推荐，线程安全、懒加载）"></a>双重检查（推荐，线程安全、懒加载）</h3><p>在实际开发中，<strong>推荐使用</strong>这种单例设计模式</p><ol><li>构造器私有化</li><li>类的内部创建对象引用，同时用<strong>volatile关键字</strong>修饰</li><li>向外暴露一个静态的公共方法，<strong>加入同步处理的代码块，并进行双重判断</strong>，解决线程安全问题</li></ol><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2、类的内部声明对象，同时用`volatile`关键字修饰，为了保证可见性。</span></span><br><span class="line">    <span class="comment">// 原子性、可见性（修改立即更新到内存）、有序性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3、向外暴露一个静态的公共方法，加入同步处理的代码块，并进行双重判断，解决线程安全问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;                <span class="comment">// 第一次检查，可能有多个线程同时通过检查</span></span><br><span class="line">            <span class="comment">// 类级别的锁对象，锁对象是全局的，对该类的所有实例均有效。回顾锁对象是this时仅限于锁当前实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;    </span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;       <span class="comment">// 第二次检查，只会有1个线程通过检查并创建实例</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li>Double-Check 概念是多线程开发中常使用到的，我们进行了<strong>两次检查</strong>，这样就可以保证线程安全了</li><li>这样实例化代码只用执行一次，后面再次访问时直接 return 实例化对象，也避免的反复进行方法同步</li><li><strong>线程安全；延迟加载；效率较高</strong></li></ul><h3 id="静态内部类（推荐）"><a href="#静态内部类（推荐）" class="headerlink" title="静态内部类（推荐）"></a>静态内部类（推荐）</h3><p>线程安全、延迟加载、效率高，推荐使用。 </p><p><strong>步骤：</strong> </p><ul><li><p>1）构造器私有化</p></li><li><p>2）定义一个<strong>静态内部类</strong>，内部定义当前类的静态属性</p></li><li><p>3）向外暴露一个静态的公共方法</p></li></ul><blockquote><p>知识加油站：</p><ul><li><p>类的加载机制是延迟加载的，也就是说，只有在需要使用到某个类时才会进行加载。</p></li><li><p>类加载过程中会加载其所有静态成员到内存中，包括静态变量、静态成员方法和静态内部类。</p></li><li><p>类加载包括加载、链接（验证、准备（为类变量分配内存并赋零值）、解析）、初始化（类变量赋初值、执行静态语句块）。</p></li></ul></blockquote><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 2、定义一个静态内部类，内部定义当前类的静态属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、向外暴露一个静态的公共方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li>这种方式采用了类装载的机制，来保证初始化实例时只有一个线程</li><li>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用getlnstance方法，才会装载Singletonlnstance 类，从而完成 Singleton 的实例化。</li><li>类的静态属性只会在第一次加载类的时候初始化，<strong>JVM</strong>帮助我们保证了<strong>线程的安全性</strong>，在类进行初始化时，别的线程是无法进入的</li><li><strong>优点</strong>：避免了线程不安全，利用静态内部类特点实现<strong>延迟加载，效率高</strong></li></ul><h3 id="枚举（推荐）"><a href="#枚举（推荐）" class="headerlink" title="枚举（推荐）"></a>枚举（推荐）</h3><p>推荐，线程安全，延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        System.out.println(instance == instance2);    <span class="comment">// true</span></span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能<strong>避免多线程同步问题</strong>，而且还能防止反序列化重新创建新的对象</li><li>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式</li></ul><h3 id="JDK-源码里单例模式分析"><a href="#JDK-源码里单例模式分析" class="headerlink" title="JDK 源码里单例模式分析"></a>JDK 源码里单例模式分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span>&#123; <span class="keyword">return</span> currentRuntime; &#125;</span><br><span class="line">    <span class="comment">// Don&#x27;t let anyone else instantiate this class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="工厂模式介绍"><a href="#工厂模式介绍" class="headerlink" title="工厂模式介绍"></a>工厂模式介绍</h2><p>以提高复杂性为代价，提高可维护性和复用性。 </p><p>工厂模式是一种<strong>创建型设计模式（跟创建对象有关）</strong>，它主要解决了对象的创建过程中的灵活性和可维护性问题。工厂模式允许在<strong>不暴露对象创建逻辑</strong>的情况下，统一由<strong>工厂类负责创建对象并返回</strong>，从而降低了代码的耦合性。</p><ol><li><p><strong>简单工厂模式</strong> </p><p>简单工厂模式是<strong>通过工厂类</strong>（抽象或非抽象）<strong>的静态方法来创建对象实例</strong>，并将实例作为方法的返回值。在使用时，只需要调用该静态方法来创建对象，而无需创建工厂类的实例。<strong>静态工厂方法也是简单工厂模式的一种</strong>。</p></li><li><p><strong>工厂方法模式</strong></p><p>工厂方法模式是在抽象工厂类里<strong>定义创建抽象产品对象的抽象方法，由具体工厂类决定要实例化的产品类</strong>。抽象工厂类的构造器里调用“创建抽象产品对象”的抽象方法，具体工厂类重写抽象方法，按情景实例化具体产品类。使用时直接创建具体工厂对象，将执行抽象工程类构造器调用重写后的创建方法，创建具体产品对象。</p><p>一个抽象工厂类能派生多个具体工厂类。每个具体工厂类只能建立一个具体产品类的实例。一个抽象产品类能派生多个具体产品类。 </p></li><li><p><strong>抽象工厂模式</strong></p><p>抽象工厂模式是抽象工厂接口里定义创建抽象产品对象的抽象方法，各具体工厂实现类根据情景创建具体产品对象。</p><p>一个抽象工厂类能够派生出多个具体工厂类。每一个具体工厂类能够建立多个具体产品类的实例。多个抽象产品类，每个抽象产品类能够派生出多个具体产品类。</p></li></ol><p><strong>优点：</strong></p><ol><li>可以避免直接使用new关键字创建对象带来的耦合性，提高了代码的<strong>可维护性</strong>；</li><li>可以将对象的创建逻辑封装到一个工厂类中，提高了代码的<strong>复用性</strong>；</li><li>可以对<strong>对象的创建逻辑进行统一管理</strong>，方便代码的维护和升级。</li></ol><p><strong>缺点：</strong></p><ol><li>增加了代码的复杂度，需要创建工厂类，会<strong>增加代码规模</strong>；</li><li>如果产品类发生变化，需要<strong>修改工厂类，可能会影响到其他代码的功能</strong>。</li></ol><p>综上所述，工厂模式是一种常用的创建型设计模式，可以提高代码的可维护性、复用性和灵活性。但是，在使用时需要权衡利弊，避免过度使用，增加代码的复杂度。</p><p><strong>工厂模式的意义：</strong></p><p>将<strong>实例化对象的代码提取出来</strong>，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</p><p><strong>设计模式的依赖抽象原则：</strong></p><ul><li>创建对象实例时，不要直接 new 类，而是把这个 new 类的动作放在一个工厂的方法中并返回。有的书上说，变量不要直接持有具体类的引用</li><li>不要让类继承具体类，而是继承抽象类或者是实现 interface（接口）</li><li>不要覆盖基类中已经实现的方法</li></ul><h2 id="披萨项目需求"><a href="#披萨项目需求" class="headerlink" title="披萨项目需求"></a>披萨项目需求</h2><p>披萨项目：要便于披萨种类的扩展，要便于维护</p><ul><li>披萨的种类很多（比如 GreekPizz、CheesePizz 等）</li><li>披萨的制作有 prepare、bake、cut、box</li><li>完成披萨店订购功能</li></ul><h2 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPizza</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 准备原材料，不同具体披萨不一样，所以是抽象方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; baking...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; cutting...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">box</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; boxing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 希腊风味披萨</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreekPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        setName(<span class="string">&quot;GreekPizza&quot;</span>);</span><br><span class="line">        System.out.println(name + <span class="string">&quot; preparing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 奶酪披萨</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheesePizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        setName(<span class="string">&quot;CheesePizza&quot;</span>);</span><br><span class="line">        System.out.println(name + <span class="string">&quot; preparing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 订购披萨，不断输入披萨类型，输出披萨的生产包装过程。</span></span><br><span class="line"><span class="comment">// 耦合度高，违反了设计模式的 OCP 原则，即对扩展开放，对修改关闭。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        String orderType;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 每次新增披萨类型，都要改这个订购类，而订购类可能会有很多，都要改就太麻烦了</span></span><br><span class="line">            orderType = getType();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;cheese&quot;</span>.equals(orderType)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;greek&quot;</span>.equals(orderType)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入类型错误，程序退出&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pizza.prepare();</span><br><span class="line">            pizza.bake();</span><br><span class="line">            pizza.cut();</span><br><span class="line">            pizza.box();</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入披萨类型：&quot;</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> reader.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 披萨商店</span></span><br><span class="line"><span class="comment">// 相当于一个客户端，发出订购</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">stubOrderPizza</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>传统方式优缺点：</strong></p><ul><li><p>优点是比较好理解，简单易操作</p></li><li><p>缺点是<strong>违反了设计模式的 OCP 原则，即对扩展开放，对修改关闭。</strong>即当给类增加新功能时，尽量不修改代码，或尽可能少修改。</p></li><li><p>比如我们这时要新增加一个Pizza的种类（Cheese技萨），需要做如下修改订购类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 胡椒披萨</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PepperPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        setName(<span class="string">&quot;PepperPizza&quot;</span>);</span><br><span class="line">        System.out.println(name + <span class="string">&quot; preparing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;pepper&quot;</span>.equals(orderType)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>改进的思路分析：</strong></p><p>分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着也需要修改。而创建Pizza的代码，往往有多处<br>思路：<strong>把创建 Pizza 对象封装到一个类中</strong>，这样我们有新的 Pizza 种类时，只需要修改该类就可，其它有创建到 Pizza 对象的代码就不需要修改了 ==&gt; <strong>简单工厂模式</strong></p><h2 id="非静态简单工厂模式"><a href="#非静态简单工厂模式" class="headerlink" title="非静态简单工厂模式"></a>非静态简单工厂模式</h2><ul><li>简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是<strong>由一个工厂对象决定创建出哪一种产品类的实例</strong>。简单工厂模式是工厂模式家族中最简单实用的模式</li><li>简单工厂模式：<strong>定义了一个创建对象的类，由这个类来封装实例化对象的行为</strong>（代码）</li><li>在软件开发中，如果要用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式</li></ul><p><strong>简单工厂模式优化披萨项目</strong></p><p>创建一个披萨工厂类，用于根据披萨类别创建披萨对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个披萨工厂类，用于根据披萨类别创建披萨对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (orderType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;cheese&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;greek&quot;</span>:  pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pepper&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改订购披萨类，披萨对象从披萨工厂类获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaFactory pizzaFactory;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(PizzaFactory pizzaFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pizzaFactory = pizzaFactory;</span><br><span class="line">        orderPizza();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            pizza = pizzaFactory.createPizza(getType());</span><br><span class="line">            <span class="keyword">if</span> (pizza == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Failed to Order Pizza&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);        <span class="comment">// 无限循环，不断输入披萨类型，进行加工、包装等操作；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态简单工厂模式"><a href="#静态简单工厂模式" class="headerlink" title="静态简单工厂模式"></a>静态简单工厂模式</h2><p>静态工厂模式也是简单工厂模式的一种，只是<strong>将工厂方法改为静态方法</strong></p><p>静态工厂模式<strong>通过工厂类的静态方法来创建对象实例，并将实例作为方法的返回值</strong>。在使用时，只需要调用该静态方法来创建对象，而无需创建工厂类的实例。</p><p>静态工厂模式的优点在于可以<strong>简化代码实现</strong>，无需创建工厂对象的实例，提高代码的简洁性；<strong>对比普通工厂模式</strong>的优点在于<strong>更方便扩展和修改</strong>，如果需要新增一个产品线，只需要添加具体的产品类和对应的工厂类即可，无需修改已有的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单静态工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title function_">createPizza2</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订购披萨类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 直接通过静态方法创建工厂对象，不用再像之前通过“构造器参数赋值成员变量”方式创建对象。</span></span><br><span class="line">            pizza = PizzaFactory.createPizza(getType());    </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式：<strong>定义创建对象的抽象方法</strong>，由<strong>子类决定要实例化的类</strong>。工厂方法模式将对象的实例化推迟到子类。</p><p><strong>实现方式：</strong>抽象工厂类的构造器里调用“创建抽象产品对象”的抽象方法，具体工厂类重写抽象方法，按情景实例化具体产品类。</p><p>一个抽象产品能够派生出多个具体产品类。 一个抽象工厂类能够派生出多个具体工厂类。每一个具体工厂类只能建立一个具体产品类的实例。 </p><p>工厂方法模式包含以下几个角色：</p><ol><li><p>抽象产品类（Product）：定义了产品的抽象接口，具体产品将按照抽象产品类所定义的接口来实现。</p></li><li><p>具体产品类（Concrete Product）：是抽象产品类的一个具体实现，定义了具体产品的实现方法。</p></li><li><p>抽象工厂类（Factory）：是工厂方法模式的核心，定义了工厂类需要实现的接口，用于创建产品对象。</p></li><li><p>具体工厂类（Concrete Factory）：是抽象工厂类的一个具体实现，实现了工厂方法创建具体对象实例的逻辑。</p></li></ol><p><strong>披萨项目新的需求</strong>：客户可以点不同口味的披萨，如<strong>北京奶酪 Pizza</strong>、北京胡椒 Pizza 或者是伦敦奶酪 Pizza、伦敦胡椒 Pizza</p><p><strong>思路1</strong>：使用简单工厂模式，创建不同的简单工厂类，比如 BJPizzaFactory、LDPizzaFactory 等等。从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好</p><p><strong>思路2</strong>：工厂方法模式设计方案：将披萨项目的<strong>实例化功能抽象成抽象方法</strong>，在不同的口味点餐子类中具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 披萨商店</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">loc</span> <span class="operator">=</span> <span class="string">&quot;bj&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (loc.equals(<span class="string">&quot;bj&quot;</span>)) &#123;                <span class="comment">// 创建北京口味的各种Rizza</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BJOrderPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LDOrderPizza</span>();             <span class="comment">// 创建伦敦口味的各种Pizza</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象工厂类，订购披萨类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOrderPizzaFactory</span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法不断根据用户输入披萨类型，调用创建披萨对象的抽象方法，实现加工披萨。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            pizza = createPizza(getType());</span><br><span class="line">            <span class="keyword">if</span> (pizza == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Failed to Order Pizza&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂类，订购伦敦披萨类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">AbstractOrderPizzaFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (orderType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;cheese&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">LDCheesePizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pepper&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">LDPepperPizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂类，订购北京披萨类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">AbstractOrderPizzaFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (orderType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;cheese&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">BJCheesePizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pepper&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂接口里有创建抽象产品的方法，各具体工厂实现类根据情景创建具体产品对象。</p><ul><li>抽象工厂模式：定义了一个接口用于创建相关或有依赖关系的对象簇，而无需指明具体的类</li><li>抽象工厂模式可以<strong>将简单工厂模式和工厂方法模式进行整合</strong></li><li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）</li><li>将工厂抽象成两层，抽象工厂接口和具体工厂类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展</li></ul><p> 抽象工厂接口里有创建抽象产品的方法，各具体工厂实现类根据情景创建具体产品对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbsPizzaFactory</span> &#123;</span><br><span class="line">    Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJPizzaFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsPizzaFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (orderType) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDPizzaFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsPizzaFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (orderType) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订购披萨</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(AbsFactory factory)</span> &#123;</span><br><span class="line">        setFactory(factory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderPizza</span><span class="params">(AbsFactory factory)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="comment">// 用户输入</span></span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类</span></span><br><span class="line">            pizza = factory.createPizza(orderType);</span><br><span class="line">            <span class="keyword">if</span> (pizza != <span class="literal">null</span>) &#123;     <span class="comment">// 订购ok</span></span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;Failed to Order Pizza&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);                <span class="comment">// 无限循环，不断输入披萨类型，进行加工、包装等操作；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建订购单，由具体工厂类创建具体产品对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">OrderPizza</span>(<span class="keyword">new</span> <span class="title class_">BJFactory</span>());</span><br></pre></td></tr></table></figure><h2 id="JDK-源码分析"><a href="#JDK-源码分析" class="headerlink" title="JDK 源码分析"></a>JDK 源码分析</h2><p>JDK 中的 Calendar 类中，就使用了静态简单工厂模式。</p><p><strong>静态简单工厂模式：由一个工厂对象</strong>（可以是抽象类，可以是非抽象类）<strong>决定创建出哪种产品类的实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Calendar类是工厂类，getInstance()是静态方法，用于创建对象</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 注意月份下标从O开始，所以取月份要+1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年:&quot;</span> + cal.get(Calendar.YEAR));</span><br><span class="line">        System.out.println(<span class="string">&quot;月:&quot;</span> + (cal.get(Calendar.MONTH) + <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;日:&quot;</span> + cal.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">        System.out.println(<span class="string">&quot;时:&quot;</span> + cal.get(Calendar. HOUR_OF_DAY)) ;</span><br><span class="line">        System.out.println(<span class="string">&quot;分:&quot;</span> + cal.get(Calendar. MINUTE)) ;</span><br><span class="line">        System.out.println(<span class="string">&quot;秒:&quot;</span> + cal. get(Calendar.SECOND));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Calendar工厂类，决定创建出哪一种产品类的实例</span></span><br><span class="line"><span class="comment">// Calendar类是工厂类，getInstance()是静态方法，用于创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Calendar</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Cloneable, Comparable&lt;Calendar&gt; &#123;</span><br><span class="line">    <span class="comment">// 根据时区地区返回Calendar 实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Locale</span> <span class="variable">aLocale</span> <span class="operator">=</span> Locale.getDefault(Locale.Category.FORMAT);</span><br><span class="line">        <span class="keyword">return</span> createCalendar(defaultTimeZone(aLocale), aLocale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据时区地区创建Calendar 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title function_">createCalendar</span><span class="params">(TimeZone zone, Locale aLocale)</span>&#123;</span><br><span class="line">        <span class="type">CalendarProvider</span> <span class="variable">provider</span> <span class="operator">=</span> LocaleProviderAdapter</span><br><span class="line">                                .getAdapter(CalendarProvider.class, aLocale)</span><br><span class="line">                                 .getCalendarProvider();</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> provider.getInstance(zone, aLocale);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">                <span class="comment">// fall back to the default instantiation</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (aLocale.hasExtensions()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">caltype</span> <span class="operator">=</span> aLocale.getUnicodeLocaleType(<span class="string">&quot;ca&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (caltype != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (caltype) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;buddhist&quot;</span>: cal = <span class="keyword">new</span> <span class="title class_">BuddhistCalendar</span>(zone, aLocale); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;japanese&quot;</span>: cal = <span class="keyword">new</span> <span class="title class_">JapaneseImperialCalendar</span>(zone, aLocale); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;gregory&quot;</span>: cal = <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>(zone, aLocale); <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cal == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据不同地区，返回不同的具体的产品类</span></span><br><span class="line">            <span class="comment">// If no known calendar type is explicitly specified,</span></span><br><span class="line">            <span class="comment">// perform the traditional way to create a Calendar:</span></span><br><span class="line">            <span class="comment">// create a BuddhistCalendar for th_TH locale,</span></span><br><span class="line">            <span class="comment">// a JapaneseImperialCalendar for ja_JP_JP locale, or</span></span><br><span class="line">            <span class="comment">// a GregorianCalendar for any other locales.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> The language, country and variant strings are interned.</span></span><br><span class="line">            <span class="keyword">if</span> (aLocale.getLanguage() == <span class="string">&quot;th&quot;</span> &amp;&amp; aLocale.getCountry() == <span class="string">&quot;TH&quot;</span>) &#123;</span><br><span class="line">                cal = <span class="keyword">new</span> <span class="title class_">BuddhistCalendar</span>(zone, aLocale);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aLocale.getVariant() == <span class="string">&quot;JP&quot;</span> &amp;&amp; aLocale.getLanguage() == <span class="string">&quot;ja&quot;</span></span><br><span class="line">                       &amp;&amp; aLocale.getCountry() == <span class="string">&quot;JP&quot;</span>) &#123;</span><br><span class="line">                cal = <span class="keyword">new</span> <span class="title class_">JapaneseImperialCalendar</span>(zone, aLocale);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cal = <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>(zone, aLocale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="经典的克隆羊问题（复制10只属性相同的羊）"><a href="#经典的克隆羊问题（复制10只属性相同的羊）" class="headerlink" title="经典的克隆羊问题（复制10只属性相同的羊）"></a>经典的克隆羊问题（复制10只属性相同的羊）</h2><p><strong>问题描述：</strong>现在有一只羊，姓名为 Tom，年龄为 1，颜色为白色，请编写程序创建和 Tom 羊属性完全相同的 10 只羊。</p><h2 id="传统方案：循环new对象"><a href="#传统方案：循环new对象" class="headerlink" title="传统方案：循环new对象"></a>传统方案：循环new对象</h2><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 羊</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 克隆羊</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">            System.out.println(sheep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点和改进思路"><a href="#优缺点和改进思路" class="headerlink" title="优缺点和改进思路"></a>优缺点和改进思路</h3><p><strong>优点</strong>：好理解，简单易操作</p><p><strong>缺点：</strong></p><ul><li><strong>每次获取再复制效率低：</strong>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li><li><strong>不灵活：</strong>总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活</li></ul><p><strong>改进的思路分析：Object 类的 clone() 方法</strong></p><p>Object 类是所有类的根类，Object 类提供了一个 clone 方法，该方法可以将一个 Java 对象复制一份，但是对应的类必须<strong>实现Cloneable接口</strong>，该接口表示该类能够复制且具有复制的能力 ==&gt; <strong>原型模式</strong></p><h2 id="原型模式（Prototype模式）"><a href="#原型模式（Prototype模式）" class="headerlink" title="原型模式（Prototype模式）"></a>原型模式（Prototype模式）</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>原型模式（Prototype 模式）：</strong>用<strong>原型实例</strong>指定创建对象种类，并通过<strong>拷贝</strong>原型创建新的对象</p><p>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。</p><p><strong>原理：</strong>将一个原型对象传给要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()</p><blockquote><p><strong>创建型设计模式：</strong>关注如何有效地创建对象，以满足不同的需求和情境。</p><p><strong>包括：</strong>单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</p></blockquote><h3 id="原理及代码演示"><a href="#原理及代码演示" class="headerlink" title="原理及代码演示"></a>原理及代码演示</h3><ul><li><strong>Prototype：</strong>原型类。包含一个用于复制对象的克隆方法。可以使用Cloneable接口作为原型接口。</li><li><strong>ConcretePrototype：</strong>具体原型类。实现原型接口、重写克隆方法clone()的具体类。</li><li><strong>Client：</strong>让一个原型对象克隆自己，创建一个属性相同的对象</li></ul><p><strong>原型接口：</strong> 可以是Cloneable接口也可以是自定义带clone()方法的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：定义原型接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Prototype</span> <span class="keyword">extends</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    Prototype <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 步骤2：实现具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Prototype) <span class="built_in">super</span>.clone();     <span class="comment">// 使用浅拷贝</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 步骤3：客户端代码，通过clone()方法创建原型对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();                     <span class="comment">// 创建具体类对象</span></span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">clonedObject</span> <span class="operator">=</span> (ConcretePrototype) prototype.clone(); <span class="comment">// 通过clone方法创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型模式解决克隆羊问题"><a href="#原型模式解决克隆羊问题" class="headerlink" title="原型模式解决克隆羊问题"></a>原型模式解决克隆羊问题</h3><blockquote><p><strong>问题回顾：</strong></p><p> 现在有一只羊，姓名为 Tom，年龄为 1，颜色为白色，请编写程序创建和 Tom 羊属性完全相同的 10 只羊。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型接口：Cloneable接口。</span></span><br><span class="line"><span class="comment">// 具体原型类：实现Cloneable接口</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sheep</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">(String name, Integer age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sheep = (Sheep) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端： 调用具体原型类的clone()方法创建10个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Sheep</span> <span class="variable">sheep1</span> <span class="operator">=</span> (Sheep) sheep.clone();</span><br><span class="line">            System.out.println(sheep1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="优缺点和使用场景"><a href="#优缺点和使用场景" class="headerlink" title="优缺点和使用场景"></a>优缺点和使用场景</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><p><strong>构造方法复杂时开销小：</strong>如果构造函数的逻辑很复杂，此时通过new创建该对象会比较耗时，那么就可以尝试使用克隆来生成对象。</p></li><li><p><strong>运行时动态创建对象：</strong>不用重新初始化对象，而是动态地获得对象运行时的状态</p></li><li><p><strong>开闭原则（OCP原则）</strong>：如果原始对象发生变化（增加或者减少属性），其它克隆对象的也会发生相应的变化，无需更改客户端代</p><p>码。相反，如果使用new方式，就需要在客户端修改构造参数。这使得系统更加灵活和可维护。</p></li><li><p><strong>对象封装性</strong>：原型模式可以帮助保护对象的封装性，因为客户端代码无需了解对象的内部结构，只需知道如何克隆对象。</p></li><li><p><strong>多态性</strong>：原型模式支持多态性，因为克隆操作可以返回具体子类的对象，而客户端代码不需要关心对象的具体类。</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li><p><strong>构造方法简单时开销大：</strong>如果构造函数的逻辑很简单，原型模式的效率不如new，因为JVM对new做了相应的性能优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//    验证构造方法简单时，原型模式开销大</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">    <span class="comment">// 克隆循环十万次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        sheep.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">midTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 20ms</span></span><br><span class="line">    System.out.println(<span class="string">&quot;克隆生成对象耗费的时间:&quot;</span> + (midTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    <span class="comment">// new10万次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Sheep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5ms</span></span><br><span class="line">    System.out.println(<span class="string">&quot;new生成对象耗费的时间:&quot;</span> + (System.currentTimeMillis() - midTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>要注意深拷贝和浅拷贝问题：</strong>实现Cloneable接口时，如果具体原型类直接返回super.clone()，则是浅拷贝。克隆的对象里，引用类型变量只拷贝引用，依然指向旧的地址。</p></li><li><p><strong>代码复杂性：</strong>在实现深拷贝的时候可能需要比较复杂的代码。设计模式一般都是以代码复杂性为代价，提高可扩展性、可读性。</p></li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ol><li><strong>构造方法复杂：</strong>要创建的对象构造方法逻辑很复杂，即创建新的对象比较复杂时，使用原型模式会比直接new效率更高；</li><li><strong>经常需要克隆：</strong>经常要创建一个和原对象属性相同的对象时，可以考虑原型模式。</li></ol><h3 id="Spring源码中的原型模式"><a href="#Spring源码中的原型模式" class="headerlink" title="Spring源码中的原型模式"></a>Spring源码中的原型模式</h3><p>Spring 框架Bean的生命周期中，ApplicationContext类的getBean()方法中，有用到原型模式。</p><p>获取Bean时会判断配置的Bean是单例还是原型，如果是原型，则用原型模式创建Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.issingleton())&#123;...&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype())&#123;</span><br><span class="line">    <span class="comment">// It&#x27;s a prototupe -&gt; create a new instance.</span></span><br><span class="line">    0<span class="type">bject</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        beforePrototypeCreation(beanName);</span><br><span class="line">        prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterPrototypeCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    beanInstance = getobjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>验证：</strong>bean指定原型模式后，getBean()获取到的多个Bean是不同对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;id01&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">// 注解方式是@Scope(&quot;prototype&quot;)。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> health;</span><br><span class="line">     <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Monster</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Monster</span><span class="params">(String name, <span class="type">int</span> health)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.health = health;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加其他属性和方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtoType</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过ID获取Monster</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;id01&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;bean: &quot;</span> + bean); <span class="comment">// 输出“牛魔王&quot;....</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean2</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;id01&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;bean2: &quot;</span> + bean2); <span class="comment">// 输出“牛魔王&quot;....</span></span><br><span class="line">        System.out.println(bean == bean2); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也可以用xml形式注册Bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里使用scope=&quot;prototype&quot;即 原型模式来创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;id01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atquigu.spring.bean.Monster&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><h4 id="浅拷贝：引用类型变量拷贝引用"><a href="#浅拷贝：引用类型变量拷贝引用" class="headerlink" title="浅拷贝：引用类型变量拷贝引用"></a>浅拷贝：引用类型变量拷贝引用</h4><ul><li><strong>浅拷贝：</strong>拷贝后对象是新地址，基本类型变量拷贝值，引用类型变量拷贝引用。只复制某个对象的引用，而不复制对象本身，新旧对象还是共享同一块内存。</li></ul><p><strong>实现方案：</strong>具体原型类直接返回super.clone()</p><p>实现Cloneable 接口，重写 clone()方法， 直接返回super.clone()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;   <span class="comment">// 虽然clone()是Object类的方法，但Java规定必须得实现一下这个接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;                            <span class="comment">// 基本类型变量拷贝值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p1.clone();            <span class="comment">// p2将是p1浅拷贝的对象</span></span><br><span class="line">        p2.age = <span class="number">20</span>;</span><br><span class="line">        System.out.println(p1 == p2);     <span class="comment">// false。拷贝后对象是新地址</span></span><br><span class="line">        System.out.println(p1.age);     <span class="comment">// 18。基本类型变量拷贝值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深拷贝：引用类型变量拷贝值"><a href="#深拷贝：引用类型变量拷贝值" class="headerlink" title="深拷贝：引用类型变量拷贝值"></a><strong>深拷贝：</strong>引用类型变量拷贝值</h4><p><strong>深拷贝：</strong>拷贝后对象是新地址，基本类型变量拷贝值，引用类型变量拷贝克隆后的值。创造一个一摸一样的对象，新对象和原对象不共享内存，修改新对象不会改变原对对象。反序列化创建对象是深拷贝。 </p><p><strong>实现方案：</strong>具体原型类专门克隆引用类型变量</p><p>实现Cloneable 接口，重写 clone()方法， 给super.clone()的引用类型成员变量也clone()一下，然后再返回克隆的对象。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;                                <span class="comment">// 基本类型变量拷贝值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            person.arr = <span class="built_in">this</span>.arr.clone();         <span class="comment">// 用引用类型的 clone 方法，引用类型变量拷贝克隆后的值</span></span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="经典的盖房子问题"><a href="#经典的盖房子问题" class="headerlink" title="经典的盖房子问题"></a>经典的盖房子问题</h2><p><strong>问题描述：</strong></p><ul><li><strong>建房子过程：</strong>打桩、砌墙、封顶。虽然建造过程一样，但实际造的房子有差别，因为房子有各种各样的，比如普通房，高楼，别墅。</li><li><strong>需求：</strong>写代码能建造各类房子</li></ul><h2 id="传统方案盖房子"><a href="#传统方案盖房子" class="headerlink" title="传统方案盖房子"></a>传统方案盖房子</h2><h3 id="实现方案：产品和创建产品过程耦合"><a href="#实现方案：产品和创建产品过程耦合" class="headerlink" title="实现方案：产品和创建产品过程耦合"></a>实现方案：产品和创建产品过程耦合</h3><p>创建以下几个类：</p><ul><li>AbsHouse（抽象盖房类）：包含打桩、砌墙、封顶三个方法；</li><li>NormalRoom（普通房间类）、Villa（别墅类）：继承抽象盖房类，根据情况重写三个方法；</li></ul><p>抽象盖房类：包含打桩、砌墙、封顶三个方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象房间类:包含打桩、砌墙、封顶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsHouse</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span>; <span class="comment">// 打桩</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span>; <span class="comment">// 砌墙</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span>; <span class="comment">// 封顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123; <span class="comment">// 盖房子</span></span><br><span class="line">        piling();</span><br><span class="line">        walling();</span><br><span class="line">        capping();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NormalRoom（普通房间类）、Villa（别墅类）：继承抽象盖房类，根据情况重写三个方法；</span></span><br><span class="line"><span class="comment">// 普通房</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalRoom</span> <span class="keyword">extends</span> <span class="title class_">AbsHouse</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房打桩...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房砌墙...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房封顶...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高楼</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighRise</span> <span class="keyword">extends</span> <span class="title class_">AbsHouse</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 别墅</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Villa</span> <span class="keyword">extends</span> <span class="title class_">AbsHouse</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点和改进思路-1"><a href="#优缺点和改进思路-1" class="headerlink" title="优缺点和改进思路"></a>优缺点和改进思路</h3><p><strong>优点：</strong>简单，好理解易操作</p><p><strong>缺点</strong>：<strong>产品和创建产品过程耦合：</strong>没有设计<strong>缓存层对象</strong>，程序的扩展和维护不好。也就是说，这种设计方案把产品（即：房子）和创建产品的过程（即：建房子流程）封装在一起，耦合性太高。</p><p><strong>改进思路分析：</strong>使用建造者模式，将产品和产品建造过程<strong>解耦</strong>。</p><h2 id="建造者模式-生成器模式"><a href="#建造者模式-生成器模式" class="headerlink" title="建造者模式/生成器模式"></a>建造者模式/生成器模式</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>建造者模式（Builder Pattern）</strong>：使用多个步骤来创建一个复杂对象，而不是在一个构造函数或工厂方法中直接返回该对象。它将产品和产品建造过程进行了解耦。</p><p>建造者模式又叫生成器模式，是一种创建型设计模式。</p><p><strong>特点：</strong></p><ul><li>分步骤创建对象：对象的构建是分多个步骤进行的，而不是直接使用构造方法new对象，适用于需要分阶段构造的复杂对象。</li><li>同一个建造过程：同样的构建过程可以创建不同的对象表示（不同的配置组合）。</li></ul><h3 id="四个角色"><a href="#四个角色" class="headerlink" title="四个角色"></a>四个角色</h3><ul><li><p><strong>Product（产品）</strong>：一个包含多个部件的类。</p><p>每个部件是一个成员变量。例如房间包括地基、墙和屋顶等组件，又例如电脑包括CPU、内存条、主板等组件。</p></li><li><p><strong>Builder（抽象建造者）</strong>：一个包含产品变量及其所有部件建造方法的抽象类或接口</p><p>包含每个部件的建造方法，和一个返回产品的build()方法。例如房间的打桩、砌墙、封顶过程。</p></li><li><p><strong>ConcreteBuilder（具体建造者）</strong>：实现抽象建造者所有抽象建造方法</p></li><li><p><strong>Director（指挥者）</strong>：一个以抽象建造者为变量的、包含建造方法的类</p><ul><li>包含一个抽象建造者变量，和一个建造并返回产品的build()方法。</li><li>实际建造产品时，先创建一个指挥者对象，然后设置它的建造者变量，最后调用它的build()方法返回产品。</li></ul></li></ul><h3 id="优缺点和使用场景-1"><a href="#优缺点和使用场景-1" class="headerlink" title="优缺点和使用场景"></a>优缺点和使用场景</h3><p><strong>优点：</strong></p><ul><li><strong>耦合性降低</strong>：<ul><li><strong>产品与建造解耦</strong>：客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li><strong>具体建造者之间解耦</strong>：每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象</li></ul></li><li><strong>代码可读性高</strong>：可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</li><li><strong>开闭原则</strong>：增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”，即代码对修改不开放，而对扩展开放。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>代码复杂性</strong>：没了解过建造者模式的人阅读代码更困难，这也是设计模式的通用缺点。</li><li><strong>过度设计风险</strong>：建造者模式只适合复杂产品对象，太简单的产品对象则没必要使用，或者建造方式只有一种的产品，都没必要使用。这也是设计模式的通用缺点。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>复杂产品对象</strong>：部件比较多的产品，例如房屋有墙、屋顶、地基、横梁等等部件。</li><li><strong>建造方式多样</strong>：例如房屋对于同一些材料，可以建成普通房屋、高楼等等。</li><li><strong>建造产品共同点</strong>：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制</li></ul><p><strong>不适用场景</strong>：</p><ul><li>简单产品对象；</li><li>建造方式单一；</li></ul><h3 id="建造者模式和抽象工厂模式的区别"><a href="#建造者模式和抽象工厂模式的区别" class="headerlink" title="建造者模式和抽象工厂模式的区别"></a>建造者模式和抽象工厂模式的区别</h3><p><strong>区别：</strong> </p><ul><li><strong>抽象工厂模式</strong>：适用于<strong>不同产品</strong>的情况。用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类）。</li><li><strong>建造者模式</strong>：适用于<strong>一个产品有多个部件</strong>的情况。用来创建一种类型的复杂对象，通过设置不同可选参数，“定制化”创建不同对象。</li></ul><p><strong>示例</strong>：顾客走进一家餐馆点餐</p><ul><li><strong>工厂模式</strong>：根据用户不同的选择，来制作<strong>不同的食物</strong>，比如披萨、汉堡、沙拉。</li><li><strong>建造者模式</strong>：对于披萨来说，用户又有各种配料可以定制，我们通过建造者模式根据用户选择的<strong>不同配料</strong>来制作披萨。</li></ul><h2 id="建造者模式盖房子"><a href="#建造者模式盖房子" class="headerlink" title="建造者模式盖房子"></a>建造者模式盖房子</h2><h3 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h3><p>产品类包含多个部件的对象。<br>每个部件是一个成员变量。例如房间包括地基、墙和屋顶等组件，又例如电脑包括CPU、内存条、主板等组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品：房间类，包含多个部件</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String pile; <span class="comment">// 地基</span></span><br><span class="line">    <span class="keyword">private</span> String wall; <span class="comment">// 墙</span></span><br><span class="line">    <span class="keyword">private</span> String roof; <span class="comment">// 屋顶</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter和setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象建造者"><a href="#抽象建造者" class="headerlink" title="抽象建造者"></a>抽象建造者</h3><p>抽象建造者是个抽象类，包含每个部件的建造方法，和一个返回产品的build()方法<br>例如房间的打桩、砌墙、封顶过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象建造者：房间建造抽象类,包含每个部件的抽象建造方法，和一个build()方法返回产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>(); <span class="comment">// 产品对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span>; <span class="comment">// 打地基</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span>; <span class="comment">// 砌墙</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span>; <span class="comment">// 封顶</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  build()方法返回产品</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体建造者"><a href="#具体建造者" class="headerlink" title="具体建造者"></a>具体建造者</h4><p>具体建造者是抽象建造者的实现类，实现各个部件具体构建逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体建造者：普通房屋建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalRoomBuilder</span> <span class="keyword">extends</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;普通房打桩...&quot;</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;普通房砌墙...&quot;</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;普通房封顶...&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighRiseBuilder</span> <span class="keyword">extends</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指挥者"><a href="#指挥者" class="headerlink" title="指挥者"></a>指挥者</h4><p>指挥类包含一个抽象建造者变量，和一个建造并返回产品的build()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指挥者：负责建造并返回产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseDirector</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象建造者变量</span></span><br><span class="line">    <span class="keyword">private</span> HouseBuilder houseBuilder;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HouseDirector</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建房子方法</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">buildHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用建造者变量的各部门建造方法，然后建造返回</span></span><br><span class="line">        houseBuilder.piling();</span><br><span class="line">        houseBuilder.walling();</span><br><span class="line">        houseBuilder.capping();</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><p><strong>步骤：</strong></p><ol><li><strong>创建指挥者</strong>：创建一个指挥者对象</li><li><strong>设置建造者</strong>：设置它的建造者变量为具体建造者对象</li><li><strong>返回产品</strong>：调用它的build()方法返回产品。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuilderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建指挥者对象</span></span><br><span class="line">        <span class="type">HouseDirector</span> <span class="variable">houseDirector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseDirector</span>();</span><br><span class="line">        House house;</span><br><span class="line">        <span class="comment">// 2.用指挥者对象的setter方法设置建造者变量</span></span><br><span class="line">        houseDirector.setHouseBuilder(<span class="keyword">new</span> <span class="title class_">NormalRoomBuilder</span>());</span><br><span class="line">        <span class="comment">// 3.指挥者对象的build()方法获取产品</span></span><br><span class="line">        house = houseDirector.buildHouse();</span><br><span class="line">        <span class="comment">// 4.建造高楼</span></span><br><span class="line">        houseDirector.setHouseBuilder(<span class="keyword">new</span> <span class="title class_">HighRiseBuilder</span>());</span><br><span class="line">        house = houseDirector.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuilder-中的建造者模式"><a href="#StringBuilder-中的建造者模式" class="headerlink" title="StringBuilder 中的建造者模式"></a>StringBuilder 中的建造者模式</h2><h3 id="JDK源码中的建造者模式"><a href="#JDK源码中的建造者模式" class="headerlink" title="JDK源码中的建造者模式"></a>JDK源码中的建造者模式</h3><p>StringBuilder不是严格的建造者模式，但是使用了建造者模式思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK中，不止StringBuilder、StringBuffer使用了建造者模式，还有：stream流</span></span><br><span class="line"><span class="comment">// 1.过滤只保留长度为3的字符串，收集成List&lt;String&gt;类型</span></span><br><span class="line">List&lt;String&gt; ansList = list.stream().filter(item -&gt; item.length() == <span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 时间API</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><h3 id="角色分析"><a href="#角色分析" class="headerlink" title="角色分析"></a>角色分析</h3><h4 id="产品：char数组"><a href="#产品：char数组" class="headerlink" title="产品：char数组"></a>产品：char数组</h4><p>char数组，数组可以包含多个元素，每个元素是一个部件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">// The value is used for character storage.</span></span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象建造者：AbstractStringBuilder"><a href="#抽象建造者：AbstractStringBuilder" class="headerlink" title="抽象建造者：AbstractStringBuilder"></a>抽象建造者：AbstractStringBuilder</h4><p>AbstractStringBuilder包含append()、delete()等方法，用来对产品（字符数组）里的部件（数组内每个元素）进行追加和删除。</p><p><strong>部件组装方法</strong>：append() 、delete()</p><p>以append()为例：</p><p><strong>核心流程</strong>：</p><ol><li><strong>判空</strong>：如果传入的字符串为null，则不追加</li><li><strong>校验扩容</strong>：若新容量大于当前数组长度，则进行扩容</li><li><strong>拷贝数组</strong>：校验数组越界后，调用System.arraycopy()拷贝数组</li></ol><p><strong>具体代码</strong>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象建造者：简化版AbstractStringBuilder</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value; <span class="comment">// 产品：一个字符数组</span></span><br><span class="line">    <span class="type">int</span> count; <span class="comment">// 实际字符串长度</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品部件建造方法：追加字符串</span></span><br><span class="line"><span class="comment">     * 这个方法不一定必须是抽象方法，子类可以重写        </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> AbstractStringBuilder &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判空：如果传入的字符串为null，则不追加</span></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="comment">// 2.校验扩容：若新容量大于当前数组长度，则进行扩容</span></span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        <span class="comment">// 3.拷贝数组</span></span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        <span class="comment">// 调整字符串长度：给count变量加上追加字符串长度</span></span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩容底层数组，@param minimumCapacity 新容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否需要扩容，若新容量大于当前数组长度，则进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value = Arrays.copyOf(value, newCapacity(minimumCapacity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getChars</span><span class="params">(<span class="type">int</span> srcBegin, <span class="type">int</span> srcEnd, <span class="type">char</span> dst[], <span class="type">int</span> dstBegin)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查源开始索引是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查源结束索引是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(srcEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查开始索引是否大于结束索引</span></span><br><span class="line">        <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(srcEnd - srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用System.arraycopy复制字符</span></span><br><span class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体建造者：重写append-返回类型"><a href="#具体建造者：重写append-返回类型" class="headerlink" title="具体建造者：重写append()返回类型"></a>具体建造者：重写append()返回类型</h4><p><strong>StringBuilder</strong></p><p>具体建造者StringBuilder继承了AbstractStringBuilder，并重写了append()方法。</p><p>append()逻辑都是用父类的append()方法，主要重写的地方在于<strong>返回类型由父类AbstractStringBuilder改成了子类StringBuilder</strong></p><blockquote><p><strong>重写规则：</strong>重写时</p><ul><li><strong>返回类可以是原返回类的子类。</strong>例如工厂方法设计模式里，抽象工厂类的createObject()方法返回值是抽象产品类，具体工厂类的createObject()方法返回类是具体产品类</li><li>访问权限不能比其父类更为严格</li><li>抛出异常不能比父类更广泛</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体建造者：简化版StringBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span> <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 追加字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> java.lang.StringBuilder &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123; <span class="comment">// // 由AbstactStringBuilder重写成StringBuilder</span></span><br><span class="line">        <span class="built_in">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>StringBuffer</strong></p><p>相比StringBuilder的append()方法，主要修改了返回值，方法内第一步清空toStringCache变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体建造者：简化版StringBuffer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuffer</span> <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存上一次调用toString()方法返回的值。</span></span><br><span class="line"><span class="comment">     * 每当StringBuffer被修改时，这个缓存会被清除。</span></span><br><span class="line"><span class="comment">     * transient关键字表明此字段不会被序列化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">char</span>[] toStringCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 追加字符串</span></span><br><span class="line"><span class="comment">     *  1.重写加了synchronized关键字，保证线程安全</span></span><br><span class="line"><span class="comment">     *  2.返回类由AbstractStringBuilder改为StringBuffer</span></span><br><span class="line"><span class="comment">     *  3.方法内第一步清空toStringCache</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> java.lang.StringBuffer &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> java.lang.StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存上一次调用toString()方法返回的值，所以每次更新底层字符数组时，都需要清空；</span></span><br><span class="line">        toStringCache = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取实际字符串长度</span></span><br><span class="line"><span class="comment">     * StringBuffer线程安全的原因：有线程同步风险的方法都加了synchronized锁，锁的粒度是当前实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展：String、StringBuffer、Stringbuilder有什么区别</strong></p><blockquote><p>得分点：是否可变、复用率、效率、线程安全问题</p></blockquote><p><strong>标准回答</strong></p><p>**String:**不可变字符序列，效率低，但是复用率高、线程安全。</p><ul><li><strong>不可变</strong>：指String对象创建之后,直到这个对象销毁为止,对象中的字符序列都不能被改变。</li><li><strong>复用率高</strong>：指String类型对象创建出来后归常量池管，可以随时从常量池调用同一个String对象。StringBuffer和StringBuider在创建对象后一般要转化成String对象才调用。</li></ul><p><strong>StringBuffer和StringBuilder</strong>都是字符序列可变的字符串，方法也一样，有共同的父类AbstractStringBuilder。 </p><ul><li><strong>StringBuilder:<strong>可变字符序列、</strong>效率最高、线程不安全</strong></li><li><strong>StringBuffer:<strong>可变字符序列、效率较高(增删)、</strong>线程安全</strong></li></ul><p><strong>扩展：为什么StringBuffer是线程安全的</strong></p><p>点进源码后发现，有线程同步风险的方法（例如length()、append()、delete()等）都加了synchronized锁，锁的粒度是当前实例。</p><blockquote><p><strong>synchronized关键字作用于三个位置：</strong></p><ol><li>作用在静态方法上,则锁是当前类的Class对象。</li><li>作用在普通方法上,则锁是当前的实例（this）。</li><li>作用在代码块上,则需要在关键字后面的小括号里,显式指定锁对象，例如this、Xxx.class。</li></ol></blockquote><p><strong>为什么StringBuffer效率低？</strong></p><ol><li><strong>锁本身效率低</strong>：存在线程竞争时，加锁的代码块本身就比不加锁要慢很多，因为锁内的共享资源同一时刻只能一个线程访问。</li><li><strong>锁粒度大</strong>：锁的粒度是当前实例，直接给整个方法加synchronized，而不是具体需要在有同步风险的代码块上加锁，性能低。这个方法内部分共享资源可能是线程安全的，并不需要加锁。</li></ol><h4 id="指挥者：StringBuilder"><a href="#指挥者：StringBuilder" class="headerlink" title="指挥者：StringBuilder"></a>指挥者：StringBuilder</h4><p>StringBuilder和StringBuffer自身既是具体建造者，也是指挥者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 &lt;em&gt;Gang of Four&lt;/em&gt; (&lt;em&gt;GoF&lt;/em&gt;) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="system" scheme="https://southernfish.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>设计模式七大原则</title>
    <link href="https://southernfish.github.io/pages/java/java-design-pattern-principle/"/>
    <id>https://southernfish.github.io/pages/java/java-design-pattern-principle/</id>
    <published>2025-07-28T02:20:36.000Z</published>
    <updated>2025-09-17T07:51:48.707Z</updated>
    
    <content type="html"><![CDATA[<p>软件设计模式的七大核心原则包括‌<strong>单一职责原则、开闭原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则和合成复用原则</strong>‌，这些原则构成了面向对象设计的基石。</p><blockquote><p>参考原文：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130403757">设计模式——设计模式简介和七大原则</a></p></blockquote><h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><ol><li><p><strong>单一职责原则（Single Responsibility Principle）</strong></p><p>对类来说，即<strong>一个类应该只负责一项职责</strong>。对接口来说，接口设计要符合单一职责原则，粒度越小通用性就越好。</p></li><li><p><strong>开闭原则（Open Close Principle）</strong></p><p><em>对扩展开放，对修改关闭</em>。</p></li><li><p><strong>里氏代换原则（Liskov Substitution Principle）</strong></p><p>只有当衍生类可替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p></li><li><p><strong>依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个是开闭原则的基础，<em>对接口编程，依赖于抽象而不依赖于具体</em>。</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle）</strong></p><p>使用多个隔离的接口来降低耦合度。</p></li><li><p><strong>迪米特法则（最少知道原则）（Demeter Principle）</strong></p><p>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p><strong>合成复用原则（Composite Reuse Principle）</strong></p><p>原则是<em>尽量使用合成/聚合的方式，而不是使用继承</em>。<em>继承实际上破坏了类的封装性</em>，超类的方法可能会被子类修改。</p></li></ol><h2 id="单一职责原则（Single-Responsibility-Principle）"><a href="#单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（Single Responsibility Principle）"></a>单一职责原则（Single Responsibility Principle）</h2><p>对类来说，即一个类应该只负责一项职责。对接口来说，接口设计要符合单一职责原则，粒度越小通用性就越好。</p><blockquote><p>例如user表只负责存储用户相关的信息。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2</p></blockquote><p><strong>注意事项和细节</strong></p><ul><li><p>1）降低类的复杂度，一个类只负责一项职责</p></li><li><p>2）提高类的可读性，可维护性</p></li><li><p>3）降低变更引起的风险</p></li><li><p>4）通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；<strong>只有类中方法数量足够少</strong>，<strong>可以在方法级别保持单一职责原则</strong></p></li></ul><p><strong>案例：</strong></p><p><strong>方案1（违反单一原则）</strong>，方法内条件判断，区分情景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);vehicle.run(<span class="string">&quot;轮船&quot;</span>);vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;汽车&quot;</span>.equals(type)) &#123;</span><br><span class="line">            System.out.println(type + <span class="string">&quot;在公路上运行...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;轮船&quot;</span>.equals(type)) &#123;</span><br><span class="line">            System.out.println(type + <span class="string">&quot;在水面上运行...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;飞机&quot;</span>.equals(type)) &#123;</span><br><span class="line">            System.out.println(type + <span class="string">&quot;在天空上运行...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案2（单一职责）：</strong>不同类，区分情景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RoadVehicle</span> <span class="variable">roadVehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoadVehicle</span>();</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        <span class="type">WaterVehicle</span> <span class="variable">waterVehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaterVehicle</span>();</span><br><span class="line">        waterVehicle.run(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">        <span class="type">AirVehicle</span> <span class="variable">airVehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AirVehicle</span>();</span><br><span class="line">        airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遵守单一职责原则，但改动很大，即将类分解，同时修改客户端。改进：直接修改Vehicle类，改动的代码会比较少=&gt;方案3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoadVehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;在公路上运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaterVehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;在水面上运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AirVehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;在天空上运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案3（方法级别单一职责）：不同方法，区分情景：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle2</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vehicle2</span>();</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle.runWater(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">        vehicle.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有对原来的类做大的修改，只是增加方法。没有在类级别上遵守单一职责原则，但在方法级别上遵守单一职责</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;在公路上运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runWater</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;在水面上运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runAir</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;在天空上运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h2><p><strong>客户端不应该依赖它不需要的接口</strong>，即一个类对另一个类的依赖应该建立在最小的接口上。</p><p>接口隔离原则（Interface Segregation Principle，ISP）是SOLID中的一个设计原则，它定义为“客户端应该不被迫依赖于它不使用的方法”，即一个类不应该强制依赖它不需要的接口。</p><p>接口隔离原则的主要目标是<strong>将庞大而臃肿的接口拆分成更小、更具体的接口</strong>，以方便客户端根据需求选择其所需的特定接口。这样可以大幅度减少客户端对于不必要的接口的依赖，使系统更加灵活、可维护和易于扩展。</p><p><strong>典型案例</strong>：当我们需要使用一个接口时，通常是需要实现该<strong>接口</strong>的所有方法，但是实际上可能<strong>只需要用到部分方法</strong>。如果这个接口包含很多方法，就会造成实现类的代码冗余和依赖性过强。</p><p>通过<strong>合理的接口拆分和组合</strong>，可以使得接口更加精简，提高代码的<strong>复用性和可拓展性</strong>。同时，也有利于提高代码的<strong>可维护性</strong>，降低代码修改时的风险和维护成本。</p><p><strong>注意</strong>：接口是一种描述行为的抽象，而隔离的目的是为了让接口更好地描述抽象行为，而不是让接口的数量变得多而复杂。因此，我们需要在接口隔离时保持适度，并根据具体情况进行选择和拆分。</p><p><strong>违法隔离的代码：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同理实现 operation2，operation3，operation4，operation5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同理实现 operation2，operation3，operation4，operation5</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A类通过接口Interface1依赖（使用）B类，但是只会用到1，2，3方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend2</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend3</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C类通过接口Interface1依赖（使用）D类，但是只会用到1，4，5方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend4</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend5</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拆分接口后的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface2</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface3</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>, Interface2 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>, Interface3 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A类通过接口Interface1,Interface2依赖（使用）B类，但是只会用到1，2，3方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend2</span><span class="params">(Interface2 i)</span> &#123;</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend3</span><span class="params">(Interface2 i)</span> &#123;</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C类通过接口Interface1,Interface3依赖（使用）D类，但是只会用到1，4，5方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend4</span><span class="params">(Interface3 i)</span> &#123;</span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend5</span><span class="params">(Interface3 i)</span> &#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p><strong>高层模块不应该依赖低层模块，二者都应该依赖其抽象</strong>（接口或抽象类）</p></li><li><p>抽象不应该依赖细节，细节应该依赖抽象</p></li><li><p>依赖倒转（倒置）的中心思想是<strong>面向接口编程</strong></p></li><li><p>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，<strong>抽象的东西要稳定的多</strong>。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</p></li><li><p>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</p></li><li><p><strong>多态</strong>是实现依赖倒转原则的方法之一。</p></li></ul><p><strong>案例：</strong>用户类接收邮件、微信等信息。</p><p><strong>违反依赖倒转</strong>：引用具体而非抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果获取的对象是微信，短信等等，则新增类，同时 Peron也要增加相应的接收方法</span></span><br><span class="line"><span class="comment">// 解决思路：引入一个抽象的接口IReceiver，表示接收者，这样Person类与接口IReceiver发生依赖</span></span><br><span class="line"><span class="comment">// 因为Email，Weixin等等属于接收的范围，他们各自实现IReceiver接口就ok，这样我们就符号依赖倒转原则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息：Hello World！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(Email email)</span> &#123;</span><br><span class="line">        System.out.println(email.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进：多态的方式引用抽象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    String <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span> <span class="keyword">implements</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息：Hello World！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weixin</span> <span class="keyword">implements</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;微信消息：Hello World！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShortMessage</span> <span class="keyword">implements</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;短信信息：Hello World！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(IReceiver receiver)</span> &#123;</span><br><span class="line">        System.out.println(receiver.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖关系传递的三种方式"><a href="#依赖关系传递的三种方式" class="headerlink" title="依赖关系传递的三种方式"></a>依赖关系传递的三种方式</h3><ul><li><p><strong>低层模块尽量都要有抽象类或接口，</strong>或者两者都有，程序稳定性更好</p></li><li><p><strong>变量的声明类型尽量是抽象类或接口</strong>，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</p></li><li><p>继承时遵循里氏替换原则</p></li></ul><p><strong>开关电视的案例：</strong> </p><ol><li><p><strong>接口传递</strong>：ITV接口是IOpenAndClose接口的普通方法参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(ITV tv)</span>;    <span class="comment">// 抽象方法，接收接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ITV接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAndClose</span> <span class="keyword">implements</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(ITV tv)</span>&#123;</span><br><span class="line">        tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>构造方法传递</strong>： ITV接口是OpenAndClose类的成员变量和构造方法参数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ITV接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAndClose</span> <span class="keyword">implements</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ITV tv;                 <span class="comment">// 成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenAndClose</span><span class="params">(ITV tv)</span>&#123;     <span class="comment">// 构造器</span></span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>setter 方式传递</strong>：ITV接口是OpenAndClose类的成员变量和setter方法参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setTv</span><span class="params">(ITV tv)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ITV接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAndClose</span> <span class="keyword">implements</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ITV tv;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTv</span><span class="params">(ITV tv)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="里氏替换原则（Liskov-Substitution-Principle）"><a href="#里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle）"></a>里氏替换原则（Liskov Substitution Principle）</h2><p><strong>面对对象OO 中继承性的思考和说明</strong></p><ul><li><p>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果<strong>子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏</strong></p></li><li><p>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来<strong>侵入性</strong>，程序的可移植性降低，增加对象间的<strong>耦合性</strong>，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</p></li><li><p>问题提出：在编程中，如何正确使用继承？=&gt;里氏替换原则</p></li></ul><p><strong>基本介绍</strong></p><ul><li><p>在1988年，由麻省理工学院的以为姓里的女士提出</p></li><li><p><strong>父类型对象替换成子类型对象后功能未变：</strong>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象</p></li><li><p>在使用继承时，遵循里氏替换原则，在<strong>子类中尽量不要重写父类的方法</strong></p></li><li><p>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过<strong>聚合、组合、依赖</strong>来解决问题</p></li></ul><p><strong>案例：</strong></p><p><strong>传统方案：</strong>子类把父类的减方法重写为加方法：整个继承体系的复用性会比较差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;1-8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 增加了一个新功能：完成两个数相加，然后和9求和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> func1(num1, num2) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进方案：</strong>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合、组合等关系代替</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个更加基础的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// 将更基础的成员和方法写到Base类中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// 如果B需要使用A类的方法，使用组合关系</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加了一个新功能：完成两个数相加，然后和9求和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> func1(num1, num2) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func3</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a.func1(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开闭原则（Open-Closed-Principle）"><a href="#开闭原则（Open-Closed-Principle）" class="headerlink" title="开闭原则（Open Closed Principle）"></a>开闭原则（Open Closed Principle）</h2><p><strong>开：</strong>对扩展开放。</p><p><strong>闭：</strong> 对修改关闭。</p><ul><li><p>开闭原则是编程中<strong>最基础、最重要</strong>的设计原则</p></li><li><p>一个软件实体如类、模块和函数应该<strong>对扩展开放</strong>（对提供者而言），<strong>对修改关闭</strong>（对使用者而言）。<strong>用抽象构建框架，用实现扩展细节</strong>。增加了新功能后，原来使用的代码并没有做更改。</p></li><li><p>当软件需要变化时，尽量通过<strong>扩展</strong>软件实体的行为来实现变化，而<strong>不是通过修改</strong>已有的代码来实现变化。</p></li><li><p>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则</p></li></ul><p><strong>方案一：传统方案</strong>，一个画图形的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.m_type == <span class="number">1</span>) &#123;</span><br><span class="line">            drawRectangle(s);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>) &#123;</span><br><span class="line">            drawCircle(s);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>) &#123;</span><br><span class="line">            drawTriangle(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawTriangle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;三角形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleShape</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    RectangleShape() &#123;</span><br><span class="line">        m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleShape</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    CircleShape() &#123;</span><br><span class="line">        m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TriangleShape</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    TriangleShape() &#123;</span><br><span class="line">        m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>方式 1 的优缺点</strong></p><ul><li><p>优点是比较好理解，简单易操作</p></li><li><p>缺点是<strong>违反了</strong>设计模式的 OCP 原则，即<strong>对扩展开放</strong>（提供方），<strong>对修改关闭</strong>（使用方）。即当我们给类增加新功能的时喉，尽量不修改代码，或者尽可能少修改代码</p></li><li><p>比如要新增加一个图形种类，需要做如下修改，修改的地方较多4）代码演示</p></li></ul><p><strong>方式 1 的改进的思路分析</strong></p><p>把创建 Shape 类做成<strong>抽象类</strong>，并提供一个<strong>抽象的 draw 方法</strong>，让子类去实现即可</p><p>这样我们有新的图形种类时，只需要让新的图形类继承 Shape，并<strong>实现 draw 方法</strong>即可</p><p>使用方的代码就不需要修改，满足了<strong>开闭原则</strong></p></blockquote><p><strong>方式 2 开闭原则：</strong>画图功能设为基类的抽象方法，新增实现类只需要继承基类并实现画图的抽象方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;</span><br><span class="line">        s.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_type;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleShape</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    RectangleShape() &#123;</span><br><span class="line">        m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleShape</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    CircleShape() &#123;</span><br><span class="line">        m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TriangleShape</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    TriangleShape() &#123;</span><br><span class="line">        m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;三角形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迪米特法则（Demeter-Principle）"><a href="#迪米特法则（Demeter-Principle）" class="headerlink" title="迪米特法则（Demeter Principle）"></a>迪米特法则（Demeter Principle）</h2><p><strong>基本介绍</strong></p><ul><li><p>一个对象应该对其他对象保持最少的了解</p></li><li><p>类与类关系越密切，耦合度越大</p></li><li><p>迪米特法则又叫<strong>最少知道原则</strong>，即<strong>一个类对自己依赖的类知道的越少越好。</strong>也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息</p></li><li><p>迪米特法则还有个更简单的定义：<strong>只与直接的朋友通信</strong></p></li><li><p><strong>直接的朋友</strong>：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多：依赖、关联、组合、聚合等。其中，我们称<strong>出现成员变量，方法参数，方法返回值中的类为直接的朋友</strong>，而<strong>出现在局部变量中的类不是直接的朋友。</strong>也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p></li></ul><p><strong>注意事项和细节</strong></p><ul><li>主要A类里存在方法里B类是直接朋友，那么A类所有方法局部变量出现的B类都是直接朋友。</li><li>迪米特法则的核心是降低类之间的耦合</li><li><strong>注意</strong>：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系</li></ul><p><strong>传统方案：</strong>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总部员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 学院员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeEmployee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 学院员工管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();            <span class="comment">//是直接朋友</span></span><br><span class="line">        CollegeEmployee collegeEmployee;                        <span class="comment">// 是直接朋友</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            collegeEmployee = <span class="keyword">new</span> <span class="title class_">CollegeEmployee</span>();</span><br><span class="line">            collegeEmployee.setId(<span class="string">&quot;学院员工id=&quot;</span> + i);</span><br><span class="line">            list.add(collegeEmployee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 总部员工管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SchoolManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 仅出现成员变量，方法参数，方法返回值中的类为直接的朋友</span></span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();                <span class="comment">// Employee 是直接朋友，出现在返回值</span></span><br><span class="line">        Employee employee;                                        <span class="comment">// 是直接朋友</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            employee = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            employee.setId(<span class="string">&quot;总部员工id=&quot;</span> + i);</span><br><span class="line">            list.add(employee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAllEmployee</span><span class="params">(CollegeManager sub)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------学院员工--------------&quot;</span>);</span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();        <span class="comment">// 不是直接朋友，出现在局部变量</span></span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee collegeEmployee : list1) &#123;</span><br><span class="line">            System.out.println(collegeEmployee.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------总部员工-------------&quot;</span>);</span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="built_in">this</span>.getAllEmployee();</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : list2) &#123;</span><br><span class="line">            System.out.println(employee.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用实例改进</strong></p><ul><li><p>前面设计的问题在于 SchoolManager 中，CollegeEmployee 类并不是 SchoolManager 类的直接朋友（分析）</p></li><li><p>按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合</p></li><li><p>对代码按照迪米特法则进行改进，<strong>将局部对象变量封装进参数里。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学院员工管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();            <span class="comment">// 是直接朋友</span></span><br><span class="line">        CollegeEmployee collegeEmployee;                        <span class="comment">// 是直接朋友</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            collegeEmployee = <span class="keyword">new</span> <span class="title class_">CollegeEmployee</span>();</span><br><span class="line">            collegeEmployee.setId(<span class="string">&quot;学院员工id=&quot;</span> + i);</span><br><span class="line">            list.add(collegeEmployee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改进，新增方法，输出学院员工信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEmployee</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------学院员工--------------&quot;</span>);</span><br><span class="line">         <span class="comment">// CollegeEmployee是直接朋友，出现在上面getAllEmployee()方法的返回值</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = getAllEmployee();   </span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee collegeEmployee : list1) &#123;</span><br><span class="line">            System.out.println(collegeEmployee.getId());</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 总部员工管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SchoolManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 仅出现成员变量，方法参数，方法返回值中的类为直接的朋友</span></span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();            <span class="comment">// Employee 是直接朋友，出现在返回值</span></span><br><span class="line">        Employee employee;                                    <span class="comment">// 是直接朋友</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            employee = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            employee.setId(<span class="string">&quot;总部员工id=&quot;</span> + i);</span><br><span class="line">            list.add(employee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAllEmployee</span><span class="params">(CollegeManager sub)</span> &#123;</span><br><span class="line">        sub.printEmployee();                                <span class="comment">// 改进，降低耦合，不用非直接朋友。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------总部员工-------------&quot;</span>);</span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="built_in">this</span>.getAllEmployee();</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : list2) &#123;</span><br><span class="line">            System.out.println(employee.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a>合成复用原则（Composite Reuse Principle）</h2><p><strong>基本介绍</strong></p><p>原则是尽量使用<strong>合成/聚合</strong>的方式，而不是使用继承。也就是把需要用到的类作为本类的参数、成员变量、局部变量。</p><ul><li><strong>依赖</strong>（Dependency）<strong>：</strong>指的是<strong>一个对象使用另一个对象</strong>的情况。通常是在一个对象的方法中传入另一个对象作为参数，或者在方法中创建另一个对象的实例。依赖关系是一种“短暂”的引用关系，一旦不再需要依赖对象就可以释放掉。</li><li><strong>合成</strong>（Composition）：指的是两个或多个对象之间一种包含与被包含的关系。其中<strong>包含对象是整体，被包含对象是零部件</strong>，它们的生命周期是一致的，无法单独存在。例如，一辆汽车是由发动机、车轮、底盘等组成的，这些组成部分与它们组合成的整体汽车具有相同的生命周期。当整体消亡时，所有零部件也随之消亡。</li><li><strong>聚合</strong>（Aggregation）：指的是两个或多个对象之间一种包含与被包含的关系，<strong>被包含对象可以存在于多个包含对象之间</strong>。在聚合关系中，被包含对象可以独立于包含对象存在，生命周期也不一定相同。例如，大学是由系部、学院、图书馆等组成的，这些部分可以独立存在，而且它们也可以属于不同的大学。即使整个大学消亡，它们仍然可以存在。</li></ul><p>总之，依赖、合成和聚合是面向对象编程中描述对象关系的重要概念，它们有助于设计和实现具有良好扩展性和可维护性的应用程序。</p><p><strong>案例</strong></p><p>B类想用A类方法，如果直接继承，那么耦合性会提高，之后A类修改后B类也得跟着修改。</p><p><strong>解决办法：</strong></p><ul><li>把A类作为B类普通方法的形参；</li><li>把A类作为B类成员变量，用setter方法</li><li>B类的普通方法里创建A类的对象；</li></ul><h2 id="其他原则"><a href="#其他原则" class="headerlink" title="其他原则"></a>其他原则</h2><h3 id="DRY原则"><a href="#DRY原则" class="headerlink" title="DRY原则"></a>DRY原则</h3><p><strong>DRY原则</strong>（Don’t Repeat Yourself）：即不要写重复的代码。</p><p><strong>代码重复的三种情况：</strong></p><ul><li><p><strong>实现逻辑重复</strong>：多段代码实现了相同的逻辑。例如有两个方法，虽然变量名和方法名不一样，但实际逻辑一模一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUserToDatabase</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span> &amp;&amp; user.isValid()) &#123;</span><br><span class="line">        database.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAdminToDatabase</span><span class="params">(User admin)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (admin != <span class="literal">null</span> &amp;&amp; admin.isValid()) &#123;</span><br><span class="line">        database.save(admin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>功能语意重复</strong>：多段代码实现了相同的功能。例如有两个方法，一个是遍历集合，一个是stream流遍历集合，只是表现形式不一样，实际功能医院。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用两种方式计算同样的总和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateTotal</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> number : numbers) &#123;</span><br><span class="line">        sum += number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateSum</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(numbers).sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>代码执行重复</strong>：多处地方调用了相同的多段代码。例如完全不抽取方法，一个service方法几千行，很多重复的代码没抽取方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;Order started&quot;</span>);</span><br><span class="line">    <span class="comment">// other order processing code</span></span><br><span class="line">    log.info(<span class="string">&quot;Order started&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>解决方案：</strong></p><ul><li><strong>三层架构</strong>：开发过程中，我们把后端服务器Servlet拆分成三层，分别是web、service和dao，这也是程序员常提到的<strong>“Java味”</strong></li><li><strong>模块化</strong>：将项目按业务分成相互隔离的多模块，然后抽取出一个common模块让其他模块调用，降低耦合；</li><li><strong>满足单一职责</strong>：即一个类应该只负责一项职责、一个接口只实现一个功能。</li><li><strong>封装继承多态</strong>：抽取公用代码为新方法、使用继承的方式替代重复成员变量、方法的编写。</li><li><strong>模板等设计模式</strong>：将通用逻辑抽取成新方法。</li></ul><hr><h1 id="UML类图：统一建模语言"><a href="#UML类图：统一建模语言" class="headerlink" title="UML类图：统一建模语言"></a>UML类图：统一建模语言</h1><ul><li>UML—-Unified modeling language UML（<strong>统一建模语言</strong>），是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果</li><li>UML 本身是<strong>一套符号的规定</strong>，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等</li><li>使用 UML 来建模，常用的工具有 Rational Rose，也可以使用一些插件来建模</li></ul><p><strong>UML 类图</strong></p><ul><li><p>用于描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系</p></li><li><p>类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合</p></li></ul><h2 id="依赖（dependence）"><a href="#依赖（dependence）" class="headerlink" title="依赖（dependence）"></a>依赖（dependence）</h2><p>只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编译都通过不了。A用到B，那么A依赖B，即A——-&gt;B。</p><ul><li><p>类中用到了对方</p></li><li><p>类的成员属性</p></li><li><p>方法的返回类型</p></li><li><p>方法接收的参数类型</p></li><li><p>方法中使用到 </p></li></ul><h2 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a>泛化（Generalization）</h2><p>泛化关系实际上就是<strong>继承</strong>关系，它是依赖关系的特例。A继承B，那么A➞B。</p><h2 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h2><p>关联关系<strong>实际上就是类与类之间的联系</strong>，它是依赖关系的特例</p><p>关联具有导航性：即双向关系或单向关系<br>关系具有多重性：如“1”（表示有且仅有一个），“0…”（表示0个或者多个），“0，1”（表示0个或者一个），“n…m”（表示n到m个都可以），“m…*”（表示至少m个）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向一对一关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCard</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向一对一关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCard</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h2><p>聚合关系表示的是<strong>整体和部分的关系</strong>，<strong>整体与部分可以分开</strong>。聚合关系是关联关系的特例，所以它具有关联的导航性与多重性</p><p>B是A的未实例化成员变量，则B—◇A</p><p>如：一台电脑由键盘（keyboard）、显示器（monitor），鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：Mouse—◇Computer，Monitor—◇Computer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monitor</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mouse mouse;</span><br><span class="line">    <span class="keyword">private</span> Monitor monitor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMouse</span><span class="params">(Mouse mouse)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mouse = mouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMonitor</span><span class="params">(Monitor monitor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.monitor = monitor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h2><p>组合关系也是<strong>整体与部分的关系</strong>，但是<strong>整体与部分不可以分开</strong></p><p>B是A的实例化成员变量，则B&lt;—◇A</p><p>如果我们认为 Mouse、Monitor 和 Computer 是不可分离的，则升级为组合关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monitor</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Mouse</span> <span class="variable">mouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mouse</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Monitor</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monitor</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个案例，在程序中我们定义实体：Person 与 IDCard、Head，那么 Head 和 Person 就是组合，IDCard 和 Person 就是聚合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCard</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Head</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Head</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Head</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;软件设计模式的七大核心原则包括‌&lt;strong&gt;单一职责原则、开闭原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则和合成复用原则&lt;/strong&gt;‌，这些原则构成了面向对象设计的基石。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考原文：&lt;/p&gt;
&lt;p&gt;&lt;a hre</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="system" scheme="https://southernfish.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>设计模式介绍及简单实现</title>
    <link href="https://southernfish.github.io/pages/java/java-design-pattern/"/>
    <id>https://southernfish.github.io/pages/java/java-design-pattern/</id>
    <published>2025-07-28T01:26:36.000Z</published>
    <updated>2025-09-17T07:51:48.707Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130403757">设计模式——设计模式简介和七大原则</a></p><p><a href="https://mp.weixin.qq.com/s/DxPjhfI3Wn70ORK-Q3FrMQ">如何优雅的将设计模式运用到实际项目中去?</a></p><p>推荐文章：<a href="https://blog.csdn.net/qq_40991313/article/details/130435077">设计模式篇（2025版）</a></p></blockquote><h1 id="设计模式介绍"><a href="#设计模式介绍" class="headerlink" title="设计模式介绍"></a>设计模式介绍</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验。模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern）代表了最佳实践。</p></li><li><p>设计模式的本质提高软件的维护性、通用性和扩展性，并降低软件的复杂度</p></li><li><p>《<strong>Design Patterns - Elements of Reusable Object-Oriented Software</strong>》（设计模式 - 可复用的面向对象软件元素）是经典的书，该书首次提到了软件开发中设计模式的概念。作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design，合称 <strong>GOF（四人帮，全拼 Gang of Four）</strong></p></li><li><p>设计模式并不局限于某种语言，Java、PHP、C++ 都有设计模式</p></li></ol><h2 id="设计模式目的及核心思想"><a href="#设计模式目的及核心思想" class="headerlink" title="设计模式目的及核心思想"></a>设计模式目的及核心思想</h2><p><strong>重要性</strong>： </p><ol><li><p>设计模式是软件设计中普遍存在问题的解决方案。</p></li><li><p>便于项目开发完成后维护项目（可读性、规范性）、新增功能。</p></li><li><p>你在实际项目中使用过什么设计模式，怎么使用的？解决了什么问题？</p></li><li><p>项目的功能模块和框架里会使用设计模式。</p></li></ol><p><strong>设计模式目的</strong>：</p><p>编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战。</p><p>设计模式是为了让程序（软件），具有更好的</p><ol><li><p>可复用性（即：相同功能的代码，不用多次编写，也叫做代码重用性）</p></li><li><p>可读性（即：编程规范性，便于其他程序员的阅读和理解）</p></li><li><p>可扩展性（即：当需要增加新的功能时，非常的方便，也叫做可维护性）</p></li><li><p>可靠性（即：当我们增加新的功能后，对原来的功能没有影响）</p></li><li><p>使程序呈现高内聚，低耦合的特性</p></li></ol><p><strong>设计原则核心思想</strong></p><ul><li><p>1）找出应用中可能<strong>需要变化之处，把它们独立出来</strong>，不要和那些不需要变化的代码混在一起</p></li><li><p>2）针对<strong>接口编程</strong>，而不是针对实现编程</p></li><li><p>3）为了交互对象之间的<strong>松耦合</strong>设计而努力</p></li></ul><h2 id="设计模式分类（3类）"><a href="#设计模式分类（3类）" class="headerlink" title="设计模式分类（3类）"></a>设计模式分类（3类）</h2><h3 id="创建型模式（对象创建优化）"><a href="#创建型模式（对象创建优化）" class="headerlink" title="创建型模式（对象创建优化）"></a>创建型模式（对象创建优化）</h3><p><strong>创建型模式</strong>（Creational Patterns）：主要<strong>用于对象的创建</strong>，包括多个不同的模式，如工厂方法模式、抽象工厂模式、建造者模式、单例模式和原型模式等。这些模式都有助于降低系统耦合度，并提高代码的可重用性和可扩展性。</p><ol><li><strong>单例模式</strong><ul><li><strong>作用</strong>：确保类仅有一个实例（如数据库连接池），全局共享访问点。</li><li><strong>实现</strong>：双重检查锁（<code>volatile</code> + <code>synchronized</code>）或静态内部类。</li></ul></li><li><strong>工厂模式</strong><ul><li><strong>简单工厂</strong>：通过参数类型创建对象，<strong>将对象创建延迟到子类</strong>（如支付方式：支付宝/微信）。</li><li><strong>工厂方法</strong>：子类决定实例化逻辑（扩展性更强）。</li><li><strong>抽象工厂</strong>：创建相关对象族（如跨平台UI组件）。</li></ul></li></ol><blockquote><p>单例模式（Singleton Pattern）、工厂模式（Factory Pattern）、抽象工厂模式（Abstract Factory Pattern）</p><p>建造者模式（Builder Pattern）、原型模式（Prototype Pattern）</p></blockquote><h3 id="结构型模式（类-对象组合优化）"><a href="#结构型模式（类-对象组合优化）" class="headerlink" title="结构型模式（类/对象组合优化）"></a>结构型模式（类/对象组合优化）</h3><p><strong>结构型模式</strong>（Structural Patterns）：主要<strong>用于描述对象之间的组合关系</strong>，包括多个不同的模式，如“代理模式”、“适配器模式”、“桥接模式”、“装饰者模式”、“外观模式”、“享元模式”和“组合模式”等。这些模式可以帮助我们更好地设计程序结构，提高代码灵活性和可维护性。</p><ol><li><strong>适配器模式</strong><ul><li><strong>场景</strong>：兼容接口差异（如老式打印机接入新系统）；</li><li><strong>类型</strong>：类适配器（继承）或对象适配器（组合）。</li></ul></li><li><strong>装饰器模式</strong><ul><li><strong>动态扩展功能</strong>：替代继承避免类爆炸（如Java I/O流嵌套包装）。</li></ul></li><li><strong>代理模式</strong><ul><li><strong>控制访问</strong>：远程调用（RPC）、权限校验（Spring AOP切面)。</li></ul></li><li><strong>外观模式</strong><ul><li>提供一个<strong>统一的接口，用来访问子系统</strong>中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li></ul></li></ol><blockquote><p>适配器模式（Adapter Pattern）、装饰器模式（Decorator Pattern）、代理模式（Proxy Pattern）<br>外观模式（Facade Pattern）</p><p>桥接模式（Bridge Pattern）、过滤器模式（Filter、Criteria Pattern）、组合模式（Composite Pattern）<br>享元模式（Flyweight Pattern）</p></blockquote><h3 id="行为型模式（对象交互优化）"><a href="#行为型模式（对象交互优化）" class="headerlink" title="行为型模式（对象交互优化）"></a>行为型模式（对象交互优化）</h3><p><strong>行为型模式</strong>（Behavioral Patterns）：主要<strong>用于描述对象之间的通信和责任分配</strong>，包括多个不同的模式，如“策略模式”、“模板方法模式”、“观察者模式”、“迭代器模式”、“职责链模式”、“命令模式”、“访问者模式”、“备忘录模式”和“解释器模式”等。这些模式通常用于实现不同的算法、流程和通信方式，以实现系统的更高灵活性和可维护性。</p><ol><li><p><strong>策略模式</strong></p><ul><li><strong>算法封装</strong>：电商促销策略（满减/折扣）动态切换；</li><li><strong>实现</strong>：<code>Comparator</code>接口实现自定义排序。</li></ul></li><li><p><strong>观察者模式</strong></p><ul><li><strong>事件驱动</strong>：定义了<strong>对象之间的一对多的依赖</strong>，一对多状态通知（如配置中心变更推送）；</li><li><strong>工具</strong>：<code>java.util.Observable</code>。</li></ul></li><li><p><strong>责任链模式</strong></p><ul><li><strong>流程解耦</strong>：多级审批系统或过滤器链（如Servlet Filter）。</li></ul></li><li><p><strong>模版方法模式</strong>（Template Method）</p><ul><li>定义了一个算法的骨架，子类重写特定步骤中，模版方法使得<strong>子类可在不改变算法结构的情况下，重新定义算法的步骤</strong>，（如<code>JdbcTemplate</code>执行流程固定）。</li></ul></li><li><p><strong>状态模式</strong>（State）</p><ul><li>对象行为随内部状态改变（如订单状态机：待支付→已发货）‌，允许<strong>对象在内部状态改变时改变它的行为</strong>。</li></ul></li></ol><blockquote><p>策略模式（Strategy Pattern）、观察者模式（Observer Pattern）、责任链模式（Chain of Responsibility Pattern）<br>模板模式（Template Pattern）、状态模式（State Pattern）</p><p>命令模式（Command Pattern）、解释器模式（Interpreter Pattern）、迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）、备忘录模式（Memento Pattern）、空对象模式（Null Object Pattern）<br>访问者模式（Visitor Pattern）</p></blockquote><h3 id="J2EE-模式"><a href="#J2EE-模式" class="headerlink" title="J2EE 模式"></a>J2EE 模式</h3><p>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</p><blockquote><ul><li>MVC 模式（MVC Pattern）</li><li>业务代表模式（Business Delegate Pattern）</li><li>组合实体模式（Composite Entity Pattern）</li><li>数据访问对象模式（Data Access Object Pattern）</li><li>前端控制器模式（Front Controller Pattern）</li><li>拦截过滤器模式（Intercepting Filter Pattern）</li><li>服务定位器模式（Service Locator Pattern）</li><li>传输对象模式（Transfer Object Pattern）</li></ul></blockquote><h2 id="关键应用对照表"><a href="#关键应用对照表" class="headerlink" title="关键应用对照表"></a>关键应用对照表</h2><table><thead><tr><th>模式</th><th>典型应用场景</th><th>代表框架实现</th></tr></thead><tbody><tr><td><strong>单例</strong></td><td>配置管理器、线程池</td><td>Spring Bean默认作用域</td></tr><tr><td><strong>工厂方法</strong></td><td>Spring的<code>FactoryBean</code>接口</td><td><code>BeanFactory</code>实例化对象</td></tr><tr><td><strong>代理</strong></td><td>MyBatis的Mapper接口动态代理</td><td>JDK动态代理生成DAO对象</td></tr><tr><td><strong>观察者</strong></td><td>Spring的事件监听机制（<code>ApplicationEvent</code>）</td><td>配置更新广播</td></tr></tbody></table><h2 id="模式选择原则"><a href="#模式选择原则" class="headerlink" title="模式选择原则"></a>模式选择原则</h2><ul><li>创建对象复杂 → 工厂模式</li><li>扩展对象功能 → 装饰器/代理</li><li>算法灵活切换 → 策略模式</li><li>状态联动更新 → 观察者模式‌</li></ul><h2 id="三种工厂模式的应用场景"><a href="#三种工厂模式的应用场景" class="headerlink" title="三种工厂模式的应用场景"></a>三种工厂模式的应用场景</h2><table><thead><tr><th><strong>模式</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>简单工厂</strong></td><td>产品种类少且不常变化，客户端只需传入参数，无需关心创建逻辑。</td></tr><tr><td><strong>工厂方法</strong></td><td>需要灵活扩展新产品，且不同子类可能需要不同的创建逻辑。</td></tr><tr><td><strong>抽象工厂</strong></td><td>需要创建一组相关或依赖的对象（产品族），且系统需要支持多套产品配置。</td></tr></tbody></table><h2 id="设计模式遵循的原则"><a href="#设计模式遵循的原则" class="headerlink" title="设计模式遵循的原则"></a>设计模式遵循的原则</h2><ol><li><p><strong>单一职责原则（Single Responsibility Principle）</strong></p><p>对类来说，即<strong>一个类应该只负责一项职责</strong>。对接口来说，接口设计要符合单一职责原则，粒度越小通用性就越好。</p></li><li><p><strong>开闭原则（Open Close Principle）</strong></p><p><em>对扩展开放，对修改关闭</em>。</p></li><li><p><strong>里氏代换原则（Liskov Substitution Principle）</strong></p><p>只有当衍生类可替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p></li><li><p><strong>依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个是开闭原则的基础，<em>对接口编程，依赖于抽象而不依赖于具体</em>。</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle）</strong></p><p>使用多个隔离的接口来降低耦合度。</p></li><li><p><strong>迪米特法则（最少知道原则）（Demeter Principle）</strong></p><p>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p><strong>合成复用原则（Composite Reuse Principle）</strong></p><p>原则是<em>尽量使用合成/聚合的方式，而不是使用继承</em>。<em>继承实际上破坏了类的封装性</em>，超类的方法可能会被子类修改。</p></li></ol><hr><h1 id="设计模式简单实现模板"><a href="#设计模式简单实现模板" class="headerlink" title="设计模式简单实现模板"></a>设计模式简单实现模板</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>‌单例模式的核心应用场景包括<strong>资源管理、配置管理、日志记录、数据库连接池</strong>等需要全局唯一实例的场景‌。该模式通过确保类仅有一个实例并提供全局访问点，优化系统性能和资源利用率。‌‌‌‌</p><p><strong>核心应用场景</strong>‌</p><ol><li><p>‌<strong>资源管理优化</strong>‌<br>适用于需频繁创建和销毁的高成本资源（如数据库连接、线程池、硬件外设管理），通过共享唯一实例减少内存开销和性能损耗。‌‌‌‌ </p><ul><li><strong>数据库连接池</strong>：避免重复建立连接，提升数据库操作效率</li><li><strong>硬件外设管理</strong>：如SPI Flash、ADC模块的全局访问控制</li></ul></li><li><p><strong>全局状态一致性</strong><br>确保多线程或跨模块访问时数据同步，例如： </p><ul><li><strong>配置管理器</strong>：统一管理应用程序配置参数，防止状态不一致</li><li><strong>日志记录器</strong>：集中处理日志输出，便于跟踪和分析</li></ul></li><li><p><strong>性能敏感场景</strong>‌</p><ul><li><strong>缓存系统</strong>：全局唯一的缓存实例可避免重复加载数据</li><li><strong>游戏引擎核心组件</strong>：如资源管理器、纹理加载器等</li></ul></li></ol><ol start="4"><li><p><strong>其他典型场景</strong>‌</p><ul><li><p><strong>操作系统服务</strong>‌：如任务管理器、回收站等需唯一实例的系统组件</p></li><li><p><strong>ID生成器/计数器‌</strong>：生成唯一序列时防止多实例导致冲突</p></li><li><p><strong>跨进程共享对象</strong>‌：如.NET框架中的远程单例对象</p></li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式（静态内部类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个静态内部类，该类中有一个静态属性Singleton</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>通过一个工厂类，根据传入的参数动态决定创建哪种具体产品类的实例。<br><strong>核心</strong>：将对象的创建逻辑集中在一个类中</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>产品种类较少且固定；客户端不需要关心对象创建细节。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>场景</strong>：用户支付场景，目前支持支付宝支付和微信支付，未来会新增银行卡，云闪付等方式。使用策略模式，每一种支付方式都是一种策略，根据用户传入的支付类型，创建不同的策略类，使用工厂模式，通过封装一个<code>PaymentStrategyHandler</code>策略处理类，其他系统直接通过一个统一的入口，进行该功能的调用，使用门面模式。</p><ol><li><p><strong>定义一个策略类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPayment</span> &#123;</span><br><span class="line">    Boolean <span class="title function_">pay</span><span class="params">(PaymentBody paymentBody)</span>; <span class="comment">// 支付</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliPay</span> <span class="keyword">implements</span> <span class="title class_">IPayment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">pay</span><span class="params">(PaymentBody paymentBody)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;支付宝支付...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatPay</span> <span class="keyword">implements</span> <span class="title class_">IPayment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">pay</span><span class="params">(PaymentBody paymentBody)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;微信支付...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionPay</span> <span class="keyword">implements</span> <span class="title class_">IPayment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">pay</span><span class="params">(PaymentBody paymentBody)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;银联支付...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建策略工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.EnumUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.ReflectUtil;</span><br><span class="line"><span class="keyword">import</span> com.universal.core.designPatterns.enums.PayStrategyEnum;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Factory for payment methods</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IPayment <span class="title function_">getPayStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.通过枚举中的type获取对应的value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> EnumUtil.getFieldBy(PayStrategyEnum::getValue, PayStrategyEnum::getType, type);</span><br><span class="line">        <span class="comment">// 2.使用反射机制创建对应的策略类</span></span><br><span class="line">        <span class="type">IPayment</span> <span class="variable">payment</span> <span class="operator">=</span> ReflectUtil.newInstance(value);</span><br><span class="line">        <span class="keyword">return</span> payment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义策略枚举</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付策略枚举</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PayStrategyEnum</span> &#123;</span><br><span class="line">    ZFB(<span class="string">&quot;ZFB&quot;</span>, <span class="string">&quot;com.universal.core.designPatterns.factory.impl.AliPay&quot;</span>),</span><br><span class="line">    WX(<span class="string">&quot;WX&quot;</span>, <span class="string">&quot;com.universal.core.designPatterns.factory.impl.WechatPay&quot;</span>),</span><br><span class="line">    UNION(<span class="string">&quot;UNION&quot;</span>, <span class="string">&quot;com.universal.core.designPatterns.factory.impl.UnionPay&quot;</span>);</span><br><span class="line">    String type;</span><br><span class="line">    String value;</span><br><span class="line">    </span><br><span class="line">    PayStrategyEnum(String type, String value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建策略的上下文角色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentContext</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IPayment paymentStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PaymentContext</span><span class="params">(IPayment paymentStrategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentStrategy = paymentStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">pay</span><span class="params">(PaymentBody paymentBody)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.paymentStrategy.pay(paymentBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>提供统一访问处理入口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.EnumUtil;</span><br><span class="line"><span class="keyword">import</span> com.universal.core.designPatterns.enums.PayStrategyEnum;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentStrategyHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">pay</span><span class="params">(PaymentBody payBody)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!EnumUtil.contains(PayStrategyEnum.class, payBody.getType())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;不支持的支付方式!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.获取支付策略对象</span></span><br><span class="line">        <span class="type">IPayment</span> <span class="variable">payStrategy</span> <span class="operator">=</span> PaymentFactory.getPayStrategy(payBody.getType());</span><br><span class="line">        <span class="comment">// 2.获取支付策略上下文</span></span><br><span class="line">        <span class="type">PaymentContext</span> <span class="variable">paymentContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaymentContext</span>(payStrategy);</span><br><span class="line">        <span class="comment">// 3.进行支付</span></span><br><span class="line">        <span class="keyword">return</span> paymentContext.pay(payBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建Controller</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/designPatterns&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesignPatternController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/pay&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">pay</span><span class="params">(<span class="meta">@RequestBody</span> PaymentBody paymentBody)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PaymentStrategyHandler.pay(paymentBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="与简单工厂的区别"><a href="#与简单工厂的区别" class="headerlink" title="与简单工厂的区别"></a>与简单工厂的区别</h3><p>简单工厂模式的最大优点在于包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，相对于客户端来说，去除了与具体产品的依赖。</p><ul><li> <strong>简单工厂：</strong>用来<strong>生产同一等级结构中的任意产品</strong>，对于增加新的产品，无能为力。    </li><li> <strong>工厂方法：</strong>用来<strong>生产同一等级结构中的固定产品</strong>，支持增加任意产品。</li></ul><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>产品种类可能动态扩展；需要将对象创建逻辑分散到不同子类中</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p><code>工厂方法模式（Factory Method）</code>，定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法是一个类的实例化延迟到其子类，通俗来说：它提供了一种实例化逻辑委托子类的方法。<strong>代码示例：</strong></p><ol><li><p><strong>定义<code>NetworkConfigFactoryService</code>工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.universal.core.designPatterns.factoryMethod.NetworkConfigCrudService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NetworkConfigFactoryService</span> &#123;</span><br><span class="line">    <span class="comment">// 获取指定的处理逻辑类</span></span><br><span class="line">    <span class="comment">// @param productType</span></span><br><span class="line">    NetworkConfigCrudService <span class="title function_">getSpecificService</span><span class="params">(String productType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>NetworkConfigFactoryService</code>工厂实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetworkConfigFactoryServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">NetworkConfigFactoryService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AServiceImpl aService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BServiceImpl bService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CServiceImpl cService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DServiceImpl dService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> NetworkConfigCrudService <span class="title function_">getSpecificService</span><span class="params">(String productType)</span> &#123;</span><br><span class="line">        <span class="type">NetworkConfigCrudService</span> <span class="variable">networkConfigCrudService</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (productType)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>: networkConfigCrudService = aService; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>: networkConfigCrudService = bService; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>: networkConfigCrudService = cService; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;D&quot;</span>: networkConfigCrudService = dService; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> networkConfigCrudService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义网点操作接口<code>NetworkConfigCrudService</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NetworkConfigCrudService</span> &#123;</span><br><span class="line">    NetworkConfigVO <span class="title function_">getNetwork</span><span class="params">(NetworkConfigDTO networkConfigDTO)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现类分别是 <code>AServiceImpl</code>、<code>BServiceImpl</code>、<code>CServiceImpl</code>、<code>DServiceImpl</code>，分别对应不同的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">NetworkConfigCrudService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> NetworkConfigVO <span class="title function_">getNetwork</span><span class="params">(NetworkConfigDTO networkConfigDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NetworkConfigVO</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">NetworkConfigCrudService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> NetworkConfigVO <span class="title function_">getNetwork</span><span class="params">(NetworkConfigDTO networkConfigDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NetworkConfigVO</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">NetworkConfigCrudService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> NetworkConfigVO <span class="title function_">getNetwork</span><span class="params">(NetworkConfigDTO networkConfigDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NetworkConfigVO</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">NetworkConfigCrudService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> NetworkConfigVO <span class="title function_">getNetwork</span><span class="params">(NetworkConfigDTO networkConfigDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NetworkConfigVO</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>控制层NetworkConfigController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/networkConfig&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetworkConfigController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NetworkConfigFactoryService factoryService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/getNetworkDetails&quot;, produces = MediaType.APPLICATION_JSON_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult&lt;NetworkConfigVO&gt; <span class="title function_">getNetworkDetails</span><span class="params">(<span class="meta">@RequestBody</span> NetworkConfigDTO networkConfigDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取AService处理类逻辑</span></span><br><span class="line">        <span class="type">NetworkConfigCrudService</span> <span class="variable">aService</span> <span class="operator">=</span> factoryService.getSpecificService(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">NetworkConfigVO</span> <span class="variable">network</span> <span class="operator">=</span> aService.getNetwork(networkConfigDTO);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.success(network);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>定义 提供一个接口，用于创建相关或依赖对象家族，而无需指定具体类。<br><strong>核心</strong>：生产多个产品族（如不同操作系统下的UI组件）</p><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p> 需要创建多个相互关联的产品（如不同主题的UI组件、跨平台适配）；系统需要独立于产品的创建和组合过程</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义产品族接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体产品族实现（Windows风格）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Windows风格按钮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Windows风格文本框&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 具体产品族实现（MacOS风格）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacOSButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MacOS风格按钮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacOSTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MacOS风格文本框&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 抽象工厂接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line">    TextField <span class="title function_">createTextField</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 具体工厂实现-windows</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 具体工厂实现（MacOS风格）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacOSFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacOSButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacOSTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 客户端调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GUIFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacOSFactory</span>();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> factory.createButton();</span><br><span class="line">        <span class="type">TextField</span> <span class="variable">textField</span> <span class="operator">=</span> factory.createTextField();</span><br><span class="line">        button.render();           <span class="comment">// 输出：MacOS风格按钮</span></span><br><span class="line">        textField.display();    <span class="comment">// 输出：MacOS风格文本框</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><strong><code>适配器模式Adapter</code></strong> 是将一个接口转换成另一个客户所期望的接口。**<code>Adapter</code>** 适配器让那些本来因为接口不兼容的类可以合作无间。</p><p><a href="https://blog.csdn.net/weixin_43718423/article/details/148005751">Spring 框架中适配器模式的五大典型应用场景</a></p><h3 id="适配器模式的角色分析"><a href="#适配器模式的角色分析" class="headerlink" title="适配器模式的角色分析"></a>适配器模式的角色分析</h3><ul><li><strong>目标接口（Traget）</strong>：客户期待的接口，目标可以是具体的或者抽象的类，也可以是接口。</li><li><strong>需要适配的对象（Source Adaptee）</strong>：需要适配的对象。</li><li><strong>适配器（Adapter）</strong>：通过包装一个需要适配的对象，把原接口转成目标接口。</li></ul><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>Java适配器模式在实际开发中主要应用于<strong>系统整合、接口兼容和功能扩展</strong>三大场景，通过对象适配器和类适配器两种方式实现接口转换。</p><p><strong>典型应用场景</strong></p><ol><li><p><strong>系统整合场景</strong>。 将旧系统的接口适配到新系统（如日志框架转换）。 <strong>示例</strong>：</p><ul><li>通过<code>FileLoggerAdapter</code>将基于文件的日志写入适配到数据库日志接口。</li><li><strong>企业级应用</strong>：整合遗留系统接口与企业中台规范。</li></ul></li><li><p><strong>接口兼容场景</strong>。 多线程开发中将<code>Callable</code>适配为Runnable接口。 <strong>示例</strong>：</p><ul><li><code>RunnableAdapter</code>转发Callable任务给Thread执行。</li><li><strong>JDK应用</strong>：<code>InputStreamReader</code>将字节流适配为字符流。</li></ul></li><li><p><strong>功能扩展场景</strong>。 多媒体播放器扩展播放格式。 <strong>示例</strong>：</p><ul><li><code>MediaPlayer</code>适配<code>AdvancedMediaPlayer</code>实现<code>mp4/vlc</code>播放支持</li><li><strong>Android开发</strong>：<code>BaseAdapter</code>统一<code>ListView</code>与不同类型数据源的交互。</li></ul></li></ol><p><strong>实现方式对比</strong></p><ol><li><strong>对象适配器</strong>（推荐）。 通过组合持有被适配对象实例。 <strong>优势</strong>：支持多态、适配器可复用、避免单继承限制。  </li><li><strong>类适配器</strong>。 通过继承实现接口转换。 <strong>局限</strong>：单继承限制、无法适配多个类。 <strong>示例</strong>：<ul><li><code>ExpensiveAdapter</code>继承<code>HuaweiPhone</code>实现Player接口。</li></ul></li></ol><p><strong>最佳实践原则</strong></p><ol><li><strong>接口设计规范</strong>。 目标接口保持最小化定义。 适配器类命名遵循<code>XxxAdapter</code>格式。</li><li><strong>组合优于继承</strong>。 对象适配器比例达<code>85%</code>以上（Java设计规范推荐）。组合方式降低耦合度，支持动态替换适配对象。</li><li><strong>异常处理机制</strong>。 在适配器中处理被适配对象的异常。 示例：<ul><li><code>RunnableAdapter</code>捕获Callable异常并转换为运行时异常。</li></ul></li></ol><h3 id="类适配器代码实现"><a href="#类适配器代码实现" class="headerlink" title="类适配器代码实现"></a>类适配器代码实现</h3><p><strong>场景</strong>：以网线上网为例，现在有一根水晶头网线，但它的接口与电脑的不匹配（因为电脑的是<code>usb</code>或者<code>typec</code>），那就需要一个转接头，也就是适配器，才能上网，下面的转接头可理解为适配器：</p><ol><li><p>我们拥有一根网线, 其有上网的功能，但是它的接口与电脑不匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要适配的类：网线</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;                    <span class="comment">// 功能：上网</span></span><br><span class="line">        System.out.println(<span class="string">&quot;链接网线上网&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个<code>usb</code>接口，也就是目标接口（Target）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口转换器的抽象实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NetToUsb</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span>;            <span class="comment">// 作用：处理请求，网线 =&gt; usb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个适配器继承着网线，连接着<code>usb</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正的适配器，余姚链接usb,连接网线</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">NetToUsb</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.request();                    <span class="comment">// 可以上网了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上网的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端类：想上网，插不上网线</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="comment">// 电脑需要连接上转接器才可以上网</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">net</span><span class="params">(NetToUsb adapter)</span>&#123;</span><br><span class="line">        adapter.handleRequest();             <span class="comment">// 上网的具体实现：找一个转接头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 电脑，适配器，网线</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(); <span class="comment">// 电脑</span></span><br><span class="line">        <span class="type">Adapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>();    <span class="comment">// 转接器</span></span><br><span class="line">        computer.net(adapter);              <span class="comment">// 电脑直接连接转接器就可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="对象适配器应用"><a href="#对象适配器应用" class="headerlink" title="对象适配器应用"></a>对象适配器应用</h3><ul><li>java.util.Arrays#asList()open in new window</li><li>java.util.Collections#list()open in new window</li><li>java.util.Collections#enumeration()open in new window</li><li>javax.xml.bind.annotation.adapters.XMLAdapter</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>**<code>代理模式Proxy</code>**，为其他对象提供一种代理以控制对这个对象的访问。</p><h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><p>‌代理模式的核心使用场景包括<strong>访问控制、功能扩展和对象隔离</strong>三大类‌，具体可分为<strong>远程访问优化、资源延迟加载、权限管理、性能增强</strong>等典型应用场景。‌</p><p><strong>远程服务访问</strong>‌</p><ol><li><p>‌<strong>远程代理</strong>‌：解决跨网络对象调用问题，客户端通过本地代理对象访问远程服务端资源。典型应用包括： </p><ul><li>分布式系统中的<code>RPC</code>调用（如<code>Dubbo</code>框架）</li><li>数据库连接池管理</li><li><code>CORBA</code>远程对象调用</li></ul></li></ol><p><strong>资源访问控制</strong>‌</p><ol><li><p>‌<strong>保护代理</strong>‌：通过权限过滤实现访问控制，包含两种实现维度： </p><ul><li><p><strong>身份认证代理</strong>：控制特定用户/角色的操作权限（如<code>OA</code>系统审批接口代理）</p></li><li><p><strong>防火墙代理</strong>：过滤非法请求（如<code>Web</code>应用防火墙）</p></li></ul></li><li><p><strong>虚拟代理</strong>‌：优化高开销对象的使用效率： </p><ul><li>大型文件加载时显示缩略图（如图库管理系统）</li><li>延迟加载数据库连接（如<code>MyBatis</code>延迟加载）</li><li>视频流分片加载（如在线视频网站）</li></ul></li></ol><p><strong>系统功能增强</strong>‌</p><ol><li><p>‌<strong>智能代理</strong>‌：在方法调用前后插入扩展逻辑： </p><ul><li>日志记录代理（记录<code>API</code>调用信息）</li></ul></li></ol><ul><li>事务管理代理（<code>Spring</code>声明式事务）<ul><li>缓存代理（<code>MyBatis</code>二级缓存机制）</li></ul></li></ul><ol start="2"><li><p><strong>适配代理</strong>‌：解决接口兼容性问题： </p><ul><li>API版本适配（如新旧支付接口兼容）</li><li>协议转换（如<code>HTTP</code>转<code>WebSocket</code>）</li><li>数据格式转换（<code>XML</code>与<code>JSON</code>互转）</li></ul></li></ol><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>代理模式</strong> 实际上在平时中也运用的非常广泛，最经典的例子就是<code>房东委托中介代理出租房子</code>的案例。</p><ol><li><p>创建一个Subject类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 活动类，目的是出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span>; <span class="comment">// 租房接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个房东角色，现在活动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 房东</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseOwner</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">// 实现租房方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东成功出租了房子...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个中介代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中介代理类</span></span><br><span class="line"><span class="comment">// 一般情况下我们不能直接联系到房东，所以需要提供一个代理类，即中介类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseProxy</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">HouseOwner</span> <span class="variable">houseOwner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseOwner</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中介收取代理费，帮助房东出租房子...&quot;</span>);</span><br><span class="line">        houseOwner.rentHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟用户找中介租房子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span>&#123;</span><br><span class="line">    <span class="type">HouseProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseProxy</span>();</span><br><span class="line">    proxy.rentHouse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><p>策略模式的核心应用场景聚焦于需要<strong>动态选择算法或业务规则</strong>的场景‌，主要适用于<strong>算法切换、支付方式选择、会员折扣系统、订单处理逻辑和游戏AI行为</strong>等需要灵活扩展的业务场景。‌‌</p><p><strong>策略模式的典型应用场景</strong>‌：策略模式通过<strong>封装算法族并实现运行时动态切换</strong>，有效解决了复杂条件判断和频繁扩展需求的问题‌。以下是其核心应用领域： </p><ol><li><p>‌<strong>算法动态切换场景</strong>‌</p><p>排序算法选择（快速排序、归并排序）。‌‌</p><p>文件压缩格式切换（<code>ZIP</code>、<code>RAR</code>、<code>7z</code>）。‌‌</p><p>加密算法适配（<code>AES</code>、<code>RSA</code>、<code>MD5</code>）。‌‌</p><p>日志输出方式配置（文件存储、网络传输、控制台输出）。‌‌</p></li><li><p><strong>电商领域高频应用</strong>‌</p><p>支付方式选择（信用卡、支付宝、微信支付），通过策略接口统一调用不同支付通道。‌‌‌‌</p><p>折扣策略配置（满减、折扣券、会员价），支持促销活动的快速迭代。‌‌</p><p>订单类型处理（普通订单、团购订单、促销订单），替代多层级if-else判断逻辑。‌‌</p></li><li><p><strong>系统行为动态调整</strong>‌</p><p>游戏AI策略切换（进攻型、防御型、逃跑型行为模式）。‌‌</p><p>交通出行方式计算（飞机、火车、自驾的成本与时间策略）。‌‌</p><p>影院售票系统（学生折扣、儿童减免、VIP积分等差异化策略）。‌‌</p></li><li><p><strong>策略模式的使用优势</strong></p><p><strong>扩展性</strong>‌：新增策略只需实现接口，无需修改上下文逻辑。‌‌</p><p><strong>解耦性</strong>‌：算法实现与使用逻辑分离，符合开闭原则。‌‌</p><p><strong>可维护性</strong>‌：消除大规模条件判断，代码结构更清晰。‌‌</p></li></ol><h3 id="基本实现步骤"><a href="#基本实现步骤" class="headerlink" title="基本实现步骤"></a>基本实现步骤</h3><p><strong>场景</strong>: 商场搞活动，根据客户购买商品的金额，收费时给与不同的打折，比如，购买 <strong>金额&gt;=2000</strong> 的打八折(0.8)，金额 <strong>500 ~ 1000</strong> 的，打九折(0.9)，购买金额 <strong>0 ~ 500</strong> 的九五折(0.95)，根据不同的金额走不同计算策略逻辑。</p><ol><li><p>定义一个<code>Strategy接口</code>来表示一个策略</p><p>其中<code>strategy</code>方法返回当前策略的唯一标识，<code>algorithm</code>则是该策略的具体执行的计算逻辑。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    String <span class="title function_">strategy</span><span class="params">()</span>; <span class="comment">// 采用策略</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span>; <span class="comment">// 计算方法逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义几个是<code>Strategy接口</code>的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">strategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StrategySelector.strategyA.getStrategy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;process with strategyA...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">strategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StrategySelector.strategyB.getStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;process with strategyB...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">strategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StrategySelector.strategyC.getStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;process with strategyC...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义策略选择枚举 <strong>StrategySelector</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">StrategySelector</span> &#123;</span><br><span class="line">    strategyA(<span class="number">1</span>,<span class="string">&quot;strategyA&quot;</span>),</span><br><span class="line">    strategyB(<span class="number">2</span>,<span class="string">&quot;strategyB&quot;</span>),</span><br><span class="line">    strategyC(<span class="number">3</span>,<span class="string">&quot;strategyC&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String strategy;</span><br><span class="line"></span><br><span class="line">    StrategySelector(Integer code, String strategy) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个<code>StrategyRunner接口</code>用来表示策略的调度器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StrategyRunner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String strategy)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>execute</code>方法内部通过判断<code>strategy</code>的值来决定具体执行哪一个策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyRunnerImpl</span> <span class="keyword">implements</span> <span class="title class_">StrategyRunner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Strategy&gt; STRATEGIES = </span><br><span class="line">        Arrays.asList(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>(), <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>(), <span class="keyword">new</span> <span class="title class_">ConcreteStrategyC</span>());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Strategy&gt; STRATEGY_MAP = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        STRATEGY_MAP = STRATEGIES.stream().collect(Collectors.toMap(Strategy::strategy, s -&gt; s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String strategy)</span> &#123;</span><br><span class="line">        STRATEGY_MAP.get(strategy).algorithm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>StrategyRunnerImpl</code>内部，定义了一个<code>STRATEGIES</code>列表来保存所有<code>Strategy</code>实现类的实例，以及一个叫做<code>STRATEGY_MAP</code>的Map来保存<code>strategy</code>和<code>Strategy实例</code>之间的对应关系，<code>static块</code>中的代码用于从<code>STRATEGIES</code>列表构造<code>STRATEGY_MAP</code>。这样，在execute方法中就可以很方便地获取到指定 strategy 的 Strategy 实例。</p></li></ol><h3 id="实现并运用策略模式"><a href="#实现并运用策略模式" class="headerlink" title="实现并运用策略模式"></a>实现并运用策略模式</h3><ol><li><p>定义一个<code>Strategy接口</code>来表示一个策略，再定义几个是<code>Strategy接口</code>的实现类，同上【1 - 2】步骤，注意需要在自定义<code>Strategy实现类</code>上标注<code>@Component</code>注解以将其注册进容器。</p></li><li><p>定义一个<code>StrategyConfig</code>配置类，用于向容器注入一个<code>StrategyRunner</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> StrategyRunner <span class="title function_">runner</span><span class="params">(List&lt;Strategy&gt; strategies)</span> &#123;</span><br><span class="line">        Map&lt;String, Strategy&gt; strategyMap = </span><br><span class="line">            strategies.stream().collect(Collectors.toMap(Strategy::strategy, s -&gt; s));</span><br><span class="line">        <span class="keyword">return</span> flag -&gt; strategyMap.get(flag).algorithm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>strategyRunner</code>方法的实现，逻辑与<code>StrategyRunnerImpl</code>几乎完全相同，也是根据一个<code>List&lt;Strategy&gt;</code>来构造一个<code>Map&lt;String, Strategy&gt;</code>。不过，这里的<code>strategies列表</code>是通过方法参数传进来的。由于<code>strategyRunner</code>标注了<code>Bean注解</code>，因此参数上的<code>List&lt;Strategy&gt;</code>实际上是在Spring Boot初始化过程中<strong>从容器获取的</strong>，所以我们之前向容器中注册的那两个实现类会在这里被注入。 这样就不必关注系统中<code>Strategy实现类</code>的具体个数，因为Spring Boot的自动配置会帮我们自动发现所有实现类。</p></li><li><p>在任何需要的地方注入<code>StrategyRunner</code>，直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/designPatterns&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesignPatternController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StrategyRunner strategyRunner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/algorithm&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="meta">@RequestParam(&quot;strategy&quot;)</span> String strategy)</span> &#123;</span><br><span class="line">        strategyRunner.execute(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问接口，控制台输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process with strategyA...</span><br></pre></td></tr></table></figure></li></ol><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p><strong><code>观察者模式Observer</code></strong> 定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p><p><em>初识观察者模式：报社+订阅者 = 观察者模式。</em></p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li>观察者模式定义了对象之间一对多的关系。</li><li>主题（可观察者）用一个共同的接口来更新观察者。</li><li>观察者和可观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</li><li>使用次模式时，你可以从被观察者处推或拉数据（推的方式被认为是更正确的）。</li><li>有多个观察者时，不可以依赖特定的通知次序。</li><li><code>java</code>中有多种观察者模式的实现，包括了通用的<code>java.util.Observable</code>，不过需要注意<code>Observable</code>实现上所带来的问题，有必要的话，可以实现自己的<code>Observable</code>。</li><li><code>Spring</code>也大量使用观察者模，比如<code>ListenrEvent</code>消息订阅与发布;</li></ul><h3 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><p><strong>GUI 事件处理</strong><br><code>场景</code>：用户界面组件（如按钮、输入框）的状态变化需要触发多个事件监听器<br><code>案例</code>：</p><ul><li><p>点击按钮后，触发日志记录、界面更新、数据提交等多个操作</p></li><li><p>输入框内容变化时，实时校验输入合法性并更新提示信息</p></li><li><p>框架应用：<code>Java Swing</code>、Android 的 <code>OnClickListener</code>、JavaScript 的<code>addEventListener</code></p></li></ul></li><li><p><strong>实时数据同步</strong><br><strong>场景</strong>：数据源的变更需要实时同步到多个客户端或组件。<strong>案例</strong>：</p><ul><li><strong>股票行情系统</strong>：股价变动时，所有关注的投资者界面自动刷新</li><li><strong>在线协作工具</strong>（如 <code>Google Docs</code>）：一个用户编辑内容，其他用户的视图实时更新</li><li><strong>前端框架</strong>（如 <code>Vue、React</code>）的数据绑定：数据变化驱动视图渲染</li><li>一个主界面由几个子界面垂直布局组成， 数据源变更，子界面数据将实时变化（页面还有几个一级标题页面，为了解耦和代码管理按照标题差分类结构）</li></ul></li><li><p><strong>状态监控与报警</strong><br><strong>场景</strong>：监控系统状态变化，并触发相关响应（如日志、报警、资源调整）。<strong>案例</strong>：</p><ul><li><p>服务器 CPU 使用率超过阈值时，触发邮件报警、记录日志、自动扩容</p></li><li><p>物联网设备（如传感器）数据异常时，通知用户和管理系统</p></li></ul></li><li><p><strong>游戏开发中的事件系统</strong><br><strong>场景</strong>：游戏内事件（如角色死亡、任务完成）需要触发多模块响应。<strong>案例</strong>：</p><ul><li><p>玩家生命值降为 0 时，触发 UI 更新死亡动画、保存进度、播放音效</p></li><li><p><strong>成就系统</strong>：当玩家达成特定条件（如击杀 100 个敌人），解锁成就并推送通知</p></li></ul></li><li><p><strong>配置或参数动态更新</strong><br><strong>场景</strong>：系统配置变更后，相关组件需动态调整行为，无需重启。<strong>案例</strong>：</p><ul><li><p>修改系统主题颜色，所有界面组件自动切换配色</p></li><li><p>动态调整日志级别，实时生效</p></li></ul></li><li><p><strong>分布式系统中的一致性保证</strong><br><strong>场景</strong>：多个服务需要根据核心服务状态变化保持一致性。<strong>案例</strong>：</p><ul><li><p>电商系统中，订单状态变为“已支付”时，通知库存服务扣减库存、物流服务生成运单</p></li><li><p><strong>分布式缓存失效</strong>：当缓存数据更新，通知所有节点清除旧缓存</p></li></ul></li></ol><p><strong>场景</strong>：以气象站为例，天气信息表示被观察者，天气布告板表示订阅者和观察者，当天气发生变化（被观察者）时，会通过<code>notifyObserver</code>通知所有观察者，并调用他们的控制方法处理数据。</p><p>一个<code>WeatherData</code>对象负责追踪目前的天气状况（温度，湿度，气压）。希望能建立一个应用，有三种布告板，分别显示目前的状况、气象统计及简单的预报。当<code>WeatherObject</code>对象获得最新的测量数据时，三种布告板必须实时更新。</p><h3 id="气象监测应用的对象分析"><a href="#气象监测应用的对象分析" class="headerlink" title="气象监测应用的对象分析"></a>气象监测应用的对象分析</h3><p>此系统中的三个部分是：</p><ul><li>气象站（获取实际气象数据的物理装置）</li><li><code>WeatherData</code>对象（最总来自气象站的数据，并更新布告板）</li><li>布告板（显示目前天气状况给用户看）。</li></ul><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><ol><li><p><strong>实现气象站</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主题接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>;     <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;     <span class="comment">// 删除观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>;                  <span class="comment">// 当主题状态改变时，这个方法会被调用，以通知所有的观察者</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当气象观测值改变时，主题会把这些状态值当作方法的参数，传送给观察者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当布告板需要显示时，调用此方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在<code>WeatherData</code>中实现主题接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherData</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Observer observer:observers)&#123;</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当从气象站得到更新观测值时，通知观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measurementsChanged</span><span class="params">()</span>&#123;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// WeatherData的其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>建立布告板</strong>（其中的一个布告板）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CurrentConditionDisplay</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>, DisplayElement &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;        <span class="comment">// 温度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;            <span class="comment">// 湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;            <span class="comment">// 气压</span></span><br><span class="line">    <span class="keyword">private</span> Subject weatherData;     <span class="comment">// 天气主题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CurrentConditionDisplay</span><span class="params">(Subject weatherData)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.weatherData = weatherData;</span><br><span class="line">        weatherData.registerObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里气象台更新的天气数据...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temp;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure</span><br><span class="line">        <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>利用内置的支持重写<code>WeatherData</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherDataTWO</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherDataTWO</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measurementsChanged</span><span class="params">()</span>&#123;</span><br><span class="line">        setChanged();          <span class="comment">// 在调用 notifyObservers()之前，要先调用 setChanged() 来指示状态已经改变</span></span><br><span class="line">        notifyObservers();     <span class="comment">// 没调用 notifyObservers 传送数据对象，表示采用的做法是拉</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature,<span class="type">float</span> humidity,<span class="type">float</span> pressure)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getHumidity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> humidity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPressure</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pressure;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>利用内置观察者重写布告板</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title class_">java</span>.util.Observer, DisplayElement &#123;</span><br><span class="line"></span><br><span class="line">    Observable observable;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CurrentConditionsDisplay</span><span class="params">(Observable observable)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.observable = observable;</span><br><span class="line">        observable.addObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;这里气象台更新的天气数据...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> WeatherDataTWO) &#123;</span><br><span class="line">            <span class="type">WeatherDataTWO</span> <span class="variable">weatherDataTWO</span> <span class="operator">=</span> (WeatherDataTWO) o;</span><br><span class="line">            <span class="built_in">this</span>.temperature = weatherDataTWO.getTemperature();</span><br><span class="line">            <span class="built_in">this</span>.humidity = weatherDataTWO.getHumidity();</span><br><span class="line">            display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p><strong><code>模板方法（Template Method）</code></strong> 是一种行为设计模式。模板方法设计模式用于创建方法存根并将某些实现步骤推迟到子类。</p><p>模板方法定义了执行算法的步骤，它可以提供可能对所有或者部分子类通用的默认实现，下面通过一个简单的例子来理解这个模式。</p><h3 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><p><strong>多个类有相似的算法结构</strong></p><p>多个类具有相似的行为或算法，只是某些步骤的实现细节不同，可以使用模板方法模式将这些相似的算法提取到一个抽象类中，<strong>将不同的步骤定义为抽象方法</strong>，由子类去实现。例如，在图形绘制程序中，绘制不同类型的图形（如圆形、矩形等）可能有相似的步骤，如<strong>初始化绘制环境、绘制图形轮廓、填充图形</strong>等，但具体的绘制轮廓和填充方式不同。</p></li><li><p><strong>控制子类的扩展</strong></p><p>模板方法模式允许在不改变算法结构的情况下，通过子类扩展来改变算法的某些步骤。例如，在一个订单处理系统中，订单的处理流程可能包括<strong>接收订单、验证订单、处理支付、发货</strong>等步骤，其中处理支付的步骤可能会因支付方式的不同而有所差异。便可将订单处理流程定义在抽象类中，将支付处理步骤定义为抽象方法，由不同的子类实现不同的支付方式，同时保证订单处理基本流程不变。</p></li><li><p><strong>框架设计</strong></p><p>框架提供了一个算法的骨架，开发者可通过继承框架中的抽象类并实现抽象方法来定制自己的功能。例如，在Java的<code>JDBC</code>框架中，<code>Statement</code>接口及其子类就体现了模板方法模式的思想。<code>Statement</code>接口定义了一系列执行SQL语句的方法，如<code>executeQuery()</code>、<code>executeUpdate()</code>等，这些方法定义了执行SQL语句的基本流程，而具体的数据库操作由不同的数据库驱动程序实现。</p></li><li><p><strong>一次性实现不变部分，避免代码重复</strong></p><p>当算法中的某些步骤是不变的，而其他步骤可能会变化时，可将不变的步骤在抽象类的模板方法中实现，<strong>变化的步骤定义为抽象方法由子类实现</strong>，这样避免了在多个子类中重复编写不变的代码。例如，在一个日志记录系统中，日志的格式和输出方式可能是不变的，但日志的内容可能会因不同的业务场景而不同，可使用模板方法模式将日志的格式和输出方式在抽象类中实现，<strong>将日志内容的生成定义为抽象方法</strong>，由具体的日志记录类实现。</p></li></ol><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>场景</strong>：假设想提供一种算法了解房子，建造房屋需要执行的步骤是：建造地基-&gt;建造支柱-&gt;建造墙壁和窗户。重点是不能改变执行的顺序，在这种情况下，可以创建一个模板方法，它将使用不同的方法来建造房子，现在盖房子的地基对于所有类型的房子都是一样的，无论是木房、玻璃房子还是混泥土房。所以可以为此提供基础实现，如果子类想要覆盖这个方法，他们可以自己选择，但大多数情况下，所有类型的房屋都很常见。为了确保子类不覆盖模板方法，应该将其设为最终方法。</p><p><strong>模板方法抽象类</strong>：若希望某些方法由子类实现，必须将基类设为抽象类。</p><ol><li><p><strong>定义抽象类<code>HouseTemplate</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HouseTemplate</span> &#123;</span><br><span class="line">    <span class="comment">// buildHouse()是模板方法，定义个执行几个步骤的执行顺序</span></span><br><span class="line">    <span class="comment">// template method, final so subclasses can&#x27;t override final修饰，子类不能重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">buildHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        buildFoundation();     <span class="comment">// 建造地基</span></span><br><span class="line">        buildPillars();     <span class="comment">// 建造柱子</span></span><br><span class="line">        buildWalls();         <span class="comment">// 建造墙壁</span></span><br><span class="line">        buildWindows();     <span class="comment">// 建造窗户</span></span><br><span class="line">        System.out.println(<span class="string">&quot;House is built successfully&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Building foundation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildFoundation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Building foundation with cement, iron rods and sand&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// methods to be implemented by subclasses</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPillars</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default implementation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildWindows</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Building Glass Windows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>WoodenHouse</code>，<code>GlassHouse</code>，<code>ConcreteHouse</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 木房 WoodenHouse</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WoodenHouse</span> <span class="keyword">extends</span> <span class="title class_">HouseTemplate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPillars</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Building Pillars With Wood coating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Building Wooden Walls...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玻璃房 GlassHouse</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlassHouse</span> <span class="keyword">extends</span> <span class="title class_">HouseTemplate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPillars</span><span class="params">()</span> &#123;</span><br><span class="line">       log.info(<span class="string">&quot;Building Pillars With Glass coating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Building Glass Walls...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 混泥土房屋 ConcreteHouse</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHouse</span> <span class="keyword">extends</span> <span class="title class_">HouseTemplate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPillars</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Building Pillars With Concrete coating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Building Concrete Walls...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>HousingClient</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HousingClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HouseTemplate</span> <span class="variable">houseBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WoodenHouse</span>();</span><br><span class="line">        houseBuilder.buildHouse();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        houseBuilder = <span class="keyword">new</span> <span class="title class_">GlassHouse</span>();</span><br><span class="line">        houseBuilder.buildHouse();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        houseBuilder = <span class="keyword">new</span> <span class="title class_">ConcreteHouse</span>();</span><br><span class="line">        houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Building foundation with cement,iron rods and sand</span><br><span class="line">Building Pillars With Wood coating...</span><br><span class="line">Building Wooden Walls...</span><br><span class="line">Building Glass Windows</span><br><span class="line">House is built successfully</span><br><span class="line">--------------</span><br><span class="line">Building foundation with cement,iron rods and sand</span><br><span class="line">Building Pillars With Glass coating...</span><br><span class="line">Building Glass Walls...</span><br><span class="line">Building Glass Windows</span><br><span class="line">House is built successfully</span><br><span class="line">--------------</span><br><span class="line">Building foundation with cement,iron rods and sand</span><br><span class="line">Building Pillars With Concrete coating...</span><br><span class="line">Building Concrete Walls...</span><br><span class="line">Building Glass Windows</span><br><span class="line">House is built successfully</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 &lt;em&gt;Gang of Four&lt;/em&gt; (&lt;em&gt;GoF&lt;/em&gt;) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="system" scheme="https://southernfish.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>阿里规约</title>
    <link href="https://southernfish.github.io/pages/java/java-coding-guidelines/"/>
    <id>https://southernfish.github.io/pages/java/java-coding-guidelines/</id>
    <published>2025-07-27T06:26:36.000Z</published>
    <updated>2025-09-17T07:51:48.706Z</updated>
    
    <content type="html"><![CDATA[<p>阿里巴巴 的代码规范（ 阿里规约 ）主要包含 Java 、 C++ 、 Python 等编程语言的编码规范。最新版本可通过其 GitHub 仓库获取。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/134039365">【阿里规约】阿里开发手册解读——命名规范篇</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/134273900">【阿里规约】阿里开发手册解读——代码格式篇</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/135678947">【阿里规约】阿里开发手册解读——数据库和ORM篇</a></p></blockquote><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><ul><li><p><strong>统一小写：</strong>例如商品库存包com.example.product.stock，而不是com.example.productStock</p></li><li><p><strong>分隔符间单词必须单语义：</strong>例如商品库存包com.example.product.stock，而不是com.example.product_stock、com.example.product-stock</p></li></ul><blockquote><p><strong>参考</strong>：</p><p>【强制】 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 <code>单数</code> 形式，但是类名如果有复数含义，类名可以使用复数形式。<br><strong>正例</strong>： 应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils（此规则参考 spring 的框架结构）</p></blockquote><h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><h3 id="普通类和方法"><a href="#普通类和方法" class="headerlink" title="普通类和方法"></a>普通类和方法</h3><ul><li>驼峰命名：例如UserService，而不是User_service。</li><li>禁止拼音英文混用；</li><li>禁止下划线、美元符号起始。</li><li><strong>可读性比长度重要：</strong>命名尽可能短，但<em>望文生义</em>更重要<ul><li><strong>可读性高（推荐）：</strong>下面这些类既保证了望文生义，又保证了缩写<ul><li>商品描述类：DescriptionOfProduct 缩写为 ProductDesc</li><li>应用程序配置类：ApplicationConfiguration 缩写为 AppConfig</li><li>客户信息类：CustomerInformation 缩写为 CustInfo。</li></ul></li><li><strong>可读性低（不推荐）</strong>：<ul><li>AbstractClass缩写命名成 AbsClass；</li><li>PurchaseProduct类缩写成PurProduct;</li></ul></li></ul></li></ul><blockquote><p><strong>参考：</strong></p><ul><li><p>【强制】 代码中的命名均不能以 下划线或美元符号 开始，也不能以 下划线或美元符号 结束。</p><p>反例： <em>name / <em><em>name / $name / name</em> / name$ / name</em></em></p></li><li><p>【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</p><p>说明： 正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，纯拼音命名方式更要避免采用。</p><p>正例： renminbi / alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。</p><p>反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</p></li><li><p>【强制】 方法名、参数名、成员变量、局部变量都统一使用 <code>lowerCamelCase</code> 风格，必须遵从驼峰形式。</p><p>正例： localValue / getHttpMessage() / inputUserId</p></li><li><p>【强制】 杜绝完全不规范的缩写，避免望文不知义。</p><p>反例： AbstractClass缩写命名成 AbsClass；condition缩写命名成 condi，此类随意缩写严重降低了代码的可阅读性。</p></li><li><p>【推荐】 为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。</p><p>正例： 在 JDK 中，表达原子更新的类名为：AtomicReferenceFieldUpdater。</p><p>反例： int a 的随意命名方式。</p></li><li><p>【推荐】 在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。</p><p>正例： startTime / workQueue / nameList / TERMINATED_THREAD_COUNT</p><p>反例： startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD</p></li></ul></blockquote><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><p><strong>命名：</strong>待测类名+Test 。</p><p><strong>举例：</strong>用户测试类UserServiceTest，而不是TestUserService。</p><blockquote><p><strong>参考：</strong></p><p>【强制】 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；</p><p>​        测试类命名以它要测试的类的名称开始，以 Test 结尾</p></blockquote><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><strong>命名：</strong> Abstract+自定义类名。</p><p><strong>举例：</strong>抽象支付方式类AbstractPaymentMethod/BasePaymentMethod，而不是AbstractPayment。</p><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p><strong>命名：</strong>自定义异常名+Exception。</p><p>例如商品找不到类ProductNotFoundException，而不是ProductNotFound。</p><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><ul><li><strong>类名：</strong>自定义类名+Enum。 例如ProcessStatusEnum</li><li><strong>成员名：</strong>跟常量一样</li><li><strong>纯大写+下划线：</strong>例如最大库存量MAX_STOCK_COUNT。</li><li><strong>可读性比长度重要：</strong>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。例如最大库存量MAX_STOCK_COUNT而不是MAX_COUNT。</li></ul><blockquote><p><strong>枚举类和常量类区别：</strong></p><p><strong>相同点：</strong>在Java中，枚举和常量都用于表示一组固定的值，但它们适用的场景有所不同。</p><p><strong>不同点：</strong></p><ul><li><strong>枚举（Enum）</strong>适用于表示<strong>一组有限的可能取值</strong>，这些取值在程序中某个上下文中具有特殊意义。例如，表示一周的星期几或某个颜色的枚举类型。枚举类型可通过限定的值范围提供更好的类型安全性，并且可使用switch语句进行更清晰的代码编写。</li><li><strong>常量（Constant）</strong>适用于表示在程序中经常使用的不可变的值。常量一般定义为 final 类型，并且通常用于表示某个固定的数值或者字符串常量。常量的值在程序中是不可修改的，可以通过常量名直接使用，提高代码的可读性和可维护性，但是可能会降低类型安全性和表达能力。</li></ul><p>总结来说，枚举适用于表示一组有限的、具有特殊意义的取值，常量适用于表示程序中经常使用的不可变的值。</p><p>【参考】 枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。<br>说明： 枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。<br>正例： 枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON</p></blockquote><h3 id="接口和实现类"><a href="#接口和实现类" class="headerlink" title="接口和实现类"></a>接口和实现类</h3><ul><li>service和dao实现类以Impl结尾。注意不要用Imp结尾。例如UserServiceImpl而不是UserServiceImp</li><li>能力型接口以-able结尾。如异常根类Throwable是可抛出的，实现类Exception和Error都可抛出。如Drawable接口和Circle实现类。</li></ul><blockquote><p><strong>参考</strong>：接口和实现类的命名有两套规则</p><ol><li><p>【强制】 对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用Impl 的后缀与接口区别。</p><p>正例： CacheServiceImpl 实现 CacheService 接口。</p></li><li><p>【推荐】 如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形容词）。</p><p>正例： AbstractTranslator 实现 Translatable 接口。</p></li></ol></blockquote><h3 id="PO、DTO、VO"><a href="#PO、DTO、VO" class="headerlink" title="PO、DTO、VO"></a>PO、DTO、VO</h3><ul><li><strong>DO / BO / DTO / VO / AO / PO / UID 要大写，而非驼峰：</strong>例如UserDO，而不是UserDo。例如serialVersionUID，而不是serialVersionUid。</li><li><strong>禁止POJO后缀：</strong>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</li></ul><blockquote><p><strong>扩展</strong>：PO、DTO、VO</p><ol><li>数据对象：xxxDO，xxx 即为数据表名。</li><li>DTO数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</li><li>VO展示对象：xxxVO，xxx 一般为网页名称。</li><li>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</li></ol><p><strong>参考</strong>：<br>【强制】 类名使用 UpperCamelCase 风格，但以下情形例外：DO / BO / DTO / VO / AO / PO / UID 等。<br>正例： JavaServerlessPlatform / UserDO / XmlService / TcpUdpDeal / TaPromotion<br>反例： javaserverlessplatform / UserDo / XMLService / TCPUDPDeal / TAPromotion<br>【参考】 各层命名规约：<br>A) Service/DAO 层方法命名规约</p><ol><li>获取单个对象的方法用 get 做前缀。</li><li>获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。</li><li>获取统计值的方法用 count 做前缀。</li><li>插入的方法用 save/insert 做前缀。</li><li>删除的方法用 remove/delete 做前缀。</li><li>修改的方法用 update 做前缀。</li></ol></blockquote><h3 id="用到设计模式的类"><a href="#用到设计模式的类" class="headerlink" title="用到设计模式的类"></a>用到设计模式的类</h3><blockquote><p>案例参考文章：<a href="/pages/java/java-design-pattern/">设计模式</a></p></blockquote><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>抽象类名以Abstarct/Base为前缀</li><li>用到设计模式时要在命名中进行体现。</li></ul><blockquote><p>参考：<br>【推荐】 如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。<br>说明： 将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。<br>正例： public class OrderFactory;   public class LoginProxy;    public class ResourceObserver;</p></blockquote><h4 id="案例一：工厂设计模式采购披萨"><a href="#案例一：工厂设计模式采购披萨" class="headerlink" title="案例一：工厂设计模式采购披萨"></a>案例一：工厂设计模式采购披萨</h4><p>采购披萨工厂类：利用工厂方法模式创建披萨时，可以把抽象工厂类命名为AbstractOrderPizzaFactory类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂类，订购披萨类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOrderPizzaFactory</span>&#123;</span><br><span class="line"><span class="comment">// 构造方法不断根据用户输入披萨类型，调用创建披萨对象的抽象方法，实现加工披萨。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            pizza = createPizza(getType());</span><br><span class="line">            <span class="keyword">if</span> (pizza == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Failed to Order Pizza&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂类，订购伦敦披萨类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">AbstractOrderPizzaFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (orderType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;cheese&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">LDCheesePizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pepper&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">LDPepperPizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="案例二：-观察者设计模式订阅天气"><a href="#案例二：-观察者设计模式订阅天气" class="headerlink" title="案例二： 观察者设计模式订阅天气"></a>案例二： 观察者设计模式订阅天气</h4><p>天气局接口和观察者类：WeatherSubject和天气观察者接口WeatherObserver</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h3><ul><li>驼峰命名：例如商品价格命名pruductPrice，而不是pruduct_price。</li><li>禁止拼音英文混用；</li><li>禁止下划线、美元符号起始。</li><li><strong>可读性比长度重要：</strong>命名尽可能短，但“望文生义”更重要<ul><li><strong>可读性高（推荐）</strong>：下面这些类<ul><li>最大值：maximumValue 缩写为 maxValue</li><li>项目数量：numberOfItems 缩写为 numItems</li><li>初始化计数器：initializeCounter 缩写为 initCounter</li></ul></li><li><strong>可读性低（不推荐）</strong>：<ul><li>数量：count缩写为cnt</li><li>值：value缩写成val</li><li>序号：index缩写成i</li></ul></li></ul></li><li><strong>类型名词放词尾：</strong>词尾是类型，让人能一眼看出这个变量是干什么的。例如：<ul><li>开始时间：startTime而不是startedAt。</li><li>工作队列：workQueue而不是QueueOfWork。</li><li>名字列表：nameList而不是listName。因为它是个列表。</li><li>最大线程数：MAX_THREAD_COUNT而不是COUNT_MAX_THREAD 。它是数量而不是线程。</li></ul></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h3><p>中括号要直接跟在类型后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：中括号放在变量名后面，注释放在右边</span></span><br><span class="line">String args[]; </span><br><span class="line"><span class="comment">// 正确示例：中括号直接跟在类型后面，注释放在代码上面</span></span><br><span class="line">String[] args; </span><br></pre></td></tr></table></figure><blockquote><p><strong>参考：</strong></p><p>【强制】 类型与中括号紧挨相连来表示数组。</p><p>正例： 定义整形数组 int[] arrayDemo;</p><p>反例： 在 main 参数中，使用 String args[]来定义</p></blockquote><h3 id="布尔型变量"><a href="#布尔型变量" class="headerlink" title="布尔型变量"></a><strong>布尔型变量</strong></h3><p>实体类（PO类）里布尔型变量不能加is前缀，否则部分框架解析会引起序列化错误。同时MySQL表达“是否”的字段可以用is_xxx，只需<code>&lt;resultMap&gt;</code>设置从 is_xxx 到 xxx 的映射关系即可。<strong>示例：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">// 逻辑删除字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> deleted;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 其他属性、构造函数和方法</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDeleted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deleted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDeleted</span><span class="params">(<span class="type">boolean</span> deleted)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.deleted = deleted;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>为什么强制 boolean 类型变量不能使用 is 开头？</strong></p><p>为了防止序列号失败。</p><ul><li><strong>lombok序列号失败</strong>：javaBeans规范boolean变量的getter方法是isXXX()，其他变量的getter方法是getXXX()。lombok遵循javaBeans规范，如果一个变量是boolean isSuccess;在注解@Data或@Getter生成getter方法的时候，它会生成isSuccess()方法，而不是isIsSucess()方法。这也是lombok的一个大坑。</li><li><strong>rpc框架序列号失败</strong>：在一些rpc框架里面，当反向解析读取到isSuccess()方法的时候，rpc框架会“以为”其对应的属性值是success，而实际上其对应的属性值是isSuccess，导致属性值获取不到，从而抛出异常。</li></ul><p>参考：<br>【强制】 POJO 类中布尔类型变量都不要加 is 前缀，否则部分框架解析会引起序列化错误。<br>说明： 在 MySQL 规约中的建表约定第一条，表达是与否的值采用 is_xxx 的命名方式，所以，需要在<code>&lt;resultMap&gt;</code> 设置从 is_xxx 到 xxx 的映射关系。<br>反例： 定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，RPC 框架在反向解析的时候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。</p></blockquote><h3 id="父子类变量"><a href="#父子类变量" class="headerlink" title="父子类变量"></a>父子类变量</h3><p><strong>父子类变量命名：</strong>避免同名变量。例如父类有个name变量，子类想声明一个昵称变量，应另外声明nickname，而非再次声明name。</p><blockquote><p>参考：<br>【强制】 避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低。<br>说明： 子类、父类成员变量名相同，即使是 public 类型的变量也是能够通过编译，而局部变量在同一方法内的不同代码块中同名也是合法的，但是要避免使用。对于非 setter/getter 的参数名称也要避免与成员变量名称相同。<br>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfusingName</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 非 setter/getter 的参数名称，不允许与本类成员变量同名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(String alibaba)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">531</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 在同一方法体中，不允许与其它代码块中的 money 命名相同</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">615</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">ConfusingName</span> &#123;</span><br><span class="line">    <span class="comment">// 不允许与父类的成员变量名称相同</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sonAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>避免同一个方法的多个代码块中声明同名局部变量。例如下面方法的money变量不符合规范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(String alibaba)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">531</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 在同一方法体中，不允许与其它代码块中的 money 命名相同</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">615</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="普通常量"><a href="#普通常量" class="headerlink" title="普通常量"></a>普通常量</h3><ul><li><p><strong>纯大写+下划线：</strong>例如最大库存量MAX_STOCK_COUNT。</p></li><li><p><strong>可读性比长度重要：</strong>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。例如最大库存量MAX_STOCK_COUNT而不是MAX_COUNT。</p></li><li><p><strong>常量类细化</strong>：不要一个总的常量类维护所有常量，要按功能创建粒度小的常量类。例如电商平台商品模块不应该一个ProductStatusConstants维护所有商品常量，而应该细化成商品类型常量类ProductTypeConstants、商品价格范围常量类PriceRangeConstants、商品属性相关常量类ProductAttributeConstants等。</p></li><li><p><strong>枚举类</strong>：变量值只在固定几个值内变化时用枚举类。例如季节Season变量只会有春夏秋冬四种类型，可以定义成季节枚举类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">    SPRING(<span class="number">1</span>), SUMMER(<span class="number">2</span>), AUTUMN(<span class="number">3</span>), WINTER(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seq;</span><br><span class="line">    </span><br><span class="line">    SeasonEnum(<span class="type">int</span> seq) &#123;</span><br><span class="line">        <span class="built_in">this</span>.seq = seq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSeq</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>参考</strong>：<br>【强制】 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>正例： MAX_STOCK_COUNT / CACHE_EXPIRED_TIME<br>反例： MAX_COUNT / EXPIRED_TIME<br>【推荐】 不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。<br>说明： 大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解和维护。<br>正例： 缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。<br>【推荐】 如果变量值仅在一个固定范围内变化用 enum 类型来定义。<br>说明： 如果存在名称之外的延伸属性应使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。</p></blockquote><h3 id="Long常量"><a href="#Long常量" class="headerlink" title="Long常量"></a>Long常量</h3><p><strong>大写L：</strong>以便于区分“L”和数字“1”。例如Long a=1L，而不是Long a=1l。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：</span></span><br><span class="line"><span class="comment">// a实际上表示 Long 型的 2，但容易混淆为数字 21。</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2l</span>; </span><br><span class="line"><span class="comment">//正确示例：</span></span><br><span class="line"><span class="comment">// 使用大写 &quot;L&quot; 来明确表示 Long 型的 2。</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2L</span>; </span><br><span class="line"><span class="comment">// 使用大写 &quot;L&quot; 来明确表示 long 型的 12345。</span></span><br><span class="line"><span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12345L</span>; </span><br></pre></td></tr></table></figure><blockquote><p><strong>参考：</strong><br>【强制】 在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。<br>说明： Long a = 2l; 写的是数字的 21，还是 Long 型的 2。</p></blockquote><hr><h1 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h1><h2 id="编码和换行符"><a href="#编码和换行符" class="headerlink" title="编码和换行符"></a>编码和换行符</h2><p><strong>规范：</strong>代码的编码统一使用UTF-8，换行符使用 Unix 格式，不要使用 Windows 格式。</p><blockquote><p>换行符：</p><p><strong>Unix格式</strong>：在Unix、Linux以及类Unix操作系统中，使用换行符\n来表示新行，这是常用的行结束符。</p><p><strong>Windows格式</strong>：在Windows操作系统中，通常使用回车符和换行符\r\n（CR-LF，Carriage Return-Line Feed）来表示新行。</p><p><strong>IDEA编码设置UTF-8</strong>：File → Setting → Editor → File Coding → Global Encoding；Project Encoding；Default encoding for properties files → 都选择 UTF-8</p></blockquote><h2 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h2><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><p><strong>规范：</strong>if/for/while/switch/do 等保留字与括号之间都必须加空格。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 代码逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 情况1的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 默认情况的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Java常见保留字</strong>：</p><ol><li><strong>条件语句关键字</strong>：如if、else、switch、case、default。</li><li><strong>循环控制关键字</strong>：如for、while、do、break、continue。</li><li><strong>访问修饰符关键字</strong>：如public、private、protected。</li><li><strong>数据类型关键字</strong>：如int、double、char、boolean。</li><li><strong>类和对象关键字</strong>：如class、new、extends、implements。</li><li><strong>异常处理关键字</strong>：如try、catch、throw、throws、finally。</li></ol></blockquote><h3 id="二目、三目运算符"><a href="#二目、三目运算符" class="headerlink" title="二目、三目运算符"></a>二目、三目运算符</h3><p><strong>规范：</strong>任何二目、三目运算符的左右两边需要加一个空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a + b;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">condition</span> <span class="operator">=</span> (x &gt; y) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>java中常见的二目、三目运算符：</strong></p><ul><li><strong>二目运算符：</strong>+、-、*、/、%、=、==、&gt;=、&amp;&amp;</li><li><strong>三目运算符：</strong>?:</li></ul></blockquote><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p><strong>规范：</strong>采用 4 个空格缩进。可以使用tab快捷键直接四个空格，禁止直接使用“tab”字符 。</p><p>IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。</p><blockquote><p><strong>IDEA设置 tab</strong>：File → Setting → Editor → Code Style → Tabs and Indents → 取消勾选Use tab character → Indent 设置4</p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><strong>规范：</strong>注释双斜线后紧跟一个空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例： 这是示例注释，请注意在双斜线之后有一个空格</span></span><br><span class="line"><span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="comment">//反例： 这是示例注释，请注意在双斜线之后没空格</span></span><br><span class="line"><span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br></pre></td></tr></table></figure><h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p><strong>规范：</strong>强制转换时，右括号后无空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例：</span></span><br><span class="line"><span class="type">long</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">1000000000000L</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> (<span class="type">int</span>)first + <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 反例：</span></span><br><span class="line"><span class="type">long</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">1000000000000L</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> (<span class="type">int</span>) first + <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p><strong>规范：</strong>方法参数逗号后加一个空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例：下例中实参的 args1，后边必须要有一个空格。</span></span><br><span class="line">method(args1, args2, args3);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 反例：下例中实参的 args1，后边没空格。</span></span><br><span class="line">method(args1,args2,args3);</span><br><span class="line">method(args1 ,args2 ,args3);</span><br></pre></td></tr></table></figure><h2 id="行数、字符数"><a href="#行数、字符数" class="headerlink" title="行数、字符数"></a>行数、字符数</h2><h3 id="单行字符数"><a href="#单行字符数" class="headerlink" title="单行字符数"></a>单行字符数</h3><p><strong>规范：</strong>单行字符数不超过120个，超过时需要换行。</p><p><strong>换行规则：</strong></p><ol><li><p>第2/3/4/..行相对第一行缩进 4 个空格。</p></li><li><p>运算符随下文一起换行。例如a + b，应该换行成a\n + b，而不是a + \nb</p></li><li><p>点符号与下文一起换行。例如dog.eat()，应该换行成dog\n.eat()，而不是dog.\neat()</p></li><li><p>方法的多个参数换行时，逗号不与下文一起换行。例如sum (1,2,3)，应该换行成sum (1,2,\n3)，而不是sum (1,2\n,3)</p></li><li><p>在括号前不换行。例如fun (a)，应该换行成\nfun (a)，而不是fun \n(a)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例：</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); </span><br><span class="line"><span class="comment">// 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行</span></span><br><span class="line">sb.append(<span class="string">&quot;Jack&quot;</span>).append(<span class="string">&quot;Ma&quot;</span>)... </span><br><span class="line">.append(<span class="string">&quot;alibaba&quot;</span>)... </span><br><span class="line">.append(<span class="string">&quot;alibaba&quot;</span>)... </span><br><span class="line">.append(<span class="string">&quot;alibaba&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 反例：</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); </span><br><span class="line"><span class="comment">// 超过 120 个字符的情况下，不要在括号前换行</span></span><br><span class="line">sb.append(<span class="string">&quot;Jack&quot;</span>).append(<span class="string">&quot;Ma&quot;</span>)...append </span><br><span class="line">(<span class="string">&quot;alibaba&quot;</span>); </span><br><span class="line"><span class="comment">// 参数很多的方法调用可能超过 120 个字符，不要在逗号前换行</span></span><br><span class="line">method(args1, args2, args3, ... </span><br><span class="line">, argsX);</span><br></pre></td></tr></table></figure><h3 id="方法行数"><a href="#方法行数" class="headerlink" title="方法行数"></a>方法行数</h3><p><strong>规范：</strong>单个方法的总行数不超过 80 行。 </p><p>除注释之外的方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过80 行。</p><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><h3 id="大括号换行规则"><a href="#大括号换行规则" class="headerlink" title="大括号换行规则"></a>大括号换行规则</h3><p><strong>规范：</strong>大括号内为空时无需换行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 大括号内为空，则不换行</span></span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>规范：</strong>大括号内非空时： </p><ul><li><strong>左大括号：</strong>前不换行，后换行</li><li><strong>右大括号：</strong>前换行，右换行（有else时不换行）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这个数字是正数&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(number &lt; -<span class="number">3</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这个数字不是正数&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;...&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="小括号规则"><a href="#小括号规则" class="headerlink" title="小括号规则"></a>小括号规则</h3><p><strong>规范：</strong>小括号内侧不隔空格，外侧隔单空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例：小括号内侧不隔空格，外侧隔单空格。</span></span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 反例：</span></span><br><span class="line"><span class="comment">// 小括号外侧没隔单空格。</span></span><br><span class="line"><span class="keyword">if</span>(a == b)</span><br><span class="line"><span class="comment">// 小括号内侧隔了空格</span></span><br><span class="line"><span class="keyword">if</span> ( a == b )</span><br></pre></td></tr></table></figure><hr><h1 id="MySQL-规约"><a href="#MySQL-规约" class="headerlink" title="MySQL 规约"></a>MySQL 规约</h1><h2 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h2><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p><strong>命名：</strong>库名与应用名称尽量一致；</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><ul><li><strong>大小写：</strong>MySQL表名不能有大写字母。因为MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。</li><li><strong>复数：</strong>不可使用复数。</li><li><strong>不可使用保留字：</strong>例如不能命名为add,from,set等。</li><li><strong>业务名称_表的作用：</strong>建议命名“业务名称_表的作用”，例如：<ul><li><strong>用户信息表</strong>：user_info</li><li><strong>产品信息表</strong>：product_info</li><li><strong>客户订单关联表</strong>：customer_order_relation</li></ul></li></ul><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><h4 id="基础命名规范"><a href="#基础命名规范" class="headerlink" title="基础命名规范"></a>基础命名规范</h4><ul><li><strong>命名要慎重：</strong>字段名的修改代价很大，所以必须要慎重；</li><li><strong>大小写：</strong>MySQL字段名不能有大写字母。因为MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写，大小写混用会出问题。</li><li><strong>保留字：</strong>不可使用保留字。例如不能命名为add,from,set等。</li></ul><h4 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h4><ul><li><strong>注释：</strong>字段含义改变时，及时更新注释； </li><li><strong>合理冗余：</strong>多读少写、长度短、非唯一索引的字段可以冗余，以降低连表查询的次数。</li><li><strong>关联字段类型：</strong>要关联查询的两个字段，数据类型必须一致。如果不一致会导致索引失效，索引和索引失效场景具体可以参考顶部导航文章中的“MySQL高级篇”；</li><li><strong>分库分表依据：</strong>单表数据量<strong>五百万条</strong>数据，或者容量<strong>2GB</strong>。</li><li><strong>三大必备字段：</strong>主键、创建时间、修改时间。即id, create_time（或者命名为gmt_create）, update_time（或者命名为gmt_modified）</li></ul><h3 id="布尔型字段"><a href="#布尔型字段" class="headerlink" title="布尔型字段"></a>布尔型字段</h3><ul><li><p><strong>结构：</strong>is_xxx</p></li><li><p><strong>数据类型：</strong>unsigned tinyint</p></li><li><p><strong>值：</strong>1 表示是，0 表示否</p></li><li><p><strong>对应实体类变量：</strong>虽然数据库必须命名成is_xxx，但是该表对应的实体类成员变量<strong>不能命名为isXxx</strong>，否则会导致序列号失败。故需要在 <code>resultMap</code> 中进行字段与属性之间的映射。</p></li></ul><blockquote><p><strong>《阿里规约》原文</strong>：<br>【强制】 表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。<br>说明： 任何字段如果为非负数，必须是 unsigned 。<br><strong>注意</strong>： POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在&lt; resultMap &gt;设置从 is_xxx到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。<br>正例： 表达逻辑删除的字段名 is_deleted ，1 表示删除，0 表示未删除。</p></blockquote><h3 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h3><ul><li><strong>类型：</strong>decimal。主要是为了防止丢失精度。</li></ul><blockquote><p>【强制】 小数类型为 decimal ，禁止使用 float 和 double 。<br>说明： 在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。</p></blockquote><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="基本规范-1"><a href="#基本规范-1" class="headerlink" title="基本规范"></a>基本规范</h4><ul><li><strong>长度几乎固定字段：</strong>使用char类型。例如电话号、身份证字段类型char(11)即可，效率要比varchar(11)更高。因为实际存储时，varchar会根据实际输入的内容占用的长度进行存储，因此占用的存储空间是实际内容长度+可变长字段长度（当varchar使用长度≤255时使用一个字节记录，长度超出255时使用二个字节记录）。</li><li><strong>超长字段：</strong>长度超过 5000的超长字段，一律使用text类型，并将该字段独立出一个表。因为text、blog类型会导致索引失效；不使用varchar是因为varchar(5000)太长，建索引后非聚簇索引树过于占用磁盘空间。</li></ul><blockquote><p>【强制】 如果存储的字符串长度几乎相等，使用 char 定长字符串类型。<br>【强制】 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text ，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p></blockquote><h4 id="varchar和char类型的区别、适用场景"><a href="#varchar和char类型的区别、适用场景" class="headerlink" title="varchar和char类型的区别、适用场景"></a>varchar和char类型的区别、适用场景</h4><p><strong>长度：</strong></p><ul><li><strong>char：</strong>固定长度的字符串</li><li><strong>varchar：</strong>可变长度的字符串。</li></ul><p><strong>存储方式：</strong></p><ul><li><strong>char：</strong>长度固定不可变，未存满的值会用空格填充到固定的长度。因此char类型字符串<strong>末尾无法存储空格</strong>，当然也不需要额外字节记录字符串长度。</li><li><strong>varchar：</strong>varchar会使用1或2个额外字节记录字符串的长度。当列最大长度是255及以下时，varchar会使用一个字节<strong>记录可变长长度</strong>，最大长度255以上会使用两个字节记录可变长长度。因为varchar有记录长度，所以字符串末尾可以存储空格。</li></ul><p><strong>存储容量：</strong></p><ul><li><strong>char：</strong>最多255个字符</li><li><strong>varchar：</strong>理论上最多65535字节，最多65532个字符（当用utf-8编码存纯英文、且该表只有这一个字段时，字符串中的字符只占1个字节，能达到65532个字符）。但实际从性能考虑，超过5000长度时就不允许再用varchar，而是使用text类型。</li></ul><blockquote><p><strong>各编码的占用长度</strong></p><ul><li>GBK编码：一个英文字符占一个字节，中文2字节，单字符最大可占用2个字节。</li><li>UTF-8编码：一个英文字符占一个字节，中文3字节，单字符最大可占用3个字节。</li><li>utf8mb4编码：一个英文字符占一个字节，中文3字节，单字符最大占4个字节（如emoji表情4字节）。</li></ul><p><strong>varchar(20) 是指字符串最大字节数是20，还是最大字符数是20</strong>？</p><p><strong>答案</strong>：取决于MySQL版本；4.0版本及以下，MySQL中varchar长度是按字节展示，如varchar(20)，指的是20字节；5.0版本及以上，MySQL中varchar长度是按字符展示。如varchar(20)，指的是20字符。</p><p><strong>为什么varchar理论上最多字符数是65532</strong>？</p><p><strong>答案：</strong>因为MySQL行默认最大65535字节，varchar还需要1或2个字节维护可变长度，1个字节标识该列是否为NULL。</p></blockquote><p><strong>性能和空间</strong>：</p><ul><li><strong>char</strong>：性能更好，每次更新时不用维护长度；但存在空间浪费的可能；</li><li><strong>varchar</strong>：性能相对差一点，因为每次更新时要维护长度。如果更新后字符串变长后，原来的数据页正好存满，则需要耗费时间处理新字符串的存储；处理方式取决于存储引擎，例如MylSAM将行拆成多个片段存储，innoDB会分裂页。</li></ul><p><strong>适用场景：</strong></p><ul><li><strong>char：</strong>存储长度几乎固定的字符串适用char类型。例如电话号、身份证字段类型char(11)即可，效率要比varchar(11)更高。因为实际存储时，varchar会根据实际输入的内容占用的长度进行存储，因此占用的存储空间是实际内容长度+可变长字段长度（当varchar使用长度≤255时使用一个字节记录，长度超出255时使用二个字节记录）。 </li><li><strong>varchar：</strong>长度几乎不固定、不超过2000字符的字符串。</li></ul><h4 id="varchar和text类型的区别、适用场景"><a href="#varchar和text类型的区别、适用场景" class="headerlink" title="varchar和text类型的区别、适用场景"></a>varchar和text类型的区别、适用场景</h4><p><strong>存储方式</strong>：</p><ul><li><strong>VARCHAR</strong>：可变长度的字符数据类型，它需要指定最大长度。实际存储时，会根据实际输入的内容占用的长度进行存储，因此占用的存储空间是实际内容长度加上一些额外的长度信息。</li><li><strong>TEXT</strong>：TEXT也用于存储可变长度的字符数据，但它可以存储非常大的文本内容，通常可以存储几GB的数据。</li></ul><p><strong>索引和查询</strong>：</p><ul><li><strong>VARCHAR</strong>：由于VARCHAR有固定的最大长度，可以建立更有效率的索引，同时在查询时会更快一些。</li><li><strong>TEXT</strong>：对于较大的文本数据，使用TEXT类型可能会导致一些查询性能上的损失，因为文本数据的处理通常会比较耗费资源。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>VARCHAR</strong>：适用于长度可预期且不会太长的文本内容，比如姓名、地址等信息。</li><li><strong>TEXT</strong>：适用于长度不确定或者非常长的文本内容，比如文章内容、评论等。</li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>VARCHAR</strong>：占用存储空间相对较小，适合存储较短字符串，支持索引，查询速度较快。但最大长度的限制可能会带来一些不便。</li><li><strong>TEXT</strong>：可以存储非常大的文本内容，并且没有固定长度的限制，适合存储较长的文本数据。但是在查询和索引上可能会稍慢，而且在某些情况下，可能会消耗更多的存储空间。</li></ul><h3 id="外键-级联"><a href="#外键-级联" class="headerlink" title="外键/级联"></a>外键/级联</h3><p><strong>禁用外键和级联。</strong>因为外键影响数据库的插入速度，每次插入时都要检查、更新外键；级联更新是强阻塞，也会影响性能。<strong>外键与级联更新适用于单机低并发</strong>的场景，不适合分布式、高并发集群的场景</p><ul><li><p><strong>级联删除：</strong>创建外键时声明级联，则引用表删除数据时，被引用表也会级联删除这条数据。示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREIGN</span> KEY (customer_id) <span class="keyword">REFERENCES</span> customers(customer_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCAD</span><br></pre></td></tr></table></figure></li><li><p><strong>级联更新：</strong>创建外键时声明级联，则引用表更新数据时，被引用表也会级联更新这条数据。示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREIGN</span> KEY (customer_id) <span class="keyword">REFERENCES</span> customers(customer_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCAD</span><br></pre></td></tr></table></figure></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="命名规范-1"><a href="#命名规范-1" class="headerlink" title="命名规范"></a>命名规范</h3><blockquote><p>【强制】 主键索引名为 pk_ 字段名；唯一索引名为 uk _字段名 ； 普通索引名则为 idx _字段名。</p><p>说明： pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p></blockquote><h3 id="创建规范"><a href="#创建规范" class="headerlink" title="创建规范"></a>创建规范</h3><ul><li><p><strong>唯一索引：</strong>唯一特性字段必须创建唯一索引。一般不需要另外创建，因为创建唯一约束的时候会自动创建唯一索引。</p></li><li><p><strong>关联查询：</strong>被驱动表优先建索引，超过三个表禁止 join。</p></li><li><p><strong>字符串：</strong></p><ul><li><strong>模糊查询：</strong>禁止左模糊、全模糊索引。因为模糊查询会使索引失效，解决方案是使用ES等搜索引擎实现页面的搜索。</li><li><strong>索引长度：</strong>必须使用前缀索引。即字符串创建索引时必须指定索引长度，具体索引长度应该在区分度较高的前提下，索引长度越短越好。区分度=count(distinct left(列名, 索引长度))/count(*)，即统计重复次数。</li></ul></li><li><p><strong>排序：</strong>保持联合索引的有序性。例如搜索条件where a=? and b=? order by c;，则创建联合索引：a_b_c</p></li><li><p><strong>联合索引：</strong>区分度高的字段放左边。</p></li><li><p><strong>覆盖索引：</strong>使用覆盖索引防止回表；例如查询where a=? and b=? and c=?，则创建联合索引a_b_c，而不是a_b，因为走a_b_c的时候，直接在非聚簇索引树就能获取到所有要查询的字段，不需要回表查聚簇索引树。</p></li><li><p><strong>子查询优化深分页：</strong>正常情况下，深分页查询性能是很差的，例如我需要1w页第一条数据，那么就需要查出前1w条数据，性能很慢。用子查询可以优化深分页。</p></li><li><p><strong>深分页查询优化：</strong>需求是返回第1000000~1000010 的记录。如果直接limit 100000,10，将会先排序前十万条数据并回表，查询速度会非常慢，甚至会超时。</p><ul><li><p><strong>主键有序的表根据主键排序，先过滤再排序：</strong>直接查上页最后记录之后的几个数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 自增。适用于app端和web端。由于不建议用自增策略（不安全、<span class="number">8.0</span>才修复的ID回溯问题），所以此方法适用性不广。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">99999</span> LIMIT <span class="number">10</span>;</span><br><span class="line"># 雪花。x是上页最后一条记录的id。只适用于app端上下滑动分页时候必能拿到上页记录id。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> #&#123;x.id&#125; LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>主键不有序的表根据主键排序，先给主键分页，然后内连接原表：</strong>当前表内连接排序截取后的主键表，连接字段是主键。因为查主键是在聚簇索引树查，不用回表，排序和分页很快</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student t,(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>,<span class="number">10</span>) a <span class="keyword">WHERE</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure></li><li><p><strong>主键有序的表根据非主键排序：</strong>得到上一页最后一条记录x（app端通过下拉翻页是肯定能获得上页最后记录的），那么目标页码的所有记录id都比x.id小（因为逆序，且排序依据其实是age,id，主键自增），目标页码的所有记录age都比x.age小或等于。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 自增</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id<span class="operator">&lt;</span>#&#123;x.id&#125; <span class="keyword">AND</span> age<span class="operator">&gt;=</span>#&#123;x.age&#125; <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"># 雪花一个思路，只是x.id通过子查询获取</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>命中索引的要求：</strong>SQL 性能优化目标至少达 range 级别（范围索引），要求是 ref 级别（非唯一索引），最好const（唯一索引）。</p></li></ul><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><h3 id="基本规范-2"><a href="#基本规范-2" class="headerlink" title="基本规范"></a>基本规范</h3><ul><li><strong>更新前要先查询：</strong>删除、更新前要先查询，避免误操作。</li><li>禁用存储过程；</li><li>禁用外键、级联。</li></ul><h3 id="查询字段"><a href="#查询字段" class="headerlink" title="查询字段"></a>查询字段</h3><ul><li><p><strong>禁用select *。</strong>原因：</p><ul><li><p><strong>性能：</strong>多查询一些不需要的字段，性能差；</p></li><li><p><strong>失去覆盖索引的可能性：</strong>在命中联合索引时，查询的字段正好在非聚簇索引树中，就不需要回表了，而如果select *，则一定需要回表，影响性能。</p></li><li><p><strong>对比select 全部字段：</strong>即使需求是查询全部字段，也尽量用select 全部字段，而不用select *。原因：</p><ul><li><p><strong>性能：</strong>select * 在系统解析的时候会多一步从系统表获取具体字段的步骤，因此会比select 全部字段多花时间，效率稍低。</p></li><li><p><strong>结果顺序：</strong>select 全部字段，查询的结果字段顺序可控；</p></li></ul></li><li><p><strong>应用场景：</strong>某些特例也是可以用select *的，例如一些特定场景，在开发过程中（非生产环境），表结构、字段名频繁变化，可以暂时用select *</p></li></ul></li><li><p><strong>查询数量：</strong>正确区分count(*)、count(1)、count(字段)</p><ul><li><strong>count(*)：</strong>统计包括null的所有行数</li></ul></li><li><p><strong>count(1)：</strong>统计包括null的第一列的行数。因为第一列在每一列都存在，所以等同于统计了所有行，并且不需要检查各行数据， 所以性能可能略高于count(*)</p><ul><li><strong>count(字段)：</strong>统计不包括null的字段列的行数。例如学生表有100行，name列全是null，select count(name) from student查出的结果是0.</li></ul></li><li><p><strong>求和：</strong>当某一列值全是null时，count(col)的值是0，sum(col)的值是null，所以求和时要防止空指针异常。</p></li></ul><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><strong>先查数量再查询：</strong>分页查询前先查询count，如果count为0，则直接返回数据为null，不再分页查询，提高效率。</p><hr><h2 id="对象关系映射（ORM）"><a href="#对象关系映射（ORM）" class="headerlink" title="对象关系映射（ORM）"></a>对象关系映射（ORM）</h2><ul><li><p><strong>禁用select *。</strong></p></li><li><p><strong>布尔型字段：</strong>数据库表用is_xxx，实体类禁用isXxx</p><ul><li><p><strong>结构：</strong>is_xxx</p></li><li><p><strong>数据类型：</strong>unsigned tinyint</p></li><li><p><strong>值：</strong>1 表示是，0 表示否</p></li><li><p><strong>对应实体类变量：</strong>虽然数据库必须命名成is_xxx，但是该表对应的实体类成员变量<strong>不能命名为isXxx</strong>，否则会导致序列号失败。所系需要在 resultMap 中进行字段与属性之间的映射。</p></li></ul></li><li><p><strong>参数：</strong>使用#{}，#param#，而不是${}。防止SQL注入。</p></li><li><p><strong>返回值：</strong>强制禁用Map，虽然少去了序列号的过程，性能会快一点，但是字段类型不可控。</p></li><li><p><strong>更新接口：</strong>更新时不要更新全部字段，尽量不要写一个参数为实体类的更新接口。一方面可以防止出错、另一方面可以提高性能、减少binlog存储（binlog是二进制日志文件，记录改不记录读，用于数据复制和数据恢复；在主从同步时用到）。</p></li><li><p><strong>不要滥用事务：</strong>事务要尽可能的控制粒度，使粒度尽可能的小，例如一些不必要的查询可以放在事务外部，以减少锁冲突、缩短连接时长，从而提高QPS（每秒发送的请求数）</p></li></ul>]]></content>
    
    
    <summary type="html">‌</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    
    <category term="system" scheme="https://southernfish.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库-表设计优化、读写分离与分库分表</title>
    <link href="https://southernfish.github.io/pages/database/db-mysql-5-sharding/"/>
    <id>https://southernfish.github.io/pages/database/db-mysql-5-sharding/</id>
    <published>2025-07-26T11:30:36.000Z</published>
    <updated>2025-09-17T07:51:48.701Z</updated>
    
    <content type="html"><![CDATA[<p>数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，核心目标是将低效SQL语句转换为高效等效语句。人工智能自动优化技术通过重写SQL语句实现性能提升。优化技术演变历经三代工具：第一代解析执行计划，第二代推荐索引优化，第三代提出语法改进建议。优化策略贯穿数据库生命周期，其中设计阶段优化成本最低且收益最大。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/139088747">【MySQL调优】如何进行MySQL调优？从参数,数据,建模,索引,SQL语句等方向，三万字详细解读MySQL的性能优化方案（2024版）</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/133797658">一篇文章搞懂MySQL的分库分表，从拆分场景、目标评估、拆分方案、不停机迁移、一致性补偿等方面详细阐述MySQL数据库的分库分表方案</a></p></blockquote><h1 id="表设计优化"><a href="#表设计优化" class="headerlink" title="表设计优化"></a>表设计优化</h1><h2 id="混合业务分表、冷热数据分表"><a href="#混合业务分表、冷热数据分表" class="headerlink" title="混合业务分表、冷热数据分表"></a>混合业务分表、冷热数据分表</h2><p>例如把一个大的任务表，分离成任务表和历史任务表，任务表里任务完成后移动到历史任务表。任务表是热数据，历史任务表是冷数据，提高查询性能。</p><p><strong>混合业务分表：</strong></p><p>根据业务逻辑，将不同的业务数据分开存储在不同的表中。每个业务模块的数据单独存储，减少了单表的大小和查询的复杂度。</p><ul><li><strong>示例：</strong>将一个大的日志表，拆分成交易日志表、操作日志表、登录日志表等。这些要在项目设计期间就根据预估的数据量进行拆分。</li></ul><p><strong>冷热数据分表：</strong></p><p>将频繁访问的“热数据”和不常访问的“冷数据”分开存储。这种策略有助于提高热数据的查询性能，并且在存储和备份方面更加灵活。</p><ul><li><strong>示例1：</strong>把一个大的任务表，分离成任务表和历史任务表，任务表里任务完成后移动到历史任务表。任务表是热数据，历史任务表是冷数据，提高查询性能。</li><li><strong>示例2：</strong>或者将日志表分成日志表和历史日志表，使用定时任务将三个月前的日志都迁移到历史日志表，用户查看操作记录时，默认只显示近三个月的数据，从而提高性能。</li></ul><h2 id="联合查询改为中间关系表"><a href="#联合查询改为中间关系表" class="headerlink" title="联合查询改为中间关系表"></a>联合查询改为中间关系表</h2><p>例如属性表和属性分组表，不使用连接查询，使用“属性-属性分组表”存储每条属性与“属性关系”的id。</p><p>对于复杂的数据库设计，使用关系表是一种常见的方法，特别是在多对多的关系中，例如学生表和课程表、商品表和商品属性表、用户和角色表、作者和书籍表、部门和人员表。</p><p><strong>示例：</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 部门表 (departments)</span><br><span class="line">departments(department_id, department_name)</span><br><span class="line"># 人员表 (employees)</span><br><span class="line">employees(employee_id, employee_name)</span><br><span class="line"># 部门员工关联表 (department_employees)</span><br><span class="line">department_employees(id, department_id, employee_id)</span><br><span class="line"># department_id：外键，指向 departments 表；employee_id：外键，指向 employees 表</span><br></pre></td></tr></table></figure><p><strong>关系表的优点：</strong></p><ul><li><strong>多对多关系：</strong>通过中间表可以管理多对多的映射关系。</li><li><strong>支持扩展：</strong>关系表可以添加额外的字段来描述关系的属性。</li><li><strong>提高查询性能：</strong>减少表连接的次数，提高查询性能。</li></ul><h2 id="遵循三个范式"><a href="#遵循三个范式" class="headerlink" title="遵循三个范式"></a>遵循三个范式</h2><p>每个属性不可再分、表必须有且只有一个主键、非主键列必须直接依赖于主键</p><h2 id="字段建议非空约束"><a href="#字段建议非空约束" class="headerlink" title="字段建议非空约束"></a>字段建议非空约束</h2><ol><li>可能查询出现空指针问题；</li><li>导致聚合函数不准确，因为它会忽略null</li><li>不能用“=”判断，只能用is null判断；</li><li>null和其他值运算只能是null，可能让你不小心把它当成0；</li><li>null值比空字符更占用空间，空值长度是0，null长度是1bit；</li><li>不覆盖索引情况下，is not null无法用索引</li></ol><h2 id="反范式：使用冗余字段"><a href="#反范式：使用冗余字段" class="headerlink" title="反范式：使用冗余字段"></a>反范式：使用冗余字段</h2><p>虽然列字段不能太多，但为查询效率可增加冗余字段。</p><p><strong>反范式：</strong>为提高查询效率，可添加不常更新的字段为冗余字段。</p><p>反范式化是数据库设计的一种策略，通过在设计中引入冗余数据来提高查询性能，简化查询操作，或满足其他业务需求。</p><p><strong>使用场景：</strong></p><p>将多读少写的字段，增加为冗余字段，从而不再需要每次都连表查询这个字段。</p><blockquote><p><strong>注意：</strong></p><p>增加冗余字段后，当这个冗余字段对应的数据改动后，必须同步更改这个冗余字段。</p><p>例如成绩表除了有student_id字段外，增加冗余字段student_name，因为学生名基本不会变化，但在修改姓名的接口里，修改学生名后要同步修改成绩表的student_name字段。</p></blockquote><h2 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h2><ol><li><p><strong>整数类型</strong></p><p>考虑好数值范围，前期可以使用<code>int</code>保证稳定性。非负数类型要用UNSIGNED；同样字节数，存储的数值范围更大。主键一般使用<code>bigint</code>，布尔类型<code>tinint</code></p></li><li><p><strong>能整数就不要用文本类型：</strong>跟文本类型数据相比，大整数往往占用更少的存储空间。</p></li><li><p><strong>避免使用TEXT、BLOB数据类</strong></p><p>这两个大数据类型，排序时不能使用临时内存表，只能使用磁盘临时表，效率很差，建议别用，或分表到单独扩展表里。LongBlob类型能存储4G文件；</p></li><li><p><strong>避免使用枚举类型：</strong>排序很慢。</p></li><li><p><strong>使用TIMESTAMP存储时间：</strong></p><p>TIMESTAMP使用4字节，DATETIME使用8个字节，同时TIMESTAMP具有自动赋值以及自动更新的特性。 缺点是只能存到2038年，MySQL5.6.4版本可以参数配置，自动修改它为BIGINT类型。</p></li><li><p><strong>DECIMAL存浮点数</strong></p><p>Decimal类型为精准浮点数，在计算时不会丢失精度，尤其是财务相关的金融类数据。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。 </p></li></ol><hr><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p><strong>读写分离</strong>：读写分离能有效提高查询性能。读写分离基于MySQL的主从同步，一台主库负责写，多台从库负责读，每次主库发生写操作后，通过binlog和relay log，将修改操作同步到从库，从而保持主库和从库的数据一致性。</p><p><strong>主从同步：</strong>一台或多台MySQL数据库(slave，即从库)从另一台NySQL数据库（master，即主库）进行日志的复制，然后再解析日志并应用到自身，最终实现从库的数据和主库的数据保持一致。MySQL主从复制是NySQL数据库自带功能，无需借助第三方工具。</p><p><strong>主从同步实现步骤：</strong> </p><ol><li><strong>主服务器</strong>把数据更改记录到<strong>二进制日志</strong>（binlog，记录改不记录读，用于数据复制和数据恢复）中；</li><li><strong>从服务器</strong>异步近似实时地把主服务器的二进制日志<strong>复制到</strong>自己的<strong>中继日志</strong>（relay log）中；</li><li><strong>从服务器重做</strong>中继日志中的操作，把更改应用到自己的数据库上，以达到数据的最终一致性。</li></ol><p><strong>主从同步的延时问题：</strong></p><ul><li><p><strong>延时问题：</strong>是主服务器压力大导致的复制延时问题。</p></li><li><p><strong>解决方案</strong>：</p><ul><li><strong>网络带宽优化：</strong>如果是网络延时问题，可以通过增大服务器的带宽解决。</li><li><strong>硬件调优：</strong>如果是因为硬件配置差导致同步延时，可以通过提升服务器配置解决。</li></ul></li><li><p><strong>参数调优：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 多线程复制（MySQL 5.7及以上版本）：设置并行线程数</span></span><br><span class="line">slave_parallel_workers = 4  </span><br><span class="line"><span class="comment"># 开启半同步复制（MySQL 5.5及以上版本）</span></span><br><span class="line">rpl_semi_sync_master_enabled = 1</span><br><span class="line">rpl_semi_sync_slave_enabled = 1</span><br><span class="line"><span class="comment"># 同步延时时间：1秒超时。如果频繁写，则适当缩小；如果频繁读少写，则适当增大，以降低服务器压力</span></span><br><span class="line">rpl_semi_sync_master_timeout = 1000  </span><br></pre></td></tr></table></figure></li><li><p><strong>缩小事务粒度：</strong>一些代码中直接在整个Controller或者整个Service方法上加个@Transcational，而整个业务中其实只有一小段需要保持事务，这样是很影响性能的，因为事务不是那个，MySQL的连接会一直被占用，对数据库的压力很大。</p><p><strong>解决方案：</strong>减小代码中事务的粒度，例如将大事务拆解成小事务，将其中的一些查询操作脱离出去，只在写操作的方法中加事务；</p></li></ul><p><strong>复制原理：</strong> </p><ul><li><strong>主库二进制日志转储线程：</strong>负责将二进制日志发给从库。强制从主库读取数据时（/<em>master</em>/ SELECT * FROM user），会给二进制日志<strong>加锁</strong> ，读完解锁。</li><li><strong>从库I/O 线程：</strong>负责连接主库，并向主库发送请求和复制二进制日志到中继日志。</li><li><strong>从库SQL 线程：</strong>负责读取并执行中继日志中的更新语句，实现主从同步。 </li></ul><p><strong>主从库数量：</strong> </p><ul><li>每个 Master 可以有多个 Slave</li><li>每个 Slave 只能有一个唯一的服务器ID，只有一个 Master。</li></ul><hr><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>只分表：</strong>单表数据量大，读写出现瓶颈，这个表所在的库还可以支撑未来几年的增长。</li><li><strong>只分库：</strong>整个数据库读写出现性能瓶颈，将整个库拆开。</li><li><strong>分库分表：</strong>单表数据量大，所在库也出现性能瓶颈，就要既分库又分表。</li><li><strong>垂直拆分：</strong>把字段分开。例如spu表的pic字段特别长，建议把这个pic字段拆到另一个表（同库或不同库）。</li><li><strong>水平拆分：</strong>把记录分开。例如表数据量到达百万，我们拆成四张20万的表。</li></ul><h2 id="拆分原则"><a href="#拆分原则" class="headerlink" title="拆分原则"></a>拆分原则</h2><p>一般情况下，单表数据量到达千万级别，就可以考虑分库分表了。</p><p>具体是否分库分表看具体业务场景，例如流水表、记录表，数据量非常容易到达千万级、亿万级，需要在设计数据库表的阶段就进行分表，还有一些表虽然数据量只有几百万，但字段非常多，而且有很多text、blog格式的字段，查询性能也会很慢，可以考虑分库分表。</p><table><thead><tr><th align="left">数据量增长情况</th><th align="left">数据表类型</th><th align="left">优化核心思想</th></tr></thead><tbody><tr><td align="left">数据量为千万级，是一个相对<strong>稳定</strong>的数据量</td><td align="left">状态表</td><td align="left">能不拆就不拆读需求水平扩展</td></tr><tr><td align="left">数据量为千万级，可能达到<strong>亿级</strong>或者更高</td><td align="left">流水表</td><td align="left">业务拆分，面向分布式存储设计</td></tr><tr><td align="left">数据量为千万级，可能达到<strong>亿级</strong>或者更高</td><td align="left">流水表</td><td align="left">设计数据统计需求存储的分布式扩展</td></tr><tr><td align="left">数据量为千万级，不应该有这么多的数据</td><td align="left">配置表</td><td align="left">小而简，避免大一统</td></tr></tbody></table><h2 id="分库分表步骤简述"><a href="#分库分表步骤简述" class="headerlink" title="分库分表步骤简述"></a>分库分表步骤简述</h2><ol><li><strong>MySQL调优：</strong>数据量能稳定在千万级，近几年不会到达亿级，其实是不用着急拆的，先尝试MySQL调优，优化读写性能。</li><li><strong>目标评估：</strong>评估拆几个库、表，举例: 当前20亿，5年后评估为100亿。分几个表? 分几个库?解答:一个合理的答案，1024个表，16个库按1024个表算，拆分完单表200万，5年后为1000万.1024个表*200w≈100亿。</li><li><strong>表拆分：</strong><ul><li><strong>业务层拆分：</strong>混合业务拆分为独立业务、冷热分离</li><li><strong>数据层拆分：</strong><ul><li><strong>按日期拆分：</strong>这种方式较普遍，尤其是按照日期维度的拆分，其实在程序层面的改动很小，但扩展性方面的收益很大。<ul><li>日维度拆分，如test_20191021</li><li>月维度拆分,如test_201910</li><li>年维度拆分,如test_2019</li></ul></li><li><strong>按主键范围拆分：</strong>例如【1,200w】主键在一个表，【200w，400w】主键在一个表。优点是单表数据量可控。缺点是流量无法分摊，写操作集中在最后面的表。</li><li><strong>中间表映射：</strong>表随意拆分，引入中间表记录查询的字段值，以及它对应的数据在哪个表里。优点是灵活。确定是引入中间表让流程变复杂。</li><li><strong>hash切分：</strong>sharding_key%N。优点是数据分片均匀，流量分摊。缺点是扩容需要迁移数据，跨节点查询问题。</li><li><strong>按分区拆分：</strong>hash,range等方式。不建议，因为数据其实难以实现水平扩展。</li></ul></li></ul></li><li><strong>sharding_key（分表字段）选择：</strong>尽量选择查询频率最高的字段，然后根据表拆分方式选择字段。</li><li><strong>代码改造：</strong>修改代码里的查询、更新语句，以便让其适应分库分表后的情况。</li><li><strong>数据迁移：</strong>最简单的就是停机迁移，复杂点的就是不停机迁移，要考虑增量同步和全量同步的问题。<ol><li><strong>全量同步：</strong>老库到新库的数据迁移，要控制好迁移效率，解决增量数据的一致性。<ol><li><strong>定时任务：</strong>定时任务查老库写新库</li><li><strong>中间件：</strong>使用中间件迁移数据</li></ol></li><li><strong>增量同步：</strong>老库迁移到新库期间，新增删改命令的落库不能出错<ol><li><strong>同步双写：</strong>同步写新库和老库；</li><li><strong>异步双写（推荐）：</strong> 写老库，监听binlog异步同步到新库</li><li><strong>中间件同步工具：</strong>通过一定的规则将数据同步到目标库表</li></ol></li></ol></li><li><strong>数据一致性校验和补偿：</strong>假设采用异步双写方案，在迁移完成后，逐条对比新老库数据，<strong>一致则跳过，不一致则补偿：</strong><ol><li>新库存在，老库不存在：新库删除数据</li><li>新库不存在，老库存在：新库插入数据</li><li>新库存在、老库存在：比较所有字段，不一致则将新库更新为老库数据</li></ol></li><li><strong>灰度切读：</strong>灰度发布指黑（旧版本）与白（新版本）之间，让一些用户继续用旧版本，一些用户开始用新版本，如果用户对新版本没什么意见，就逐步把所有用户迁移到新版本，实现平滑过渡发布。<strong>原则：</strong><ol><li>有问题及时切回老库</li><li>灰度放量先慢后快，每次放量观察一段时间</li><li>支持灵活的规则：门店维度灰度、百 (万)分比灰度</li></ol></li><li><strong>停老用新：</strong>下线老库，用新库读写。</li></ol><h2 id="分库分表步骤详细"><a href="#分库分表步骤详细" class="headerlink" title="分库分表步骤详细"></a>分库分表步骤详细</h2><h3 id="分库分表的原则：能不分就不分"><a href="#分库分表的原则：能不分就不分" class="headerlink" title="分库分表的原则：能不分就不分"></a>分库分表的原则：能不分就不分</h3><ol><li><p><strong>优先MySQL调优，能不分就不分</strong></p><p>数据量能稳定在千万级，近几年不会到达亿级，其实是不用着急拆的，先尝试MySQL调优，优化读写性能。只有在MySQL调优已经无法解决慢查询问题时，才可以考虑分库分表。</p></li><li><p><strong>分片数量尽量少</strong>。</p><p>分片尽量均匀分布在多个 DataHost 上，因为一个查询 SQL 跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量。</p></li><li><p><strong>不要一个事务里跨越多个分片查询</strong></p><p>尽量不要在一个事务中的 SQL 跨越多个分片，分布式事务一直是个不好处理的问题。</p></li></ol><h3 id="目标评估"><a href="#目标评估" class="headerlink" title="目标评估"></a>目标评估</h3><p>评估需要拆分成几个库、几个表。</p><p><strong>举例：</strong>当前20亿，5年后评估为100亿。分几个表? 分几个库?</p><p><strong>解答</strong>：一个合理的答案，1024个表，16个库按1024个表算，拆分完单表200万，5年后为1000万.1024个表*200w≈100亿</p><h3 id="表拆分"><a href="#表拆分" class="headerlink" title="表拆分"></a>表拆分</h3><h4 id="业务层面拆分"><a href="#业务层面拆分" class="headerlink" title="业务层面拆分"></a>业务层面拆分</h4><h5 id="混合业务拆分"><a href="#混合业务拆分" class="headerlink" title="混合业务拆分"></a>混合业务拆分</h5><p>将混合业务拆分为独立业务。<strong>业务场景举例：</strong></p><ul><li><strong>电商网站：</strong>一个典型的混合业务，包含用户信息、订单信息、商品信息等。可以将用户信息、订单信息和商品信息分别拆分到不同的库或表中，以减少数据冗余并提高访问效率。</li><li><strong>社交媒体平台：</strong>含用户信息、好友关系、动态信息等。可将用户信息和好友关系分离存储，以便更好支持好友关系的查询和更新。</li><li><strong>在线游戏：</strong>涉及角色信息、道具信息、战斗日志等。可以将角色信息和道具信息拆分到不同的表中，以提升查询效率，并将战斗日志存储到日志数据库中，以减轻主数据库的负载。</li><li><strong>物流系统：</strong>包含订单信息、配送信息、运输信息等。可以将订单信息、配送信息和运输信息分别拆分到不同的表中，以便更好地支持订单的查询和跟踪。</li></ul><h5 id="冷热分离"><a href="#冷热分离" class="headerlink" title="冷热分离"></a>冷热分离</h5><p>将常用的“热”数据和不常使用的“冷”数据分开存储。即在处理数据时将数据库分成冷库和热库，冷库存放那些走到终态、不常使用的数据，热库存放还需要修改、经常使用的数据。</p><p><strong>什么情况下可以使用冷热分离？</strong></p><ol><li><strong>数据走到终态后只有读没有写的需求。</strong>例如订单完结后基本只会读不会改。</li><li><strong>用户能接受新旧数据分开查询。</strong>比如某电商网站默认只让查询3个月内的订单，若要查询3个月前的订单，还需要访问其他的页面。</li></ol><p><strong>业务场景举例：</strong></p><ul><li><strong>邮件系统：</strong>邮件系统中最近邮件是用户经常访问和修改的，三个月前的邮件或已归档的邮件不经常访问的。可以将用户的收件箱、发件箱里最近三个月的邮件放在一个库里（热库），之前的邮件或者已读的邮件放在另一个库里（冷库）。</li><li><strong>日志系统：</strong>在大型应用中，日志数据是非常庞大的，但并不是所有日志都需要经常查询或分析。可以将最近一段时间的活动日志存放在热库中，而将过去的历史日志存放在冷库中，以减轻热库的负载和优化查询性能。</li><li><strong>社交媒体平台</strong>：社交媒体平台上的用户数据量通常很大，但是只有少部分用户是活跃的，并且只有少量用户的数据会频繁访问和更新，如果所有用户都放在同一个库里，势必会影响活跃用户的查询效率。可以将活跃用户的个人信息、好友关系等存放在热库中，而将不活跃用户的数据存放在冷库中，以提升热库的性能和减少冷库的存储成本。</li><li><strong>电商平台：</strong>电商平台上的商品数据也可以进行冷热分离。热库中存放热门商品的基本信息和库存等，以支持频繁的查询和更新操作，而将不活跃或下架的商品信息存放在冷库中，以减少热库的负载和优化查询性能。</li><li><strong>客服工单：</strong>在我们日常操作时，经常能看到查询历史工单时会有个“近三个月工单”的选项，实际业务场景中，用户基本只会关注近三个月工单，而且这些工单也会经常需要进行修改、删除的操作，而对很早期的历史订单基本就没有修改、删除的需求，只有少量的查询需求。</li></ul><h4 id="数据层面拆分"><a href="#数据层面拆分" class="headerlink" title="数据层面拆分"></a>数据层面拆分</h4><ul><li><strong>按日期拆分：</strong>这种使用方式比较普遍，尤其是按照日期维度的拆分，其实在程序层面的改动很小，但是扩展性方面的收益很大。<ul><li>日维度拆分，如test_20191021</li><li>月维度拆分,如test_201910</li><li>年维度拆分,如test_2019</li></ul></li><li><strong>按主键范围拆分：</strong>例如【1,200w】主键在一个表，【200w，400w】主键在一个表。优点是单表数据量可控。缺点是流量无法分摊，写操作集中在最后面的表。</li><li><strong>中间表映射：</strong>表随意拆分，引入中间表记录查询的字段值，及它对应的数据在哪个表里。虽然灵活但是引入中间表让流程变复杂。</li><li><strong>hash切分：</strong>sharding_key%N。优点是数据分片均匀，流量分摊。缺点是扩容需要迁移数据，跨节点查询问题。</li><li><strong>按分区拆分：</strong>hash,range等方式。不建议，因为数据其实难以实现水平扩展。</li></ul><h3 id="分表字段（sharding-key）选择"><a href="#分表字段（sharding-key）选择" class="headerlink" title="分表字段（sharding_key）选择"></a>分表字段（sharding_key）选择</h3><p>最佳的分表字段应该是能够让数据分布均匀、频繁查询的字段及不可变的字段。通过选择最佳的分表字段，可提高系统性能和查询效率。</p><h4 id="常用字段"><a href="#常用字段" class="headerlink" title="常用字段"></a>常用字段</h4><ul><li><strong>主键ID：</strong>频繁查询并且唯一，非常适合作分表字段。<em>例如</em>，在用户表中，用户ID作为分表字段是一个不错的选择，因为用户ID是唯一的，而且在查询用户信息时经常会用到。</li><li><strong>时间字段：</strong>如果业务需要按时间范围查询数据，那么选择时间字段作为分表字段是合理的。<em>例如</em>，在日志表中，可以选择时间戳字段作为分表字段，以便按天、按月或按年分割数据，方便查询和维护。</li><li><strong>地理信息字段：</strong>如果业务需要按地区查询数据，那么选择地理信息字段作为分表字段是合适的。<em>例如</em>，在订单表中，可以选择订单地区字段作为分表字段，以便将订单数据按地区进行拆分，方便查询和扩展。</li><li><strong>关联字段：</strong>如果业务需要频繁进行关联查询，那么选择订单号等关联字段作为分表字段。<em>例如</em>，在订单表中，可以选择订单号作为分表字段，因为订单号唯一且包含业务信息，并且日常查询、关联查询都是根据订单号查询的，很少根据id查询，方便查询和维护。</li></ul><h4 id="选择分表字段的原则"><a href="#选择分表字段的原则" class="headerlink" title="选择分表字段的原则"></a>选择分表字段的原则</h4><ol><li><p><strong>数据分布均匀</strong></p><p>最佳的分表字段应该是能够让数据分布均匀的字段，这样可以避免某个表的数据过多，导致查询效率降低。在用户表中，如果以地区作为分表字段，可能会导致某些地区的数据过多，而某些地区的数据过少。</p></li><li><p><strong>频繁查询的字段</strong></p><p>尽量选择查询频率最高的字段（例如主键id），然后根据表拆分方式选择字段。在一个订单表中，如果经常需要根据用户ID查询订单信息，那么以用户ID作为分表字段是一个不错的选择。</p></li><li><p><strong>不可变字段</strong></p><p>最佳的分表字段还应该是不可变的字段，这样可以避免在数据迁移时出现问题。在一个商品表中，如果选择以商品名称作为分表字段，那么当商品名称发生变化时，就需要将数据移动到不同的表中，这样会增加系统的复杂度。</p></li></ol><h3 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a>代码改造</h3><p>修改代码里的查询、更新语句，以便让其适应分库分表后的情况。</p><p><strong>查询语句改造：</strong></p><ul><li><p><strong>单库查询改为跨库查询：</strong>对于需要查询的字段，需要明确指定查询的库和表，以避免查询到错误的数据。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;            # 原查询语句</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> db.table_name <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;     # 修改后：其中 db 为目标数据库，table_name 为目标表</span><br></pre></td></tr></table></figure></li><li><p><strong>单表查询改为跨表查询：</strong>例如投诉记录表根据哈希取余的方式分成10个表，如果id%1=0，则查0号表complaint_records_0。</p></li></ul><h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>最简单的就是停机迁移，复杂点的就是不停机迁移，要考虑增量同步和全量同步的问题。</p><h4 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h4><p>老库迁移到新库期间，增删改命令的落库不能出错</p><ul><li>同步双写：同步写新库和老库；</li><li><strong>异步双写（推荐）：</strong> 写老库，监听binlog异步同步到新库</li><li>中间件同步工具：通过一定的规则将数据同步到目标库表</li></ul><h4 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h4><p>老库到新库的数据迁移，要控制好迁移效率，解决增量数据的一致性。</p><ul><li><strong>定时任务查老库写新库</strong></li><li>使用中间件迁移数据，例如<code>Dbmate、Apache NiFi、Ladder、Phinx、Flyway、TiDB</code>等。</li></ul><h3 id="数据一致性校验和补偿"><a href="#数据一致性校验和补偿" class="headerlink" title="数据一致性校验和补偿"></a>数据一致性校验和补偿</h3><p>假设采用异步双写方案，在迁移完成后，逐条对比新老库数据，一致则跳过，<strong>不一致则补偿：</strong></p><ul><li>新库存在，老库不存在：新库删除数据</li><li>新库不存在，老库存在：新库插入数据</li><li>新库存在、老库存在：比较所有字段，不一致则将新库更新为老库数据</li></ul><h3 id="灰度切读"><a href="#灰度切读" class="headerlink" title="灰度切读"></a>灰度切读</h3><p>灰度发布指黑（旧版本）与白（新版本）之间，让一些用户继续用旧版本，一些用户开始用新版本，如果用户对新版本没什么意见，就逐步把所有用户迁移到新版本，实现平滑过渡发布。<strong>遵循原则如下：</strong></p><ul><li>有问题及时切回老库</li><li>灰度放量先慢后快，每次放量观察一段时间</li><li>支持灵活的规则：门店维度灰度、百 (万)分比灰度</li></ul><h3 id="停旧库、写新库"><a href="#停旧库、写新库" class="headerlink" title="停旧库、写新库"></a>停旧库、写新库</h3><p>下线老库，用新库读写。</p>]]></content>
    
    
    <summary type="html">‌数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，目标是将低效SQL语句转换为高效等效语句。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库-查询优化</title>
    <link href="https://southernfish.github.io/pages/database/db-mysql-6-query/"/>
    <id>https://southernfish.github.io/pages/database/db-mysql-6-query/</id>
    <published>2025-07-26T07:30:36.000Z</published>
    <updated>2025-09-17T07:51:48.701Z</updated>
    
    <content type="html"><![CDATA[<p>数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，核心目标是将低效SQL语句转换为高效等效语句。人工智能自动优化技术通过重写SQL语句实现性能提升。优化技术演变历经三代工具：第一代解析执行计划，第二代推荐索引优化，第三代提出语法改进建议。优化策略贯穿数据库生命周期，其中设计阶段优化成本最低且收益最大。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/139088747">【MySQL调优】如何进行MySQL调优？从参数,数据,建模,索引,SQL语句等方向，三万字详细解读MySQL的性能优化方案（2024版）</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130787410">MySQL高级篇——关联查询和子查询优化</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130790354">MySQL高级篇——排序、分组、分页优化</a></p></blockquote><h1 id="数据库引擎查询流程"><a href="#数据库引擎查询流程" class="headerlink" title="数据库引擎查询流程"></a>数据库引擎查询流程</h1><h2 id="通用查询流程"><a href="#通用查询流程" class="headerlink" title="通用查询流程"></a>通用查询流程</h2><ol><li><strong>解析 SQL 语句：</strong>数据库引擎先将 SQL 语句解析成内部的执行计划，包括了查询哪些数据表、使用哪些索引、如何连接多个数据表等信息。</li><li><strong>优化查询计划：</strong>数据库引擎对内部的执行计划进行优化，根据查询的复杂度、数据量和系统资源等因素，选择最优的执行计划。</li><li><strong>执行查询计划：</strong>数据库引擎根据执行计划，通过 I/O 操作读取数据表的数据，进行数据过滤、排序、分组等操作，最终返回结果集。</li><li><strong>缓存查询结果：</strong>如果查询结果集比较大或者查询频率较高，数据库引擎会将查询结果缓存在内存中，以加速后续的查询操作。</li></ol><h2 id="MySQL-中-select-的执行流程"><a href="#MySQL-中-select-的执行流程" class="headerlink" title="MySQL 中 select 的执行流程"></a>MySQL 中 select 的执行流程</h2><ol><li><strong>连接器：</strong>主要作用是建立连接、管理连接及校验用户信息。</li><li><strong>查询缓冲：</strong>查询缓冲是以key-value的方式存储，key就是查询语句，value就是查询语句的查询结果集；如果命中直接返回。<ul><li><strong>8.0版本废弃</strong>：注意，MySQL 8.0已经删除了查询缓冲。从MySQL 5.6版本开始，官方将Query Cache设置为了默认关闭。</li><li><strong>原因</strong>：官方给出的原因是此功能比较鸡肋，而且减少性能的可变性确实通常比提高峰值吞吐量更重要，尤其是在生产环境中。稳定的性能可以确保用户体验的一致性，并减少系统出现瓶颈或宕机的风险。</li><li><strong>方案</strong>：官方给出了所替代的解决方案建议——使用第三方工具客户端缓存ProxySQL 来代替Query Cache。</li></ul></li><li><strong>分析器：</strong>词法句法分析生成语法树。</li><li><strong>优化器：</strong>指定执行计划，选择查询成本最小的计划。</li><li><strong>执行器：</strong>根据执行计划，从存储引擎获取数据，并返回客户端</li></ol><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250727122422644.png" alt="image-20250727122422644"></p><h2 id="ProxySQL"><a href="#ProxySQL" class="headerlink" title="ProxySQL"></a>ProxySQL</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>一个MySQL中间件，一个高性能的 MySQL 代理，一个用 C++ 开发的轻量级产品。旨在提高 MySQL 服务器的性能、可伸缩性和可用性。MySQL官方推荐的Query Cache替换方案。</p><p><strong>同类产品：</strong>DBproxy、MyCAT、OneProxy</p><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">sudo yum install proxysql</span><br><span class="line"># 配置： 修改<span class="operator">/</span>etc<span class="operator">/</span>proxysql.cnf 直接配置，或者访问管理接口配置</span><br><span class="line"><span class="comment">-- 连接到管理接口</span></span><br><span class="line">mysql <span class="operator">-</span>u admin <span class="operator">-</span>padmin <span class="operator">-</span>h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">-</span>P <span class="number">6032</span></span><br><span class="line"><span class="comment">-- 添加MySQL服务器</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_servers (hostgroup_id, hostname, port) <span class="keyword">VALUES</span> (<span class="number">0</span>, <span class="string">&#x27;192.168.1.100&#x27;</span>, <span class="number">3306</span>);</span><br><span class="line"><span class="comment">-- 加载配置到运行时</span></span><br><span class="line">LOAD MYSQL SERVERS <span class="keyword">TO</span> RUNTIME;</span><br><span class="line"><span class="comment">-- 保存配置到磁盘</span></span><br><span class="line">SAVE MYSQL SERVERS <span class="keyword">TO</span> DISK;</span><br></pre></td></tr></table></figure><h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><ul><li><p><strong>查询缓存</strong></p></li><li><p><strong>负载均衡</strong>：支持自动摘除宕机的DB</p></li><li><p>读写分离</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 主库</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_servers (hostgroup_id, hostname, port) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">&#x27;192.168.1.101&#x27;</span>, <span class="number">3306</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从库</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_servers (hostgroup_id, hostname, port) <span class="keyword">VALUES</span> (<span class="number">20</span>, <span class="string">&#x27;192.168.1.102&#x27;</span>, <span class="number">3306</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_servers (hostgroup_id, hostname, port) <span class="keyword">VALUES</span> (<span class="number">20</span>, <span class="string">&#x27;192.168.1.103&#x27;</span>, <span class="number">3306</span>);</span><br><span class="line"><span class="comment">-- 将所有写操作（INSERT、UPDATE、DELETE）定向到主库</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;^INSERT&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;^UPDATE&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">1</span>, <span class="string">&#x27;^DELETE&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 将所有读操作（SELECT）定向到从库</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">1</span>, <span class="string">&#x27;^SELECT&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">-- 加载并保存配置</span></span><br><span class="line">LOAD MYSQL SERVERS <span class="keyword">TO</span> RUNTIME;</span><br><span class="line">SAVE MYSQL SERVERS <span class="keyword">TO</span> DISK;</span><br></pre></td></tr></table></figure></li><li><p>实时监控</p></li><li><p>连接池</p></li><li><p>动态加载配置</p></li><li><p>访问控制</p></li><li><p>ProxySQL集群</p></li></ul><h1 id="连接查询优化"><a href="#连接查询优化" class="headerlink" title="连接查询优化"></a>连接查询优化</h1><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><ul><li><strong>外连接小表驱动大表</strong>：LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。</li><li><strong>内连接驱动表由优化器决定</strong>：INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。</li><li><strong>被驱动表优先创建索引</strong>：被驱动表的JOIN字段要创建索引；</li><li><strong>两表连接字段类型必须一致</strong>：两个表JOIN字段数据类型保持绝对一致。防止自动类型转换导致索引失效。</li><li><strong>关联替代子查询</strong>：能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)。子查询是一个SELECT查询的结果作为另一个SELECT语句的条件。</li><li><strong>多次查询代替子查询</strong>：不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li><li>衍生表建不了索引</li></ul><h2 id="被驱动表优先创建索引"><a href="#被驱动表优先创建索引" class="headerlink" title="被驱动表优先创建索引"></a>被驱动表优先创建索引</h2><p>外连接查询时，右表就是被驱动表，建议加索引。</p><p><strong>原因：</strong>因为MySQL连接查询底层是先查过滤条件下的左表，按左表查询的结果，再以<strong>连接字段</strong>作为条件查询结果，所以右表的连接字段加索引，将极大地提高查询性能。</p><blockquote><p><strong>驱动表与被驱动表：</strong></p><ul><li><strong>驱动表：</strong>在连接操作中，驱动表是首先被读取的表。MySQL会从驱动表中读取数据行，然后在被驱动表中寻找匹配的行。</li><li><strong>被驱动表：</strong>被驱动表是连接操作中第二个被读取的表。对于驱动表中的每一行，MySQL会在被驱动表中寻找匹配的行。</li></ul></blockquote><h2 id="左外连接：优先右表创建索引，连接字段类型要一致"><a href="#左外连接：优先右表创建索引，连接字段类型要一致" class="headerlink" title="左外连接：优先右表创建索引，连接字段类型要一致"></a>左外连接：优先右表创建索引，连接字段类型要一致</h2><p><strong>优先右表创建索引：</strong>因为左表是查所有数据，右表是按条件查询，所以右表的条件字段创建索引价值更高一点。</p><p><strong>连接字段类型要一致：</strong>两个表的card字段一定要是同一类型，如果类型不同会导致<strong>隐式类型转换</strong>从而索引失效。 </p><h2 id="内连接：驱动表由数据量和索引决定"><a href="#内连接：驱动表由数据量和索引决定" class="headerlink" title="内连接：驱动表由数据量和索引决定"></a>内连接：驱动表由数据量和索引决定</h2><p>内连接查到的是交集，两个表谁做驱动表查的结果是一样的。所以查询优化器会<strong>根据查询成本</strong>选择驱动表。驱动表就是主表，被驱动表就是从表。<strong>驱动表的选择依据：</strong></p><ul><li><strong>没索引的表：</strong>当只有一个表有索引时，查询优化器会选择没索引的表作为驱动表。</li><li><strong>小表：</strong>当两个表都有或都没有索引时，数据量小的表为驱动表。</li></ul><h2 id="join语句原理"><a href="#join语句原理" class="headerlink" title="join语句原理"></a>join语句原理</h2><p>join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是嵌套循环(Nested Loop Join)。如果关联表的数据量很大，则join关联的执行时间会很长。在MySQL5.5以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。</p><ol><li><p><strong>驱动表和被驱动表</strong>：驱动表就是主表，被驱动表就是从表、非驱动表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 对于内连接来说：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ... </span><br><span class="line"># 优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过explain关键字可以查看。</span><br><span class="line"># 对于外连接来说：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> a(f1 <span class="type">INT</span>, f2 <span class="type">INT</span>, INDEX(f1)) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> b(f1 <span class="type">INT</span>, f2 <span class="type">INT</span>) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> a <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> b <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line"># 测试</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">WHERE</span> (a.f2<span class="operator">=</span>b.f2);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">AND</span> (a.f2<span class="operator">=</span>b.f2);</span><br><span class="line"># 通常，大家会认为A就是驱动表，B就是被驱动表。但也未必。</span><br></pre></td></tr></table></figure></li><li><p><strong>Simple Nested-Loop Join (简单嵌套循环连接)</strong></p><p>算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到result.. 以此类推，驱动表A中的每一条记录与被驱动表B的记录进行判断：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726165251064.png" alt="image-20250726165251064"></p><p>这种方式效率是非常低的，以上述表A数据100条，表B数据1000条计算，则A*B=10万次。开销统计如下:</p><table><thead><tr><th align="left">开销统计</th><th align="left">SNLJ</th></tr></thead><tbody><tr><td align="left">外表扫描次数</td><td align="left">1</td></tr><tr><td align="left">内表扫描次数</td><td align="left">A</td></tr><tr><td align="left">读取记录数</td><td align="left">A+B * A</td></tr><tr><td align="left">JOIN比较次数</td><td align="left">B * A</td></tr><tr><td align="left">回表读取记录次数</td><td align="left">0</td></tr></tbody></table></li></ol><p>​    当然mysql肯定不会这么粗暴的去进行表的连接，所以就出现了后面的两种对Nested-Loop Join优化算法。</p><ol start="3"><li><p><strong>Index Nested-Loop Join （索引嵌套循环连接）</strong></p><p>Index Nested-Loop Join其优化的思路主要是为了减少内存表数据的匹配次数，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内存表的每条记录去进行比较，这样极大的减少了对内存表的匹配次数。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726165315601.png" alt="image-20250726165315601"></p><p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表（外表）。</p><table><thead><tr><th align="left">开销统计</th><th align="left">SNLJ</th><th>INLJ</th></tr></thead><tbody><tr><td align="left">外表扫描次数</td><td align="left">1</td><td>1</td></tr><tr><td align="left">内表扫描次数</td><td align="left">A</td><td>0</td></tr><tr><td align="left">读取记录数</td><td align="left">A+B * A</td><td>A+B(match)</td></tr><tr><td align="left">JOIN比较次数</td><td align="left">B * A</td><td>A*Index(Height)</td></tr><tr><td align="left">回表读取记录次数</td><td align="left">0</td><td>B(match) (if possible)</td></tr></tbody></table><p>如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p></li><li><p><strong>Block Nested-Loop Join（块嵌套循环连接）</strong></p><p>如果存在索引，那么会使用index的方式进行ioin，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配，这样周而复始，大大增加了!0的次数。为了减少被驱动表的<code>IO</code>次数，就出现了<code>Block Nested-Loop Join</code>的方式。<br>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了 **<code>join buffer缓冲区</code>**，将驱动表join相关的部分数据列(大小受join buffer的限制)缓存到join bufer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和ioinbuffer中的所有驱动表记录进行匹配(内存中操作)，将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p><blockquote><p>注意：</p><p>这里缓存的不只是关联表的列，select后面的列也会缓存起来。</p><p>在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让join buffer中可以存放更多的列。</p></blockquote><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726165457696.png" alt="image-20250726165457696"></p><table><thead><tr><th align="left">开销统计</th><th align="left">SNLJ</th><th>INLJ</th><th>BNIJ</th></tr></thead><tbody><tr><td align="left">外表扫描次数</td><td align="left">1</td><td>1</td><td>1</td></tr><tr><td align="left">内表扫描次数</td><td align="left">A</td><td>0</td><td>A*used_column_size/join_buffer_size+1</td></tr><tr><td align="left">读取记录数</td><td align="left">A+B * A</td><td>A+B(match)</td><td>A+B*(A*used_column_size/join_buffer_size)</td></tr><tr><td align="left">JOIN比较次数</td><td align="left">B * A</td><td>A*Index(Height)</td><td>B*A</td></tr><tr><td align="left">回表读取记录次数</td><td align="left">0</td><td>B(match) (if possible)</td><td>0</td></tr></tbody></table><p>参数设置：</p><ul><li><p><strong><code>block_nested_loop</code><strong>：通过</strong>show variables like ‘%optimizer_switch%</strong> 查看 <strong>block_nested_loop</strong>状态。默认是开启的。</p></li><li><p><strong><code>join_buffer_size</code><strong>：驱动表能不能一次加载完，要看join buffer能不能存储所有的数据，默认</strong>join_buffer_size=256k</strong>。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%join_buffer%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>join_buffer_size的最大值在32位操作系统可以申请4G，而在64位操作系统下可以申请大于4G的Join Buffer空间（64位Windows除外，其大值会被截断为4GB并发出警告）。</p></li><li><p><strong>Join小结</strong></p><ol><li><p><strong>整体效率比较：INLJ &gt; BNLJ &gt; SNLJ</strong></p></li><li><p>永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）（小的度量单位指的是表行数 * 每行大小）</p></li><li><p>为被驱动表匹配的条件增加索引(减少内存表的循环匹配次数)</p></li><li><p>增大join buffer size的大小（一次索引的数据越多，那么内层包的扫描次数就越少）</p></li><li><p>减少驱动表不必要的字段查询（字段越少，join buffer所缓存的数据就越多）</p></li><li><p>Hash Join</p><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p><ul><li><p>Nested Loop：对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。</p></li><li><p>Hash Join是做<strong>大数据集连接</strong>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<strong>散列表</strong>，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p><ul><li><p>这种方式适合于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</p></li><li><p>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<strong>若干不同的分区</strong>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</p></li><li><p>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。Hash Join只能应用于等值连接（如WHERE A.COL1 = B.COL2），这是由Hash的特点决定的。</p></li></ul></li></ul><table><thead><tr><th>类别</th><th>Nested Loop</th><th>Hash Join</th></tr></thead><tbody><tr><td>使用条件</td><td>任何条件</td><td>等值连接(=)</td></tr><tr><td>相关资源</td><td>CPU、磁盘I/0</td><td>内存、临时空间</td></tr><tr><td>特点</td><td>当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果。</td><td>当缺乏索引或者索引条件模糊时，Hash Join比NestedLoop有效。在数据仓库环境下，如果表的纪录数多，效率高。</td></tr><tr><td>缺点</td><td>当索引丢失或者查询条件限制不够时，效率很低;当表的纪录数多时，效率低。</td><td>为建立哈希表，需要大量内存。第一次的结果返回较慢。</td></tr></tbody></table></li></ol></li></ol><hr><h1 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h1><p>MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即<strong>一个SELECT查询的结果作为另一个SELECT语句的条件</strong>。 子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作 。</p><p>子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，<strong>子查询的执行效率不高。</strong>原因：</p><ol><li>执行子查询时，MySQL需要<strong>为内层查询语句的查询结果建立一个临时表</strong> ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表 。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</li><li>子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会 受到一定的影响。</li><li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li></ol><blockquote><p><strong>子查询原理：</strong></p><p>子查询是指在一个SQL语句中嵌套另一个完整的SQL查询。它可以作为主查询的一部分，也可以作为WHERE、FROM或HAVING子句的一部分。子查询的执行顺序是先执行子查询，然后将其结果作为外部查询的条件或数据源。</p></blockquote><h2 id="子查询优化成关联查询"><a href="#子查询优化成关联查询" class="headerlink" title="子查询优化成关联查询"></a>子查询优化成关联查询</h2><p><strong>性能：</strong></p><ul><li>数据量小、过滤条件简单时，子查询效率高一点；数据量大、过滤条件复杂时，关联查询效率高很多。综合考虑，建议关联查询。</li><li><strong>子查询的缺点：</strong><ul><li><strong>嵌套查询：</strong>子查询可能导致嵌套查询，一个子查询套另一个子查询，又套另一个子查询，这会增加查询的复杂性并降低性能。</li><li><strong>数据重复检索：</strong>子查询可能需要对数据进行多次检索，尤其是在相关子查询中。而连接则允许数据库一次性检索所有需要的数据，从而减少I/O操作和计算开销。</li></ul></li><li><strong>语义清晰度</strong>：还是建议使用关联查询，阅读起来更直白、明确，层次结构清晰，后期维护成本也越低，查询次数也一般更低一些。</li></ul><blockquote><p><strong>注意</strong>：如果见到<strong>子查询+范围查询</strong>的SQL，要直接进行优化，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查询每个学生的出生地</span><br><span class="line"><span class="keyword">SELECT</span> id, fullname, birth_city <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> id <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> person_id <span class="keyword">FROM</span> student);</span><br><span class="line"># 优化后</span><br><span class="line"><span class="keyword">SELECT</span> id, fullname, birth_city <span class="keyword">FROM</span> person p <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student s <span class="keyword">ON</span> p.id <span class="operator">=</span> s.person_id;</span><br></pre></td></tr></table></figure><p>因为范围查询会使索引失效，再加上使用子查询，优化前的SQL性能是很慢的。</p></blockquote><p><strong>结论</strong>：能够直接多表关联的尽量<strong>使用连接（JOIN）查询来替代子查询</strong>。连接查询 <strong>不需要建立临时表</strong> ，其 <strong>速度比子查询</strong> 要快 ，如果查询中使用索引的话，性能就会更好。子查询是一个SELECT查询的结果作为另一个SELECT语句的条件。</p><h2 id="多次查询代替子查询"><a href="#多次查询代替子查询" class="headerlink" title="多次查询代替子查询"></a>多次查询代替子查询</h2><p>在复杂SQL中，同一个子查询语句可能在整个SQL中多次出现，这就导致了性能浪费。这种情况下，结合Java代码多次查询而不用子查询，可以使这个重复子查询语句只查一次，从而提高性能。</p><blockquote><p><strong>误区</strong>：通常可能认为多次查询肯定没一次查询快，因为MySQL查询两次肯定就有两次I/O调用过程，而查询一次只有一次调用过程。</p><p>如果是简单SQL，只调用了一次子查询，那肯定是子查询快，当同一个子查询语句可能在整个SQL中多次出现时，用Java代码，肯定是更快的，虽然IO次数多，但这么多次子查询缩减成了一次，性能是快了的。</p></blockquote><p><strong>结论</strong>：不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</p><h2 id="临时表代替子查询"><a href="#临时表代替子查询" class="headerlink" title="临时表代替子查询"></a>临时表代替子查询</h2><p>如果一个复杂SQL中，多次用到了同一个子查询，可以尝试将其抽离出来，优化成临时表。这样可以避免重复计算、减少查询次数，从而提高查询性能。</p><p>并且可维护性也有效提高，每次修改时只需要修改这一个临时表，而不需要手动一个个修改子查询语句。</p><p>​    </p><blockquote><p>最终结论：<strong>尽量不要使用NOT IN或者NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</strong></p></blockquote><hr><h1 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h1><h2 id="排序优化建议"><a href="#排序优化建议" class="headerlink" title="排序优化建议"></a>排序优化建议</h2><blockquote><p><strong>问题</strong>：在 WHERE 条件字段上加索引，但是为什么在 <strong>ORDER BY 字段上还要加索引</strong>呢？</p></blockquote><p>MySQL支持两种排序方式： </p><ul><li><strong>Index排序：</strong>索引排序中，索引可以保证数据的有序性，不需要再进行排序，<strong>效率更高，推荐使用</strong>。</li><li><strong>FileSort排序：</strong>FileSort 排序则一般在<strong>内存中进行排序</strong>，占用<strong>CPU较多</strong>。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，<strong>效率较低。</strong></li></ul><p><strong>优化建议：</strong></p><ul><li><strong>优化器自动选择排序方式：</strong>MySQL支持索引排序和FileSort排序，索引保证记录有序性，性能高，推荐使用。FileSort排序是内存中排序，数据量大时产生临时文件在磁盘里排序，效率低还占用大量CPU。并不是说FileSort一定效率低，一些情况它可能效率高。例如没覆盖索引的左模糊、“不等于”查询，全表扫描效率比索引遍历再回表更高。</li><li>要符合最左前缀：where后条件和order by字段创建联合索引，顺序要需要符合最左前缀。例如索引(a,b,c)，查询where a=1 order by b,c。</li><li><strong>范围查询右边排序索引失效：</strong>例如索引(a,b,c)，查询where a&gt;1 order by b,c，导致b,c排序不能走索引，需要filesort。</li><li><strong>要么全升序要么全降序：</strong>排序顺序必须要么全部DESC，要么全部ASC。乱序会导致索引失效。</li><li><strong>待排序数量大时会导致索引失效：</strong>待排序数据量大约超过一万个，就不走索引走filesort了。建议用limit和where过滤，减少数据量。数据量很大时，索引排序完需要回表查所有数据，性能很差，还不如FileSort在内存中排序效率高。并不是说使用limit一定会走索引排序，关键看的是数据量，数据量过大时优化器会使用FileSort排序。</li><li><strong>优先范围字段加索引：</strong>当【范围条件】和【group by 或者 order by】的字段出现二选一时，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。这样即使范围查询导致排序索引失效，效率依然比只索引排序字段时候高。如果只能过滤一点点，那就优先索引放到排序字段上。</li><li><strong>调优FileSort ：</strong>无法使用 Index 排序时，需要对 FileSort 方式进行调优。例如增大sort_buffer_size（排序缓冲区大小）和 max_length_for_sort_data（排序数据最大长度）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 不加索引直接走filesort排序</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid;</span><br><span class="line"># 加索引后，<span class="keyword">order</span> <span class="keyword">by</span> 时不limit导致数据量过大,从而索引失效：</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age,classId,name);</span><br><span class="line"># 索引失败。没有limit</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid;</span><br><span class="line"># 索引成功，key_len为<span class="number">73</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid LIMIT <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><p><strong>order by 时顺序错误，索引失效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 创建索引age,classid,stuno</span><br><span class="line"># <span class="keyword">call</span> proc_drop_index(<span class="string">&#x27;atguigudb2&#x27;</span>,<span class="string">&#x27;student&#x27;</span>);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_stuno <span class="keyword">ON</span> student (age,classid,stuno);</span><br><span class="line"># 索引失效，不符合最左前缀</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid LIMIT <span class="number">10</span>;</span><br><span class="line"># 索引失效，不符合最左前缀</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid,name LIMIT <span class="number">10</span>;</span><br><span class="line"># 索引失效，不符合最左前缀</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classid<span class="operator">=</span><span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,stuno;</span><br><span class="line"># 全走索引，虽然不符合最左前缀，但因为查询量小，优化器先排序三个字段，再<span class="keyword">where</span>找<span class="number">10</span>个返回。</span><br><span class="line"># 优化器认为索引比filesort效率高，就用了索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classid<span class="operator">=</span><span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,stuno LIMIT <span class="number">10</span>;</span><br><span class="line"># 索引成功，符合最左前缀</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid,stuno LIMIT <span class="number">10</span>;</span><br><span class="line"># 索引成功，符合最左前缀</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>order by 时规则不一致，索引失效（顺序错，不索引；方向反，不索引）</strong></p><p>必须符合最左前缀和“全升序或全降序”</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建索引age,classid,stuno</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_stuno <span class="keyword">ON</span> student (age,classid,stuno);</span><br><span class="line"># 没符合“全升序或全降序”，索引失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>,classid <span class="keyword">ASC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"># 没符合最左前缀，索引失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid <span class="keyword">DESC</span>,name <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"># 没符合“全升序或全降序”，索引失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>,classid <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"># 符合最左前缀，符合“全升序或全降序”，索引成功</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>,classid <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>limit数据量小时，不满足最左前缀也可能走索引，先排序再where筛选。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_stuno <span class="keyword">ON</span> student (age,classid,stuno);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age,classId,name);</span><br><span class="line"># 都走了索引。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid LIMIT <span class="number">10</span>;</span><br><span class="line"># 都走了索引。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid,name;</span><br><span class="line"># 都没用索引，不符合最左前缀</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classid<span class="operator">=</span><span class="number">45</span> <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br><span class="line"># 全走了索引。因为limit数据量小，优化器直接先用排序字段索引排序，然后再<span class="keyword">where</span>筛选<span class="number">10</span>个</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classid<span class="operator">=</span><span class="number">45</span> <span class="keyword">order</span> <span class="keyword">by</span> age limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>范围查找导致索引失效</strong>：下面有索引(userDbid,addressDbid,createTime)，userDbid,addressDbid走了索引，因为addressDbid是范围查找，导致createTime索引失败。</p><h2 id="范围查询时索引字段选择"><a href="#范围查询时索引字段选择" class="headerlink" title="范围查询时索引字段选择"></a>范围查询时索引字段选择</h2><ol><li><strong>mysql自动选择最优的方案：</strong>两个索引同时存在，mysql自动选择最优的方案。（对于这个例子，mysql选择 idx_age_stuno_name）。但是， 随着数据量的变化，选择的索引也会随之变化的。</li><li><strong>过滤比例高时优先过滤字段加索引：</strong>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</li></ol><blockquote><p>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序。</p></blockquote><p>案例分析：<strong>查询年龄为30岁的，且学生编号小于101000的学生，按用户名称排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME ;</span><br><span class="line"># 结论：type 是 <span class="keyword">ALL</span>，即最坏的情况。Extra 里还出现了 <span class="keyword">Using</span> filesort,也是最坏的情况。优化是必须的。</span><br></pre></td></tr></table></figure><p><strong>为了去掉 filesort 创建索引，查询效率高了一点</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建新索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> student(age,NAME);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME;</span><br><span class="line">只有age走了索引： 优化掉了 <span class="keyword">using</span> filesort</span><br></pre></td></tr></table></figure><p><strong>尽量让where的过滤条件和排序使用上索引，发现查询效率更高</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 建一个三个字段的组合索引，发现<span class="keyword">using</span> filesort依然存在：</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_stuno_name <span class="keyword">ON</span> student (age,stuno,NAME);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME;</span><br></pre></td></tr></table></figure><p>发现<code>using filesort</code>依然存在，所以name并没有用到索引，而且type还是range光看名字其实并不美好。因为<strong>stuno是一个范围过滤</strong>，所以索引后面的字段不会在使用索引了 。但分析发现<code>filesort</code>运行速度比索引还快，而且快了很多，几乎一瞬间就出现了结果。</p><p><strong>原因</strong>：所有的排序都是在条件过滤之后才执行的。所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。相对的 <code>stuno&lt;101000</code> 这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。</p><h2 id="filesort-算法"><a href="#filesort-算法" class="headerlink" title="filesort 算法"></a>filesort 算法</h2><h3 id="双路排序和单路排序"><a href="#双路排序和单路排序" class="headerlink" title="双路排序和单路排序"></a>双路排序和单路排序</h3><p><strong>双路排序 （慢）</strong></p><ul><li><strong>MySQL 4.1之前</strong>是使用双路排序 ，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和 order by列 ，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段 。</li></ul><p>取一批数据，要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在mysql4.1之后，出现了第二种 改进的算法，就是单路排序。</p><p><strong>单路排序 （快）</strong></p><p>从磁盘读取查询需要的 所有列 ，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p><p><strong>结论及引申出的问题</strong></p><ul><li>由于单路是后出的，<strong>总体而言好过双路</strong></li><li>但是用单路有问题<ul><li>在sort_buffer中，单路要比多路多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了<strong>sort_buffer</strong>的容量，导致每次只能取<strong>sort_buffer</strong>容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排…从而多次I/O。</li><li>单路本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</li></ul></li></ul><h3 id="调优filesort"><a href="#调优filesort" class="headerlink" title="调优filesort"></a><strong>调优</strong>filesort</h3><ol><li><p><strong>尝试提高 sort_buffer_size</strong></p><p>不管用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程<br>(connection)的1M-8M之间调整。MySQL5.7，InnoDB存储引擎默认值是1048576字节，1MB。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="operator">%</span>sort_buffer_size<span class="operator">%</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string">+---------------------------+-----------+</span></span><br><span class="line"><span class="string">| Variable_name             | Value     |</span></span><br><span class="line"><span class="string">+---------------------------+-----------+</span></span><br><span class="line"><span class="string">| innodb_sort_buffer_size   | 1048576   |</span></span><br><span class="line"><span class="string">| myisam_sort_buffer_size   | 8388608   |</span></span><br><span class="line"><span class="string">| sort_buffer_size          | 262144    |</span></span><br><span class="line"><span class="string">+---------------------------+-----------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>尝试提高 max_length_for_sort_data</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%max_length_for_sort_data%&#x27;</span>; # 默认<span class="number">1924</span>字节</span><br></pre></td></tr></table></figure><p>提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort buffer size的概率就增大，明显症状是高的磁盘IO活动和低的处理器使用率。如果需要返回的列的总长度大于max_length_for_sort data，使用双路算法，否则使用单路算法.1024-8192字节之间调整。</p></li><li><p><strong>Order by 时select * 是一个大忌。最好只Query需要的字段。</strong></p><ul><li>当Query的字段大小总和小于<code>max_ength_for_sort_data</code>，而且排序字段不是TEXTBLOB 类型时，会用改进后的算法–单路排序，否则用老算法——多路排序。</li><li>两种算法的数据都有可能超出<code>sort_bufer_size</code>的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/0，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size。</li></ul></li></ol><hr><h1 id="分组优化"><a href="#分组优化" class="headerlink" title="分组优化"></a>分组优化</h1><ul><li><p><strong>跟排序优化近似：</strong>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</p></li><li><p><strong>最左前缀：</strong>group by 先排序再分组，遵照索引建的最佳左前缀法则</p></li><li><p><strong>调优FileSort</strong>：当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置</p></li><li><p><strong>where效率高于having</strong>，能写在where限定的条件就不要写在having中了。where是分组前过滤，having是分组后过滤。</p></li><li><p><strong>尽量不排序分组、节省cpu：</strong>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。<strong>Order by、group by、distinct这些语句较为耗费CPU</strong>，数据库的CPU资源是极其宝贵的。</p></li><li><p><strong>使用limit：</strong>包含<code>order by、group by、distinct</code>的查询语句，where条件过滤出的结果集请保持1000行以内，否则SQL会很慢。</p></li></ul><hr><h1 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a>分页查询优化</h1><h2 id="深分页查询优化"><a href="#深分页查询优化" class="headerlink" title="深分页查询优化"></a>深分页查询优化</h2><p>一般分页查询时，通过创建<strong>覆盖索引</strong>能够比较好地提高性能。</p><p><strong>目前问题：</strong> offset非常大时，需要查询大量无用的数据量再分页，性能差。</p><p>一个常见问题：limit 2000000,10。此时需要MySQL排序前200000010 记录，仅仅返回2000000~2000010 的记录，其他记录丢弃，查询排序的代价常大。并且<code>select *</code> 需要回表，更耗费时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 直接查询 limit <span class="number">2000000</span>,<span class="number">10</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">2000000</span>,<span class="number">10</span>; </span><br><span class="line"># 优化方案一：主键自增的表：直接查范围之后的<span class="number">10</span>个数据。可以把Limit 查询转换成某个位置的查询 。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">2000000</span> LIMIT <span class="number">10</span>;</span><br><span class="line"># 优化方案二：主键不自增的表：当前表内连接排序截取后的主键表，连接字段是主键。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student t,(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">WHERE</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure><blockquote><p> 也可以用子查询，子查询优化成关联查询。</p></blockquote><h2 id="带排序的深分页优化"><a href="#带排序的深分页优化" class="headerlink" title="带排序的深分页优化"></a>带排序的深分页优化</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 优化前：查询根据age逆序排列的深分页</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span> LIMIT <span class="number">2000000</span>,<span class="number">10</span>; </span><br><span class="line"># 优化方案一：主键不有序的表根据主键排序，先给主键分页，然后内连接原表：当前表内连接排序截取后的主键表，连接字段是主键。因为查主键是在聚簇索引树查，不用回表，排序和分页很快</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student t1,(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">desc</span> LIMIT <span class="number">2000000</span>,<span class="number">10</span>) t2 </span><br><span class="line"><span class="keyword">WHERE</span> t1.id<span class="operator">=</span>t2.id</span><br><span class="line"># 优化方案二：主键有序的表根据非主键排序，可以得到上一页最后一条记录x，那么目标页码的所有记录id都比x.id小（因为逆序，且排序依据其实是age,id），目标页码的所有记录age都比x.age小或等于。需要传参数。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&lt;</span> \#&#123;x.id&#125; <span class="keyword">AND</span> age <span class="operator">&lt;=</span> \#&#123;x.age&#125; <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">‌数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，目标是将低效SQL语句转换为高效等效语句。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库-优化</title>
    <link href="https://southernfish.github.io/pages/database/db-mysql-4-optimize/"/>
    <id>https://southernfish.github.io/pages/database/db-mysql-4-optimize/</id>
    <published>2025-07-26T05:30:36.000Z</published>
    <updated>2025-09-17T07:51:48.701Z</updated>
    
    <content type="html"><![CDATA[<p>数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，核心目标是将低效SQL语句转换为高效等效语句。人工智能自动优化技术通过重写SQL语句实现性能提升。优化技术演变历经三代工具：第一代解析执行计划，第二代推荐索引优化，第三代提出语法改进建议。优化策略贯穿数据库生命周期，其中设计阶段优化成本最低且收益最大。</p><blockquote><p>原文链接：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130355955">MySQL高级篇——性能分析工具</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/131059110">【MySQL调优】如何进行MySQL调优？一篇文章就够了！</a></p></blockquote><h1 id="数据库服务器的优化步骤"><a href="#数据库服务器的优化步骤" class="headerlink" title="数据库服务器的优化步骤"></a>数据库服务器的优化步骤</h1><p>在数据库调优中，目标是<strong>响应时间更快，吞吐量更大</strong>。利用宏观的<strong>监控工具</strong>和微观的<strong>日志分析</strong>可以帮我们快速找到调优的思路和方式。 </p><p><strong>调优流程：</strong></p><ol><li><strong>SHOW STATUS</strong>观察服务器状态，是否存在周期性波动；如果存在的话就<strong>缓存优化</strong>；</li><li>如果还存在不规则延迟或卡顿的话，就<strong>开启慢查询、explain分析查询语句</strong>；</li><li>如果发现sql等待时间长，就<strong>调优服务器参数</strong>；如果发现sql执行时间长，就<strong>索引优化、表优化；</strong></li><li>如果还存在不规则延迟或卡顿的话，就<strong>观察</strong>sql查询是否到瓶颈了；是的话就<strong>读写分离、分库分表。</strong></li></ol><p><strong>三种分析工具（SQL调优三步骤）：</strong>慢查询、EXPLAN、SHOW PROFLING</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726121610266.png" alt="image-20250726121610266"></p><p>整个流程划分成了观察（Show status） 和行动（Action） 两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。</p><p>优化方式<strong>硬件，系统配置，数据库表结构，SQL及索引</strong>，从左至右效果渐好，从右至左，成本渐高。</p><hr><h1 id="查看系统性能参数"><a href="#查看系统性能参数" class="headerlink" title="查看系统性能参数"></a>查看系统性能参数</h1><h2 id="SHOW-STATUS-LIKE-‘参数’"><a href="#SHOW-STATUS-LIKE-‘参数’" class="headerlink" title="SHOW STATUS  LIKE ‘参数’"></a>SHOW STATUS  LIKE ‘参数’</h2><p>在MySQL中，可以使用<strong>SHOW STATUS</strong> 语句查询一些MySQL<strong>数据库服务器</strong>的<strong>性能参数</strong>、执行频率。</p><p>SHOW STATUS语句语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p> 中括号代表可省略。</p><p>一些常用的性能参数如下：</p><ul><li><p><strong>Connections：</strong>连接MySQL服务器的次数。</p></li><li><p><strong>Uptime：</strong>MySQL服务器的上线时间。重启服务器后会重置。</p></li><li><p><strong>Slow_queries：慢查询的次数</strong>。查询时长超过指定时间，次数越少越好。</p></li><li><p>Innodb_rows_read：Select查询返回的行数</p></li><li><p>Innodb_rows_inserted：执行INSERT操作插入的行数</p></li><li><p>Innodb_rows_updated：执行UPDATE操作更新的行数</p></li><li><p>Innodb_rows_deleted：执行DELETE操作删除的行数</p></li><li><p>Com_select：查询操作的次数。</p></li><li><p>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。</p></li><li><p>Com_update：更新操作的次数。</p></li><li><p>Com_delete：删除操作的次数。</p></li><li><p><strong>last_query_cost</strong>：查询优化器上一个查询的成本，最近一次删除用到数据页数量。</p></li></ul></blockquote><h2 id="查看SQL的查询成本"><a href="#查看SQL的查询成本" class="headerlink" title="查看SQL的查询成本"></a>查看SQL的查询成本</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br></pre></td></tr></table></figure><p>SQL查询是一个动态的过程，从页加载的角度来看:</p><ol><li><p><strong>缓冲池查询效率优于从磁盘查</strong></p><p>如果页就在数据库<strong>缓冲池</strong>中，那么<strong>效率是最高</strong>的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</p><blockquote><p>MySQL的缓冲池被分为多个不同的缓存池，其中包括：</p><ul><li>查询缓存：用来缓存查询结果。</li><li>InnoDB缓存池：用来缓存热点表和索引数据页。</li><li>MyISAM缓存池：用来缓存表数据块。</li></ul><p>当缓冲池中已经存储了较多的数据时，MySQL会使用一种叫做缓冲池替换算法的方法，将部分缓存数据替换出去，以腾出空间为新的数据做缓存。</p><p><strong>MySQL的缓冲池使用的是LRU（最近最少使用）算法</strong>，它会优先缓存最近使用的数据。当缓冲池的空间不足时，MySQL会将最不常用的数据从缓冲池中替换出去，以腾出空间缓存新的数据。</p></blockquote></li><li><p><strong>批量顺序查询平均下来每页查询更高</strong></p><p>如果从磁盘中对单一页进行随机读，那么效率是很低的(差不多10ms)，而采用<strong>顺序读取</strong>的方式，<strong>批量对页进行读取</strong>，<strong>平均一页的读取效率就会提升</strong>很多，甚至要快于单个页面在内存中的随机读取。</p><p>首先要考虑数据存放的位置，如果是<strong>经常使用的数据就要尽量放到缓冲池</strong>中，其次可以充分利用磁盘的吞吐能力，一次性<strong>批量读取数据</strong>，这样单个页的读取效率也就得到了提升。 </p><blockquote><p><strong>测试缓冲池缓存已使用的表和索引到内存中，效率高：</strong>查询900001和 900001~9000100查询成本差很多，查询速度差不多</p><p>查询 <strong>id=900001</strong> 的记录，然后看下查询成本，可以直接在聚簇索引上进行查找：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询 id<span class="operator">=</span><span class="number">900001</span> 的记录</span><br><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">900001</span>; </span><br><span class="line"># 运行结果（<span class="number">1</span> 条记录，运行时间为 <span class="number">0.042</span>s ）</span><br><span class="line"># 查询优化器的成本，实际上 只需要检索一个页</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">1.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br></pre></td></tr></table></figure><p>查询 id 在 <strong>900001</strong> 到 <strong>9000100</strong> 之间的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询 id 在 <span class="number">900001</span> 到 <span class="number">9000100</span> 之间的记录</span><br><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">900001</span> <span class="keyword">AND</span> <span class="number">900100</span>;</span><br><span class="line"># 运行结果（<span class="number">100</span> 条记录，运行时间为 <span class="number">0.046</span>s ）：</span><br><span class="line"># 查询优化器的成本，这时我们大概需要进行 <span class="number">20</span> 个页的查询。</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">21.134453</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br></pre></td></tr></table></figure><p>虽然页的数量是刚才的 20 倍，但<strong>查询的效率没有明显变化</strong>，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了<strong>顺序读取</strong>的方式将页面一次性加载到<strong>缓冲池</strong>中，然后再查找。虽然<strong>页数量</strong>（last_query_cost）<strong>增加了不少</strong>，但是通过缓冲池的机制，并<strong>没有增加多少查询时间。</strong></p><p><strong>为什么第二次是直接从缓冲池查</strong></p><p>因为 MySQL 缓存淘汰策略 LRU 最近最少使用，会优先缓存最近查询数据，优先淘汰最近最少使用数据。</p><p><strong>使用场景</strong>：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p></blockquote></li></ol><hr><h1 id="定位执行慢的-SQL：慢查询日志"><a href="#定位执行慢的-SQL：慢查询日志" class="headerlink" title="定位执行慢的 SQL：慢查询日志"></a>定位执行慢的 SQL：慢查询日志</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>MySQL的慢查询日志，用来<strong>记录在MySQL中响应时间超过阀值的语句</strong>，具体指运行时间超过 <code>long-query_time</code> 值的SQL，则会被记录到慢查询日志中。 long_query_time的默认值为 10，意思是运行10秒以上(不含10秒)的语句，认为是超出了最大忍耐时间值。</p><p>主要作用是发现执行时间特别长的 SOL 查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，结合explain进行全面分析，以解决问题。</p><p>默认情况下，MySQL数据库 没有开启慢查询日志 ，需要我们手动来设置这个参数。<strong>如果不是调优需要的话，一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的<strong>性能影响</strong>。慢查询日志支持将日志记录写入文件 。</p><h2 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h2><p>利用监控工具（例如<code>Prometheus+Grafana</code>）监控MySQL，发现查询性能变慢，报警提醒运维人员</p><p><strong>常见监控工具：</strong></p><ol><li><strong>MySQL Enterprise Monitor：</strong>由Oracle提供，它提供实时和历史的MySQL性能监控（查询性能、服务器状态、数据库复制等）。</li><li><strong>Percona Monitoring and Management：</strong>由Percona提供的开源工具，提供性能监控、查询分析、数据库配置等功能。</li><li><strong>MyTOP：</strong>一个基于命令行的工具，用于实时监控MySQL数据库的性能。</li><li><strong>MySQL Performance Schema：</strong>MySQL自带的性能监控工具，可以通过查询Performance Schema表来获取有关数据库性能和资源利用情况的详细信息。</li><li><strong>Nagios：</strong>一个通用的网络监控工具，可以使用插件来监控MySQL数据库的各种指标。</li><li><strong>Zabbix：</strong>一个通用的网络监控工具，可以使用插件来监控MySQL数据库的各种指标。</li><li><strong>Datadog：</strong>一个云端监控服务，提供对MySQL数据库的性能和状态的实时监控。</li><li><strong>Prometheus + Grafana：</strong>一组流行的开源工具，通过Prometheus监控MySQL数据库，使用Grafana创建仪表板进行可视化。</li></ol><h2 id="开启慢查询日志参数"><a href="#开启慢查询日志参数" class="headerlink" title="开启慢查询日志参数"></a>开启慢查询日志参数</h2><ol><li><p><strong>慢查询是否开启</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 慢查询是否开启</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> low_query_log   <span class="operator">|</span> OFF       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>开启慢查询日志slow_query_log</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 开启慢查询日志</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"># 查看下慢查询日志是否开启，以及慢查询日志文件的位置（默认为MySQL的数据目录）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name          <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> low_query_log          <span class="operator">|</span> <span class="keyword">ON</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> low_query_log_file   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu01<span class="operator">-</span>slow.log      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------------------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>修改慢查询阈值long_query_time</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看慢查询的时间阈值</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"># 查看全局慢查询的时间阈值：</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name     <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> long_query_time   <span class="operator">|</span> <span class="number">10.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-----------+</span></span><br></pre></td></tr></table></figure><p><strong>临时修改慢查询的时间阈值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 当前回话</span><br><span class="line"><span class="keyword">set</span> long_query_time <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line"># 全局</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span>; </span><br></pre></td></tr></table></figure><blockquote><p>对于 “global” 选项，是全局级别的配置参数。它可以在 MySQL 服务器启动时或 MySQL 安装时在 MySQL 配置文件中设置，或者通过 SET GLOBAL 命令在运行时更改。全局级别的配置参数对所有的 MySQL 连接都有效。</p></blockquote><p><strong>永久修改</strong>（重启数据库后依然有效，<strong>不建议永久修改</strong>，仅在优化时候打开，慢查询拖性能） ：修改<code>my.cnf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log=ON <span class="comment"># 开启慢查询日志的开关</span></span><br><span class="line">slow_query_log_file=/var/lib/mysql/atguigu-slow.log <span class="comment">#慢查询日志的目录和文件名信息</span></span><br><span class="line">long_query_time=3 <span class="comment">#设置慢查询的闽值为3秒，超出此设定值的SQL即被记录到慢查询日志</span></span><br><span class="line">log_output=FILE</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 测试发现：设置<span class="keyword">global</span>的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并执行下述语句</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">1</span>;                        # 设置全局慢查询阈值<span class="number">1</span>s</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;        # 全局<span class="number">1</span>s</span><br><span class="line"><span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;            # 当前会话<span class="number">10</span>s</span><br></pre></td></tr></table></figure></blockquote></li></ol><h2 id="查看慢查询次数"><a href="#查看慢查询次数" class="headerlink" title="查看慢查询次数"></a>查看慢查询次数</h2><p>查询当前系统中有多少条慢查询记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="慢查询日志分析工具：mysqldumpslow"><a href="#慢查询日志分析工具：mysqldumpslow" class="headerlink" title="慢查询日志分析工具：mysqldumpslow"></a>慢查询日志分析工具：mysqldumpslow</h2><p><code>mysqldumpslow</code>是用于分析MySQL慢查询日志的命令行工具。通过解析慢查询日志，可以了解到数据库的性能问题，从而进行优化。</p><blockquote><p><strong>查看mysqldumpslow的帮助信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow <span class="comment">--help</span></span><br></pre></td></tr></table></figure><p><strong>mysqldumpslow</strong> 命令的具体参数如下：</p><ul><li>-a: 不将数字抽象成N，字符串抽象成S</li><li><strong>-s: 是表示按照何种方式排序：</strong><ul><li>c: 访问次数</li><li>l: 锁定时间</li><li>r: 返回记录</li><li><strong>t: 查询时间</strong></li><li>al:平均锁定时间</li><li>ar:平均返回记录数</li><li><strong>at:平均查询时间 （默认方式）</strong></li><li>ac:平均查询次数</li></ul></li><li><strong>-t: 即为返回前面多少条的数据；</strong></li><li>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</li></ul></blockquote><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 按照查询时间排序，查看最慢的<span class="number">10</span>个查询，可以使用如下命令</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 如果需要筛选特定的查询，可以使用 `<span class="operator">-</span>g` 参数</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">-</span>g &quot;SELECT * FROM user&quot; <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 解析：该命令表示按照时间排序，显示最慢的<span class="number">10</span>个查询，其中关键字为 &quot;SELECT * FROM user&quot;。</span><br><span class="line"></span><br><span class="line"># 重新返回记录集最多的<span class="number">10</span>个<span class="keyword">SQL</span></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 查询访问次数最多的<span class="number">10</span>个<span class="keyword">SQL</span></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s c <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 查询按照时间排序的前<span class="number">10</span>条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">-</span>g &quot;left join&quot; <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 建议在使用这些命令时结合 <span class="operator">|</span> 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log <span class="operator">|</span> more</span><br></pre></td></tr></table></figure><h2 id="关闭慢查询日志"><a href="#关闭慢查询日志" class="headerlink" title="关闭慢查询日志"></a>关闭慢查询日志</h2><p>MySQL服务器停止慢查询日志功能有两种方法：</p><p><strong>方式1：永久性方式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">#slow_query_log=OFF</span></span><br></pre></td></tr></table></figure><p><strong>mysql默认关闭慢查询日志</strong>，或者，把slow_query_log一项注释掉 或 删除</p><p>重启MySQL服务，执行如下语句查询慢日志功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>;                 # 查询慢查询日志所在目录</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;     # 查询超时时长</span><br></pre></td></tr></table></figure><p><strong>方式2：临时性方式</strong></p><p>使用SET语句来设置。停止MySQL慢查询日志功能，具体SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log<span class="operator">=</span>off;                 # golbal全局有效。</span><br><span class="line"># 重启MySQL服务，使用<span class="keyword">SHOW</span>语句查询慢查询日志功能信息，发现慢查询日志已经关闭成功。</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>;                # 发现关闭成功</span><br><span class="line"># 慢查询阈值</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;       # <span class="number">10</span>s。前面改的时候没有加<span class="keyword">global</span>，所以重启服务器后阈值恢复<span class="number">10</span>s。</span><br></pre></td></tr></table></figure><h2 id="删除慢查询日志"><a href="#删除慢查询日志" class="headerlink" title="删除慢查询日志"></a>删除慢查询日志</h2><p><strong>手动删除</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用<span class="keyword">SHOW</span>语句显示慢查询日志信息，会得到慢查询日志的目录，在该目录下 手动删除慢查询日志文件 即可。</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> `slow_query_log<span class="operator">%</span>`;</span><br></pre></td></tr></table></figure><p><strong>自动删除</strong> </p><p>使用命令 mysqladmin flush-logs 来重新生成查询日志文件，执行完毕会在数据目录下重新生成慢查询日志文件。</p><p><strong>重新生成慢查询日志文件（直接删除旧的）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs slow</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong></p><p>慢查询日志都是使用<code>mysqladmin flush-logs</code>命令来<strong>删除重建</strong>的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p></blockquote><hr><h1 id="定位慢查询语句、查看-SQL-执行成本：show-profile"><a href="#定位慢查询语句、查看-SQL-执行成本：show-profile" class="headerlink" title="定位慢查询语句、查看 SQL 执行成本：show profile"></a>定位慢查询语句、查看 SQL 执行成本：show profile</h1><p>show profile 是 MySQL 提供的可以用来分析<strong>当前会话中</strong> <strong>SQL 都做了什么、执行的资源消耗工具的情况</strong>，可用于 sql 调优的测量。默认情况下处于关闭状态，并保存最近15次的运行结果。</p><p><code>SHOW PROFILE</code> 是一个用于查看会话执行的查询的性能分析信息的 MySQL 命令。它可以帮助开发人员和 DBA <strong>分析查询语句执行时的瓶颈</strong>，并找出哪些部分需要优化。 </p><blockquote><p><strong>SHOW VARIABLES</strong> 显示了 MySQL 服务器的当前配置变量，包括全局配置变量和会话配置变量，以及它们的值。SHOW VARIABLES 用于查看 MySQL 配置系统参数的详细信息并进行系统参数的修改。<br><strong>SHOW STATUS</strong> 显示服务器的性能参数，包括连接、线程、查询等方面的状态信息，以及它们的值。 </p></blockquote><p><strong>查看配置是否开启profile：</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br><span class="line"># 开启 <span class="keyword">show</span> profile</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> profiling <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> profiling         <span class="operator">|</span> <span class="keyword">ON</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"># 执行查询语句</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees;</span><br><span class="line"># <span class="keyword">show</span> profiles; 查询当前会话所有查询语句持续时间</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profiles;</span><br><span class="line"># <span class="keyword">show</span> profile;查询当前会话最近<span class="keyword">sql</span>语句的执行成本</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profile;</span><br><span class="line"># 查询指定QueryID的cpu信息</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu <span class="keyword">for</span> <span class="number">2</span>;</span><br><span class="line"># 在<span class="keyword">SHOW</span> PROFILE 中可以查看不同部分的开销，比如 cpu、block.io 等</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu,block io <span class="keyword">for</span> query <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>show profile的常用查询参数：</strong></p><ol><li><p>ALL：显示所有的开销信息。</p></li><li><p>BLOCK IO：显示块IO开销。</p></li><li><p>CONTEXT SWITCHES：上下文切换开销。</p></li><li><p>CPU：显示CPU开销信息。</p></li><li><p>IPC：显示发送和接收开销信息。</p></li><li><p>MEMORY：显示内存开销信 息。</p></li><li><p>PAGE FAULTS：显示页面错误开销信息。</p></li><li><p>SOURCE：显示和Source_function，Source_file， Source_line相关的开销信息。</p></li><li><p>SWAPS：显示交换次数开销信息。</p></li></ol><p><strong>日常开发需注意：</strong></p><ol><li><p> <strong>converting HEAP to MyISAM</strong>: 查询结果太大，内存不够，数据往磁盘上搬了。</p></li><li><p><strong>Creating tmp table</strong>：创建临时表。先拷贝数据到临时表，用完后再删除临时表。</p></li><li><p><strong>Copying to tmp table on disk</strong>：把内存中临时表复制到磁盘上，警惕！</p></li><li><p><strong>locked</strong>。</p></li></ol><p>如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。</p><p><strong>注意：</strong>不过<strong>SHOW PROFILE命令将被弃用</strong>，但可以从 <strong>information_schema 中的 profiling 数据表</strong>进行查看。</p></blockquote><hr><h1 id="执行计划表：EXPLAIN"><a href="#执行计划表：EXPLAIN" class="headerlink" title="执行计划表：EXPLAIN"></a>执行计划表：EXPLAIN</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL的EXPLAIN是一种<strong>分析SQL语句查询性能的工具</strong>。当我们在MySQL中执行SELECT语句时，EXPLAIN可以帮助我们<strong>查看MySQL如何执行这个查询，即执行计划</strong>，包括<strong>使用哪些索引、选择哪些表、以及如何读取数据</strong>等信息。</p><p>EXPLAIN的使用方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> my_column <span class="operator">=</span> <span class="string">&#x27;my_value&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行以上命令后，MySQL会返回一张查询执行计划表，其中包含了MySQL执行这个查询的详细信息。通过分析查询执行计划表<strong>了解查询的性能瓶颈</strong>，以及如何优化查询语句，从而提高查询性能。  </p><p><strong>注意：</strong> </p><ul><li>EXPLAIN不考虑各种Cache</li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li><li>部分统计信息是估算的，并非精确值</li></ul><blockquote><p><strong>MySQL中有专门负责优化SELECT语句的优化器模块</strong></p><p><strong>主要功能</strong>：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供<strong>它认为最优的 执行计划</strong> (他认为最优的数据检索方式，但不见得是DBA（数据库管理员）认为是最优的，这部分最耗费时间)。</p></blockquote><p><strong>能做什么？</strong></p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><p><strong>官网介绍</strong></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">MySQL :: MySQL 5.7 Reference Manual :: 8.8.2 EXPLAIN Output Format</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">MySQL :: MySQL 8.0 Reference Manual :: 8.8.2 EXPLAIN Output Format</a></p><p><strong>版本情况</strong></p><ul><li><strong>MySQL 5.6.3以前只能 EXPLAIN SELECT</strong> ；<strong>MYSQL 5.6.3以后</strong>就可以 EXPLAIN SELECT，<strong>UPDATE， DELETE</strong></li><li>在5.7以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示 filtered 需要使用 explain extended 命令。在5.7版本后，默认explain直接显示partitions和 filtered中的信息。</li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>EXPLAIN 或 DESCRIBE语句的语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br><span class="line"># 一般指定在查询时不使用缓存</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE select_options</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure><p>除了以 SELECT 开头的查询语句，其余的 DELETE、INSERT、REPLACE 以及UPDATE 语句等都可以加上EXPLAIN</p><h2 id="执行计划表介绍"><a href="#执行计划表介绍" class="headerlink" title="执行计划表介绍"></a>执行计划表介绍</h2><h3 id="执行计划各个列的作用（概述）"><a href="#执行计划各个列的作用（概述）" class="headerlink" title="执行计划各个列的作用（概述）"></a>执行计划各个列的作用（概述）</h3><table><thead><tr><th>列</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>每个SELECT子句或者join操作都会被分配一个唯一的编号，编号越小优先级越高，id相同的语句可以被认为是一组。id为NULL表示独立的子查询，子查询优先级都比主查询高。</td></tr><tr><td>select_type</td><td>查询的类型。主查询(primary)、普通查询(simple)、联合查询、子查询(subquery)、derived(from表临时子查询)、union(union后查询)、union result()</td></tr><tr><td>table</td><td>表名。显示当前这行的数据是哪个表的。</td></tr><tr><td>partitions</td><td>匹配的分区信息。如果表未分区则为NULL。</td></tr><tr><td><strong>type</strong></td><td><strong>访问类型，根据索引、全表扫描等方法来执行查询的优化策略。</strong>all（全表扫描），ref（命中非唯一索引），index(没命中索引，扫描索引树再回表)、const（命中主键/唯一索引）、range(范围索引查询)、index_merge(使用多个索引)、 system(一行记录时,快速查询)。</td></tr><tr><td>possible_keys</td><td>可能用到的索引。列出MySQL能够使用哪些索引来查询。如果该列只有一个possible_keys，通常意味着这个查询是高效的。如果这个列有多个possible_keys，并且MySQL只使用了其中一个，则需要考虑是否需要在该列上增加一个联合索引。</td></tr><tr><td><strong>key</strong></td><td><strong>实际上使用的索引。</strong>如果没有明确的指定KEY，MySQL会根据查询条件自动选择最优的索引。</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息。常量等值查询const, 表达式/函数使用到时func,关联查询显示关联字段名</td></tr><tr><td><strong>rows</strong></td><td>预估的需要读取的记录条数。数值越小越好，表示结果集越小，查询越高效。</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比。这个值越小越好，说明可通过索引直接返回数据。</td></tr><tr><td><strong>Extra</strong></td><td>额外信息。看有没有走索引，还是全表扫描了。一般搭配type字段看。Using index(使用到覆盖索引)、Using where(未完全命中索引)、Using temporary(临时表存储结果集.排序/分组会使用)、Using filesort(排序操作未用索引)、Using join buffer(连接条件未用索引)、Impossible where(where约束语句可能有问题导致没有结果集)</td></tr></tbody></table><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p><strong>select_type：</strong>查询的类型，有以下几种取值：</p><ul><li>SIMPLE：不使用子查询或UNION，不包含UNION ALL的简单SELECT查询。</li><li>PRIMARY：最外层的SELECT查询。</li><li>DERIVED：以FROM子句中的子查询方式出现的SELECT语句。</li><li>UNION：UNION中的第二个或之后的SELECT查询。</li><li>UNION RESULT：从UNION的结果集中获取数据的SELECT查询。</li><li>SUBQUERY：不在FROM子句中出现的子查询，通常在SELECT语句中使用。</li><li>DEPENDENT SUBQUERY：子查询依赖外层查询的结果集。</li></ul><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p><strong>key：</strong>实际上使用的索引。在MySQL中创建索引时使用的是INDEX关键字，但在EXPLAIN执行计划表中，显示的是KEY，这是因为<strong>MySQL允许在创建索引时指定统计信息</strong>，例如最小值、最大值等，这些<strong>统计信息</strong>在索引中被视为<strong>索引键</strong>（Index key），所以在执行计划表中，显示为KEY。</p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p><strong>type：</strong>访问类型，根据索引、全表扫描等方法来执行查询的优化策略。当 type 列的取值不是 Const 时，我们需要重点关注有关索引、缓存的性能调优，对 SQL 语句进行优化，适当修复可能的数据设计问题。</p><ul><li><p><strong>system：一行记录时,快速查询。</strong>只有一行数据即将被查询。这是最快的查询类型，通常出现在系统表的查询中。</p></li><li><p><strong>const：命中主键或唯一索引。</strong>使用主键或唯一索引查找单个行时使用，此时查询只能返回一行数据。这是一种非常快的查询类型。</p></li><li><p>eq_ref：连接使用唯一索引查找符合查询条件的数据时使用，每个连接类型都需要使用唯一索引进行访问，比ref执行速度更快。</p></li><li><p><strong>ref：命中非唯一索引。</strong>使用非唯一索引查找数据时使用，查询结果比eq_ref大，但仍很快。</p></li><li><p><strong>range：范围索引查询。</strong>使用索引范围查找数据时，可能会查找一定范围内的数据，如使用 BETWEEN 或 &gt; 或 &gt; &lt; 等操作时的查询。</p></li><li><p><strong>index：没命中索引，扫描非聚簇索引树再回表。</strong></p><ul><li><p>直接在某个索引树上做条件判断，并且不需要回表。全表扫描没有好的索引适用时使用，相比于全表扫描速度更快。</p></li><li><p>index是另外一种形式的全表扫描，扫描已有索引树然后回表取数据。和all相比，他要回表随机取数据，因此index不可能会比all快（取同一个表数据），官方手册说它的效率说的比all好，唯一可能的原因在于，按照索引扫描全表的数据是有序的。这样一来，结果不同，也就没法比效率的问题了。</p></li><li><p>比如：select t3.key1 from t3 where t3.key2 =6 ;当我们创建了联合索引idx_key1_key2(key1,key2)时，判断条件key2=6时，其虽然不满足索引的最左前缀原则，但是我们可以遍历idx_key1_key2这颗索引树，找到key2=6的记录即可。由于查询结果需要的key1在这个联合索引上，也不需要回表，此时就可以使用index。</p></li></ul></li><li><p><strong>all：全表扫描。</strong>扫描整个表以获得需要的数据，速度最慢，必须尽量避免使用。</p></li><li><p>unique_subquery：在对查询结果进行过滤或使用 IN 操作时，优化器会选择使用此类型的查询，使用了 In 操作符的子查询依赖于外层查询的唯一索引。</p></li><li><p>index_subquery：使用了 In 操作符但子查询使用的普通索引，而不是唯一索引。</p></li><li><p>range_check：在使用索引来检查外键参照时使用。</p></li><li><p>index_merge：使用多个索引。</p></li></ul><h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><ul><li><strong>using index：</strong>使用了覆盖索引，即不需要回表。查询的几个列正好都在这个聚簇索引树上。</li><li><strong>Using where：</strong>通过where过滤。没完全命中索引，需要回表。如index(a)，查的是where a=2 and b=3，查b=3时就要回表过滤。</li><li><strong>Using index condition：</strong>使用了索引下推。</li><li>Using temporary：临时表存储结果集.排序/分组会使用</li><li>Using filesort：排序操作未用索引</li><li>Using join buffer：连接条件未用索引</li><li>Impossible where：where约束语句可能有问题导致没有结果集</li></ul><h2 id="EXPLAIN四种输出格式"><a href="#EXPLAIN四种输出格式" class="headerlink" title="EXPLAIN四种输出格式"></a>EXPLAIN四种输出格式</h2><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式： <code>传统格式</code> ，<code>JSON格式</code> ， <code>TREE格式</code> 以及 <code>可视化输出</code> 。用户可以根据需要选择适用于自己的格式。</p><ol><li><p>传统格式：传统格式简单明了，输出是一个表格形式，概要说明查询计划。输出中缺少衡量执行好坏的重要属性 —— <code>成本</code>。</p></li><li><p>JSON格式：四种格式里面输出<code>信息最详尽</code>的格式，里面包含了执行的成本信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> ....</span><br></pre></td></tr></table></figure></li><li><p>TREE格式：TREE格式是8.0.16版本之后引入的新格式，主要根据查询的 <code>各个部分之间的关系</code> 和 <code>各部分的执行顺序</code> 来描述如何查询。</p></li><li><p>可视化输出：通过MySQL Workbench可视化查看执行计划。点击Workbench的放大镜图标，即可生成可视化的查询计划。</p><p>从左到右的连接顺序显示表。红色框表示 <code>全表扫描</code> ，而绿色框表示使用 <code>索引查找</code> 。对于每个表， 显示使用的索引。还要注意的是，每个表格的框上方是每个表访问所发现的行数的估计值以及访问该表的成本。 </p></li></ol><h2 id="SHOW-WARNINGS的使用"><a href="#SHOW-WARNINGS的使用" class="headerlink" title="SHOW WARNINGS的使用"></a>SHOW WARNINGS的使用</h2><p>在MySQL中，SHOW WARNINGS是一个可以查看最近一次执行的语句中产生的警告信息的命令。当MySQL执行语句时，如果发现一些不符合预期的情况，会产生一些警告信息，包括非致命性错误，例如某些类型的数据不能隐式转换或某些数据截断等。</p><p>执行SHOW WARNINGS命令时，MySQL会返回警告信息的详细列表，包括：</p><ul><li>Warning：该警告的类型</li><li>Level：该警告的级别，通常为Note、Warning或Error</li><li>Code：警告的返回代码</li><li>Message：警告信息的内容</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 可以使用<span class="keyword">SELECT</span>的方式来查看最近一次操作的警告信息：</span><br><span class="line"><span class="keyword">SHOW</span> WARNINGS;</span><br><span class="line"># 也可以配合使用<span class="keyword">INSERT</span>、<span class="keyword">UPDATE</span>、<span class="keyword">DELETE</span>、<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>等命令，检查某个具体操作产生的警告信息：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_table (name, age) <span class="keyword">VALUES</span> (<span class="string">&#x27;John Doe&#x27;</span>, <span class="number">150</span>);</span><br><span class="line"><span class="keyword">SHOW</span> WARNINGS;</span><br></pre></td></tr></table></figure><h2 id="EXPLAIN-ANALYZE命令"><a href="#EXPLAIN-ANALYZE命令" class="headerlink" title="EXPLAIN ANALYZE命令"></a>EXPLAIN ANALYZE命令</h2><p>MySQL 8.0引入了explain analyze命令，相比explain，它提供的是实际的查询计划，而explain提供的是预估查询计划。</p><p><strong>explain和explain analyze的区别：</strong></p><ul><li><strong>explain：</strong>只生成执行计划，不实际执行</li><li><strong>explain analyze：</strong>生成执行计划，并实际执行sql</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 分析人员表联查部门表</span><br><span class="line">EXPLAIN ANALYZE</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> personnel p <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> department d <span class="keyword">on</span> p.department<span class="operator">=</span>d.id</span><br><span class="line"># 查询计划结果</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> Nested loop <span class="keyword">left</span> <span class="keyword">join</span>  (cost<span class="operator">=</span><span class="number">915.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1980</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.333</span>.<span class="number">.14</span><span class="number">.500</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2453</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Table</span> scan <span class="keyword">on</span> p  (cost<span class="operator">=</span><span class="number">222.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1980</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.283</span>.<span class="number">.8</span><span class="number">.625</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2453</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Filter</span>: (p.DEPARTMENT <span class="operator">=</span> d.ID)  (cost<span class="operator">=</span><span class="number">0.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.002</span>.<span class="number">.0</span><span class="number">.002</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">2453</span>)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> Single<span class="operator">-</span><span class="type">row</span> index lookup <span class="keyword">on</span> d <span class="keyword">using</span> <span class="keyword">PRIMARY</span> (ID<span class="operator">=</span>p.DEPARTMENT)  (cost<span class="operator">=</span><span class="number">0.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.002</span>.<span class="number">.0</span><span class="number">.002</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">2453</span>)</span><br></pre></td></tr></table></figure><p><strong>结果分析</strong>：</p><p><strong>第一行：</strong>Nested loop left join  (cost=915.25 rows=1980) (actual time=0.333..14.500 rows=2453 loops=1)</p><ul><li><strong>Nested loop left join:</strong> 执行的最外层操作，表示使用嵌套循环的左连接。</li><li><strong>成本估计</strong>: (cost=915.25 rows=1980)：预计消耗915.25ms并返回1980行。</li><li><strong>实际时间</strong>: (actual time=0.333..14.500 rows=2453 loops=1)：实际读取第一行平均花费0.333ms，返回所有行平均花费14.500ms，共循环调用该迭代器1次，返回2453行。</li></ul><p><strong>第二行：</strong>Table scan on p  (cost=222.25 rows=1980) (actual time=0.283..8.625 rows=2453 loops=1)</p><ul><li><strong>Table scan on p:</strong> 对人员表的全表扫描。</li><li><strong>成本估计</strong>: (cost=222.25 rows=1980)：预计消耗222.25ms并返回1980行。</li><li><strong>实际时间</strong>: (actual time=0.283..8.625 rows=2453 loops=1)：实际读取第一行平均花费0.283ms，返回所有行平均花费8.625ms，共循环调用该迭代器1次，返回2453行。</li></ul><p><strong>第三行：</strong>Filter: (p.DEPARTMENT = d.ID)  (cost=0.25 rows=1) (actual time=0.002..0.002 rows=1 loops=2453)</p><ul><li><p><strong>Filter: (p.DEPARTMENT = d.ID):</strong> 执行对 md_gams_jc_department 表中 p.DEPARTMENT = d.ID 条件的过滤操作。</p></li><li><p><strong>成本估计</strong>: (cost=0.25 rows=1)：预计消耗0.25ms并返回1行。</p></li><li><p><strong>实际时间</strong>: (actual time=0.002..0.002 rows=1 loops=2453)：过滤操作平均花费0.002ms，共循环调用该迭代器2453次，返回1行。</p></li></ul><p><strong>第四行：</strong>Single-row index lookup on d using PRIMARY …… (actual time=0.002..0.002 rows=1 loops=2453)</p><ul><li><strong>Single-row index lookup on d using PRIMARY (ID=p.DEPARTMENT):</strong> 对部门表使用主键索引进行单行查找，其中 ID=p.DEPARTMENT。</li><li><strong>成本估计</strong>: (cost=0.25 rows=1)：预计消耗0.25ms并返回1行。</li><li><strong>实际时间</strong>: (actual time=0.002..0.002 rows=1 loops=2453)：查找操作平均花费0.002ms，共循环调用该迭代器2453次，返回1行。</li></ul><hr><h1 id="分析优化器执行计划：trace"><a href="#分析优化器执行计划：trace" class="headerlink" title="分析优化器执行计划：trace"></a>分析优化器执行计划：trace</h1><p>在MySQL中，可以使用trace命令来进行优化器执行计划的跟踪和分析。trace命令可以显示MySQL优化器在生成执行计划时所采取的决策，包括哪些表被处理，以及使用哪些索引、算法等。</p><p>使用trace命令需要先启用<code>general_log</code>和<code>performance_schema</code>两个系统变量，其次需要使用SET语句来设置一些参数，例如<code>trace-unique-check、trace-max-protocol、trace-protocol、trace-feature、trace-feature-check</code>等。设置完成后，可以通过<code>SET global trace_format=&#39;json&#39;</code>语句来选择输出结果的格式。</p><p>下面是对使用trace命令的一个简单示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>设置参数：</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_feature <span class="operator">=</span> <span class="string">&#x27;qa&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@max</span>_execution_time<span class="operator">=</span><span class="number">50000</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_level <span class="operator">=</span> <span class="string">&#x27;+ddl,+engine&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_feature_check <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_unique_check <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_protocol <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_max_protocol <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"># <span class="number">2.</span>启用general_log和performance_schema：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> performance_schema <span class="operator">=</span> <span class="keyword">on</span>;</span><br><span class="line"># <span class="number">3.</span>执行查询并查看结果：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> my_table</span><br><span class="line"><span class="keyword">WHERE</span> my_column <span class="operator">=</span> <span class="string">&#x27;some_value&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> SESSION STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Last_Query_Plan&#x27;</span>;</span><br><span class="line"># <span class="number">4.</span>关闭general_log和performance_schema：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> general_log <span class="operator">=</span> off;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> performance_schema <span class="operator">=</span> off;</span><br></pre></td></tr></table></figure><p>在trace输出中，可以看到优化器在执行计划中使用的索引、执行算法、行数估计等细节信息。通过分析trace结果，可以找到一些性能问题的根源，并进行相应的调整和优化。但要注意，trace命令可能会带来额外的性能消耗和IO开销，不应该在生产环境中长期启用。</p><hr><h1 id="MySQL监控分析视图-sys-schema"><a href="#MySQL监控分析视图-sys-schema" class="headerlink" title="MySQL监控分析视图-sys schema"></a>MySQL监控分析视图-sys schema</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>MySQL在8.0版本引入了sys schema，该模式包含用于监视和分析MySQL服务器性能的视图和函数。sys schema提供了一组易于使用的视图和函数，可以帮助我们更好地理解和分析MySQL数据库的行为和性能。</p><p>以下是sys schema中一些常用的监控分析视图：</p><ul><li><p>sys.statements_with_sorting: 显示哪些语句使用了排序操作，包括使用哪些排序操作、每个语句排序次数及排序操作的资源消耗。</p></li><li><p>sys.statements_with_runtimes_in_95th_percentile`: 显示执行时间最长的语句。</p></li><li><p>sys.io_global_by_file_by_bytes: 显示每个文件的磁盘IO字节数，可以用来检测IO瓶颈。</p></li><li><p>sys.memory_by_host_by_current_bytes: 显示每个客户端的当前内存使用情况，可以用于检测内存泄漏或内存占用高的情况。</p></li><li><p>sys.waits_global_by_latency: 显示哪些等待操作最耗费时间，可以帮助我们找到性能问题的瓶颈所在。</p></li><li><p>sys.processlist: 显示当前正在运行的线程和进程的信息，包括执行的语句、查询ID、用户、主机、线程ID和状态等信息。</p></li></ul><p><strong>sys schema</strong>中的视图和函数提供了更深入的MySQL性能分析和监控功能，可以帮助我们更好地理解MySQL数据库的行为和性能瓶颈。 </p><ol><li><strong>主机相关</strong>：以host_summary开头，主要汇总了IO延迟的信息。</li><li><strong>Innodb相关</strong>：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。</li><li><strong>I/o相关</strong>：以io开头，汇总了等待I/O、I/O使用量情况。</li><li><strong>内存使用情况</strong>：以memory开头，从主机、线程、事件等角度展示内存的使用情况</li><li><strong>连接与会话信息</strong>：processlist和session相关视图，总结了会话相关信息。</li><li><strong>表相关</strong>：以schema_table开头的视图，展示了表的统计信息。</li><li><strong>索引信息</strong>：统计了索引的使用情况，包含冗余索引和未使用的索引情况。</li><li><strong>语句相关</strong>：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。</li><li><strong>用户相关</strong>：以user开头的视图，统计了用户使用的文件I/O、执行语句统计信息。</li><li><strong>等待事件相关信息</strong>：以wait开头，展示等待事件的延迟情况。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><p>索引情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查询冗余索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_redundant_indexes;</span><br><span class="line"># <span class="number">2.</span> 查询未使用过的索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_unused_indexes;</span><br><span class="line"># <span class="number">3.</span> 查询索引的使用情况</span><br><span class="line"><span class="keyword">select</span> index_name,rows_selected,rows_inserted,rows_updated,rows_deleted</span><br><span class="line"><span class="keyword">from</span> sys.schema_index_statistics <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>表相关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查询表的访问量</span><br><span class="line"><span class="keyword">select</span> table_schema,table_name,<span class="built_in">sum</span>(io_read_requests<span class="operator">+</span>io_write_requests) <span class="keyword">as</span> io </span><br><span class="line"><span class="keyword">from</span> sys.schema_table_statistics <span class="keyword">group</span> <span class="keyword">by</span> table_schema,table_name <span class="keyword">order</span> <span class="keyword">by</span> io <span class="keyword">desc</span>;</span><br><span class="line"># <span class="number">2.</span> 查询占用bufferpool较多的表</span><br><span class="line"><span class="keyword">select</span> object_schema,object_name,allocated,data</span><br><span class="line"><span class="keyword">from</span> sys.innodb_buffer_stats_by_table <span class="keyword">order</span> <span class="keyword">by</span> allocated limit <span class="number">10</span>;</span><br><span class="line"># <span class="number">3.</span> 查看表的全表扫描情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.statements_with_full_table_scans <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>语句相关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 监控<span class="keyword">SQL</span>执行的频率</span><br><span class="line"><span class="keyword">select</span> db,exec_count,query <span class="keyword">from</span> sys.statement_analysis <span class="keyword">order</span> <span class="keyword">by</span> exec_count <span class="keyword">desc</span>;</span><br><span class="line"># <span class="number">2.</span> 监控使用了排序的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,first_seen,last_seen,query <span class="keyword">from</span> sys.statements_with_sorting limit <span class="number">1</span>;</span><br><span class="line"># <span class="number">3.</span> 监控使用了临时表或者磁盘临时表的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line"><span class="keyword">from</span> sys.statement_analysis <span class="keyword">where</span> tmp_tables<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">or</span> tmp_disk_tables <span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (tmp_tables<span class="operator">+</span>tmp_disk_tables) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure></li><li><p>I/O相关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查看消耗磁盘IO的文件</span><br><span class="line"><span class="keyword">select</span> file,avg_read,avg_write,avg_read<span class="operator">+</span>avg_write <span class="keyword">as</span> avg_io</span><br><span class="line"><span class="keyword">from</span> sys.io_global_by_file_by_bytes <span class="keyword">order</span> <span class="keyword">by</span> avg_read limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>Innodb 相关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 行锁阻塞情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="MySQL调优"><a href="#MySQL调优" class="headerlink" title="MySQL调优"></a>MySQL调优</h1><h2 id="基础优化"><a href="#基础优化" class="headerlink" title="基础优化"></a>基础优化</h2><h3 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h3><ul><li><strong>缓冲池优化：</strong>调整缓冲池大小innodb_buffer_pool_size。</li><li><strong>引入内存结构数据库：</strong>例如Redis。</li></ul><p><strong>提示</strong>：InnoDB使用缓冲池缓存记录和索引</p><h4 id="缓冲池优化"><a href="#缓冲池优化" class="headerlink" title="缓冲池优化"></a>缓冲池优化</h4><p><strong>缓冲池：</strong>MySQL的缓冲池被分为多个不同的缓存池，其中包括：</p><ul><li><strong>查询缓存：</strong>用来缓存查询结果。</li><li><strong>InnoDB缓存池：</strong>用来缓存热点表和索引数据页。</li><li><strong>MyISAM缓存池：</strong>用来缓存表数据块。</li></ul><p>缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。</p><p><strong>缓冲池的淘汰策略：</strong></p><p>LRU算法。MySQL的缓冲池默认使用的是LRU（最近最少使用）淘汰策略，它会优先缓存最近使用的数据。当缓冲池的空间不足时，MySQL会将最不常用的数据从缓冲池中替换出去，以腾出空间缓存新的数据。</p><blockquote><p><strong>lru算法底层原理：</strong></p><p>底层是双向链表（因为经常要移动元素），链表首部是最常使用元素，尾部是最少使用元素。</p><p>每次刚访问的数据会移动到链表首部，刚添加的数据也会添加到链表首部。超出maxmemory会淘汰链表尾部元素，它也最长时间没有被使用的数据。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726175640829.png" alt="image-20250726175640829"></p></blockquote><p><strong>缓冲池相关参数：</strong></p><ul><li><p><strong>MyISAM缓冲池大小：</strong>key_buffer_size：该参数用来设置MyISAM索引的缓存大小。如果应用程序中涉及到大量的索引查询，可以适当提高该值。一般来说，key_buffer_size占用总内存的1/4到1/3比较合适。</p></li><li><p><strong>InnoDB缓冲池大小：</strong>innodb_buffer_pool_size：该参数用来设置InnoDB缓冲池的大小。<strong>InnoDB</strong>存储引擎使用<strong>缓冲池来缓存数据和索引文件</strong>。如果InnoDB表的读写频次较高，建议将该值设置为物理内存的70%到80%。</p></li><li><p><strong>排序缓冲区大小：</strong>sort_buffer_size：该参数用来设置排序缓冲区大小。如果查询中涉及到ORDER BY或GROUP BY操作，可以适当提高该值。一般来说，sort_buffer_size占用总内存的1/4到1/3比较合适。</p></li><li><p><strong>读取缓冲区大小：</strong>read_buffer_size和read_rnd_buffer_size：这两个参数是用来设置读取缓冲区大小的，默认值为128 KB。如果应用程序中经常进行大文件的读取操作，可以适当提高这两个参数。</p></li><li><p><strong>binlog大小：</strong>binlog_cache_size：该参数是用来设置二进制日志的缓存大小。如果应用程序中需要持久化一些数据，可以开启二进制日志，并适当调整该参数。</p></li></ul><p><strong>参数配置方法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>查看当前缓冲池参数：</span><br><span class="line"><span class="keyword">show</span> VARIABLES  <span class="keyword">like</span> <span class="string">&#x27;key_buffer_size&#x27;</span>;</span><br><span class="line"># <span class="number">2.</span>修改缓冲池参数：</span><br><span class="line"># <span class="number">2.1</span> 在运行中的MySQL实例中临时设置这个值（这不会持久保存，重启后会失效）：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> key_buffer_size <span class="operator">=</span> <span class="number">67108864</span>;  <span class="comment">-- 64MB</span></span><br><span class="line"># 在MySQL配置文件（通常是 my.cnf 或 my.ini）中进行更改，然后重启MySQL服务使更改生效：</span><br><span class="line">[mysqld]</span><br><span class="line">key_buffer_size <span class="operator">=</span> <span class="number">64</span>M</span><br></pre></td></tr></table></figure><h4 id="Redis优化"><a href="#Redis优化" class="headerlink" title="Redis优化"></a>Redis优化</h4><p>Redis是一个基于内存的NoSQL数据库，MySQL是一个基于磁盘的关系型数据库。内存的读写速度是远高于磁盘的，所以对于一些多读少写的热点数据，搭配Redis存储数据，可以极大地提高数据的访问速度。</p><blockquote><p>参考文章：<a href="/pages/database/db-redis/">Redis</a></p></blockquote><h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><p>服务器加内存条、升级SSD固态硬盘、把磁盘I/O分散在多个设备、配置多处理器。</p><h3 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h3><ol><li><p>关闭不必要的服务和日志：调优结束关闭慢查询日志；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 临时关闭慢查询日志，如果想永久关闭，需要修改my.ini或my.cnf配置文件</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="string">&#x27;OFF&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>调整最大连接数：max_connections 。MySQL5.5及之后版本默认最大连接数是151，可根据实际场景压测得出合适的最大连接数。</p><ul><li><p>MySQL5.5 ～ 5.7：默认的最大连接数都是 151，上限为：100000</p></li><li><p>MySQL5.0 版本：默认的最大连接数为 100，上限为 16384</p></li><li><p>MySQL8.0 版本: 默认的最大连接数是 151</p></li><li><p>修改最大链接数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>查看当前最大连接数：</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"># <span class="number">2.</span>临时修改最大连接数（重启后失效）：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_connections <span class="operator">=</span><span class="number">1000</span></span><br><span class="line"># <span class="number">3.</span>永久修改连接数（重启后有效）：</span><br><span class="line"># 在Linux系统中，配置文件通常是<span class="operator">/</span>etc<span class="operator">/</span>my.cnf或<span class="operator">/</span>etc<span class="operator">/</span>mysql<span class="operator">/</span>my.cnf。</span><br><span class="line"># 在Windows系统中，通常是 [安装目录下]\MySQL Server <span class="number">5.7</span>\my.ini。</span><br><span class="line">[mysqld]</span><br><span class="line">max_connections <span class="operator">=</span> <span class="number">1000</span></span><br><span class="line"># Linux，重启</span><br><span class="line">sudo systemctl restart mysql</span><br><span class="line"># windows，服务重启：服务管理器<span class="operator">-</span>搜索MySQL<span class="operator">-</span>重启服务</span><br></pre></td></tr></table></figure></li></ul></li><li><p>线程池缓存线程数：thread_cache_size，缓存空闲线程，有连接时直接分配该线程处理连接；</p></li><li><p>缓冲池大小：innodb_buffer_pool_size 。</p></li></ol><h3 id="定期清理垃圾"><a href="#定期清理垃圾" class="headerlink" title="定期清理垃圾"></a>定期清理垃圾</h3><p>对于不再使用的表、数据、日志、缓存等，应该及时清理，避免占用过多的MySQL资源，从而提高MySQL的性能。</p><h4 id="清理不再使用的表"><a href="#清理不再使用的表" class="headerlink" title="清理不再使用的表"></a>清理不再使用的表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除这些表：</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line"># 保留表结构但删除所有数据</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure><h4 id="清理过期数据"><a href="#清理过期数据" class="headerlink" title="清理过期数据"></a>清理过期数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 一些场景下，某个时期之前的数据都不再需要，可以清理这些数据</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> createTime <span class="operator">&lt;</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">30</span> <span class="keyword">DAY</span>;</span><br><span class="line"># 创建一个MySQL事件来定期清理过期数据</span><br><span class="line"><span class="keyword">CREATE</span> EVENT clean_up_event</span><br><span class="line"><span class="keyword">ON</span> SCHEDULE <span class="keyword">EVERY</span> <span class="number">1</span> <span class="keyword">DAY</span></span><br><span class="line">DO</span><br><span class="line">  <span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> created_at <span class="operator">&lt;</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">30</span> <span class="keyword">DAY</span>;</span><br></pre></td></tr></table></figure><h4 id="清理日志"><a href="#清理日志" class="headerlink" title="清理日志"></a>清理日志</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 清理<span class="number">2023</span>年之前的日志</span><br><span class="line">PURGE <span class="type">BINARY</span> LOGS BEFORE <span class="string">&#x27;2023-01-01 00:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="清理缓存池"><a href="#清理缓存池" class="headerlink" title="清理缓存池"></a>清理缓存池</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RESET QUERY CACHE;</span><br><span class="line"># 或者修改配置文件，禁用查询缓存以避免潜在的性能问题：</span><br><span class="line">[mysqld]</span><br><span class="line">query_cache_type <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">query_cache_size <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="优化表：OPTIMIZE-TABLE"><a href="#优化表：OPTIMIZE-TABLE" class="headerlink" title="优化表：OPTIMIZE TABLE"></a>优化表：OPTIMIZE TABLE</h4><p>在 MySQL 数据库中，OPTIMIZE TABLE 是一个重要的命令，用于优化表的性能和空间利用。通过重新组织表的存储结构，去除碎片、重建索引，OPTIMIZE TABLE 可以帮助提高查询性能、减少存储空间占用以及减少数据碎片。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure><p><strong>优化原理：</strong></p><p>删除delete语句留下来的垃圾碎片。使用delete语句删除数据时，delete语句只会将记录的位置或者数据页标记为”可复用”，但是数据库磁盘文件的大小不会改变，即表空间不会被回收，此时使用该命令可以释放空间，压缩数据文件。</p><p><strong>底层原理：</strong>执行OPTIMIZE TABLE命令后，MySQL会进行以下几个步骤</p><ol><li><strong>创建临时表</strong>：MySQL 首先会创建一个与原表结构相同的临时表。</li><li><strong>原表数据复制到临时表</strong>：将原表中的数据复制到临时表中。</li><li><strong>临时表去碎片</strong>：在数据复制的过程中，MySQL 会对数据进行整理和重组，去除碎片，提高数据的连续性。</li><li><strong>删旧表留新表</strong>：当数据复制完成并且表被优化后，MySQL 会删除原表，然后将临时表重命名为原表的名称。</li></ol><h4 id="分析表：ANALYZE-TABLE"><a href="#分析表：ANALYZE-TABLE" class="headerlink" title="分析表：ANALYZE TABLE"></a>分析表：ANALYZE TABLE</h4><p>MySQL 的Optimizer（优化元件）在优化SQL语句时，首先需要收集一些相关信息，其中就包括表的cardinality（散列程度），它表示某个索引对应的列包含多少个不同的值——如果cardinality大大少于数据的实际散列程度，那么索引就基本失效了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure><p><strong>对不同存储引擎的效果：</strong></p><ul><li><strong>InnoDB：</strong>对 InnoDB 表执行 ANALYZE TABLE 会重新计算表和索引的统计信息，并更新优化器统计信息。</li><li><strong>MyISAM：</strong>对 MyISAM 表执行 ANALYZE TABLE 会分析表的关键字分布，并更新索引统计信息。</li><li><strong>其他存储引擎：</strong>对其他存储引擎（如 MEMORY 或 ARCHIVE），效果类似，即更新表和索引的统计信息。</li></ul><h4 id="计划任务清理数据、日志、优化表"><a href="#计划任务清理数据、日志、优化表" class="headerlink" title="计划任务清理数据、日志、优化表"></a>计划任务清理数据、日志、优化表</h4><p>对于以上的清理垃圾方案，可以写一个定时任务，定期统一清理垃圾数据、优化表的存储空间和索引。</p><h5 id="方案一：创建cron作业"><a href="#方案一：创建cron作业" class="headerlink" title="方案一：创建cron作业"></a>方案一：创建cron作业</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.编辑crontab</span></span><br><span class="line"><span class="comment"># 使用crontab命令编辑当前用户的cron作业列表。对于系统级别的作业，可以使用sudo运行crontab。</span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="comment"># 或者，为特定用户编辑cron作业：</span></span><br><span class="line">sudo crontab -u username -e</span><br><span class="line"><span class="comment"># 2. 编写cron作业</span></span><br><span class="line"><span class="comment"># 在打开的编辑器中，添加新的cron作业，每行代表一个作业，执行指定路径下的脚本：</span></span><br><span class="line">0 2 * * * /path/to/cleanup_script.sh</span><br></pre></td></tr></table></figure><blockquote><p>cron表达式格式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* * * * * command-to-be-executed</span><br><span class="line">- - - - -</span><br><span class="line">| | | | |</span><br><span class="line">| | | | +----- Day of the week (0 - 7) (Sunday=0 or 7)</span><br><span class="line">| | | +------- Month (1 - 12)</span><br><span class="line">| | +--------- Day of the month (1 - 31)</span><br><span class="line">| +----------- Hour (0 - 23)</span><br><span class="line">+------------- Minute (0 - 59)</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例清理脚本</strong>：/path/to/cleanup_script.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># MySQL credentials</span></span><br><span class="line">USER=<span class="string">&quot;your_username&quot;</span></span><br><span class="line">PASSWORD=<span class="string">&quot;your_password&quot;</span></span><br><span class="line">DATABASE=<span class="string">&quot;your_database&quot;</span></span><br><span class="line"><span class="comment"># 清理过期数据</span></span><br><span class="line">mysql -u <span class="variable">$USER</span> -p<span class="variable">$PASSWORD</span> -e <span class="string">&quot;DELETE FROM table_name WHERE created_at &lt; NOW() - INTERVAL 30 DAY;&quot;</span> <span class="variable">$DATABASE</span></span><br><span class="line"><span class="comment"># 清理二进制日志</span></span><br><span class="line">mysql -u <span class="variable">$USER</span> -p<span class="variable">$PASSWORD</span> -e <span class="string">&quot;PURGE BINARY LOGS BEFORE NOW() - INTERVAL 7 DAY;&quot;</span></span><br><span class="line"><span class="comment"># 优化表</span></span><br><span class="line">mysql -u <span class="variable">$USER</span> -p<span class="variable">$PASSWORD</span> -e <span class="string">&quot;OPTIMIZE TABLE table_name;&quot;</span> <span class="variable">$DATABASE</span></span><br></pre></td></tr></table></figure><h5 id="方案二：使用Spring定时任务"><a href="#方案二：使用Spring定时任务" class="headerlink" title="方案二：使用Spring定时任务"></a>方案二：使用Spring定时任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤①：开启定时任务功能，在引导类上开启定时任务功能的开关，使用注解@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootTaskApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Springboot22TaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 步骤②：在task包下定义Bean，在对应要定时执行的操作上方，使用注解@Scheduled定义执行的时间，执行时间的描述方式还是cron表达式</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 具体清理垃圾的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何想对定时任务进行详细配置，可以通过配置文件进行</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">task:</span></span><br><span class="line">       <span class="attr">scheduling:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">           <span class="attr">size:</span> <span class="number">1</span> <span class="comment">#任务调度线程池大小 默认 1</span></span><br><span class="line">      <span class="attr">thread-name-prefix:</span> <span class="string">ssm_</span>           <span class="comment">#调度线程名称前缀 默认 scheduling-      </span></span><br><span class="line">        <span class="attr">shutdown:</span></span><br><span class="line">          <span class="attr">await-termination:</span> <span class="literal">false</span>         <span class="comment">#线程池关闭时等待所有任务完成</span></span><br><span class="line">          <span class="attr">await-termination-period:</span> <span class="string">10s</span>     <span class="comment">#调度线程关闭前最大等待时间，确保最后一定关闭</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>总结</strong></p><ol><li>spring task需要使用注解@EnableScheduling开启定时任务功能</li><li>为定时执行的的任务设置执行周期，描述方式cron表达式</li></ol></blockquote><h3 id="使用合适的存储引擎"><a href="#使用合适的存储引擎" class="headerlink" title="使用合适的存储引擎"></a>使用合适的存储引擎</h3><p>MyISAM：适合读取频繁，写入较少的场景（因为表级锁、B+树叶存地址）</p><p>InnoDB：适合并发写入的场景（因为行级锁、B+树叶存记录）。</p><h3 id="读写分离与分库分表"><a href="#读写分离与分库分表" class="headerlink" title="读写分离与分库分表"></a>读写分离与分库分表</h3><blockquote><p>参考文章：<a href="/pages/database/db-mysql-5-sharding/">MySQL数据库-表设计优化、读写分离与分库分表</a></p></blockquote><p><strong>读写分离</strong>：读写分离能有效提高查询性能。主从同步用到bin log和relay log。</p><p><strong>分库分表</strong>：数据量级到达千万级以上后，垂直拆分（分库）、水平拆分（分表）、垂直+水平拆分（分库分表）。</p><h2 id="表设计优化"><a href="#表设计优化" class="headerlink" title="表设计优化"></a>表设计优化</h2><blockquote><p>参考文章：<a href="/pages/database/db-mysql-5-sharding/">MySQL数据库-表设计优化、读写分离与分库分表</a></p></blockquote><ol><li>混合业务分表、冷热数据分表</li><li>联合查询改为中间关系表</li><li>遵循三个范式</li><li>字段建议非空约束</li><li>反范式：使用冗余字段</li><li>数据类型优化</li></ol><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="索引优化思路"><a href="#索引优化思路" class="headerlink" title="索引优化思路"></a>索引优化思路</h3><p>都有哪些维度可以进行数据库调优？简言之：</p><ul><li><p>索引失效、没有充分利用到索引——<strong>建立索引</strong></p></li><li><p>关联查询太多JOIN（设计缺陷或不得已的需求）——<strong>SQL优化</strong></p></li><li><p>服务器调优及各个参数设置（关闭慢查询日志、缓冲、线程数等）——<strong>调整my.cnf</strong></p></li><li><p>数据过多——<strong>分库分表</strong></p></li><li><p><strong>定期清理垃圾：</strong>对于不再使用的表、数据、日志、缓存等，应该及时清理，避免占用过多的MySQL资源，从而提高MySQL的性能。</p></li><li><p><strong>使用合适的存储引擎：</strong>MyISAM比较适合读取频繁，写入较少的场景（因为表级锁、B+树叶存地址），而InnoDB比较适合并发写入的场景（因为行级锁、B+树叶存记录）。</p></li></ul><p>关于数据库调优的知识非常分散。不同的DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。</p><p>虽然SQL查询优化的技术有很多，但是大方向上完全可以分成<strong>物理查询优化</strong>和<strong>逻辑查询优化</strong>两大块。</p><ul><li><strong>物理查询优化</strong>：<strong>索引</strong>和<strong>表连接方式</strong>等技术来进行优化，这里重点需要掌握索引的使用。</li><li><strong>逻辑查询优化</strong>：通过SQL<strong>等价变换</strong>提升查询效率，即换一种查询写法效率可能更高。</li></ul><h3 id="索引失效的11种情况"><a href="#索引失效的11种情况" class="headerlink" title="索引失效的11种情况"></a>索引失效的11种情况</h3><p><strong>用不用索引，最终都是优化器说了算：</strong></p><p>优化器是基于什么的优化器? 基于 **cost开销(CostBaseOptimizer)**，它不是基于规则(Rule-Basedoptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</p><h4 id="查询条件相关"><a href="#查询条件相关" class="headerlink" title="查询条件相关"></a>查询条件相关</h4><ul><li><p><strong>隐式类型转换</strong>：当查询条件中的数据类型与索引列的数据类型不匹配时，会触发隐式转换，导致索引失效。例如，索引列是<code>varchar</code>类型，查询时使用了数字类型。</p></li><li><p><strong>左模糊匹配</strong>：使用<code>like</code>语句进行模糊查询时，如果通配符<code>%</code>在最左边，无法利用索引的有序性，索引失效。如<code>select * from users where name like &#39;%张%&#39;</code>。</p></li><li><p><strong>索引列参与运算</strong>：对索引列进行运算，如<code>age + 1 &gt; 30</code>，数据库需对每行数据计算后才能比较，无法直接利用索引，索引失效。</p></li><li><p><strong>函数操作索引字段</strong>：在查询条件中对索引列使用函数，如<code>date_format(created_at, &#39;%y-%m&#39;)</code>，函数转换会破坏索引的有序性，导致索引失效。</p></li><li><p><strong>最左前缀原则违反</strong>：对于联合索引，必须从左到右连续使用，即最左优先，否则索引失效。</p><p><strong>结论</strong>：MySQL可以为多个字段创建索引，一个索引可以包含16个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong>。</p><p><strong>例如</strong>：联合索引<code>(country, city, age)</code>，查询条件为<code>city=&#39;北京&#39; and age&gt;25</code>，跳过了第一个字段<code>country</code>字段，索引失效。</p></li><li><p><strong>范围条件右边的列索引失效</strong>：（a,b,c）联合索引，查询条件a,b,c，如果b使用了范围查询，那么b右边的c索引失效。这里右边看的联合索引的键右边。</p><p><strong>解决办法</strong>：新建联合索引（a,c,b）或（c,a,b），把需要范围查询的字段放在最后</p><p><strong>范围包括</strong>：(&lt;) (&lt;=) (&gt;) (&gt;=) 和 between。</p></li><li><p><strong>or连接非索引字段</strong>：<code>or</code>条件要求所有涉及的列都有索引，否则索引失效。如<code>select * from users where age=25 or address=&#39;北京&#39;</code>，<code>address</code>无索引。</p></li><li><p><strong>使用不等号（!= / &lt;&gt;）</strong>：因为“不等于”不能精准匹配，全表扫描二级索引树再回表效率不如直接全表扫描聚簇索引树。使用不等号进行查询时，如果需要扫描大部分数据，优化器可能会放弃索引。如<code>select * from orders where status != &#39;completed&#39;</code>。</p></li><li><p><strong>索引选择性过低</strong>：当索引列的值过于重复，区分度低于30%时，优化器可能认为全表扫描更高效，从而放弃使用索引。</p></li></ul><h4 id="查询操作相关"><a href="#查询操作相关" class="headerlink" title="查询操作相关"></a>查询操作相关</h4><ul><li><strong>使用not in / not exists</strong>：<code>not in</code>和<code>not exists</code>操作符在某些情况下会导致索引失效，尤其是当查询结果集较大时。如<code>select * from user where id not in (1,2,3)</code>。</li><li><strong>使用is null / is not null</strong>：虽然<code>is null</code>或<code>is not null</code>条件可以使用索引，但如果索引列中的数据分布不均匀，查询可能仍然会导致索引失效，特别是在大数据量的情况下。</li><li><strong>全表扫描更快的情况</strong>：当查询结果超过表总行数的30%时，MySQL可能会认为全表扫描比索引查询更快，从而选择全表扫描。</li><li><strong>使用distinct</strong>：在某些情况下，<code>distinct</code>查询可能会导致MySQL不使用索引，尤其是在查询中涉及多个字段时。</li></ul><h4 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h4><ul><li><p><strong>排序顺序不同</strong>：<code>order by</code>中的字段与<code>where</code>条件中的字段不一致时，可能会导致索引失效。如<code>select id_no,name,email from db_staff where id_no &gt; &#39;110112202409881120&#39; order by create_time</code>。</p></li><li><p><strong>查询不在索引范围内</strong>：如果查询条件不在索引覆盖范围内，索引失效。如<code>select * from test_001 where user_age = 2500</code>。</p></li><li><p><strong>不同字符集导致索引失败，建议utf8mb4</strong>：不同的字符集进行比较前需要进行<strong>转换</strong>会造成索引失效。</p><p>数据库和表的字符集统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，可以<strong>避免由于字符集转换产生的乱码</strong>。</p></li><li><p><strong>主键插入顺序尽量自增</strong></p><p>对于使用 InnoDB 存储引擎的表来说，在没有显式的创建索引时，表中的数据实际上都是存储在<strong>聚簇索引的叶子节点</strong>的。而记录又是存储在数据页中的，数据页和记录又是按照记录<strong>主键值从小到大</strong>的顺序进行排序。所以如果 插入 的记录的 主键值是依次增大 的话，那每插满一个数据页就换到下一个数据页继续插，而插入的<strong>主键值忽大忽小</strong>的话，假设某个数据页存储的记录已经满了，再插入数据就需要把当前 <strong>页面分裂</strong> 成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着 <strong>性能损耗</strong> ！</p><p><strong>建议</strong>：让主键 <strong><code>AUTO_INCREMENT</code></strong> ，插入数据时存储引擎会自动填入自增主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p></li></ul><h3 id="遵循索引设计原则"><a href="#遵循索引设计原则" class="headerlink" title="遵循索引设计原则"></a>遵循索引设计原则</h3><ol><li><p>命名：索引的字段个数尽量别超过5个，命名格式“idx_col1_col2”</p></li><li><p>在频繁查询（特别是分组、范围、排序查询）的列建立索引；</p></li><li><p>频繁更新的表，不要创建过多索引</p></li><li><p>唯一特性的字段，适合创建索引；</p></li><li><p>很长的varchar字段，适合根据区分度和长度创建前缀索引；</p></li><li><p>多个字段都要创建索引时，联合索引优于单值索引；</p></li><li><p>避免创建过多索引，避免索引失效；</p></li><li><p><strong>尽量用有序的字段作为主键索引</strong>：防止乱序时新主键前移到已满的数据页，导致插入后分裂数据页，造成性能损耗； </p></li></ol><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><blockquote><p>参考文章：<a href="/pages/database/db-mysql-6-query/">MySQL数据库-查询优化</a></p></blockquote><ol><li>连接查询优化<ol><li>优化方案</li><li>左外连接：优先右表创建索引，连接字段类型要一致</li><li>内连接：驱动表由数据量和索引决定</li><li>join语句原理</li></ol></li><li>子查询优化<ol><li>子查询优化成关联查询</li><li>多次查询代替子查询</li><li>临时表代替子查询</li></ol></li><li>排序优化<ol><li>排序优化建议</li><li>范围查询时索引字段选择</li><li>filesort 算法</li></ol></li><li>分组优化</li><li>分页查询优化<ol><li>深分页查询优化</li><li>带排序的深分页优化</li></ol></li></ol><h3 id="尽量覆盖索引"><a href="#尽量覆盖索引" class="headerlink" title="尽量覆盖索引"></a>尽量覆盖索引</h3><blockquote><p><strong>详细请参考：</strong><a href="/pages/database/db-mysql-3-index.md">MySQL数据库-索引</a></p></blockquote><h3 id="字符串前缀索引"><a href="#字符串前缀索引" class="headerlink" title="字符串前缀索引"></a>字符串前缀索引</h3><blockquote><p><strong>详细请参考：</strong><a href="/pages/database/db-mysql-3-index.md">MySQL数据库-索引</a></p></blockquote><h3 id="尽量使用索引下推"><a href="#尽量使用索引下推" class="headerlink" title="尽量使用索引下推"></a>尽量使用索引下推</h3><blockquote><p><strong>详细请参考：</strong><a href="/pages/database/db-mysql-3-index.md">MySQL数据库-索引</a></p></blockquote><p>MySQL5.6支持。一个索引包含了满足查询结果的数据。因为不需要回表，故查询效率高。覆盖索引时<strong>左模糊和不等于</strong>不能让索引失效。</p><h3 id="写多读少时尽量用普通索引"><a href="#写多读少时尽量用普通索引" class="headerlink" title="写多读少时尽量用普通索引"></a>写多读少时尽量用普通索引</h3><p>查询时普通索引和唯一索引效率差不多；更新时普通索引效率更高，因为有change buffer（写缓存）将更新后的数据页缓存到内存，下次访问时或后台定期会执行merge操作，将该数据页写入磁盘。change buffer在事务提交时会写入redo log，保证数据持久化。</p><p><strong>普通索引</strong>：不加任何限制条件，如create index idx_name on student(name)。</p><p><strong>唯一索引</strong>：UNIQUE参数限制索引唯一，如create UNIQUE index idx_name on student(name)。</p><blockquote><p><strong>详细请参考：</strong><a href="/pages/database/db-mysql-3-index.md">MySQL数据库-索引</a></p></blockquote><hr><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="EXISTS-和-IN-的区分"><a href="#EXISTS-和-IN-的区分" class="headerlink" title="EXISTS 和 IN 的区分"></a>EXISTS 和 IN 的区分</h2><p><strong>问题：</strong>不太理解哪种情况下应该使用 EXISTS，哪种情况应该用 IN。选择的标准是看能否使用表的索引吗？</p><p><strong>回答：</strong>索引是个前提，其实选择与否还是要看表的大小。可将选择标准理解为 <strong>小表驱动大表</strong>。在这种方式下效率是最高的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 比如下面这样:</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> CC <span class="keyword">IN</span> (<span class="keyword">SELECT</span> CC <span class="keyword">FROM</span> B);                     # 当B小于A</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> CC <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.CC<span class="operator">=</span>A.CC);     # 当A小于B时</span><br><span class="line"># 当A小于B时，用 <span class="keyword">EXISTS</span>。因为 <span class="keyword">EXISTS</span> 的实现，相当于外表循环，实现的逻辑类似于</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> A</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> B</span><br><span class="line">        if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span></span><br><span class="line"># 当B小于A时，用 <span class="keyword">IN</span>。因为实现的逻辑类似于</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> B</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> A</span><br><span class="line">        if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span></span><br></pre></td></tr></table></figure><p>遵循小表驱动大表原则，左边表小就是EXISTS，左边表大就用IN。</p><p><strong>小表驱动大表是为了减少连接次数</strong>：连接查询的原理是先查左表，再根据连接字段查右表，然后过滤右表的条件。因为相比普通的查询，连接查询要左表右表都查一次，肯定没有只查一次快，所以连接次数越少越好。</p><h2 id="建议COUNT-或COUNT-1"><a href="#建议COUNT-或COUNT-1" class="headerlink" title="建议COUNT(*)或COUNT(1)"></a>建议COUNT(*)或COUNT(1)</h2><p>**统计行数尽量用COUNT(1),COUNT(*)**：这时查询优化器会优先选用有索引的、占用空间最小的二级索引树进行统计，只有找不到非聚簇索引树时采用使用聚簇索引树统计，空间占用大。当然也能COUNT(最小空间二级索引字段)，但麻烦不如交给优化器自动选择。</p><p>问：在 MySQL 中统计数据表的行数，可以使用三种方式： SELECT COUNT(*) 、 SELECT COUNT(1) 和 SELECT COUNT(具体字段) ，使用这三者之间的查询效率是怎样的？</p><p>答：如果要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。</p><ul><li><p><strong>count（1）：</strong>统计整个表的记录行数。括号里表示一个固定值，可以是任何固定的数字字符，是个常量。在InnoDB存储引擎中，查询优化器会优先选择占用空间最小的二级索引树进行统计。COUNT(*) 和COUNT(1)都是对所有结果进行COUNT(*)，两者<strong>本质上没有区别</strong>，性能上也没有显著差别，因为优化器会处理为相同的查询计划。。有 WHERE 子句是对所有符合筛选条件的数据行进行统计，没有 WHERE子句，则是对数据表的数据行数进行统计。</p></li><li><p><strong>count（*）：</strong>统计整个表的记录行数，与count（1）执行结果相同，但是执行会根据目标表的不同进行优化。</p></li><li><p><strong>count（列名）：</strong>统计某一列的非空记录数。它会统计指定列中不为NULL的行数，忽略NULL值。</p></li><li><p><strong>count(distinct(列名)) ：</strong>统计某一列的非空去重记录数。其实是 count(列名) + distinct 的结果集，指定列不为NULL，并且在字段值重复的情况下只统计一次</p></li></ul><p><strong>MylSAM 统计只需O(1)：</strong>如果是 <strong>MylSAM 存储引擎，统计数据表的行数只需要 O(1)的复杂度</strong>，因为每张 MyISAM 的数据表都有一个 meta 信息存储了 <strong>row_count 值</strong>，而一致性则由表级锁来保证。 如果是InnoDB 存储引擎，因为<strong>innoDB</strong> 支持事务，采用行级锁和 MVCC机制，无法像 MyISAM 维护1个row_count变量，因此<strong>需要采用扫描全表，是O(n)的复杂度</strong>，进行循环+计数的方式来完成统计。</p><p><strong>选择建议：</strong>在ImnoDB中，如果采用<strong>COUNT(具体字段)<strong>来统计数据行数，要</strong>尽量采用二级索引</strong>。因为主键是聚簇索引，聚簇索引叶节点包含整个记录，统计时要加载到内存的数据量更大，性能就差一点。对于COUNT(*)和 COUNT(1)来说，它们不需要查找具体的行，只是统计行数，<strong>系统会自动采用占用空间更小的二级索引来进行统计</strong>。 如果有多个二级索引，会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p><h2 id="建议SELECT-字段-而不是SELECT"><a href="#建议SELECT-字段-而不是SELECT" class="headerlink" title="建议SELECT(字段)而不是SELECT(*)"></a>建议SELECT(字段)而不是SELECT(*)</h2><p>在表查询中，建议明确字段，不要使用 <code>*</code> 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。<strong>原因</strong>：</p><ol><li>MySQL 在解析的过程中，会通过查询数据字典<strong>将<code>*</code>按序转换成所有列名</strong>，会大大耗费资源和时间。</li><li>无法使用覆盖索引</li></ol><blockquote><p><strong>数据库引擎的查询流程：</strong>参考文章<a href="/pages/database/db-mysql-6-query/">MySQL数据库-查询优化</a></p></blockquote><h2 id="LIMIT-1-对优化的影响"><a href="#LIMIT-1-对优化的影响" class="headerlink" title="LIMIT 1 对优化的影响"></a>LIMIT 1 对优化的影响</h2><p>针对的是<strong>会扫描全表的 SQL 语句</strong>，如果可以<strong>确定结果集只有一条</strong>，加上 LIMIT 1 时，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 LIMIT 1 了。</p><h2 id="全表扫描时尽量用“LIMIT”"><a href="#全表扫描时尽量用“LIMIT”" class="headerlink" title="全表扫描时尽量用“LIMIT”"></a>全表扫描时尽量用“LIMIT”</h2><p>当进行全表扫描并且明确时，使用LIMIT可以在达到指定数量后停止扫描，减少不必要的开销。</p><p>例如根据学号查询学生，根据身份证号查询人，根据订单号查询订单，当我们明确知道需要精准查询时，用Limit 1 总错不了。</p><p>当然如果走了唯一索引，就无需用limit了，查到对应记录会直接返回；如果走了普通索引，并且对应记录重复数据很多的话，用limit也会提高一些性能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 根据学号（假设学号是按班级隔离的）和班级号精准查询学生</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">where</span> stuno <span class="operator">=</span><span class="number">23</span> <span class="keyword">and</span> classid<span class="operator">=</span><span class="number">1</span> LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="使用limit-N，少用limit-M，N"><a href="#使用limit-N，少用limit-M，N" class="headerlink" title="使用limit N，少用limit M，N"></a>使用limit N，少用limit M，N</h2><p><strong>避免大偏移量的LIMIT</strong>：在大表或M值较大时，LIMIT M, N的性能较差，因为需要扫描并丢弃前M条记录。可以通过记录上次查询的最大ID来优化分页。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> large_table <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> last_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="将长事务拆为多个小事务"><a href="#将长事务拆为多个小事务" class="headerlink" title="将长事务拆为多个小事务"></a>将长事务拆为多个小事务</h2><ul><li><p><strong>提交事务可以释放的资源</strong>：回滚段上用于恢复数据的信息、锁、redo / undo log buffer 中的空间。</p></li><li><p><strong>多使用COMMIT</strong>：长事务会持有锁和占用资源较长时间，拆分为小事务并频繁COMMIT可以释放锁、减少资源占用。</p></li></ul><p>尽量多使用 COMMIT，用编程式事务而不是声明式事务，降低事务粒度。<strong>示例：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.查询a</span></span><br><span class="line">    <span class="comment">// 2.查询b</span></span><br><span class="line">    <span class="comment">// 3.数据处理</span></span><br><span class="line">    <span class="comment">// 4.保存c表</span></span><br><span class="line">    <span class="comment">// 5.保存b表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.查询a</span></span><br><span class="line">    <span class="comment">// 2.查询b</span></span><br><span class="line">    <span class="comment">// 3.数据处理</span></span><br><span class="line">    <span class="comment">// 4.落库</span></span><br><span class="line">    savaFun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">savaFun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.保存c表</span></span><br><span class="line">    <span class="comment">// 2.保存d表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="先查再删改"><a href="#先查再删改" class="headerlink" title="先查再删改"></a>先查再删改</h2><p>UPDATE、DELETE语句一定要有明确的WHERE条件。</p><p><strong>确保WHERE条件明确</strong>：在执行UPDATE或DELETE操作前，先SELECT一下并不会让性能变差，它可以确保有明确的WHERE条件，避免误操作和全表扫描。</p><h2 id="尽量UNION-ALL而不是UNION"><a href="#尽量UNION-ALL而不是UNION" class="headerlink" title="尽量UNION ALL而不是UNION"></a>尽量UNION ALL而不是UNION</h2><p><strong>UNION ALL</strong>：UNION ALL 和 UNION 都用于组合两个或多个查询结果集。UNION ALL在组合时，<strong>不进行去重操作</strong>，比UNION更快，适用于不需要去重的场景。</p><h2 id="多使用COMMIT"><a href="#多使用COMMIT" class="headerlink" title="多使用COMMIT"></a>多使用COMMIT</h2><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p><p>COMMIT 所释放的资源：</p><ul><li>回滚段上用于恢复数据的信息</li><li>被程序语句获得的锁</li><li><code>redo / undo log buffer</code> 中的空间</li><li>管理上述 3 种资源中的内部花费</li></ul>]]></content>
    
    
    <summary type="html">‌数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，目标是将低效SQL语句转换为高效等效语句。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
