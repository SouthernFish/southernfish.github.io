<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Southern Fish</title>
  
  
  <link href="https://southernfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://southernfish.github.io/"/>
  <updated>2025-09-20T11:18:48.142Z</updated>
  <id>https://southernfish.github.io/</id>
  
  <author>
    <name>Southern Fish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>服务限流</title>
    <link href="https://southernfish.github.io/pages/high-availability/server-limit-stream/"/>
    <id>https://southernfish.github.io/pages/high-availability/server-limit-stream/</id>
    <published>2025-09-18T09:02:36.000Z</published>
    <updated>2025-09-20T11:18:48.142Z</updated>
    
    <content type="html"><![CDATA[<p>对软件系统来讲，限流就是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。因为软件系统的处理能力是有限的，当超过了其处理能力的范围，软件系统可能直接宕机。限流可能会导致用户的请求无法被正确处理或者无法立即被处理，不过，这往往也是权衡了软件系统的稳定性之后得到的最优解。</p><p>现实生活中，处处都有限流的实际应用，就比如排队买票是为了避免大量用户涌入购票而导致售票员无法处理。</p><p>本文主要介绍了常见的限流算法、限流对象的选择以及单机限流和分布式限流分别应该怎么实现。</p><blockquote><p>参考文章：</p><p><a href="https://javaguide.cn/high-availability/limit-request.html">服务限流详解</a></p></blockquote><h1 id="常见限流算法"><a href="#常见限流算法" class="headerlink" title="常见限流算法"></a>常见限流算法</h1><p>简单介绍 4 种非常好理解并且容易实现的限流算法！</p><blockquote><p>图片来源于 InfoQ 的一篇文章<a href="https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673">《分布式服务限流实战，已经为你排好坑了》</a>。</p></blockquote><h2 id="固定窗口计数器算法"><a href="#固定窗口计数器算法" class="headerlink" title="固定窗口计数器算法"></a>固定窗口计数器算法</h2><p>固定窗口其实就是时间窗口，其原理是将时间划分为固定大小的窗口，在每个窗口内限制请求的数量或速率，即固定窗口计数器算法规定了系统单位时间处理的请求数量。</p><p>假如我们规定系统中某个接口 1 分钟只能被访问 33 次的话，使用固定窗口计数器算法的实现思路如下：</p><ul><li>将时间划分固定大小窗口，这里是 1 分钟一个窗口。</li><li>给定一个变量 <code>counter</code> 来记录当前接口处理的请求数量，初始值为 0（代表接口当前 1 分钟内还未处理请求）。</li><li>1 分钟之内每处理一个请求之后就将 <code>counter+1</code> ，当 <code>counter=33</code> 之后（也就是说在这 1 分钟内接口已经被访问 33 次的话），后续的请求就会被全部拒绝。</li><li>等到 1 分钟结束后，将 <code>counter</code> 重置 0，重新开始计数。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250918212607016.png" alt="image-20250918212607016"></p><p><strong>优点</strong>：实现简单，易于理解。</p><p><strong>缺点</strong>：</p><ul><li><strong>限流不够平滑</strong>。例如，我们限制某个接口每分钟只能访问 30 次，假设前 30 秒就有 30 个请求到达的话，那后续 30 秒将无法处理请求，这是不可取的，用户体验极差！</li><li><strong>无法保证限流速率，因而无法应对突然激增的流量</strong>。例如，我们限制某个接口 1 分钟只能访问 1000 次，该接口的 QPS 为 500，前 55s 这个接口 1 个请求没有接收，后 1s 突然接收了 1000 个请求。然后，在当前场景下，这 1000 个请求在 1s 内是没办法被处理的，系统直接就被瞬时的大量请求给击垮了。</li></ul><h2 id="滑动窗口计数器算法"><a href="#滑动窗口计数器算法" class="headerlink" title="滑动窗口计数器算法"></a>滑动窗口计数器算法</h2><p>是固定窗口计数器算法的升级版，<strong>限流的颗粒度更小</strong>。</p><p>滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：<strong>它把时间以一定比例分片</strong> 。</p><p>例如我们的接口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理不大于 <code>60(请求数)/60（窗口数）</code> 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。</p><p>显然， <strong>当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。</strong></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250918212849635.png" alt="image-20250918212849635"></p><p>优点：</p><ul><li>相比于固定窗口算法，滑动窗口计数器算法<strong>可以应对突然激增的流量</strong>。</li><li>相比于固定窗口算法，滑动窗口计数器算法的颗粒度更小，可以<strong>提供更精确的限流控制</strong>。</li></ul><p>缺点：</p><ul><li>与固定窗口计数器算法类似，滑动窗口计数器算法依然存在<strong>限流不够平滑</strong>的问题。</li><li>相比较于固定窗口计数器算法，滑动窗口计数器算法实现和理解起来更复杂一些。</li></ul><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>可以把发请求的动作比作成注水到桶中，处理请求的过程可以比喻为漏桶漏水。<strong>往桶中以任意速率流入水，以一定速率流出水</strong>。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。</p><p>实现也很简单，准备一个队列用来保存请求，然后定期从队列中拿请求来执行就好了（和消息队列削峰/限流的思想是一样的）。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250918213254887.png" alt="image-20250918213254887"></p><p><strong>优点</strong>：</p><ul><li>实现简单，易于理解。</li><li>可以控制限流速率，<strong>避免网络拥塞和系统过载</strong>。</li></ul><p><strong>缺点</strong>：</p><ul><li>无法应对突然激增的流量，因为<strong>只能以固定的速率处理请求</strong>，对系统资源利用不够友好。</li><li>桶流入水（发请求）的速率如果一直大于桶流出水（处理请求）的速率的话，那么桶会一直是满的，一部分新的请求会被丢弃，导致服务质量下降。</li></ul><blockquote><p> 注意：实际业务场景中，基本不会使用漏桶算法。</p></blockquote><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法也比较简单。和漏桶算法算法一样，主角还是桶，不过现在桶里装的是令牌，请求在被处理前需要拿到一个令牌，请求处理完后将这个令牌丢弃（删除）。<strong>根据限流大小，按照一定的速率往桶里添加令牌</strong>。如果桶装满了，就不能继续往里面继续添加令牌了。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250918213449848.png" alt="image-20250918213449848"></p><p><strong>优点</strong>：</p><ul><li>可以限制平均速率和应对突然激增的流量。</li><li>可以动态调整生成令牌的速率。</li></ul><p><strong>缺点</strong>：</p><ul><li>如果令牌产生速率和桶的容量设置不合理，可能会出现问题比如大量的请求被丢弃、系统过载。</li><li>相比于其他限流算法，实现和理解起来更复杂一些。</li></ul><h1 id="限流对象"><a href="#限流对象" class="headerlink" title="限流对象"></a>限流对象</h1><p>实际项目中，还需要确定限流对象，也就是针对什么来进行限流。常见的限流对象如下：</p><ul><li><strong>IP</strong> ：针对 IP 进行限流，适用面较广，简单粗暴。</li><li><strong>业务 ID</strong>：挑选<em>唯一的业务 ID</em> 以实现更针对性地限流。例如，基于用户 ID 进行限流。</li><li><strong>个性化</strong>：根据用户的属性或行为，进行不同的限流策略。例如， VIP 用户不限流，而普通用户限流。根据系统的运行指标（如 QPS、并发调用数、系统负载等），动态调整限流策略。例如，当系统负载较高的时候，控制每秒通过的请求减少。</li></ul><p>针对 IP 进行限流是目前比较常用的一个方案。不过，实际应用中<strong>需要注意用户真实 IP 地址的正确获取</strong>。常用的真实 IP 获取方法有 <code>X-Forwarded-For</code> 和 <code>TCP Options</code> 字段承载真实源 IP 信息。虽然 <strong>X-Forwarded-For 字段可能会被伪造</strong>，但因为其实现简单方便，很多项目还是直接用的这种方法。</p><p>还有一些其他较为复杂的限流对象策略，如阿里的 Sentinel 还支持 <a href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6#%E5%9F%BA%E4%BA%8E%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">基于调用关系的限流</a>（包括基于调用方限流、基于调用链入口限流、关联流量限流等）以及更细维度的 <a href="https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81">热点参数限流</a>（实时的统计热点参数并针对热点参数的资源调用进行流量控制）。</p><p>另外，一个项目可以根据具体的业务需求选择多种不同的限流对象搭配使用。</p><hr><h1 id="单机限流实现"><a href="#单机限流实现" class="headerlink" title="单机限流实现"></a>单机限流实现</h1><p>单机限流针对的是单体架构应用。</p><p>单机限流可以直接使用 Google Guava 自带的限流工具类 <code>RateLimiter</code> 。 <code>RateLimiter</code> 基于令牌桶算法，可以应对突发流量。</p><blockquote><p>Guava 地址：<a href="https://github.com/google/guava">https://github.com/google/guava</a></p></blockquote><p>除了最基本的令牌桶算法(平滑突发限流)实现之外，Guava 的<code>RateLimiter</code>还提供了 <strong>平滑预热限流</strong> 的算法实现。</p><p><strong>平滑突发限流</strong>就是按照指定的速率放令牌到桶里，而平滑预热限流会有一段预热时间，预热时间之内，速率会逐渐提升到配置的速率。</p><p>在项目中引入 Guava 相关的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>31.0.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>简单的 Guava 平滑突发限流的 Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">5</span>); <span class="comment">// 1s 放 5 个令牌到桶里也就是 0.2s 放 1个令牌到桶里</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">sleepingTime</span> <span class="operator">=</span> rateLimiter.acquire(<span class="number">1</span>);</span><br><span class="line">            System.out.printf(<span class="string">&quot;get 1 tokens: %ss%n&quot;</span>, sleepingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的 Guava 平滑预热限流的 Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1s 放 5 个令牌到桶里也就是 0.2s 放 1个令牌到桶里</span></span><br><span class="line">        <span class="comment">// 预热时间为3s,也就说刚开始的 3s 内发牌速率会逐渐提升到 0.2s 放 1 个令牌到桶里</span></span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">sleepingTime</span> <span class="operator">=</span> rateLimiter.acquire(<span class="number">1</span>);</span><br><span class="line">            System.out.printf(<span class="string">&quot;get 1 tokens: %sds%n&quot;</span>, sleepingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，<strong>Bucket4j</strong> 是一个非常不错的基于令牌/漏桶算法的限流库。</p><blockquote><p>Bucket4j 地址：<a href="https://github.com/vladimir-bukhtoyarov/bucket4j">https://github.com/vladimir-bukhtoyarov/bucket4j</a></p></blockquote><p>相对于，Guava 的限流工具类来说，Bucket4j 提供的限流功能更加全面。不仅支持单机限流和分布式限流，还可以集成监控，搭配 Prometheus 和 Grafana 使用。</p><p>不过，毕竟 Guava 也只是一个功能全面的工具类库，其提供的开箱即用的限流功能在很多单机场景下还是比较实用的。</p><p>Spring Cloud Gateway 中自带的单机限流的早期版本就是基于 Bucket4j 实现的。后来，替换成了 <strong>Resilience4j</strong>。</p><p>Resilience4j 是一个轻量级的容错组件，其灵感来自于 Hystrix。自<a href="https://github.com/Netflix/Hystrix/commit/a7df971cbaddd8c5e976b3cc5f14013fe6ad00e6">Netflix 宣布不再积极开发 Hystrix</a> 之后，Spring 官方和 Netflix 都更推荐使用 Resilience4j 来做限流熔断。</p><blockquote><p>Resilience4j 地址: <a href="https://github.com/resilience4j/resilience4j">https://github.com/resilience4j/resilience4j</a></p></blockquote><p>一般情况下，为了保证系统的高可用，项目的限流和熔断都是要一起做的。</p><p>Resilience4j 不仅提供限流，还提供了熔断、负载保护、自动重试等保障系统高可用开箱即用的功能。并且，Resilience4j 的生态也更好，很多网关都使用 Resilience4j 来做限流熔断的。</p><p>因此，在绝大部分场景下 Resilience4j 或许会是更好的选择。如果是比较简单的限流场景的话，Guava 或者 Bucket4j 也是不错的选择。</p><hr><h1 id="分布式限流实现"><a href="#分布式限流实现" class="headerlink" title="分布式限流实现"></a>分布式限流实现</h1><p>分布式限流针对的分布式/微服务应用架构应用，此时单机限流不再适用，因为会存在多种服务，并且一种服务也可能会被部署多份。</p><p>分布式限流常见的方案：</p><ul><li><strong>借助中间件限流</strong>：可以借助 <code>Sentinel</code> 或者使用 <code>Redis</code> 来自己实现对应的限流逻辑。</li><li><strong>网关层限流</strong>：比较常用的一种方案，直接在网关层把限流给安排上了。不过，通常网关层限流通常也需要借助到中间件/框架。就比如 Spring Cloud Gateway 的分布式限流实现<code>RedisRateLimiter</code>就是基于 <code>Redis+Lua</code> 来实现的，再比如 Spring Cloud Gateway 还可以整合 <code>Sentinel</code> 来做限流。</li></ul><p>如果要基于 Redis 来手动实现限流逻辑的话，建议配合 Lua 脚本来做。</p><p><strong>建议 Redis+Lua 的方式</strong> 主要有两点原因：</p><ul><li><strong>减少了网络开销</strong>：可利用 Lua 脚本批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</li><li><strong>原子性</strong>：一段 Lua 脚本可视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</li></ul><p>不想写 Lua 脚本也可直接利用 Redisson 中的 <code>RRateLimiter</code> 来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。</p><p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，比如 Java 中常用的数据结构实现、分布式锁、延迟队列等等。并且，Redisson 还支持 Redis 单机、Redis Sentinel、Redis Cluster 等多种部署架构。</p><p><code>RRateLimiter</code> 的使用方式非常简单。首先获取一个<code>RRateLimiter</code>对象，直接通过 Redisson 客户端获取。然后设置限流规则就好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Redisson 客户端实例</span></span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create();</span><br><span class="line"><span class="comment">// 获取一个名为 &quot;javaguide.limiter&quot; 的限流器对象</span></span><br><span class="line"><span class="type">RRateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(<span class="string">&quot;javaguide.limiter&quot;</span>);</span><br><span class="line"><span class="comment">// 尝试设置限流器的速率为每小时 100 次</span></span><br><span class="line"><span class="comment">// RateType 有两种，OVERALL是全局限流,ER_CLIENT是单Client限流（可以认为就是单机限流）</span></span><br><span class="line">rateLimiter.trySetRate(RateType.OVERALL, <span class="number">100</span>, <span class="number">1</span>, RateIntervalUnit.HOURS);</span><br></pre></td></tr></table></figure><p>接下来调用<code>acquire()</code>方法或<code>tryAcquire()</code>方法即可获取许可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个许可，如果超过限流器的速率则会等待</span></span><br><span class="line"><span class="comment">// acquire()是同步方法，对应的异步方法：acquireAsync()</span></span><br><span class="line">rateLimiter.acquire(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 尝试在 5 秒内获取一个许可，如果成功则返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">// tryAcquire()是同步方法，对应的异步方法：tryAcquireAsync()</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> rateLimiter.tryAcquire(<span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">‌Redis(Remote Dictionary Server)，远程字典服务，是用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，提供多种语言的API。</summary>
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Redis的持久化机制</title>
    <link href="https://southernfish.github.io/pages/database/db-redis-persistence/"/>
    <id>https://southernfish.github.io/pages/database/db-redis-persistence/</id>
    <published>2025-09-18T01:15:36.000Z</published>
    <updated>2025-09-20T11:18:48.139Z</updated>
    
    <content type="html"><![CDATA[<p>使用缓存时经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。Redis 持久化机制（RDB 持久化、AOF 持久化、RDB 和 AOF 的混合持久化）相关的问题比较多，也比较重要，本文总结了 Redis 持久化机制相关的知识点和问题。</p><blockquote><p>参考文章：</p><p><a href="https://javaguide.cn/database/redis/redis-persistence.html">Redis 持久化机制详解</a></p></blockquote><h1 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h1><p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p><ul><li>快照（snapshotting，RDB）</li><li>只追加文件（append-only file, AOF）</li><li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li></ul><p><code>RDB（Redis Database）</code>：指定的时间间隔能对你的数据进行快照存储。</p><ul><li><strong>数据备份机制RDB（默认）：数据</strong>每隔一段时间写进磁盘rdb文件，故障后从文件读。可以在redis.conf配置多少秒内多少key修改时自动bgsave。占CPU和内存但恢复快，不能恢复完整数据。save命令是主进程立即执行一次RDB，其他所有命令进程阻塞。bgsave是子进程fork主进程，阻塞并拷贝一份主进程的页表（虚拟内存到物理内存的映射关系），然后子进程写数据到rdb文件，主进程继续处理用户请求。</li></ul><p><code>AOF（Append Only File）</code>：每一个收到的写命令都<strong>通过write函数追加到文件中</strong>。</p><ul><li><strong>追加文件机制AOF</strong>：命令日志按指定频率（默认立刻，在redis.conf配置为缓存一秒）写进磁盘aof文件，可以按条件（redis.conf配置，比上次重写aof文件超过多少百分比时自动重写、aof文件超过多大自动重写）自动重写aof文件中的命令（多次更新同一数据只有最近一次更新有效），故障后从文件读命令恢复数据。不占CPU和内存占IO，能恢复完整或故障1s前的数据但恢复慢。</li></ul><h1 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis 可以通过创建快照来获得存储在内存里面的数据在 <em>某个时间点</em> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。<br>快照持久化是 Redis 默认采用的持久化方式，在 redis.conf 配置文件中默认有此下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           <span class="comment">#在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span><br><span class="line">save 300 10          <span class="comment">#在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span><br><span class="line">save 60 10000        <span class="comment">#在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span><br></pre></td></tr></table></figure><h2 id="RDB-创建快照时会阻塞主线程吗"><a href="#RDB-创建快照时会阻塞主线程吗" class="headerlink" title="RDB 创建快照时会阻塞主线程吗"></a>RDB 创建快照时会阻塞主线程吗</h2><p>Redis 提供了两个命令来生成 RDB 快照文件：</p><ul><li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li><li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li></ul><blockquote><p>这里说 Redis 主线程而非主进程是因为 Redis 启动后主要通过单线程方式完成主要工作。若将其描述为 Redis 主进程，也没毛病。</p></blockquote><h1 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了），可以通过 <code>appendonly</code> 参数开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ <code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中。</p><p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。</p><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 <code>dir</code> 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p><h2 id="AOF-工作基本流程"><a href="#AOF-工作基本流程" class="headerlink" title="AOF 工作基本流程"></a>AOF 工作基本流程</h2><p>AOF 持久化功能的实现可以简单分为 5 步：</p><ol><li><strong>命令追加（append）</strong>：所有的写命令会追加到 <code>AOF 缓冲区</code>中。</li><li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 <code>AOF 文件</code>中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了<code>系统内核缓冲区</code>之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。</li><li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</li><li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 <code>AOF 文件进行重写</code>，达到压缩的目的。</li><li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 <code>AOF 文件</code>进行数据恢复。</li></ol><blockquote><p>Linux 系统直接提供了一些函数用于对文件和设备进行访问和控制，这些函数被称为 <strong>系统调用（syscall）</strong>。</p><p><code>write</code>：写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。</p><p><code>fsync</code>：<code>fsync</code>用于强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。</p></blockquote><h2 id="AOF-的持久化方式"><a href="#AOF-的持久化方式" class="headerlink" title="AOF 的持久化方式"></a>AOF 的持久化方式</h2><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p><ol><li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li><li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li><li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li></ol><p>可以看出：<strong>这 3 种持久化方式的主要区别在于 <code>fsync</code> 同步 AOF 文件的时机（刷盘）</strong>。</p><h2 id="AOF-为何在执行完命令后记录日志"><a href="#AOF-为何在执行完命令后记录日志" class="headerlink" title="AOF 为何在执行完命令后记录日志"></a>AOF 为何在执行完命令后记录日志</h2><p>关系型数据库（如 MySQL）通常都是执行命令前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后记录日志。原因如下：</p><ul><li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ul><p>这样也带来了风险：</p><ul><li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li><li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li></ul><h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。</p><blockquote><p>AOF 重写（rewrite） 是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p></blockquote><p>AOF 文件重写期间，Redis 还会维护一个 <strong>AOF 重写缓冲区</strong>，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p><p>开启 AOF 重写功能，可以调用 <code>BGREWRITEAOF</code> 命令手动执行，也可以设置下面两个配置项，让程序自动决定触发时机：</p><ul><li><code>auto-aof-rewrite-min-size</code>：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;</li><li><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。</li></ul><h2 id="AOF-校验机制"><a href="#AOF-校验机制" class="headerlink" title="AOF 校验机制"></a>AOF 校验机制</h2><p>纯 AOF 模式下，Redis 不会对整个 AOF 文件使用校验和（如 CRC64），而是通过逐条解析文件中的命令来验证文件的有效性。如果解析过程中发现语法错误（如命令不完整、格式错误），Redis 会终止加载并报错，从而避免错误数据载入内存。</p><p>在 <strong>混合持久化模式</strong>（Redis 4.0 引入）下，AOF 文件由两部分组成：</p><ul><li><strong>RDB 快照部分</strong>：文件以固定的 <code>REDIS</code> 字符开头，存储某一时刻的内存数据快照，并在快照数据末尾附带一个 CRC64 校验和（位于 RDB 数据块尾部、AOF 增量部分之前）。</li><li><strong>AOF 增量部分</strong>：紧随 RDB 快照部分之后，记录 RDB 快照生成后的增量写命令。这部分增量命令以 Redis 协议格式逐条记录，无整体或全局校验和。</li></ul><h2 id="Redis-4-0-对持久化机制的优化"><a href="#Redis-4-0-对持久化机制的优化" class="headerlink" title="Redis 4.0 对持久化机制的优化"></a>Redis 4.0 对持久化机制的优化</h2><p>RDB 和 AOF 各有优势，Redis 4.0 开始支持 RDB 和 AOF 混合持久化（默认关闭，可通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><p>官方文档地址：<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a></p><h1 id="如何选择-RDB-和-AOF"><a href="#如何选择-RDB-和-AOF" class="headerlink" title="如何选择 RDB 和 AOF"></a>如何选择 RDB 和 AOF</h1><p><strong>RDB 比 AOF 优秀的地方</strong></p><ul><li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li><li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li></ul><p><strong>AOF 比 RDB 优秀的地方</strong></p><ul><li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li><li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li><li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li></ul><p><strong>综上</strong></p><ul><li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li><li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li><li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li></ul>]]></content>
    
    
    <summary type="html">‌Redis(Remote Dictionary Server)，远程字典服务，是用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，提供多种语言的API。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="Redis" scheme="https://southernfish.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>三大缓存读写策略</title>
    <link href="https://southernfish.github.io/pages/database/cache-read-write-strategies/"/>
    <id>https://southernfish.github.io/pages/database/cache-read-write-strategies/</id>
    <published>2025-09-17T13:15:36.000Z</published>
    <updated>2025-09-20T11:18:48.137Z</updated>
    
    <content type="html"><![CDATA[<p>Cache的读写策略是指在计算机系统中，对于缓存（Cache）的数据读取和写入操作所采取的策略和方法。不同读写策略可根据系统需求和应用场景进行选择和配置，以达到最优性能和效果。本文简单记录了三大缓存读写策略旁路缓存模式、读写穿透、异步缓存写入，它们各有优劣不存在最佳模式，根据具体的业务场景选择适合的缓存读写模式。</p><blockquote><p>参考文章：</p><p><a href="https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html">3种常用的缓存读写策略详解</a></p></blockquote><h1 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h1><p><strong>Cache Aside Pattern ：平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong>该策略中服务端需要同时维系 db 和 cache，并且以 db 的结果为准。</p><h2 id="缓存读写步骤"><a href="#缓存读写步骤" class="headerlink" title="缓存读写步骤"></a>缓存读写步骤</h2><p><strong>写</strong>：由应用先更新 db；然后应用再直接删除 cache 。</p><p><strong>读</strong> ：应用从 cache 中读取数据，读取到就直接返回；若读取不到应用就会从 db 中读取数据返回；然后应用再把数据写到 cache 中。</p><blockquote><p>**在写数据的过程中，是否可以先删除 cache 后更新 db？ **</p><p><strong>答案</strong>：肯定不可以！因为这样可能会造成 <strong>数据库（db）和缓存（Cache）数据不一致</strong>的问题。</p><p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。该过程实际是：请求 1 先把 cache 中的 A 数据删除 → 请求 2 从 db 中读取数据 → 请求 1 再把 db 中的 A 数据更新。</p><p><strong>在写数据的过程中，先更新 db后删除 cache 是否就没有问题？</strong></p><p><strong>答案</strong>：理论上仍可能会出现数据不一致性的问题，但概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。</p><p>举例：请求 1 先读数据 A，请求 2 随后写数据 A，且数据 A 在请求 1 请求前不在缓存中时也有可能产生数据不一致性的问题。该过程实际是：请求 1 从 db 读数据 A → 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） → 请求 1 将数据 A 写入 cache</p></blockquote><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ol><li><p><strong>缺陷 1：首次请求数据一定不在 cache。</strong>解决办法如下：</p><p>数据预热。将热点数据提前放入 cache。</p></li><li><p><strong>缺陷 2：写操作频繁导致 cache 中数据被频繁删除影响缓存命中率 。</strong>解决办法如下：</p><p><strong>数据库和缓存数据强一致</strong>：更新 db 的时同样更新 cache，需加一个锁/分布式锁保证更新 cache 时不存在线程安全问题。</p><p><strong>可短暂地允许数据库和缓存数据不一致</strong>：更新 db 时同样更新 cache，但给缓存一个较短过期时间，如此数据不一致影响也较小。</p></li></ol><hr><h1 id="Read-Write-Through-Pattern（读写穿透）"><a href="#Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read/Write Through Pattern（读写穿透）"></a>Read/Write Through Pattern（读写穿透）</h1><p>该策略中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。在平时在开发过程中非常少见。</p><p><strong>写（Write Through）：</strong>先查 cache，若cache 中不存在，直接更新 db。cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）</p><p><strong>读(Read Through)：</strong>从 cache 中读取数据，读取到就直接返回 。读取不到则先从 db 加载，写入到 cache 后返回响应。</p><blockquote><p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p></blockquote><hr><h1 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h1><p>和 Read/Write Through Pattern 相似都是由 cache 服务来负责 cache 和 db 的读写。</p><p>但不同的是<strong>Read/Write Through 同步更新 cache 和 db，而 Write Behind 只更新缓存不直接更新 db，而是异步批量更新 db。</strong></p><p>这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。平时开发非常少见，但消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。</p><p>Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>]]></content>
    
    
    <summary type="html">‌Redis(Remote Dictionary Server)，远程字典服务，是用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，提供多种语言的API。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="Redis" scheme="https://southernfish.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存与数据库的一致性</title>
    <link href="https://southernfish.github.io/pages/database/db-redis-consistency/"/>
    <id>https://southernfish.github.io/pages/database/db-redis-consistency/</id>
    <published>2025-09-17T13:15:36.000Z</published>
    <updated>2025-09-20T11:18:48.138Z</updated>
    
    <content type="html"><![CDATA[<p>在处理涉及 Redis 和数据库（如 MySQL）的应用时，确保数据的一致性是非常关键的。特别是在高并发环境下，数据的一致性问题可能会变得尤为突出。</p><blockquote><p>推荐文章：</p><p><a href="https://developer.aliyun.com/article/1608405">Redis缓存与数据库如何保证一致性？同步删除+延时双删+异步监听+多重保障方案</a></p></blockquote><h1 id="四种基础同步策略"><a href="#四种基础同步策略" class="headerlink" title="四种基础同步策略"></a>四种基础同步策略</h1><p>保证缓存和数据库的双写一致性，共有<strong>四种同步策略</strong>，即先更新缓存再更新数据库、先更新数据库再更新缓存、先删除缓存再更新数据库、先更新数据库再删除缓存。 </p><ul><li>先更新缓存再更新数据库：第二步失败缓存库是脏数据</li><li><strong>先更新数据库再更新缓存：</strong>第二步失败缓存库是旧数据</li><li>先删除缓存再更新数据库：第二步失败缓存库是空数据</li><li><strong>先更新数据库、再删除缓存（推荐）：</strong>第二步失败缓存库是旧数据 </li></ul><h2 id="更新缓存还是删除缓存"><a href="#更新缓存还是删除缓存" class="headerlink" title="更新缓存还是删除缓存"></a>更新缓存还是删除缓存</h2><h3 id="更新缓存的优缺点"><a href="#更新缓存的优缺点" class="headerlink" title="更新缓存的优缺点"></a>更新缓存的优缺点</h3><p>更新缓存的优点是每次数据变化时都能<strong>及时地更新缓存</strong>，这样不容易出现查询未命中的情况，但这种操作的<strong>消耗很大</strong>，如果数据需要经过复杂的计算再写入缓存的话，频繁的更新缓存会影响到服务器的性能。如果是写入数据比较频繁的场景，可能会导致频繁的更新缓存却没有业务来读取该数据。</p><h3 id="删除缓存的优缺点（推荐）"><a href="#删除缓存的优缺点（推荐）" class="headerlink" title="删除缓存的优缺点（推荐）"></a>删除缓存的优缺点（推荐）</h3><p>删除缓存的优点是<strong>操作简单</strong>，无论更新的操作复杂与否，都是直接删除缓存中的数据。这种做法的缺点则是，当删除了缓存之后，下一次容易出现未命中的情况，那么这时就需要再次读取数据库。 </p><p>那么对比而言，<strong>删除缓存无疑是更好的选择</strong>。 </p><h2 id="先操作数据库还是先删除缓存"><a href="#先操作数据库还是先删除缓存" class="headerlink" title="先操作数据库还是先删除缓存"></a>先操作数据库还是先删除缓存</h2><h3 id="先删除缓存再操作数据库的优缺点"><a href="#先删除缓存再操作数据库的优缺点" class="headerlink" title="先删除缓存再操作数据库的优缺点"></a><strong>先删除缓存再操作数据库的优缺点</strong></h3><p><strong>情况1：数据库和缓存内容不一致</strong></p><p>线程1删除缓存后还没有来得及更新数据库时，线程2读缓存，由于缓存中的数据已经被线程1清空了所以线程2需要去数据库读数据，然后把读到的结果保存到缓存中。此时线程1更新更新数据库成功。就会出现数据库和缓存内容不一致。</p><p><strong>情况2：缓存击穿，数据库卡死</strong></p><p>线程1删除缓存后还没有来得及更新数据库时，来了大量的读请求，由于缓存中没有数据，导致缓存击穿直接将大量请求访问到数据库，导致数据库崩溃。</p><h3 id="先操作数据库再删除缓存的优缺点（推荐）"><a href="#先操作数据库再删除缓存的优缺点（推荐）" class="headerlink" title="先操作数据库再删除缓存的优缺点（推荐）"></a>先操作数据库再删除缓存的优缺点（推荐）</h3><p><strong>脏数据问题：</strong>先操作数据库但删除缓存失败的话，导致缓存库里一直存留着旧数据，而我们数据库里存的是新数据。</p><p><strong>解决办法：异步重试机制</strong></p><p>出现上述问题的时候，我们一般采用重试机制解决，而为了避免重试机制影响主要业务的执行，一般建议重试机制采用<strong>异步</strong>的方式执行。当我们采用重试机制之后由于存在并发，先删除缓存依然可能存在缓存中存储了旧的数据，而数据库中存储了新的数据，二者数据不一致的情况。</p><h2 id="最优同步策略：先更新数据库、再删除缓存"><a href="#最优同步策略：先更新数据库、再删除缓存" class="headerlink" title="最优同步策略：先更新数据库、再删除缓存"></a>最优同步策略：先更新数据库、再删除缓存</h2><p><strong>先更新数据库、再删除缓存是影响更小的方案</strong>。如果第二步出现失败的情况，则可以采用<strong>重试机制</strong>解决问题。</p><p><strong>同步删除方案：</strong> 先更新数据库、再删除缓存。适用于不强制要求数据一致性的情景</p><p><strong>流程：</strong>先更新数据库、再删除缓存。</p><p><strong>问题：</strong></p><ul><li><strong>并发时脏数据：</strong>在查询数据库到写缓存期间其他线程执行了一次更新删除，导致缓存的数据是旧数据</li><li><strong>缓存删除失败：</strong>删除失败导致缓存库还是旧数据</li></ul><h1 id="同步删除-可靠消息方案"><a href="#同步删除-可靠消息方案" class="headerlink" title="同步删除+可靠消息方案"></a>同步删除+可靠消息方案</h1><p><strong>同步删除+可靠消息删除：</strong> 适用于不强制要求数据一致性的情景</p><p><strong>流程：</strong>先更新数据库、再删除缓存，如果删除失败就发可靠MQ不断重试删除缓存，直到删除成功或重试5次。</p><p><strong>问题：</strong>MQ多次重试失败，导致长期脏数据。</p><h1 id="延时双删：更高一致性方案"><a href="#延时双删：更高一致性方案" class="headerlink" title="延时双删：更高一致性方案"></a>延时双删：更高一致性方案</h1><p><strong>延时双删方案：</strong>比同步删除策略一致性更高的方案。</p><p><strong>流程：</strong>先删除缓存再更新数据库，大约在数据库从库更新后再删一次。</p><p><strong>问题：</strong>时间无法控制，不能保证在数据库从库更新后删除缓存。若在从库更新前删除，用户再在更新前查从库又把脏数据写在缓存里了。</p><h1 id="异步监听-可靠消息删除方案"><a href="#异步监听-可靠消息删除方案" class="headerlink" title="异步监听+可靠消息删除方案"></a>异步监听+可靠消息删除方案</h1><p><strong>异步监听+可靠消息删除：</strong>很多大厂正在使用的方案。</p><p><strong>流程：</strong></p><ol><li>更新数据库后不做操作；</li><li><code>Canal</code>等组件监听binlog发现有更新时就发可靠MQ删除缓存；</li><li>如果删除缓存失败，就基于手动<code>ack、retry</code>等机制，让消息在有限次数之内不断重试。</li></ol><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250722220829774.png" alt="image-20250722220829774"></p><p><strong>优点：</strong></p><ul><li>异步删除，性能更高；</li><li>可靠消息重试机制，多次删除保证删除成功。</li></ul><p><strong>问题：</strong>要求<code>canal</code>等<code>binlog</code>抓取组件高可用，如果canal故障，会导致长期脏数据。</p><h1 id="多重保障：最终强一致方案"><a href="#多重保障：最终强一致方案" class="headerlink" title="多重保障：最终强一致方案"></a>多重保障：最终强一致方案</h1><p><strong>多重保障方案：</strong>同步删除+ 异步监听+可靠消息删除，缓存时设置过期时间，查询时强制主库查；适合于强制要求数据一致性的情况</p><ol><li><strong>同步删除：</strong>先更新数据库、再删除缓存；之后本链路禁止再查该数据，防止没来得及删缓存就又查到旧缓存数据。</li><li><strong>Canal监听：</strong>Canal等组件监听binlog发现有更新时就发可靠MQ删除缓存；第二重保证删缓存成功；</li><li><strong>延迟消息校验一致性：</strong>Canal等组件监听binlog，发延迟MQ，N秒后校验缓存一致性；</li><li><strong>缓存过期时间：</strong>每次缓存时设置过期时间；第三重保证删缓存成功；</li><li><strong>强制Redis主库查：</strong>以后查缓存时强制从缓存主库查；因为主从同步有延迟，同时不用担心主库压力大，因为分片集群机制。</li></ol>]]></content>
    
    
    <summary type="html">Redis(Remote Dictionary Server)，远程字典服务，是用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，提供多种语言的API。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="Redis" scheme="https://southernfish.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的缓存穿透、缓存击穿、缓存雪崩</title>
    <link href="https://southernfish.github.io/pages/database/db-redis-produce-problem/"/>
    <id>https://southernfish.github.io/pages/database/db-redis-produce-problem/</id>
    <published>2025-09-17T13:15:36.000Z</published>
    <updated>2025-09-20T11:18:48.139Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单记录了Redis的缓存穿透、缓存击穿、缓存雪崩三大常见生产问题，及对应的解决方案。</p><blockquote><p>推荐文章：</p><p><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-%E9%87%8D%E8%A6%81">Redis常见面试题总结(下)</a></p></blockquote><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>缓存穿透</strong>：简单来说就是大量请求的 key 是不合理的，<strong>缓存和数据库中都不存在</strong>，可用户仍源源不断的发起请求，导致每次请求都到数据库，从而压垮数据库。</p><p>举例：某黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620114220915.png" alt="image-20250620114220915"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li><p><strong>业务层校验</strong></p><ul><li>用户发过来的请求，<strong>根据请求参数进行校验</strong>，对于明显错误的参数，直接拦截返回。</li><li>如请求参数为主键自增id，那么对于请求小于0的id参数，可以直接返回错误请求。</li><li>如传入的邮箱格式不对时直接返回错误消息给客户端。</li></ul></li><li><p><strong>不存在数据设置短过期时间</strong></p><ul><li><p>对于某个查询为空的数据，可以将这个空结果进行<code>Redis</code>缓存，但设置很短的过期时间，命令：<code>SET key value EX 30000</code>。</p></li><li><p>这种方式可解决请求 key 变化不频繁的情况，若黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 缓存大量无效的 key。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInclNullById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheValue</span> <span class="operator">=</span> cache.get(id); <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="literal">null</span>) &#123; <span class="comment">// 缓存为空</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">storageValue</span> <span class="operator">=</span> storage.get(key);<span class="comment">// 从数据库中获取</span></span><br><span class="line">        cache.set(key, storageValue);<span class="comment">// 缓存空对象</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="literal">null</span>) &#123; <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);<span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>布隆过滤器</strong></p><ul><li>布隆过滤器是<strong>一种数据结构，利用极小的内存，可以判断大量的数据</strong>“一定不存在或者可能存在”。</li><li>对于缓存击穿，把所有可能存在的请求的值都都哈希到一个足够大的布隆过滤器中，用户发送的<strong>请求会先被布隆过滤器拦截，一定不存在的数据就直接拦截返回请求参数错误信息给客户端了</strong>，存在的话才会走下面的流程从而避免下一步对数据库的压力。</li></ul></li><li><p><strong>接口限流</strong></p><p>根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。</p><p>后面提到的缓存击穿和雪崩都可以配合接口限流来解决，毕竟这些问题的关键都是有很多请求落到了数据库上造成数据库压力过大。</p><p>限流的具体方案可参考文章：<a href="/pages/high-availability/server-limit-stream/">服务限流</a>。</p></li></ul><hr><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><strong>缓存击穿</strong>：请求的 key 对应的是 <strong>热点数据</strong>，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong>。Redis中一个<code>热点key</code>在失效的同时，大量的请求过来，从而会全部到达数据库，压垮数据库。</p><p>举例：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620115506995.png" alt="image-20250620115506995"></p><h2 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li><strong>设置热点数据永不过期（不推荐）</strong><ul><li>对于某个需要频繁获取的信息，缓存在Redis中，并设置其永不过期。这种方式比较粗暴，对于某些业务场景是不适合的。</li></ul></li><li><strong>提前预热（推荐）</strong>：对热点数据提前预热，将其存入缓存中并设置合理过期时间，如秒杀场景下数据在秒杀结束之前不过期。</li><li><strong>定时更新</strong><ul><li>比如某热点数据的过期时间是1h，那么每到59minutes时，通过定时任务更新热点key，并重新设置其过期时间。</li></ul></li><li><strong>互斥锁（常用</strong>）<ul><li>在缓存失效后，通过设置互斥锁确保只有一个请求去查询数据库并更新缓存。</li><li>在<code>Redis</code>中根据key获得value为空时先锁上，再从数据库加载，加载完毕，释放锁。</li><li>若其他线程也在请求该key时，获取锁失败，则睡眠一段时间（如100ms）后重试。</li></ul></li></ul><h2 id="缓存穿透和缓存击穿的区别"><a href="#缓存穿透和缓存击穿的区别" class="headerlink" title="缓存穿透和缓存击穿的区别"></a>缓存穿透和缓存击穿的区别</h2><p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong></p><hr><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p><strong>缓存雪崩</strong>：简单来说，<strong>Redis中缓存的数据大面积同时失效，或者Redis缓存服务宕机</strong>，导致大量请求直接到数据库，压垮数据库。</p><p>举个例子：缓存中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250620115530134.png" alt="image-20250620115530134"></p><h2 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h2><p><strong>针对 Redis 服务不可用的情况</strong>：</p><ol><li><strong>Redis 集群</strong>：采用 Redis 集群，以防止Redis集群单节点故障导致整个缓存服务不可用。Redis Cluster 和 Redis Sentinel 是两种最常用的 Redis 集群实现方案，详细介绍可以参考：<a href="/pages/database/db-redis-cluster/">Redis 集群</a>。</li><li><strong>多级缓存</strong>：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。</li></ol><p><strong>针对大量缓存同时失效的情况</strong>：</p><ol><li><strong>持久缓存策略</strong>（看情况）：一般不推荐设置缓存永不过期，但对于某些关键性和变化不频繁的数据，可以考虑这种策略。</li><li><strong>设置有效期均匀分布</strong><ul><li><strong>设置随机失效时间</strong>（可选）：避免缓存设置相近的有效期，可为缓存设置随机的失效时间，比如在设置有效期时增加随机值；</li><li>或者统一规划有效期，使得过期时间均匀分布。</li></ul></li><li><strong>数据预热</strong>（推荐）<ul><li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间，比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>对于即将来临的大量请求，可以提前走一遍系统，将数据提前缓存在Redis中，并设置不同的过期时间。<ul><li><strong>使用定时任务</strong>，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</li><li><strong>使用消息队列</strong>，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</li></ul></li></ul></li></ol><h2 id="缓存雪崩和缓存击穿的区别"><a href="#缓存雪崩和缓存击穿的区别" class="headerlink" title="缓存雪崩和缓存击穿的区别"></a>缓存雪崩和缓存击穿的区别</h2><p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在于缓存中（通常是因为缓存中的那份数据已经过期）。</p>]]></content>
    
    
    <summary type="html">‌Redis(Remote Dictionary Server)，远程字典服务，是用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，提供多种语言的API。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="Redis" scheme="https://southernfish.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群</title>
    <link href="https://southernfish.github.io/pages/database/db-redis-cluster/"/>
    <id>https://southernfish.github.io/pages/database/db-redis-cluster/</id>
    <published>2025-09-17T13:15:36.000Z</published>
    <updated>2025-09-20T11:18:48.138Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网高并发、海量数据的场景下，单机 Redis 已无法满足系统对性能、存储和高可用性的需求。Redis 集群作为分布式缓存的终极解决方案，通过巧妙的架构设计实现了数据分片、自动故障转移和动态扩容。本文记录了相关原理、 Redis 集群的核心机制，及完整的实战部署流程。本文简单介绍了Redis的三种集群部署模式：<strong>主从模式，Sentinel（哨兵）模式，Cluster模式。</strong></p><blockquote><p>参考文章：</p><p><a href="https://cloud.tencent.com/developer/article/2169883">Redis集群部署的三种模式</a></p></blockquote><h1 id="Redis-集群模式"><a href="#Redis-集群模式" class="headerlink" title="Redis 集群模式"></a>Redis 集群模式</h1><p>Rdis最开始使用主从模式做集群，若master宕机需手动配置slave转为master；后来为了高可用提出哨兵模式，该模式下有一个哨兵监视master和slave，若master宕机可自动将slave转为master，但它也有一个问题，就是不能动态扩充；所以在3.x提出cluster集群模式。</p><h2 id="三种集群模式对比"><a href="#三种集群模式对比" class="headerlink" title="三种集群模式对比"></a>三种集群模式对比</h2><p>Redis 发展至今形成了三种典型的集群模式，每种模式都针对不同的业务需求进行了优化：</p><table><thead><tr><th>模式</th><th>版本</th><th>核心优势</th><th>局限性</th></tr></thead><tbody><tr><td>主从模式</td><td>Redis 2.8前</td><td>数据备份与读写分离</td><td>手动故障转移、无法动态扩容</td></tr><tr><td>哨兵模式</td><td>Redis 2.8+</td><td>自动故障转移、主从状态监测</td><td>写操作无法负载均衡、存储受限</td></tr><tr><td>Cluster模式</td><td>Redis 3.0+</td><td>分布式分片、动态扩容、自动故障转移</td><td>多Key命令不支持、架构较新</td></tr></tbody></table><p><code>Redis哨兵（Sentinel）</code>是一个高可用性解决方案。哨兵系统可以<strong>监测Redis主从服务器的健康状态，自动执行故障转移，选举新的主服务器，并通知应用程序新主服务器的地址</strong>。哨兵还负责通知管理员，发送警报，并执行自定义脚本响应各种事件。<br><code>Redis集群（Cluster）</code>提供了一个<strong>数据分区（sharding）和自动管理的环境，支持在多个节点间进行数据共享</strong>。它能够在<strong>节点间自动分配数据，并在节点故障时提供自动的故障转移功能</strong>。集群通过分片来提高数据库的可扩展性，并能在不中断服务的情况下，动态地添加或移除节点。</p><hr><h1 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主从模式是三种模式中最简单的，在主从复制中，数据库分为两类：主数据库(master)和从数据库(slave)。其中，主从复制有如下特点：</p><ul><li>主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库；</li><li>从数据库一般是只读的，并且接收主数据库同步过来的数据；</li><li>一个master可以拥有多个slave，但是一个slave只能对应一个master；</li><li>slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来；</li><li>master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务；</li><li>master挂了以后，不会在slave节点中重新选一个master；</li></ul><p><strong>主从模式工作示意图</strong>：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250919221344753.png" alt="image-20250919221344753"></p><h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><ul><li>当slave启动后，主动向master发送SYNC命令。master接收到SYNC命令后在后台保存快照（RDB持久化）和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令。</li><li>复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。</li></ul><h2 id="实践-amp-配置"><a href="#实践-amp-配置" class="headerlink" title="实践&amp;配置"></a>实践&amp;配置</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>需要准备至少3台机器：</p><table><thead><tr><th>主机名</th><th>IP</th><th>角色</th></tr></thead><tbody><tr><td>local-168-10-1</td><td>192.168.10.1</td><td>master</td></tr><tr><td>local-168-10-2</td><td>192.168.10.2</td><td>slave1</td></tr><tr><td>local-168-10-3</td><td>192.168.10.3</td><td>slave2</td></tr></tbody></table><h3 id="下载解压Redis安装包"><a href="#下载解压Redis安装包" class="headerlink" title="下载解压Redis安装包"></a>下载解压Redis安装包</h3><p>下载地址：<a href="http://download.redis.io/releases/%E3%80%82">http://download.redis.io/releases/。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/software</span><br><span class="line">wget http://download.redis.io/releases/redis-7.0.3.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -xf redis-7.0.3.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-7.0.3</span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export REDIS_HOME=/opt/software/redis-7.0.3&quot;</span>&gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="编译安装所有节点"><a href="#编译安装所有节点" class="headerlink" title="编译安装所有节点"></a>编译安装所有节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$REDIS_HOME</span></span><br><span class="line">yum -y install gcc gcc++</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="comment"># 默认安装目录 /usr/local/bin</span></span><br></pre></td></tr></table></figure><h3 id="为安装节点配置服务"><a href="#为安装节点配置服务" class="headerlink" title="为安装节点配置服务"></a>为安装节点配置服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; /usr/lib/systemd/system/redis.service</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Redis persistent key-value database</span></span><br><span class="line"><span class="string">After=network.target</span></span><br><span class="line"><span class="string">After=network-online.target</span></span><br><span class="line"><span class="string">Wants=network-online.target</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">ExecStart=/usr/local/bin/redis-server /usr/local/redis/redis.conf --supervised systemd</span></span><br><span class="line"><span class="string">ExecStop=/usr/libexec/redis-shutdown</span></span><br><span class="line"><span class="string">Type=forking</span></span><br><span class="line"><span class="string">User=redis</span></span><br><span class="line"><span class="string">Group=redis</span></span><br><span class="line"><span class="string">RuntimeDirectory=redis</span></span><br><span class="line"><span class="string">RuntimeDirectoryMode=0755</span></span><br><span class="line"><span class="string">LimitNOFILE=65536</span></span><br><span class="line"><span class="string">PrivateTmp=true</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>配置相关描述和说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Description: # 描述服务</span><br><span class="line">After: # 描述服务类别</span><br><span class="line">[Service] # 服务运行参数的设置</span><br><span class="line">Type=forking # 是后台运行的形式</span><br><span class="line">ExecStart # 为服务的具体运行命令</span><br><span class="line">ExecReload # 为重启命令</span><br><span class="line">ExecStop # 为停止命令</span><br><span class="line">LimitNOFILE=<span class="number">65536</span> # 打开文件数和进程数有限制，默认限制为<span class="number">1024</span>，不设置或设置为LimitNOFILE=unlimited(不识别)，则为<span class="number">1024</span></span><br><span class="line">PrivateTmp=True # 表示给服务分配独立的临时空间</span><br></pre></td></tr></table></figure><blockquote><p>【注意】[Service]的启动、重启、停止命令全部要求使用绝对路径 [Install] #运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</p></blockquote><p>重载系统服务（启停redis）：systemctl daemon-reload。以下是配置，位于/usr/libexec/redis-shutdown路径下。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line"># Wrapper to <span class="built_in">close</span> properly redis <span class="keyword">and</span> sentinel</span><br><span class="line">test x<span class="string">&quot;$REDIS_DEBUG&quot;</span> != x &amp;&amp; set -x</span><br><span class="line">REDIS_CLI=/usr/<span class="keyword">local</span>/bin/redis-cli</span><br><span class="line"># Retrieve service name</span><br><span class="line">SERVICE_NAME=<span class="string">&quot;$1&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;$SERVICE_NAME&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   SERVICE_NAME=redis</span><br><span class="line">fi</span><br><span class="line"># Get the proper <span class="built_in">config</span> file based on service name</span><br><span class="line">CONFIG_FILE=<span class="string">&quot;/usr/local/redis/$SERVICE_NAME.conf&quot;</span></span><br><span class="line"># Use awk to retrieve host, port from <span class="built_in">config</span> file</span><br><span class="line">HOST=`awk <span class="string">&#x27;/^[[:blank:]]*bind/ &#123; print $2 &#125;&#x27;</span> $CONFIG_FILE | tail -n1`</span><br><span class="line">PORT=`awk <span class="string">&#x27;/^[[:blank:]]*port/ &#123; print $2 &#125;&#x27;</span> $CONFIG_FILE | tail -n1`</span><br><span class="line">PASS=`awk <span class="string">&#x27;/^[[:blank:]]*requirepass/ &#123; print $2 &#125;&#x27;</span> $CONFIG_FILE | tail -n1`</span><br><span class="line">SOCK=`awk <span class="string">&#x27;/^[[:blank:]]*unixsocket\s/ &#123; print $2 &#125;&#x27;</span> $CONFIG_FILE | tail -n1`</span><br><span class="line"># Just <span class="keyword">in</span> case, use default host, port</span><br><span class="line">HOST=$&#123;HOST:<span class="number">-127.0</span><span class="number">.0</span><span class="number">.1</span>&#125;</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$SERVICE_NAME&quot;</span> = redis ]; <span class="keyword">then</span></span><br><span class="line">    PORT=$&#123;PORT:<span class="number">-6379</span>&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    PORT=$&#123;PORT:<span class="number">-26739</span>&#125;</span><br><span class="line">fi</span><br><span class="line"># Setup additional parameters</span><br><span class="line"># e.g password-protected redis instances</span><br><span class="line">[ -z <span class="string">&quot;$PASS&quot;</span>  ] || ADDITIONAL_PARAMS=<span class="string">&quot;-a $PASS&quot;</span></span><br><span class="line"># shutdown the service properly</span><br><span class="line"><span class="keyword">if</span> [ -e <span class="string">&quot;$SOCK&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">        $REDIS_CLI -s $SOCK $ADDITIONAL_PARAMS shutdown</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        $REDIS_CLI -h $HOST -p $PORT $ADDITIONAL_PARAMS shutdown</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="授权启动服务相关命令"><a href="#授权启动服务相关命令" class="headerlink" title="授权启动服务相关命令"></a>授权启动服务相关命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /usr/libexec/redis-shutdown</span><br><span class="line">useradd -s /sbin/nologin redis</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis ; <span class="built_in">cp</span> <span class="variable">$REDIS_HOME</span>/redis.conf /usr/local/redis/ &amp;&amp; <span class="built_in">chown</span> -R redis:redis /usr/local/redis</span><br><span class="line"><span class="built_in">mkdir</span> -p /opt/software/redis-7.0.3/data &amp;&amp; <span class="built_in">chown</span> -R redis:redis /opt/software/redis-7.0.3/data</span><br><span class="line">yum install -y bash-completion &amp;&amp; <span class="built_in">source</span> /etc/profile                 <span class="comment"># 命令补全</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure><h3 id="修改linux内核参数"><a href="#修改linux内核参数" class="headerlink" title="修改linux内核参数"></a>修改linux内核参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时生效</span></span><br><span class="line">sysctl  -w  vm.overcommit_memory=1</span><br><span class="line"><span class="comment"># 永久生效</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;vm.overcommit_memory=1&#x27;</span> &gt;&gt; /etc/sysctl.conf &amp;&amp; sysctl -p</span><br><span class="line"><span class="comment">### 可选值：0，1，2。</span></span><br><span class="line"><span class="comment"># 0：表示内核将检查是否有足够可用内存供应用进程使用；若有足够可用内存，内存申请允许；否则内存申请失败，并把错误返回给应用进程。</span></span><br><span class="line"><span class="comment"># 1：表示内核允许分配所有的物理内存，而不管当前的内存状态如何。</span></span><br><span class="line"><span class="comment"># 2：表示内核允许分配超过所有物理内存和交换空间总和的内存。</span></span><br></pre></td></tr></table></figure><h3 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h3><ul><li><p>master节点配置，打开master节点文件，文件位于vi/usr/local/redis/redis.conf，修改配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 192.168.10.1               <span class="comment"># 监听ip，多个ip用空格分隔</span></span><br><span class="line">daemonize <span class="built_in">yes</span>               <span class="comment"># 允许后台启动</span></span><br><span class="line">logfile <span class="string">&quot;/usr/local/redis/redis.log&quot;</span>                <span class="comment"># 日志路径</span></span><br><span class="line"><span class="built_in">dir</span> /opt/software/redis-7.0.3/data                 <span class="comment"># 数据库备份文件存放目录</span></span><br><span class="line">masterauth 123456               <span class="comment"># slave连接master密码，master可省略</span></span><br><span class="line">requirepass 123456              <span class="comment"># 设置master连接密码，slave可省略</span></span><br><span class="line">appendonly <span class="built_in">yes</span>                  <span class="comment"># 在/opt/software/redis-7.0.3/data目录生成appendonly.aof文件，将每一次写操作请求都追加到appendonly.aof 文件中</span></span><br></pre></td></tr></table></figure></li><li><p>slave1节点配置，打开slave1节点文件，文件位于vi/usr/local/redis/redis.conf，修改配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 192.168.10.2               <span class="comment"># 监听ip，多个ip用空格分隔</span></span><br><span class="line">daemonize <span class="built_in">yes</span>               <span class="comment"># 允许后台启动</span></span><br><span class="line">logfile <span class="string">&quot;/usr/local/redis/redis.log&quot;</span>                <span class="comment"># 日志路径</span></span><br><span class="line"><span class="built_in">dir</span> /opt/software/redis-7.0.3/data                 <span class="comment"># 数据库备份文件存放目录</span></span><br><span class="line"><span class="comment">#  replicaof用于追随某个节点的redis，被追随的节点为主节点，追随的为从节点。就是设置master节点</span></span><br><span class="line">replicaof 192.168.10.1 6379</span><br><span class="line">masterauth 123456               <span class="comment"># slave连接master密码，master可省略</span></span><br><span class="line">requirepass 123456              <span class="comment"># 设置master连接密码，slave可省略</span></span><br><span class="line">appendonly <span class="built_in">yes</span>                  <span class="comment"># 在/opt/software/redis-7.0.3/data目录生成appendonly.aof文件，将每一次写操作请求都追加到appendonly.aof 文件中</span></span><br></pre></td></tr></table></figure></li><li><p>slave2节点配置，打开slave2节点文件，文件位于vi/usr/local/redis/redis.conf，修改配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 192.168.10.3               <span class="comment"># 监听ip，多个ip用空格分隔</span></span><br><span class="line">daemonize <span class="built_in">yes</span>               <span class="comment"># 允许后台启动</span></span><br><span class="line">logfile <span class="string">&quot;/usr/local/redis/redis.log&quot;</span>                <span class="comment"># 日志路径</span></span><br><span class="line"><span class="built_in">dir</span> /opt/software/redis-7.0.3/data                 <span class="comment"># 数据库备份文件存放目录</span></span><br><span class="line"><span class="comment">#  replicaof用于追随某个节点的redis，被追随的节点为主节点，追随的为从节点。就是设置master节点</span></span><br><span class="line">replicaof 192.168.10.1 6379</span><br><span class="line">masterauth 123456               <span class="comment"># slave连接master密码，master可省略</span></span><br><span class="line">requirepass 123456              <span class="comment"># 设置master连接密码，slave可省略</span></span><br><span class="line">appendonly <span class="built_in">yes</span>                  <span class="comment"># 在/opt/software/redis-7.0.3/data目录生成appendonly.aof文件，将每一次写操作请求都追加到appendonly.aof 文件中</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="启动Redis服务"><a href="#启动Redis服务" class="headerlink" title="启动Redis服务"></a>启动Redis服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start redis</span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure><h3 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交互式</span></span><br><span class="line">redis-cli -h 192.168.10.1 -a 123456</span><br><span class="line">192.168.10.1:6379&gt; info replication</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式</span></span><br><span class="line">redis-cli -h 192.168.182.110</span><br><span class="line">192.168.10.1:6379&gt; auth 123456</span><br><span class="line">192.168.10.1:6379&gt; info replication</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非交互式</span></span><br><span class="line">redis-cli -h 192.168.10.1 -a 123456 info replication</span><br></pre></td></tr></table></figure><p>如果一切配置都没有问题，Redis的主数据库会不定时的向从数据库同步数据。</p><hr><h1 id="Sentinel（哨兵）模式"><a href="#Sentinel（哨兵）模式" class="headerlink" title="Sentinel（哨兵）模式"></a>Sentinel（哨兵）模式</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>主从模式的弊端就是不具备高可用性，当master挂掉以后，Redis将不能再对外提供写入操作，因此sentinel模式应运而生。sentinel中文含义为哨兵，顾名思义，它的作用就是监控redis集群的运行状况，此模式具有如下一些特点：</p><ul><li>sentinel模式是建立在主从模式的基础上，如果只有一个Redis节点，sentinel就没有任何意义；</li><li>当master挂了以后，sentinel会在slave中选择一个做为master，并修改它们的配置文件，其他slave的配置文件也会被修改，比如slaveof属性会指向新的master；</li><li>当master重新启动后，它将不再是master，而是做为slave接收新的master的同步数据；</li><li>sentinel因为也是一个进程，所以有挂掉的可能，所以sentinel也会启动多个形成一个sentinel集群；</li><li>多sentinel配置的时候，sentinel之间也会自动监控；</li><li>当主从模式配置密码时，sentinel也会同步将配置信息修改到配置文件中；</li><li>一个sentinel或sentinel集群可以管理多个主从Redis，多个sentinel也可以监控同一个redis；</li><li>sentinel最好不要和Redis部署在同一台机器，不然Redis的服务器挂了以后，sentinel也可能会挂掉。</li></ul><p><strong>Sentinel（哨兵）模式工作原理图</strong>：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250919224755151.png" alt="image-20250919224755151"></p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul><li>每个sentinel以每秒钟一次的频率向它所知的master，slave以及其他sentinel实例发送一个 PING 命令；</li><li>如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被sentinel标记为主观下线；</li><li>若一个master被标记为主观下线，则正在监视这个master的所有sentinel要<strong>每秒一次</strong>确认master的确进入了主观下线状态；</li><li>当有足够数量的sentinel（大于等于配置文件指定的值）在指定的时间范围内确认master的确进入了主观下线状态， 则master会被标记为客观下线；</li><li>在一般情况下， 每个sentinel会以每 10 秒一次的频率向它已知的所有master，slave发送 INFO 命令；</li><li>当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 10 秒一次改为 1 秒一次；</li><li>若没有足够数量的sentinel同意master已经下线，master的客观下线状态就会被移除；若master重新向sentinel的 PING 命令返回有效回复，master的主观下线状态就会被移除。</li></ul><h2 id="实践-amp-配置-1"><a href="#实践-amp-配置-1" class="headerlink" title="实践&amp;配置"></a>实践&amp;配置</h2><h3 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h3><blockquote><p>与上述主从模式一样。同时为保证能够最小可能的碟机事件，sentinel 最好跟 redis 部署在不同机器上，sentinel 端口：26379。</p></blockquote><h3 id="配置sentinel"><a href="#配置sentinel" class="headerlink" title="配置sentinel"></a>配置sentinel</h3><p>哨兵模式基于主从模式，所以 redis 的相关配置参考主从模式。只需在主从模式基础上修改sentinel配置文件，配置3个哨兵即可，哨兵的配置可以参考如下内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三个节点创建存储目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /opt/software/redis-7.0.3/sentinel</span><br><span class="line"><span class="built_in">mkdir</span> /opt/software/redis-7.0.3/sentinel ; <span class="built_in">chown</span> -R redis:redis /opt/software/redis-7.0.3/</span><br><span class="line"><span class="built_in">cat</span> &gt;/usr/local/redis/sentinel.conf&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">daemonize yes</span></span><br><span class="line"><span class="string">logfile &quot;/usr/local/redis/sentinel.log&quot;</span></span><br><span class="line"><span class="string"># sentinel工作目录</span></span><br><span class="line"><span class="string">dir &quot;/opt/software/redis-7.0.3/sentinel&quot;</span></span><br><span class="line"><span class="string"># 判断master失效至少需要2个sentinel同意，建议设置为n/2+1，n为sentinel个数</span></span><br><span class="line"><span class="string"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;count&gt;</span></span><br><span class="line"><span class="string">sentinel monitor mymaster 192.168.182.110 6379 2</span></span><br><span class="line"><span class="string">sentinel auth-pass mymaster 123456</span></span><br><span class="line"><span class="string"># 判断master主观下线时间，默认30s</span></span><br><span class="line"><span class="string">sentinel down-after-milliseconds mymaster 30000</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h3 id="启动sentinel"><a href="#启动sentinel" class="headerlink" title="启动sentinel"></a>启动sentinel</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/redis-sentinel /usr/local/redis/sentinel.conf</span><br><span class="line">netstat -tnlp|grep 26379</span><br></pre></td></tr></table></figure><h3 id="故障模拟测试"><a href="#故障模拟测试" class="headerlink" title="故障模拟测试"></a>故障模拟测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停掉master</span></span><br><span class="line">systemctl stop redis</span><br><span class="line">redis-cli -h 192.168.10.1 -a 123456 info replication</span><br></pre></td></tr></table></figure><p>Redis发现master节点出现问题后，会自动切换到其它节点。主要看 master_link_status:up/down</p><p>测试读写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@local-168-10-1 redis-7.0.3]<span class="comment"># redis-cli -h 192.168.10.3 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">&#x27;-a&#x27;</span> or <span class="string">&#x27;-u&#x27;</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">192.168.10.3:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>结果是新的master节点读写能力都是正常的，接下来恢复故障，看能否正常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.10.3 -a 123456 info replication</span><br></pre></td></tr></table></figure><p>结果发现原先的master节点在恢复后并不会主动切换到master角色，而是作为slave角色继续服务。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Sentinel-作用"><a href="#Sentinel-作用" class="headerlink" title="Sentinel 作用"></a>Sentinel 作用</h3><p>Sentinel是一中运行模式，不提供任何的读写过程，它只负责运行特殊的Redis命令执行自动化的故障转移。作用如下：</p><ol><li><strong>监控</strong>：Sentinel会监控redis的每一个节点（master，slave），甚至包括监控自己。</li><li><strong>故障转移</strong>：当一个master节点出现故障后，Sentinel会自动实现故障转移，自动将某一台的slave节点选举为新的master节点</li><li><strong>通知</strong>：通知slave连接线新的master节点，让他们执行replicaof命令成为新的master的slave</li><li><strong>配置提供</strong>：客户端连接 sentinel 请求 master 的地址，如果发生故障转移，sentinel 会通知新的 master 链接信息给客户端。</li></ol><h3 id="节点下线检测-amp-主观下线VS客观下线"><a href="#节点下线检测-amp-主观下线VS客观下线" class="headerlink" title="节点下线检测&amp;主观下线VS客观下线"></a>节点下线检测&amp;主观下线VS客观下线</h3><p>Sentinel 通过定期发送 PING 命令检测节点状态，并根据响应情况判断节点是否下线。主观下线是单个 Sentinel 根据配置时间阈值判断节点无响应的状态，而客观下线需要多个 Sentinel 达成共识后才能触发故障转移。</p><p><strong>主观下线检测</strong>：每个 Sentinel 会以固定频率（默认每秒一次）向所有被监控的节点发送 PING 命令。若节点在 :ml-search-more[down-after-milliseconds]{text=”down-after-milliseconds”}（如 30000 毫秒）内未响应或回复无效内容（如非 PONG、LOADING、MASTERDOWN），则该 Sentinel 会将该节点标记为主观下线。</p><p><strong>客观下线判定</strong>：当多个 Sentinel（默认需超过半数）确认同一主服务器进入主观下线状态后，会通过互相询问（is-master-down-by-addr 命令）达成共识。若所有 Sentinel 均认为主服务器不可达，则触发客观下线判定，随后执行故障转移。</p><h3 id="故障转移流程"><a href="#故障转移流程" class="headerlink" title="故障转移流程"></a>故障转移流程</h3><ol><li><strong>主观下线判定</strong>‌：每个Sentinel 节点独立检查主节点的健康状态，若主节点失联超过配置的阈值（如 down-after-milliseconds 默认 5000 毫秒），则判定该节点主观下线。 ‌</li><li>‌<strong>客观下线判定</strong>‌：当超过指定数量的 Sentinel 节点（如 quorum 值）都判定主节点失联时，系统进入客观下线状态。 ‌</li><li>‌<strong>选举新主节点</strong>‌：使用Raft 协议选举新的Sentinel 领头节点，该节点负责后续故障转移操作。 ‌</li><li>‌<strong>选择最优从节点</strong>‌：领头节点根据配置（如优先选择复制延迟低、在线时间长的从节点）确定晋升的新主节点。 ‌</li><li>‌<strong>晋升新主节点</strong>‌：通过SLAVEOF 命令将选定的从节点晋升为主节点，并更新配置文件。 ‌</li><li>‌<strong>同步数据</strong>‌：新主节点通过复制功能将数据同步给原从节点，完成故障转移</li></ol><h3 id="为什么建议哨兵集群"><a href="#为什么建议哨兵集群" class="headerlink" title="为什么建议哨兵集群"></a>为什么建议哨兵集群</h3><p>目的是为了 <strong>防止误判</strong>，主要基于以下原因：</p><ol><li><strong>故障判断的准确性</strong>：单个Sentinel节点可能因网络延迟或自身故障导致误判，通过多数派投票机制（如2n+1个奇数节点）可确保故障判断的准确性。若节点数量不足3个，无法形成有效投票机制，可能导致主节点误判或延迟发现故障。 ‌</li><li><strong>决策一致性需求</strong>：故障转移决策需全体哨兵节点达成一致，至少3个节点可确保在主节点故障时快速完成选举并切换至备用节点，避免因决策分歧导致服务中断。 ‌</li><li><strong>集群健壮性保障</strong>：哨兵集群采用分布式部署，即使部分节点故障也能维持剩余节点的正常运行，确保监控和故障转移功能持续有效。 ‌</li><li><strong>数据一致性要求</strong>：故障转移过程需同步多个节点数据，3个以上节点可分散数据存储风险，减少单点故障对数据完整性的影响。</li></ol><h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><p>slave必须是在线状态才能参加竞选成为新的master，sentinel在选举新的master时是基于以下3个方面来实现的：</p><ol><li><p><strong>slave的优先级</strong>：可以通过slave-priority手动设置slave的优先级，优先级越高成为master的几率也就越高，优先级最高的slave可以直接成为master，如是没有设置slave的优先级sentinel会采用复制进度进一步判断</p></li><li><p><strong>复制进度</strong>：sentinel会选择出数据最完整也就是复制进度最快的slave节点升级为master</p></li><li><p><strong>runid</strong>：通常经过前面两轮筛选已经成果选出来了新的 master，万一真有多个 slave 的优 先级和复制进度一样的话，那就 runid 小的成为新的 master，每个 redis 节点启动时都有一个 40 字节随机字符串作为运行 id。</p></li></ol><h3 id="如何从-Sentinel-集群选出-Leader"><a href="#如何从-Sentinel-集群选出-Leader" class="headerlink" title="如何从 Sentinel 集群选出 Leader"></a>如何从 Sentinel 集群选出 Leader</h3><p>这就需要用到分布式领域的 <strong>共识算法</strong> 了。简单来说，共识算法就是让分布式系统中的节点就一个问题达成共识。在 sentinel 选举 leader 这个场景下，这些 sentinel 要达成的共识就是谁才是 leader 。 大部分共识算法都是基于 <strong>Paxos 算法</strong>改进而来，在 sentinel 选举 leader 这个场景下使用的是 <strong>Raft 算法</strong>。这是一个比 Paxos 算法更易理解和实现的共识算法—Raft 算法。更具体点来说，Raft 是 MultiPaxos 的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现</p><h3 id="Sentinel-可以防止脑裂吗"><a href="#Sentinel-可以防止脑裂吗" class="headerlink" title="Sentinel 可以防止脑裂吗"></a>Sentinel 可以防止脑裂吗</h3><p>“脑裂”是指主节点和从节点之间出现通信中断，哨兵误判主节点失效并触发故障转移。可以通过设置合理的超时时间和部署多个哨兵节点来降低脑裂的风险。</p><hr><h1 id="Cluster（集群）模式"><a href="#Cluster（集群）模式" class="headerlink" title="Cluster（集群）模式"></a>Cluster（集群）模式</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，redis3.0 加入了 Cluster 集群模式，实现了 Redis 的分布式存储，即每台 Redis 节点上存储不同的内容。下面是Cluster 集群模式的一些特点：</p><ul><li>sentinel模式基本可以满足一般生产的需求，具备高可用性。但当数据量过大到一台服务器存放不下时，主从模式或sentinel模式就不能满足需求了，这个时候需要对存储的数据进行分片，将数据存储到多个Redis实例中。cluster模式的出现就是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器。</li><li>Cluster 是sentinel+主从模式的结合体，通过cluster可实现主从和master重选功能，所以如果配置两个副本三个分片，就需要6个Redis实例。因为Redis的数据是根据一定规则分配到cluster的不同机器的，当数据量过大时，可以新增机器进行扩容。</li><li>使用集群只需将redis配置文件中cluster-enable配置打开即可，每个集群中至少需要三个主数据库才能正常运行，新增节点方便。</li></ul><p><strong>Cluster 集群模式架构示意图</strong></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250919230038247.png" alt="image-20250919230038247"></p><h2 id="实践-amp-配置-2"><a href="#实践-amp-配置-2" class="headerlink" title="实践&amp;配置"></a>实践&amp;配置</h2><h3 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h3><table><thead><tr><th>主机名</th><th>IP</th><th>端口</th><th>角色</th></tr></thead><tbody><tr><td>local-168-10-1</td><td>192.168.10.1</td><td>7001,7002,7003</td><td>node1</td></tr><tr><td>local-168-10-2</td><td>192.168.10.2</td><td>7001,7002,7003</td><td>node2</td></tr><tr><td>local-168-10-3</td><td>192.168.10.3</td><td>7001,7002,7003</td><td>node3</td></tr></tbody></table><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><ol><li><p>基于主从模式的配置做如下修改:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建存储目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /opt/software/redis-7.0.3/cluster/redis_&#123;7001..7003&#125;</span><br><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis.conf /usr/local/redis/cluster_redis_7001.conf</span><br><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis.conf /usr/local/redis/cluster_redis_7002.conf</span><br><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis.conf /usr/local/redis/cluster_redis_7003.conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> -R redis:redis /usr/local/redis ;<span class="built_in">chown</span> -R redis:redis /opt/software/redis-7.0.3/cluster</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件cluster_redis_7001.conf，位于/usr/local/redis/cluster_redis_7001.conf目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 【注意】节点不一样，IP不一样，记得修改这个bind配置</span></span><br><span class="line"><span class="built_in">bind</span> 192.168.10.1</span><br><span class="line">port 7001</span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">pidfile <span class="string">&quot;/var/run/cluster_redis_7001.pid&quot;</span></span><br><span class="line">logfile <span class="string">&quot;/usr/local/redis/cluster_redis_7001.log&quot;</span></span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/opt/software/redis-7.0.3/cluster/redis_7001&quot;</span></span><br><span class="line"><span class="comment">#replicaof 192.168.10.1 6379</span></span><br><span class="line">masterauth <span class="string">&quot;123456&quot;</span></span><br><span class="line">requirepass <span class="string">&quot;123456&quot;</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 开启集群模式</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 虽然此配置的名字叫&quot;集群配置文件&quot;，但是此配置文件不能人工编辑，它是集群节点自动维护的文件，主要用于记录集群中有哪些节点、他们的状态以及一些持久化参数等，方便在重启时恢复这些状态。通常是在收到请求之后这个文件就会被更新。</span></span><br><span class="line">cluster-config-file nodes_7001.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件cluster_redis_7002.conf，位于/usr/local/redis/cluster_redis_7002.conf目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 【注意】节点不一样，IP不一样，记得修改这个bind配置</span></span><br><span class="line"><span class="built_in">bind</span> 192.168.10.1</span><br><span class="line">port 7002</span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">pidfile <span class="string">&quot;/var/run/cluster_redis_7002.pid&quot;</span></span><br><span class="line">logfile <span class="string">&quot;/usr/local/redis/cluster_redis_7002.log&quot;</span></span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/opt/software/redis-7.0.3/cluster/redis_7002&quot;</span></span><br><span class="line"><span class="comment">#replicaof 192.168.10.1 6379</span></span><br><span class="line">masterauth <span class="string">&quot;123456&quot;</span></span><br><span class="line">requirepass <span class="string">&quot;123456&quot;</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 配置yes则开启集群功能，此redis实例作为集群的一个节点，否则，它是一个普通的单一的redis实例。</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 虽然此配置的名字叫&quot;集群配置文件&quot;，但是此配置文件不能人工编辑，它是集群节点自动维护的文件，主要用于记录集群中有哪些节点、他们的状态以及一些持久化参数等，方便在重启时恢复这些状态。通常是在收到请求之后这个文件就会被更新。</span></span><br><span class="line">cluster-config-file nodes_7002.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件cluster_redis_7003.conf，位于/usr/local/redis/cluster_redis_7003.conf目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 【注意】节点不一样，IP不一样，记得修改这个bind配置</span></span><br><span class="line"><span class="built_in">bind</span> 192.168.182.1</span><br><span class="line">port 7003</span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">pidfile <span class="string">&quot;/var/run/cluster_redis_7003.pid&quot;</span></span><br><span class="line">logfile <span class="string">&quot;/usr/local/redis/cluster_redis_7003.log&quot;</span></span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/opt/software/redis-7.0.3/cluster/redis_7003&quot;</span></span><br><span class="line"><span class="comment">#replicaof 192.168.10.1 6379</span></span><br><span class="line">masterauth <span class="string">&quot;123456&quot;</span></span><br><span class="line">requirepass <span class="string">&quot;123456&quot;</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 配置yes则开启集群功能，此redis实例作为集群的一个节点，否则，它是一个普通的单一的redis实例。</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 虽然此配置的名字叫&quot;集群配置文件&quot;，但是此配置文件不能人工编辑，它是集群节点自动维护的文件，主要用于记录集群中有哪些节点、他们的状态以及一些持久化参数等，方便在重启时恢复这些状态。通常是在收到请求之后这个文件就会被更新。</span></span><br><span class="line">cluster-config-file nodes_7003.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure></li><li><p>其它两台机器配置与192.168.10.1一致，只是ip不同，此处省略。</p></li></ol><h3 id="启动Redis服务-1"><a href="#启动Redis服务-1" class="headerlink" title="启动Redis服务"></a>启动Redis服务</h3><p>启动Redis服务的所有的节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis-server /usr/local/redis/cluster_redis_7001.conf</span><br><span class="line">netstat -tnlp|grep 7001</span><br><span class="line">redis-server /usr/local/redis/cluster_redis_7002.conf</span><br><span class="line">netstat -tnlp|grep 7002</span><br><span class="line">redis-server /usr/local/redis/cluster_redis_7003.conf</span><br><span class="line">netstat -tnlp|grep 7003</span><br><span class="line"><span class="built_in">tail</span> -f /usr/local/redis/cluster_redis_7001.<span class="built_in">log</span></span><br><span class="line"><span class="built_in">tail</span> -f /usr/local/redis/cluster_redis_7002.<span class="built_in">log</span></span><br><span class="line"><span class="built_in">tail</span> -f /usr/local/redis/cluster_redis_7003.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>为了能够正常工作，需要集群的一个主节点有2个从节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># –cluster-replicas 2 : 表示集群的一个主节点有2个从节点，就是一主两从模式</span></span><br><span class="line">redis-cli -a 123456 --cluster create \</span><br><span class="line">192.168.10.1:7001 192.168.10.1:7002 192.168.10.1:7003 \</span><br><span class="line">192.168.10.2:7001 192.168.10.2:7002 192.168.10.2:7003 \</span><br><span class="line">192.168.10.3:7001 192.168.10.3:7002 192.168.10.3:7003 \</span><br><span class="line">--cluster-replicas 2</span><br></pre></td></tr></table></figure><p>系统会自动生成nodes.conf文件，打开文件即可看到集群的相关信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /opt/software/redis-7.0.3/cluster/redis_&#123;7001..7003&#125;</span><br></pre></td></tr></table></figure><h3 id="继承操作"><a href="#继承操作" class="headerlink" title="继承操作"></a>继承操作</h3><p>登录集群，集群信息，列出集群节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -h 192.168.10.1 -p 7001</span><br><span class="line">192.168.10.1:7001&gt; auth 123456</span><br><span class="line">192.168.10.1:7001&gt; CLUSTER INFO</span><br><span class="line">192.168.10.1:7001&gt; CLUSTER NODES</span><br></pre></td></tr></table></figure><h3 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h3><p>比如，在node1服务器上增加一节点。</p><ol><li><p>首先添加如下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copy配置</span></span><br><span class="line"><span class="built_in">cp</span> /usr/local/redis/cluster_redis_7003.conf /usr/local/redis/cluster_redis_7004.conf</span><br><span class="line"><span class="comment"># 创建存储目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /opt/software/redis-7.0.3/cluster/redis_7004</span><br><span class="line"><span class="comment"># 修改配置</span></span><br><span class="line">vi /usr/local/redis/cluster_redis_7004.conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span> 192.168.10.1</span><br><span class="line">port 7004</span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">pidfile <span class="string">&quot;/var/run/redis_7004.pid&quot;</span></span><br><span class="line">logfile <span class="string">&quot;/usr/local/redis/cluster_redis_7004.log&quot;</span></span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/opt/software/redis-7.0.3/cluster/redis_7004&quot;</span></span><br><span class="line"><span class="comment">#replicaof 192.168.10.1 6379</span></span><br><span class="line">masterauth <span class="string">&quot;123456&quot;</span></span><br><span class="line">requirepass <span class="string">&quot;123456&quot;</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line">cluster-config-file nodes_7004.conf</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line"><span class="built_in">chown</span> -R redis:redis /usr/local/redis &amp;&amp; <span class="built_in">chown</span> -R redis:redis /opt/software/redis-7.0.3/cluster/redis_7004</span><br></pre></td></tr></table></figure></li><li><p>再启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server /usr/local/redis/cluster_redis_7004.conf</span><br><span class="line">netstat -tnlp|grep :7004</span><br></pre></td></tr></table></figure></li><li><p>如果要在集群中增加节点，可以使用下面的方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@local-168-10-1 ~]<span class="comment"># redis-cli -c -h 192.168.10.1 -p 7001</span></span><br><span class="line">192.168.10.1:7001&gt; auth 123456</span><br><span class="line"><span class="comment"># 添加节点</span></span><br><span class="line">192.168.10.1:7001&gt; CLUSTER MEET 192.168.10.1 7004</span><br><span class="line"><span class="comment"># 查看节点信息</span></span><br><span class="line">192.168.10.1:7001&gt; CLUSTER NODES</span><br></pre></td></tr></table></figure></li><li><p>新增节点都是以master身份加入集群的。如果要【更换节点身份】，比如将新增的192.168.10.1:7004节点身份改为192.168.10.1:7001的slave。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -h 192.168.10.1 -p 7004</span><br><span class="line">192.168.10.1:7004&gt; auth 123456</span><br><span class="line"><span class="comment"># 改变节点类型</span></span><br><span class="line">192.168.10.1:7004&gt; cluster replicate <span class="string">&#x27;所列出节点的id&#x27;</span></span><br><span class="line">192.168.10.1:7004&gt; CLUSTER NODES</span><br></pre></td></tr></table></figure></li></ol><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -h 192.168.10.1 -p 7001</span><br><span class="line">192.168.10.1:7001&gt; auth 123456</span><br><span class="line"><span class="comment"># 查看节点</span></span><br><span class="line">192.168.10.1:7001&gt; CLUSTER NODES</span><br><span class="line"><span class="comment"># 删除节点</span></span><br><span class="line">192.168.10.1:7001&gt; CLUSTER FORGET <span class="string">&#x27;待删除节点id&#x27;</span></span><br><span class="line"><span class="comment"># 检查节点信息</span></span><br><span class="line">192.168.10.1:7001&gt; CLUSTER NODES</span><br></pre></td></tr></table></figure><p>在配置修改完后保存配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -h 192.168.10. -p 7001</span><br><span class="line">192.168.10.1:7001&gt; auth 123456</span><br><span class="line"><span class="comment"># 将节点的配置文件保存到硬盘里面</span></span><br><span class="line">192.168.10.1:7001&gt; CLUSTER SAVECONFIG</span><br></pre></td></tr></table></figure><p>可以看到，之前删除的节点又恢复了，这是因为对应的配置文件没有删除，执行CLUSTER SAVECONFIG恢复。</p><h3 id="故障模拟"><a href="#故障模拟" class="headerlink" title="故障模拟"></a>故障模拟</h3><h4 id="故障转移流程-1"><a href="#故障转移流程-1" class="headerlink" title="故障转移流程"></a>故障转移流程</h4><p>当主节点故障时，集群会按以下步骤完成故障转移：</p><ul><li><strong>故障检测</strong>：超过半数节点认为主节点下线（FAIL状态）</li><li><strong>从节点选举</strong>：基于Raft协议，获得N/2+1票的从节点胜出</li><li><strong>角色切换</strong>：新主节点执行 SLAVEOF NO ONE 成为主节点</li><li><strong>槽位迁移</strong>：新主节点接管原主节点的所有槽位</li><li><strong>集群广播</strong>：通过PONG消息通知所有节点状态变更</li></ul><h4 id="多从节点选举机制"><a href="#多从节点选举机制" class="headerlink" title="多从节点选举机制"></a>多从节点选举机制</h4><p>在多从场景下，选举过程遵循以下规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 从节点发现主节点下线，广播 CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</span><br><span class="line">2. 其他主节点收到请求后，若未投票则返回 CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</span><br><span class="line">3. 从节点收集投票，当票数 ≥ (N/2 + 1) 时当选新主（N为主节点总数）</span><br><span class="line">4. 若选举周期内无节点获足够票数，进入下一轮选举</span><br></pre></td></tr></table></figure><h4 id="模拟主节点挂掉"><a href="#模拟主节点挂掉" class="headerlink" title="模拟主节点挂掉"></a>模拟主节点挂掉</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -lntp |grep :7001|awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span>|<span class="built_in">cut</span> -d <span class="string">&#x27;/&#x27;</span> -f 1|xargs <span class="built_in">kill</span> -9</span><br><span class="line">redis-cli -c -h 192.168.10.1 -p 7001 -a 123456 CLUSTER NODES</span><br></pre></td></tr></table></figure><p>结果，192.168.10.1:7001的一行为master fail，状态为disconnected；而对应192.168.10.1:7004的一行，slave已经变成master。</p><p>再模拟下故障恢复场景，重新启动192.168.10.1:7001节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server /usr/local/redis/cluster_redis_7001.conf</span><br><span class="line">redis-cli -c -h 192.168.10.1 -p 7001 -a 123456 CLUSTER NODES</span><br></pre></td></tr></table></figure><p>结果，192.168.10.1:7001节点启动后为slave节点，并且是192.168.10.1:7004的slave节点。即master节点如果挂掉，它的slave节点变为新master节点继续对外提供服务，而原来的master节点重启后变为新master节点的slave节点。需要说明的是，cluster不能选择db，只能默认db为0，所以select切库相当于是不能使用的。</p><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h3><ul><li>cluster info ：打印集群的信息</li><li>cluster nodes ：列出集群当前已知的所有节点（ node），以及这些节点的相关信息。</li></ul><h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><ul><li>cluster meet ：将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。</li><li>cluster forget <node_id> ：从集群中移除 node_id 指定的节点。</li><li>cluster replicate <node_id> ：将当前节点设置为 node_id 指定的节点的从节点。</li><li>cluster saveconfig ：将节点的配置文件保存到硬盘里面。</li></ul><h3 id="槽-slot-操作"><a href="#槽-slot-操作" class="headerlink" title="槽(slot)操作"></a>槽(slot)操作</h3><ul><li>cluster addslots [slot …] ：将一个或多个槽（ slot）指派（ assign）给当前节点。</li><li>cluster delslots [slot …] ：移除一个或多个槽对当前节点的指派。</li><li>cluster flushslots ：移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。</li><li>cluster setslot node <node_id> ：将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽，然后再进行指派。</li><li>cluster setslot migrating <node_id> ：将本节点的槽 slot 迁移到 node_id 指定的节点中。</li><li>cluster setslot importing <node_id> ：从 node_id 指定的节点中导入槽 slot 到本节点。</li><li>cluster setslot stable ：取消对槽 slot 的导入（ import）或者迁移（ migrate）。</li></ul><h3 id="键"><a href="#键" class="headerlink" title="键"></a>键</h3><ul><li>cluster keyslot ：计算键 key 应该被放置在哪个槽上。</li><li>cluster countkeysinslot ：返回槽 slot 目前包含的键值对数量。</li><li>cluster getkeysinslot ：返回 count 个 slot 槽中的键</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Redis Cluster 通过哈希槽分片与自动故障转移，完美解决了单机 Redis 的三大痛点：<strong>存储限制、写操作瓶颈和手动运维成本</strong>。其无中心化架构与动态扩容能力，使其成为以下场景的首选方案：</p><ul><li><strong>高并发读写</strong>：电商秒杀、社交平台 feed 流</li><li><strong>海量数据存储</strong>：用户行为分析、实时统计系统</li><li><strong>高可用要求</strong>：核心业务缓存、分布式会话存储</li><li><strong>弹性扩展场景</strong>：流量波动大的互联网应用</li></ul><h2 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Redis-Cluster-特性"><a href="#Redis-Cluster-特性" class="headerlink" title="Redis Cluster 特性"></a>Redis Cluster 特性</h3><p>Redis Cluster 作为官方推荐的分布式方案，具有以下革命性突破：</p><ol><li><p><strong>无中心化架构</strong>：所有节点通过 <code>PING-PONG</code> 机制网络互联，数据共享，不存在单点故障，客户端可以连接任何一个主节点进行读写。</p><p>所有的节点都是一主一从（也可以是一主多从），其中从不提供服务，仅作为备用；</p></li><li><p><strong>哈希槽分片</strong>：将数据映射到 16384 个槽位，实现<strong>自动数据分片</strong></p><p>不支持同时处理多个key（如MSET/MGET），因为redis需要把key均匀分布在各个节点上，并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为；</p></li><li><p><strong>智能故障转移</strong>：基于 <code>Raft</code> 协议的选举机制，超过半数节点投票确认故障</p></li><li><p><strong>动态扩容</strong>：支持节点在线添加与删除，自动迁移数据槽位</p></li><li><p><strong>高可用性</strong>：主从复制结合自动故障转移，保证服务持续可用</p></li></ol><h3 id="哈希槽分片机制"><a href="#哈希槽分片机制" class="headerlink" title="哈希槽分片机制"></a>哈希槽分片机制</h3><p>Redis Cluster 采用哈希槽（Hash Slot） 实现数据分片，这是其区别于传统分片方案的关键：</p><ul><li><strong>槽位分配</strong>：16384 个槽位均匀分配给集群中的主节点</li><li><strong>数据路由</strong>：通过 HASH_SLOT = CRC16(key) mod 16384 计算目标槽位</li><li><strong>透明转发</strong>：当客户端请求非本节点槽位时，节点会返回正确节点地址</li></ul><p>Redis 支持<strong>客户端分片，代理分片，服务器端分片（Redis Cluster）</strong>三种分片实现方式，各有适用场景：</p><table><thead><tr><th></th><th>客户端分片</th><th>代理分片</th><th>服务器端分片（Redis Cluster）</th></tr></thead><tbody><tr><td>原理</td><td>在业务代码中实现分片逻辑，直接连接多个 Redis 实例</td><td>通过代理层接收请求并转发至目标节点</td><td>节点自身管理分片逻辑，客户端直接连接</td></tr><tr><td>工具</td><td>无成熟开源方案</td><td>Twemproxy、Codis</td><td>——</td></tr><tr><td>优势</td><td>无中间层开销，性能最佳</td><td>业务无感知，运维方便</td><td>官方支持，无中间层，自动故障转移</td></tr><tr><td>缺点</td><td>代码侵入性强，运维复杂，不适合中小团队</td><td>引入代理层性能损耗（约20%）</td><td>多Key命令限制，需要客户端支持</td></tr></tbody></table><h3 id="为什么是-16384-个哈希槽"><a href="#为什么是-16384-个哈希槽" class="headerlink" title="为什么是 16384 个哈希槽"></a>为什么是 16384 个哈希槽</h3><ul><li><p><strong>均匀分布</strong>：使用 16384 个哈希槽可以提供一种相对均匀的分布方式。这意味着理论上每个节点可以处理大约 16384 / N 个键值对，其中 N 是集群中节点的数量。这种均匀分布有助于减少热点问题（即某些节点负载过重，而其他节点负载较轻）的发生。</p></li><li><p>灵活性：16384 这个数字足够大，可以适应大多数中小型部署的需求。对于大型部署，虽然理论上可以增加更多的哈希槽，但在实践中，考虑到性能和操作的复杂性，16384 已经是一个较为合理的上限。</p></li><li><p><strong>简化计算</strong>：在 Redis Cluster 中，键到哈希槽的映射是通过计算键的 CRC16 值来实现的，然后将这个值对 16384 取模（即 CRC16(key) % 16384），从而确定该键应该存储在哪个哈希槽中。使用 16384 作为模数简化了计算过程，因为它是 2 的幂次方，使得模运算非常高效。</p></li><li><p><strong>网络带宽效率</strong>：Gossip协议的通信成本。Redis集群节点间通过Gossip协议交换集群状态（如节点存活、槽位分配等）。每个节点会定期向其他节点广播自己负责的槽位信息，这些信息通过位图（bitmap）表示，16384个槽对应16384位，恰好<strong>2048字节，即2KB</strong>。若槽位数量更多（如65536=2^16），位图会增至8KB。在节点数量较多时（如100个节点），广播的总数据量会显著增加（从200KB增至800KB），浪费带宽并增加节点处理负担。<br>16384的设计在“槽位数量”和“Gossip通信成本”间取得了平衡，保证了集群状态同步的轻量性。</p></li></ul><h3 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h3><p>在Redis Cluster中，所有节点之间都是通过TCP协议进行通信的。Redis Cluster中的节点间通信主要分为两种方式：</p><ul><li><strong>节点间的gossip通信</strong>：每个节点都会定期向其他节点发送PING消息，以检查其他节点的状态和可用性。同时，节点也会接收其他节点发送的PING消息，并根据接收到的消息更新自己的节点列表。如果一个节点在一定时间内没有回复PING消息，就会被判定为下线，并进行相应的处理，如进行故障转移等。另外，节点之间还会进行CLUSTER MEET消息的交换，以建立新的节点之间的连接。</li><li><strong>节点间的命令通信</strong>：当一个节点接收到客户端的请求后，如果该节点不是负责处理该请求的槽位，则会触发重定向机制，将请求重定向到负责槽位的节点。负责槽位的节点接收到请求后，会进行相应的处理，并将结果返回给客户端。在这种情况下，节点之间会通过TCP协议进行命令通信，以保证数据的正确性和一致性。</li></ul><p>在实现上，Redis Cluster中的节点间通信使用了基于TCP协议的二进制协议，以保证通信的高效性和稳定性。每个节点都会维护一个关于整个集群的拓扑结构，以便进行槽位的分配和重定向机制的触发。同时，Redis Cluster还提供了一些机制，如槽位迁移、故障转移等，以保证数据的可靠性和高可用性。</p><h3 id="确定-key-对应的哈希槽"><a href="#确定-key-对应的哈希槽" class="headerlink" title="确定 key 对应的哈希槽"></a>确定 key 对应的哈希槽</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="comment"># 计算 key 应该落到哪个节点的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_slot</span>(<span class="params">key</span>):</span><br><span class="line">    key_hash = hashlib.md5(key.encode()).digest()</span><br><span class="line">    slot = (key_hash[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | (key_hash[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (key_hash[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | key_hash[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> slot % <span class="number">16384</span></span><br><span class="line"><span class="comment"># 示例 key</span></span><br><span class="line">key = <span class="string">&quot;example_key&quot;</span></span><br><span class="line">slot = calculate_slot(key)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;The key &#x27;<span class="subst">&#123;key&#125;</span>&#x27; should be in slot: <span class="subst">&#123;slot&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="手动干预重新分配哈希槽"><a href="#手动干预重新分配哈希槽" class="headerlink" title="手动干预重新分配哈希槽"></a>手动干预重新分配哈希槽</h3><p>虽然大多数情况下Redis集群可以自动处理哈希槽的迁移，但在某些情况下，可能需要手动干预：</p><p>使用CLUSTER SETSLOT命令：Redis提供了CLUSTER SETSLOT命令来手动指定某个槽应该被迁移到哪个节点。例如，CLUSTER SETSLOT 1234 IMPORTING <node_id>可以用来指示一个节点开始导入槽1234的数据，而CLUSTER SETSLOT 1234 MIGRATING <node_id>则用来指示一个节点开始迁移槽1234的数据到另一个节点。</p><p>使用CLUSTER SETSLOT <slot> NODE <node_id>：这个命令可以用来更改特定槽的主节点。</p><h3 id="扩容缩容期间可以提供服务吗"><a href="#扩容缩容期间可以提供服务吗" class="headerlink" title="扩容缩容期间可以提供服务吗"></a>扩容缩容期间可以提供服务吗</h3><p><em>可以</em>继续提供服务。因为 Redis 的节点会根据集群拓扑结构进行自动重定向，以确保客户端可以找到正确的节点来处理请求。</p><p>扩容和缩容操作指 Redis Cluster 允许在运行时动态添加和移除节点。步骤大致如下：</p><ol><li><p><strong>在已有集群中添加新节点</strong>：添加新的 Redis 节点到已有的集群中</p></li><li><p><strong>将新节点加入集群</strong>：将新的 Redis 节点加入到集群中，并进行握手和插槽分配</p></li><li><p><strong>迁移槽位</strong>：自动将一部分槽位从已有的节点迁移到新的节点上</p></li><li><p><strong>重新分配槽位</strong>：当槽位被迁移到新的节点后，集群会自动重新分配所有的槽位</p></li><li><p><strong>移除旧节点</strong>：当新节点成功加入集群并接管了相应的槽位后，可以选择移除旧的节点</p></li></ol>]]></content>
    
    
    <summary type="html">‌Redis(Remote Dictionary Server)，远程字典服务，是用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，提供多种语言的API。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="Redis" scheme="https://southernfish.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis支持的数据类型</title>
    <link href="https://southernfish.github.io/pages/database/db-redis-datatype/"/>
    <id>https://southernfish.github.io/pages/database/db-redis-datatype/</id>
    <published>2025-09-17T11:43:36.000Z</published>
    <updated>2025-09-20T11:18:48.139Z</updated>
    
    <content type="html"><![CDATA[<p>Redis(Remote Dictionary Server)，远程字典服务，是用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，提供多种语言的API。</p><blockquote><p>参考文章：</p><p><a href="https://javaguide.cn/database/redis/redis-data-structures-01.html">Redis 5 种基本数据类型详解</a></p><p><a href="https://javaguide.cn/database/redis/redis-data-structures-02.html">Redis 3 种特殊数据类型详解</a></p><p><a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter.html">Bloom filter（布隆过滤器）</a></p><p><a href="https://blog.csdn.net/u022812849/article/details/145855462">【redis】数据类型之Bitfields</a></p></blockquote><h1 id="Redis-支持的数据类型"><a href="#Redis-支持的数据类型" class="headerlink" title="Redis 支持的数据类型"></a>Redis 支持的数据类型</h1><ul><li><strong>5 种基础数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li><li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。</li><li>此外，还有一些其他的，比如 Bloom filter（布隆过滤器）、Bitfield（位域）。</li></ul><h2 id="5-种基本数据类型"><a href="#5-种基本数据类型" class="headerlink" title="5 种基本数据类型"></a>5 种基本数据类型</h2><p>Redis 共有 5 种基本数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p><p>这 5 种数据类型是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Dict（哈希表/字典）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。</p><p>Redis 5 种基本数据类型对应的底层数据结构实现如下表所示：</p><table><thead><tr><th align="left">String</th><th align="left">List</th><th align="left">Hash</th><th align="left">Set</th><th align="left">Zset</th></tr></thead><tbody><tr><td align="left">SDS</td><td align="left">LinkedList/ZipList/QuickList</td><td align="left">Dict、ZipList</td><td align="left">Dict、Intset</td><td align="left">ZipList、SkipList</td></tr></tbody></table><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>String 是 Redis 中最简单同时也是最常用的一个数据类型。它是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p><p><strong>应用场景</strong></p><ul><li><strong>常规数据</strong>： 缓存Session、Token、序列化后的对象、图片的路径。相关命令为<code>SET</code>、<code>GET</code>。</li><li><strong>计数</strong>：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。相关命令为<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</li><li><strong>分布式锁</strong>：利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（有缺陷，不推荐）。</li></ul><p>Redis String 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=string">https://redis.io/commands/?group=string</a> 。</p><p>Redis 构建了一种 <strong>简单动态字符串</strong>（Simple Dynamic String，<strong>SDS</strong>）。SDS 相比于 C 语言中的字符串有如下提升：</p><ol><li><strong>可以避免缓冲区溢出</strong>：C 语言中字符串被修改时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小，不满足要求会先扩展至所需大小再进行修改操作。</li><li><strong>获取字符串长度的复杂度较低</strong>：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li><li><strong>减少内存分配次数</strong>：C 语言的字符串修改字符串时，每次都需要重新分配内存。SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li><li><strong>二进制安全</strong>：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，而一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li></ol><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>Redis 中的 List 是链表数据结构的实现，但 C 语言没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><p>Redis List 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=list">https://redis.io/commands/?group=list</a> 。</p><p><strong>应用场景</strong></p><ul><li><strong>信息流展示</strong>：最新文章、最新动态。相关命令为<code>LPUSH</code>、<code>LRANGE</code>。</li><li><strong>消息队列</strong>：可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</li></ul><h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，适合用于存储对象，后续操作时可以直接修改这个对象中的某些字段的值。<br>Hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p><p>Redis Hash 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=hash">https://redis.io/commands/?group=hash</a> 。</p><p><strong>应用场景</strong></p><ul><li><strong>对象数据存储</strong>：用户信息、商品信息、文章信息、购物车信息。相关命令为<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）。</li></ul><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，类似于 Java 的 <code>HashSet</code> 。当要存储列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p><p>可基于 Set 轻易实现交集、并集、差集的操作，比如实现如共同关注、共同粉丝、共同喜好等功能就是求交集的过程。</p><p>Redis Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=set">https://redis.io/commands/?group=set</a> 。</p><p><strong>应用场景</strong></p><ul><li><strong>存放的数据不能重复</strong>：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。相关命令为<code>SCARD</code>（获取集合数量） 。</li><li><strong>获取多个数据源交集、并集和差集</strong>：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。相关命令为<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</li><li><strong>随机获取数据源中的元素</strong>：抽奖系统、随机点名等场景。相关命令为<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</li></ul><h3 id="Sorted-set（有序集合）"><a href="#Sorted-set（有序集合）" class="headerlink" title="Sorted set（有序集合）"></a>Sorted set（有序集合）</h3><p>Sorted Set 类似于 Set，但Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</p><p>Redis Sorted Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=sorted-set">https://redis.io/commands/?group=sorted-set</a> 。</p><p><strong>应用场景</strong></p><ul><li><strong>随机获取数据源中的元素根据某个权重进行排序</strong>：各种排行榜，如直播间送礼物、朋友圈的微信步数、王者荣耀中的段位、话题热度排行榜等。相关命令为<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li><li><strong>存储的数据有优先级或者重要程度</strong>：优先级任务队列。相关命令为<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul><h3 id="String-对比-Hash"><a href="#String-对比-Hash" class="headerlink" title="String 对比 Hash"></a>String 对比 Hash</h3><ul><li><strong>对象存储方式</strong>：String 存储的是序列化后的对象数据，存放的是整个对象，操作简单直接。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li><li><strong>内存消耗</strong>：Hash 通常比 String 更节省内存，特别是在字段较多且字段长度较短时。Redis 对小型 Hash 进行优化（如使用 ziplist 存储），进一步降低内存占用。</li><li><strong>复杂对象存储</strong>：String 在处理多层嵌套或复杂结构的对象时更方便，因为无需处理每个字段的独立存储和操作。</li><li><strong>性能</strong>：String 的操作通常具有 O(1) 的时间复杂度，因为它存储的是整个对象，操作简单直接，整体读写的性能较好。Hash 由于需要处理多个字段的增删改查操作，在字段较多且经常变动的情况下，可能会带来额外的性能开销。</li></ul><p><strong>总结</strong>：</p><ul><li>在绝大多数情况下，<strong>String</strong> 更适合存储对象数据，尤其是当对象结构简单且整体读写是主要操作时。</li><li>如果你需要频繁操作对象的部分字段或节省内存，<strong>Hash</strong> 可能是更好的选择。</li></ul><h2 id="3-种特殊数据类型"><a href="#3-种特殊数据类型" class="headerlink" title="3 种特殊数据类型"></a>3 种特殊数据类型</h2><p>Redis 支持 3 种特殊的数据类型：Bitmap （位图）、HyperLogLog（基数统计）、Geospatial (地理位置)。</p><h3 id="Bitmap-（位图）"><a href="#Bitmap-（位图）" class="headerlink" title="Bitmap （位图）"></a>Bitmap （位图）</h3><p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap，只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p><p>可将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p><p><strong>应用场景</strong></p><ul><li><strong>保存状态信息（0/1 即可表示）</strong>：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。相关命令为<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li></ul><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SETBIT key offset value</td><td>设置指定 offset 位置的值</td></tr><tr><td>GETBIT key offset</td><td>获取指定 offset 位置的值</td></tr><tr><td>BITCOUNT key start end</td><td>获取 start 和 end 之间值为 1 的元素个数</td></tr><tr><td>BITOP operation destkey key1 key2 …</td><td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</td></tr></tbody></table><h3 id="HyperLogLog（基数统计）"><a href="#HyperLogLog（基数统计）" class="headerlink" title="HyperLogLog（基数统计）"></a>HyperLogLog（基数统计）</h3><p>HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。Redis 提供的 HyperLogLog 占用空间非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。另外，Redis 优化了 HyperLogLog 的存储结构，采用两种方式计数：</p><ul><li><strong>稀疏矩阵</strong>：计数较少的时候，占用空间很小。</li><li><strong>稠密矩阵</strong>：计数达到某个阈值的时候，占用 12k 的空间。</li></ul><p>基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> ）。</p><p><strong>应用场景</strong></p><ul><li><strong>数量巨大（百万、千万级别以上）的计数</strong>：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计。相关命令为<code>PFADD</code>、<code>PFCOUNT</code> 。</li></ul><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>PFADD key element1 element2 …</td><td>添加一个或多个元素到 HyperLogLog 中</td></tr><tr><td>PFCOUNT key1 key2</td><td>获取一个或者多个 HyperLogLog 的唯一计数。</td></tr><tr><td>PFMERGE destkey sourcekey1 sourcekey2 …</td><td>将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</td></tr></tbody></table><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial (地理位置)"></a>Geospatial (地理位置)</h3><p>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。通过 GEO 可轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p><p><strong>应用场景</strong></p><ul><li><strong>管理使用地理空间数据</strong>：附近的人。相关命令为 <code>GEOADD</code>、<code>GEORADIUS</code>、<code>GEORADIUSBYMEMBER</code> 。</li></ul><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>GEOADD key longitude1 latitude1 member1 …</td><td>添加一个或多个元素对应的经纬度信息到 GEO 中</td></tr><tr><td>GEOPOS key member1 member2 …</td><td>返回给定元素的经纬度信息</td></tr><tr><td>GEODIST key member1 member2 M/KM/FT/MI</td><td>返回两个给定元素之间的距离</td></tr><tr><td>GEORADIUS key longitude latitude radius distance</td><td>获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数</td></tr><tr><td>GEORADIUSBYMEMBER key member radius distance</td><td>类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</td></tr></tbody></table><hr><h1 id="Bloom-filter（布隆过滤器）"><a href="#Bloom-filter（布隆过滤器）" class="headerlink" title="Bloom filter（布隆过滤器）"></a>Bloom filter（布隆过滤器）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>布隆过滤器（Bloom Filter，BF）是 Bloom 于 1970 年提出的。可以看作由<em>二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）</em>两部分组成的数据结构。相比于 List、Map、Set 等数据结构，它占用空间更少并且效率更高，但其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。</p><p>Bloom Filter 会使用一个较大的 bit 数组来保存所有的数据，数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1（代表 false 或者 true），这也是 Bloom Filter 节省内存的核心所在。这样来算的话，申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 KB ≈ 122KB 的空间。</p><p><strong>总结</strong>：一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>当一个元素加入布隆过滤器中时，会进行如下操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数（多个）对元素值进行<em>哈希计算</em>，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p><strong>当需要判断一个元素是否存在于布隆过滤器时，会进行如下操作：</strong></p><ol><li>对给定元素再次进行相同的<em>哈希计算</em>；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p><strong>注意</strong>：不同的字符串可能哈希出来的位置相同，这种情况可以适当增加位数组大小或者调整我们的哈希函数。</p><p><strong>综上</strong>：布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><strong>判断给定数据是否存在</strong>：判断一个数字是否存在于包含大量数字的数字集中（数字集很大，上亿）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤（判断一个邮件地址是否在垃圾邮件列表中）、黑名单功能（判断一个 IP 地址或手机号码是否在黑名单中）等等。</li><li><strong>去重</strong>：爬给定网址的时候对已经爬取过的 URL 去重、对巨量的 QQ 号/订单号去重。</li></ol><p>去重场景也需要用到判断给定数据是否存在，因此布隆过滤器主要是为了解决海量数据的存在性问题。</p><h2 id="编码实战"><a href="#编码实战" class="headerlink" title="编码实战"></a>编码实战</h2><h3 id="java手动实现"><a href="#java手动实现" class="headerlink" title="java手动实现"></a>java手动实现</h3><p>步骤如下：</p><ol><li>一个合适大小的位数组保存数据</li><li>几个不同的哈希函数</li><li>添加元素到位数组（布隆过滤器）的方法实现</li><li>判断给定元素是否存在于位数组（布隆过滤器）的方法实现。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBloomFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_SIZE</span> <span class="operator">=</span> <span class="number">2</span> &lt;&lt; <span class="number">24</span>; <span class="comment">// 位数组的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] SEEDS = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">13</span>, <span class="number">46</span>, <span class="number">71</span>, <span class="number">91</span>, <span class="number">134</span>&#125;; <span class="comment">// 通过此数组可创建6个不同哈希函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">BitSet</span> <span class="variable">bits</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(DEFAULT_SIZE); <span class="comment">// 位数组。数组中的元素只能是 0 或者 1</span></span><br><span class="line">    <span class="keyword">private</span> SimpleHash[] func = <span class="keyword">new</span> <span class="title class_">SimpleHash</span>[SEEDS.length]; <span class="comment">// 存放包含 hash 函数的类的数组</span></span><br><span class="line">    <span class="comment">// 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBloomFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化多个不同的 Hash 函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SEEDS.length; i++) &#123;</span><br><span class="line">            func[i] = <span class="keyword">new</span> <span class="title class_">SimpleHash</span>(DEFAULT_SIZE, SEEDS[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加元素到位数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</span><br><span class="line">            bits.set(f.hash(value), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断指定元素是否存在于位数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</span><br><span class="line">            ret = ret &amp;&amp; bits.get(f.hash(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hash 操作的 静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleHash</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cap;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> seed;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SimpleHash</span><span class="params">(<span class="type">int</span> cap, <span class="type">int</span> seed)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cap = cap;</span><br><span class="line">            <span class="built_in">this</span>.seed = seed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算 hash 值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">            <span class="type">int</span> h;</span><br><span class="line">            <span class="keyword">return</span> (value == <span class="literal">null</span>) ? <span class="number">0</span> : Math.abs((cap - <span class="number">1</span>) &amp; seed * ((h = value.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下所示，得出结果为 false false true true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="string">&quot;https://javaguide.cn/&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="string">&quot;https://github.com/Snailclimb&quot;</span>;</span><br><span class="line"><span class="type">MyBloomFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBloomFilter</span>();</span><br><span class="line">System.out.println(filter.contains(value1));</span><br><span class="line">System.out.println(filter.contains(value2));</span><br><span class="line">filter.add(value1);</span><br><span class="line">filter.add(value2);</span><br><span class="line">System.out.println(filter.contains(value1));</span><br><span class="line">System.out.println(filter.contains(value2));</span><br></pre></td></tr></table></figure><h3 id="利用-Guava-自带的布隆过滤器"><a href="#利用-Guava-自带的布隆过滤器" class="headerlink" title="利用 Guava 自带的布隆过滤器"></a>利用 Guava 自带的布隆过滤器</h3><p>在项目中引入 Guava 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>28.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建布隆过滤器对象</span></span><br><span class="line">BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</span><br><span class="line">    Funnels.integerFunnel(),</span><br><span class="line">    <span class="number">1500</span>,     <span class="comment">// 最多 1500 个整数的布隆过滤器</span></span><br><span class="line">    <span class="number">0.01</span>);     <span class="comment">// 容忍误判的概率为百分之（0.01）</span></span><br><span class="line"><span class="comment">// 判断指定元素是否存在</span></span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 将元素添加进布隆过滤器</span></span><br><span class="line">filter.put(<span class="number">1</span>);</span><br><span class="line">filter.put(<span class="number">2</span>);</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><blockquote><p>当 <code>mightContain()</code> 返回 <em>true</em> 时， 可以99％确定该元素在过滤器中，返回 <em>false</em> 时，可以 100％确定该元素不存在于过滤器中。</p><p>缺陷：只能单机使用，容量扩展也不容易，而现在互联网一般都是分布式的场景，需要用到 Redis 中的布隆过滤器</p></blockquote><h2 id="Redis-中的布隆过滤器"><a href="#Redis-中的布隆过滤器" class="headerlink" title="Redis 中的布隆过滤器"></a>Redis 中的布隆过滤器</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。布隆过滤器就是其中的 Module。官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module，地址：<a href="https://github.com/RedisBloom/RedisBloom">https://github.com/RedisBloom/RedisBloom</a></p><p>其他还有：</p><ul><li>redis-lua-scaling-bloom-filter（lua 脚本实现）：<a href="https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter">https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter</a></li><li>pyreBloom（Python 中的快速 Redis 布隆过滤器）：<a href="https://github.com/seomoz/pyreBloom">https://github.com/seomoz/pyreBloom</a></li></ul><p>RedisBloom 提供了多种语言的客户端支持，包括：Python、Java、JavaScript 和 PHP。</p><h3 id="使用-Docker-安装"><a href="#使用-Docker-安装" class="headerlink" title="使用 Docker 安装"></a>使用 Docker 安装</h3><p>直接在 Google 搜索 docker redis bloomfilter，具体地址：<a href="https://hub.docker.com/r/redislabs/rebloom/%EF%BC%88%E4%BB%8B%E7%BB%8D%E7%9A%84%E5%BE%88%E8%AF%A6%E7%BB%86">https://hub.docker.com/r/redislabs/rebloom/（介绍的很详细</a> ）。</p><p><strong>具体操作如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest</span><br><span class="line">docker <span class="built_in">exec</span> -it redis-redisbloom bash</span><br><span class="line">root@21396d02c252:/data<span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：当前 rebloom 镜像已经被废弃，官方推荐使用<a href="https://hub.docker.com/r/redis/redis-stack">redis-stack</a></strong></p></blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><blockquote><p>注意：key : 布隆过滤器的名称，item : 添加的元素。</p></blockquote><ol><li><code>BF.ADD</code>：将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器。格式：<code>BF.ADD &#123;key&#125; &#123;item&#125;</code>。</li><li><code>BF.MADD</code> : 将一个或多个元素添加到“布隆过滤器”中，并创建一个尚不存在的过滤器。该命令的操作方式<code>BF.ADD</code>与之相同，只不过它允许多个输入并返回多个值。格式：<code>BF.MADD &#123;key&#125; &#123;item&#125; [item ...]</code> 。</li><li><code>BF.EXISTS</code> : 确定元素是否在布隆过滤器中存在。格式：<code>BF.EXISTS &#123;key&#125; &#123;item&#125;</code>。</li><li><code>BF.MEXISTS</code>：确定一个或者多个元素是否在布隆过滤器中存在。格式：<code>BF.MEXISTS &#123;key&#125; &#123;item&#125; [item ...]</code>。</li><li> <code>BF.RESERVE</code>： 自定义参数的布隆过滤器。格式：<code>BF.RESERVE &#123;key&#125; &#123;error_rate&#125; &#123;capacity&#125; [EXPANSION expansion]</code> 。</li><li><em>key</em>：布隆过滤器的名称</li><li><em>error_rate</em> : 期望的误报率。该值必须介于 0 到 1 之间。例如，对于期望的误报率 0.1％（1000 中为 1），error_rate 应该设置为 0.001。该数字越接近零，则每个项目的内存消耗越大，并且每个操作的 CPU 使用率越高。</li><li><em>capacity</em>: 过滤器的容量。当实际存储的元素个数超过这个值之后，性能将开始下降。实际的降级将取决于超出限制的程度。随着过滤器元素数量呈指数增长，性能将线性下降。</li><li><em>expansion</em>：可选参数。如果创建了一个新的子过滤器，则其大小将是当前过滤器的大小乘以<code>expansion</code>。默认扩展值为 2。这意味着每个后续子过滤器将是前一个子过滤器的两倍。</li></ol><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BF.ADD myFilter java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.ADD myFilter javaguide</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter javaguide</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter github</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><hr><h1 id="Bitfield（位域）"><a href="#Bitfield（位域）" class="headerlink" title="Bitfield（位域）"></a>Bitfield（位域）</h1><p>Bitfields（位域）与Bitmap一样，在Redis中不是一种独立的数据类型，而是一种基于字符串的数据结构，用于处理位级别的操作。允许用户将一个Redis字符串视作由一系列二进制位组成的数组，并对这些位进行高效的访问和操作。通过Bitfield，开发者可以将多个小的整数存储到一个较大的位图中，或者将一个庞大的键分割为多个较小的键进行存储，从而极大地提高了内存的使用效率。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>位域</strong>（Bitfield）：在Redis中，位域是一种特殊的数据结构，用于存储和操作二进制位数据。</p><p><strong>字符串与位域</strong>：虽然Redis字符串是最基本的数据类型之一，支持丰富的操作，但在处理位级数据时，字符串的效率较低。相比之下，位域通过压缩存储多个小的整数或状态信息，极大地提高了内存的使用效率</p><h2 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h2><p>bitfield是redis的一个命令，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITFIELD key [GET <span class="built_in">type</span> offset] [SET <span class="built_in">type</span> offset value] [INCRBY <span class="built_in">type</span> offset increment] [OVERFLOW WRAP|SAT|FAIL]</span><br></pre></td></tr></table></figure><h3 id="获取操作"><a href="#获取操作" class="headerlink" title="获取操作"></a>获取操作</h3><p><strong>语法</strong>：BITFIELD key [GET type offset]</p><p><strong>功能</strong>：获取指定键的位域值。</p><p><strong>参数</strong>：</p><ul><li><code>key</code>：要操作的Redis键。</li><li><code>GET</code>：表示要从字符串值中读取位。</li><li><code>type</code>：指定读取数据的类型（u表示无符号整数，i表示有符号整数）。</li><li><code>offset</code>：位字段的起始偏移位置，从0开始计数。</li></ul><h3 id="设置操作"><a href="#设置操作" class="headerlink" title="设置操作"></a>设置操作</h3><p><strong>语法</strong>：BITFIELD key [SET type offset value]</p><p><strong>功能</strong>：设置指定位域的值并返回其原值。</p><p><strong>参数</strong>：</p><ul><li><code>SET</code>：表示要设置字符串值中的位。</li><li><code>type</code>：指定读取数据的类型（u表示无符号整数，i表示有符号整数）。</li><li><code>offset</code>：位字段的起始偏移位置，从0开始计数。</li><li><code>value</code>：是要设置的值。</li></ul><h3 id="自增操作"><a href="#自增操作" class="headerlink" title="自增操作"></a>自增操作</h3><p><strong>语法</strong>：BITFIELD key [INCRBY type offset increment]</p><p><strong>功能</strong>：对指定位域的值进行自增操作。</p><p><strong>参数</strong>：</p><ul><li><code>key</code>：要操作的Redis键。</li><li><code>INCRBY</code>：表示自增。</li><li><code>type</code>：指定读取数据的类型（u表示无符号整数，i表示有符号整数）。</li><li><code>offset</code>：位字段的起始偏移位置，从0开始计数。</li><li><code>increment</code>：是自增的数值。</li></ul><h3 id="溢出控制"><a href="#溢出控制" class="headerlink" title="溢出控制"></a>溢出控制</h3><p>Bitfield提供了三种溢出控制方式：</p><ul><li><code>WRAP</code>：使用回绕方法处理有符号整数和无符号整数的溢出情况。</li><li><code>SAT</code>：使用饱和计算处理溢出，超过最大值再增加则数值不变。下溢计算的结果为最小整数值，上溢计算的结果为最大的整数值。</li><li><code>FAIL</code>：命令将拒绝执行那些会导致上溢或者下溢情况出现的计算，并向用户返回空值表示计算未被执行。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>集合运算</strong>：使用位掩码来表示集合中的元素，可以高效地进行集合运算，如并集、交集和差集。如使用一个整数的每一位来表示一个用户的兴趣标签，然后通过位运算来快速查询某个用户感兴趣的所有内容。</p><p><strong>计数器</strong>：BitField可以用来实现高效的计数器，尤其是在需要对大量离散事件进行计数时。如使用一个BitField来记录某个在线游戏中的玩家死亡次数，或者记录某个网站的访问次数。</p><p><strong>状态压缩</strong>：对于需要存储大量状态信息的情况，使用BitField可以将状态信息压缩到更少的存储空间中。如使用一个BitField来表示一个游戏中的多个游戏角色的状态，如是否在线、是否死亡等。</p><p><strong>权限控制</strong>：BitField可以用于实现复杂的权限控制系统，通过位运算来快速检查用户是否具有某个权限。如使用一个BitField来表示用户的权限集合，然后通过位运算来检查用户是否具有访问某个资源的权限。</p><p><strong>空间优化</strong>：对于需要存储大量二进制数据的情况，使用BitField可以节省存储空间。如使用一个BitField来表示一张图像的颜色信息，而不是使用完整的字节或整数来存储每个像素的颜色值。</p><p><strong>网络协议优化</strong>：在网络通信中，使用BitField可以有效地压缩和传输数据。如使用一个BitField来表示一个TCP数据包中的标志位，从而减少数据包的大小和提高传输效率。</p><blockquote><p><strong>注意</strong>：虽然BitField提供了高效的存储和操作位级数据的能力，但它也有一些限制和缺点，如不支持事务、不支持范围查询等。因此，在使用BitField时，需要根据具体的应用场景和需求来权衡其优缺点。</p></blockquote><h3 id="在Java中的使用"><a href="#在Java中的使用" class="headerlink" title="在Java中的使用"></a>在Java中的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RBitSet;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="comment">// redisson中bitfields的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonBitfieldsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置Redisson客户端</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建Redisson客户端实例</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="comment">// 表示用户的状态</span></span><br><span class="line">        <span class="comment">// 第0~15位：用户等级，共16位</span></span><br><span class="line">        <span class="comment">// 第16~47位：剩余积分，共32位</span></span><br><span class="line">        <span class="comment">// 第48位：是否VIP，1位布尔值</span></span><br><span class="line">        <span class="type">RBitSet</span> <span class="variable">userStatus</span> <span class="operator">=</span> redisson.getBitSet(<span class="string">&quot;user:status:10086&quot;</span>);</span><br><span class="line">        userStatus.setShort(<span class="number">0</span>, (<span class="type">short</span>) <span class="number">5</span>); <span class="comment">// 用户等级为5</span></span><br><span class="line">        userStatus.setInteger(<span class="number">16</span>, <span class="number">1100</span>); <span class="comment">// 用户剩余积分1100</span></span><br><span class="line">        userStatus.setByte(<span class="number">48</span>, (<span class="type">byte</span>) <span class="number">1</span>); <span class="comment">// 用户是VIP</span></span><br><span class="line">        System.out.println(userStatus.getShort(<span class="number">0</span>)); <span class="comment">// 5</span></span><br><span class="line">        System.out.println(userStatus.getInteger(<span class="number">16</span>)); <span class="comment">// 1100</span></span><br><span class="line">        System.out.println(userStatus.getByte(<span class="number">48</span>)); <span class="comment">// 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentScore</span> <span class="operator">=</span> userStatus.incrementAndGetInteger(<span class="number">16</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(currentScore); <span class="comment">// 1200</span></span><br><span class="line">        redisson.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">‌Redis(Remote Dictionary Server)，远程字典服务，是用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，提供多种语言的API。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="Redis" scheme="https://southernfish.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁详解</title>
    <link href="https://southernfish.github.io/pages/distributed/distributed-lock/"/>
    <id>https://southernfish.github.io/pages/distributed/distributed-lock/</id>
    <published>2025-09-17T11:34:36.000Z</published>
    <updated>2025-09-20T11:18:48.139Z</updated>
    
    <content type="html"><![CDATA[<p>分布式锁的英文是<strong>Distributed Lock</strong>。该术语用于描述在多节点系统中控制资源访问的关键技术，通过协调各节点对共享资源的操作权限，确保同一时刻只有一个节点能持有锁。</p><p>多线程环境中，线程之间常用互斥锁实现共享资源的独占访问。在多进程环境，特别是分布式环境，常使用分布式锁来实现共享资源的独占访问。简单来说，分布式锁就是指在分布式环境下，通过加解锁实现多节点对共享资源的互斥访问。</p><blockquote><p>参考文章：</p><p><a href="https://javaguide.cn/distributed-system/distributed-lock.html">分布式锁介绍</a></p><p><a href="https://javaguide.cn/distributed-system/distributed-lock-implementations.html">分布式锁常见实现方案总结</a></p></blockquote><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p><strong>分布式锁的用途</strong>：分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。<br>• <strong>分布式锁应具备的条件</strong>：互斥、高可用、可重入、高性能、非阻塞。<br>• <strong>分布式锁的常见实现方式</strong>：关系型数据库比如 MySQL、分布式协调服务 ZooKeeper、分布式键值存储系统比如 Redis 、Etcd 。</p><h2 id="分布式锁-1"><a href="#分布式锁-1" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><strong>分布式锁</strong></p><ul><li>控制分布式系统<strong>不同进程共同访问共享资源</strong>的一种锁的实现。</li><li>如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往<strong>需要互斥来防止彼此干扰，以保证一致性</strong>。</li></ul><p><strong>特征</strong></p><ul><li><code>互斥性</code>: 任意时刻，只有一个客户端能持有锁。</li><li><code>锁超时释放</code>：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。</li><li><code>可重入性</code>:一个线程如果获取了锁之后,可以再次对其请求加锁。</li><li><code>高性能和高可用</code>：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。</li><li><code>安全性</code>：锁只能被持有的客户端删除，不能被其他客户端删除。</li></ul><p><strong>Redis分布式锁</strong></p><ul><li>其实就是在系统里面<strong>占一个“坑”，其他程序也要占“坑”时，占用成功了就可继续执行，失败了只能放弃或稍后重试</strong>。</li></ul><h2 id="Redis-分布式锁的缺陷"><a href="#Redis-分布式锁的缺陷" class="headerlink" title="Redis 分布式锁的缺陷"></a>Redis 分布式锁的缺陷</h2><p>Redis 分布式锁不能解决超时的问题，分布式锁<strong>有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题</strong>。</p><h2 id="Redis分布式锁实现"><a href="#Redis分布式锁实现" class="headerlink" title="Redis分布式锁实现"></a>Redis分布式锁实现</h2><h3 id="方案一：SETNX-EXPIRE"><a href="#方案一：SETNX-EXPIRE" class="headerlink" title="方案一：SETNX + EXPIRE"></a>方案一：SETNX + EXPIRE</h3><p><strong>先用<code>setnx</code>来抢锁，抢到之后，再用<code>expire</code>给锁设置一个过期时间，防止锁忘记了释放</strong>。<br>SETNX 是<code>SET IF NOT EXISTS</code>的简写。命令格式是<code>SETNX key value</code>，若 key不存在，则SETNX成功返回1，若这个key已经存在，则返回0。<br>该方案中，setnx和expire两个命令分开了，<strong>不是原子操作</strong>。若执行完setnx加锁，正要执行expire设置过期时间时，进程crash或要重启维护了，那么这个锁就“长生不老”了，<strong>别的线程永远获取不到锁</strong>。<br>假设某电商网站的<strong>某商品做秒杀活动</strong>，key可以设置为<code>key_resource_id,value</code>设置任意值，<em>伪代码如下</em>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.setnx(key_resource_id, lock_value) == 1)&#123; // 加锁</span><br><span class="line">  expire(key_resource_id，100);// 设置过期时间</span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="keyword">do</span> something // 业务请求</span><br><span class="line">  &#125; <span class="function"><span class="title">catch</span></span>()&#123;</span><br><span class="line">    // ......</span><br><span class="line">  &#125; finally&#123;</span><br><span class="line">    jedis.del(key_resource_id); // 释放锁</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案二：SETNX-value值是-系统时间-过期时间"><a href="#方案二：SETNX-value值是-系统时间-过期时间" class="headerlink" title="方案二：SETNX + value值是(系统时间+过期时间)"></a>方案二：SETNX + value值是(系统时间+过期时间)</h3><p>为了<em>解决发生异常锁得不到释放的场景</em>，<strong>把过期时间放到<code>setnx</code>的<code>value</code>值里面</strong>。若加锁失败，再拿出value值校验一下即可</p><p>但这个方案有<strong>缺点</strong>：<br>过期时间是客户端自己生成的（<code>System.currentTimeMillis()</code>是当前系统的时间），要求分布式环境下，每个<strong>客户端的时间必须同步</strong>。<br>若锁过期的时候，并发多个客户端同时请求过来，都执行<code>jedis.getSet()</code>，最终只能有一个客户端加锁成功，但该客户端锁的过期时间，可能被别的客户端覆盖。<br><strong>该锁没有保存持有者的唯一标识，可能被别的客户端释放/解锁。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">long expires = System.currentTimeMillis() + expireTime;// 系统时间+设置的过期时间</span><br><span class="line">String expiresStr = String.value0f(expires);</span><br><span class="line">// 如果当前锁不存在，返回加锁成功</span><br><span class="line"><span class="keyword">if</span>(jedis.setnx(key resource <span class="built_in">id</span>,expiresStr) == 1)&#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 如果锁已经存在，获取锁的过期时间</span><br><span class="line">String currentValueStr = jedis.get(key resource <span class="built_in">id</span>);</span><br><span class="line">// 如果杂取到的过期时间，小于系统当前时间，表示已经过期</span><br><span class="line"><span class="keyword">if</span>(currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis())&#123;</span><br><span class="line">  // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span><br><span class="line">  String oldValueStr =jedis.getSet(key resource <span class="built_in">id</span>, expiresStr);</span><br><span class="line">  <span class="keyword">if</span>(oldValueStr != null &amp;&amp; oldValueStr.equals(currentValueStr))&#123;</span><br><span class="line">    // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 其他情况，均返回加锁失败</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="方案三：使用Lua脚本-包含SETNX-EXPIRE两条指令"><a href="#方案三：使用Lua脚本-包含SETNX-EXPIRE两条指令" class="headerlink" title="方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)"></a>方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)</h3><p>可以使用Lua脚本来保证原子性（包含<code>setnx</code>和<code>expire</code>两条指令）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// lua脚本如下：</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;setnx&#x27;</span>,KEYS[1],ARGV[1]) == 1 <span class="keyword">then</span></span><br><span class="line">   redis.call(<span class="string">&#x27;expire&#x27;</span>,KEYS[1],ARGV[2])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">return</span> 0</span><br><span class="line">end;</span><br><span class="line">// 加锁代码如下：</span><br><span class="line">String lua_scripts = <span class="string">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +</span><br><span class="line">        <span class="string">&quot; redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;   </span><br><span class="line">Object result = jedis.eval(lua_scripts, Collections.singletonList(key_resource_id), Collections.singletonList(values));</span><br><span class="line">//判断是否成功</span><br><span class="line"><span class="built_in">return</span> result.equals(1L);</span><br></pre></td></tr></table></figure><h3 id="方案四：SET的扩展命令（SET-EX-PX-NX）"><a href="#方案四：SET的扩展命令（SET-EX-PX-NX）" class="headerlink" title="方案四：SET的扩展命令（SET EX PX NX）"></a>方案四：SET的扩展命令（SET EX PX NX）</h3><p>巧用Redis的SET指令扩展参数，它也是原子性的！伪代码如下：<br><code>SET key value[EX seconds][PX milliseconds][NX|XX]</code></p><ul><li><code>NX</code>：表示key不存在时，才能set成功，也保证只有第一个客户端请求才能获得锁。其他客户端请求只能等其释放锁，才能获取。</li><li><code>EX seconds</code>：设定key的过期时间，时间单位是秒。</li><li><code>PX milliseconds</code>：设定key的过期时间，单位为毫秒</li><li><code>XX</code>：仅当key存在时设置值</li></ul><p>这个方案可能<strong>存在问题</strong>：</p><ul><li><strong>锁过期释放了，业务还没执行完</strong>。<ul><li>假设线程a获取锁成功，一直在执行临界区的代码。100s过去后，它还没执行完。但锁已过期，此时线程b请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么临界区的业务代码都不是严格串行执行的了。</li></ul></li><li><strong>锁被别的线程误删</strong><ul><li>假设线程a执行完后，去释放锁。但它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但线程b临界区业务代码可能都还没执行完。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.set(key_resource <span class="built_in">id</span>, lock_value, <span class="string">&quot;NX&quot;</span>,<span class="string">&quot;EX&quot;</span>，100s) == 1)&#123; // 加锁</span><br><span class="line">  try &#123;</span><br><span class="line">    // <span class="keyword">do</span> something 业务处理</span><br><span class="line">  &#125; <span class="function"><span class="title">catch</span></span>()&#123;</span><br><span class="line">    // ......</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    jedis.del(key_resource_id); // 释放锁</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案五：SET-EX-PX-NX-校验唯一随机值，再删除"><a href="#方案五：SET-EX-PX-NX-校验唯一随机值，再删除" class="headerlink" title="方案五：SET EX PX NX  + 校验唯一随机值，再删除"></a>方案五：SET EX PX NX  + 校验唯一随机值，再删除</h3><p>既然锁可能被别的线程误删，那我们<strong>给value值设置一个标记当前线程唯一的随机数，在删除的时候，校验一下</strong>，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.<span class="built_in">set</span>(key _resource id, uni_request id, <span class="string">&quot;NX&quot;</span>,<span class="string">&quot;EX&quot;</span>，<span class="number">100</span>s) == <span class="number">1</span>)&#123; <span class="comment">// 加锁</span></span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="comment">// do something 业务处理</span></span><br><span class="line">  &#125; catch()&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    <span class="comment">// 判断是不是当前线程加的锁, 是才释放</span></span><br><span class="line">    <span class="keyword">if</span>(uni request id.equals(jedis.get(key resource id)))&#123;</span><br><span class="line">      jedis.del(lockKey);<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断是不是当前线程加的锁 和 释放锁 不是原子操作</strong>。调用<code>jedis.del()</code>释放锁时，可能这把锁已经不属于当前客户端，会解除他人加的锁。<br>为了更严谨，用lua脚本代替。lua脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[1]) == ARGV[1] <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[1])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">return</span> 0</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h3 id="方案六：Redisson框架"><a href="#方案六：Redisson框架" class="headerlink" title="方案六：Redisson框架"></a>方案六：Redisson框架</h3><p><code>Redisson</code>框架下，只要线程加锁成功，就会启动一个<code>watch dog</code>看门狗（一个后台线程），每隔10秒检查一下，若线程1还持有锁，就会不断延长锁key的生存时间。因此，<code>Redisson</code><strong>解决了<em>锁过期释放，业务没执行完</em>问题</strong>。Redisson底层原理如图所示：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620122023110.png" alt="image-20250620122023110"></p><h3 id="方案七：多机实现的分布式锁Redlock-Redisson"><a href="#方案七：多机实现的分布式锁Redlock-Redisson" class="headerlink" title="方案七：多机实现的分布式锁Redlock+Redisson"></a>方案七：多机实现的分布式锁Redlock+Redisson</h3><p>前六种方案都是基于单机版。但Redis一般都是集群部署的（如图）：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620122038873.png" alt="image-20250620122038873"></p><p>若线程一在Redis的master节点上拿到了锁，但加锁的key还没同步到slave节点。恰好这时master节点发生故障，一个slave节点就会升级为master节点。线程二就可以获取同个key的锁，但线程一也已经拿到锁了，锁的安全性就没了。</p><h3 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h3><p><strong>Redlock核心思想：</strong><br>搞多个<code>Redis master</code>部署，以保证它们不会同时宕掉。并且<strong>这些master节点是完全相互独立的，相互之间不存在数据同步</strong>。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。<br><strong>RedLock的简化实现步骤：</strong></p><ul><li>按顺序向<code>N</code>（N=5）个master节点请求加锁</li><li>根据设置的超时时间来判断，是不是要跳过该master节点。</li><li>如果**大于等于<code>N/2+1</code>**（5/2+1=3）个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功。</li><li>如果获取锁失败，解锁！</li></ul><p><strong>RedLock的实现步骤：</strong></p><ul><li><p>获取当前时间，以毫秒为单位。</p></li><li><p>按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，且超时时间要小于锁的失效时间。</p><ul><li>（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间，就假设超时时间是50ms）。若超时则跳过该master节点，尽快尝试下一个master节点。</li></ul></li><li><p>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如图，10s&gt; 30ms+40ms+50ms+40ms+50ms）</p><ul><li><p>如果<strong>获取到了锁</strong>，key的真正有效时间就变了，需要减去获取锁所使用的时间。</p></li><li><p>如果<strong>获取锁失败</strong>（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也<strong>需要解锁</strong>，以防止有些漏网之鱼）。</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/1750393665152.png" alt="1750393665152"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;分布式锁的英文是&lt;strong&gt;Distributed Lock&lt;/strong&gt;。该术语用于描述在多节点系统中控制资源访问的关键技术，通过协调各节点对共享资源的操作权限，确保同一时刻只有一个节点能持有锁。&lt;/p&gt;
&lt;p&gt;多线程环境中，线程之间常用互斥锁实现共享资源的独占访</summary>
      
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="Redis" scheme="https://southernfish.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeeper</title>
    <link href="https://southernfish.github.io/pages/distributed/zookeeper/"/>
    <id>https://southernfish.github.io/pages/distributed/zookeeper/</id>
    <published>2025-09-17T09:05:36.000Z</published>
    <updated>2025-09-20T11:18:48.140Z</updated>
    
    <content type="html"><![CDATA[<p>ZooKeeper是一个分布式的，<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E6%BA%90%E7%A0%81/7176422?fromModule=lemma_inlink">开放源码</a>的<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/9854429?fromModule=lemma_inlink">分布式应用程序</a>协调服务，是<a href="https://baike.baidu.com/item/Google/86964?fromModule=lemma_inlink">Google</a>的Chubby一个开源的实现，是<a href="https://baike.baidu.com/item/Hadoop/3526507?fromModule=lemma_inlink">Hadoop</a>和<a href="https://baike.baidu.com/item/Hbase/7670213?fromModule=lemma_inlink">Hbase</a>的重要组件。它是一个为<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8/1372598?fromModule=lemma_inlink">分布式应用</a>提供一致性服务的软件，提供的功能包括：配置维护、<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1/3352191?fromModule=lemma_inlink">域名服务</a>、分布式同步、组服务等。<br>Kafka 和 ZooKeeper 在分布式系统中扮演着不同的角色，并且它们之间有着紧密的合作关系。</p><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="zookeeper-是什么？"><a href="#zookeeper-是什么？" class="headerlink" title="zookeeper 是什么？"></a>zookeeper 是什么？</h2><p>‌<strong>ZooKeeper</strong>‌是一个开源的<strong>分布式协调服务</strong>，由<code>Apache</code>开发。它主要用于<strong>解决分布式系统中的一致性问题</strong>，如配置管理、节点选举和分布式锁等‌。<code>ZooKeeper</code>的<strong>主要功能</strong>包括：</p><ul><li>‌<strong>配置管理</strong>‌：集中管理分布式系统中的配置信息。</li><li>‌<strong>命名服务</strong>‌：提供唯一的命名服务，帮助分布式系统中的服务发现，客户端能根据指定名字获取资源或服务的地址，提供者等信息。</li><li>‌<strong>分布式锁</strong>‌：实现分布式环境中的锁机制。<code>zookeeper</code> 提供两种锁：<strong>独占锁、共享锁</strong>。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可有多个线程同时读同一个资源，若要使用写锁也只能有一个线程使用。</li><li>‌<strong>集群管理</strong>‌：管理集群中的节点，<strong>确保数据的一致性和系统的可靠性</strong>。监控节点存活状态、运行请求等。</li><li><strong>主节点选举：</strong>主节点挂掉了之后可以从备用的节点开始<strong>新一轮选主</strong>，使用 zookeeper 可以协助完成这个过程。</li></ul><h2 id="zookeeper-有几种部署模式？-三种"><a href="#zookeeper-有几种部署模式？-三种" class="headerlink" title="zookeeper 有几种部署模式？(三种)"></a>zookeeper 有几种部署模式？(三种)</h2><p><strong>单机部署：</strong>一台集群上运行；<br><strong>集群部署：</strong>多台集群运行；<br><strong>伪集群部署：</strong>一台集群启动多个 zookeeper 实例运行。</p><h2 id="zookeeper-怎么保证主从节点的状态同步？"><a href="#zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="zookeeper 怎么保证主从节点的状态同步？"></a>zookeeper 怎么保证主从节点的状态同步？</h2><p><code>zookeeper</code> 的核心是<strong>原子广播</strong>，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。<code>zab 协议</code>有两种模式，分别是<strong>恢复模式（选主）和广播模式（同步）</strong>。<em>当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了</em>。状态同步保证了 <code>leader</code> 和 <code>server</code> 具有相同的系统状态。</p><h2 id="集群中为什么要有主节点？"><a href="#集群中为什么要有主节点？" class="headerlink" title="集群中为什么要有主节点？"></a>集群中为什么要有主节点？</h2><p>在分布式环境中，<strong>有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果</strong>，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p><h2 id="集群中有-3-台服务器，一个节点宕机了，zookeeper-还可以用吗？"><a href="#集群中有-3-台服务器，一个节点宕机了，zookeeper-还可以用吗？" class="headerlink" title="集群中有 3 台服务器，一个节点宕机了，zookeeper 还可以用吗？"></a>集群中有 3 台服务器，一个节点宕机了，zookeeper 还可以用吗？</h2><p>可以继续使用，<strong>单数服务器只要没超过一半的服务器宕机就可以继续使用</strong>。</p><h2 id="zookeeper-的通知机制？"><a href="#zookeeper-的通知机制？" class="headerlink" title="zookeeper 的通知机制？"></a>zookeeper 的通知机制？</h2><p><strong>客户端会对某个 <code>znode</code> 建立一个 <code>watcher</code> 事件</strong>，当该 <code>znode</code> 发生变化时，这些客户端会<strong>收到 zookeeper 的通知</strong>，然后客户端可以<strong>根据 znode 变化来做出业务上的改变</strong>。</p><h2 id="Kafka与ZooKeeper的关系"><a href="#Kafka与ZooKeeper的关系" class="headerlink" title="Kafka与ZooKeeper的关系"></a>Kafka与ZooKeeper的关系</h2><p><code>Kafka</code>依赖<code> ZooKeeper</code>来管理集群元数据、控制器选举和消费者组协调等任务。ZooKeeper 为 Kafka 提供了选主（<code>leader election</code>）、集群成员管理等核心功能，<strong>确保Kafka能够在多个节点之间进行有效的通信和管理‌</strong>。随着 Kafka 的发展，其对 ZooKeeper的依赖也带来了一些问题：</p><ul><li>‌<strong>复杂性增加</strong>‌：ZooKeeper 是一个独立的外部组件，增加了运维的复杂度。</li><li>‌<strong>性能瓶颈</strong>‌：在高负载情况下，ZooKeeper 可能成为系统的瓶颈，限制Kafka的扩展能力。</li><li>‌<strong>一致性问题</strong>‌：Kafka内部的一致性模型与 ZooKeeper 的一致性模型有所不同，可能导致状态不一致，影响系统的稳定性和消息传递的可靠性‌。</li></ul>]]></content>
    
    
    <summary type="html">ZooKeeper是一个分布式应用程序协调服务，是Hadoop和Hbase的重要组件。</summary>
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="Zookeeeper" scheme="https://southernfish.github.io/tags/Zookeeeper/"/>
    
  </entry>
  
  <entry>
    <title>其他简单算法</title>
    <link href="https://southernfish.github.io/pages/algorithm/simple_algorithm/"/>
    <id>https://southernfish.github.io/pages/algorithm/simple_algorithm/</id>
    <published>2025-08-07T07:30:36.000Z</published>
    <updated>2025-09-20T11:18:48.136Z</updated>
    
    <content type="html"><![CDATA[<p>与树相关的一些问题。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/2402_83476639/article/details/149788621">优先级队列（堆）</a></p><p><a href="https://blog.csdn.net/2302_79577794/article/details/139581587">【算法笔记】二分查找 &amp;&amp; 二分答案</a></p><p><a href="https://blog.csdn.net/cj13106811623/article/details/136358329">数据结构 -栈和队列(Java实现)</a></p><p><a href="https://blog.csdn.net/m0_64450656/article/details/149851595">第3章栈、队列、数组和矩阵</a></p><p><a href="https://blog.csdn.net/2301_76779875/article/details/146417751">双指针（java）</a></p><p><a href="https://blog.csdn.net/mybook201314/article/details/117589533">算法题 - 求数组的子集合</a></p></blockquote><h1 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h1><p>队列是一种先进先出(FIFO)的数据结构，但有些情况下，操作的数据可能带有优先级，一般出队列时，可能需要优先级高的元素先出队列，该场景下，使用队列显然不合适，比如：在手机上玩游戏的时候，如果有来电，那么系统应该优先处理打进来的电话；初中那会班主任排座位时可能会让成绩好的同学先挑座位。</p><p>这种情况下，数据结构应该提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新的对象。这种数据结构就是优先级队列(Priority Queue)。</p><h2 id="PriorityQueue常用接口"><a href="#PriorityQueue常用接口" class="headerlink" title="PriorityQueue常用接口"></a>PriorityQueue常用接口</h2><h3 id="PriorityQueue的特性"><a href="#PriorityQueue的特性" class="headerlink" title="PriorityQueue的特性"></a>PriorityQueue的特性</h3><p>Java集合框架中提供了PriorityQueue和PriorityBlockingQueue两种类型的优先级队列，PriorityQueue是线程不安全的，PriorityBlockingQueue是线程安全的，此处主要介绍PriorityQueue。</p><p>关于PriorityQueue的使用要注意：</p><ol><li><p>使用时必须导入 PriorityQueue 所在的包，即：<code>import java.util.PriorityQueue;</code></p></li><li><p>PriorityQueue 中放置的元素必须要能够比较大小，不能插入无法比较大小的对象，否则会抛出 ClassCastException 异常</p></li><li><p>不能插入 null 对象，否则会抛出 NullPointerException</p></li><li><p>没有容量限制，可以插入任意多个元素，其内部可以自动扩容。优先级队列的<strong>扩容说明</strong>：</p><ol><li>如果容量小于64时，是按照oldCapacity的2倍方式扩容的</li><li>如果容量大于等于64，是按照oldCapacity的1.5倍方式扩容的</li><li>如果容量超过MAX_ARRAY_SIZE，按照MAX_ARRAY_SIZE来进行扩容</li></ol></li><li><p>插入和删除元素的时间复杂度为O（logN）</p></li><li><p>PriorityQueue 底层使用了堆数据结构</p></li><li><p>PriorityQueue 默认情况下是小堆，即每次获取到的元素都是最小的元素</p></li></ol><h3 id="优先级队列的构造"><a href="#优先级队列的构造" class="headerlink" title="优先级队列的构造"></a>优先级队列的构造</h3><table><thead><tr><th>构造器</th><th>功能介绍+H4:021H4:H4:013</th></tr></thead><tbody><tr><td>PriorityQueue()</td><td>创建一个空的优先级队列，默认容量是11</td></tr><tr><td>PriorityOueue(int initialCapacity)</td><td>创建一个初始容量为initialCapacity的优先级队列<br>注意：<code>initialCapacity</code>不能小于1，否则会抛lllegalArgumentException异常</td></tr><tr><td>PriorityQueue(Collection&lt;? extends E&gt; c)</td><td>用一个集合来创建优先级队列</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">TestPriorityQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的优先级队列，底层默认容量是11</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; q1 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 创建一个空的优先级队列，底层的容量为initialCapacity</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; q2 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用ArrayList对象来构造一个优先级队列的对象</span></span><br><span class="line">    <span class="comment">// q3中已经包含了三个元素</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">4</span>);list.add(<span class="number">3</span>);list.add(<span class="number">2</span>);list.add(<span class="number">1</span>);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; q3 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(list);</span><br><span class="line">    System.out.println(q3.size());</span><br><span class="line">    System.out.println(q3.peek());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：默认情况下，PriorityQueue队列是小堆，如果需要大堆需要用户提供比较器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户自己定义的比较器：直接实现Comparator接口，然后重写该接口中的compare方法即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntCmp</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2-o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPriorityQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">IntCmp</span>());</span><br><span class="line">        <span class="comment">// 或者Lambda 写法</span></span><br><span class="line">        <span class="comment">// PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a,b) -&gt; b - a);</span></span><br><span class="line">        p.offer(<span class="number">4</span>); p.offer(<span class="number">3</span>); p.offer(<span class="number">2</span>);  p.offer(<span class="number">1</span>); p.offer(<span class="number">5</span>);</span><br><span class="line">        System.out.println(p.peek());</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="插入-删除-获取优先级最高的元素"><a href="#插入-删除-获取优先级最高的元素" class="headerlink" title="插入/删除/获取优先级最高的元素"></a>插入/删除/获取优先级最高的元素</h3><table><thead><tr><th>函数名</th><th>功能介绍</th></tr></thead><tbody><tr><td>boolean offer(E e)</td><td>插入元素e，插入成功返回true，如果e对象为空，抛出NulIPointerException异常，时间复杂度<br>注意：空间不够时候会进行扩容</td></tr><tr><td>E peek()</td><td>获取优先级最高的元素，如果优先级队列为空，返回null</td></tr><tr><td>E poll())</td><td>移除优先级最高的元素并返回，如果优先级队列为空，返回null</td></tr><tr><td>int size()</td><td>获取有效元素的个数</td></tr><tr><td>void clear()</td><td>清空</td></tr><tr><td>boolean isEmpty()</td><td>检测优先级队列是否为空，空返回true</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">TestPriorityQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 一般在创建优先级队列对象时，如果知道元素个数，建议就直接将底层容量给好</span></span><br><span class="line">    <span class="comment">// 否则在插入时需要不多的扩容</span></span><br><span class="line">    <span class="comment">// 扩容机制：开辟更大的空间，拷贝元素，这样效率会比较低</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(arr.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> e: arr) &#123;</span><br><span class="line">        q.offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(q.size());   <span class="comment">// 打印优先级队列中有效元素个数</span></span><br><span class="line">    System.out.println(q.peek());   <span class="comment">// 获取优先级最高的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从优先级队列中删除两个元素之后，再次获取优先级最高的元素</span></span><br><span class="line">    q.poll();</span><br><span class="line">    q.poll();</span><br><span class="line">    System.out.println(q.size());   <span class="comment">// 打印优先级队列中有效元素个数</span></span><br><span class="line">    System.out.println(q.peek());   <span class="comment">// 获取优先级最高的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将优先级队列中的有效元素删除掉，检测其是否为空</span></span><br><span class="line">    q.clear();</span><br><span class="line">    <span class="keyword">if</span>(q.isEmpty())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;优先级队列已经为空!!!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;优先级队列不为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h2><h3 id="PriorityQueue的实现"><a href="#PriorityQueue的实现" class="headerlink" title="PriorityQueue的实现"></a>PriorityQueue的实现</h3><p>用堆作为底层结构封装优先级队列</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序即利用堆的思想来进行排序，总共分为两个步骤：</p><ol><li><p>建堆：升序，建大堆；降序，建小堆    </p></li><li><p>利用堆删除思想来进行排序</p></li></ol><p>建堆和堆删除中都用到了向下调整，因此掌握了向下调整，就可以完成堆排序。</p><h3 id="Top-k问题"><a href="#Top-k问题" class="headerlink" title="Top-k问题"></a>Top-k问题</h3><p>TOP-K问题：即求数据集合中前K个最大的元素或者最小的元素，一般情况下数据量都比较大。</p><p>比如：专业前10名、世界500强、富豪榜、游戏中前100的活跃玩家等。</p><p>对于Top-K问题，能想到的最简单直接的方式就是排序，但是：如果数据量非常大，排序就不太可取了(可能数据都 不能一下子全部加载到内存中)。最佳的方式就是用堆来解决，基本思路如下：</p><ol><li><p>用数据集合中前K个元素来建堆 前k个最大的元素，则建小堆前k个最小的元素，则建大堆</p></li><li><p>用剩余的N-K个元素依次与堆顶元素来比较，不满足则替换堆顶元素</p></li></ol><p>将剩余N-K个元素依次与堆顶元素比完之后，堆中剩余的K个元素就是所求的前K个最小或者最大的元素。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>例题参见 <a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0">数组中的第K个最大元素</a></p><hr><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找，也称为折半查找（Binary Search），是一种在有序数组中高效查找特定元素的搜索算法，时间复杂度为O(log⁡n)<em>O</em>(log<em>n</em>)，通过不断缩小搜索范围实现快速定位。它的基本思想是将目标值与数组中间的元素进行比较，如果目标值小于中间元素，则在数组的左半部分继续查找，否则在右半部分查找，不断缩小搜索范围，直到找到目标值或确定目标值不存在为止。</p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>二分查找的核心思想是<strong>分治策略</strong>，具体步骤如下</p><ol><li><strong>有序数组前提</strong>：仅适用于已排序的数组，利用顺序性快速排除无效区间。</li><li><strong>中间元素比较</strong>：每次取中间位置元素与目标值比较，若相等则返回位置:</li><li>缩小搜索范围<ol><li>若目标值小于中间元素，则在左半区间继续查找;</li><li>若目标值大于中间元素，则在右半区间继续查找。</li></ol></li><li><strong>终止条件</strong>：当搜索区间缩小至空(即左边界超过右边界)时，判定元素不存在。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;  <span class="comment">// 防止整数溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码关键点：</p><ul><li><strong>循环条件</strong>：<code>left &lt;= right</code>确保单个元素时仍能执行判断。</li><li><strong>中间值计算</strong>：使用<code>mid = left + (right - left) / 2</code>避免整数溢出风险。</li></ul><p><strong>时间复杂度与空间复杂度</strong></p><ul><li><strong>时间复杂度</strong>：O(log⁡n)<em>O</em>(log<em>n</em>)，每次迭代将搜索范围减半。</li><li><strong>空间复杂度</strong>：迭代实现为O(1)<em>O</em>(1)，递归实现因调用栈深度为O(log⁡n)<em>O</em>(log<em>n</em>)。</li></ul><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><p>例题参见 <a href="#%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">寻找两个正序数组的中位数</a></p><hr><h1 id="栈-amp-矩阵-amp-队列"><a href="#栈-amp-矩阵-amp-队列" class="headerlink" title="栈&amp;矩阵&amp;队列"></a>栈&amp;矩阵&amp;队列</h1><h2 id="矩阵（Matrix）"><a href="#矩阵（Matrix）" class="headerlink" title="矩阵（Matrix）"></a>矩阵（Matrix）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>矩阵是一个多维数组，其元素以行和列的形式排列。在计算机内存中，矩阵通常被实现为向量中的向量。一个3x3的矩阵有9个位置，每个位置可以通过一对索引（行号和列号）来访问。例如，一个元素 <code>M </code>可能位于 <code>[0][0] </code>的位置，而另一个元素 <code>O </code>可能位于 <code>[2][2] </code>的位置。矩阵可以是任意维度的，比如四维矩阵、五维矩阵等，但它们通常用于处理复杂的科学计算和图形渲染。</p><p>矩阵是数据科学、图像处理、机器学习、计算机图形学等领域最基础、最常用的数据结构之一。在现实世界中，数据往往以二维或多维数组的形式存在。</p><h3 id="矩阵转置（Transpose）"><a href="#矩阵转置（Transpose）" class="headerlink" title="矩阵转置（Transpose）"></a>矩阵转置（Transpose）</h3><p>矩阵转置（Transpose）是指将矩阵的行与列互换，通常记作 $A^T$。例如，$A$ 为 $m×n$ 矩阵，则 $A^T$ 为 $n×m$ 矩阵，满足 $A^T[i][j] = A[j][i]$。重要性如下：</p><ul><li><strong>数据变换</strong>：在高效存储或算法实现时，经常需要将行主序（row-major）与列主序（column-major）格式互换；</li><li><strong>线性代数</strong>：在求解矩阵方程、特征值分解等算法中，转置操作会频繁出现；</li><li><strong>并行加速</strong>：对大规模矩阵做转置时，合理的分块策略和优化手段能大幅提升缓存命中率和并行效率。</li></ul><h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>栈是一种特殊的列表，其添加和删除元素的操作仅限于一端，即栈顶。栈的基本操作包括入栈（push）和出栈（pop），遵循后进先出（LIFO）或先进后出（FILO）的原则。栈在程序中用于存储函数调用的上下文、保存局部变量、实现递归函数等。</p><p><strong>压栈</strong>：栈的插入操作叫做进栈/压栈/入栈，<strong>入数据在栈顶。</strong></p><p><strong>出栈</strong>：栈的删除操作叫做出栈。<strong>出数据在栈顶。</strong></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>new Stack()</td><td>创建一个新的空白的栈</td></tr><tr><td>push(a)</td><td>将元素a插入栈中，实现压栈</td></tr><tr><td>pop()</td><td>将栈顶元素进行出栈</td></tr><tr><td>peek()</td><td>获取栈顶元素</td></tr><tr><td>int size()</td><td>获取栈中元素的个数</td></tr><tr><td>boolean isEmpty()</td><td>判断栈中元素是否为空</td></tr></tbody></table><h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p><strong>队列：</strong>只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有<strong>先进先出</strong>，</p><p><strong>入队列：</strong>进行插入操作的一端称为<strong>队尾</strong></p><p><strong>出队列：</strong>进行删除操作的一端称为<strong>队头</strong></p><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p>在Java中，<strong>Queue是个接口，底层是通过链表实现的。</strong></p><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>boolean offer(E e)</td><td>入队列</td></tr><tr><td>E poll()</td><td>出队列</td></tr><tr><td>peek()</td><td>获取队头元素</td></tr><tr><td>int size()</td><td>获取队列中有效元素个数</td></tr><tr><td>boolean isEmpty()</td><td>检测队列是否为空</td></tr></tbody></table><p><strong>注意</strong>：Queue是个接口，在实例化时必须实例化<code>LinkedList</code>的对象，因为<code>LinkedList</code>实现了Queue接口。</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>解决假溢出的方法就是后面满了，就再从头开始，也就是头尾相接的循环。<strong>我们把队列的这种头尾相接的顺序存储结构称为循环队列。</strong>当队首指针**<code>Q-&gt;front = maxsize-1</code>**后，再前进一个位置就自动到0，这可以利用除法取余运算（%）来实现。</p><ul><li>初始时：Q-&gt;front = Q-&gt;rear=0</li><li>队首指针进1：Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE</li><li>队尾指针进1：Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE</li><li>队列长度：(Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE</li></ul><p>判断队列为空的条件是：<strong>Q-&gt;front == Q-&gt;rear</strong></p><p>为了区分队列还是队满的情况，有三种处理方式： (<strong>重点是第一种</strong>)</p><ol><li>牺牲一个单元来判断队空还是队满,入队时少用一个单元. 约定以“<strong>队头指针在队尾指针的下一位置作为队满的标志</strong>”<ul><li><strong>队满条件</strong>： (Q-&gt;rear + 1)%Maxsize == Q-&gt;front</li><li><strong>队空条件</strong>： Q-&gt;front == Q-&gt;rear</li><li><strong>队列中元素的个数</strong>： (Q-&gt;rear - Q -&gt;front + Maxsize)% Maxsize</li></ul></li><li>使用计数的方法来判断队列是否已满</li><li>增设一个boolean flag标记,以区分队满还是队空,flag等于false,若因删除导致 <code>Q-&gt;front == Q-&gt;rear</code> ，则为队空；flag 等于 true 时，若因插入导致 <code>Q -&gt;front == Q-&gt;rear</code> ，则为队满 </li></ol><h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><p>例题参见 <a href="#%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2">最大矩形</a>、<a href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2">柱状图中最大的矩形</a></p><hr><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>双指针算法通过维护两个指针（索引或节点引用）在数据结构中协同移动，以优化时间复杂度。其核心在于减少不必要的遍历次数，将原本需要嵌套循环的问题转化为单次遍历，时间复杂度通常从 O(n²) 降低至 O(n) 或 O(n log&gt; n)，适用于数组、链表、字符串等线性结构 。</p><h2 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h2><blockquote><p><strong>双指针协同</strong>：两指针根据规则同步或异步移动，覆盖问题解空间。<br><strong>单调性依赖</strong>：多数问题需数据结构具备有序性或其他规律，例如排序后的数组或特定约束的子串。<br><strong>高效性</strong>：通过剪枝或跳过无效区间，避免重复计算。</p></blockquote><h2 id="分类与应用场景"><a href="#分类与应用场景" class="headerlink" title="分类与应用场景"></a>分类与应用场景</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p><strong>原理</strong>：两个指针以不同速度移动，常用于 链表操作 和 循环检测。<br><strong>应用场景</strong>：</p><ul><li>链表环检测：快指针每次移动两步，慢指针移动一步，若相遇则存在环 。</li><li>链表中点查找：快指针到末尾时，慢指针指向中点 。</li><li>删除重复元素：慢指针标记唯一元素位置，快指针遍历数组（如有序数组去重）</li></ul><h3 id="对撞指针（左右指针）"><a href="#对撞指针（左右指针）" class="headerlink" title="对撞指针（左右指针）"></a>对撞指针（左右指针）</h3><p><strong>原理</strong>：两指针从两端向中间移动，适用于 有序数组查找 或 对称性问题。<br><strong>应用场景</strong>：</p><ul><li>两数之和：在排序数组中找和为目标值的两个数（指针调整方向基于当前和与目标值的比较） 。</li><li>盛水容器：计算最大容积时，移动高度较小的指针以寻求更大可能 。</li><li>反转数组/字符串：交换左右指针元素直至相遇</li></ul><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><strong>原理</strong>：维护动态窗口，通过调整窗口边界寻找最优解，常用于 子串/子数组问题。<br><strong>应用场景</strong>：</p><ul><li>最小覆盖子串：窗口覆盖目标字符集时收缩左边界以优化长度 。</li><li>最长无重复子串：右指针扩展窗口，左指针在重复时跳跃 。</li></ul><h2 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h2><p>例题参见 <a href="#%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0">好子数组的最大分数</a></p><hr><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>例题参见 <a href="#%E8%B6%85%E7%BA%A7%E5%9B%9E%E6%96%87%E6%95%B0">超级回文数</a></p><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><p>例题参见 <a href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5">螺旋矩阵</a></p><h1 id="子集合"><a href="#子集合" class="headerlink" title="子集合"></a>子集合</h1><p>例题参见 <a href="#%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E9%9B%86%E5%90%88">求数组的子集合</a></p><hr><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><p>题目链接：<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">LeetCode_215. 数组中的第K个最大元素</a></p><blockquote><p><strong>问题描述：</strong><br>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。<br>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。<br>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6], k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        minHeap.offer(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; minHeap.peek()) &#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">            minHeap.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h2><p>题目链接：<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">LeetCode_4. 寻找两个正序数组的中位数</a></p><blockquote><p>**问题描述：<br>**给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。<br>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6</code></li></ul><p><strong>思路</strong>：<br>两个有序数组的长度分别为m和n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。</p><p>为简化代码，不分情况讨论，使用一个小技巧：分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。假如 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。</p><p>定义一个函数用于在两个有序数组中找到第K个元素，下面重点来看如何实现<strong>找到第 <code>K</code> 个元素</strong>。</p><ol><li>首先，为了避免产生新的数组从而增加时间复杂度，使用两个变量 i 和 j 分别来标记数组 nums1 和 nums2 的起始位置。</li><li>然后，处理边界问题，比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。还有如果 K=1 ，那么只要比较 nums1 和 nums2 的起始位置 i 和 j 上的数字就可以了。</li><li>难点在于一般的情况怎么处理？因为需要在两个有序数组中找到第K个元素，为了加快搜索的速度，要使用二分法，对 K 二分，意思是要分别在 nums1 和 nums2 中查找第 K/2 个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第 K/2 个数字，所以需要先检查数组中到底存不存在第 K/2 个数字，如果存在就取出来，否则就赋值上一个整型最大值。如果某个数组没有第 K/2 个数字，那么淘汰另一个数字的前K/2个数字。有没有可能两个数组都不存在第 K/2 个数字呢，这道题里是不可能的，因为K是给的m+n的中间值，所以必定至少会有一个数组是存在第K/2个数字的。</li><li>最后就是二分法的核心，比较这两个数组的第 K/2 小的数字 midVal1 和 midVal2 的大小，如果第一个数组的第 K/2 个数字小的话，那么说明要找的数字肯定不在 nums1 中的前 K/2 个数字，所以可以将其淘汰，将 nums1 的起始位置向后移动 K/2 个，并且此时的K也自减去K/2，调用递归。反之，淘汰nums2中的前K/2个数字，并将 nums2 的起始位置向后移动 K/2 个，并且此时的 K 也自减去K/2，调用递归。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, left) + findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, right)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i: nums1的起始位置 j: nums2的起始位置,k 表示 第 k 个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> i, <span class="type">int</span>[] nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( i &gt;= nums1.length) &#123; <span class="comment">// nums1为空数组</span></span><br><span class="line">            <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( j &gt;= nums2.length) &#123; <span class="comment">// nums2为空数组</span></span><br><span class="line">            <span class="keyword">return</span> nums1[i + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(nums1[i], nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal1</span> <span class="operator">=</span> (i + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums1.length) ? nums1[i + k / <span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal2</span> <span class="operator">=</span> (j + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums2.length) ? nums2[j + k / <span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(midVal1 &lt; midVal2) &#123; <span class="comment">// 淘汰 nums1的前 k/2个</span></span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, i + k / <span class="number">2</span>, nums2, j , k - k / <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 淘汰 nums2的前 k/2个</span></span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, i, nums2, j + k / <span class="number">2</span> , k - k / <span class="number">2</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a>最大矩形</h2><p>题目链接：<a href="https://leetcode.cn/problems/maximal-rectangle/">85. 最大矩形</a></p><blockquote><p><strong>问题描述：</strong>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p><strong>示例 1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：6</span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[&quot;0&quot;]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>rows == matrix.length</code></li><li><code>cols == matrix[0].length</code></li><li><code>1 &lt;= row, cols &lt;= 200</code></li><li><code>matrix[i][j]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length, area = <span class="number">0</span>, min;</span><br><span class="line">    <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">1</span> &amp;&amp; matrix[i - <span class="number">1</span>][j - <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = dp[i][j - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">1</span> &amp;&amp; matrix[i - <span class="number">2</span>][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                min = dp[i][j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= dp[i][j][<span class="number">1</span>]; k++) &#123;</span><br><span class="line">                    min = Math.min(min, dp[i - k + <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">                    area = Math.max(area, min * k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2><p>题目链接：<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p><blockquote><p><strong>问题描述：</strong>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例 1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： heights = [2,4]</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;=10^5</code></li><li><code>0 &lt;= heights[i] &lt;= 10^4</code></li></ul><p><strong>思路</strong>：使用单调增栈可以 O(1) 的获取柱体 i 左边第一个比它小的柱体，因为对于栈中的柱体来说，栈中的下一个柱体就是其「左边第一个小于自身的柱体」。遍历每个柱体，若当前的柱体 i 高度大于等于栈顶柱体的高度，就直接将当前柱体入栈，否则若当前柱体 i 高度小于栈顶柱体的高度，说明 i 是栈顶柱体的「右边第一个小于栈顶柱体的柱体」，以栈顶柱体为高的矩形的左右宽度边界就确定了，那么就可以将栈顶柱体出栈来计算以其为高的矩形的面积了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="comment">// 在柱体数组的头和尾加了两个高度为 0 的柱体</span></span><br><span class="line">    <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">    System.arraycopy(heights, <span class="number">0</span>, tmp, <span class="number">1</span>, heights.length); </span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; tmp[i] &lt; tmp[stack.peek()]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> tmp[stack.pop()]; <span class="comment">// 栈顶柱体高度，注意是出栈</span></span><br><span class="line">            area = Math.max(area, (i - stack.peek() - <span class="number">1</span>) * h); <span class="comment">// 栈顶元素计算左右宽度边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="好子数组的最大分数"><a href="#好子数组的最大分数" class="headerlink" title="好子数组的最大分数"></a>好子数组的最大分数</h2><p>题目链接：<a href="https://leetcode.cn/problems/maximum-score-of-a-good-subarray/">LeetCode_1793. 好子数组的最大分数</a></p><blockquote><p><strong>问题描述：</strong><br>给你一个整数数组 <code>nums</code> <strong>（下标从 0 开始）</strong>和一个整数 <code>k</code> 。一个子数组 <code>(i, j)</code> 的 <strong>分数</strong> 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code> 。一个 <strong>好</strong> 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。请你返回 <strong>好</strong> 子数组的最大可能 <strong>分数</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,4,3,7,4,5], k = 3</span><br><span class="line">输出：15</span><br><span class="line">解释：最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,5,4,5,4,1,1,1], k = 0</span><br><span class="line">输出：20</span><br><span class="line">解释：最优子数组的左右端点下标是 (0, 4) ，分数为 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 10^4</code></li><li><code>0 &lt;= k &lt; nums.length</code></li></ul><p><strong>思路</strong>：判断左右指针对应的数组值哪个比较大，移动到大的一端即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumScore</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, ret = nums[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k, j = k, mn = nums[k]; i &gt; <span class="number">0</span> || j &lt; n - <span class="number">1</span>; ) &#123;</span><br><span class="line">        <span class="comment">// mn 表示 Math.min(nums[i], nums[i+1], ..., nums[j]) </span></span><br><span class="line">        <span class="keyword">if</span> (j == n - <span class="number">1</span> || i &gt; <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            mn = Math.min(mn, nums[--i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mn = Math.min(mn, nums[++j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = Math.max(ret, mn * (j - i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="超级回文数"><a href="#超级回文数" class="headerlink" title="超级回文数"></a>超级回文数</h2><p>题目链接：<a href="https://leetcode.cn/problems/super-palindromes/">LeetCode_906. 超级回文数</a></p><blockquote><p><strong>问题描述：</strong><br>如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为 <strong>超级回文数</strong> 。现在，给你两个以字符串形式表示的正整数 left 和 right ，统计并返回区间 <code>[left, right]</code> 中的 <strong>超级回文数</strong> 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：left = &quot;4&quot;, right = &quot;1000&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：4、9、121 和 484 都是超级回文数。</span><br><span class="line">注意 676 不是超级回文数：26 * 26 = 676 ，但是 26 不是回文数。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：left = &quot;1&quot;, right = &quot;2&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= left.length, right.length &lt;= 18</code></li><li><code>left</code> 和 <code>right</code> 仅由数字（0 - 9）组成。</li><li><code>left</code> 和 <code>right</code> 不含前导零。</li><li><code>left</code> 和 <code>right</code> 表示的整数在区间 <code>[1, 10^18 - 1]</code> 内。</li><li><code>left</code> 小于等于 <code>right</code> 。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">superpalindromesInRange</span><span class="params">(String left, String right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;1&quot;</span>+<span class="string">&quot;0&quot;</span>.repeat(</span><br><span class="line">            String.valueOf((<span class="type">int</span>)Math.sqrt(Double.parseDouble(left))).length() - <span class="number">1</span>),<span class="number">3</span>); ; a++)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">check</span> <span class="operator">=</span> Integer.toString(a,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(check).reverse().toString().equals(check)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Integer.parseInt(check) &lt; (<span class="type">int</span>)Math.sqrt(Double.parseDouble(left))) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Integer.parseInt(check) &gt; (<span class="type">int</span>)Math.sqrt(Double.parseDouble(right))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(check.chars().map(b -&gt; ((<span class="type">char</span>)b - <span class="string">&#x27;0&#x27;</span>) * ((<span class="type">char</span>)b - <span class="string">&#x27;0&#x27;</span>)).sum() &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left.length() == <span class="number">1</span> &amp;&amp; Integer.parseInt(left) &lt;= <span class="number">9</span> </span><br><span class="line">            &amp;&amp; (right.length() &gt; <span class="number">1</span> || Integer.parseInt(right) &gt;= <span class="number">9</span>)) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><p>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></p><blockquote><p><strong>问题描述：</strong>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><p><strong>思路</strong>：模拟矩形的顺时针旋转，所以核心依然是依然是坚持循环不变量，按照左闭右开的原则。模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>设置四个边界，注意状态改变后要增加条件限制，比如后面两个for循环，这个解题是比较好记的，注意每次都是左开右闭就可以了，不要随意更改，其实就是二分查找的区间不变量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> matrix.length-<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123; <span class="comment">// 上行从左到右</span></span><br><span class="line">            result.add(matrix[top][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= bottom; i++) &#123; <span class="comment">// 右列从上到下</span></span><br><span class="line">            result.add(matrix[i][right]);</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left &amp;&amp; top &lt;= bottom; i--) &#123; <span class="comment">// 下行从右到左</span></span><br><span class="line">            result.add(matrix[bottom][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        bottom--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt;= top &amp;&amp; left &lt;= right; i--) &#123; <span class="comment">// 左列从下到上</span></span><br><span class="line">            result.add(matrix[i][left]);</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求数组的子集合"><a href="#求数组的子集合" class="headerlink" title="求数组的子集合"></a>求数组的子集合</h2><blockquote><p><strong>题目一</strong>：给出一个数组 list = [1,2,3,4,5,6]，求此数组的所有子集合<br><strong>输出</strong>：[1]，[1,2]，[1,2,3]…</p><p><strong>题目二</strong>：给出一个数组 list = [1,2,3,4,5,6]，求此数组的所有子集合中和为6的子集<br><strong>输出</strong>：[6，[2,4]，[1,5]，[1,2,3]</p><p><strong>解题思路：</strong><br>方式一：递归<br>方式二：全排列方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归方式 求数组的子集合，子数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] list = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">// 测试数组</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 保存结果集</span></span><br><span class="line">    List&lt;Integer&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    subList(list, <span class="number">0</span>, resultList, subList); <span class="comment">// 递归调用</span></span><br><span class="line">    <span class="comment">// 求数组的子集</span></span><br><span class="line">    System.out.println(<span class="string">&quot;数组的所有子集合：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; sub : resultList) &#123;</span><br><span class="line">        System.out.println(Arrays.toString(sub.toArray()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求各个子集中 和 为6的集合</span></span><br><span class="line">    System.out.println(<span class="string">&quot;输出和为：6&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; sub : resultList) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sub.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">6</span>) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(sub.toArray()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">subList</span><span class="params">(<span class="type">int</span>[] list , <span class="type">int</span> index, </span></span><br><span class="line"><span class="params">        List&lt;List&lt;Integer&gt;&gt; resultList, List&lt;Integer&gt; subList)</span> &#123;</span><br><span class="line">    resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(subList));</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.length ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; size; ) &#123;</span><br><span class="line">        subList.add(list[i]);</span><br><span class="line">        subList(list, ++i, resultList, subList);</span><br><span class="line">        subList.remove(subList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求数组的子集合，子数组 方式二：全排列方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] list = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">// 测试数组</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 保存结果集 </span></span><br><span class="line">    <span class="comment">// 全排列 循环</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.length ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(list[i])));  <span class="comment">// 保存单个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">            List&lt;Integer&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            subList.add(list[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j; k &lt; size; k++) &#123;</span><br><span class="line">                subList.add(list[k]);</span><br><span class="line">                resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(subList)); <span class="comment">// 重新保存一个数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;数组的所有子集合：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; sub : resultList) &#123;</span><br><span class="line">        System.out.println(Arrays.toString(sub.toArray()));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;输出和为：6&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; sub : resultList) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sub.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">6</span>) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(sub.toArray()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;与树相关的一些问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/2402_83476639/article/details/149788621&quot;&gt;优先级队列（堆）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="https://southernfish.github.io/pages/algorithm/backtrack-algorithm/"/>
    <id>https://southernfish.github.io/pages/algorithm/backtrack-algorithm/</id>
    <published>2025-08-06T10:30:36.000Z</published>
    <updated>2025-09-20T11:18:48.135Z</updated>
    
    <content type="html"><![CDATA[<p>回溯算法是一种通过系统性试探和回退策略搜索问题解的通用方法，适用于组合优化、约束满足等复杂问题，其核心特征是“能进则进，不进则退”的深度优先搜索机制。</p><blockquote><p>参考文章：</p><p><a href="https://cloud.tencent.com/developer/article/2477018">回溯算法详解</a></p><p><a href="https://c.biancheng.net/view/9lsh1qb.html">什么是回溯算法</a></p><p><a href="https://cloud.tencent.com/developer/article/2410719">图论基础及深度优先遍历（DFS）、广度优先遍历（BFS）</a></p></blockquote><h1 id="回溯算法详解"><a href="#回溯算法详解" class="headerlink" title="回溯算法详解"></a>回溯算法详解</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>回溯算法，又称为“试探法”。是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>基本思想：从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p><p><strong>八皇后问题</strong>就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。<strong>回溯算法说白了就是穷举法</strong>。不过回溯算法使用<strong>剪枝函数</strong>，<strong>剪去一些不可能到达 <code>最终状态（即答案状态）</code>的节点，从而减少状态空间树节点的生成</strong>。</p><p>回溯算法求解问题时，按深度优先搜索策略对解空间树进行搜索，在搜索至解空间树中的任一结点时，先判断该结点是否包含问题的解：</p><ul><li>若包含问题的解，则沿着该分支继续进行深度优先搜索遍历；</li><li>否则，跳过该结点的分支沿着该结点向上一个结点回溯。</li></ul><p>回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而<strong>回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束</strong>。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。</p><h2 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h2><p>深度优先遍历算法采用了回溯思想，从起始节点开始，沿着一条路径尽可能深入地访问节点，直到无法继续前进时为止，然后回溯到上一个未访问的节点，继续深入搜索，直到完成整个搜索过程。</p><p>因为遍历到的节点顺序符合「先进后出」的特点，所以深度优先搜索遍历可以通过「栈/递归」来实现。</p><p><strong>特点</strong>：一路到底，逐层回退。</p><p><strong>用途</strong>：解决找到所有解问题（找到起始–终点的所有路径，此时 DFS 空间占用少）。</p><p>例题参见 <a href="#%E7%AE%97%E6%B3%95%E9%A2%98%E4%BA%8C%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89">算法题二（二叉树）</a></p><h2 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h2><p>广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外扩张。以此类推，直到完成整个搜索过程。</p><p>因为遍历到的节点顺序符合「先进先出」的特点，所以广度优先遍历可以通过「队列」来实现。</p><p><strong>特点</strong>：全面扩散，逐层递进。</p><p><strong>用途</strong>：解决找到最优解的问题（找到的第一个起始–终点路径，即是最短路径）。</p><p>例题参见 <a href="#%E7%AE%97%E6%B3%95%E9%A2%98%E4%B8%89">算法题三</a></p><h2 id="回溯VS递归"><a href="#回溯VS递归" class="headerlink" title="回溯VS递归"></a>回溯VS递归</h2><p>在回溯法中可以看到有递归的身影，但两者有区别。  回溯法从问题本身出发，寻找可能实现的所有情况。和穷举法的思想相近，不同在于穷举法是将所有的情况都列举出来以后再一一筛选，而回溯法在列举过程如果发现当前情况根本不可能存在，就停止后续的所有工作，返回上一步进行新的尝试。</p><p><strong>递归</strong>是从问题的结果出发，例如求 n！，要想知道 n！的结果，就需要知道 n*(n-1)! 的结果，而要想知道 (n-1)! 结果，就需要提前知道 (n-1)*(n-2)!。这样不断地向自己提问，不断地调用自己的思想就是递归。 </p><p> 回溯和递归唯一的联系就是，<strong>回溯法可以用递归思想实现。</strong></p><h2 id="回溯算法的实现过程"><a href="#回溯算法的实现过程" class="headerlink" title="回溯算法的实现过程"></a>回溯算法的实现过程</h2><p>使用回溯法解决问题的过程，实际上是建立一棵“状态树”的过程。例如，在解决列举集合{1,2,3}所有子集的问题中，对于每个元素，都有两种状态，取还是舍，所以构建的状态树为：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807143329560.png" alt="image-20250807143329560"></p><p>回溯算法的求解过程实质上是先序遍历“状态树”的过程。树中每一个叶子结点，都有可能是问题的答案。图中的状态树是满二叉树，得到的叶子结点全部都是问题的解。  </p><p>在某些情况下，回溯算法解决问题的过程中创建的状态树并不都是满二叉树，因为在试探的过程中，有时会发现此种情况下，再往下进行没有意义，所以会放弃这条死路，回溯到上一步。在树中的体现，就是在树的最后一层不是满的，即不是满二叉树，需要自己判断哪些叶子结点代表的是正确的结果。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>用回溯算法解决问题的一般步骤：</p><ol><li>针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。</li><li>确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。</li><li>以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</li></ol><h3 id="问题的解空间"><a href="#问题的解空间" class="headerlink" title="问题的解空间"></a>问题的解空间</h3><p>问题的解空间至少包含一个最优解。例如，对于装载问题，若有 n 个集装箱要装上一艘载重量为 c 的轮船，其中集装箱 i 的重量为 wi，要求在不超过轮船载重量的前提下，将尽可能多的集装箱装上轮船。</p><p>当 n=3 时，解空间是由长度为 3 的向量组成的，每个向量的元素取值为 0 或 1，解空间为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;(0,0,0),(0,0,1),(0,1,0),(1,0,0),(0,1,1),(1,0,1),(1,1,0),(1,1,1)&#125;</span><br></pre></td></tr></table></figure><p>其中，0 表示不装入轮船，1 表示装入轮船。若 c=50，W={18, 25, 25}，则解空间可用一棵二叉树表示，左分支用 1 表示，右分支用 0 表示，如下图所示。其中，解向量 (1,1,1) 表示将重量为 18、25、25 的集装箱都装入轮船，总重量为 68。解向量 (0,1,1) 表示将重量为 25 和 25 的集装箱装入轮船，总重量为 50。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807144158991.png" alt="image-20250807144158991"></p><p>解空间树一般分为两种：<strong>子集树和排列树</strong>。当所给的问题是从 n 个元素的集合 S 中找出满足某种性质的子集时，相应的解空间树称为子集树。当所给问题是确定 n 个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有 n! 个叶子结点。因此，遍历排列树需要 O(n!) 的计算时间。</p><h3 id="算法的基本思想"><a href="#算法的基本思想" class="headerlink" title="算法的基本思想"></a>算法的基本思想</h3><p>在构造好解空间树之后，可以利用回溯算法对解空间树进行搜索，通过搜索求出问题的最优解。从解空间树的根结点出发，对解空间进行深度优先搜索遍历：</p><ul><li>初始时，根结点成为活结点，并成为当前的扩展结点，沿着扩展结点向纵深方向搜索，达到一个新的结点后，新的结点就成为活结点，并成为当前的扩展结点。</li><li>若当前的扩展结点不能继续向前搜索，则当前的扩展结点成为死结点，这时就会回溯到最近的活结点位置。</li><li>重复按以上方式搜索整个解空间树，直到程序结束。</li></ul><p>若已经生成一个结点或多个结点，而它的所有孩子结点还没有全部生成，则该结点称为活结点；扩展结点指的是当前正在生成孩子结点的活结点；死结点指的是不再继续扩展的结点或其孩子结点已经全部生成的结点。</p><h2 id="贪心算法实际应用"><a href="#贪心算法实际应用" class="headerlink" title="贪心算法实际应用"></a>贪心算法实际应用</h2><h3 id="解决装载问题"><a href="#解决装载问题" class="headerlink" title="解决装载问题"></a>解决装载问题</h3><p>已知有 n 个集装箱（重量分别为 w1,w2,…,wn）和 1 艘轮船，轮船的载重量为 c，要求在不超过轮船载重量的前提下，将尽可能多的集装箱装入轮船。其中，第 i 个集装箱的重量为 wi。</p><p>当 c=50、W={18, 25, 25} 时，装载问题的搜索过程可以表示成一棵子集树，如下图所示：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807144722069.png" alt="image-20250807144722069"></p><ol><li><p>初始时，根结点是唯一的活结点，也是当前的扩展结点，此时轮船的剩余容量为 cr=50，还未有集装箱装入轮船。</p></li><li><p>从根结点 A 出发对左分支结点 B 进行扩展，若将第 1 个集装箱装入轮船，则有 cr=50-18=32，此时结点 B 为当前的扩展结点，结点 A 和结点 B 为活结点。</p></li><li><p>从当前的扩展结点 B 继续沿深度方向扩展，若将第 2 个集装箱装入轮船，则有 cr=32-25=7，此时结点 D 为当前的扩展结点，结点 A、结点 B 和结点 D 为活结点。</p></li><li><p>从当前的扩展结点 D 沿着左分支继续扩展，由于 cr&lt;25，因此无法将第 3 个集装箱放入轮船，这是一个不可行的解，回溯到结点 D。</p></li><li><p>结点 D 成为活结点，并成为当前的扩展结点，从结点 D 沿着右分支进行扩展，扩展到结点 I，即不将第 3 个集装箱装入轮船，此时有第 1 个和第 2 个集装箱装入轮船，得到一个可行解，解向量为 {1,1,0}，装入轮船的集装箱总重量为 43。</p></li><li><p>结点 I 不能再扩展，成为死结点，回溯到结点 D，结点 D 已无可扩展结点，成为死结点，回溯到结点 B。</p></li><li><p>结点 B 成为当前的扩展结点，沿着结点 B 向右分支结点扩展，到达结点 E，结点 E 成为活结点，并成为当前的扩展结点，第 2 个集装箱不装入轮船，此时轮船上只有第 1 个集装箱，cr=32。</p></li><li><p>沿着结点 E 往左分支扩展，结点 J 成为活结点，并成为当前的扩展结点，将第 3 个集装箱装入轮船，此时有 cr=32-25=7，第 1 个和第 3 个集装箱装入轮船，解向量为 {1,0,1}，装入轮船的总重量为 43。</p></li><li><p>结点 J 不可扩展，成为死结点，回溯到结点 E，结点 E 成为当前的扩展结点，沿着结点 E 向右分支扩展，到达结点 K，结点 K 为活结点，即第 3 个集装箱不装入轮船，此时 cr=32，只有第 1 个集装箱装入轮船，解向量为 {1,0,0}，装入轮船的总重量为 18。<br>按照以上方式继续在解空间树上搜索，搜索完毕后，即可得到装载问题的最优解，最优解为 {0,1,1}。</p></li></ol><h3 id="解决旅行商问题"><a href="#解决旅行商问题" class="headerlink" title="解决旅行商问题"></a>解决旅行商问题</h3><p>旅行商问题（Traveling Salesman Problem，TSP）又称为旅行推销员问题、货郎担问题，是数学领域的著名问题之一。</p><p>一个旅行商要从 n 个城市的某一城市出发去往其他城市，每个城市经过且只经过一次，最后回到原来出发的城市。求在去往任何一个城市的所有路径中路径长度最短的一条。</p><p>为了方便描述该问题，可采用带权图表示 n 个城市之间的关系，顶点表示城市，顶点之间的权值表示城市之间的距离。例如，n=4 时的旅行商问题可用下图表示。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807144956840.png" alt="image-20250807144956840"></p><p>图中的回路有 (1,2,3,4,1)、(1,2,4,3,1)、(1,3,2,4,1)、(1,4,2,3,1)、(1,3,4,2,1) 等，其中 (1,3,4,2,1) 的路径长度最短，其路径长度为 29。旅行商人所走过的可能路线其实是所有路径的排列组合，这些方案可绘制成一棵排列树，也是该问题的解空间树，如下图所示。该树的深度为 5，两个结点之间的路径表示旅行商经过的城市。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807145028236.png" alt="image-20250807145028236"></p><hr><h1 id="算法题一"><a href="#算法题一" class="headerlink" title="算法题一"></a>算法题一</h1><h2 id="N-皇后"><a href="#N-皇后" class="headerlink" title="N 皇后"></a>N 皇后</h2><p>题目链接：<a href="https://leetcode.cn/problems/n-queens/">LeetCode_51. N 皇后</a></p><blockquote><p><strong>问题描述：</strong><br>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。<br>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例 1</strong><br><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807145358766.png" alt="image-20250807145358766"><br><strong>输入</strong>：n = 4<br><strong>输出</strong>：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br><strong>解释</strong>：如上图所示，4 皇后问题存在两个不同的解法。</p><p><strong>示例 2：</strong><br><strong>输入</strong>：n = 1<br><strong>输出</strong>：[[“Q”]]</p><p><strong>提示：</strong><code>1 &lt;= n &lt;= 9</code></p><p><strong>解释</strong>：n皇后和数独有异曲同工的方法。数独是每个横竖宫只有一个相同数字，皇后是横竖斜只有一个皇后。所以N*N矩阵皇后每行每列只有一个皇后。<br><strong>判断皇后位置正确</strong>：判断某位置是否可以放下皇后时，由于是从左往右从上往下的遍历顺序，因此只需要检索当前点的上方，左上方，右上方即可。此外，由于回溯内部的for循环是从左往右遍历的，所以可以肯定遍历到当前节点的时候，当前节点的左边肯定没有皇后， 因此可以不对左边节点进行检索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 结果集</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储一个结果子集</span></span><br><span class="line">    <span class="type">char</span> arr[][] = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 初始化全为空</span></span><br><span class="line">            arr[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(<span class="keyword">new</span> <span class="title class_">String</span>(arr[i])); <span class="comment">// 初始化结果子集</span></span><br><span class="line">    &#125;</span><br><span class="line">    dfs(n, path, <span class="number">0</span>); <span class="comment">// 深度优先搜索 </span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先搜索 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, List&lt;String&gt; q, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">    <span class="comment">// 遍历到底部，退出循环</span></span><br><span class="line">    <span class="keyword">if</span> (start == n)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(q));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRight(q, n, start, i)) &#123; <span class="comment">// 判断 [start][i] 位置是否可以放皇后</span></span><br><span class="line">            <span class="type">char</span>[] rows = q.get(start).toCharArray(); <span class="comment">// 第 start+1行</span></span><br><span class="line">            rows[i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            q.set(start, <span class="keyword">new</span> <span class="title class_">String</span>(rows)); <span class="comment">// 放置皇后</span></span><br><span class="line">            </span><br><span class="line">            dfs(n, q, start + <span class="number">1</span>); <span class="comment">// 深度优先搜索 开始横坐标 start+1 </span></span><br><span class="line">            rows = q.get(start).toCharArray();</span><br><span class="line">            rows[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            q.set(start, <span class="keyword">new</span> <span class="title class_">String</span>(rows));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断该位置是否可以放下,检索横竖斜</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRight</span><span class="params">(List&lt;String&gt; q, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="comment">// 检测当前节点上方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.get(i).charAt(y) == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测左上方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x - <span class="number">1</span>, j = y - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.get(i).charAt(j) == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测右上方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x - <span class="number">1</span>, j = y + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.get(i).charAt(j) == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>题目链接：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">LeetCode_17. 电话号码的字母组合</a></p><blockquote><p><strong>问题描述：</strong></p><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。给出数字到字母的映射与电话按键相同。注意 1 不对应任何字母。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; re = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 结果集</span></span><br><span class="line">String corr[] = &#123;<span class="string">&quot;_&quot;</span>,<span class="string">&quot;!@#&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;; <span class="comment">// 0 - 9 对应的字符</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(digits.length() == <span class="number">0</span> || digits.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    re = findCombination(re, corr, digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归 获取字符串组合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findCombination</span><span class="params">(String digits, <span class="type">int</span> index, String s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == digits.length())&#123;</span><br><span class="line">        re.add(s); <span class="comment">// 添加字符串</span></span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> digits.charAt(index); <span class="comment">// 当前字符数字</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> corr[c- <span class="string">&#x27;0&#x27;</span>]; <span class="comment">// 当前数字对应的字母集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; letters.length(); i++)&#123; <span class="comment">// 2-9 每个数字都对应了多个字符</span></span><br><span class="line">        findCombination(digits, index + <span class="number">1</span>,  s + letters.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算法题二（二叉树）"><a href="#算法题二（二叉树）" class="headerlink" title="算法题二（二叉树）"></a>算法题二（二叉树）</h1><h2 id="树节点定义"><a href="#树节点定义" class="headerlink" title="树节点定义"></a>树节点定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; </span><br><span class="line">        <span class="built_in">this</span>.val = val; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">char</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历  父 左 右</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);  <span class="comment">// 访问根节点</span></span><br><span class="line">    preOrder(root.left);               <span class="comment">// 递归左子树</span></span><br><span class="line">    preOrder(root.right);              <span class="comment">// 递归右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历 左 父 右</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历 左 右 父</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 创建一个队列，加入根节点</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 取出队首元素</span></span><br><span class="line">        System.out.print(cur.val + <span class="string">&quot;&quot;</span>);  <span class="comment">// 访问</span></span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left); <span class="comment">// 左节点入队</span></span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right); <span class="comment">// 右节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树还原"><a href="#二叉树还原" class="headerlink" title="二叉树还原"></a>二叉树还原</h2><p>公共代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> in.nextLine().trim();</span><br><span class="line">    String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] charsEnd = arr[<span class="number">0</span>].trim().toCharArray();</span><br><span class="line">    <span class="type">char</span>[] charsMid = arr[<span class="number">1</span>].trim().toCharArray();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> buildTree(charsMid, charsEnd); <span class="comment">// 构建树</span></span><br><span class="line">    List&lt;Character&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 层次遍历结果</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 根出队</span></span><br><span class="line">        res.add(node.val);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">        System.out.print(res.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="已知：后序-中序"><a href="#已知：后序-中序" class="headerlink" title="已知：后序 + 中序"></a>已知：后序 + 中序</h3><blockquote><p><strong>案例</strong>：<br>后序  ： C B E F D A<br>中序  ： C B A E D F</p><ol><li>后序 最后一个元素 A 为根节点</li><li>在中序中左子树在根节点左侧：拿着根节点 A 在中序中找</li><li>对照着后序：CB 为左子树的后序，EFD 为右子树的后序</li><li>还原 A 的左子树<pre><code>后序   CB      确定 B 为左子树的根节点，拿着 B 去中序中找，C 是 B 的左子树，B 的右子树为空中序   CB</code></pre></li><li>还原 A 的右子树<pre><code>后序   EFD    D 为右子树的根中序   EDF    D 的左子树是 E 右子树为 F </code></pre></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">char</span>[] charsMid, <span class="type">char</span>[] charsEnd)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (charsMid.length == <span class="number">0</span> ||  charsEnd.length == <span class="number">0</span> || charsEnd.length != charsMid.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character, Integer&gt; mapMid = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charsMid.length; i++) &#123;</span><br><span class="line">        mapMid.put(charsMid[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildTreeHelpPostMid(charsMid, <span class="number">0</span>, charsMid.length - <span class="number">1</span>, charsEnd, <span class="number">0</span>, charsEnd.length - <span class="number">1</span>, mapMid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTreeHelperPostMid</span><span class="params">(<span class="type">char</span>[] charsMid, <span class="type">int</span> minS, <span class="type">int</span> midE,</span></span><br><span class="line"><span class="params">                                     <span class="type">char</span>[] charsEnd, <span class="type">int</span> endS, <span class="type">int</span> endE, Map&lt;Character, Integer&gt; midMap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(endS &gt; endE || minS &gt; midE) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">rootVal</span> <span class="operator">=</span> charsEnd[endE];</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">midRootIndex</span> <span class="operator">=</span> midMap.get(rootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numsLeft</span> <span class="operator">=</span>  midRootIndex - minS; <span class="comment">// 左子树长度</span></span><br><span class="line">    <span class="comment">// 还原左子树</span></span><br><span class="line">    root.left = buildTreeHelperPostMid(charsMid, minS, midE - <span class="number">1</span>,</span><br><span class="line">                              charsEnd, endS, endS + numsLeft - <span class="number">1</span>, midMap);</span><br><span class="line">    <span class="comment">// 还原右子树</span></span><br><span class="line">    root.right = buildTreeHelperPostMid(charsMid, midRootIndex + <span class="number">1</span>, midE,</span><br><span class="line">                               charsEnd, endS + numsLeft, endE - <span class="number">1</span>, midMap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="已知：先序-中序"><a href="#已知：先序-中序" class="headerlink" title="已知：先序 + 中序"></a>已知：先序 + 中序</h3><blockquote><p><strong>案例</strong>：<br>先序  ： E F H I G J K<br>中序  ： H F I E J K G</p><ol><li>先序 第一个元素 E 为根节点</li><li>在中序中左子树在根节点左侧：拿着根节点 E 在中序中找</li><li>对照着先序：FHI 为左子树的先序，GJK 为右子树的先序</li><li>还原 E 的左子树<pre><code>先序  FHI      确定 F 为左子树的根节点，拿着 F 去中序中找，H 是 F 的左子树，I 为 F 的右子树中序  HFI</code></pre></li><li>还原 E 的右子树<pre><code>先序   GJK    G 为右子树的根中序   JKG    G 的左子树是 JK 右子树为空</code></pre></li><li>还原G的左子树<pre><code>先序   JK       J 为 G 的左子树的根中序   JK       J 为 G 的左子树的右子树</code></pre></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">char</span>[] charsMid, <span class="type">char</span>[] charsPre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (charsMid.length == <span class="number">0</span> || charsPre.length == <span class="number">0</span> || charsPre.length != charsMid.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character, Integer&gt; mapMid = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charsMid.length; i++) &#123;</span><br><span class="line">        mapMid.put(charsMid[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildTreeHelpPreMid(charsMid, <span class="number">0</span>, charsMid.length - <span class="number">1</span>, charsPre, <span class="number">0</span>, charsPre.length - <span class="number">1</span>, mapMid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTreeHelpPreMid</span><span class="params">(<span class="type">char</span>[] charsMid, <span class="type">int</span> midS, <span class="type">int</span> midE,</span></span><br><span class="line"><span class="params">                                     <span class="type">char</span>[] charsPre, <span class="type">int</span> preS, <span class="type">int</span> preE, Map&lt;Character, Integer&gt; midMap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(preS &gt; preE || midS &gt; midE) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">rootVal</span> <span class="operator">=</span> charsPre[preS];</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">midRootIndex</span> <span class="operator">=</span> midMap.get(rootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numsLeft</span> <span class="operator">=</span>  midRootIndex - midS; <span class="comment">// 左子树长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原左子树</span></span><br><span class="line">    root.left = buildTreeHelpPreMid(charsMid, midS, midE - <span class="number">1</span>,</span><br><span class="line">            charsPre, preS + <span class="number">1</span>, preS + numsLeft, midMap);</span><br><span class="line">    <span class="comment">// 还原右子树</span></span><br><span class="line">    root.right = buildTreeHelpPreMid(charsMid, midRootIndex + <span class="number">1</span>, midE,</span><br><span class="line">            charsPre, preS + numsLeft + <span class="number">1</span>, preE, midMap);</span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><p>题目链接：<a href="https://leetcode.cn/problems/diameter-of-binary-tree/">LeetCode_543. 二叉树的直径</a></p><blockquote><p><strong>问题描述：</strong><br>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 10^4]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 全局变量 最长路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> (root.left == <span class="literal">null</span>) ? <span class="number">0</span>: dfs(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightSize</span> <span class="operator">=</span> (root.right == <span class="literal">null</span>) ? <span class="number">0</span>: dfs(root.right) + <span class="number">1</span>;</span><br><span class="line">    max = Math.max(max, leftSize + rightSize);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftSize, rightSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h2><p>题目链接：<a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">LeetCode_124. 二叉树中的最大路径和</a></p><blockquote><p><strong>问题描述：</strong><br>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong>节点，且不一定经过根节点。 <strong>路径和</strong>是路径中各节点值的总和。给出二叉树的根节点 <code>root</code> ，返回其<strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE; <span class="comment">// 全局变量 最大路径和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先搜索</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Math.max(dfs(root.left), <span class="number">0</span>); <span class="comment">// 左子树最大路径和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Math.max(dfs(root.right), <span class="number">0</span>); <span class="comment">// 右子树最大路径和</span></span><br><span class="line">    res = Math.max(res, l + r + root.val); <span class="comment">// 左右子树最大路径和+根节点值</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(l, r) + root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相邻字符不同的最长路径"><a href="#相邻字符不同的最长路径" class="headerlink" title="相邻字符不同的最长路径"></a>相邻字符不同的最长路径</h2><p>题目链接：<a href="https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/">LeetCode_2246. 相邻字符不同的最长路径</a></p><blockquote><p><strong>问题描述：</strong><br>给你一棵 <strong>树</strong>（即一个连通、无向、无环图），根节点是节点 <code>0</code> ，这棵树由编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点组成。用下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>parent</code> 来表示这棵树，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点，由于节点 <code>0</code> 是根节点，所以 <code>parent[0] == -1</code> 。<br>另给你一个字符串 <code>s</code> ，长度也是 <code>n</code> ，其中 <code>s[i]</code> 表示分配给节点 <code>i</code> 的字符。<br>请你找出路径上任意一对相邻节点都没有分配到相同字符的 <strong>最长路径</strong> ，并返回该路径的长度。<br><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：parent = [-1,0,0,1,1,2], s = &quot;abacbe&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：任意一对相邻节点字符都不同的最长路径是：0 -&gt; 1 -&gt; 3 。该路径的长度是 3 ，所以返回 3 。</span><br><span class="line">可以证明不存在满足上述条件且比 3 更长的路径。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：parent = [-1,0,0,0], s = &quot;aabc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：任意一对相邻节点字符都不同的最长路径是：2 -&gt; 0 -&gt; 3 。该路径的长度为 3 ，所以返回 3 。</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807160857199.png" alt="image-20250807160857199"></p><p><strong>提示：</strong></p><ul><li><code>n == parent.length == s.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li>对所有 <code>i &gt;= 1</code> ，<code>0 &lt;= parent[i] &lt;= n - 1</code> 均成立</li><li><code>parent[0] == -1</code></li><li><code>parent</code> 表示一棵有效的树</li><li><code>s</code> 仅由小写英文字母组成</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPath</span><span class="params">(<span class="type">int</span>[] parent, String s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">        adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 构建类似多叉树：父节点包含多个子节点</span></span><br><span class="line">        adj.get(parent[i]).add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s, <span class="number">0</span>); <span class="comment">// 深度优先</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(String s, <span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj.get(root).isEmpty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> next : adj.get(root)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> dfs(s, next);</span><br><span class="line">        ans = Math.max(ans, now);</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(root) != s.charAt(next)) &#123;</span><br><span class="line">            q.offer(now);</span><br><span class="line">            <span class="comment">// 一个父节点在路径中最多保留两条子路径的和</span></span><br><span class="line">            <span class="keyword">if</span> (q.size() &gt; <span class="number">2</span>) q.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> q.isEmpty() ? <span class="number">0</span> : q.poll(), b = q.isEmpty() ? <span class="number">0</span> : q.poll();</span><br><span class="line">    ans = Math.max(ans, a + b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(a, b) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长同值路径"><a href="#最长同值路径" class="headerlink" title="最长同值路径"></a>最长同值路径</h2><p>题目链接：<a href="https://leetcode.cn/problems/longest-univalue-path/">LeetCode_687. 最长同值路径</a></p><blockquote><p><strong>问题描述：</strong><br>给定一个二叉树的 <code>root</code> ，返回 <em>最长的路径的长度</em> ，这个路径中的 <em>每个节点具有相同值</em> 。 这条路径可以经过也可以不经过根节点。<strong>两个节点之间的路径长度</strong> 由它们之间的边数表示。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,5,1,1,5]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,4,5,4,4,5]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>树的节点数的范围是 <code>[0, 10^4]</code> </li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li>树的深度将不超过 <code>1000</code> </li></ul><p><strong>思路：</strong>对于任意一个节点, 如果最长同值路径包含该节点, 那么只可能是两种情况：</p><pre><code>1. 其左右子树中加上该节点后所构成的同值路径中较长的那个继续向父节点回溯构成最长同值路径2. 左右子树加上该节点都在最长同值路径中, 构成了最终的最长同值路径</code></pre><p>需要注意因为要求同值, 所以在判断左右子树能构成的同值路径时要加入当前节点的值作为判断依据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    getMaxL(root, root.val);</span><br><span class="line">    <span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxL</span><span class="params">(TreeNode r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getMaxL(r.left, r.val);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getMaxL(r.right, r.val);</span><br><span class="line">    maxL = Math.max(maxL, left+right); <span class="comment">// 路径长度为节点数减1所以此处不加1</span></span><br><span class="line">    <span class="keyword">if</span>(r.val == val) &#123; <span class="comment">// 和父节点值相同才返回以当前节点所能构成的最长通知路径长度, 否则返回0</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算法题三"><a href="#算法题三" class="headerlink" title="算法题三"></a>算法题三</h1><h2 id="流浪地球"><a href="#流浪地球" class="headerlink" title="流浪地球"></a>流浪地球</h2><blockquote><p><strong>问题描述：</strong><br>流浪地球计划在赤道上均匀部署了N个转向发动机，按位置顺序编号为0~N。</p><ol><li>初始状态下所有的发动机都是未启动状态;</li><li>发动机启动的方式分为”手动启动”和”关联启动”两种方式;</li><li>如果在时刻1一个发动机被启动，下一个时刻2与之相邻的两个发动机就会被”关联启动”;</li><li>如果准备启动某个发动机时，它已经被启动了，则什么都不用做</li></ol><p>发动机0与发动机N-1是相邻的。地球联合政府准备挑选某些发动机在某些时刻进行“手动启动”。当然最终所有的发动机都会被启动。<br>哪些发动机最晚被启动呢?</p><p><strong>输入描述：</strong>第一行两个数字N和E，中间有空格，N代表部署发动机的总个数，E代表计划手动启动的发动机总个数 1&lt;N&lt;=1000,1&lt;=E&lt;=1000,E&lt;=N。接下来共E行，每行都是两个数字T和P，中间有空格 T 代表发动机的手动启动时刻，P代表此发动机的位置编号。 0&lt;=T&lt;=N.0&lt;=P&lt;N<br><strong>输出描述：</strong>第一行一个数字N，以回车结束 N代表最后被启动的发动机个数；第二行N个数字，中间有空格，以回车结束 每个数字代表发动机的位置编号，从小到大排序</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">8 2</span><br><span class="line">0 2</span><br><span class="line">0 6</span><br><span class="line">输出</span><br><span class="line">2</span><br><span class="line">0 4</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8个发动机;</span><br><span class="line">时刻0启动(2,6);</span><br><span class="line">时刻1启动(1,3.5,7)(其中1,3被2关联启动，5，7被6关联启动);</span><br><span class="line">时刻2启动(0,4)(其中0被1,7关联启动，4被3,5关联启动);</span><br><span class="line">至此所有发动机都被启动，最后被启动的有2个，分别是0和4。</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：模拟。枚举每一秒时间，用一个队列维护当前启动了哪些发动机。之后每一秒先遍历队列中的所有发动机，尝试向左右两侧扩展一次，如果扩展到没有启动的发动机就更新其启动时间，同时把发动机放入队列。之后再遍历所有手动启动的发动机，如果某个发动机没启动并且会在这一秒启动，就把他放入队列同时更新启动时间这样就能更新出所有发动机的最早启动时间，找出最大值并输出所有最晚启动的即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">problem28</span><span class="params">(<span class="type">int</span> n, List&lt;<span class="type">int</span>[]&gt; a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 存每个发动机最早启动时间</span></span><br><span class="line">    Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">// 用一个队列维护当前启动了哪些发动机</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t &lt;= <span class="number">5000</span>; ++t)&#123; <span class="comment">// 枚举每一秒时间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size(); <span class="comment">// 当前队列大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; sz; ++j)&#123; <span class="comment">// 循环队列大小次</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> q.poll(); <span class="comment">// 出队</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (f - <span class="number">1</span> + n) % n; <span class="comment">// 左侧相邻发动机</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (f + <span class="number">1</span>) % n; <span class="comment">// 右侧相邻发动机</span></span><br><span class="line">            <span class="keyword">if</span>(ans[x] == -<span class="number">1</span>)&#123; <span class="comment">// 未启动则启动并放入队列</span></span><br><span class="line">                q.add(x);</span><br><span class="line">                ans[x] = ans[f] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans[y] == -<span class="number">1</span>)&#123; <span class="comment">// 未启动则启动并放入队列</span></span><br><span class="line">                q.add(y);</span><br><span class="line">                ans[y] = ans[f] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.size(); ++i)&#123; <span class="comment">// 遍历所有手动启动的发动机</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> a.get(i)[<span class="number">0</span>]; <span class="comment">// 时间</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">P</span> <span class="operator">=</span> a.get(i)[<span class="number">1</span>]; <span class="comment">// 编号</span></span><br><span class="line">            <span class="keyword">if</span>(T == t &amp;&amp; ans[P] == -<span class="number">1</span>)&#123; <span class="comment">// 如果某个发动机没启动并且会在这一秒启动，就把他放入队列同时更新启动时间</span></span><br><span class="line">                q.add(P);</span><br><span class="line">                ans[P] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        max = Math.max(max, ans[i]); <span class="comment">// 找最晚时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max == ans[i])&#123; <span class="comment">// 找符合最晚时间的个数</span></span><br><span class="line">            c += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(c); <span class="comment">// 输出个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == max) &#123;<span class="comment">// 输出具体序号</span></span><br><span class="line">            <span class="keyword">if</span> (f != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Boss的收入"><a href="#Boss的收入" class="headerlink" title="Boss的收入"></a>Boss的收入</h2><blockquote><p><strong>问题描述：</strong><br>一个XX产品行销总公司，只有一个boss，其有若干一级分销，一级分销又有若干二级分销，每个分销只有唯一的上级分销。规定每个月，下级分销需要将自己的总收入(自己的+下级上交的)每满100元上交15元给自己的上级。现给出一组分销的关系，和每个分销的收入，请找出 boss并计算出这 boss 的收入。<br>比如：收入100元上交15元,收入199元(9元不够100)上交15元，收入200元，上交30元。<br>分销关系和收入:分销id 上级分销的id 收入；分销ID范围0…65535 ；收入范围:0…65535,单位元<br><strong>提示</strong>：输入的数据只存在1个 boss，不存在环路<br><strong>输入描述：</strong>第1行输入关系的总数量N；第2行开始，输入关系信息，格式：分销ID 上级分销ID 收入<br><strong>输出描述：</strong>boss的ID 总收入<br><strong>补充说明：</strong>给定的输入数据都是合法的，不存在重复</p><p><strong>示例 1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">5</span><br><span class="line">1 0 100</span><br><span class="line">2 0 200</span><br><span class="line">3 0 300</span><br><span class="line">4 0 200</span><br><span class="line">5 0 200</span><br><span class="line">输出 0 150</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">3</span><br><span class="line">1 0 223</span><br><span class="line">2 0 323</span><br><span class="line">3 2 1203</span><br><span class="line">输出 0 105</span><br><span class="line">说明：2的最终收入等于323+1203/100*15=323+180；0的最终收入等于(323+180+223)/100*15=105</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：使用一个队列进行广度优先搜索（BFS）。从队列中取出当前分销IDx，获取其上级分销IDy，更新收入并更新上级分销的下级计数器in。如果某个上级分销没有下级分销了，将其加入队列。重复此过程直至队列为空。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关系的总数量N, 关系信息列表（分销ID 上级分销ID 收入）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">problem63</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] arr)</span> &#123;</span><br><span class="line">    <span class="type">long</span>[] fa = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">100010</span>];  <span class="comment">// 记录每个分销的上级分销ID</span></span><br><span class="line">    <span class="type">long</span>[] mon = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">100010</span>];  <span class="comment">// 记录每个分销的收入</span></span><br><span class="line">    Arrays.fill(fa, -<span class="number">1</span>);  <span class="comment">// 初始化fa数组，全部设置为-1，表示未知上级</span></span><br><span class="line">    List&lt;Integer&gt; in = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Collections.nCopies(<span class="number">100010</span>, <span class="number">0</span>));  <span class="comment">// 记录每个分销被定义为上级的次数</span></span><br><span class="line">    Set&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();  <span class="comment">// 用于存储所有出现的分销ID</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[i][<span class="number">0</span>], y = arr[i][<span class="number">1</span>], z = arr[i][<span class="number">2</span>];</span><br><span class="line">        st.add(x);  <span class="comment">// 将分销ID x 加入集合</span></span><br><span class="line">        st.add(y);  <span class="comment">// 将上级分销ID y 加入集合</span></span><br><span class="line">        in.set(y, in.get(y) + <span class="number">1</span>);  <span class="comment">// 记录上级分销ID y 被定义为上级的次数</span></span><br><span class="line">        fa[x] = y;  <span class="comment">// 设置分销 x 的上级分销ID 为 y</span></span><br><span class="line">        mon[x] = z;  <span class="comment">// 设置分销 x 的收入为 z</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个队列用于处理没有下级的分销</span></span><br><span class="line">    Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : st) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in.get(x) == <span class="number">0</span>) &#123;</span><br><span class="line">            que.offer(x);  <span class="comment">// 如果某分销ID没有下级分销，将其加入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 最终输出的 boss 收入</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 最终输出的 boss ID</span></span><br><span class="line">    <span class="comment">// 广度优先</span></span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        x = que.poll();  <span class="comment">// 获取队列中的第一个元素</span></span><br><span class="line">        ans = mon[x];  <span class="comment">// 收入设置为当前的收入（会随程序运行最后是 boss 的收入）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) fa[x];  <span class="comment">// 获取分销 x 的上级分销ID</span></span><br><span class="line">        <span class="keyword">if</span> (y == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 如果上级分销ID是-1，跳过此次循环（可能是根节点）</span></span><br><span class="line">        &#125;</span><br><span class="line">        in.set(y, in.get(y) - <span class="number">1</span>);  <span class="comment">// 上级分销 y 的下级数量减1</span></span><br><span class="line">        <span class="keyword">if</span> (in.get(y) == <span class="number">0</span>) &#123;</span><br><span class="line">            que.offer(y);  <span class="comment">// 如果上级分销 y 没有下级分销了，将其加入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算并累加上级分销 y 的收入：当前收入的15%上交给上级</span></span><br><span class="line">        mon[y] += mon[x] / <span class="number">100</span> * <span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出最终的 boss ID 和 boss 的总收入</span></span><br><span class="line">    System.out.println(x + <span class="string">&quot; &quot;</span> + ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回溯算法是一种通过系统性试探和回退策略搜索问题解的通用方法，适用于组合优化、约束满足等复杂问题，其核心特征是“能进则进，不进则退”的深度优先搜索机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tence</summary>
      
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://southernfish.github.io/pages/algorithm/greedy-algorithm/"/>
    <id>https://southernfish.github.io/pages/algorithm/greedy-algorithm/</id>
    <published>2025-08-04T07:20:36.000Z</published>
    <updated>2025-09-20T11:18:48.136Z</updated>
    
    <content type="html"><![CDATA[<p>贪心算法是一种在每一步选择中都采取当前状态下最优（即最有利）的选择，从而希望导致结果是全局最优的算法策略。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/weixin_67868534/article/details/149097914">贪心算法（Greedy Algorithm）</a></p><p><a href="https://cloud.tencent.com/developer/article/2527732">【算法/训练】：贪心（算法理论学习及实践）</a></p><p><a href="https://blog.csdn.net/WandZ123/article/details/125019048">＜贪心算法＞学习及经典实例分析</a></p></blockquote><h1 id="贪心算法详解"><a href="#贪心算法详解" class="headerlink" title="贪心算法详解"></a>贪心算法详解</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>贪心算法（Greedy Algorithm）是一种<strong>分阶段决策策略</strong>：在对问题求解时，总是做出在当前看来是最好的选择的算法，也就是当前状态的局部最优解，通过迭代累积这些局部最优解，期望得到全局最优解。其核心特征是 “<strong>无后效性</strong>”（当前决策不影响后续状态）和 “<strong>贪心选择性质</strong>”（局部最优可推导全局最优）。贪心算法的核心在于<strong>贪心策略的选择</strong>，即每一步的最优选择是否能推导出全局最优解。</p><p>贪心算法的价值在于其<strong>简洁性与高效性</strong>，但必须警惕其局限性——<strong>局部最优未必全局最优</strong>。掌握其适用条件（贪心选择性质+最优子结构）和证明方法，方能灵活应用于任务调度、图论、组合优化等场景。</p><h2 id="核心性质"><a href="#核心性质" class="headerlink" title="核心性质"></a>核心性质</h2><p><strong>贪心算法采用自顶向下，以迭代的方法做出相继的贪心选择</strong>，每做一次贪心选择就将所求问题简化为一个规模更小的子问题，通过每一步贪心选择，可得到问题的一个最优解，虽然每一步上都要保证能获得局部最优解，但由此产生的全局解有时不一定是最优的，所以贪婪法不要回溯。能够用贪心算法求解的问题一般具有两个重要特性：<strong>贪心选择性质和最优子结构性质</strong></p><ul><li><strong>贪心选择性质</strong>：每一步的最优解不依赖于未来决策或子问题的解。<ul><li><strong>所求问题的整体最优解可以通过一系列局部最优的选择</strong>，即贪心选择来达到。这是贪心算法可行的第一个基本要素。</li><li>对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。</li><li><strong>证明的大致过程如下：</strong><ul><li>首先考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始。</li><li>做了贪心选择后，原问题简化为规模更小的类似子问题。</li><li>然后用数学归纳法证明通过每一步做贪心选择，最终可得到问题的整体最优解。</li><li>其中，证明贪心选择后的问题简化为规模更小的类似子问题的关键在于利用该问题的<strong>最优子结构性质</strong></li></ul></li></ul></li><li><strong>最优子结构</strong>：问题的最优解包含其子问题的最优解，与动态规划共享此性质，但贪心算法<strong>无需回溯或存储子问题解</strong>。</li><li><strong>无后效性</strong>：决策一旦做出，不可更改，后续状态仅由当前状态决定。</li></ul><h2 id="贪心算法与动态规划的差异"><a href="#贪心算法与动态规划的差异" class="headerlink" title="贪心算法与动态规划的差异"></a>贪心算法与动态规划的差异</h2><ul><li>动态规划和贪心算法都是一种递推算法，均有最优子结构性质，通过局部最优解来推导全局最优解。</li><li>两者之间的区别在于：<ul><li>贪心算法中作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一步之前的最优解则不作保留，贪心算法每一步的最优解一定包含上一步的最优解。</li><li>动态规划算法中全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解。    </li></ul></li></ul><h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><p>贪心算法的通用实现步骤：</p><blockquote><ol><li>定义问题目标与约束条件</li><li>设计贪心选择策略（如排序、优先队列）</li><li>迭代选择局部最优解</li><li>验证并合并解到全局解</li><li>终止条件：问题规模归零或约束满足</li></ol></blockquote><p><strong>算法思路</strong>：</p><ol><li>建立数学模型来描述问题；</li><li>把求解的问题分成若干个子问题；</li><li>对每个子问题进行求解，得到子问题的局部最优解；</li><li>把子问题的解（局部最优解）合成原来问题的解；</li></ol><p><strong>算法实现</strong>：</p><ol><li>从问题的某个初始解出发；</li><li>采用循环语句，当可以向求解目标前进一步时，就根据局部最优策略，得到一个部分解，缩小问题的范围或规模；</li><li>将所有部分解综合起来，得到问题的最终解；</li></ol><p><strong>使用情况</strong></p><blockquote><p> <strong>举个例子：</strong>  有 6 张纸币，面额分别为 100，70，50， 20，20，10，现在我们可以拿走 3 张纸币，要求总金额最大，该怎么拿 </p></blockquote><ul><li>一看到这个问题，肯定就会想着拿最大的那三张就行了，其实这个想法是没错的，但可以把这个想法分解一下：</li><li>不考虑拿 3 张，只考虑拿走一张的最大值（局部最优），那这个问题就可以拆解为拿三次的情况，第一次拿 100，第二次拿 70，第三次拿 50，那我们最多可以拿 220</li></ul><h2 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h2><ol><li><p><strong>任务调度与区间问题</strong></p><ul><li><p><strong>活动选择</strong>：最大化不重叠活动数量（按结束时间排序）。</p></li><li><p><strong>会议室安排</strong>：最小化会议室使用数量（转化为区间重叠计数）。</p></li></ul></li><li><h5 id="图论问题"><a href="#图论问题" class="headerlink" title="图论问题"></a><strong>图论问题</strong></h5><ul><li><strong>最小生成树</strong><ul><li><strong>Prim算法</strong>：从单点出发，每次选择与树相连的最小边。</li><li><strong>Kruskal算法</strong>：按边权升序排序，选择不形成环的边。</li></ul></li><li><strong>最短路径</strong><ul><li><strong>Dijkstra算法</strong>：从源点出发，每次选择距离最小的未处理节点。</li></ul></li></ul></li><li><h5 id="组合优化问题"><a href="#组合优化问题" class="headerlink" title="组合优化问题"></a><strong>组合优化问题</strong></h5><ul><li><strong>分数背包</strong>：按单位价值排序，优先装入高价值物品。</li><li><strong>找零问题</strong>：硬币面额满足贪心性质时（如人民币面额），优先使用大面额硬币。</li></ul></li></ol><h2 id="经典例题详解"><a href="#经典例题详解" class="headerlink" title="经典例题详解"></a>经典例题详解</h2><ul><li><p><strong>最小合并代价</strong><br>​<strong>​问题​</strong>​：合并n个部落，每次合并代价为两部落人数之和，求最小总代价。<br>​<strong>​解法​</strong>​：优先队列（最小堆）每次合并最小的两个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">min_cost</span>(<span class="params">nums</span>):</span><br><span class="line">    heapq.heapify(nums)</span><br><span class="line">    cost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(nums) &gt; <span class="number">1</span>:</span><br><span class="line">        a = heapq.heappop(nums)</span><br><span class="line">        b = heapq.heappop(nums)</span><br><span class="line">        cost += a + b</span><br><span class="line">        heapq.heappush(nums, a + b)</span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure></li><li><p><strong>纪念品分组</strong><br><strong>问题</strong>：将物品两两分组，每组和不超过W，求最少组数。<br><strong>解法</strong>：排序后双指针配对（最大与最小配对）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">min_groups</span>(<span class="params">items, W</span>):</span><br><span class="line">    items.sort()</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(items) - <span class="number">1</span></span><br><span class="line">    groups = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> items[left] + items[right] &lt;= W:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">        groups += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> groups</span><br></pre></td></tr></table></figure></li><li><h5 id="变种与挑战问题"><a href="#变种与挑战问题" class="headerlink" title="变种与挑战问题"></a><strong>变种与挑战问题</strong></h5><ol><li><strong>加油站问题</strong><ul><li>环形路线上，每个加油站有油量gas[i]，从第i站到下一站耗油cost[i]，求可行起点。</li><li><strong>贪心策略</strong>：若当前剩余油量&lt;0，则起点设为下一站，重置油量。</li></ul></li><li><strong>数列极差问题</strong><ul><li>操作：每次擦去两数a、b，加入a×b+1，求最终数的极差（max-min）。</li><li><strong>解法</strong>：最小化时合并最大数，最大化时合并最小数。</li></ul></li></ol></li><li><p><strong>实战训练建议</strong></p><ul><li><strong>入门题库</strong>：LeetCode “Assign Cookies”（分配问题）、”Best Time to Buy and Sell Stock II”（股票买卖）。</li><li><strong>进阶挑战</strong>：蓝桥杯 “答疑”（按s+a升序排序减少等待时间）、HackerRank “Greedy Florist”。</li><li><strong>竞赛考点</strong>：贪心常与排序、堆、双指针结合，需重点训练边界条件处理。</li></ul></li></ul><hr><h1 id="贪心策略的代码实现范式"><a href="#贪心策略的代码实现范式" class="headerlink" title="贪心策略的代码实现范式"></a>贪心策略的代码实现范式</h1><h2 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h2><ul><li><strong>优先队列（堆）</strong>：用于快速获取最小值/最大值（如合并果子问题）。</li><li><strong>排序预处理</strong>：为贪心选择创造条件（如区间调度需按结束时间排序）。</li></ul><h2 id="经典问题实现"><a href="#经典问题实现" class="headerlink" title="经典问题实现"></a>经典问题实现</h2><h3 id="区间调度（最大不重叠区间）"><a href="#区间调度（最大不重叠区间）" class="headerlink" title="区间调度（最大不重叠区间）"></a>区间调度（最大不重叠区间）</h3><p><strong>问题描述</strong>：从一组区间中选择最多数量的互不重叠区间。<br><strong>贪心策略</strong>：按结束时间升序排序，优先选择结束早的区间。<br><strong>时间复杂度</strong>：O(n log n)，主要来自排序操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_non_overlapping</span>(<span class="params">intervals</span>):</span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])  <span class="comment"># 按结束时间排序</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    last_end = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> start, end <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">if</span> start &gt;= last_end:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            last_end = end</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="哈夫曼编码（数据压缩）"><a href="#哈夫曼编码（数据压缩）" class="headerlink" title="哈夫曼编码（数据压缩）"></a>哈夫曼编码（数据压缩）</h3><p><strong>问题描述</strong>：构造字符的最优前缀编码树，使带权路径长度最小。<br><strong>贪心策略</strong>：每次合并频率最小的两个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_huffman_tree</span>(<span class="params">data</span>):</span><br><span class="line">    freq = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> data:</span><br><span class="line">        freq[char] = freq.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    heap = [[weight, [char, <span class="string">&quot;&quot;</span>]] <span class="keyword">for</span> char, weight <span class="keyword">in</span> freq.items()]</span><br><span class="line">    heapq.heapify(heap)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(heap) &gt; <span class="number">1</span>:</span><br><span class="line">        lo = heapq.heappop(heap)</span><br><span class="line">        hi = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> lo[<span class="number">1</span>:]:</span><br><span class="line">            pair[<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span> + pair[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> hi[<span class="number">1</span>:]:</span><br><span class="line">            pair[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span> + pair[<span class="number">1</span>]</span><br><span class="line">        heapq.heappush(heap, [lo[<span class="number">0</span>] + hi[<span class="number">0</span>]] + lo[<span class="number">1</span>:] + hi[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="正确性证明与复杂度分析"><a href="#正确性证明与复杂度分析" class="headerlink" title="正确性证明与复杂度分析"></a>正确性证明与复杂度分析</h2><h3 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h3><ul><li><strong>数学归纳法</strong>：证明每一步贪心选择均保持最优子结构。</li><li><strong>反证法</strong>：假设存在更优解，通过替换操作证明贪心解更优（如区间调度问题）。</li><li><strong>构造法</strong>：展示贪心解可逐步扩展为全局最优解（如哈夫曼树构造）。</li></ul><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th align="left">问题类型</th><th align="left">时间复杂度</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">区间调度</td><td align="left">O(n log n)</td><td align="left">O(1)</td></tr><tr><td align="left">哈夫曼编码</td><td align="left">O(n log n)</td><td align="left">O(n)</td></tr><tr><td align="left">最小生成树（Prim）</td><td align="left">O(E log V)</td><td align="left">O(V)</td></tr></tbody></table><h3 id="适用条件判断"><a href="#适用条件判断" class="headerlink" title="适用条件判断"></a>适用条件判断</h3><p>贪心算法<strong>仅适用于满足以下性质的问题</strong>：</p><ul><li><strong>贪心选择性质</strong>：局部最优可推导全局最优。</li><li><strong>最优子结构</strong>：子问题最优解可组合为原问题最优解。</li><li><strong>不适用场景</strong>：当前选择影响未来状态（如0-1背包问题需用动态规划）。</li></ul><hr><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>题目链接：<a href="https://leetcode.cn/problems/candy/">LeetCode_135. 分发糖果</a></p><blockquote><p><strong>问题描述：</strong><br><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。需要按照以下要求，给这些孩子分发糖果：<br>每个孩子至少分配到 <code>1</code> 个糖果；相邻两个孩子中，评分更高的那个会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p><strong>示例 1：</strong><br><strong>输入</strong>：ratings = [1,0,2]<br><strong>输出</strong>：5<br><strong>解释</strong>：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</p><p><strong>示例 2：</strong><br><strong>输入</strong>：ratings = [1,2,2]<br><strong>输出</strong>：4<br><strong>解释</strong>：可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</p><p><strong>提示：</strong><br><code>n == ratings.length</code><br><code>1 &lt;= n &lt;= 2 * 10^4</code><br><code>0 &lt;= ratings[i] &lt;= 2 * 10^4</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] candyVec = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length]; <span class="comment">// 每个小孩分的糖果</span></span><br><span class="line">    Arrays.fill(candyVec, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 从左往右遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ratings.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>])&#123;</span><br><span class="line">            candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右往左遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) &#123;</span><br><span class="line">            candyVec[i] = Math.max(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; candyVec.length; i++) &#123;</span><br><span class="line">        result += candyVec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>题目链接：<a href="https://leetcode.cn/problems/container-with-most-water/">LeetCode_11. 盛最多水的容器</a></p><blockquote><p><strong>问题描述：</strong><br>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。<br>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。<br><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong><br><strong>输入</strong>：[1,8,6,2,5,4,8,3,7]<br><strong>输出</strong>：49<br><strong>解释</strong>：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250807133603378.png" alt="image-20250807133603378"></p><p><strong>示例 2：</strong><br><strong>输入</strong>：height = [1,1]<br><strong>输出</strong>：1</p><p><strong>提示：</strong><br><code>n == height.length</code><br><code>2 &lt;= n &lt;= 10^5</code><br><code>0 &lt;= height[i] &lt;= 10^4</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> height.length - <span class="number">1</span>, max = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; r; ) &#123;</span><br><span class="line">       max = Math.max(max, Math.min(height[l], height[r]) * (r - l));</span><br><span class="line">       <span class="keyword">if</span> (height[l] &lt; height[r]) &#123;</span><br><span class="line">            l++;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           r--;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><blockquote><p><strong>问题描述：</strong><br>有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。<br>物品：A    B    C    D    E     F    G<br>重量：35  30  60  50  40  10  25<br>价值：10  40  30  50  35  40  30</p><p><strong>问题分析：</strong></p><ol><li><strong>目标函数</strong>：<code>∑pi</code> 求和，最大，使得装入背包中的所有物品 <code>pi</code> 的价值加起来最大；</li><li><strong>约束条件</strong>：装入的物品总重量不超过背包容量：<code>∑wi &lt;= M( M=150)</code>；</li><li>贪心策略：<ul><li>选择价值最大的物品。</li><li>选择重量最小的物品。</li><li>选择单位重量价值最大的物品。</li></ul></li></ol><p>1、值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。<br>2、贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。<br>3、可惜的是，它需要证明后才能真正运用到题目的算法中。</p></blockquote><p>一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。对于背包问题中的 3 种贪心策略，都是 <strong>无法成立（无法被证明）</strong> 的，解释如下：</p><ol><li><p><strong>选取价值最大者</strong>：W=30</p><table><thead><tr><th>物品</th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>A</td><td>28</td><td>30</td></tr><tr><td>B</td><td>12</td><td>20</td></tr><tr><td>C</td><td>12</td><td>20</td></tr></tbody></table><p>根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B和C一起，则更好。</p></li><li><p><strong>选取重量最小者</strong>：选取重量最小。它的反例与第一种策略的反例差不多。</p></li><li><p>选取单位重量价值最大者：W=30</p><table><thead><tr><th>物品</th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>A</td><td>28</td><td>28</td></tr><tr><td>B</td><td>20</td><td>20</td></tr><tr><td>C</td><td>10</td><td>10</td></tr></tbody></table></li></ol><p>根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。但是<strong>如果在条件中加一句当遇见单位价值相同的时候，优先装重量小的，这样的问题就可以解决。</strong></p><p>以下这个算法里面就是采用的贪心第三方案，一般这个方案是成功率最大的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// n：物品个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// m：背包容量</span></span><br><span class="line">    List&lt;Package&gt; p = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 输入物品的重量和价值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> value / weight * <span class="number">1.0</span>;</span><br><span class="line">        p.add(<span class="keyword">new</span> <span class="title class_">Package</span>(weight, value, average));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序默认升序，需要自定义为降序</span></span><br><span class="line">    Collections.sort(p, (pac1, pac2) -&gt; Double.compare(pac2.avg, pac1.avg));</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt;= p.get(i).weight) &#123;</span><br><span class="line">            m -= p.get(i).weight;</span><br><span class="line">            maxValue = maxValue + p.get(i).value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(maxValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Package</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;         <span class="comment">// 重量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;          <span class="comment">// 价值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> avg;         <span class="comment">// 单位价值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Package</span><span class="params">(<span class="type">int</span> weight, <span class="type">int</span> value, <span class="type">double</span> avg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight=weight;</span><br><span class="line">        <span class="built_in">this</span>.value=value;</span><br><span class="line">        <span class="built_in">this</span>.avg=avg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="购物清单（带条件的背包问题）"><a href="#购物清单（带条件的背包问题）" class="headerlink" title="购物清单（带条件的背包问题）"></a>购物清单（带条件的背包问题）</h2><p>题目链接：<a href="https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4">牛客网_HJ16 购物单</a></p><blockquote><p><strong>问题描述：</strong>王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件。</p><ul><li>主件可以没有附件，至多有 22 个附件。附件不再有从属于自己的附件。</li><li>若要购买某附件，必须先购买该附件所属的主件，且每件物品只能购买一次。</li></ul><p>王强查到了 m 件物品的价格，而他只有 n 元的预算。为了先购买重要的物品，他给每件物品规定了一个重要度，用整数 1∼5 表示。他希望在不超过预算的前提下，使满意度最大。满意度定义为所购每件物品价格与重要度乘积之和。</p><p><strong>输入描述</strong>：第一行输入两个整数 n,m代表预算、查询到的物品总数。<br>此后 m 行，第 i 行输入三个整数 vi, wi, qi 分别代表价格、重要度、主件编号。特别地， qi = 0,代表该物品为主件，否则表示该附件从属于主件 。编号即输入顺序，从1开始。保证全部物品的价格 v 均为 10 的倍数；且每个主件的附件数不超过 2 个。</p><p><strong>输出描述</strong>：在一行上输出一个整数，代表王强可获得的最大满意度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">50 5</span><br><span class="line">20 3 5</span><br><span class="line">20 3 5</span><br><span class="line">10 3 0</span><br><span class="line">10 2 0</span><br><span class="line">10 1 0</span><br><span class="line">输出 130</span><br><span class="line">说明：在这个样例中，第三、四、五件物品为主件，第一、二件物品为第五件物品的附件。这就意味着，如果购买了第一件物品或第二件物品，则必须购买第五件物品；但是特别地，如果同时购买了第一件物品和第二件物品，则只需要购买一次第五件物品。</span><br><span class="line">我们可以证明，购买一、二、五件商品，获得的满意度最大，为 20×3+20×3+10×1=130。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// 预算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// 物品数</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span> || m &lt;= <span class="number">0</span>) System.out.println(<span class="number">0</span>);</span><br><span class="line">    Package[] p = <span class="keyword">new</span> <span class="title class_">Package</span>[m + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[][] appendix =  <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][<span class="number">2</span>]; <span class="comment">// 附件 最多2个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123; <span class="comment">// 输入物品 价格、重要度、主件编号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// weight</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wi</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// value</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">qi</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        p[i] = <span class="keyword">new</span> <span class="title class_">Package</span>(vi, wi, qi);</span><br><span class="line">        <span class="keyword">if</span> (qi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (appendix[qi][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                appendix[qi][<span class="number">0</span>] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                appendix[qi][<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>]; <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">Package</span> <span class="variable">item</span> <span class="operator">=</span> p[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> p[i].vi;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> p[i].wi * vi; <span class="comment">// 只有主件</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> <span class="number">0</span>, dp2 = <span class="number">0</span>, dp3 = <span class="number">0</span>, v1 = <span class="number">0</span>, v2 = <span class="number">0</span>, v3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (appendix[i][<span class="number">0</span>] != <span class="number">0</span>) &#123; <span class="comment">// 附件1</span></span><br><span class="line">            v1 = vi + p[appendix[i][<span class="number">0</span>]].vi;</span><br><span class="line">            dp1 = dp0 + p[appendix[i][<span class="number">0</span>]].wi * p[appendix[i][<span class="number">0</span>]].vi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (appendix[i][<span class="number">1</span>] != <span class="number">0</span>) &#123; <span class="comment">// 附件2</span></span><br><span class="line">            v2 = vi + p[appendix[i][<span class="number">1</span>]].vi;</span><br><span class="line">            dp2 = dp0 + p[appendix[i][<span class="number">1</span>]].wi * p[appendix[i][<span class="number">1</span>]].vi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (appendix[i][<span class="number">0</span>] != <span class="number">0</span> &amp;&amp; appendix[i][<span class="number">1</span>] != <span class="number">0</span>) &#123; <span class="comment">// 附件1, 2</span></span><br><span class="line">            v3 = vi + p[appendix[i][<span class="number">0</span>]].vi + p[appendix[i][<span class="number">1</span>]].vi;</span><br><span class="line">            dp3 = dp0 + p[appendix[i][<span class="number">0</span>]].wi * p[appendix[i][<span class="number">0</span>]].vi + </span><br><span class="line">                p[appendix[i][<span class="number">1</span>]].wi * p[appendix[i][<span class="number">1</span>]].vi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (p[i].qi == <span class="number">0</span>) &#123; <span class="comment">// 主件</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= vi &amp;&amp; vi != <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - vi] + dp0);</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v1 &amp;&amp; v1 != <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - v1] + dp1);</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v2 &amp;&amp; v2 != <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - v2] + dp2);</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v3 &amp;&amp; v3 != <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - v3] + dp3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(dp[m][n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Package</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> vi;         <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> wi;          <span class="comment">// 重要性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> qi;      <span class="comment">// 0 为主件 否则为为从属主件parent - 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Package</span><span class="params">(<span class="type">int</span> vi, <span class="type">int</span> wi, <span class="type">int</span> qi)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vi=vi;</span><br><span class="line">        <span class="built_in">this</span>.wi=wi;</span><br><span class="line">        <span class="built_in">this</span>.qi=qi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="活动时间安排问题"><a href="#活动时间安排问题" class="headerlink" title="活动时间安排问题"></a>活动时间安排问题</h2><p><strong>问题描述</strong>：</p><p>设有 <code>n</code>个活动的集合 <code>E=&#123;1,2,…,n&#125;</code>，其中每个活动都<strong>要求使用同一资源</strong>，如：演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 i 都有一个要求使用该资源的起始时间 <code>si</code> 和一个结束时间 fi ,且 <code>si &lt; fi</code> 。<strong>要求设计程序，使得安排的活动最多</strong>。<br>注：活动结束时间从小到大排序</p><table><thead><tr><th>i</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>S[i]</td><td>1</td><td>3</td><td>0</td><td>5</td><td>3</td><td>5</td><td>6</td><td>8</td><td>8</td><td>2</td><td>12</td></tr><tr><td>f[i]</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td></tr></tbody></table><p><strong>问题分析：</strong></p><p>活动安排问题要求安排一系列争用某一公共资源的活动。贪心算法可提供一个简单、漂亮的方法，使尽可能多的活动能兼容的使用公共资源。设有 <code>n</code> 个活动的集合<code>｛0，1，2，…，n-1｝</code>，其中每个活动都要求使用同一资源，如会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 <code>i</code> 都有一个要求使用该资源的起始时间 <code>starti</code> 和一个结束时间 <code>endi</code> ，且 <code>starti &lt; endi</code>。如选择了活动 <code>i</code>，则它在半开时间区间 [starti, endi) 内占用资源。若区间 <code>[starti,endi)</code> 与区间 <code>[startj,endj)</code> 不相交，称活动 <code>i</code> 与活动 <code>j</code> 是<strong>相容的</strong>。即，当 <code>startj ≥ endi</code> 或 <code>starti ≥ endj</code> 时，活动 i 与活动 j 相容。<strong>活动安排问题就是在所给的活动集合中选出最多的不相容活动</strong>。</p><p><strong>算法设计：</strong></p><p>若被检查的 <code>活动 i</code> 的开始时间 <code>starti</code> 小于最近选择的 <code>活动 j</code> 的结束时间 <code>endj</code>，则不选择 <code>活动 i</code>，否则选择 <code>活动 i</code> 加入集合中。运用该算法解决活动安排问题的效率极高。当输入的活动已按结束时间的非减序排列，算法只需 <code>O(n)</code> 的时间安排 <code>n</code> 个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用 <code>O(nlogn)</code> 的时间重排。</p><p><strong>代码实现一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();     <span class="comment">// n：活动个数</span></span><br><span class="line">    List&lt;Active&gt; act = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 输入开始和结束</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">finish</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        act.add(<span class="keyword">new</span> <span class="title class_">Active</span>(start, finish));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将活动按活动结束时间从小到大排序</span></span><br><span class="line">    Collections.sort(act, (o1, o2) -&gt; o1.finish - o2.finish);</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// t：与各个活动的起始时间相比较</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// total：最后的活动的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//循环访问所有活动</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt;= act.get(i).start) &#123;</span><br><span class="line">            total ++;</span><br><span class="line">            t = act.get(i).finish;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(total);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Active</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> start;     <span class="comment">// 开始时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> finish;    <span class="comment">// 结束时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Active</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> finish)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start=start;</span><br><span class="line">        <span class="built_in">this</span>.finish=finish;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码实现二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">11</span>; <span class="comment">// 活动数</span></span><br><span class="line">    <span class="comment">// 将活动时间进行静态数组直接存储</span></span><br><span class="line">    <span class="type">int</span>[] s = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">12</span>&#125;; <span class="comment">// 下标从1开始,存储活动开始时间</span></span><br><span class="line">    <span class="type">int</span>[] f = &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>&#125;; <span class="comment">//下标从1开始,存储活动结束时间</span></span><br><span class="line">    <span class="type">boolean</span>[] A = <span class="keyword">new</span> <span class="title class_">boolean</span>[N + <span class="number">1</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;各活动的开始时间,结束时间分别为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + i + <span class="string">&quot;]:&quot;</span> + <span class="string">&quot;(&quot;</span> + s[i] + <span class="string">&quot;,&quot;</span> + f[i] + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    GreedySelector(N, s, f, A);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i]) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span> + i + <span class="string">&quot;]:&quot;</span> + <span class="string">&quot;(&quot;</span> + s[i] + <span class="string">&quot;,&quot;</span> + f[i] + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">GreedySelector</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] s, <span class="type">int</span>[] f, <span class="type">boolean</span>[] A)</span> &#123;</span><br><span class="line">    A[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 记录最近一次加入A中的活动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123; <span class="comment">// 依次检查活动i是否与当前已选择的活动相容</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= f[j]) &#123;</span><br><span class="line">            A[i] = <span class="literal">true</span>;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：虽然贪心算法不是一定可以得到最好的解 ，但是对于这种活动时间的问题，他却得到的总是最优解，这点可用数学归纳法证明。在这里，体现出来的贪心策略是：每一个活动时间的挑选总是选择最优的，就是刚好匹配的，这样得出的结果也就是最优的了。</p><h2 id="最小生成树（克鲁斯卡尔算法）"><a href="#最小生成树（克鲁斯卡尔算法）" class="headerlink" title="最小生成树（克鲁斯卡尔算法）"></a>最小生成树（克鲁斯卡尔算法）</h2><p>在连通网中查找最小生成树的常用方法有两个，分别称为普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法。</p><blockquote><p><strong>克鲁斯卡尔算法</strong> 查找最小生成树的方法是：将连通网中所有的边按照权值大小做升序排序，从权值最小的边开始选择，<strong>只要此边不和已选择的边一起构成环路，就可以选择它组成最小生成树</strong>。<strong>对于 <code>N</code> 个顶点的连通网，挑选出 <code>N-1</code> 条符合条件的边，这些边组成的生成树就是最小生成树</strong>。</p></blockquote><p><strong>问题描述：</strong>求一个连通无向图的最小生成树的代价（图边权值为正整数）。</p><p><strong>输入</strong>：第一行是一个整数N（1&lt;=N&lt;=20），表示有多少个图需要计算。以下有N个图，第i图的第一行是一个整数M（1&lt;=M&lt;=50），表示图的顶点数，第i图的第2行至1+M行为一个M*M的二维矩阵，其元素ai,j表示图的i顶点和j顶点的连接情况，如果ai,j=0，表示i顶点和j顶点不相连；如果ai,j&gt;0，表示i顶点和j顶点的连接权值。</p><p><strong>输出：</strong>每个用例，用一行输出对应图的最小生成树的代价。</p><p><strong>样例输入：</strong></p><blockquote><p>1<br>6<br>0 6 1 5 0 0<br>6 0 5 0 3 0<br>1 5 0 5 6 4<br>5 0 5 0 0 2<br>0 3 6 0 0 6<br>0 0 4 2 6 0</p></blockquote><p><strong>样例输出：</strong>15</p><p><strong>问题分析：</strong></p><ol><li>边的选择要求从小到大选择，则开始显然要对边进行升序排序；</li><li>选择的边是否需要，则从判断该边加入后是否构成环；</li></ol><p><strong>算法设计：</strong></p><ol><li><strong>对边进行升序排序</strong>：在此采用链式结构，通过插入排序完成。每一结点存放一条边的左右端点序号、权值及后继结点指针；</li><li><strong>边的加入后，是否会构成环</strong>：最开始假定各顶点分别为一组，其组号为端点序号。选择某边后看其两端点是否在同一组中，即所在组号是否相同，若是，表示构成了环，则舍去。若两个端点所在的组不同，则表示可以加入，则将该边两端的组合并成同一组。</li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// V是顶点数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">E</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// E是边数</span></span><br><span class="line">    Edge[] edge = <span class="keyword">new</span> <span class="title class_">Edge</span>[E]; <span class="comment">// 存储边的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">        edge[i] = <span class="keyword">new</span> <span class="title class_">Edge</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    kruskal(V, edge);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行克鲁斯卡尔算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">(<span class="type">int</span> V, Edge[] edge)</span> &#123;</span><br><span class="line">    Edge result[] = <span class="keyword">new</span> <span class="title class_">Edge</span>[V]; <span class="comment">// 存储结果的数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示result数组中的下标</span></span><br><span class="line">    Arrays.sort(edge);  <span class="comment">// 将边按照权重从小到大排序</span></span><br><span class="line">    Subset subsets[] = <span class="keyword">new</span> <span class="title class_">Subset</span>[V]; <span class="comment">// 创建V个子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; ++i) &#123; <span class="comment">// 初始化每个子集的父节点和秩</span></span><br><span class="line">        subsets[i] = <span class="keyword">new</span> <span class="title class_">Subset</span>(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取E-1条边</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (e &lt; V - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">Edge</span> <span class="variable">next_edge</span> <span class="operator">=</span> edge[i++];</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> findParentNode(subsets, next_edge.src);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> findParentNode(subsets, next_edge.dest);</span><br><span class="line">        <span class="comment">// 如果两个节点不在同一个集合中，合并它们</span></span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            result[e++] = next_edge;</span><br><span class="line">            unionSubsets(subsets, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Following are the edges in the constructed MST&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e; ++i)&#123;</span><br><span class="line">        System.out.println(result[i].src + <span class="string">&quot; - &quot;</span> + result[i].dest + <span class="string">&quot; - &quot;</span> + result[i].weight);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找父节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findParentNode</span><span class="params">(Subset subsets[], <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (subsets[i].parent != i)</span><br><span class="line">        subsets[i].parent = findParentNode(subsets, subsets[i].parent);</span><br><span class="line">    <span class="keyword">return</span> subsets[i].parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个子集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unionSubsets</span><span class="params">(Subset subsets[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xroot</span> <span class="operator">=</span> findParentNode(subsets, x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yroot</span> <span class="operator">=</span> findParentNode(subsets, y);</span><br><span class="line">    <span class="keyword">if</span> (subsets[xroot].rank &lt; subsets[yroot].rank)&#123;</span><br><span class="line">        subsets[xroot].parent = yroot;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subsets[xroot].rank &gt; subsets[yroot].rank) &#123;</span><br><span class="line">        subsets[yroot].parent = xroot;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subsets[yroot].parent = xroot;</span><br><span class="line">        subsets[xroot].rank++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义边的数据结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Edge&gt; &#123;</span><br><span class="line">    <span class="type">int</span> src, dest, weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Edge edge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - edge.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集数据结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Subset</span> &#123;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    <span class="type">int</span> rank;</span><br><span class="line">    Subset(<span class="type">int</span> parent, <span class="type">int</span> rank) &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent=parent;</span><br><span class="line">        <span class="built_in">this</span>.rank=rank;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------------------- 无用 --------------------------</span></span><br><span class="line"><span class="comment">// 定义一个辅助函数，用于查找结点所在的集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[i] == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> findNode(parent, parent[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个辅助函数，用于合并两个集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unionNode</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xset</span> <span class="operator">=</span> findNode(parent, x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yset</span> <span class="operator">=</span> findNode(parent, y);</span><br><span class="line">    parent[xset] = yset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段覆盖（Lines-cover）"><a href="#线段覆盖（Lines-cover）" class="headerlink" title="线段覆盖（Lines cover）"></a>线段覆盖（Lines cover）</h2><p><strong>问题描述：</strong>在一维空间中告诉你N条线段的起始坐标与终止坐标，要求求出这些线段一共覆盖了多大的长度。</p><p><strong>解题思路：</strong>上述的表格中的数据代表10条线段的起始点和终点，对他们的起始点从小到大按顺序排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] start = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;  <span class="comment">// 起始点</span></span><br><span class="line">    <span class="type">int</span>[] end = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>&#125;; <span class="comment">// 终点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total_len</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">//至少的长度为：3-2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start[i] &gt;= end[j]) &#123; <span class="comment">// 不相交</span></span><br><span class="line">            total_len = total_len + end[i] - start[i];</span><br><span class="line">            j = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (end[i] &lt;= end[j]) &#123; <span class="comment">// 重叠</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 相交</span></span><br><span class="line">                total_len = total_len + end[i] - end[j];</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(total_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数字组合问题"><a href="#数字组合问题" class="headerlink" title="数字组合问题"></a>数字组合问题</h2><p><strong>问题描述</strong>：设有N个正整数，现在需要你设计一个程序，使他们连接在一起成为最大的数字。</p><p><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">12 456 342</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：45634212</p><p><strong>程序要求</strong>：输入整数N 接下来一行输入N个数字，最后一行输出最大的那个数字。</p><p><strong>题目解析</strong>：</p><ol><li><p>首先想到如何使两个数连接在一起最大，例如 12 和 456 ，连接在一起有两种情况分别为 12456 和 45612 ，显然后者比前者大。</p></li><li><p>如果是多个正整数连在一起，我们则需要对元素进行比较，很显然这是一个排序的过程，而且 需要相邻的元素两两比较，由此可以想到 <code>冒泡排序</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用冒泡排序来实现升序序列</span></span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// 开始冒泡排序 总共排序轮数为：元素个数 - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 内层对比循环 次数 = 元素个数 - 排序轮数 - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果第一个数字比第二个数字大，实现交换这两个数字</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>若有四个数字：456、12、342、78<br>1、先进行比较 456 和 12，发现 45612 比 12456 更大，此时交换两个数字的位置：12、456、342、78<br>2、再进行比较 456 和 342，发现 456342 比 342456 更大，再次进行位置的交换：12、342、456、78<br>3、在进行比较 456 和 78，发现 78456 比 45678 更大，无需进行交换；<br>4、最后顺序：12 、342 、456 、78</p><p>分析到这其实发现要想连接到一起的数字最大，其实需要排序的是每个数字的第一位，最终每个数字的第一位排序得到： <code>1,3,4,7;</code></p><p><strong>综上所述，解题思路：就是在相邻两个正整数连接起来比较大小的基础上再对所有数字冒泡排序，即可完成题目要求</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        arr[i] = scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; num - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//如果 arr[j] 大于 arr[j+1]，则交换，否则，不交换</span></span><br><span class="line">            <span class="keyword">if</span>(compare(arr[j], arr[j+<span class="number">1</span>])) &#123;</span><br><span class="line">                 <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                 arr[j]   = arr[j+<span class="number">1</span>];</span><br><span class="line">                 arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">               <span class="comment">// Collections.swap(list, i, j); //交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        System.out.print(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义排序  num1：:12，num2：456</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nm1</span> <span class="operator">=</span> num1, nm2 = num2;</span><br><span class="line">    <span class="keyword">while</span> (nm1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count1++;   <span class="comment">//用来得到 num1 的位数：2</span></span><br><span class="line">        nm1 /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (nm2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count2++;   <span class="comment">//用来得到 num2 的位数：3</span></span><br><span class="line">        nm2 /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Math.pow(a, b)：求 a 的 b 次方，这里用作将两个数连接起来进行下一步的比较</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> num1 * Math.pow(<span class="number">10.0</span>, count2) + num2; <span class="comment">// 表示组合数：num1 num2：12  * 1000 + 456 = 12456</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> num2 * Math.pow(<span class="number">10.0</span>, count1) + num1; <span class="comment">// 表示组合数：num2 num1：456 * 100  + 12  = 45612</span></span><br><span class="line">    <span class="keyword">return</span> Double.compare(a, b) == <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// true表示组合数(num1 num2)大于组合数(num2 num1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拼数"><a href="#拼数" class="headerlink" title="拼数"></a>拼数</h2><p>题目链接：<a href="https://ac.nowcoder.com/acm/problem/16783">牛客网_拼数</a></p><blockquote><p><strong>描述</strong>：设有n个正整数（n ≤ 20），将它们联接成一排，组成一个最大的多位整数。例如：n=3时，3个整数13，312，343联接成的最大整数为：34331213。又如：n=4时，4个整数7，13，4，246联接成的最大整数为：7424613<br><strong>输入描述</strong>：第一行，一个正整数n。第二行，n个正整数。<br><strong>输出描述</strong>: 一个正整数，表示最大的整数</p><p><strong>示例1</strong><br><strong>输入：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">13 312 343</span><br></pre></td></tr></table></figure><p><strong>输出：</strong>34331213</p><p><strong>示例2</strong><br><strong>输入：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">921650139 925571586 931563581 923960668 870548039 358493469 371229218 737101511 514654859 185379933 19421244 117259400 301947570 48520742 79303948 222979736 153546206 250582036 106394401 198125223</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">931563581925571586923960668921650139870548039793039487371015115146548594852074237122921835849346930194757025058203622297973619812522319421244185379933153546206117259400106394401</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p>先把<strong>整数化成字符串</strong>，然后再比较<strong>a+b和b+a</strong>，如果<strong>a+b&gt;b+a，就把a排在b的前面，反之则把a排在b的后面，最后输出排序后的字符串，即可得到最大的整数</strong>（如果求最小的整数，则从小到大排序）。</p><p><strong>举例说明：a=‘123’，b=‘71’，a+b=’12371’，b+a=‘71123’，所以a+b&lt;b+a，将b排在前面** 注意：正常的字符串存在比较缺陷，**如：A=’321’，B=’32’，按照标准的字符串比较规则因为A&gt;B，所以A+B &gt; B+A ，而实际上’32132’ &lt; ’32321’。</strong> 具体步骤如下：</p><ol><li>获取n   </li><li>依次获取n个正整数，<strong>将整数转换为字符串</strong>：声明字符串数组a[n]，将获取到的正整数存入数组a中，即可实现正整数到字符串的转换  </li><li><strong>自定义排序函数：</strong>若a+b &gt; b+a，则把a排在前面，否则将b排在前面（对字符串a、b，a+b表示连接两个字符串形成一个新串）</li><li><strong>从大到小输出排序后的字符串</strong>即可得到最大的整数</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">    sc.nextLine();</span><br><span class="line">    String[] strArray = sc.nextLine().split(<span class="string">&quot; &quot;</span>); <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 自定义排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>; m &lt; n-<span class="number">1</span>-k; m++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!sortStr(strArray[m], strArray[m + <span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> strArray[m];</span><br><span class="line">                strArray[m] = strArray[m + <span class="number">1</span>];</span><br><span class="line">                strArray[m + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">        System.out.print(strArray[i]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序函数实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">sortStr</span><span class="params">(String str1,String str2)</span>&#123;</span><br><span class="line">    <span class="type">char</span>[] char1 = (str1 + str2).toCharArray();</span><br><span class="line">    <span class="type">char</span>[] char2 = (str2 + str1).toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; char1.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(char1[i] &gt; char2[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(char1[i] &lt; char2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找零钱问题"><a href="#找零钱问题" class="headerlink" title="找零钱问题"></a>找零钱问题</h2><p>在贪心算法里面最常见的莫过于找零钱的问题了。</p><p><strong>问题描述</strong>：对于人民币的面值有1元 、5元 、10元 、20元 、50元 、100元，下面要求设计一个程序，输入找零的钱，输出找钱方案中最少张数的方案，比如： 123元，最少是 1 张100 的，1 张 20 的，3 张 1 元的，一共5张。</p><p><strong>问题解析</strong>：运用的贪心策略是每次选择最大的钱，如果最后超过了，再选择次大的面值，然后次次大的面值，一直到最后与找的钱相等。</p><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> scanner.nextInt();                  <span class="comment">// money：需要的交换的钱数</span></span><br><span class="line">    <span class="type">int</span>[] moneyClass = &#123;<span class="number">100</span>,<span class="number">50</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;          <span class="comment">// 记录钱的面值</span></span><br><span class="line">    <span class="type">int</span>[] moneyNum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];                    <span class="comment">// 记录各种面值的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">moneyCount</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= moneyClass.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (moneyCount + moneyClass[i] &gt; money) &#123;   <span class="comment">// 如果需要的钱数小于最大的面值</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;                               <span class="comment">// 换用更小的面值，继续去判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        moneyCount += moneyClass[i];</span><br><span class="line">        moneyNum[i] ++;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">while</span> (moneyCount == money) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;一共需要：&quot;</span> + count + <span class="string">&quot;张纸钱。&quot;</span> );</span><br><span class="line">    <span class="comment">// 输出张数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (moneyNum[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: System.out.println(<span class="string">&quot;面值为100的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: System.out.println(<span class="string">&quot;面值为50的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: System.out.println(<span class="string">&quot;面值为20的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: System.out.println(<span class="string">&quot;面值为10的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>: System.out.println(<span class="string">&quot;面值为5的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>: System.out.println(<span class="string">&quot;面值为1的有：&quot;</span> + moneyNum[i] + <span class="string">&quot;张&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最好时机-二"><a href="#买卖股票的最好时机-二" class="headerlink" title="买卖股票的最好时机(二)"></a>买卖股票的最好时机(二)</h2><p>题目链接：<a href="https://www.nowcoder.com/practice/fbc5dad3e215457fb82a3ae688eb7281?tpld=230&tpld=39768&ru=/exam/oj">牛客网_买卖股票的最好时机(二)</a></p><blockquote><p><strong>描述</strong>：假设数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益</p><ol><li>可以多次买卖该只股票，但是再次购买前必须卖出之前的股票</li><li>如果不能获取收益，请返回0</li><li>假设买入卖出均无手续费</li></ol><p><strong>输入描述</strong>：<br>第一行输入一个正整数 n ，表示数组 prices 的长度<br>第二行输入 n 个正整数，表示数组中prices的值<br><strong>输出描述</strong>：输出最大收益</p><p><strong>示例1</strong><br><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">&gt;8 9 2 5 4 7 1</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：7<br><strong>说明</strong>：<br>在第1天(股票价格=8)买入，第2天(股票价格=9)卖出，获利9-8=1<br>在第3天(股票价格=2)买入，第4天(股票价格=5)卖出，获利5-2=3<br>在第5天(股票价格=4)买入，第6天(股票价格=7)卖出，获利7-4=3<br>总获利1+3+3=7，返回7  </p><p><strong>示例2</strong><br><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">&gt;5 4 3 2 1</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：0<br><strong>说明</strong>：由于每天股票都在跌，因此不进行任何交易最优。最大收益为0。</p><p><strong>示例3</strong><br><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">&gt;1 2 3 4 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：4<br><strong>说明</strong>：第一天买进，最后一天卖出最优。中间的当天买进当天卖出不影响最终结果。最大收益为4。</p><p><strong>思路</strong>： 只要当天价格比上一天价格大，就累加，然后算出最大利润即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span>[] prices = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        prices[i] = in.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>]) &#123; <span class="comment">// 如果任何一天比前一天价格高，就在前一天买入今天卖</span></span><br><span class="line">            sum += (prices[i]-prices[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &lt; prices[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            total += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组队竞赛"><a href="#组队竞赛" class="headerlink" title="组队竞赛"></a>组队竞赛</h2><p>题目链接：<a href="https://www.nowcoder.com/questionTerminal/6736cc3ffd1444a4a0057dee89be789b">牛客网_组队竞赛</a></p><blockquote><p><strong>描述</strong>：牛牛举办了一次编程比赛，参加比赛的有3*n个选手，每个选手都有一个水平值a_i。现在要将这些选手进行组队，一共组成n个队伍，即每个队伍3人。牛牛发现队伍的水平值等于该队伍队员中第二高水平值。例如:<br>一个队伍三个队员的水平值分别是3，3，3。那么队伍的水平值是3<br>一个队伍三个队员的水平值分别是3，2，3。那么队伍的水平值是3<br>一个队伍三个队员的水平值分别是1，5，2。那么队伍的水平值是2<br>为了让比赛更有看点，牛牛想安排队伍使所有队伍的水平值总和最大。<br>如样例所示：如果牛牛把6个队员划分到两个队伍<br>如果方案为：team1:{1,2,5}, team2:{5,5,8}, 这时候水平值总和为7.<br>而如果方案为：team1:{2,5,8}, team2:{1,5,5}, 这时候水平值总和为10.<br>没有比总和为10更大的方案,所以输出10.<br><strong>输入描述：</strong>输入的第一行为一个正整数n(1 ≤ n ≤ 10^5)。第二行包括3*n个整数a_i(1 ≤ a_i ≤ 10^9),表示每个参赛选手的水平值。<br><strong>输出描述：</strong>输出一个整数表示所有队伍的水平值总和最大值</p><p><strong>示例1</strong><br><strong>输入：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 2 8 5 1 5</span><br></pre></td></tr></table></figure><p><strong>输出：</strong>10</p><p><strong>思路</strong>：先排序，比如排完序 1 2 3 4 5 6 7 8 9 这九个数；组队思路是这样的，第一个最后两个（1 8 9），剩下 2 3 4 5 6 7，第一个最后两个（2 6 7），剩下3 4 5一组。就是第一个和最后两个，再把已经组队的删掉，然后再循环，第一个最后两个。那么中位数可以看到是 8 6 4，找到中位数在整个排序后的素组和下标的规则是 data[data.length-(2*(i+1))]，再加在一起。最重要的是 result一定要是long，int会越界。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();;</span><br><span class="line">    <span class="type">long</span>[] data = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">3</span> * n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length ; i++) &#123;</span><br><span class="line">        data[i] = scanner.nextLong();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(data); <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result += data[data.length - (<span class="number">2</span> * (i + <span class="number">1</span>))];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">    ArrayList&lt;Long&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Long&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>*n; i++) &#123;</span><br><span class="line">        arr.add(scan.nextLong());</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(arr);</span><br><span class="line">    list = arr.subList(n,<span class="number">3</span>*n);</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            sum += list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p>题目链接：<a href="https://leetcode.cn/problems/merge-intervals/description/">LeetCode_56. 合并区间 </a></p><p><strong>贪心策略:</strong></p><ul><li>先按照区间的「左端点」排序:此时我们会发现，能够合并的区间都是连续的，b.然后从左往后，按照求「并集」的方式，合并区间。</li></ul><p><strong>如何求并集:</strong> 由于区间已经按照「左端点」排过序了，因此当两个区间「合并」的时候，合并后的区间：</p><ol><li>左端点就是「前一个区间」的左端点;</li><li>右端点就是两者「右端点的最大值」。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));  <span class="comment">// 升序排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &gt;= intervals[i+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">            intervals[i+<span class="number">1</span>][<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            intervals[i+<span class="number">1</span>][<span class="number">1</span>] = Math.max(intervals[i][<span class="number">1</span>], intervals[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.add(intervals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个对比完记得加入result数组中</span></span><br><span class="line">    result.add(intervals[intervals.length - <span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span>[][] reIntervals = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">        reIntervals[i] = result.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reIntervals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非重叠区间"><a href="#非重叠区间" class="headerlink" title="非重叠区间"></a>非重叠区间</h3><p>题目链接：<a href="https://leetcode.cn/problems/non-overlapping-intervals/description/">LeetCode_435. 无重叠区间</a></p><p><strong>贪心策略:</strong></p><ol><li>按照「左端点」排序;</li><li>当两个区间「重叠」的时候，为了能够「在移除某个区间后，保留更多的区间」，我们应该把「区间范围较大」的区间移除。</li></ol><p>如何移除区间范围较大的区间：由于已经按照「左端点」排序了，因此两个区间重叠的时候，应该移除「右端点较大」的区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">    Arrays.sort(intervals, (a,b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>])); <span class="comment">// 升序排列</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 统计需要移除的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &gt; intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123; <span class="comment">// 代表存在重复</span></span><br><span class="line">            count++;</span><br><span class="line">            intervals[i+<span class="number">1</span>][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>], intervals[i + <span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// 修改下一段区间起点位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重叠区间数量"><a href="#重叠区间数量" class="headerlink" title="重叠区间数量"></a>重叠区间数量</h3><p>题目链接：<a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">LeetCode_452. 用最少数量的箭引爆气球</a></p><p><strong>贪心策略:</strong></p><ul><li>按照左端点排序，我们发现，排序后有这样一个性质:「互相重叠的区间都是连续的」;</li><li>这样，我们在射箭的时候，要发挥每一支箭「最大的作用」，应该把「互相重叠的区间」统一引爆。</li></ul><p><strong>如何求互相重叠区间?</strong></p><p>由于我们是按照「左端点」排序的，因此对于两个区间，我们求的是它们的「交集」:</p><ol><li>左端点为两个区间左端点的「最大值」(但是左端点不会影响我们的合并结果，所以可以忽略)</li><li>右端点为两个区间右端点的「最小值」。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以用 合并区间的代码，只需要改三个字母即可，其中要注意安全比较</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> merge(points); <span class="comment">// 返回列表大小即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123; <span class="comment">// 合并区间代码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>])); <span class="comment">// 安全比较</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>],R = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(merged.size() == <span class="number">0</span> || merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L)&#123;</span><br><span class="line">            merged.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L,R&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 注意就是这里，把max换成min即可</span></span><br><span class="line">            merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.min(merged.get(merged.size() -<span class="number">1</span>)[<span class="number">1</span>],R);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间套娃"><a href="#区间套娃" class="headerlink" title="区间套娃"></a>区间套娃</h3><p>题目链接：<a href="https://leetcode.cn/problems/russian-doll-envelopes/description/">Leetcode_354. 俄罗斯套娃信封问题</a></p><p><strong>思路：重写排序 + 贪心 + 二分</strong></p><p>当我们把整个信封按照「下面的规则」排序之后:</p><ol><li>左端点不同的时候:按照「左端点从小到大」排序;</li><li>左端点相同的时候:按照「右端点从大到小」排序</li></ol><p>此时问题就变成了仅考虑信封的「右端点」，完全变成「最长上升子序列」模型。就可以用「贪心+二分」优化算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先按长排序, 然后按照O(N^2)的最长递增子序列的思想来做</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEnvelopes</span><span class="params">(<span class="type">int</span>[][] envelopes)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> envelopes.length;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    Arrays.sort(envelopes, (a,b) -&gt; (a[<span class="number">0</span>]-b[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(envelopes[i][<span class="number">0</span>] &gt; envelopes[j][<span class="number">0</span>] &amp;&amp; envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>])</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(NlogN)的做法, 按照长度升序, 同长则宽度降序排列, 然后使用O(logN)的最长递增子序列解法(链接在评论中)来做即可. 排序后等于把在二维(长、宽)上的最长递增子序列问题转换成一维(宽)上的最长递增子序列的查找, 因为对于长度来说已经满足递增, 只需要在宽度上也递增即为递增序列, 同长时按宽度降序排列的原因是避免同长时宽度小的也被列入递增序列中, 例如[3,3], [3,4],如果宽度也按升序来排列, [3,3]和[3,4]会形成递增序列, 而实际上不行.</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEnvelopes</span><span class="params">(<span class="type">int</span>[][] envelopes)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[envelopes.length];</span><br><span class="line">    Arrays.sort(envelopes, (a, b) -&gt; (a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] - a[<span class="number">1</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] env : envelopes) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = maxL;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[mid] &lt; env[<span class="number">1</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[lo] = env[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(lo == maxL) maxL++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整数问题"><a href="#整数问题" class="headerlink" title="整数问题"></a>整数问题</h2><h3 id="坏了的计算器"><a href="#坏了的计算器" class="headerlink" title="坏了的计算器"></a>坏了的计算器</h3><p>题目链接：<a href="https://leetcode.cn/problems/broken-calculator/description/">LeetCode_991. 坏了的计算器 </a></p><p><strong>贪心策略：【正难则反】</strong></p><p>当「反着」来思考的时候，我们发现</p><ol><li>当 end&lt;= begin 的时候，只能执行「加法」操作;</li><li>当 end &gt; begin 的时候，对于「奇数」来说，只能执行「加法」操作;对于「偶数」来说，最好的方式就是执行「除法」操作</li></ol><p>这样的话，每次的操作都是「固定唯一」的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">brokenCalc</span><span class="params">(<span class="type">int</span> startValue, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(startValue &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">return</span> startValue - target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + brokenCalc(startValue, target / <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + brokenCalc(startValue, target + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数替换"><a href="#整数替换" class="headerlink" title="整数替换"></a>整数替换</h3><p>题目链接：<a href="https://leetcode.cn/problems/integer-replacement/description/">LeetCode_397. 整数替换</a></p><p><strong>贪心策略:</strong>  我们的任何选择，应该让这个数尽可能快的变成1</p><p>对于偶数：只能执行除 2操作，没有什么分析的;</p><p>对于奇数：    </p><ul><li>当 n == 1 的时候，不用执行任何操作;</li><li>当 n == 3 的时候，变成 1 的最优操作数是 2;</li><li>当 n &gt; 1 &amp;&amp; n%4 == 1 的时候，那么它的二进制表示是……01，最优的方式应该选择 -1，这样就可以把末尾的1干掉，接下来执行除法操作，能够更快的变成</li><li>当 n &gt; 3 &amp;&amp; n%4 == 3 的时候，那么它的二进制表示是……11，此时最优的策略应该是 +1，这样可以把一堆连续的1转换成 0，更快的变成 1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerReplacement</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>)func((<span class="type">long</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">func</span><span class="params">(<span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> + func(n / <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>  &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> + Math.min(func(n + <span class="number">1</span>), func(n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可被三整除的最大和"><a href="#可被三整除的最大和" class="headerlink" title="可被三整除的最大和"></a>可被三整除的最大和</h3><p>题目链接：<a href="https://leetcode.cn/problems/greatest-sum-divisible-by-three/description/">LeetCode_1262. 可被三整除的最大和</a></p><p><strong>思路</strong>：正难则反 + 贪心 + 分类讨论</p><p><strong>正难则反：</strong>可以先把所有的数累加在一起，然后根据累加和的结果，贪心的删除一些数。</p><p><strong>分类讨论：</strong>设累加和为 sum，用 x 标记 %3 == 1 的数，用 y 标记 %3 == 2 的数。那么根据 sum 的余数，可以分为下面三种情况:</p><ol><li><p>sum %3 == 0，此时所有元素的和就是满足要求的，那么我们一个也不用删除;，</p></li><li><p>sum %3 == 1，此时数组中要么存在一个 x，要么存在两个 y。因为我们要的是最大值，所以应该选择 x 中最小的那么数，记为x1，或者是y 中最小以及次小的两个数，记为 y1，y2。    </p><p>那么，我们应该选择两种情况下的最大值：max(sum-x1，sum - y1 -y2）；</p></li><li><p>sum %3 == 2，此时数组中要么存在一个 y，要么存在两个 x。因为我们要的是最大值，所以应该选择 y 中最小的那么数，记为y1，或者是x 中最小以及次小的两个数，记为 x1，x2。    </p><p>那么，我们应该选择两种情况下的最大值：max(sum-y1，sum - x1 -x2）；</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumDivThree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>]; <span class="comment">// dp[i][j]表示前i个数，模3=j时的最大值</span></span><br><span class="line">    dp[<span class="number">0</span>][nums[<span class="number">0</span>] % <span class="number">3</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//先将上一个状态转移过来</span></span><br><span class="line">            dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            <span class="comment">//转移每个模3=j的数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j] + nums[i];</span><br><span class="line">            dp[i][sum % <span class="number">3</span>] = Math.max(dp[i][sum % <span class="number">3</span>],sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h3><p>题目链接：<a href="https://leetcode.cn/problems/monotone-increasing-digits/submissions/650566325/">LeetCode_738. 单调递增的数字</a></p><p><strong>解法(贪心)</strong></p><ol><li>为了方便处理数中的每一位数字，可以先讲整数转换成字符串</li><li>从左往右扫描，找到第一个递减的位置</li><li>从这个位置向前推，推到相同区域的最左端</li><li>该点的值 -1，后面的所有数统一变成 9</li></ol><p><strong>思路</strong>：从右向左扫描数字，若发现当前数字比其左边一位（较高位）小， 则把其左边一位数字减1，并将该位及其右边的所有位改成9</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[i] &lt; chars[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            flag = i;</span><br><span class="line">            chars[i - <span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> flag; i &lt; length; i++) &#123;</span><br><span class="line">        chars[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(chars));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><h3 id="排列数字使相邻数字不等"><a href="#排列数字使相邻数字不等" class="headerlink" title="排列数字使相邻数字不等"></a>排列数字使相邻数字不等</h3><p>题目链接：<a href="https://leetcode.cn/problems/distant-barcodes/description/">LeetCode_1054. 距离相等的条形码 </a></p><p><strong>贪心策略:</strong></p><ol><li>每次处理一批相同的数字，往n个空里面摆放;</li><li>每次摆放的时候，隔一个格子摆放一个数;</li><li>优先处理出现次数最多的那个数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] rearrangeBarcodes(<span class="type">int</span>[] barcodes) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> barcodes.length,temp;</span><br><span class="line">    <span class="comment">// 从左边开始找到相邻条形码相同，将后一个条形码与后面不同的条形码交换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(barcodes[i] == barcodes[i-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(barcodes[j] != barcodes[i])&#123;</span><br><span class="line">                    swap(barcodes,i,j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右边再来一次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(barcodes[i] == barcodes[i + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(barcodes[j] != barcodes[i])&#123;</span><br><span class="line">                    swap(barcodes,i,j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从左边不能保证[2,1,1]、[2,3,1,1,1]，从右边不能保证[1,1,2]等，但左右都来一次就能保证结果满足      </span></span><br><span class="line">    <span class="keyword">return</span> barcodes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] barcodes, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> barcodes[i];</span><br><span class="line">    barcodes[i] = barcodes[j];</span><br><span class="line">    barcodes[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排列字符串使相邻字符不等"><a href="#排列字符串使相邻字符不等" class="headerlink" title="排列字符串使相邻字符不等"></a>排列字符串使相邻字符不等</h3><p>题目链接：<a href="https://leetcode.cn/problems/reorganize-string/description/">LeetCode_767. 重构字符串</a></p><p>Java大根堆，每次取出现频率最多的2个字符组合，重点对于剩1个元素时情况的讨论</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reorganizeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        cnt[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1,o2) -&gt; (o2[<span class="number">1</span>]-o1[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i] != <span class="number">0</span>) pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i,cnt[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> !pq.isEmpty();</span><br><span class="line">    <span class="keyword">if</span> (pq.peek()[<span class="number">1</span>] &gt; n/<span class="number">2</span> + <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span>[] a = pq.poll(), b = pq.poll();</span><br><span class="line">        <span class="keyword">assert</span> b != <span class="literal">null</span>;</span><br><span class="line">        sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span>+a[<span class="number">0</span>]));</span><br><span class="line">        sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span>+b[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">if</span> (--a[<span class="number">1</span>] &gt; <span class="number">0</span>) pq.add(a);</span><br><span class="line">        <span class="keyword">if</span> (--b[<span class="number">1</span>] &gt; <span class="number">0</span>) pq.add(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pq.isEmpty()) <span class="keyword">return</span> sb.toString();</span><br><span class="line">    <span class="keyword">if</span> (pq.peek()[<span class="number">1</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span>+pq.peek()[<span class="number">0</span>])).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="行驶问题"><a href="#行驶问题" class="headerlink" title="行驶问题"></a>行驶问题</h2><h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><p>题目链接：<a href="https://leetcode.cn/problems/gas-station/description/">LeetCode_134. 加油站 </a></p><p><strong>暴力解法:</strong></p><ul><li>依次枚举所有的起点:</li><li>从起点开始，模拟一遍加油的流程</li></ul><p><strong>贪心优化:</strong></p><ul><li>当从 i位置出发，走了 step 步之后，如果失败了。那么[i，i+ step]这个区间内任意一个位置作为起点，都不可能环绕一圈。</li><li>因此我们枚举的下一个起点，应该是 i + step + 1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 只要sumOfCost &lt;= sumOfGas 就代表者一定是可以到达的</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>, minBalance = <span class="number">0</span>; <span class="comment">// 具体从哪里出发的话就是从欠债最多的那个加油站就可以的</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class="line">       balance += gas[i] - cost[i];</span><br><span class="line">       <span class="keyword">if</span> (balance &lt; minBalance) &#123;</span><br><span class="line">           minBalance = balance;</span><br><span class="line">           minIndex = i + <span class="number">1</span>; <span class="comment">// 这里是问的第几个加油站</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> balance &gt;= <span class="number">0</span> ? minIndex : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列问题"><a href="#序列问题" class="headerlink" title="序列问题"></a>序列问题</h2><h3 id="递增的三元子序列"><a href="#递增的三元子序列" class="headerlink" title="递增的三元子序列"></a>递增的三元子序列</h3><p>题目链接：<a href="https://leetcode.cn/problems/increasing-triplet-subsequence/description/">LeetCode_334. 递增的三元子序列</a></p><p><strong>贪心策略:</strong></p><ul><li>最长递增子序列的简化版。</li><li>不用一个数组存数据，仅需两个变量即可。也不用二分插入位置，仅需两次比较就可以找到插入位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">increasingTriplet</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2147483647</span>, b = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n: nums) </span><br><span class="line">        <span class="keyword">if</span> (n &lt;= a) a = n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= b) b = n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>题目链接：<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://leetcode.cn/problems/longest-increasing-subsequence/&objectId=2527732&objectType=1&isNewArticle=undefined">LeetCode_300. 最长递增子序列</a></p><p><strong>贪心策略:</strong></p><ul><li>在考虑最长递增子序列的长度的时候，其实并不关心这个序列长什么样子，我们只是关心最后一个元素是谁。</li><li>这样新来一个元素之后，我们就可以判断是否可以拼接到它的后面。</li><li>因此，我们可以创建一个数组，统计长度为 x的递增子序列中，最后一个元素是谁。</li><li>为了尽可能的让这个序列更长，我们仅需统计长度为 x的所有递增序列中最后一个元素的「最小值」。</li><li>统计的过程中发现，数组中的数呈现「递增」趋势，因此可以使用「二分」来查找插入位置。</li></ul><p><strong>思路</strong>：</p><p>dp[i]: 所有长度为i+1的递增子序列中, 最小的那个序列尾数。由定义知dp数组必然是一个递增数组, 可以用 maxL 来表示最长递增子序列的长度。对数组进行迭代, 依次判断每个数num将其插入dp数组相应的位置:</p><ol><li>num &gt; dp[maxL], 表示num比所有已知递增序列的尾数都大, 将num添加入dp数组尾部, 并将最长递增序列长度maxL加1</li><li>dp[i - 1] &lt; num &lt;= dp[i], 只更新相应的dp[i]</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;  <span class="comment">// 二分法查找, 也可以调用库函数如binary_search</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = maxL;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid] &lt; num) &#123;</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hi = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[lo] = num;</span><br><span class="line">            <span class="keyword">if</span>(lo == maxL) &#123;</span><br><span class="line">                maxL++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;贪心算法是一种在每一步选择中都采取当前状态下最优（即最有利）的选择，从而希望导致结果是全局最优的算法策略。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_67868534/art</summary>
      
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>动态规划算法</title>
    <link href="https://southernfish.github.io/pages/algorithm/dynamic-programming/"/>
    <id>https://southernfish.github.io/pages/algorithm/dynamic-programming/</id>
    <published>2025-08-02T06:20:36.000Z</published>
    <updated>2025-09-20T11:18:48.136Z</updated>
    
    <content type="html"><![CDATA[<p>滑动窗口算法可以将嵌套的循环问题，转换为单循环问题，降低<a href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1001.2101.3001.7020">时间复杂度</a>。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/m0_46208463/article/details/141429458">【算法】动态规划</a></p><p><a href="https://blog.csdn.net/qq_43466788/article/details/109628158">【算法】备忘录法（记忆化搜索）</a></p><p><a href="https://blog.csdn.net/qq_43466788/article/details/109627650">【算法】动态规划（Dynamic Programming）</a></p></blockquote><h1 id="动态规划详解"><a href="#动态规划详解" class="headerlink" title="动态规划详解"></a>动态规划详解</h1><p>动态规划（Dynamic Programming，简称DP）是一种广泛应用于数学、计算机科学和经济学等领域的方法论。其核心思想是通过将复杂问题分解为相对简单的子问题，并存储子问题的解以避免冗余计算，从而显著提高计算效率。</p><p>动态规划作为运筹学的一个分支，专注于解决决策过程的最优化问题。20世纪50年代初，美国数学家贝尔曼（R. Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，并基于此创立了动态规划。动态规划的应用范围极为广泛，包括工程技术、经济、工业生产、军事以及自动化控制等多个领域。在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等实际问题中，动态规划均展现出了显著的效果。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>动态规划常常适用于具有重叠子问题和最优子结构性质的问题。其基本思想是将待求解的问题分解为若干个相关联的子问题，先求解子问题，然后利用这些子问题的解来构造原问题的解。对于重复出现的子问题，只在第一次遇到的时候对他进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。</p><p><strong>总体思想</strong><br>（1）动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题<br>（2）经分解得到的子问题往往不是互相独立的，有些子问题被重复计算多次<br>（3）若能保存已解决子问题的答案，而在需要时再找出已求得的答案，就可避免大量重复计算，从而得到多项式时间算法（备忘录法）</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806113808720.png" alt="image-20250806113808720"></p><p>动态规划的基本过程包括定义子问题，解决子问题，合并子问题的解来求解原问题。动态规划通常采用自底向上的方式进行，通过迭代计算子问题并存储子问题的解，逐步求解更大规模的问题，直到求解出原问题。</p><p>动态规划主要包括两个要素：<code>最优子结构</code>和<code>重叠子问题</code>。</p><p><strong>重复子问题</strong></p><ul><li>递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次，这种性质称为子问题的重叠性质</li><li>动态规划算法对每个子问题只解一次，并将其解保存在一个表格中，当再次需要解此子问题时，只是简单用常数时间查看一下结果</li><li>通常不同的子问题个数随问题的大小呈多项式增长，用动态规划算法只需要多项式时间，从而获得较高的解题效率</li></ul><p><strong>最优子结构</strong></p><ul><li>一个问题的最优解包含着其子问题的最优解，这种性质称为最优子结构性质</li><li>分析问题的最优子结构性质：首先假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾</li><li>利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解</li><li>最优子结构是一个问题能用动态规划算法求解的前提</li></ul><p><strong>动态规划算法与分治算法的异同点</strong></p><ul><li>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题</li><li>分治算法经分解得到的子问题往往是独立的</li><li>动态规划算法经分解得到的子问题往往不是独立的，有些子问题被重复计算多次</li></ul><p><strong>动态规划求解的基本步骤</strong></p><ol><li>找出最优解的性质，并刻划其结构特征</li><li>递归地定义最优值</li><li>以自底向上的方式计算出最优值</li><li>根据计算最优值时得到的信息，构造最优解</li></ol><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>动态规划算法的基本步骤通常包括：划分阶段、定义状态、建立状态转移方程以及确定边界条件等。</p><p><strong>划分阶段</strong>：按照时间或空间特征，将问题划分为若干个阶段，每个阶段对应一个决策过程。这些阶段需要满足无后效性，即某个阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响。这是动态规划方法应用的前提，也是保证算法有效性的基础。</p><p><strong>定义状态</strong>：对每个阶段定义状态变量，状态变量应该能够表示出该阶段所有可能的信息，且能从中推导出下一阶段的状态。在定义状态时，要考虑到问题的具体特征，使得状态变量能够简洁明了地反映问题的本质。</p><p><strong>状态转移方程</strong>：根据问题的性质，建立从一个阶段到下一个阶段的递推关系式，即状态转移方程。状态转移方程是动态规划算法的核心部分，它描述了问题在不同阶段之间的转移关系。在建立状态转移方程时，需要仔细分析问题的特征，找到正确的状态转移方式。同时，要注意避免重复计算，提高算法的效率。</p><p><strong>边界条件</strong>：确定状态转移方程中的起始状态，即问题的初始条件。边界条件是动态规划算法的重要组成部分，它决定了算法的起点和范围。在确定边界条件时，要根据问题的具体要求进行设定，确保算法的正确性和有效性。</p><p><strong>求解最优解</strong>：利用状态转移方程和边界条件，从初始状态开始逐步求解问题，最终得到问题的最优解。在求解过程中，要注意保存中间结果，以便后续使用。同时，要注意算法的时间复杂度和空间复杂度，确保算法在实际应用中的可行性。</p><p><strong>优化与改进</strong>：在得到基本解决方案后，可以对算法进行优化和改进。例如，可以采用更高效的数据结构来存储中间结果，或者采用更合理的状态转移方式来减少计算量。此外，还可以结合其他算法和技术来进一步提高算法的性能和适用范围。</p><p><strong>算法实现与测试</strong>：将优化后的算法用具体的编程语言实现，并进行测试以验证其正确性和有效性。在实现过程中，要注意代码的可读性和可维护性，以便后续修改和扩展。同时，要进行充分的测试以确保算法在各种情况下的正确性。</p><h2 id="动态规划优缺点"><a href="#动态规划优缺点" class="headerlink" title="动态规划优缺点"></a>动态规划优缺点</h2><p><strong>优点</strong></p><ul><li><p>对于具有重叠子问题和最优子结构性质的问题，动态规划可以显著提高求解效率，避免不必要的重复计算。通过存储和复用子问题的解，动态规划算法能够避免重复计算相同的子问题，从而大大减少计算量。</p></li><li><p>动态规划算法的代码通常比较简洁，易于理解和实现。一旦确定了问题的状态转移方程和边界条件，动态规划算法的代码实现往往非常直观和简洁。</p></li></ul><p><strong>缺点</strong></p><ul><li>对于没有重叠子问题和最优子结构性质的问题，动态规划算法可能并不适用，此时需要考虑其他算法。动态规划算法的有效性建立在问题的重叠子问题和最优子结构性质上，如果问题不具备这些性质，那么动态规划算法就无法发挥其优势。</li><li>动态规划算法的空间复杂度通常较高，需要存储所有子问题的解，以便后续使用。这可能导致算法在处理大规模问题时需要消耗大量的内存空间。在某些情况下，可能需要考虑使用滚动数组或其他优化技巧来降低空间复杂度。滚动数组是一种常用的优化方法，它只保留当前需要使用的子问题解，从而避免了存储所有子问题的解。</li></ul><hr><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>动态规划是求多阶段决策过程最优化的一种数学方法，它将问题的整体按时间或空间的特征分成若干个前后衔接的时空阶段，把多个阶段决策问题表示为前后有关的一系列单阶段决策问题，然后逐个求解，从而求出整个问题的最有决策序列。动态规划的十大经典问题：</p><blockquote><ol><li>最长公共子序列</li><li>背包问题</li><li>矩阵链路乘法</li><li>编辑距离</li><li>硬币找零问题</li><li>最大子段和</li><li>最长递增子序列</li><li>0-1背包问题</li><li>划分问题</li><li>合并排序问题</li></ol></blockquote><h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><p>有一只小兔子站在一片三角形的胡萝卜地的入口（数字1处），如下所示，图中的数字表示每一个坑中胡萝卜的数量，小兔子每次只能跳到左下角或者右下角的坑中，请问小兔子怎么跳才能得到最多数量的胡萝卜？</p><blockquote><p>1<br>3 2<br>4 10 1<br>4 3 2 20</p></blockquote><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806114712772.png" alt="image-20250806114712772"></p><h3 id="经典递归解法"><a href="#经典递归解法" class="headerlink" title="经典递归解法"></a>经典递归解法</h3><p>采用暴力法解决这个问题，从第一层开始，每次有两个选择，左下角和右下角，也就是n层的话，有2^{n-1}条路径，T（n） = 2^n 。</p><h4 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h4><p>把上面的三角形放到一个二维数组中，没有放数的地方都为0<br>从二位数组的a[i][j] 开始，最多的胡萝卜数为a[i][j]加上以右下角为起点和左下角为起点路径中的胡萝卜最大数的路径，循坏递归，因为每个点都有两条路径选择，每次选择路径中胡萝卜最多的路径。递归的结束条件是 i = n+1时结束，因为有n层，到n+1层时自然就结束。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] a = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>&#125;,&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">20</span>&#125;&#125;;</span><br><span class="line">    System.out.println(solve(a,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span>[][] a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="comment">// 第 n+1 层结束  ===》从0层开始计算 ，那么 i = n 时结束</span></span><br><span class="line">    <span class="keyword">if</span> (i == a.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[i][j]+ Math.max(solve(a,i+<span class="number">1</span>,j),solve(a,i+<span class="number">1</span>,j+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="备忘录法"><a href="#备忘录法" class="headerlink" title="备忘录法"></a>备忘录法</h3><h4 id="什么是备忘录法"><a href="#什么是备忘录法" class="headerlink" title="什么是备忘录法"></a>什么是备忘录法</h4><ul><li>备忘录法是为了解决避免递归算法中相同子问题的重复求解。</li><li>备忘录法为每个解过的子问题建立备忘录以备需要时查看，所以也称搜表法。</li><li>备忘录法的控制与直接使用递归方法的控制结构相同。</li><li>备忘录法又称记忆化搜索，自顶向下的方式解决问题。</li></ul><h4 id="备忘录法的实现"><a href="#备忘录法的实现" class="headerlink" title="备忘录法的实现"></a>备忘录法的实现</h4><p>避免子问题重复被求解，可以定义一个数组，每次要计算一个子问题时，首先从数组中查询这个子问题的解，子问题解没有在数组中，说明没有计算过该子问题，那么计算该子问题，并将解放到数组中去，以便下次计算该子问题时，可以直接从数组中拿。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>上面递归时候，我们solve(a,2,1)被重复计算过两次。此时可用备忘录法，即利用一个二维数组记录每次子问题计算的值（例如a(6，3)的解就放到 d [6] [3]中），每次需要计算子问题时，先判断数组中是否计算过保存了，有则直接取用，没有就计算并把结果保存到数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] a = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>&#125;,&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">20</span>&#125;&#125;;</span><br><span class="line">    System.out.println(solve(a, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">int</span>[a.length][a.length]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span>[][] a,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span>[][] p)</span>&#123;</span><br><span class="line">    <span class="comment">//第 n+1 层结束  ===》从0层开始计算 ，那么 i = n 时结束</span></span><br><span class="line">    <span class="keyword">if</span> (i == a.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        p[i][j] = a[i][j] + Math.max(solve(a, i + <span class="number">1</span>, j, p), solve(a, i + <span class="number">1</span>, j + <span class="number">1</span>, p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ol><li><p><code>p[i][j]</code>表示(i, j)的达到最后一层的最大路径和，那么p[i][j]的最优解包含了子问题<code>p[i+1][j]</code>或<code>p[i+1][j+1]</code>的最优解</p></li><li><p>状态转移方程（递归方程）及图解</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806120324792.png" alt="image-20250806120324792"></p></li><li><p>最终结果是<code>p[0][0]</code>（从表的最后一层开始填）</p></li><li><p>动态规划法又叫填表法，填完上面那张表结果就出来了</p></li></ol><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] a = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>&#125;,&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">20</span>&#125;&#125;;</span><br><span class="line">    System.out.println(solve(a));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span>[][] a)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[][] p = a.clone();</span><br><span class="line">    <span class="comment">// 最后一层的数不需要修改 ，从倒数第二次开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            p[i][j] = a[i][j] + Math.max(p[i+<span class="number">1</span>][j],p[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ol><li><p><code>p[i][j]</code>表示从(1,1)到达(i, j) 的最大路径和，那么<code>p[i][j]</code>的最优解包含了子问题<code>p[i-1][j-1]</code>或<code>p[i-1][j]</code>的最优解</p></li><li><p>状态转移方程（递归方程）和图解</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806120733577.png" alt="image-20250806120733577"></p></li><li><p>最终结果是<code>p[4][4]</code>（从表的第一层开始填）</p></li></ol><h2 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>最长公共子序列（Longest Common Subsequence，简称LCS）。其基本思想是寻找两个字符串中都存在的最长子序列，该最长子序列可以不连续，但要保证其相对顺序一样。（注意，这里是子序列，而不是子串，子序列可以不连续，而子串是连续的）。具有特征如下：</p><blockquote><p><strong>长度</strong>：最长公共子序列的长度最大为两个序列的最小长度，如果两个序列完全相同，则它们的最长公共子序列即为它们本身。</p><p><strong>顺序</strong>：最长公共子序列中的子序列在原序列中的顺序一致。</p><p><strong>相同元素</strong>：最长公共子序列中的子序列所包含的元素必须在两个原序列中都存在。</p><p><strong>不连续性</strong>：最长公共子序列不需要在原序列中连续出现。</p></blockquote><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>​    求解LCS问题，不能使用暴力搜索方法。一个长度为n的序列拥有 2的n次方个子序列，它的时间复杂度是指数阶，太恐怖了。解决LCS问题，需要借助动态规划的思想。</p><p>  动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。</p><h3 id="特征分析"><a href="#特征分析" class="headerlink" title="特征分析"></a>特征分析</h3><p>  <strong>设A=“a0，a1，…，am”，B=“b0，b1，…，bn”，且Z=“z0，z1，…，zk”为它们的最长公共子序列。不难证明有以下性质：</strong></p><blockquote><p>如果am=bn，则zk=am=bn，且“z0，z1，…，z(k-1)”是“a0，a1，…，a(m-1)”和“b0，b1，…，b(n-1)”的一个最长公共子序列；<br>如果am!=bn，则若zk!=am，蕴涵“z0，z1，…，zk”是“a0，a1，…，a(m-1)”和“b0，b1，…，bn”的一个最长公共子序列；<br>如果am!=bn，则若zk!=bn，蕴涵“z0，z1，…，zk”是“a0，a1，…，am”和“b0，b1，…，b(n-1)”的一个最长公共子序列。</p></blockquote><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806105617464.png" alt="image-20250806105617464"></p><p>案例说明：S1 = {1,3,4,5,6,7,7,8} 和 S2 = {3,5,7,4,8,6,7,8,2}），结合上图：<br>  假如S1的最后一个元素 与 S2的最后一个元素相等，那么S1和S2的LCS就等于 {S1减去最后一个元素} 与 {S2减去最后一个元素} 的 LCS 再加上 S1和S2相等的最后一个元素。</p><p>  假如S1的最后一个元素 与 S2的最后一个元素不等（本例子就是属于这种情况），那么S1和S2的LCS就等于 ： {S1减去最后一个元素} 与 S2 的LCS， {S2减去最后一个元素} 与 S1 的LCS 中的最大的那个序列。</p><h3 id="递归公式"><a href="#递归公式" class="headerlink" title="递归公式"></a>递归公式</h3><p>​    根据LCS的特征，假设需要求 a1 … am 和 b1 … b(n-1)的LCS 和 a1 … a(m-1) 和 b1 … bn的LCS，一定会递归地并且重复地把如a1… a(m-1) 与 b1 … b(n-1) 的 LCS 计算几次。所以我们需要一个数据结构来记录中间结果，避免重复计算。</p><p>  假设用c[i,j]表示Xi 和 Yj 的LCS的长度（直接保存最长公共子序列的中间结果不现实，需要先借助LCS的长度）。其中X = {x1 … xm}，Y ={y1…yn}，Xi = {x1 … xi}，Yj={y1… yj}。可得递归公式如下：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/wps1.jpg" alt="img"></p><h3 id="计算LSC的长度"><a href="#计算LSC的长度" class="headerlink" title="计算LSC的长度"></a>计算LSC的长度</h3><p>以表格的形式表示整个过程如下：</p><table><thead><tr><th>下标</th><th>j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>i</td><td></td><td>S2j</td><td>3</td><td>5</td><td>7</td><td>4</td><td>8</td><td>6</td><td>7</td><td>8</td><td>2</td></tr><tr><td>0</td><td>S1i</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>3</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>3</td><td>4</td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>4</td><td>5</td><td>0</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>5</td><td>6</td><td>0</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>6</td><td>7</td><td>0</td><td>1</td><td>2</td><td>3</td><td>3</td><td>3</td><td>3</td><td>4</td><td>4</td><td>4</td></tr><tr><td>7</td><td>7</td><td>0</td><td>1</td><td>2</td><td>3</td><td>3</td><td>3</td><td>3</td><td>4</td><td>4</td><td>4</td></tr><tr><td>8</td><td>8</td><td>0</td><td>1</td><td>2</td><td>3</td><td>3</td><td>4</td><td>4</td><td>4</td><td>5</td><td>5</td></tr></tbody></table><p>填表的过程就相当于解题的过程（第0行、第0列初始值都为0），以第0行为参照，先从左到右填满第1行；再以第1行为参照，从左到右填满第2行；以此类推，当表格填完后，答案就出来了（即为L[n][n]）。根据性质，c[8,9] = S1 和 S2 的 LCS的长度，即为5。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>参见下文 <a href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">最长公共子序列</a></p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>给定n种物品（每种物品只有一件）和一个背包：物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</li><li>对于每种物品，只有两种选择：装(1)或者不装(0)，不允许装物品的一部分</li></ul><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li><p>n=5, c=10, w={2, 2, 6, 5, 4}, v={6, 3, 5, 4, 6}</p></li><li><p>选中1，2，5三件物品，最高价值15，总重8</p></li><li><p>填表，物品的种类为表行，背包容量+1为行，从后面填到前面，j表示背包容量。</p></li><li><p>最后一行</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806121725952.png" alt="image-20250806121725952"></p></li><li><p>前面的行</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250806121833004.png" alt="image-20250806121833004"></p></li><li><p>最大值为右上角</p></li></ul><h3 id="代码实现一"><a href="#代码实现一" class="headerlink" title="代码实现一"></a>代码实现一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 浪费数组的第一个</span></span><br><span class="line">    <span class="type">int</span>[] w = &#123;<span class="number">0</span>,<span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] v = &#123;<span class="number">0</span>,<span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    System.out.println(fun(<span class="number">5</span>, <span class="number">10</span>, v, w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> c,<span class="type">int</span>[] v,<span class="type">int</span>[] w)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[][] m = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][c+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 防止数组越界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">jMax</span> <span class="operator">=</span> Math.min(w[n]-<span class="number">1</span>,c);</span><br><span class="line">    <span class="comment">// Step1:填最后一行</span></span><br><span class="line">    <span class="comment">// j&lt;w[n] ==&gt;m[n][j]=0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= jMax; j++) &#123;</span><br><span class="line">        m[n][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// j&gt;=w[n] ==&gt;m[n][j]=v[n]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> w[n]; j &lt;= c; j++) &#123;</span><br><span class="line">        m[n][j] = v[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Step2: 从倒数第二行往前面填</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        jMax = Math.min(w[i]-<span class="number">1</span>,c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= jMax; j++) &#123;</span><br><span class="line">            m[i][j] = m[i+<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> w[i]; j &lt;= c; j++) &#123;</span><br><span class="line">            m[i][j] = Math.max(m[i+<span class="number">1</span>][j],m[i+<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一行最后一个元素</span></span><br><span class="line">    m[<span class="number">1</span>][c] = m[<span class="number">2</span>][c];</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= w[<span class="number">1</span>])&#123;</span><br><span class="line">        m[<span class="number">1</span>][c] = Math.max(m[<span class="number">1</span>][c],m[<span class="number">2</span>][c-w[<span class="number">1</span>]]+v[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m[<span class="number">1</span>][c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码实现二"><a href="#代码实现二" class="headerlink" title="代码实现二"></a>代码实现二</h3><p>知道选择了哪些物品使得价值最大，选择了物品用1表示，没选择用0表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据填的表格推断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traceback</span><span class="params">(<span class="type">int</span>[][] m,<span class="type">int</span> n,<span class="type">int</span> c,<span class="type">int</span>[] w)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] x = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//没有选择</span></span><br><span class="line">        <span class="keyword">if</span> (m[i][c] == m[i+<span class="number">1</span>][c] )&#123;</span><br><span class="line">            x[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            x[i] = <span class="number">1</span>;</span><br><span class="line">            c -= w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    x[n] = (m[n][c]&gt;<span class="number">0</span>) ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span> ; i &lt; x.length; i++) &#123;</span><br><span class="line">        System.out.print(x[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p><a href="https://leetcode.cn/problems/regular-expression-matching/">LeetCode 10 正则表达式匹配</a></p><blockquote><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><ul><li><code>&#39;.&#39;</code> 匹配任意单个字符</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code> 的，而不是部分字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;, p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;, p = &quot;a*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ab&quot;, p = &quot;.*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code>，<code>1 &lt;= p.length &lt;= 20</code></li><li><code>s</code> 只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li><li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), pLen = p.length();</span><br><span class="line">    <span class="type">boolean</span>[][] memory = <span class="keyword">new</span> <span class="title class_">boolean</span>[sLen+<span class="number">1</span>][pLen+<span class="number">1</span>]; <span class="comment">// i,j是否匹配</span></span><br><span class="line">    memory[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= sLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= pLen; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">// 用例保证了第一个字符不可能是 *</span></span><br><span class="line">                memory[i][j] = memory[i][j-<span class="number">2</span>] || </span><br><span class="line">                    (i &gt; <span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">2</span>) || p.charAt(j-<span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; memory[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                memory[i][j] = i &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">                    (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; memory[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[sLen][pLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/description/">LeetCode 53 最大子数组和</a></p><blockquote><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) sum += num;</span><br><span class="line">        <span class="keyword">else</span> sum = num;</span><br><span class="line">        res = Math.max(res, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">LeetCode 1143 最长公共子序列</a></p><blockquote><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义dp[i][j]表示[0,i-1]的子串text1与[0,j-1]的子串text2的最长公共长度</span></span><br><span class="line">    <span class="comment">// 假如两者text1[i]=text2[j]，当前长度就是dp[i-1][j-1]+1</span></span><br><span class="line">    <span class="comment">// 假如两者不等，当前长度可以从[i-1][j]推出，也可以从[i][j-1]推出</span></span><br><span class="line">    <span class="comment">// 当前值可以从左上角、左边、上方3个方向推导</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> text1.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> text2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))</span><br><span class="line">                dp[i][j] = dp[i -<span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找终点"><a href="#找终点" class="headerlink" title="找终点"></a>找终点</h2><p><a href="https://www.nowcoder.com/discuss/679138988615020544">牛客网_找终点</a></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数数组，设为nums，最大为100个成员，求从第一个成员开始，正好走到数组最后一个成员，所使用的最少步骤数。要求:</span><br><span class="line">1、第一步必须从第一元素开始，且1&lt;=第一步的步长&lt;len/2;(len为数组的长度，需要自行解析)。</span><br><span class="line">2、从第二步开始，只能以所在成员的数字走相应的步数，不能多也不能少,如果目标不可达返回-1，只输出最少的步骤数量。</span><br><span class="line">3、只能向数组的尾部走，不能往回走。</span><br><span class="line">输入描述：由正整数组成的数组，以空格分隔， 数组长度 小于100，请自行解析数据数量。</span><br><span class="line">输出描述：正整数，表示最少的步数，如果不存在输出-1</span><br><span class="line">示例1</span><br><span class="line">输入 7 5 9 4 2 6 8 3 5 4 3 9</span><br><span class="line">输出  2</span><br><span class="line">说明：</span><br><span class="line">第一步:第一个可选步长选择2，从第一个成员7开始走2步，到达9;</span><br><span class="line">第二步:从9开始，经过自身数字9对应的9个成员到最后。</span><br><span class="line">示例2</span><br><span class="line">输入 1 2 3 7 1 5 9 3 2 1</span><br><span class="line">输出 -1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findTheEnd</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化动态规划数组，dp[i]表示到达第i个位置所需的最少步骤数</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">999999</span>); <span class="comment">// 初始化填充较大值</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一个位置的步骤数为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n / <span class="number">2</span>; i++) &#123; <span class="comment">// 初始化从第一个位置开始的步长，步长范围为1到len/2</span></span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历数组，更新动态规划数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + a[i] &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i + a[i]] = Math.min(dp[i + a[i]], dp[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果，如果最后一个位置的步数仍为无穷大，表示不可达，输出-1</span></span><br><span class="line">    System.out.println(dp[n - <span class="number">1</span>] == <span class="number">999999</span> ? -<span class="number">1</span> : dp[n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StepTo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Input input;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> <span class="title class_">Input</span>(<span class="string">&quot;7 5 9 4 2 6 8 3 5 4 3 9&quot;</span>);</span><br><span class="line">        input = <span class="keyword">new</span> <span class="title class_">Input</span>(<span class="string">&quot;1 2 3 7 1 5 9 3 2 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        String[] split = input.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[split.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; split.length; i++) &#123;</span><br><span class="line">            array[i] = Integer.parseInt(split[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后一脚 迈到终点 则说明该这一步的起脚点 下标 + 对应的之恰好是中调的坐标</span></span><br><span class="line">        <span class="comment">// 依次递归个逻辑即可找到路径 计算该路径的步数即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> array.length - <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] + i == array.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">steps1</span> <span class="operator">=</span> getSteps(array, i);</span><br><span class="line">                <span class="keyword">if</span> (steps1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    steps = Math.min(steps, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (steps == <span class="number">1000</span>) &#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(steps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSteps</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> step)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这一步落在数组的前半部分， 第一步迈到这里即可以到达终点</span></span><br><span class="line">        <span class="keyword">if</span> ( step &gt;= <span class="number">1</span> &amp;&amp; step &lt; (array.length - <span class="number">1</span>)/<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果起脚点小于 1 说明没有合适的起脚点</span></span><br><span class="line">        <span class="keyword">if</span> (step &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextStep</span> <span class="operator">=</span> -<span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 找到上一脚的起脚点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> step - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] + i == step) &#123;</span><br><span class="line">                nextStep = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  getSteps(array, nextStep) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;滑动窗口算法可以将嵌套的循环问题，转换为单循环问题，降低&lt;a href=&quot;https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;spm=1001.2101.3001.702</summary>
      
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口算法</title>
    <link href="https://southernfish.github.io/pages/algorithm/sliding-window/"/>
    <id>https://southernfish.github.io/pages/algorithm/sliding-window/</id>
    <published>2025-08-02T02:00:36.000Z</published>
    <updated>2025-09-20T11:18:48.137Z</updated>
    
    <content type="html"><![CDATA[<p>滑动窗口算法可以将嵌套的循环问题，转换为单循环问题，降低<a href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1001.2101.3001.7020">时间复杂度</a>。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/mengyoufengyu/article/details/145620833">算法07-滑动窗⼝算法</a></p><p><a href="https://blog.csdn.net/qq_39559641/article/details/122793321">滑动窗口算法精讲（Sliding Window Algorithm）</a></p><p><a href="https://blog.csdn.net/guihunkun/article/details/109266185">滑动窗口相关算法题总结</a></p></blockquote><h1 id="详细讲解"><a href="#详细讲解" class="headerlink" title="详细讲解"></a>详细讲解</h1><h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p><strong>滑动窗口算法</strong>是一种通过维护一个动态窗口来解决问题的技巧，窗口在数据上“滑动”，逐步找到最优解。</p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>滑动窗口算法的本质是双指针法中的左右指针法，所谓滑动窗口，就像描述的那样，可以理解成是一个会滑动的窗口，每次记录下窗口的状态，再找出符合条件的适合的窗口。它可以将双层嵌套的循环问题，转换为单层遍历的循环问题。使用两个指针一左一右构成一个窗口，就可以将二维循环的问题转化成一维循环一次遍历，相当于通过旧有的计算结果对搜索空间进行剪枝，使时间复杂度从O（n²）降低至O（n），比如经典字符串查找算法Rabin-Karp 指纹字符串查找算法，它本质上也使用了滑动窗口的思想，通过公式推导降低窗口滑动时计算子串哈希值的复杂度。</p><p>滑动窗口算法更多的是一种思想或技巧，按照窗口大小是否固定分为固定滑动窗口和变长滑动窗口，可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。往往类似于“请找到满足xx的最x的区间（子串、子数组等）的xx”这类问题都可以使用该方法进行解决。</p><p>想象你在看一列火车，火车窗口只能看到一部分车厢。滑动窗口算法就是通过调整窗口的起点和终点，找到你感兴趣的部分（比如最长的连续车厢、最短的覆盖范围等）。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>滑动窗口算法通常用于解决以下问题：</p><ol><li><strong>子数组/子字符串问题</strong>：比如找最长的无重复字符子串、最短的覆盖子串等。</li><li><strong>连续区间问题</strong>：比如找满足条件的连续子数组。</li><li><strong>优化问题</strong>：比如在固定窗口大小内找最大值、最小值或平均值。</li></ol><h2 id="滑动窗口的两种类型"><a href="#滑动窗口的两种类型" class="headerlink" title="滑动窗口的两种类型"></a>滑动窗口的两种类型</h2><h3 id="固定大小的窗口"><a href="#固定大小的窗口" class="headerlink" title="固定大小的窗口"></a>固定大小的窗口</h3><ul><li>窗口大小固定，比如每次只看连续的 3 个元素。</li><li>例子：计算数组中每个长度为 k 的子数组的平均值。</li></ul><h3 id="可变大小的窗口"><a href="#可变大小的窗口" class="headerlink" title="可变大小的窗口"></a>可变大小的窗口</h3><ul><li>窗口大小不固定，根据条件动态调整。</li><li>例子：找最长的无重复字符子串。</li></ul><h2 id="滑动窗口的基本步骤"><a href="#滑动窗口的基本步骤" class="headerlink" title="滑动窗口的基本步骤"></a>滑动窗口的基本步骤</h2><ol><li><p><strong>初始化窗口</strong>：</p><ul><li>定义窗口的起点（<code>left</code>）和终点（<code>right</code>），通常初始化为 0，把索引闭区间 [left, right] 称为一个「窗口」。</li><li>定义一些辅助变量（比如当前窗口的和、最大值、最小值等）。</li></ul></li><li><p><strong>滑动窗口</strong>：</p><ul><li><p>移动右边界（<code>right</code>），扩大窗口 [left, right]，直到满足某个条件。（找可行解）</p></li><li><p>移动左边界（<code>left</code>），缩小窗口 [left, right]，直到不满足条件。同时每次增加 left 都要更新一轮结果。（优化可行解）</p></li><li><p>在滑动过程中，记录需要的结果（比如最大长度、最小长度等）。</p></li></ul></li><li><p><strong>滑动窗口</strong>，直至一次遍历结束：重复第 2 步，直到 right 到达到的尽头。</p></li><li><p><strong>返回结果</strong>：根据滑动过程中记录的结果，返回最终答案。</p></li></ol><h2 id="关键特点"><a href="#关键特点" class="headerlink" title="关键特点"></a>关键特点</h2><ol><li><strong>高效</strong>：通过滑动窗口，避免了重复计算，时间复杂度通常为 (O(n))。</li><li><strong>灵活</strong>：适用于多种问题，尤其是需要处理连续区间的问题。</li><li><strong>双指针</strong>：滑动窗口通常用双指针（<code>left</code> 和 <code>right</code>）来实现。</li></ol><hr><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="模板一"><a href="#模板一" class="headerlink" title="模板一"></a>模板一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">slideWindowTemplate</span><span class="params">(String nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;        <span class="comment">//[初始化窗口]</span></span><br><span class="line">    <span class="comment">//codes...               [其他初始化信息,定义一些维护数据的数据结构]</span></span><br><span class="line">    <span class="keyword">while</span>(r &lt; nums.length)&#123;</span><br><span class="line">        <span class="comment">//codes.....         [维护窗口中的数据] </span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; check(xxx) == <span class="literal">false</span>)&#123;   <span class="comment">//[窗口不满足某种性质]</span></span><br><span class="line">            <span class="comment">//codes...       [维护窗口中的数据] </span></span><br><span class="line">            l++;             <span class="comment">//[缩小窗口]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//codes..            [更新结果]</span></span><br><span class="line">        r++;                 <span class="comment">//[增大窗口]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板二"><a href="#模板二" class="headerlink" title="模板二"></a>模板二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">slideWindowTemplate</span><span class="params">(String nums)</span>&#123;</span><br><span class="line">    <span class="comment">//codes...               [其他初始化信息,定义一些维护数据的数据结构]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.length; r++)&#123;</span><br><span class="line">        <span class="comment">//codes.....         [维护窗口中的数据] </span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; check(xxx) == <span class="literal">false</span>)&#123;   <span class="comment">//[窗口不满足某种性质]</span></span><br><span class="line">            <span class="comment">//codes...       [维护窗口中的数据] </span></span><br><span class="line">            l++;             <span class="comment">//[缩小窗口]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//codes..            [更新结果]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="补种未成活胡杨"><a href="#补种未成活胡杨" class="headerlink" title="补种未成活胡杨"></a>补种未成活胡杨</h2><blockquote><p>近些年来，我国防沙治沙取得显著成果。某沙漠新种植N棵胡杨(编号1-N)，排成一排。一个月后，有M棵胡杨未能成活。<br>现可补种胡杨K棵，请问如何补种(只能补种，不能新种)，可以得到最多的连续胡杨树?<br>输入描述<br>N 总种植数量<br>M 未成活胡杨数量<br>M 个空格分隔的数，按编号从小到大排列<br>K 最多可以补种的数量<br>其中:<br>1&lt;=N&lt;=100000<br>1&lt;=M&lt;=N<br>0&lt;=K&lt;=M<br>输出描述：最多的连续胡杨棵树<br>示例1<br>输入<br>5<br>2<br>2 4<br>1<br>输出 3<br>说明：补种到2或4结果一样，最多的连续胡杨棵树都是3<br>示例2<br>输入<br>10<br>3<br>2 4 7<br>1<br>输出 6<br><strong>说明</strong>：补种第7棵树，最多的连续胡杨棵树为6(5,6,7,8,9,10)<br><strong>解析</strong><br><strong>初始化</strong>：首先读取总种植数量N，并初始化一个长度为N的数组tree，所有初始值为0，表示所有胡杨都成活。读取未成活胡杨的数量M，然后读取未成活胡杨的编号，将相应位置的tree值设为1，表示该胡杨未成活。读取最多可以补种的数量K。</p><p><strong>滑动窗口算法</strong>：遍历每棵树的位置，如果当前树未成活（tree[i]为1），则将其加到tot中。如果未成活树的总数tot超过K，说明当前窗口的未成活树数超过了补种数量，需要调整窗口大小，从左侧逐次减少未成活树数，直到tot不超过K。每次调整窗口之后，计算当前窗口的大小（i - j + 1），如果大于之前记录的最大连续成活树数，则更新最大值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// 读入总种植数量N</span></span><br><span class="line">    <span class="type">int</span> tree[] = <span class="keyword">new</span> <span class="title class_">int</span>[N];  <span class="comment">// 创建一个长度为N的数组用于存储每棵树的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// 读入未成活胡杨数量M</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> in.nextInt(); <span class="comment">// 读入每棵未成活胡杨的编号</span></span><br><span class="line">        tree[x - <span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 将对应位置的值设为1，表示未成活</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 读入最多可以补种的数量K</span></span><br><span class="line">    <span class="comment">// 初始化变量:总未成活树数、最大连续胡杨数、滑动窗口起始位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历所有树的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">        <span class="comment">// 每次遍历都将当前树的状态加到tot，如果未成活则+1，成活则+0</span></span><br><span class="line">        tot += tree[r];</span><br><span class="line">        <span class="comment">// 如果未成活树的总数超过了补种限制</span></span><br><span class="line">        <span class="keyword">while</span> (tot &gt; cnt) &#123;</span><br><span class="line">            tot -= tree[l]; <span class="comment">// 减去窗口起始位置的树的状态</span></span><br><span class="line">            l++;         <span class="comment">// 滑动窗口的起始位置右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算当前滑动窗口的大小，如果比之前的最大连续数大则更新</span></span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; ans) &#123;</span><br><span class="line">            ans = r - l + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(ans); <span class="comment">// 输出最大连续胡杨数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LeetCode 3 无重复字符的最长子串</a></p><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(s.charAt(right)) &amp;&amp; map.get(s.charAt(right)) &gt;= left) &#123;</span><br><span class="line">            max = Math.max(max, right - left);</span><br><span class="line">            left = map.get(s.charAt(right)) + <span class="number">1</span>; <span class="comment">// 左边设置为重复字符的下一位</span></span><br><span class="line">            map.put(s.charAt(right), right);<span class="comment">// 已存在字符更新最新下标</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(s.charAt(right), right); <span class="comment">// 添加字符 及下标</span></span><br><span class="line">            max = Math.max(max, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(string s)</span> s&#123;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt; record;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>,left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(record.find(s[right]) == record.end()) &#123;</span><br><span class="line">            record.insert(s[right++]);</span><br><span class="line">            res = max(res,(<span class="type">int</span>)record.size());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            record.erase(s[left++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">LeetCode 76 最小覆盖子串</a></p><blockquote><p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。<br>示例：<br>输入：S = “ADOBECODEBANC”, T = “ABC”<br>输出：“BANC”<br>提示：<br>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>]; <span class="comment">// ASCII码  0-9：48-57； a-z:97-122  A-Z：65-90</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) cnt[t.charAt(i)]++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, ansL = <span class="number">0</span>, ansR = <span class="number">0</span>, ans = Integer.MAX_VALUE, cntT = t.length();</span><br><span class="line">    <span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[s.charAt(r++)]-- &gt; <span class="number">0</span>) cntT--;</span><br><span class="line">        <span class="keyword">while</span> (cntT == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l &lt; ans) &#123;</span><br><span class="line">                ans = r - l;</span><br><span class="line">                ansL = l;</span><br><span class="line">                ansR = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt[s.charAt(l++)]++ == <span class="number">0</span>) cntT++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(ansL, ansR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大连续1的个数-III"><a href="#最大连续1的个数-III" class="headerlink" title="最大连续1的个数 III"></a>最大连续1的个数 III</h2><p><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">LeetCode 1004 最大连续1的个数 III</a></p><blockquote><p>给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。<br>返回仅包含 1 的最长（连续）子数组的长度。<br>示例 1：<br>输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2<br>输出：6<br>解释：<br>[1,1,1,0,0,1,1,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 6。<br>示例 2：<br>输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3<br>输出：10<br>解释：<br>[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 10。<br>提示：<br>1 &lt;= A.length &lt;= 20000<br>0 &lt;= K &lt;= A.length<br>A[i] 为 0 或 1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestOnes</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] == <span class="number">0</span>) &#123;</span><br><span class="line">            k--; <span class="comment">// 0变成1，消耗一个1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] == <span class="number">0</span>) &#123;</span><br><span class="line">                k++; <span class="comment">// 1变成0，归还一个1</span></span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, right - left + <span class="number">1</span>); <span class="comment">// 把 right++语句在后面，所以这里是 right-left+1</span></span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可获得的最大点数"><a href="#可获得的最大点数" class="headerlink" title="可获得的最大点数"></a>可获得的最大点数</h2><p><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/">LeetCode 1423 可获得的最大点数</a></p><blockquote><p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。你的点数就是你拿到手中的所有卡牌的点数之和。<br>给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。<br>示例 1：<br>输入：cardPoints = [1,2,3,4,5,6,1], k = 3<br>输出：12<br>解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。<br>示例 2：<br>输入：cardPoints = [2,2,2], k = 2<br>输出：4<br>解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。<br>示例 3：<br>输入：cardPoints = [9,7,7,9,7,7,9], k = 7<br>输出：55<br>解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。<br>示例 4：<br>输入：cardPoints = [1,1000,1], k = 1<br>输出：1<br>解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。<br>示例 5：<br>输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3<br>输出：202<br>提示：<br>1 &lt;= cardPoints.length &lt;= 10^5<br>1 &lt;= cardPoints[i] &lt;= 10^4<br>1 &lt;= k &lt;= cardPoints.length</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScore</span><span class="params">(<span class="type">int</span>[] cardPoints, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cardPoints.length, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cardPoint: cardPoints) &#123;</span><br><span class="line">        sum += cardPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> len - k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        temp += cardPoints[i];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= length) &#123;</span><br><span class="line">            temp -= cardPoints[i - length];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= length - <span class="number">1</span>)</span><br><span class="line">            min = Math.min(min, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绝对差不超过限制的最长连续子数组"><a href="#绝对差不超过限制的最长连续子数组" class="headerlink" title="绝对差不超过限制的最长连续子数组"></a>绝对差不超过限制的最长连续子数组</h2><p><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">LeetCode 1438 绝对差不超过限制的最长连续子数组</a></p><blockquote><p>给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。<br>如果不存在满足条件的子数组，则返回 0 。<br>示例 1：<br>输入：nums = [8,2,4,7], limit = 4<br>输出：2<br>解释：所有子数组如下：<br>[8] 最大绝对差 |8-8| = 0 &lt;= 4.<br>[8,2] 最大绝对差 |8-2| = 6 &gt; 4.<br>[8,2,4] 最大绝对差 |8-2| = 6 &gt; 4.<br>[8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4.<br>[2] 最大绝对差 |2-2| = 0 &lt;= 4.<br>[2,4] 最大绝对差 |2-4| = 2 &lt;= 4.<br>[2,4,7] 最大绝对差 |2-7| = 5 &gt; 4.<br>[4] 最大绝对差 |4-4| = 0 &lt;= 4.<br>[4,7] 最大绝对差 |4-7| = 3 &lt;= 4.<br>[7] 最大绝对差 |7-7| = 0 &lt;= 4.<br>因此，满足题意的最长子数组的长度为 2 。<br>示例 2：<br>输入：nums = [10,1,2,4,7,2], limit = 5<br>输出：4<br>解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。<br>示例 3：<br>输入：nums = [4,2,2,2,4,4,2,2], limit = 0<br>输出：3<br>提示：<br>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i] &lt;= 10^9<br>0 &lt;= limit &lt;= 10^9</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑窗+红黑树 极简解法，时间复杂度O(n*logn)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(); <span class="comment">// 默认升序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">        treeMap.compute(nums[right++], (k, v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (treeMap.lastKey() - treeMap.firstKey() &gt; limit) &#123;</span><br><span class="line">            treeMap.compute(nums[left++], (k, v) -&gt; v == <span class="number">1</span> ? <span class="literal">null</span> : v - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下解法会超时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.naturalOrder());</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length &amp;&amp; left &lt; nums.length) &#123;</span><br><span class="line">        minQueue.add(nums[right]);</span><br><span class="line">        maxQueue.add(nums[right]);</span><br><span class="line">        <span class="keyword">if</span> (maxQueue.peek() - minQueue.peek() &lt;= limit) &#123;</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxQueue.remove((Integer) nums[left]);</span><br><span class="line">        minQueue.remove((Integer) nums[left]);</span><br><span class="line">        left++;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;滑动窗口算法可以将嵌套的循环问题，转换为单循环问题，降低&lt;a href=&quot;https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;spm=1001.2101.3001.702</summary>
      
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>RuoYi</title>
    <link href="https://southernfish.github.io/pages/framwork/ruoyi/"/>
    <id>https://southernfish.github.io/pages/framwork/ruoyi/</id>
    <published>2025-07-31T05:20:36.000Z</published>
    <updated>2025-09-20T11:18:48.141Z</updated>
    
    <content type="html"><![CDATA[<p>若依框架（RuoYi）是一套基于Java开发的快速开发框架，它提供了许多常用的功能模块和工具，包括用户管理、部门管理、角色管理、菜单管理、字典管理、系统监控、定时任务等。若依框架采用了MVC（Model-View-Controller）的架构模式，使用了Spring Boot、MyBatis等流行的开源框架，可以帮助开发者快速搭建企业级的后台管理系统。若依框架还提供了许多可视化的操作界面，使得开发者可以方便地进行系统配置和管理。</p><blockquote><p>官网地址：<a href="https://doc.ruoyi.vip/">若依框架</a></p><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_20143059/article/details/131337812">ruoyi架构那点事</a></p><p><a href="https://blog.csdn.net/2302_76927249/article/details/149039117">若依框架（前后端分离版）</a></p></blockquote><h1 id="若依介绍"><a href="#若依介绍" class="headerlink" title="若依介绍"></a>若依介绍</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>若依（<a href="https://so.csdn.net/so/search?q=RuoYi&spm=1001.2101.3001.7020">RuoYi</a>）是一款基于Spring Boot和MyBatis的Java快速开发框架，主要用于企业级应用系统的开发。它提供了一套完整的后台管理系统解决方案，包括用户权限管理、菜单配置、数据监控等功能，同时支持代码生成器，显著提升开发效率。</p><h2 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h2><ul><li><strong>模块化设计</strong>：前后端分离架构，前端可选Vue2/Vue3版本，后端基于Spring Boot。</li><li><strong>代码生成器</strong>：通过可视化配置自动生成CRUD代码，减少重复劳动。</li><li><strong>权限控制</strong>：基于RBAC（角色基于访问控制）模型，精细化管理菜单、按钮权限。</li><li><strong>多数据源支持</strong>：轻松配置动态数据源，适应复杂业务场景。</li></ul><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li><strong>后端</strong>：Spring Boot、MyBatis、Shiro（安全框架）、Redis（缓存）。</li><li><strong>前端</strong>：Vue.js、Element UI（Vue2版本）或Ant Design Vue（Vue3版本）。</li><li><strong>数据库</strong>：支持MySQL、Oracle、SQL Server等主流数据库</li></ul><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>JDK8 以上，mysql，Redis（<a href="https://www.redis.net.cn/tutorial/3504.html">Redis 配置_redis教程</a>），Maven，Vue</p><h2 id="提供的功能"><a href="#提供的功能" class="headerlink" title="提供的功能"></a>提供的功能</h2><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><p>用户管理：用户是系统操作者，该功能主要完成系统用户配置。<br>部门管理：配置系统组织机构（公司、部门、小组），树结构展现支持数据权限。<br>岗位管理：配置系统用户所属担任职务。<br>菜单管理：配置系统菜单，操作权限，按钮权限标识等。<br>角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。<br>字典管理：对系统中经常使用的一些较为固定的数据进行维护。<br>参数管理：对系统动态配置常用参数。<br>通知公告：系统通知公告信息发布维护。</p><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。<br>登录日志：系统登录日志记录查询包含登录异常。</p><h3 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h3><p>在线用户：当前系统中活跃用户状态监控。<br>服务监控：监视当前系统CPU、内存、磁盘、堆栈等相关信息。<br>缓存监控：对系统的缓存查询，查看、清理等操作。<br>在线构建器：拖动表单元素生成相应的HTML代码。<br>连接池监视：监视当期系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈。</p><h3 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h3><p>定时任务：在线（添加、修改、删除)任务调度包含执行结果日志。<br>代码生成：前后端代码的生成（java、html、xml、sql)支持CRUD下载 。<br>系统接口：根据业务代码自动生成相关的api接口文档。</p><hr><h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis（Remote Dictionary Server）是一个开源的高性能键值存储系统，支持多种数据结构（如字符串、哈希、列表、集合等）。它以内存存储为主，兼具持久化功能，常用于缓存、消息队列、实时数据分析等场景。</p><h2 id="核心特点-1"><a href="#核心特点-1" class="headerlink" title="核心特点"></a>核心特点</h2><p><strong>内存存储</strong>：数据主要存储在内存中，读写速度极快（可达10万次/秒以上）。</p><p><strong>持久化支持</strong>：提供RDB（快照）和AOF（日志）两种方式将数据保存到磁盘。</p><p><strong>数据结构丰富</strong>：支持字符串、哈希、列表、集合、有序集合等，适应不同业务需求。</p><p><strong>高可用性</strong>：通过哨兵（Sentinel）和集群（Cluster）模式实现故障自动转移与横向扩展。</p><h2 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h2><ul><li><strong>缓存加速</strong>：减轻数据库压力，提升网站响应速度。</li><li><strong>会话存储</strong>：分布式系统中共享用户会话信息。</li><li><strong>实时排行榜</strong>：利用有序集合实现分数排序。</li><li><strong>消息队列</strong>：通过列表或Stream结构实现异步任务处理。</li></ul><h2 id="与其他数据库对比"><a href="#与其他数据库对比" class="headerlink" title="与其他数据库对比"></a>与其他数据库对比</h2><ul><li><strong>Redis vs MySQL</strong>：Redis基于内存，适合高速读写；MySQL基于磁盘，适合复杂查询与事务。</li><li><strong>Redis vs Memcached</strong>：Redis支持数据持久化和更多数据结构，Memcached仅支持简单键值且无持久化。</li></ul><p>Redis的灵活性和高性能使其成为现代分布式系统中的重要组件。</p><h1 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h1><p>Nginx（发音为“engine-x”）是一款高性能的开源Web服务器、反向代理服务器、负载均衡器及HTTP缓存工具。最初由俄罗斯开发者Igor Sysoev设计，于2004年首次公开发布，现已成为全球最流行的Web服务器之一。</p><h2 id="Nginx的核心功能"><a href="#Nginx的核心功能" class="headerlink" title="Nginx的核心功能"></a>Nginx的核心功能</h2><p><strong>Web服务器</strong>：Nginx可以高效地处理静态内容（如HTML、CSS、图片），支持高并发连接，资源占用低，适合高流量场景。</p><p><strong>反向代理</strong>：作为反向代理服务器，Nginx可将客户端请求转发至后端多台服务器，隐藏真实服务器信息，提升安全性和可扩展性。</p><p><strong>负载均衡</strong>：支持多种负载均衡算法（如轮询、加权轮询、IP哈希），将流量分配到多台后端服务器，提高系统可用性和性能。</p><p><strong>HTTP缓存</strong>：通过缓存静态或动态内容，减少后端服务器压力，加速响应速度。</p><h2 id="Nginx的特点"><a href="#Nginx的特点" class="headerlink" title="Nginx的特点"></a>Nginx的特点</h2><ul><li><p><strong>事件驱动架构</strong>：基于异步非阻塞模型，支持高并发连接（单机可处理数万并发请求）。</p></li><li><p><strong>模块化设计</strong>：通过模块扩展功能（如支持SSL、gzip压缩、HTTP/2）。</p></li><li><p><strong>低资源消耗</strong>：内存和CPU占用率远低于传统服务器（如Apache）。</p></li><li><p><strong>跨平台</strong>：支持Linux、Windows、macOS等操作系统。</p></li></ul><h2 id="登录验证码流程"><a href="#登录验证码流程" class="headerlink" title="登录验证码流程"></a>登录验证码流程</h2><p>首先通过后端生成一个表达式上传到前端，并且将验证码答案存放在Redis中，用户通过前端登录时将key值和输入答案一起传入数据库。</p><p>登录操作将内容保存在表中 <code>sys_logininfor</code></p><h2 id="进行增删该查操作"><a href="#进行增删该查操作" class="headerlink" title="进行增删该查操作"></a>进行增删该查操作</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801170733602.png" alt="image-20250801170733602"></p><p>单应用在<code>resources</code>目录下的<code>application.yml</code>，多模块<code>ruoyi-generator</code>中的<code>resources</code>目录下的<code>generator.yml</code>，可以自己根据实际情况调整默认配置。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 代码生成</span></span><br><span class="line">gen: </span><br><span class="line">  <span class="meta"># 开发者姓名，生成到类注释上</span></span><br><span class="line">  author: ruoyi</span><br><span class="line">  <span class="meta"># 默认生成包路径 system 需改成自己的模块名称 如 system monitor tool</span></span><br><span class="line">  packageName: com.ruoyi.system</span><br><span class="line">  <span class="meta"># 自动去除表前缀，默认是false</span></span><br><span class="line">  autoRemovePre: <span class="literal">false</span></span><br><span class="line">  <span class="meta"># 表前缀（生成类名不会包含表前缀，多个用逗号分隔）</span></span><br><span class="line">  tablePrefix: sys_</span><br></pre></td></tr></table></figure><h3 id="代码生成使用"><a href="#代码生成使用" class="headerlink" title="代码生成使用"></a>代码生成使用</h3><p>1、登录系统（系统工具 -&gt; 代码生成 -&gt; 导入对应表）</p><p>2、代码生成列表中找到需要表（可预览、编辑、同步、删除生成配置）</p><p>3、点击生成代码会得到一个<code>ruoyi.zip</code>执行<code>sql</code>文件，按照包内目录结构复制到自己的项目中即可</p><p>代码生成支持编辑、预览、同步</p><p>预览：对生成的代码提前预览，防止出现一些不符合预期的情况。</p><p>同步：对原表的字段进行同步，包括新增、删除、修改的字段处理。</p><p>修改：对生成的代码基本信息、字段信息、生成信息做一系列的调整。</p><p>另外多模块所有代码生成的相关业务逻辑代码在<code>ruoyi-generator</code>模块，不需要可以自行删除模块。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="后端部署"><a href="#后端部署" class="headerlink" title="后端部署"></a>后端部署</h4><p>打包工程文件：在工程文件下打开执行bin/package.bat文件进行打包，生成war/jar文件</p><h4 id="前端部署"><a href="#前端部署" class="headerlink" title="前端部署"></a>前端部署</h4><p>当项目开发完毕，只需要运行一行命令就可以打包应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包正式环境</span></span><br><span class="line">npm run build:prod</span><br><span class="line"><span class="comment"># 打包预发布环境</span></span><br><span class="line">npm run build:stage</span><br></pre></td></tr></table></figure><p>构建打包成功之后，会在根目录生成 dist 文件夹，里面就是构建打包好的文件，通常是 <em><strong>.js 、</strong></em>.css、index.html 等静态文件。</p><p>通常情况下 dist 文件夹的静态文件发布到你的 nginx 或者静态服务器即可，其中的 index.html 是后台服务的入口页面。</p><h1 id="快速搭建若依"><a href="#快速搭建若依" class="headerlink" title="快速搭建若依"></a>快速搭建若依</h1><h2 id="前端搭建"><a href="#前端搭建" class="headerlink" title="前端搭建"></a>前端搭建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="后端搭建"><a href="#后端搭建" class="headerlink" title="后端搭建"></a>后端搭建</h2><p>修改数据库和redis的配置。</p><h2 id="代码介绍"><a href="#代码介绍" class="headerlink" title="代码介绍"></a>代码介绍</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801163351287.png" alt="image-20250801163351287"></p><h3 id="ruoyi-quartz"><a href="#ruoyi-quartz" class="headerlink" title="ruoyi-quartz"></a>ruoyi-quartz</h3><p>使用quartz作为定时任务管理，这里不多说，老生常谈的问题。如果想了解可以参考文章：<a href="https://baocl.blog.csdn.net/article/details/106075216">quartz实现定时任务</a></p><h3 id="ruoyi-generator"><a href="#ruoyi-generator" class="headerlink" title="ruoyi-generator"></a>ruoyi-generator</h3><p>该包为代码生成器，主要的流程如下。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801163413997.png" alt="image-20250801163413997"></p><p><strong>GenTableServiceImpl/generatorCode代码生成</strong></p><p>核心代码为该类的方法。主要使用<strong>org.apache.velocity.app</strong>的API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generatorCode</span><span class="params">(String tableName)</span>&#123;</span><br><span class="line">    <span class="comment">// 查询表信息</span></span><br><span class="line">    <span class="type">GenTable</span> <span class="variable">table</span> <span class="operator">=</span> genTableMapper.selectGenTableByName(tableName);</span><br><span class="line">    <span class="comment">// 设置主子表信息</span></span><br><span class="line">    setSubTable(table);</span><br><span class="line">    <span class="comment">// 设置主键列信息</span></span><br><span class="line">    setPkColumn(table);</span><br><span class="line">    VelocityInitializer.initVelocity();</span><br><span class="line">    <span class="type">VelocityContext</span> <span class="variable">context</span> <span class="operator">=</span> VelocityUtils.prepareContext(table);</span><br><span class="line">    <span class="comment">// 获取模板列表</span></span><br><span class="line">    List&lt;String&gt; templates = VelocityUtils.getTemplateList(table.getTplCategory());</span><br><span class="line">    <span class="keyword">for</span> (String template : templates) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.containsAny(template, <span class="string">&quot;sql.vm&quot;</span>, <span class="string">&quot;api.js.vm&quot;</span>, <span class="string">&quot;index.vue.vm&quot;</span>, <span class="string">&quot;index-tree.vue.vm&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// 渲染模板</span></span><br><span class="line">            <span class="type">StringWriter</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">            <span class="type">Template</span> <span class="variable">tpl</span> <span class="operator">=</span> Velocity.getTemplate(template, Constants.UTF8);</span><br><span class="line">            tpl.merge(context, sw);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> getGenPath(table, template);</span><br><span class="line">                FileUtils.writeStringToFile(<span class="keyword">new</span> <span class="title class_">File</span>(path), sw.toString(), CharsetKit.UTF_8);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;渲染模板失败，表名：&quot;</span> + table.getTableName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ruoyi-system"><a href="#ruoyi-system" class="headerlink" title="ruoyi-system"></a>ruoyi-system</h3><p>标准的增删改查方法。没有什么多说的。但是ruoyi项目将controller与service部分隔离开来。</p><h3 id="ruoyi-common"><a href="#ruoyi-common" class="headerlink" title="ruoyi-common"></a>ruoyi-common</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801163603079.png" alt="image-20250801163603079"></p><h4 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h4><p>自定义注解，注解的功能在下方。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801163631130.png" alt="image-20250801163631130"></p><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>获取application.yml中的配置信息，并注入项目bean中。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801163728304.png" alt="image-20250801163728304"></p><h4 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h4><p>为项目提供常量池。</p><h4 id="core"><a href="#core" class="headerlink" title="core"></a>core</h4><p><strong>1.controller</strong>：所有接口层的基类，提供了分页，排序等方法，其他接口类直接继承即可。架构的常用做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseController</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line">    <span class="comment">// 将前台传递过来的日期格式的字符串，自动转化为Date类型</span></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder binder)</span>&#123;</span><br><span class="line">        <span class="comment">// Date 类型转换</span></span><br><span class="line">        binder.registerCustomEditor(Date.class, <span class="keyword">new</span> <span class="title class_">PropertyEditorSupport</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAsText</span><span class="params">(String text)</span>&#123;</span><br><span class="line">                setValue(DateUtils.parseDate(text));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置请求分页数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startPage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PageDomain</span> <span class="variable">pageDomain</span> <span class="operator">=</span> TableSupport.buildPageRequest();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageNum</span> <span class="operator">=</span> pageDomain.getPageNum();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageSize</span> <span class="operator">=</span> pageDomain.getPageSize();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotNull(pageNum) &amp;&amp; StringUtils.isNotNull(pageSize)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">orderBy</span> <span class="operator">=</span> SqlUtil.escapeOrderBySql(pageDomain.getOrderBy());</span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">reasonable</span> <span class="operator">=</span> pageDomain.getReasonable();</span><br><span class="line">            PageHelper.startPage(pageNum, pageSize, orderBy).setReasonable(reasonable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置请求排序数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startOrderBy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PageDomain</span> <span class="variable">pageDomain</span> <span class="operator">=</span> TableSupport.buildPageRequest();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(pageDomain.getOrderBy())) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">orderBy</span> <span class="operator">=</span> SqlUtil.escapeOrderBySql(pageDomain.getOrderBy());</span><br><span class="line">            PageHelper.orderBy(orderBy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 响应请求分页数据</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">protected</span> TableDataInfo <span class="title function_">getDataTable</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">TableDataInfo</span> <span class="variable">rspData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableDataInfo</span>();</span><br><span class="line">        rspData.setCode(HttpStatus.SUCCESS);</span><br><span class="line">        rspData.setMsg(<span class="string">&quot;查询成功&quot;</span>);</span><br><span class="line">        rspData.setRows(list);</span><br><span class="line">        rspData.setTotal(<span class="keyword">new</span> <span class="title class_">PageInfo</span>(list).getTotal());</span><br><span class="line">        <span class="keyword">return</span> rspData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>domain</strong>：权限等架构查询使用的实体类集合，其中<code>BaseEntity、AjaxResult</code>为架构设计经常使用的。BaseEntity需要其他实体类继承，提供了页码、总数等通用字段。AjaxResult是统一返回的实体类，能与前台约定固定的返回格式。<code>&#123;code: message: data&#125;</code>格式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AjaxResult</span> <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;String, Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/** 状态码 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CODE_TAG</span> <span class="operator">=</span> <span class="string">&quot;code&quot;</span>;</span><br><span class="line">    <span class="comment">/** 返回内容 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MSG_TAG</span> <span class="operator">=</span> <span class="string">&quot;msg&quot;</span>;</span><br><span class="line">    <span class="comment">/** 数据对象 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DATA_TAG</span> <span class="operator">=</span> <span class="string">&quot;data&quot;</span>;</span><br><span class="line">    <span class="comment">// 初始化一个新创建的 AjaxResult 对象，使其表示一个空消息。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AjaxResult</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化一个新创建的 AjaxResult 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AjaxResult</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(CODE_TAG, code);</span><br><span class="line">        <span class="built_in">super</span>.put(MSG_TAG, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化一个新创建的 AjaxResult 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AjaxResult</span><span class="params">(<span class="type">int</span> code, String msg, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(CODE_TAG, code);</span><br><span class="line">        <span class="built_in">super</span>.put(MSG_TAG, msg);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotNull(data)) &#123;</span><br><span class="line">            <span class="built_in">super</span>.put(DATA_TAG, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEntity</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/** 搜索值 */</span></span><br><span class="line">    <span class="keyword">private</span> String searchValue;</span><br><span class="line">    <span class="comment">/** 创建者 */</span></span><br><span class="line">    <span class="keyword">private</span> String createBy;</span><br><span class="line">    <span class="comment">/** 创建时间 */</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="comment">/** 更新者 */</span></span><br><span class="line">    <span class="keyword">private</span> String updateBy;</span><br><span class="line">    <span class="comment">/** 更新时间 */</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="comment">/** 备注 */</span></span><br><span class="line">    <span class="keyword">private</span> String remark;</span><br><span class="line">    <span class="comment">/** 请求参数 */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h4><p>封装了一系列的异常，在特定时期使用即可。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801164106581.png" alt="image-20250801164106581"></p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>过滤器，通用写法，如果有使用直接复制即可。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801164146902.png" alt="image-20250801164146902"></p><h4 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h4><p>提供了一大波工具类。如果需要可以直接复制使用。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801164221975.png" alt="image-20250801164221975"></p><h3 id="ruoyi-framework"><a href="#ruoyi-framework" class="headerlink" title="ruoyi-framework"></a>ruoyi-framework</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801164236304.png" alt="image-20250801164236304"></p><h4 id="DataScopeAspect"><a href="#DataScopeAspect" class="headerlink" title="DataScopeAspect"></a>DataScopeAspect</h4><p><strong>1.DataScopeAspect数据权限</strong>：在执行接口时，将当前用户的组织机构等查询条件利用AOP拼接上，可以看到根据在菜单页面维护的数据权限类别进行动态的拼接sql语句。核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dataScopeFilter</span><span class="params">(JoinPoint joinPoint, SysUser user, String deptAlias, String userAlias)</span>&#123;</span><br><span class="line">    <span class="comment">// 拼接sql</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sqlString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (SysRole role : user.getRoles()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dataScope</span> <span class="operator">=</span> role.getDataScope();</span><br><span class="line">        <span class="keyword">if</span> (DATA_SCOPE_ALL.equals(dataScope)) &#123;</span><br><span class="line">            sqlString = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DATA_SCOPE_CUSTOM.equals(dataScope)) &#123; <span class="comment">// 自定义权限拼接</span></span><br><span class="line">            sqlString.append(StringUtils.format(</span><br><span class="line">                <span class="string">&quot; OR &#123;&#125;.dept_id IN ( SELECT dept_id FROM sys_role_dept WHERE role_id = &#123;&#125; ) &quot;</span>,</span><br><span class="line">                deptAlias, role.getRoleId()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DATA_SCOPE_DEPT.equals(dataScope)) &#123; <span class="comment">// 部门权限拼接</span></span><br><span class="line">            sqlString.append(StringUtils.format(<span class="string">&quot; OR &#123;&#125;.dept_id = &#123;&#125; &quot;</span>, deptAlias, user.getDeptId()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DATA_SCOPE_DEPT_AND_CHILD.equals(dataScope)) &#123; <span class="comment">// 部门及以下权限拼接</span></span><br><span class="line">            sqlString.append(StringUtils.format(</span><br><span class="line"><span class="string">&quot; OR &#123;&#125;.dept_id IN ( SELECT dept_id FROM sys_dept WHERE dept_id = &#123;&#125; or find_in_set( &#123;&#125; , ancestors ) )&quot;</span>,</span><br><span class="line">                deptAlias, user.getDeptId(), user.getDeptId()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.DataSourceAspect多数据源</strong>：利用上文DataSource注解动态的切换数据源，如果有需求可以直接使用，固定写法。</p><p><strong>3.LogAspect日志</strong>：全局日志收集，如用户姓名、接口方法、调用ip等，并插入数据库，比较通用功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLog</span><span class="params">(<span class="keyword">final</span> JoinPoint joinPoint, Log controllerLog, </span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> Exception e, Object jsonResult)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前的用户</span></span><br><span class="line">            <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> SecurityUtils.getLoginUser();</span><br><span class="line">            <span class="comment">// *========数据库日志=========*//</span></span><br><span class="line">            <span class="type">SysOperLog</span> <span class="variable">operLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysOperLog</span>();</span><br><span class="line">            operLog.setStatus(BusinessStatus.SUCCESS.ordinal());</span><br><span class="line">            <span class="comment">// 请求的地址</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> IpUtils.getIpAddr(ServletUtils.getRequest());</span><br><span class="line">            operLog.setOperIp(ip);</span><br><span class="line">            operLog.setOperUrl(ServletUtils.getRequest().getRequestURI());</span><br><span class="line">            <span class="comment">//获取用户姓名</span></span><br><span class="line">            <span class="keyword">if</span> (loginUser != <span class="literal">null</span>) &#123;</span><br><span class="line">                operLog.setOperName(loginUser.getUsername());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                operLog.setStatus(BusinessStatus.FAIL.ordinal());</span><br><span class="line">                operLog.setErrorMsg(StringUtils.substring(e.getMessage(), <span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置方法名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">            operLog.setMethod(className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot;()&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置请求方式</span></span><br><span class="line">            operLog.setRequestMethod(ServletUtils.getRequest().getMethod());</span><br><span class="line">            <span class="comment">// 处理设置注解上的参数</span></span><br><span class="line">            getControllerMethodDescription(joinPoint, controllerLog, operLog, jsonResult);</span><br><span class="line">            <span class="comment">// 保存数据库</span></span><br><span class="line">            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exp) &#123;</span><br><span class="line">            <span class="comment">// 记录本地异常日志</span></span><br><span class="line">            log.error(<span class="string">&quot;==前置通知异常==&quot;</span>);</span><br><span class="line">            log.error(<span class="string">&quot;异常信息:&#123;&#125;&quot;</span>, exp.getMessage());</span><br><span class="line">            exp.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RateLimiterAspect限流</strong>：将每一次的调用的ip存放在redis中，然后判断本次调用和上次调用的相隔时间。短时间调用会阻止调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;@annotation(rateLimiter)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint point, RateLimiter rateLimiter)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//redis固定的参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> rateLimiter.key();</span><br><span class="line">    <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> rateLimiter.time();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rateLimiter.count();</span><br><span class="line">    <span class="comment">//获取ip+调用的方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">combineKey</span> <span class="operator">=</span> getCombineKey(rateLimiter, point);</span><br><span class="line">    List&lt;Object&gt; keys = Collections.singletonList(combineKey);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取一定时间内的调用次数</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">number</span> <span class="operator">=</span> redisTemplate.execute(limitScript, keys, count, time);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNull(number) || number.intValue() &gt; count) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;访问过于频繁，请稍候再试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;限制请求&#x27;&#123;&#125;&#x27;,当前请求&#x27;&#123;&#125;&#x27;,缓存key&#x27;&#123;&#125;&#x27;&quot;</span>, count, number.intValue(), key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServiceException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;服务器限流异常，请稍候再试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="config-1"><a href="#config-1" class="headerlink" title="config"></a>config</h4><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801164708417.png" alt="image-20250801164708417"></p><p><strong>1.DruidProperties</strong>：从application.yml中获取数据源信息。固定写法不详细描述。</p><p><strong>2.ApplicationConfig</strong>：配置时区信息这里不详细描述。</p><p><strong>3.CaptchaConfig</strong>：验证码配置，配置文字文本框格式等，固定写法。</p><p><strong>4.DruidConfig</strong>：多数据源配置，固定写法。</p><p><strong>5.FastJson2JsonRedisSerializer</strong>：redis序列化配置，固定写法。</p><p><strong>6.FilterConfig</strong>：过滤器配置，<code>@ConditionalOnProperty(value = &quot;xss.enabled&quot;, havingValue = &quot;true&quot;)</code>根据application.yml是否配置xss.enabled值决定是否加载该类，也就是是否开启xss拦截器。</p><p><strong>7.KaptchaTextCreator</strong>：验证码验证的规则，这里是计算验证码，逻辑在此类中，不详细讲解。</p><p><strong>8.MyBatisConfig</strong>：从application.yml动态获取mybatis包的地址。并重新封装SqlSessionFactory。实现mybatis路径的可配置化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//从application.yml获取配置</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">typeAliasesPackage</span> <span class="operator">=</span> env.getProperty(<span class="string">&quot;mybatis.typeAliasesPackage&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">mapperLocations</span> <span class="operator">=</span> env.getProperty(<span class="string">&quot;mybatis.mapperLocations&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> env.getProperty(<span class="string">&quot;mybatis.configLocation&quot;</span>);</span><br><span class="line">    <span class="comment">//获取实体类的包</span></span><br><span class="line">    typeAliasesPackage = setTypeAliasesPackage(typeAliasesPackage);</span><br><span class="line">    VFS.addImplClass(SpringBootVFS.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">    <span class="comment">//加入数据源</span></span><br><span class="line">    sessionFactory.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">//加入实体类地址</span></span><br><span class="line">    sessionFactory.setTypeAliasesPackage(typeAliasesPackage);</span><br><span class="line">    <span class="comment">//加入mapper</span></span><br><span class="line">    sessionFactory.setMapperLocations(resolveMapperLocations(StringUtils.split(mapperLocations, <span class="string">&quot;,&quot;</span>)));</span><br><span class="line">    <span class="comment">//加入配置文件地址</span></span><br><span class="line">    sessionFactory.setConfigLocation(<span class="keyword">new</span> <span class="title class_">DefaultResourceLoader</span>().getResource(configLocation));</span><br><span class="line">    <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9.RedisConfig</strong>：redis配置固定写法，如果整合redis可以参考。</p><p><strong>10.ResourcesConfig</strong>：通用配置，其中包括拦截器生效配置，跨域配置等 可以直接使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcesConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RepeatSubmitInterceptor repeatSubmitInterceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">/** 本地文件上传路径 */</span></span><br><span class="line">        registry.addResourceHandler(Constants.RESOURCE_PREFIX + <span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;file:&quot;</span> + RuoYiConfig.getProfile() + <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">/** swagger配置 */</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/swagger-ui/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/springfox-swagger-ui/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置拦截器生效</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span>&#123;   <span class="comment">//此处配置了上文点击重复的拦截器</span></span><br><span class="line">        registry.addInterceptor(repeatSubmitInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跨域配置</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        config.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 设置访问源地址</span></span><br><span class="line">        config.addAllowedOriginPattern(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置访问源请求头</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置访问源请求方法</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 有效期 1800秒</span></span><br><span class="line">        config.setMaxAge(<span class="number">1800L</span>);</span><br><span class="line">        <span class="comment">// 添加映射路径，拦截一切请求</span></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">        <span class="comment">// 返回新的CorsFilter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>11.SecurityConfig</strong>：Security的配置，如果想详细了解，请访问博主专栏：<a href="https://blog.csdn.net/qq_20143059/category_11001830.html?spm=1001.2014.3001.5482">Security入门到精通。</a></p><p><strong>12.ServerConfig</strong>：获取请求信息，包括：域名，端口，上下文访问路径</p><p><strong>13.ThreadPoolConfig</strong>：线程池配置，固定配置，其中下文的manager使用了异步线程池。</p><h4 id="datasource"><a href="#datasource" class="headerlink" title="datasource"></a>datasource</h4><p>多数据源固定配置，与DataSourceAspect配合使用。</p><h4 id="interceptor"><a href="#interceptor" class="headerlink" title="interceptor"></a>interceptor</h4><p>主要功能为不允许重复点击，主要实现为将每一次的调用信息组装为key值存放到redis中，每一次调用从redis获取该key数据验证相隔时间，核心代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRepeatSubmit</span><span class="params">(HttpServletRequest request, RepeatSubmit annotation)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">nowParams</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (request <span class="keyword">instanceof</span> RepeatedlyRequestWrapper)&#123;</span><br><span class="line">        <span class="type">RepeatedlyRequestWrapper</span> <span class="variable">repeatedlyRequest</span> <span class="operator">=</span> (RepeatedlyRequestWrapper) request;</span><br><span class="line">        nowParams = HttpHelper.getBodyString(repeatedlyRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// body参数为空，获取Parameter的数据</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(nowParams)) &#123;</span><br><span class="line">        nowParams = JSONObject.toJSONString(request.getParameterMap());</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Object&gt; nowDataMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    nowDataMap.put(REPEAT_PARAMS, nowParams);</span><br><span class="line">    nowDataMap.put(REPEAT_TIME, System.currentTimeMillis());</span><br><span class="line">    <span class="comment">// 请求地址（作为存放cache的key值）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">    <span class="comment">// 唯一值（没有消息头则使用请求地址）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">submitKey</span> <span class="operator">=</span> request.getHeader(header);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(submitKey)) &#123;</span><br><span class="line">        submitKey = url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组装成加入redis的key值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheRepeatKey</span> <span class="operator">=</span> Constants.REPEAT_SUBMIT_KEY + submitKey;</span><br><span class="line">    <span class="comment">//根据key值查询redsi</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sessionObj</span> <span class="operator">=</span> redisCache.getCacheObject(cacheRepeatKey);</span><br><span class="line">    <span class="comment">//如果能够查询到</span></span><br><span class="line">    <span class="keyword">if</span> (sessionObj != <span class="literal">null</span>) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; sessionMap = (Map&lt;String, Object&gt;) sessionObj;</span><br><span class="line">        <span class="keyword">if</span> (sessionMap.containsKey(url)) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; preDataMap = (Map&lt;String, Object&gt;) sessionMap.get(url);</span><br><span class="line">            <span class="comment">// 比对参数，同时比对时间</span></span><br><span class="line">            <span class="keyword">if</span> (compareParams(nowDataMap, preDataMap) </span><br><span class="line">                &amp;&amp; compareTime(nowDataMap, preDataMap, annotation.interval())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Object&gt; cacheMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    cacheMap.put(url, nowDataMap);</span><br><span class="line">    redisCache.setCacheObject(cacheRepeatKey, cacheMap, annotation.interval(), TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h4><p><code>AsyncManager、ShutdownManager</code>为异步工厂提供方法，AsyncFactory为如何使用异步，如果需要使用可以直接在类中参考编写。</p><h4 id="security"><a href="#security" class="headerlink" title="security"></a>security</h4><p><strong>1.JwtAuthenticationTokenFilter</strong>：主要为验证token是否正确，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenService tokenService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                                    HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">                                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 验证用户信息</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> tokenService.getLoginUser(request);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotNull(loginUser) &amp;&amp; StringUtils.isNull(SecurityUtils.getAuthentication()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 刷新token</span></span><br><span class="line">            tokenService.verifyToken(loginUser);</span><br><span class="line">            <span class="comment">// 获取用户权限对象</span></span><br><span class="line">            <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">                <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line">            authenticationToken.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">            <span class="comment">// 将用户权限等信息存放在SecurityContext中</span></span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.AuthenticationEntryPointImpl、LogoutSuccessHandlerImpl</strong>：将调用信息转换为json返回的固定写法。如果有需要可以参考。</p><h4 id="web"><a href="#web" class="headerlink" title="web"></a>web</h4><p><strong>1.server</strong>：获取服务器信息，如cpu等，都是固定写法，如需参考直接复制即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setCpuInfo</span><span class="params">(CentralProcessor processor)</span> &#123;</span><br><span class="line">    <span class="comment">// CPU信息</span></span><br><span class="line">    <span class="type">long</span>[] prevTicks = processor.getSystemCpuLoadTicks();</span><br><span class="line">    Util.sleep(OSHI_WAIT_SECOND);</span><br><span class="line">    <span class="type">long</span>[] ticks = processor.getSystemCpuLoadTicks();</span><br><span class="line">    <span class="type">long</span> <span class="variable">nice</span> <span class="operator">=</span> ticks[TickType.NICE.getIndex()] - prevTicks[TickType.NICE.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">irq</span> <span class="operator">=</span> ticks[TickType.IRQ.getIndex()] - prevTicks[TickType.IRQ.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">softirq</span> <span class="operator">=</span> ticks[TickType.SOFTIRQ.getIndex()] - prevTicks[TickType.SOFTIRQ.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">steal</span> <span class="operator">=</span> ticks[TickType.STEAL.getIndex()] - prevTicks[TickType.STEAL.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">cSys</span> <span class="operator">=</span> ticks[TickType.SYSTEM.getIndex()] - prevTicks[TickType.SYSTEM.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">user</span> <span class="operator">=</span> ticks[TickType.USER.getIndex()] - prevTicks[TickType.USER.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">iowait</span> <span class="operator">=</span> ticks[TickType.IOWAIT.getIndex()] - prevTicks[TickType.IOWAIT.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">idle</span> <span class="operator">=</span> ticks[TickType.IDLE.getIndex()] - prevTicks[TickType.IDLE.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">totalCpu</span> <span class="operator">=</span> user + nice + cSys + idle + iowait + irq + softirq + steal;</span><br><span class="line">    cpu.setCpuNum(processor.getLogicalProcessorCount());</span><br><span class="line">    cpu.setTotal(totalCpu);</span><br><span class="line">    cpu.setSys(cSys);</span><br><span class="line">    cpu.setUsed(user);</span><br><span class="line">    cpu.setWait(iowait);</span><br><span class="line">    cpu.setFree(idle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置内存信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMemInfo</span><span class="params">(GlobalMemory memory)</span> &#123;</span><br><span class="line">    mem.setTotal(memory.getTotal());</span><br><span class="line">    mem.setUsed(memory.getTotal() - memory.getAvailable());</span><br><span class="line">    mem.setFree(memory.getAvailable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.exception</strong>：<code>@RestControllerAdvice、@ExceptionHandler</code>全局的拦截异常，当系统中有异常时，该类会直接获取异常并输出，很多类就不用特意try catch了。架构的常用写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line">    <span class="comment">// 权限校验异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(AccessDeniedException.class)</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">handleAccessDeniedException</span><span class="params">(AccessDeniedException e, HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.error(<span class="string">&quot;请求地址&#x27;&#123;&#125;&#x27;,权限校验失败&#x27;&#123;&#125;&#x27;&quot;</span>, requestURI, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> AjaxResult.error(HttpStatus.FORBIDDEN, <span class="string">&quot;没有权限，请联系管理员授权&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求方式不支持</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(HttpRequestMethodNotSupportedException.class)</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">handleHttpRequestMethodNotSupported</span><span class="params">(HttpRequestMethodNotSupportedException e,</span></span><br><span class="line"><span class="params">            HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.error(<span class="string">&quot;请求地址&#x27;&#123;&#125;&#x27;,不支持&#x27;&#123;&#125;&#x27;请求&quot;</span>, requestURI, e.getMethod());</span><br><span class="line">        <span class="keyword">return</span> AjaxResult.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.service</strong>：权限相关的service。大部分都是curd的业务，这里详细说TokenService。TokenService使用jwt生成token、从token中获取数据等。大部分为jwt固定写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从数据声明生成令牌 @param claims 数据声明 @return 令牌</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">createToken</span><span class="params">(Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">            .setClaims(claims)</span><br><span class="line">            .signWith(SignatureAlgorithm.HS512, secret).compact();</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从令牌中获取数据声明 @param token 令牌 @return 数据声明</span></span><br><span class="line"><span class="keyword">private</span> Claims <span class="title function_">parseToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">            .setSigningKey(secret)</span><br><span class="line">            .parseClaimsJws(token)</span><br><span class="line">            .getBody();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ruoyi-admin"><a href="#ruoyi-admin" class="headerlink" title="ruoyi-admin"></a>ruoyi-admin</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250801165556243.png" alt="image-20250801165556243"></p><h4 id="common通用方法"><a href="#common通用方法" class="headerlink" title="common通用方法"></a>common通用方法</h4><p><strong>CaptchaController</strong>：获取验证码通过API生成验证码。详细代码不进行讲解。</p><p><strong>CommonController</strong>：通用的上传下载接口，如果需要直接使用即可。</p><h4 id="monitor监控"><a href="#monitor监控" class="headerlink" title="monitor监控"></a>monitor监控</h4><p><strong>1.CacheController监控redis</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;monitor:cache:list&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping()</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">getInfo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// redis的常用信息</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> (Properties) redisTemplate.execute(</span><br><span class="line">            (RedisCallback&lt;Object&gt;) connection -&gt; connection.info()</span><br><span class="line">        );</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">commandStats</span> <span class="operator">=</span> (Properties) redisTemplate.execute(</span><br><span class="line">            (RedisCallback&lt;Object&gt;) connection -&gt; connection.info(<span class="string">&quot;commandstats&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// rediskey数量</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">dbSize</span> <span class="operator">=</span> redisTemplate.execute((RedisCallback&lt;Object&gt;) connection -&gt; connection.dbSize());</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        result.put(<span class="string">&quot;info&quot;</span>, info);</span><br><span class="line">        result.put(<span class="string">&quot;dbSize&quot;</span>, dbSize);</span><br><span class="line">        <span class="comment">// key的详细信息</span></span><br><span class="line">        List&lt;Map&lt;String, String&gt;&gt; pieList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        commandStats.stringPropertyNames().forEach(key -&gt; &#123;</span><br><span class="line">            Map&lt;String, String&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> commandStats.getProperty(key);</span><br><span class="line">            data.put(<span class="string">&quot;name&quot;</span>, StringUtils.removeStart(key, <span class="string">&quot;cmdstat_&quot;</span>));</span><br><span class="line">            data.put(<span class="string">&quot;value&quot;</span>, StringUtils.substringBetween(property, <span class="string">&quot;calls=&quot;</span>, <span class="string">&quot;,usec&quot;</span>));</span><br><span class="line">            pieList.add(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        result.put(<span class="string">&quot;commandStats&quot;</span>, pieList);</span><br><span class="line">        <span class="keyword">return</span> AjaxResult.success(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.ServerController服务器监控</strong>：主要监控正在运行服务器的信息，核心代码如下，如果需要使用直接复制即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyTo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">SystemInfo</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemInfo</span>();</span><br><span class="line">    <span class="type">HardwareAbstractionLayer</span> <span class="variable">hal</span> <span class="operator">=</span> si.getHardware();</span><br><span class="line">    setCpuInfo(hal.getProcessor());</span><br><span class="line">    setMemInfo(hal.getMemory());</span><br><span class="line">    setSysInfo();</span><br><span class="line">    setJvmInfo();</span><br><span class="line">    setSysFiles(si.getOperatingSystem());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置CPU信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setCpuInfo</span><span class="params">(CentralProcessor processor)</span> &#123;</span><br><span class="line">    <span class="comment">// CPU信息</span></span><br><span class="line">    <span class="type">long</span>[] prevTicks = processor.getSystemCpuLoadTicks();</span><br><span class="line">    Util.sleep(OSHI_WAIT_SECOND);</span><br><span class="line">    <span class="type">long</span>[] ticks = processor.getSystemCpuLoadTicks();</span><br><span class="line">    <span class="type">long</span> <span class="variable">nice</span> <span class="operator">=</span> ticks[TickType.NICE.getIndex()] - prevTicks[TickType.NICE.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">irq</span> <span class="operator">=</span> ticks[TickType.IRQ.getIndex()] - prevTicks[TickType.IRQ.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">softirq</span> <span class="operator">=</span> ticks[TickType.SOFTIRQ.getIndex()] - prevTicks[TickType.SOFTIRQ.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">steal</span> <span class="operator">=</span> ticks[TickType.STEAL.getIndex()] - prevTicks[TickType.STEAL.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">cSys</span> <span class="operator">=</span> ticks[TickType.SYSTEM.getIndex()] - prevTicks[TickType.SYSTEM.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">user</span> <span class="operator">=</span> ticks[TickType.USER.getIndex()] - prevTicks[TickType.USER.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">iowait</span> <span class="operator">=</span> ticks[TickType.IOWAIT.getIndex()] - prevTicks[TickType.IOWAIT.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">idle</span> <span class="operator">=</span> ticks[TickType.IDLE.getIndex()] - prevTicks[TickType.IDLE.getIndex()];</span><br><span class="line">    <span class="type">long</span> <span class="variable">totalCpu</span> <span class="operator">=</span> user + nice + cSys + idle + iowait + irq + softirq + steal;</span><br><span class="line">    cpu.setCpuNum(processor.getLogicalProcessorCount());</span><br><span class="line">    cpu.setTotal(totalCpu);</span><br><span class="line">    cpu.setSys(cSys);</span><br><span class="line">    cpu.setUsed(user);</span><br><span class="line">    cpu.setWait(iowait);</span><br><span class="line">    cpu.setFree(idle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置内存信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMemInfo</span><span class="params">(GlobalMemory memory)</span> &#123;</span><br><span class="line">    mem.setTotal(memory.getTotal());</span><br><span class="line">    mem.setUsed(memory.getTotal() - memory.getAvailable());</span><br><span class="line">    mem.setFree(memory.getAvailable());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置服务器信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setSysInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> System.getProperties();</span><br><span class="line">    sys.setComputerName(IpUtils.getHostName());</span><br><span class="line">    sys.setComputerIp(IpUtils.getHostIp());</span><br><span class="line">    sys.setOsName(props.getProperty(<span class="string">&quot;os.name&quot;</span>));</span><br><span class="line">    sys.setOsArch(props.getProperty(<span class="string">&quot;os.arch&quot;</span>));</span><br><span class="line">    sys.setUserDir(props.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置Java虚拟机</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setJvmInfo</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> System.getProperties();</span><br><span class="line">    jvm.setTotal(Runtime.getRuntime().totalMemory());</span><br><span class="line">    jvm.setMax(Runtime.getRuntime().maxMemory());</span><br><span class="line">    jvm.setFree(Runtime.getRuntime().freeMemory());</span><br><span class="line">    jvm.setVersion(props.getProperty(<span class="string">&quot;java.version&quot;</span>));</span><br><span class="line">    jvm.setHome(props.getProperty(<span class="string">&quot;java.home&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置磁盘信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setSysFiles</span><span class="params">(OperatingSystem os)</span> &#123;</span><br><span class="line">    <span class="type">FileSystem</span> <span class="variable">fileSystem</span> <span class="operator">=</span> os.getFileSystem();</span><br><span class="line">    List&lt;OSFileStore&gt; fsArray = fileSystem.getFileStores();</span><br><span class="line">    <span class="keyword">for</span> (OSFileStore fs : fsArray)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">free</span> <span class="operator">=</span> fs.getUsableSpace();</span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> fs.getTotalSpace();</span><br><span class="line">        <span class="type">long</span> <span class="variable">used</span> <span class="operator">=</span> total - free;</span><br><span class="line">        <span class="type">SysFile</span> <span class="variable">sysFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysFile</span>();</span><br><span class="line">        sysFile.setDirName(fs.getMount());</span><br><span class="line">        sysFile.setSysTypeName(fs.getType());</span><br><span class="line">        sysFile.setTypeName(fs.getName());</span><br><span class="line">        sysFile.setTotal(convertFileSize(total));</span><br><span class="line">        sysFile.setFree(convertFileSize(free));</span><br><span class="line">        sysFile.setUsed(convertFileSize(used));</span><br><span class="line">        sysFile.setUsage(Arith.mul(Arith.div(used, total, <span class="number">4</span>), <span class="number">100</span>));</span><br><span class="line">        sysFiles.add(sysFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.SysLogininforController，SysOperlogController 登录日志、操作日志</strong>：主要查询前文AOP生成的日志表，普通的增删改查。</p><p><strong>4.SysUserOnlineController在线用户管理</strong>：主要功能为在线用户监控与强踢下线。通过查询和删除redis缓存即可实现。</p><h4 id="system业务代码"><a href="#system业务代码" class="headerlink" title="system业务代码"></a>system业务代码</h4><p>这里都是系统管理业务代码，写法比较统一，但是在编写过程中有部分架构的规定，下面一一说明。</p><p>**1.@PreAuthorize(“@ss.hasPermi(‘system:dict:list’)”)**：权限注解，上文已经详解</p><p><strong>2.AjaxResult</strong>：提供了 结果编码/调用信息/数据的返回格式，为前台提供了统一的返回格式。架构的基础组成部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AjaxResult</span> <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;String, Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/** 状态码 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CODE_TAG</span> <span class="operator">=</span> <span class="string">&quot;code&quot;</span>;</span><br><span class="line">    <span class="comment">/** 返回内容 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MSG_TAG</span> <span class="operator">=</span> <span class="string">&quot;msg&quot;</span>;</span><br><span class="line">    <span class="comment">/** 数据对象 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DATA_TAG</span> <span class="operator">=</span> <span class="string">&quot;data&quot;</span>;</span><br><span class="line">    <span class="comment">// 初始化一个新创建的 AjaxResult 对象，使其表示一个空消息。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AjaxResult</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 初始化一个新创建的 AjaxResult 对象 @param code 状态码 @param msg 返回内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AjaxResult</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(CODE_TAG, code);</span><br><span class="line">        <span class="built_in">super</span>.put(MSG_TAG, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化一个新创建的 AjaxResult 对象 @param code 状态码 @param msg 返回内容 @param data 数据对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AjaxResult</span><span class="params">(<span class="type">int</span> code, String msg, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(CODE_TAG, code);</span><br><span class="line">        <span class="built_in">super</span>.put(MSG_TAG, msg);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotNull(data)) &#123;</span><br><span class="line">            <span class="built_in">super</span>.put(DATA_TAG, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回成功消息 @return 成功消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AjaxResult <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AjaxResult.success(<span class="string">&quot;操作成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.extends BaseController</strong>：上文介绍了<code>BaseController</code>，在这里使用就可以直接调用分页、排序等方法了。不用每个类都编写。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ruoyi框架搭建方便，依赖组件非常少。同时提供了基本的业务功能，如用户管理、部门管理、代码生成器等，但是对于技术的深度还是不太到位，如mq的使用，安全框架等技术都没有特多的涉及。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;若依框架（RuoYi）是一套基于Java开发的快速开发框架，它提供了许多常用的功能模块和工具，包括用户管理、部门管理、角色管理、菜单管理、字典管理、系统监控、定时任务等。若依框架采用了MVC（Model-View-Controller）的架构模式，使用了Spring Boo</summary>
      
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    
    <category term="RuoYi" scheme="https://southernfish.github.io/tags/RuoYi/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis-Plus</title>
    <link href="https://southernfish.github.io/pages/framwork/mybatis-plus/"/>
    <id>https://southernfish.github.io/pages/framwork/mybatis-plus/</id>
    <published>2025-07-30T05:20:36.000Z</published>
    <updated>2025-09-20T11:18:48.140Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis-Plus和MyBatis是共生的，而非替代品。MyBatis-Plus只做增强不做改变，引入它不会对现有工程产生影响。其会在启动时自动注入基本CRUD(增删改查)，性能基本无损耗，直接面向对象操作，使得开发人员能够更加方便地进行数据库操作。</p><blockquote><p>官网地址：<a href="https://baomidou.com/">Mybatis-Plus</a></p><p>参考文章：<a href="https://blog.csdn.net/NingMaoKing/article/details/147305430">Mybtis和Mybatis-Plus区别</a>、<a href="https://blog.csdn.net/qq_40991313/article/details/126470047">MyBatisPlus基础</a></p><p>推荐文章：<a href="https://blog.csdn.net/a370300020/article/details/112461506">MyBatis Plus 讲解</a></p></blockquote><h1 id="Mybatis-Plus-简介"><a href="#Mybatis-Plus-简介" class="headerlink" title="Mybatis-Plus 简介"></a>Mybatis-Plus 简介</h1><h2 id="MP架构"><a href="#MP架构" class="headerlink" title="MP架构"></a>MP架构</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250731220225906.png" alt="image-20250731220225906"></p><h2 id="MP的特性"><a href="#MP的特性" class="headerlink" title="MP的特性"></a>MP的特性</h2><ul><li><strong>无侵入：只做增强不做改变</strong>，不会对现有工程产生影响</li><li><strong>强大的 CRUD 操作：</strong>内置通用 Mapper，少量配置即可实现单表CRUD 操作</li><li>支持 Lambda：编写查询条件无需担心字段写错</li><li><strong>支持主键五种自动生成策略</strong></li><li><strong>内置分页插件、代码生成器、全局拦截插件、sql注入剥离器</strong>（支持sql注入剥离，防止SQL注入攻击）</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li><p><strong>导入mybatis-plus-boot-starter依赖</strong>，dao继承BaseMapper&lt;实体类名&gt;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>说明:</strong></p><ul><li>druid数据源可以加也可以不加，SpringBoot有内置的数据源，可以配置成使用Druid数据源</li><li>从MP的依赖关系可以看出，通过依赖传递已经<strong>将MyBatis与MyBatis整合Spring的jar包导入，我们不需要额外在添加MyBatis的相关jar包</strong></li></ul></blockquote></li><li><p><strong>加MP的相关配置信息</strong></p><p>resources默认生成的是properties配置文件，可以将其<strong>替换成yml文件</strong>，并在文件中配置<strong>数据库连接的相关信息</strong>:<code>application.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment">#serverTimezone是用来设置时区，UTC是标准时区，和咱们的时间差8小时，所以可以将其修改为Asia/Shanghai</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC</span> </span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：如果需要导入druid专有属性，就必须换依赖和配置方法了：</strong>pom.xml</p><p>导入了druid-spring-boot-starter依赖，就<strong>不用再导入druid依赖了</strong>，它里面包含了与druid相关的配置超过200条以上</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"> <span class="attr">druid:</span></span><br><span class="line">   <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">   <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">   <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">   <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>mp在实体类的注解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注解了lombok的@Data会自动生成getter,setter,toString方法</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">// 一般数据库表名tbl_user，这里注解@TableName(&quot;tbl_user&quot;)，就可以对应上表名</span></span><br><span class="line"><span class="comment">// 毕竟mp的语句里没有指定表名，都是在数据库中搜索和首字母小的的实体类名对应的表的。</span></span><br><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 设置主键自增策略为auto，mp默认自增策略是ASSIGN_ID，分布式、雪花算法。自增策略也可以在yml中全局配置。</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// value属性起别名，select设置该字段是否参与查询，针对于一些密码等隐私数据不希望被查出来</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;password&quot;,select = false)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String tel;</span><br><span class="line">    <span class="comment">// exist属性设置是否在数据库中存在该字段</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String online;</span><br><span class="line">    <span class="comment">// 乐观锁注解版本，需要搭配乐观拦截器</span></span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">    <span class="comment">// 逻辑删除，本质是更新，数据库内该字段默认是0，通过标记为1来判定删除。</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer delete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Lombok常见的注解有</strong>:</p><p><code>@Setter</code>：为模型类的属性提供setter方法<br><code>@Getter</code>：为模型类的属性提供getter方法<br><code>@ToString</code>：为模型类的属性提供toString方法<br><code>@EqualsAndHashCode</code>：为模型类的属性提供equals和hashcode方法<br><code>@Data</code>：是个组合注解，包含Setter、Getter、ToString、EqualsAndHashCode<br><code>@NoArgsConstructor</code>：提供一个无参构造函数<br><code>@AllArgsConstructor</code>：提供一个包含所有参数的构造函数</p></li><li><p>**创建Dao接口，继承 基础mapper：BaseMapper<User>**。继承之后dao类多出了很多方法如selectById……</p></li><li><p><strong>编写引导类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//@MapperScan(&quot;com.itheima.dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mybatisplus01QuickstartApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Mybatisplus01QuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Dao接口要想被容器扫描到，有两种解决方案:</p><ol><li>在Dao接口上添加@Mapper注解，并且确保Dao处在引导类所在包或其子包中。需要在每一Dao接口中添加注解</li><li>在引导类上添加@MapperScan注解，其属性为所要扫描的Dao所在包。只需要写一次，则指定包下的所有Dao接口都能被扫描到，@Mapper就可以不写。</li></ol></blockquote></li></ol><p><strong>userDao注入的时候下面有红线提示的原因是什么?</strong></p><p>UserDao是一个接口，不能实例化对象，只有在服务器启动IOC容器初始化后，由框架创建DAO接口的代理对象来注入。服务器并未启动，代理对象也未创建，IDEA查找不到对应的对象注入就会提示报红。一旦服务启动，就能注入其代理对象，故该提示不影响正常运行。</p><p>跟之前整合MyBatis相比，<strong>不需要在DAO接口中编写方法和SQL语句了，只需要继承<code>BaseMapper</code>接口即可。</strong>整体来说简化很多。</p><hr><h1 id="DQL编程控制"><a href="#DQL编程控制" class="headerlink" title="DQL编程控制"></a>DQL编程控制</h1><h2 id="条件查询的Wrapper包装器类"><a href="#条件查询的Wrapper包装器类" class="headerlink" title="条件查询的Wrapper包装器类"></a>条件查询的Wrapper包装器类</h2><p>MyBatisPlus将书写复杂的SQL查询条件进行了封装，使用编程的形式完成查询条件的组合。<strong>包装器Wrapper<T>是接口</strong>，实际开发中主要使用它的两个实现类：<strong>QueryWrapper和LambdaQueryWrapper</strong>。两种方式各有优劣：</p><ul><li><strong>QueryWrapper存在属性名写错的危险，但是支持聚合、分组查询；</strong></li><li><strong>LambdaQueryWrapper没有属性名写错的危险，但不支持聚合、分组查询；</strong></li></ul><h2 id="基本比较操作"><a href="#基本比较操作" class="headerlink" title="基本比较操作"></a>基本比较操作</h2><table><thead><tr><th>方法</th><th>说明</th><th>方法</th><th>说明</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>eq</td><td>等于 =</td><td>ge</td><td>大于等于 &gt;=</td><td>notBetween</td><td>NOT BETWEEN 值1 AND 值2</td></tr><tr><td>alleq</td><td>全部<a href="https://www.baomidou.com/pages/10c804/#eq">eq</a>(或个别<a href="https://www.baomidou.com/pages/10c804/#isnull">isNull</a>)</td><td>It</td><td>小于 &lt;</td><td>in</td><td>字段 IN (value.get(0), value.get(1), …)**</td></tr><tr><td>ne</td><td>不等于 &lt;&gt;</td><td>le</td><td>小于等于 &lt;=</td><td>notIn</td><td>字段 NOT IN (v0, v1, …)</td></tr><tr><td>gt</td><td>大于 &gt;</td><td>between</td><td>BETWEEN 值1 AND 值2</td><td></td><td></td></tr></tbody></table><h2 id="构建条件查询"><a href="#构建条件查询" class="headerlink" title="构建条件查询"></a>构建条件查询</h2><ol><li><p>查询包装器QueryWrapper（不建议）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建QueryWrapper对象</span></span><br><span class="line"><span class="type">QueryWrapper</span> <span class="variable">qw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line"><span class="comment">//lt代表小于，大于是gt</span></span><br><span class="line">qw.lt(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>); <span class="comment">// 属性名写错就错了</span></span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(qw);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,password,age,tel <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> (age <span class="operator">&lt;</span> ?)</span><br></pre></td></tr></table></figure></li><li><p>QueryWrapper的基础上使用lambda（不建议）。可以<strong>防止数据库属性名写错</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda，QueryWrapper&lt;User&gt;必须加泛型</span></span><br><span class="line">QueryWrapper&lt;User&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">qw.lambda().lt(User::getAge, <span class="number">10</span>);<span class="comment">// 添加条件，使用Lambda不容易写错属性名</span></span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(qw);</span><br></pre></td></tr></table></figure><p>User::getAget,为lambda表达式中的，类名::方法名，最终的sql语句为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,password,age,tel <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> (age <span class="operator">&lt;</span> ?)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>构建LambdaQueryWrapper的时候泛型不能省。</p></li><li><p><strong>LambdaQueryWrapper（推荐）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">lqw.lt(User::getAge, <span class="number">30</span>);</span><br><span class="line">lqw.gt(User::getAge, <span class="number">10</span>);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,password,age,tel <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> (age <span class="operator">&lt;</span> ? <span class="keyword">AND</span> age <span class="operator">&gt;</span> ?)</span><br></pre></td></tr></table></figure></li></ol><h2 id="多条件构建，链式编程"><a href="#多条件构建，链式编程" class="headerlink" title="多条件构建，链式编程"></a>多条件构建，链式编程</h2><p>构建多条件的时候，可以支持<strong>链式编程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line"><span class="comment">// 多条件查询默认是and，or要用.or() </span></span><br><span class="line">lqw.lt(User::getAge, <span class="number">30</span>).gt(User::getAge, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// lqw.lt(User::getAge, 30).or().gt(User::getAge, 10);</span></span><br><span class="line"><span class="comment">// SELECT id,name,password,age,tel FROM user WHERE (age &lt; ? OR age &gt; ?)</span></span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure><h2 id="条件查询null值处理"><a href="#条件查询null值处理" class="headerlink" title="条件查询null值处理"></a>条件查询null值处理</h2><p><strong>针对问题</strong>：区间条件查询，例如某宝筛选价格范围，用户只填最高价，最低价为null不算在查询条件里。 </p><p><strong>解决办法</strong>：新建实体类继承原实体类，多出属性范围，使用<code>lqw.lt(null!=uq.getAge2(),User::getAge, uq.getAge2());</code>判定。</p><p><strong>后台如果想接收前端的两个数据，该如何接收?</strong></p><p>一般使用的参数类只有一个age属性，接收页面上的两个值有两个解决方案：</p><ol><li><p><strong>添加属性age2</strong>,这种做法可以但是会影响到原模型类的属性内容（不推荐）</p></li><li><p><strong>在domain.query下新建一个模型类继承User类</strong>，并为其添加age2属性，UserQuery在拥有User属性和age2属性。（推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟页面传递过来的查询数据</span></span><br><span class="line"><span class="type">UserQuery</span> <span class="variable">uq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserQuery</span>();</span><br><span class="line">uq.setAge(<span class="number">10</span>);</span><br><span class="line">uq.setAge2(<span class="number">30</span>);</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line"><span class="comment">// lt(boolean condition, SFunction&lt;User,?&gt;column, Object val)</span></span><br><span class="line"><span class="comment">// 第一个参数为判断条件condition为boolean类型，返回true，则添加条件，返回false则不添加条件</span></span><br><span class="line">lqw.lt(<span class="literal">null</span>!=uq.getAge2(), User::getAge, uq.getAge2());</span><br><span class="line">lqw.gt(<span class="literal">null</span>!=uq.getAge(), User::getAge, uq.getAge());</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br></pre></td></tr></table></figure></li></ol><h2 id="查询投影"><a href="#查询投影" class="headerlink" title="查询投影"></a>查询投影</h2><h3 id="查询指定字段"><a href="#查询指定字段" class="headerlink" title="查询指定字段"></a>查询指定字段</h3><p><strong>查询投影：</strong>不查询所有字段，**只查询出指定字段的数据。查询指定字段lqw.select()**。</p><ol><li><p><strong>使用Lambda（推荐）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">lqw.select(User::getId,User::getName,User::getAge);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br></pre></td></tr></table></figure><p>select(…)方法用来设置查询的字段列，可以设置多个，最终的sql语句为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,age <span class="keyword">FROM</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure></li><li><p>不用Lambda（不推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">lqw.select(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;tel&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,age,tel <span class="keyword">FROM</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><p><strong>聚合查询不能用Lambda，只能用QueryWrapper。方法qw.select(“count(*) as count”);和userDao.selectMaps(qw)</strong></p><blockquote><p>聚合函数查询</p><p>count：总记录数，max：最大值，min：最小值，avg：平均值，sum：求和</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line"><span class="comment">//lqw.select(&quot;count(*) as count&quot;);</span></span><br><span class="line"><span class="comment">//SELECT count(*) as count FROM user</span></span><br><span class="line"><span class="comment">//lqw.select(&quot;max(age) as maxAge&quot;);</span></span><br><span class="line"><span class="comment">//SELECT max(age) as maxAge FROM user</span></span><br><span class="line"><span class="comment">//lqw.select(&quot;min(age) as minAge&quot;);</span></span><br><span class="line"><span class="comment">//SELECT min(age) as minAge FROM user</span></span><br><span class="line"><span class="comment">//lqw.select(&quot;sum(age) as sumAge&quot;);</span></span><br><span class="line"><span class="comment">//SELECT sum(age) as sumAge FROM user</span></span><br><span class="line">lqw.select(<span class="string">&quot;avg(age) as avgAge&quot;</span>);</span><br><span class="line"><span class="comment">//SELECT avg(age) as avgAge FROM user</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; userList = userDao.selectMaps(lqw);</span><br></pre></td></tr></table></figure><h3 id="分组查询-group-by"><a href="#分组查询-group-by" class="headerlink" title="分组查询(group by)"></a>分组查询(group by)</h3><blockquote><p><strong>注意：分组查询一定是要配合聚合函数的</strong></p><ul><li>聚合与分组查询，无法使用lambda表达式来完成</li><li>MP只是对MyBatis的增强，<strong>如果MP实现不了，可以直接在DAO接口中使用MyBatis的方式实现</strong></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">lqw.select(<span class="string">&quot;count(*) as count,tel&quot;</span>);</span><br><span class="line">lqw.groupBy(<span class="string">&quot;tel&quot;</span>);</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; list = userDao.selectMaps(lqw);</span><br></pre></td></tr></table></figure><p>groupBy为分组，最终的sql语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> count,tel <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> tel</span><br></pre></td></tr></table></figure><h2 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h2><p>除了 lt() 和 gt() 这两个方法外，MP的查询条件有很多，使用方法参见<a href="https://baomidou.com/guides/wrapper/">条件构造器</a></p><ul><li>等值匹配（eq）：<strong>eq()： equal的缩小，相当于 <code>=</code></strong></li><li>范围匹配（&gt; 、 = 、between）</li><li>模糊匹配（like）:<ul><li><strong>like()：前后加百分号</strong>，如 %J%</li><li><strong>likeLeft()：左边加百分号</strong>，如 %J</li><li>likeRight()：后面加百分号，如 J%</li></ul></li><li>空判定（null）</li><li>包含性匹配（in）</li><li>分组（group）</li><li>排序（order）<ul><li><strong>orderBy排序</strong><ul><li>condition:条件，true则添加排序，false则不添加排序</li><li>isAsc:是否为升序，true升序，false降序</li><li>columns:排序字段，可以有多个</li></ul></li><li>**orderByAsc/Desc(单个column):**按照指定字段进行升序/降序</li><li>**orderByAsc/Desc(多个column):**按照多个字段进行升序/降序</li><li><strong>orderByAsc/Desc</strong><ul><li>condition:条件，true添加排序，false不添加排序</li><li>多个columns：按照多个字段进行排序</li></ul></li></ul></li></ul><p>MP的查询结果形式：</p><ul><li><strong>selectList：</strong>查询结果为多个或者单个</li><li>**selectOne:**查询结果为单个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.等值查询</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">lqw.eq(User::getName, <span class="string">&quot;Jerry&quot;</span>).eq(User::getPassword, <span class="string">&quot;jerry&quot;</span>);</span><br><span class="line"><span class="comment">// SELECT id,name,password,age,tel FROM user WHERE (name = ? AND password = ?)</span></span><br><span class="line"><span class="type">User</span> <span class="variable">loginUser</span> <span class="operator">=</span> userDao.selectOne(lqw);</span><br><span class="line"><span class="comment">// 2.范围查询</span></span><br><span class="line">lqw.between(User::getAge, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">// SELECT id,name,password,age,tel FROM user WHERE (age BETWEEN ? AND ?)</span></span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line"><span class="comment">// 3.模糊查询</span></span><br><span class="line">lqw.likeLeft(User::getName, <span class="string">&quot;J&quot;</span>);</span><br><span class="line"><span class="comment">// SELECT id,name,password,age,tel FROM user WHERE (name LIKE ?)</span></span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line"><span class="comment">// 4.排序查询</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * condition ：条件，返回boolean，当condition为true，进行排序，如果为false，则不排序</span></span><br><span class="line"><span class="comment"> * isAsc:是否为升序，true为升序，false为降序</span></span><br><span class="line"><span class="comment"> * columns：需要操作的列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">lwq.orderBy(<span class="literal">true</span>,<span class="literal">false</span>, User::getId);</span><br><span class="line">userDao.selectList(lwq);</span><br></pre></td></tr></table></figure><h2 id="映射匹配兼容性"><a href="#映射匹配兼容性" class="headerlink" title="映射匹配兼容性"></a>映射匹配兼容性</h2><p>属性起别名、可见性、权限、表明和实体类名不匹配。</p><p><strong>问题1:表字段与编码属性设计不同步</strong></p><p>表的列名和模型类的属性名发生不一致，就会导致数据封装不到模型对象</p><p><strong>解决：<code>@TableField字段注解</code>里的value属性起别名</strong></p><p><strong>问题2:编码中添加了数据库中未定义的属性</strong></p><p>当模型类中多了一个数据库表不存在的字段，就会导致生成的sql语句中在select的时候查询了数据库不存在的字段，程序运行就会报错，错误信息为：Unknown column ‘多出来的字段名称’ in ‘field list’</p><p><strong>解决：<code>@TableField</code>注解里的exist属性设置其是否在数据库存在</strong>，设置为false则不存在，生成sql查询时，不会再查询该字段。</p><p><strong>问题3：采用默认查询开放了更多的字段查看权限</strong></p><p>查询表中所有的列的数据时可能把敏感数据查询到返回给前端，这时候就需要限制哪些字段默认不要进行查询。</p><p><strong>解决：<code>@TableField</code>注解里的select属性，设置属性是否参与查询</strong>，该属性设置默认是否需要查询该字段的值，true(默认值)表示默认查询该字段，false表示默认不查询该字段。</p><p><strong>问题4:表名与编码开发设计不同步</strong></p><p>表的名称和模型类的名称不一致，导致查询失败，因为mybatisplus的语句中没有表名，不像sql能select * form xxx，只能根据实体类名和表明匹配。这个时候通常会报如下错误信息：<strong>Table ‘databaseName.tableNaem’ doesn’t exist</strong>，译为数据库中的表不存在。</p><p><strong>解决方案一：</strong>是使用MP提供的另外一个<strong>注解<code>@TableName</code>来设置表与模型类之间的对应关系。</strong></p><p>解决方法二：配置统一给实体类名加前缀：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">        <span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br></pre></td></tr></table></figure><h3 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a>@TableField</h3><table><thead><tr><th align="left">名称</th><th align="left">@TableField</th></tr></thead><tbody><tr><td align="left">类型</td><td align="left"><strong>属性注解</strong></td></tr><tr><td align="left">位置</td><td align="left">模型类属性定义上方</td></tr><tr><td align="left">作用</td><td align="left">设置当前属性对应的数据库表中的字段关系</td></tr><tr><td align="left">相关属性</td><td align="left">value(默认)：设置数据库表字段名称<br/>exist:设置属性在数据库表字段中是否存在，默认为true，此属性不能与value合并使用<br/>select:设置属性是否参与查询，此属性与select()映射配置不冲突</td></tr></tbody></table><h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><table><thead><tr><th align="left">名称</th><th align="left">@TableName</th></tr></thead><tbody><tr><td align="left">类型</td><td align="left"><strong>类注解</strong></td></tr><tr><td align="left">位置</td><td align="left">模型类定义上方</td></tr><tr><td align="left">作用</td><td align="left">设置当前类对应于数据库表关系</td></tr><tr><td align="left">相关属性</td><td align="left">value(默认)：设置数据库表名称</td></tr></tbody></table><hr><h1 id="DML编程控制"><a href="#DML编程控制" class="headerlink" title="DML编程控制"></a>DML编程控制</h1><h2 id="id生成策略控制"><a href="#id生成策略控制" class="headerlink" title="id生成策略控制"></a>id生成策略控制</h2><p>前面我们在新增的时候留了一个问题，就是新增成功后，<strong>主键ID是一个很长串的内容</strong>，我们更想要的是按照数据库表字段进行自增长。</p><p><strong>ID该如何选择:</strong></p><ul><li><strong>不同的表应用不同的id生成策略</strong><ul><li>日志：自增（1,2,3,4，……）</li><li>购物订单：特殊规则（FQ23948AK3843）</li><li>外卖单：关联地区日期等信息（10 04 20200314 34 91）</li><li>关系表：可省略id</li></ul></li></ul><h3 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h3><table><thead><tr><th align="left">名称</th><th align="left">@TableId</th></tr></thead><tbody><tr><td align="left">类型</td><td align="left"><strong>属性注解</strong></td></tr><tr><td align="left">位置</td><td align="left">模型类中用于表示主键的属性定义上方</td></tr><tr><td align="left">作用</td><td align="left">设置当前类中主键属性的生成策略</td></tr><tr><td align="left">相关属性</td><td align="left"><strong>value(默认)：设置数据库表主键名称 type:设置主键属性的生成策略，值查照IdType的枚举值</strong></td></tr></tbody></table><h3 id="五种id策略代码实现"><a href="#五种id策略代码实现" class="headerlink" title="五种id策略代码实现"></a>五种id策略代码实现</h3><p><strong>概述：</strong> </p><ul><li><p><strong>AUTO策略：数据库默认自增策略</strong></p></li><li><p><strong>NONE: 不设置id生成策略</strong></p></li><li><p><strong>INPUT：用户手工输入id</strong>，如果id为null会报错</p></li><li><p>**ASSIGN_ID:雪花算法生成id(可兼容数值型与字符串型)**，mp默认id策略</p></li><li><p><strong>ASSIGN_UUID:以UUID生成算法作为id生成策略</strong></p></li><li><p><strong>其他的几个策略均已过时，都将被ASSIGN_ID和ASSIGN_UUID代替掉。</strong></p></li></ul><blockquote><p><strong>注意：除了INPUT策略，其他策略即使指定id为null会自动生成，不为null会用指定的id。</strong></p><p><strong>分布式ID是什么?</strong></p><ul><li>当数据量足够大的时候，一台数据库服务器存储不下，这个时候就需要<strong>多台数据库服务器进行存储</strong></li><li>比如订单表就有可能被存储在不同的服务器上</li><li><strong>如果用数据库表的自增主键，因为在两台服务器上所以会出现冲突</strong></li><li>这个时候就需要一个<strong>全局唯一ID,这个ID就是分布式ID。</strong></li></ul></blockquote><ol><li><p><strong>AUTO策略：数据库默认自增策略</strong>，使用该策略的时候一定要确保对应的数据库表设置了ID主键自增，否则无效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.AUTO)</span> <span class="comment">// 给实体类id属性，设置生成策略为AUTO</span></span><br></pre></td></tr></table></figure></li><li><p><strong>设置生成策略为INPUT</strong>，这种ID生成策略，需要将表的自增策略删除掉，添加数据手动设置ID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.INPUT)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="comment">// 使用 设置主键ID的值</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">666L</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>设置生成策略为ASSIGN_ID</strong>，这种生成策略，不需要手动设置ID，如果手动设置ID，则会使用自己设置的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.ASSIGN_ID)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>设置生成策略为ASSIGN_UUID</strong>，主键的类型应该改成String，表字段类型设置为varchar，长度要大于32，因为UUID生成的主键为32位，如果长度小的话就会导致插入失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure><p>雪花算法(SnowFlake)，是Twitter官方给出的算法实现 是用Scala写的。其生成的结果是一个64bit大小整数，它的结构如下图:</p><ul><li>1bit，不用，因为二进制中最高位是符号位，1表示负数，<strong>0表示正数</strong>。生成的id一般都是用整数，所以<strong>最高位固定为0</strong>。</li><li>41bit-<strong>时间戳</strong>，用来记录时间戳，毫秒级</li><li>10bit-<strong>工作机器id</strong>，用来记录工作机器id,其中高位5bit是数据中心ID其取值范围0-31，低位5bit是工作节点ID其取值范围0-31，两个组合起来最多可以容纳1024个节点</li><li><strong>序列号</strong>占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID</li></ul></li></ol><h3 id="ID生成策略对比"><a href="#ID生成策略对比" class="headerlink" title="ID生成策略对比"></a>ID生成策略对比</h3><ul><li><strong>NONE: 不设置id生成策略</strong>，MP不自动生成，<strong>约等于INPUT</strong>,所以这两种方式都<strong>需要用户手动设置</strong>，但是手动设置第一个问题是容易出现相同的ID造成主键冲突，为了保证主键不冲突就需要做很多判定，实现起来比较复杂</li><li>**AUTO:**数据库ID自增,这种策略适合在数据库服务器只有1台的情况下使用,不可作为分布式ID使用</li><li><strong>ASSIGN_UUID:<strong>可以在</strong>分布式的情况下使用</strong>，而且能够<strong>保证唯一</strong>，但是生成的主键是<strong>32位的字符串，长度过长占用空间而且还不能排序，查询性能也慢</strong></li><li><strong>ASSIGN_ID:<strong>可以在</strong>分布式</strong>的情况下使用，生成的是<strong>Long类型的数字</strong>，可以<strong>排序性能也高</strong>，但是<strong>生成的策略和服务器时间有关，如果修改了系统时间就有可能导致出现重复主键</strong></li></ul><h3 id="配置方法设置id策略和实体类前缀tbl"><a href="#配置方法设置id策略和实体类前缀tbl" class="headerlink" title="配置方法设置id策略和实体类前缀tbl_"></a>配置方法设置id策略和实体类前缀tbl_</h3><p><strong>模型类主键策略设置</strong></p><p>但是如果要在项目中的每一个模型类上都需要使用相同的生成策略，只需要在配置文件中添加如下内容，就能让所有的模型类都可以使用该主键ID策略：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">        <span class="attr">id-type:</span> <span class="string">assign_id</span></span><br></pre></td></tr></table></figure><p><strong>配置方法设置数据库表与模型类的映射关系</strong></p><p><strong>MP会默认将模型类的类名名首字母小写作为表名使用</strong>，假如数据库表的名称都以<code>tbl_</code>开头，那么我们就需要将所有的模型类上添加**<code>@TableName</code>**，简化方式为在配置文件中配置如下内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">        <span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br></pre></td></tr></table></figure><h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><p>根据传入的ID集合批量操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br></pre></td></tr></table></figure><h2 id="逻辑删除，-TableLogic"><a href="#逻辑删除，-TableLogic" class="headerlink" title="逻辑删除，@TableLogic"></a>逻辑删除，@TableLogic</h2><ul><li><strong>物理删除：</strong>业务数据从数据库中丢弃，执行的是delete操作。</li><li><strong>逻辑删除：</strong>为数据设置是否可用状态字段<strong>，</strong>删除时设置状态字段为不可用状态，数据保留在数据库中，执行的是update操作。</li></ul><ol><li><p><strong>修改数据库表添加<code>deleted</code>列</strong></p></li><li><p><strong>实体类设置逻辑删除成员</strong></p><ol><li><p><strong>单个实体类注解<code>@TableLogic</code></strong></p><p>标识新增的字段为逻辑删除字段，使用<strong>注解<code>@TableLogic，value属性是默认值，delval是删除后修改的值</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic(value=&quot;0&quot;,delval=&quot;1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure></li><li><p><strong>yml全局配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">       <span class="comment">#逻辑删除字段名</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span></span><br><span class="line">       <span class="comment">#逻辑删除字面值：未删除为0</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br><span class="line">       <span class="comment">#逻辑删除字面值：删除为1</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>执行查询操作默认给sql语句后面加where deleted=0</strong></p><p>MP的逻辑删除会将所有的查询都添加一个未被删除的条件，也就是已经被删除的数据是不应该被查询出来的。</p></li></ol><h3 id="TableLogic"><a href="#TableLogic" class="headerlink" title="@TableLogic"></a>@TableLogic</h3><table><thead><tr><th align="left">名称</th><th align="left">@TableLogic</th></tr></thead><tbody><tr><td align="left">类型</td><td align="left"><strong>属性注解</strong></td></tr><tr><td align="left">位置</td><td align="left">模型类中用于表示删除字段的属性定义上方</td></tr><tr><td align="left">作用</td><td align="left">标识该字段为进行逻辑删除的字段</td></tr><tr><td align="left">相关属性</td><td align="left">value：逻辑未删除值<br/>delval：逻辑删除值</td></tr></tbody></table><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><strong>乐观锁通过版本号控制事务的并发。</strong></p><ol><li>给数据加版本号</li><li><strong>保存数据时判断版本号是否取出时的版本，如果是则说明数据没有改动，直接保存并且版本号加1，否则回退。</strong></li></ol><p><strong>悲观锁：</strong>就是锁定你想要使用的资源，其他请求想要使用这个资源就必须排队，等这个资源释放了才能继续。</p><p><strong>乐观锁使用案例：</strong></p><p>业务并发现象带来的问题：<strong>秒杀</strong>。假如有100个商品或者票在出售，为了能保证每个商品或者票只能被一个人购买，如何保证不会出现超买或者重复卖。</p><ul><li>第一个想到的就是锁，锁在一台服务器中是可以解决的，但是如果在多台服务器下锁就没有办法控制，比如12306有两台服务器在进行卖票，在两台服务器上都添加锁的话，那也有可能会导致在同一时刻有两个线程在进行卖票，还是会出现并发问题</li><li>接下来介绍的这种方式是针对于小型企业的解决方案，因为数据库本身的性能就是个瓶颈，如果对其并发量超过2000以上的就需要考虑其他的解决方案了。</li></ul><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul><li>数据库表中<strong>添加version列</strong>，比如默认值给1</li><li>第一个线程要修改数据之前，取出记录时，获取当前数据库中的version=1</li><li>第二个线程要修改数据之前，取出记录时，获取当前数据库中的version=1</li><li>第一个线程执行更新时，set version = newVersion where version = oldVersion<ul><li>newVersion = version+1 [2]</li><li>oldVersion = version [1]</li></ul></li><li>第二个线程执行更新时，set version = newVersion where version = oldVersion<ul><li>newVersion = version+1 [2]</li><li>oldVersion = version [1]</li></ul></li><li>假如这两个线程都来更新数据，第一个和第二个线程都可能先执行<ul><li><strong>假如第一个线程先执行更新，乐观锁发现version依然为1，就把version改为2，第二个线程再更新</strong>的时候，set version = 2 where version = 1，此时<strong>乐观锁发现数据库表version已经为2，所以第二个线程会修改失败</strong></li><li>假如第二个线程先执行更新，会把version改为2，第一个线程再更新的时候，set version = 2 where version = 1,此时数据库表的数据version已经为2，所以第一个线程会修改失败</li><li><strong>不管谁先执行都会确保只能有一个线程更新数据，这就是MP提供的乐观锁的实现原理分析。</strong></li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol><li><p><strong>数据库表添加列，默认值1</strong>。列名可以任意，比如使用<code>version</code>,给列设置默认值为<code>1</code></p></li><li><p><strong>在模型类中添加对应的属性，@Version</strong>。根据添加的字段列名，在模型类中添加对应的属性值version，并注解@Version</p></li><li><p><strong>添加乐观锁的拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MpConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mpInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.定义Mp拦截器</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mpInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 2.添加乐观锁拦截器</span></span><br><span class="line">        mpInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">         <span class="comment">// 分页拦截器 </span></span><br><span class="line">        <span class="comment">//mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());   </span></span><br><span class="line">        <span class="keyword">return</span> mpInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>先查询version再更新操作</strong> </p><p><strong>要想实现乐观锁，首先第一步应该是拿到表中的version，然后拿version当条件在将version加1更新回到数据库表中</strong>，所以我们在修改的时候，需要对其进行查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.先通过要修改的数据id将当前数据查询出来</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDao.selectById(<span class="number">3L</span>);</span><br><span class="line"><span class="comment">// 2.将要修改的属性逐一设置进去</span></span><br><span class="line">user.setName(<span class="string">&quot;Jock888&quot;</span>);</span><br><span class="line">userDao.updateById(user);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>注意：必须先查询再修改，修改后系统自动给version属性加1。手动加和不查不加都是步行的。</strong>如果手动加version，提交后系统还会加一次1.</p></blockquote><hr><h1 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h1><h2 id="代码生成器实现"><a href="#代码生成器实现" class="headerlink" title="代码生成器实现"></a>代码生成器实现</h2><ol><li><p><strong>创建一个Maven项目</strong>，<strong>导入对应的jar包</strong>mybatis-plus,druid,lombok，代码生成器mybatis-plus-generator和模板引擎velocity-engine-core依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatisplus_04_generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--spring webmvc--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatisplus--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--druid--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--test--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--代码生成器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--velocity模板引擎--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写引导类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisplusGeneratorApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MybatisplusGeneratorApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建代码生成类CodeGenerator</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取代码生成器的对象</span></span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">autoGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line">        <span class="comment">// 创建DataSourceConfig 对象设置数据库相关配置</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dataSource.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        autoGenerator.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">// 设置全局配置</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">globalConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">      globalConfig.setOutputDir(System.getProperty(<span class="string">&quot;user.dir&quot;</span>)</span><br><span class="line">                                + <span class="string">&quot;/mybatisplus_04_generator/src/main/java&quot;</span>);   </span><br><span class="line">        <span class="comment">// 设置代码生成位置</span></span><br><span class="line">        globalConfig.setOpen(<span class="literal">false</span>);                     <span class="comment">// 设置生成完毕后是否打开生成代码所在的目录</span></span><br><span class="line">        globalConfig.setAuthor(<span class="string">&quot;黑马程序员&quot;</span>);             <span class="comment">// 设置作者</span></span><br><span class="line">        globalConfig.setFileOverride(<span class="literal">true</span>);             <span class="comment">// 设置是否覆盖原始生成的文件</span></span><br><span class="line">        globalConfig.setMapperName(<span class="string">&quot;%sDao&quot;</span>);            <span class="comment">// 设置数据层接口名，%s为占位符，指代模块名称</span></span><br><span class="line">        globalConfig.setIdType(IdType.ASSIGN_ID);       <span class="comment">// 设置Id生成策略</span></span><br><span class="line">        autoGenerator.setGlobalConfig(globalConfig);</span><br><span class="line">        <span class="comment">// 设置包名相关配置</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">packageInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        packageInfo.setParent(<span class="string">&quot;com.aaa&quot;</span>);   <span class="comment">// 设置生成的包名，与代码所在位置不冲突，二者叠加组成完整路径</span></span><br><span class="line">        packageInfo.setEntity(<span class="string">&quot;domain&quot;</span>);    <span class="comment">// 设置实体类包名</span></span><br><span class="line">        packageInfo.setMapper(<span class="string">&quot;dao&quot;</span>);       <span class="comment">// 设置数据层包名</span></span><br><span class="line">        autoGenerator.setPackageInfo(packageInfo);</span><br><span class="line">        <span class="comment">// 策略设置</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">strategyConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        strategyConfig.setInclude(<span class="string">&quot;tbl_user&quot;</span>);  <span class="comment">//设置当前参与生成的表名，参数为可变参数</span></span><br><span class="line">        strategyConfig.setTablePrefix(<span class="string">&quot;tbl_&quot;</span>);  <span class="comment">//设置数据库表的前缀名称，模块名 = 数据库表名-前缀名。</span></span><br><span class="line">        <span class="comment">// 如：User = tbl_user-tbl_</span></span><br><span class="line">        strategyConfig.setRestControllerStyle(<span class="literal">true</span>);    <span class="comment">//设置是否启用Rest风格</span></span><br><span class="line">        strategyConfig.setVersionFieldName(<span class="string">&quot;version&quot;</span>);  <span class="comment">//设置乐观锁字段名</span></span><br><span class="line">        strategyConfig.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);  <span class="comment">//设置逻辑删除字段名</span></span><br><span class="line">        strategyConfig.setEntityLombokModel(<span class="literal">true</span>);  <span class="comment">//设置是否启用lombok</span></span><br><span class="line">        autoGenerator.setStrategy(strategyConfig);</span><br><span class="line">        <span class="comment">// 2.执行代码生成器</span></span><br><span class="line">        autoGenerator.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以参考<a href="https://baomidou.com/guides/new-code-generator/">代码生成器</a></p></li><li><p><strong>运行生成器类的main方法</strong>，运行成功后会在当前项目中生成很多代码，代码包含<code>controller</code>，<code>service</code>，<code>mapper</code>和<code>entity</code></p></li></ol><h2 id="MP中Service的CRUD"><a href="#MP中Service的CRUD" class="headerlink" title="MP中Service的CRUD"></a>MP中Service的CRUD</h2><h3 id="IService和ServiceImpl-lt-UserDao-User-gt"><a href="#IService和ServiceImpl-lt-UserDao-User-gt" class="headerlink" title="IService和ServiceImpl&lt;UserDao, User&gt;"></a>IService<User>和ServiceImpl&lt;UserDao, User&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.selectList(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MP提供了一个Service接口和实现类，分别是：**<code>IService</code>和<code>ServiceImpl</code>**，后者是对前者的一个具体实现。自定义Service可修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt;&#123;&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserDao, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>修改以后的好处是，MP已经帮我们把业务层的一些基础的增删改查都已经实现了，可以直接进行使用。</p><blockquote><p>在MP封装的Service层都有哪些方法可以用，可以查看官方文档<a href="https://baomidou.com/guides/data-interface/">持久层接口</a>，这些提供的方法大家可以参考官方文档进行学习使用，方法的名称可能有些变化，但是方法对应的参数和返回值基本类似。</p></blockquote><hr><h1 id="ActiveRecord简介"><a href="#ActiveRecord简介" class="headerlink" title="ActiveRecord简介"></a>ActiveRecord简介</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>ActiveRecord属于ORM（对象关系映射）层</strong>，由Rails最早提出，遵循标准的<strong>ORM模型：表映射到记录，记录映射到对象，字段映射到对象属性。</strong>配合遵循的命名和配置惯例，能够很大程度的快速实现模型的操作，而且简洁易懂。</p><p><strong>主要思想是：</strong></p><ul><li><strong>每一个数据库表对应创建一个类，类的每一个对象实例对应于数据库中表的一行记录；通常表的每个字段在类中都有相应的Field；</strong></li><li>ActiveRecord同时负责把自己<strong>持久化</strong>，在ActiveRecord中封装了对数据库的访问，即CURD;</li><li>ActiveRecord是一种领域模型(Domain Model)，封装了部分业务逻辑；</li></ul><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>在MP中，开启AR非常简单，只需要将**实体对象继承Model&lt;实体类&gt;**即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;User&gt;&#123;</span><br><span class="line">    <span class="comment">// fields...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li><strong>之后增删改查就可以不用自动注入dao接口，直接实体类对象就能调用mp的各种方法。</strong></li><li><strong>但dao还不能删除，因为ar底层还是dao。</strong></li></ul></blockquote><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    System.out.println(user.selectById(<span class="number">2L</span>));    <span class="comment">//或者给user设置id后user.selectById()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者给user设置id后user.selectById()</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">QueryWrapper&lt;User&gt; userQueryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">userQueryWrapper.le(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">List&lt;User&gt; users = user.selectList(userQueryWrapper);</span><br><span class="line"><span class="keyword">for</span> (User user1 : users) &#123;</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;刘备&quot;</span>);</span><br><span class="line">user.setAge(<span class="number">30</span>);</span><br><span class="line">user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">user.setUserName(<span class="string">&quot;liubei&quot;</span>);</span><br><span class="line">user.setEmail(<span class="string">&quot;liubei@itcast.cn&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">insert</span> <span class="operator">=</span> user.insert();</span><br><span class="line">System.out.println(insert);</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">7L</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">delete</span> <span class="operator">=</span> user.deleteById();</span><br><span class="line">System.out.println(delete);</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">8L</span>);</span><br><span class="line">user.setAge(<span class="number">35</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> user.updateById();</span><br><span class="line">System.out.println(update);</span><br></pre></td></tr></table></figure><hr><h1 id="Mybtis和Mybatis-Plus区别"><a href="#Mybtis和Mybatis-Plus区别" class="headerlink" title="Mybtis和Mybatis-Plus区别"></a>Mybtis和Mybatis-Plus区别</h1><p><strong>MyBatis-Plus 是在 MyBatis 基础上增强的工具包</strong>，让开发更便捷、高效。<a href="https://baomidou.com/">MyBatis-Plus官网地址</a>。</p><h2 id="核心区别总结"><a href="#核心区别总结" class="headerlink" title="核心区别总结"></a>核心区别总结</h2><table><thead><tr><th>特性</th><th>MyBatis</th><th>MyBatis-Plus</th></tr></thead><tbody><tr><td>配置复杂度</td><td>需要手写大量 XML 或注解</td><td>极简配置，自动生成 SQL</td></tr><tr><td>CRUD 操作</td><td>手写 Mapper 方法 + SQL</td><td>内置通用 CRUD 方法</td></tr><tr><td>分页功能</td><td>需要手写分页逻辑或第三方插件</td><td>内置分页插件，开箱即用</td></tr><tr><td>条件构造器</td><td>无，需要手写 where 条件</td><td>内置 Lambda 条件构造器</td></tr><tr><td>代码生成</td><td>无</td><td>提供代码生成器（Code Generator）</td></tr><tr><td>主键策略</td><td>需要手动配置</td><td>内置多种主键生成策略</td></tr><tr><td>乐观锁</td><td>自己实现</td><td>提供内置乐观锁插件</td></tr><tr><td>审计字段（如创建时间、修改时间）</td><td>自行维护</td><td>提供自动填充功能</td></tr><tr><td>性能分析</td><td>需要额外工具</td><td>内置 SQL 性能分析插件</td></tr><tr><td>兼容性</td><td>灵活、手动控制高</td><td>完全兼容 MyBatis，可随时退回</td></tr></tbody></table><h2 id="配置复杂度"><a href="#配置复杂度" class="headerlink" title="配置复杂度"></a>配置复杂度</h2><p><strong>MyBatis：</strong></p><ul><li>需要创建 <code>Mapper 接口</code> + <code>Mapper.xml</code> 文件</li><li>SQL 都需要手动写，配置较繁琐</li><li>实体类、字段和表结构需要手动映射（resultMap 或 @Results）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyBatis 的 select 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>MyBatis-Plus：</strong></p><ul><li>只需配置数据库连接、扫描 Mapper 包</li><li>不需要写 XML，自动完成 SQL 拼接</li><li>实体类字段与表字段名称一致可自动映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简洁调用</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure><h2 id="CRUD-操作"><a href="#CRUD-操作" class="headerlink" title="CRUD 操作"></a>CRUD 操作</h2><p><strong>MyBatis：</strong></p><ul><li>所有 CRUD 方法都需要手写</li><li>如果实体类字段多，SQL 写起来冗长，易出错</li></ul><p><strong>MyBatis-Plus：</strong></p><ul><li>提供 <code>BaseMapper&lt;T&gt;</code>，自动拥有 20+ 个通用 CRUD 方法</li><li>例如：<ul><li><code>selectById</code>, <code>insert</code>, <code>updateById</code>, <code>deleteById</code></li><li>批量插入、分页查询、条件查询等也支持</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span> <span class="params">(T t)</span></span><br></pre></td></tr></table></figure><ul><li>T：泛型，新增用来保存新增数据</li><li>int：返回值，新增成功后返回1，没有新增成功返回的是0</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据多个ID 批量删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 批量删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 不常用</span></span><br><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="comment">//int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);</span></span><br></pre></td></tr></table></figure><p><strong>Serializable：</strong>参数类型</p><ul><li><p><strong>思考：</strong>参数类型为什么是一个序列化类?</p><p>String和Number是Serializable的子类，Number又是Float,Double,Integer等类的父类，能作为主键的数据类型都已经是Serializable的子类，MP使用Serializable作为参数类型，就类似java中Object接收任何数据类型一样。</p></li><li><p><strong>int：</strong>返回值类型，数据删除成功返回1，未删除数据返回0。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T t)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;</span><br></pre></td></tr></table></figure><ul><li>T：泛型，<strong>需要修改的数据内容</strong>，注意因为是根据ID进行修改，所以传入的对象中需要有ID属性值</li><li>int：返回值，修改成功后返回1，未修改数据返回0</li></ul><p><strong>根据条件更改</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setAge(<span class="number">22</span>); <span class="comment">//更新的字段</span></span><br><span class="line"><span class="comment">// 更新的条件</span></span><br><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(<span class="string">&quot;id&quot;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">//执行更新操作</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.userMapper.update(user, wrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>修改的时候，只修改实体对象中有值的字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>Serializable：</strong>参数类型,主键ID的值</li><li><strong>T：</strong>根据ID查询只会返回一条数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span><br></pre></td></tr></table></figure><ul><li><strong>Wrapper：</strong>用来构建条件查询的条件，目前我们没有可直接传为Null</li><li><strong>List：</strong>因为查询的是所有，所以返回的数据是一个集合</li></ul><h2 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h2><p><strong>MyBatis：</strong></p><ul><li>需要自己拼接分页 SQL（LIMIT/OFFSET）</li><li>或接入第三方分页插件如 PageHelper</li></ul><p><strong>MyBatis-Plus：</strong></p><ul><li>提供 <code>分页插件</code>，配置一次后，使用非常方便</li><li>统一使用 <code>Page&lt;T&gt;</code> 对象传参</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span></span><br></pre></td></tr></table></figure><ul><li><strong>IPage<T>：</strong>用来<strong>构建分页查询条件</strong></li><li><strong>Wrapper：</strong>译为包装器，封装器。用来构建<strong>条件查询的条件</strong>，目前我们没有可直接传为Null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方法传入参数获取返回值</span></span><br><span class="line">Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 页码1，每页10条</span></span><br><span class="line">Page&lt;User&gt; result = userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageUtils <span class="title function_">queryPage</span><span class="params">(Map&lt;String, Object&gt; params, Long categoryId)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (String) params.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    LambdaQueryWrapper&lt;AttrGroupEntity&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 先根据检索查</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(key))&#123;</span><br><span class="line"><span class="comment">//wrapper.eq(AttrGroupEntity::getAttrGroupId,key).or().like(AttrGroupEntity::getAttrGroupName,key);//也可以</span></span><br><span class="line">        wrapper.and(</span><br><span class="line">                obj -&gt; obj.eq(AttrGroupEntity::getAttrGroupId,key)</span><br><span class="line">                        .or().like(AttrGroupEntity::getAttrGroupName,key)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(categoryId!=<span class="number">0</span>) &#123;</span><br><span class="line">        wrapper.eq(AttrGroupEntity::getCatelogId,categoryId);</span><br><span class="line">    &#125;</span><br><span class="line">    IPage&lt;AttrGroupEntity&gt; page = <span class="built_in">this</span>.page(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Query</span>&lt;AttrGroupEntity&gt;().getPage(params),</span><br><span class="line">            wrapper</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageUtils</span>(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在config包下创建分页拦截器类</strong>：分页拦截器类代码是通用的，可以直接复制粘贴。可以查看<a href="https://baomidou.com/plugins/pagination/">官方文档类配置</a></p><p>配置拦截器MP，并将其配置成Spring管理的bean对象即可。需要用到MybatisPlusInterceptor 对象的addInnerInterceptor方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注解为配置类@Configuration，也可以在引导类@Import(&#123;MybatisPlusConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 被Spring容器管理    </span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1 创建mp拦截器对象MybatisPlusInterceptor</span></span><br><span class="line">        MybatisPlusInterceptor mpInterceptor=<span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//2 添加内置拦截器，参数为分页内置拦截器对象PaginationInnerInterceptor</span></span><br><span class="line">        mpInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> mpInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h2><p><strong>MyBatis</strong>：条件查询时需要手写 SQL 中的 where 子句</p><p><strong>MyBatis-Plus：</strong></p><ul><li>提供 <code>QueryWrapper</code> 和 <code>LambdaQueryWrapper</code></li><li>可链式编程、支持条件组合、动态拼接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(User::getAge, <span class="number">20</span>).like(User::getName, <span class="string">&quot;张&quot;</span>);</span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p><strong>MyBatis：</strong>没有自带代码生成工具，通常需要借助 MyBatis Generator 插件，且配置复杂</p><p><strong>MyBatis-Plus：</strong></p><ul><li>自带 <code>Code Generator</code>，支持通过数据库自动生成：<ul><li>实体类、Mapper 接口、XML、Service、Controller 等</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速生成一整套文件，只需配置数据库和模板路径</span></span><br><span class="line"><span class="type">AutoGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"><span class="comment">// 配置略...</span></span><br><span class="line">generator.execute();</span><br></pre></td></tr></table></figure><h2 id="主键策略"><a href="#主键策略" class="headerlink" title="主键策略"></a>主键策略</h2><p><strong>MyBatis：</strong>插入数据时需要手动指定主键或配置主键返回策略（如 useGeneratedKeys）</p><p><strong>MyBatis-Plus：</strong></p><ul><li>支持多种主键生成方式：<ul><li>自增、UUID、雪花算法（默认使用雪花）</li></ul></li><li>只需在实体类中加注解即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.ASSIGN_ID)</span> <span class="comment">// 使用雪花算法生成主键</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><h2 id="乐观锁-1"><a href="#乐观锁-1" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><strong>MyBatis：</strong>需要手动实现版本字段逻辑和 SQL 拼接</p><p><strong>MyBatis-Plus：</strong>提供内置插件支持乐观锁，自动对 <code>version</code> 字段进行比较和更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version; <span class="comment">// 更新时会自动加入 version=... 的判断</span></span><br></pre></td></tr></table></figure><h2 id="审计字段（如创建时间、修改时间）"><a href="#审计字段（如创建时间、修改时间）" class="headerlink" title="审计字段（如创建时间、修改时间）"></a>审计字段（如创建时间、修改时间）</h2><p><strong>MyBatis：</strong>需要手动在 insert/update 语句中维护 <code>createTime</code>, <code>updateTime</code></p><p><strong>MyBatis-Plus：</strong></p><ul><li><p>提供自动填充功能，支持插入/更新时自动填充字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime updateTime;</span><br></pre></td></tr></table></figure></li><li><p>需要配置 <code>MetaObjectHandler</code>，一次性设置全局规则</p></li></ul><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><strong>MyBatis：</strong>需要自己接入日志框架或 SQL 监控工具（如 P6Spy）</p><p><strong>MyBatis-Plus：</strong>内置 SQL 执行分析插件（dev/test 环境下很实用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启性能分析插件</span></span><br><span class="line">interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PerformanceInterceptor</span>());</span><br></pre></td></tr></table></figure><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><strong>MyBatis：</strong>灵活度高，自由度大，但需要手动控制 SQL</p><p><strong>MyBatis-Plus：</strong></p><ul><li>100% 兼容原生 MyBatis</li><li>可以只使用通用功能，特殊需求时照样写 XML、注解 SQL</li></ul><h2 id="使用场景建议"><a href="#使用场景建议" class="headerlink" title="使用场景建议"></a>使用场景建议</h2><ul><li><strong>MyBatis</strong>：适合 SQL 极度复杂、强定制化的项目，想完全控制 SQL。</li><li><strong>MyBatis-Plus</strong>：适合大多数通用业务，追求开发效率、简洁的项目，尤其适合中后台管理系统。</li></ul>]]></content>
    
    
    <summary type="html">MyBatis-Plus是一个MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为简化开发、提高效率而生。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="MyBatis" scheme="https://southernfish.github.io/categories/Framwork/MyBatis/"/>
    
    
    <category term="MyBatis" scheme="https://southernfish.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 组件</title>
    <link href="https://southernfish.github.io/pages/middleware/rabbitmq-component/"/>
    <id>https://southernfish.github.io/pages/middleware/rabbitmq-component/</id>
    <published>2025-07-30T01:45:36.000Z</published>
    <updated>2025-09-20T11:18:48.148Z</updated>
    
    <content type="html"><![CDATA[<p><strong>RabbitMQ</strong>是实现了高级<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4751675?fromModule=lemma_inlink">消息队列</a>协议（<a href="https://baike.baidu.com/item/AMQP/8354716?fromModule=lemma_inlink">AMQP</a>）的开源消息代理软件（亦称面向消息的<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240?fromModule=lemma_inlink">中间件</a>）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang/0?fromModule=lemma_inlink">Erlang</a>语言编写的，而集群和<a href="https://baike.baidu.com/item/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/14768924?fromModule=lemma_inlink">故障转移</a>是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0/15696499?fromModule=lemma_inlink">开放电信平台</a>框架上的，支持高并发处理和分布式部署。所有主要的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131?fromModule=lemma_inlink">编程语言</a>均有与代理接口通讯的客户端库。RabbitMQ本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，更适合于企业级的开发。它还实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队，通过队列机制实现应用程序间的异步通信与数据传输，常用于流量削峰、系统解耦及异步处理场景。对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。多用于进行企业级的ESB整合。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/u011488477/article/details/146038779">5.RabbitMQ交换机详解</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146039356">7.RabbitMQ延时交换机</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146038909">6.RabbitMQ死信队列</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146039416">8.RabbitMQ队列详解</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146042593">9.RabbitMQ消息的可靠性</a></p></blockquote><h1 id="RabbitMQ-交换机"><a href="#RabbitMQ-交换机" class="headerlink" title="RabbitMQ 交换机"></a>RabbitMQ 交换机</h1><p>Exchange(X) 可翻译成交换机/交换器/路由器</p><h2 id="RabbitMQ交换器-Exchange-类型"><a href="#RabbitMQ交换器-Exchange-类型" class="headerlink" title="RabbitMQ交换器 (Exchange)类型"></a>RabbitMQ交换器 (Exchange)类型</h2><ol><li><code>Fanout Exchange</code>（扇形交换机）：广播，<strong>分发模式</strong>，把消息<strong>分发给所有订阅者</strong>。广播，将消息交给所有绑定到交换机的队列</li><li><code>Direct Exchange</code>（直连交换机）：定向，把消息交给符合指定routing key 的队列。<strong>发送方把消息发送给订阅方</strong>，针对多个订阅者，<strong>默认采取轮询方式进行消息发送</strong>。</li><li><code>Topic Exchange</code>（主题交换机）：通配符，<strong>匹配订阅模式</strong>，使用<strong>正则匹配</strong>到消息队列，把消息交给符合routing pattern（路由模式） 的队列</li><li><code>Headers Exchange</code>（头部交换机）：与 <code>direct</code> 类似，只是性能很差，此类型几乎用不到。</li><li>x-local-random Exchange</li><li>自定义交换机</li></ol><blockquote><p>使用流程：引入依赖 → 配置MQ（yaml）→ 定义常量 →  定义MQ → 定义生产者 →  定义消费者 →  发送消息 → 测试结果</p><p>引入依赖，配置MQ（yaml）都一样，根据不同类型，不同情况。定义常量、MQ、生产者、消费者略有差别。</p></blockquote><h3 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h3><p>扇形交换机会将消息投递到所有绑定的队列，不需要路由键，不需要进行路由键的匹配，相当于广播、群发；消息发送流程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 可以有多个消费者</span><br><span class="line">2. 每个消费者有自己的queue（队列）</span><br><span class="line">3. 每个队列都要绑定到Exchange（交换机）</span><br><span class="line">4. 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。</span><br><span class="line">5. 交换机把消息发送给绑定过的所有队列</span><br><span class="line">6. 队列的消费者都能拿到消息。实现一条消息被多个消费者消费</span><br></pre></td></tr></table></figure><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_FANOUT</span> <span class="operator">=</span> <span class="string">&quot;exchange.fanout&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_FANOUT_A</span> <span class="operator">=</span> <span class="string">&quot;queue.fanout.a&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_FANOUT_B</span> <span class="operator">=</span> <span class="string">&quot;queue.fanout.B&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// rabbitmq 三部曲</span></span><br><span class="line">    <span class="comment">// 1、定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(RabbitMQConstant.EXCHANGE_FANOUT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2 定义队列a</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(RabbitMQConstant.QUEUE_FANOUT_A);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2 定义队列b</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(RabbitMQConstant.QUEUE_FANOUT_B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 绑定交换机和队列a</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bingingA</span><span class="params">(FanoutExchange fanoutExchange, Queue queueA)</span> &#123;</span><br><span class="line">        <span class="comment">// 将队列A绑定到扇形交换机</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 绑定交换机和队列b</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bingingB</span><span class="params">(FanoutExchange fanoutExchange, Queue queueB)</span> &#123;</span><br><span class="line">        <span class="comment">// 将队列B绑定到扇形交换机</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 生产者发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 定义要发送的消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息封装成Message对象</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(msg.getBytes());</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_FANOUT, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 接收两个队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_FANOUT_A,RabbitMQConstant.QUEUE_FANOUT_B&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;&quot;</span>,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Wed Jul 30 22:01:46 GMT+08:00 2025</span><br><span class="line">接收到的消息为:hello world</span><br><span class="line">接收到的消息为:hello world</span><br></pre></td></tr></table></figure><h3 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h3><p>在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key），消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。路由键与队列名完全匹配的交换机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</span><br><span class="line">X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</span><br><span class="line">C1：消费者，其所在队列指定了需要routing key 为 error 的消息</span><br><span class="line">C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</span><br></pre></td></tr></table></figure><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_DIRECT</span> <span class="operator">=</span> <span class="string">&quot;exchange.direct&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DIRECT_A</span> <span class="operator">=</span> <span class="string">&quot;queue.direct.a&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DIRECT_B</span> <span class="operator">=</span> <span class="string">&quot;queue.direct.b&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_WARNING_KEY</span> <span class="operator">=</span> <span class="string">&quot;warn&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 1、定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用建造者模式创建</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_DIRECT).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用建造者模式创建</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DIRECT_A).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DIRECT_B).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、交换机和队列进行绑定</span></span><br><span class="line">    <span class="comment">// 队列A绑定info</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingA</span><span class="params">(DirectExchange directExchange, Queue queueA)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用建造者模式创建</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(directExchange).with(RabbitMQConstant.ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列B绑定info</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingB1</span><span class="params">(DirectExchange directExchange, Queue queueB)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(directExchange).with(RabbitMQConstant.ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列B绑定warn</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingB2</span><span class="params">(DirectExchange directExchange, Queue queueB)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(directExchange).with(RabbitMQConstant.ROUTING_WARNING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 发送一个两个队列都能接收的消息</span></span><br><span class="line">        <span class="comment">// 使用建造者模式创建消息</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        <span class="comment">// 参数1 交换机, 参数2 路由key, 参数3 消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_DIRECT, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_KEY, message);</span><br><span class="line">        <span class="comment">// 发送一个只有队列B能接收的消息</span></span><br><span class="line">        <span class="comment">// 使用建造者模式创建消息</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">error_message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;error world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_DIRECT,</span><br><span class="line">                                      RabbitMQConstant.ROUTING_WARNING_KEY, error_message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 接收A队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_DIRECT_A&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgA</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到A的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收B队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_DIRECT_B&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgB</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到B的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Wed Jul 30 22:01:46 GMT+08:00 2025</span><br><span class="line">接收到B的消息为:hello world</span><br><span class="line">接收到A的消息为:hello world</span><br><span class="line">接收到B的消息为:error world</span><br></pre></td></tr></table></figure><h3 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Topic 类型的 Exchange 与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过 Topic 类型 Exchange 可以让队列在绑定 Routing key 的时候使用通配符！即direct是完全匹配，topic模式是模糊匹配。</span><br><span class="line">通配符匹配(相当于模糊匹配)，Topic模式中路由键通过<span class="string">&quot;.&quot;</span>分为多个部分。</span><br></pre></td></tr></table></figure><p>通配符规则：用”.”隔开的为一个单词。</p><p>#：匹配一个或多个词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beijing.# == beijing.queue.abc, beijing.queue.xyz.xxx</span><br></pre></td></tr></table></figure><p>*：匹配不多不少恰好 1 个词。必须有一个而且只有一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beijing.* == beijing.queue, beijing.xyz</span><br></pre></td></tr></table></figure><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_TOPIC</span> <span class="operator">=</span> <span class="string">&quot;exchange.topic&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_TOPIC_A</span> <span class="operator">=</span> <span class="string">&quot;queue.topic.a&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_TOPIC_B</span> <span class="operator">=</span> <span class="string">&quot;queue.topic.b&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">topicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(RabbitMQConstant.EXCHANGE_TOPIC).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_TOPIC_A).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_TOPIC_B).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingA</span><span class="params">(TopicExchange topicExchange, Queue queueA)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(topicExchange).with(<span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingB1</span><span class="params">(TopicExchange topicExchange, Queue queueB)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(topicExchange).with(<span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingB2</span><span class="params">(TopicExchange topicExchange, Queue queueB)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(topicExchange).with(<span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        <span class="comment">// 参数1 交换机,参数2 发送路由key, 参数3 消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_TOPIC, <span class="string">&quot;lazy.orange.rabbit&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 接收A队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_TOPIC_A&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgA</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到A的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收B队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_TOPIC_B&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgB</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到B的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接收到A的消息为:hello world</span><br><span class="line">接收到B的消息为:hello world</span><br></pre></td></tr></table></figure><h3 id="Headers-Exchange"><a href="#Headers-Exchange" class="headerlink" title="Headers Exchange"></a>Headers Exchange</h3><p>基于消息内容中的headers属性进行匹配，不是根据路由键匹配。headers交换器和direct交换器完全一致，但性能差很多，几乎不用了。</p><p>消费方指定的headers中必须包含一个”x-match”键，”x-match”键的值有两个</p><ul><li><p>x-match=all:表示所有的键值对都匹配才能接受消息</p></li><li><p>x-match=any:表示只要有键值对匹配就能接受消息</p></li></ul><p>发消息时可以指定消息属性(MessageProperties)，如果heanders中包含多个消息属性，则所有属性都匹配上才算匹配上。</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_HEADERS</span> <span class="operator">=</span> <span class="string">&quot;exchange.headers&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_HEADERS_A</span> <span class="operator">=</span> <span class="string">&quot;queue.headers.a&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_HEADERS_B</span> <span class="operator">=</span> <span class="string">&quot;queue.headers.b&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HeadersExchange <span class="title function_">headersExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.headersExchange(RabbitMQConstant.EXCHANGE_HEADERS).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_HEADERS_A).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_HEADERS_B).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定队列与交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingA</span><span class="params">(HeadersExchange headersExchange, Queue queueA)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; headerValues = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headerValues.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        headerValues.put(<span class="string">&quot;status&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(headersExchange).whereAll(headerValues).match();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingB</span><span class="params">(HeadersExchange headersExchange, Queue queueB)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; headerValues = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headerValues.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;s&quot;</span>);</span><br><span class="line">        headerValues.put(<span class="string">&quot;status&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(headersExchange).whereAll(headerValues).match();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 消息属性</span></span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">        Map&lt;String, Object&gt; headers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headers.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;s&quot;</span>);</span><br><span class="line">        headers.put(<span class="string">&quot;status&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置消息头</span></span><br><span class="line">        messageProperties.setHeaders(headers);</span><br><span class="line">        <span class="comment">// 添加了消息属性</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .andProperties(messageProperties).build();</span><br><span class="line">        <span class="comment">// 头部交换机,路由key无所谓</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_HEADERS, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 接收A队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_HEADERS_A&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgA</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到A的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收B队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_HEADERS_B&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgB</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到B的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕！</span><br><span class="line">接收到B的消息为:hello world</span><br></pre></td></tr></table></figure><h3 id="自定义交换机"><a href="#自定义交换机" class="headerlink" title="自定义交换机"></a>自定义交换机</h3><p>参考：延时交换机使用方式</p><h2 id="交换机属性"><a href="#交换机属性" class="headerlink" title="交换机属性"></a>交换机属性</h2><h3 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h3><ol><li><p>name：交换机名称，就是一个字符串</p></li><li><p>Type：交换机类型(direct、topic、fanout、headers、x-local-random)五种</p></li><li><p>durable：持久化，声明交换机是否持久化，代表交换机在服务器重启后是否还存在</p></li><li><p>autoDelete：是否自动删除，曾经有队列绑定到该交换机，后来解绑了，那就会自动删除该交换机</p></li><li><p>internal：内部使用的，如果是yes表示客户端无法直接发消息到此交换机，它只能用于交换机与交换机的绑定</p></li><li><p>arguments：只有一个取值alternate-exchange，表示备用交换机</p></li><li><p>alternate：设置备用交换机</p></li></ol><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_DIRECT</span> <span class="operator">=</span> <span class="string">&quot;exchange.direct&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DIRECT</span> <span class="operator">=</span> <span class="string">&quot;queue.direct&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 1、定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder <span class="comment">// 默认为持久化的</span></span><br><span class="line">                .directExchange(RabbitMQConstant.EXCHANGE_DIRECT) <span class="comment">// 交换机的名字</span></span><br><span class="line">                .autoDelete() <span class="comment">// 是否自动删除,默认不自动删除,调用该方法则表示自动删除</span></span><br><span class="line">                .durable(<span class="literal">false</span>) <span class="comment">// false表示不持久化,服务器重启会丢失;true表示持久化</span></span><br><span class="line">                <span class="comment">// 是否是内部使用(如果是yes表示客户端无法直接发消息到此交换机,它只能用于交换机与交换机的绑定)</span></span><br><span class="line">                .internal() <span class="comment">// 调用此方法表示设置为true</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DIRECT).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  3、绑定交换机与队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(DirectExchange directExchange, Queue queue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(directExchange).with(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_DIRECT, <span class="string">&quot;info&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_DIRECT, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 接收队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_DIRECT&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsgA</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><ol><li><p>不加条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Wed Jul <span class="number">30</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">46</span> GMT+08:<span class="number">00</span> <span class="number">2025</span></span><br><span class="line">消息发送完毕！</span><br><span class="line">接收到的消息为:hello world</span><br></pre></td></tr></table></figure></li><li><p>当配置属性internal时报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Wed Jul 30 22:01:46 GMT+08:00 2025</span><br><span class="line">Shutdown Signal: channel error; protocol method: #method&lt;channel.close&gt;(reply-code:403 reply-text:ACCESS_REFUSED....</span><br></pre></td></tr></table></figure></li><li><p>测试持久化按上</p><p>设置持久化为false，重启rabbitmq-server，则交换机丢失</p></li><li><p>测试配置autoDelete</p><p>自动删除为 true，从控制台上手动解绑，会发现自动删除</p></li></ol><h2 id="备用交换机"><a href="#备用交换机" class="headerlink" title="备用交换机"></a>备用交换机</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当消息经过交换器准备路由给队列的时候，发现没有对应的队列可以投递信息，在rabbitmq中会默认丢弃消息。如果想要监测哪些消息被投递到没有对应的队列，可以用备用交换机来实现，然后接收备用交换机的消息从而记录日志或发送报警信息。</p><h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><p>注意：备用交换机一般使用fanout交换机</p><p>测试时：指定一个错误路由</p><p>重点：普通交换机设置参数绑定到备用交换机</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.normal.backup&quot;</span>;</span><br><span class="line">    <span class="comment">// 备用交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_BACKUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.backup&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.normal.backup&quot;</span>;</span><br><span class="line">    <span class="comment">// 备用队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_BACKUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.backup&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_WARNING_KEY</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 定义正常交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/*//指定当前正常的交换机的备用交换机是谁</span></span><br><span class="line"><span class="comment">        arguments.put(&quot;alternate-exchange&quot;, RabbitMQConstant.EXCHANGE_BACKUP_NAME);</span></span><br><span class="line"><span class="comment">        return new DirectExchange(RabbitMQConstant.EXCHANGE_NORMAL_NAME, true, false, arguments);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder <span class="comment">// 默认为持久化的,默认不自动删除</span></span><br><span class="line">                .directExchange(RabbitMQConstant.EXCHANGE_NORMAL_NAME) <span class="comment">// 交换机的名字</span></span><br><span class="line">                .alternate(RabbitMQConstant.EXCHANGE_BACKUP_NAME) <span class="comment">//设置备用交换机 alternate-exchange</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueNormal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定正常交换机和队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(DirectExchange normalExchange, Queue queueNormal)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueNormal).to(normalExchange)</span><br><span class="line">            .with(RabbitMQConstant.ROUTING_WARNING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义备用交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">alternateExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(RabbitMQConstant.EXCHANGE_BACKUP_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义备用队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">alternateQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_BACKUP_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定备用交换机和队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingAlternate</span><span class="params">(FanoutExchange alternateExchange, Queue alternateQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(alternateQueue).to(alternateExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        Message message= MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NORMAL_NAME,<span class="string">&quot;test&quot;</span>,message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 接收备用队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_BACKUP_NAME&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        log.info(<span class="string">&quot;接收到备用的消息为:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>发送消息</strong></p><p>故意写错路由key，由于正常交换机设置了备用交换机，所以该消息就会进入备用交换机从而进入备用队列。可以写一个程序接收备用对列的消息，接收到后通知相关人员进行处理。如果正常交换机没有设置备用交换机，则该消息会被抛弃。</p><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Wed Jul 30 22:01:46 GMT+08:00 2025</span><br><span class="line">接收到备用的消息为:hello world</span><br></pre></td></tr></table></figure><hr><h1 id="RabbitMQ-延时交换机"><a href="#RabbitMQ-延时交换机" class="headerlink" title="RabbitMQ 延时交换机"></a>RabbitMQ 延时交换机</h1><h2 id="延时问题"><a href="#延时问题" class="headerlink" title="延时问题"></a>延时问题</h2><p><strong>场景</strong>：有一个订单，15分钟内如果不支付，就把该订单设置为交易关闭，那么就不能支付了。</p><p><strong>解决方式</strong>：</p><ul><li><p><strong>定时任务方式</strong>：每隔3秒扫描一次数据库，查询过期的订单然后进行处理；</p><p><strong>优点：</strong>简单,容易实现；</p><p><strong>缺点：</strong></p><ul><li>存在延迟(延迟时间不准确)，如果你每隔1分钟扫一次，那么就有可能延迟1分钟；</li><li>性能较差,每次扫描数据库，如果订单量很大会影响性能</li></ul></li><li><p><strong>被动取消</strong>：当用户查询订单的时候,判断订单是否超时,超时了就取消(交易关闭)；</p><p><strong>优点：</strong>对服务器而言，压力小；</p><p><strong>缺点：</strong></p><ul><li>用户不查询订单，将永远处于待支付状态，会对数据统计等功能造成影响；</li><li>用户打开订单页面，有可能比较慢，因为要处理大量订单，用户体验少稍差；</li></ul></li><li><p>JDK延迟队列(单体应用，不能分布式下)：DelayedQueue。无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素</p><p><strong>优点：</strong>实现简单，任务延迟低</p><p><strong>缺点：</strong></p><ul><li>服务重启、宕机，数据丢失；</li><li>只适合单机版，不适合集群；</li><li>订单量大，可能内存不足而发生异常；</li></ul></li><li><p>采用消息中间件(rabbitmq)</p><p>RabbitMQ本身不支持延迟队列，可以使用TTL结合DLX的方式来实现消息的延迟投递，即把DLX跟某个队列绑定，到了指定时间，消息过期后，就会从DLX路由到这个队列，消费者可以从这个队列取走消息。</p><p>不同延迟时间的消息要发到不同的队列上，同一个队列的消息，它的延迟时间应该一样。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250730224552796.png" alt="image-20250730224552796"></p></li></ul><h2 id="延时交换机"><a href="#延时交换机" class="headerlink" title="延时交换机"></a>延时交换机</h2><h3 id="死信队列实现"><a href="#死信队列实现" class="headerlink" title="死信队列实现"></a>死信队列实现</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>给正常队列绑定一个死信交换机和设置死信路由key；给正常队列设置消息过期时间，过期时间用于模拟延时操作，当消息过期后没有被消费就会转到死信队列。</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机(</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.delay.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.delay.dlx.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.delay.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.delay.dlx.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME</span> <span class="operator">=</span> <span class="string">&quot;order1&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;error1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 重点:设置这两个参数</span></span><br><span class="line">        <span class="comment">// 设置队列的死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);</span><br><span class="line">        <span class="comment">// 设置死信路由key,要和死信交换机和死信队列绑定key一模一样,因为死信交换机是直连交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.ROUTING_DLX_NAME);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME)</span><br><span class="line">                .ttl(<span class="number">25000</span>)                 <span class="comment">// 队列的过期时间</span></span><br><span class="line">                .withArguments(arguments)     <span class="comment">// 设置对列的参数</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常交换机和正常队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlxExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机和死信队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDlx</span><span class="params">(DirectExchange dlxExchange, Queue dlxQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(dlxQueue).to(dlxExchange).with(RabbitMQConstant.ROUTING_DLX_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250730224414884.png" alt="image-20250730224414884"></p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>如果不设置队列的过期时间，在发送消息时设置消息的过期时间会存在以下问题</p><ul><li>若队头的消息过期时间长，后面的消息过期时间短，但因为队头的消息没有被消费，因此后面已过期的消息也无法到达死信队列中</li></ul><h4 id="多队列解决过期时间问题"><a href="#多队列解决过期时间问题" class="headerlink" title="多队列解决过期时间问题"></a>多队列解决过期时间问题</h4><p>对于上面存在的问题，可以将不同过期时间的消息发送到不同的队列上，过期后再转到死信队列上</p><p><strong>定义MQ</strong></p><p>注意：正常队列不要设置过期时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 重点:设置这两个参数</span></span><br><span class="line">        <span class="comment">// 设置队列的死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);</span><br><span class="line">        <span class="comment">// 设置死信路由key,要和死信交换机和死信队列绑定key一模一样,因为死信交换机是直连交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.ROUTING_DLX_NAME);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME)</span><br><span class="line">                <span class="comment">//.ttl(5000)                 // 队列的过期时间</span></span><br><span class="line">                .withArguments(arguments)     <span class="comment">// 设置对列的参数</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="comment">// 正常交换机和正常队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlxExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机和死信队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDlx</span><span class="params">(DirectExchange dlxExchange, Queue dlxQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(dlxQueue).to(dlxExchange).with(RabbitMQConstant.ROUTING_DLX_NAME);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><p>发送消息时先发送一条过期时间长的，再发送一条过期时间短的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            messageProperties.setExpiration(<span class="string">&quot;25000&quot;</span>); <span class="comment">// 第一条消息 过期时间</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world 1&quot;</span>.getBytes())</span><br><span class="line">                    .andProperties(messageProperties)</span><br><span class="line">                    .build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            messageProperties.setExpiration(<span class="string">&quot;15000&quot;</span>); <span class="comment">// 第二条消息 过期时间</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world 2&quot;</span>.getBytes())</span><br><span class="line">                    .andProperties(messageProperties)</span><br><span class="line">                    .build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><p>消费者监听死信队列的消息来查看消息接收的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 延迟队列一定要接收死信队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = RabbitMQConstant.QUEUE_DLX_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;,接收时间为:&#123;&#125;&quot;</span>, body, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：先接收到的是队头的消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Wed Jul 30 22:01:46 GMT+08:00 2025</span><br><span class="line">消息发送完毕，发送时间为:Wed Jul 30 22:01:46 GMT+08:00 2025</span><br><span class="line">接收到的消息为:hello world 1,接收时间为:Wed Jul 30 22:02:16 GMT+08:00 2025</span><br><span class="line">接收到的消息为:hello world 2,接收时间为:Wed Jul 30 22:02:16 GMT+08:00 2025</span><br></pre></td></tr></table></figure><h3 id="使用延时插件"><a href="#使用延时插件" class="headerlink" title="使用延时插件"></a>使用延时插件</h3><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><ol><li><p><strong>下载</strong></p><p>选择对应的版本下载 <a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">rabbitmq_delayed_message_exchange</a> 插件。官网下载地址<a href="http://www.rabbitmq.com/community-plugins.html">community-plugins</a>。</p></li><li><p><strong>插件拷贝到 RabbitMQ 服务器plugins目录下</strong></p></li><li><p>解压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install unzip -y <span class="comment"># 如果unzip没有安装,先安装一下</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/rabbitmq_server-4.0.7/plugins</span><br><span class="line">unzip rabbitmq_delayed_message_exchange-v4.0.7.ez</span><br></pre></td></tr></table></figure></li><li><p><strong>启用插件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/rabbitmq_server-4.0.7/sbin/</span><br><span class="line">./rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_delayed_message_exchange </span><br></pre></td></tr></table></figure></li><li><p><strong>查询安装情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rabbitmq-plugins list <span class="comment"># 查询安装的所有插件</span></span><br></pre></td></tr></table></figure></li><li><p>重启Rabbitmq使其生效</p></li></ol><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>消息发送后不会直接投递到队列，而是先存储到内嵌的 Mnesia数据库中，然后会检查 x-delay 时间(消息头部)，将过期的消息放到死信队列中。延迟插件在 RabbitMQ 3.5.7 及以上的版本才支持，依赖 Erlang/OPT 18.0 及以上运行环境；</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250730225956046.png" alt="image-20250730225956046"></p><p>Mnesia 是一个小型数据库，不适合于大量延迟消息的实现。解决了消息过期时间不一致出现的问题。</p><h4 id="实现延时队列"><a href="#实现延时队列" class="headerlink" title="实现延时队列"></a>实现延时队列</h4><p>消息只要发送到延时交换机即可，延时交换机绑定死信路由的key</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机(死信交换机)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.delay.4&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.delay.4&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME</span> <span class="operator">=</span> <span class="string">&quot;plugin4&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><p>注意延时交换机需要使用自定义类型定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 创建自定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">customExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>); <span class="comment">// 放一个参数</span></span><br><span class="line">        <span class="comment">// CustomExchange(String name, String type, boolean durable, boolean autoDelete, </span></span><br><span class="line">        <span class="comment">// Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                  <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(RabbitMQConstant.QUEUE_NAME) <span class="comment">// 队列名称</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(CustomExchange customExchange, Queue queue)</span> &#123;</span><br><span class="line">        <span class="comment">//绑定也指定路由key,加noargs 方法</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(customExchange).with(RabbitMQConstant.ROUTING_NAME).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><p>生产者发送消息时要在headers中添加过期时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            messageProperties.setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">25000</span>);<span class="comment">// 第一条消息 延迟时间</span></span><br><span class="line">            <span class="comment">//messageProperties.setExpiration(&quot;25000&quot;); // 不要用这个</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world 1&quot;</span>.getBytes())</span><br><span class="line">                    .andProperties(messageProperties)</span><br><span class="line">                    .build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            messageProperties.setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">15000</span>); <span class="comment">// 第二条消息 延迟时间</span></span><br><span class="line">            <span class="comment">//messageProperties.setExpiration(&quot;15000&quot;); // 不要用这个</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world 2&quot;</span>.getBytes())</span><br><span class="line">                    .andProperties(messageProperties)</span><br><span class="line">                    .build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">// 延迟队列一定要接收死信队列的消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = RabbitMQConstant.QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;,接收时间为:&#123;&#125;&quot;</span>, body, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="RabbitMQ-死信队列"><a href="#RabbitMQ-死信队列" class="headerlink" title="RabbitMQ 死信队列"></a>RabbitMQ 死信队列</h1><h2 id="过期消息（Time-To-Live，TTL）"><a href="#过期消息（Time-To-Live，TTL）" class="headerlink" title="过期消息（Time To Live，TTL）"></a>过期消息（Time To Live，TTL）</h2><p>消息的过期时间有两种设置方式：(过期消息)</p><ol><li><strong>单条消息过期</strong>：单条消息的过期时间决定了在没有任何消费者消费时,消息可以存活多久；</li><li><strong>队列属性设置所有消息过期</strong>：队列的过期时间决定了在没有任何消费者的情况下，队列中的消息可以存活多久；</li></ol><p>如果消息和对列都设置过期时间，则消息的TTL以两者之间较小的那个数值为准。</p><h3 id="设置消息过期时间"><a href="#设置消息过期时间" class="headerlink" title="设置消息过期时间"></a>设置消息过期时间</h3><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.ttl.a&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_TNAME</span> <span class="operator">=</span> <span class="string">&quot;queue.ttl.a&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 1、定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_TNAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、绑定交换机与队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(DirectExchange directExchange, Queue queue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(directExchange).with(RabbitMQConstant.ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 设置单条消息的过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">        messageProperties.setExpiration(<span class="string">&quot;35000&quot;</span>); <span class="comment">//过期的毫秒</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .andProperties(messageProperties).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_KEY, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：发送消息后查看 <code>queue.ttl.a</code> 有一条数据，35秒后查看发现数据丢失。</p><h3 id="设置队列消息过期时间"><a href="#设置队列消息过期时间" class="headerlink" title="设置队列消息过期时间"></a>设置队列消息过期时间</h3><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.ttl.b&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_TNAME</span> <span class="operator">=</span> <span class="string">&quot;queue.ttl.b&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 1、定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 方式1 new Queue 的方式</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">15000</span>); <span class="comment">// 消息过期时间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(RabbitMQConstant.QUEUE_TNAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">        <span class="comment">// 方式2 建造者</span></span><br><span class="line">        <span class="comment">//return QueueBuilder.durable(RabbitMQConstant.QUEUE_TNAME).withArguments(arguments).build();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、绑定交换机与队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(DirectExchange directExchange, Queue queue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(directExchange).with(RabbitMQConstant.ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_KEY, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：先后发送两条消息，发送消息后查看 queue.ttl.b 有2条数据，第1条消息到期后消失，第2条消息到期后消失</p><h2 id="死信队列（Dead-Letter-Exchange，DLX）"><a href="#死信队列（Dead-Letter-Exchange，DLX）" class="headerlink" title="死信队列（Dead Letter Exchange，DLX）"></a>死信队列（Dead Letter Exchange，DLX）</h2><h3 id="单条消息过期"><a href="#单条消息过期" class="headerlink" title="单条消息过期"></a>单条消息过期</h3><p>消息设置了过期时间，在到达过期时间后消息没有被消费：可能是因为消息积压太多，消息消费不过来；也可能是没有对应的消费者。</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常队列,没有消费者,设置过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.dlx.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.dlx.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_KEY</span> <span class="operator">=</span> <span class="string">&quot;order1&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DLX_KEY</span> <span class="operator">=</span> <span class="string">&quot;error1&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 示例中，各个示例的编号分别顺次为1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NORMAL_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 重点:设置这两个参数</span></span><br><span class="line">        <span class="comment">// 设置队列的死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);</span><br><span class="line">        <span class="comment">// 设置死信路由key,要和死信交换机和死信队列绑定key一模一样,因为死信交换机是直连交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.DLX_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME)</span><br><span class="line">                .withArguments(arguments)     <span class="comment">// 设置对列的参数</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常交换机和正常队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.NORMAL_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlxExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机和死信队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDlx</span><span class="params">(DirectExchange dlxExchange, Queue dlxQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(dlxQueue).to(dlxExchange).with(RabbitMQConstant.DLX_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 生产者发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 消息属性</span></span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">        <span class="comment">// 设置单条消息的过期时间,单位为毫秒,数据类型为字符串</span></span><br><span class="line">        messageProperties.setExpiration(<span class="string">&quot;15000&quot;</span>);</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .andProperties(messageProperties).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NORMAL_NAME, </span><br><span class="line">                                      RabbitMQConstant.NORMAL_KEY, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕:发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：发送的消息先出现在正常队列，待过期后消息会出现在死信队列</p><h3 id="队列设置过期"><a href="#队列设置过期" class="headerlink" title="队列设置过期"></a>队列设置过期</h3><p>队列设置了过期时间，在到达过期时间后消息没有被消费：可能是因为消息积压太多，消息消费不过来；也可能是没有对应的消费者。</p><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置队列的过期时间为20秒</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">20000</span>);</span><br><span class="line">        <span class="comment">// 设置这两个参数</span></span><br><span class="line">        <span class="comment">// 重点:给正常队列绑定死信交换机和设置死信路由的key,也就是消息过期后发送到哪个死信交换机,发送时设置死信路由的key</span></span><br><span class="line">        <span class="comment">// 设置对列的死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME); </span><br><span class="line">         <span class="comment">// 设置死信路由key,要和死信交换机和死信队列绑定key一模一样</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.DLX_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NORMAL_NAME, </span><br><span class="line">                                      RabbitMQConstant.NORMAL_KEY, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕:发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：发送的消息先出现在正常队列，待过期后消息会出现在死信队列</p><h3 id="队列到达最大长度"><a href="#队列到达最大长度" class="headerlink" title="队列到达最大长度"></a>队列到达最大长度</h3><p>先入队的消息会被发送到DLX</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.normal.2&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常队列:没有消费者、设置过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.normal.2&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.dlx.2&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.dlx.2&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_KEY</span> <span class="operator">=</span> <span class="string">&quot;order2&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DLX_KEY</span> <span class="operator">=</span> <span class="string">&quot;error2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置对列的最大长度</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 重点:设置这两个参数</span></span><br><span class="line">        <span class="comment">// 设置队列的死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);</span><br><span class="line">        <span class="comment">// 设置死信路由key,要和死信交换机和死信队列绑定key一模一样,因为死信交换机是直连交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.DLX_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME)</span><br><span class="line">                .withArguments(arguments) <span class="comment">// 设置对列过期时间</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world &quot;</span> + i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(str.getBytes()).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NORMAL_NAME,</span><br><span class="line">                                          RabbitMQConstant.NORMAL_KEY, message);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕:发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：超过正常队列的长度后先入队的消息会放入死信队列</p><h3 id="消费消息不进行重新投递"><a href="#消费消息不进行重新投递" class="headerlink" title="消费消息不进行重新投递"></a>消费消息不进行重新投递</h3><ul><li>从正常的队列接收消息，但对消息不进行确认并且不对消息进行重新投递，此时消息就进入死信队列</li><li>业务处理过程中出现异常也会变成死信，因为消费者没有进行确认</li></ul><p><strong>配置MQ</strong></p><p>需要开启消费者手动确认模式，否则默认是消息消费后自动确认的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dlx-learn4</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="comment"># 开启消费者手动确认</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">15000</span>); <span class="comment">//设置对列的过期时间</span></span><br><span class="line">        <span class="comment">// 重点:设置这两个参数</span></span><br><span class="line">        <span class="comment">// 设置对列的死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);</span><br><span class="line">        <span class="comment">// 设置死信路由key,要和死信交换机和死信队列绑定key一模一样,因为死信交换机是直连交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.DLX_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME)</span><br><span class="line">                .withArguments(arguments) <span class="comment">// 设置对列的参数</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(str.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NORMAL_NAME, </span><br><span class="line">                                      RabbitMQConstant.NORMAL_KEY, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕:发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听正常的那个队列的名字,不是监听那个死信队列</span></span><br><span class="line"><span class="comment">     * 从正常的队列接收消息,但是对消息不进行确认,并且不对消息进行重新投递,此时消息就进入死信队列</span></span><br><span class="line"><span class="comment">     * channel 消息信道(是连接下的一个消息信道,一个连接下有多个消息信息,发消息/接消息都是通过信道完成的)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NORMAL_NAME&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message, Channel channel)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的消息:&quot;</span> + message);</span><br><span class="line">        <span class="comment">//对消息不确认,ack单词是 确认 的意思</span></span><br><span class="line">        <span class="comment">// void basicNack(long deliveryTag, boolean multiple, boolean requeue)</span></span><br><span class="line">        <span class="comment">// deliveryTag:消息的一个数字标签</span></span><br><span class="line">        <span class="comment">// multiple:true表示对小于deliveryTag标签下的消息都进行Nack不确认;false表示只对当前deliveryTag标签的消息Nack</span></span><br><span class="line">        <span class="comment">// requeue:true表示消息被Nack后重新发送到队列;false表示消息被Nack后不会重新发送到队列</span></span><br><span class="line">        <span class="comment">// 获取消息属性</span></span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> message.getMessageProperties();</span><br><span class="line">        <span class="comment">// 获取消息的唯一标识,类似身份证或者学号</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> messageProperties.getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">            log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;,接收时间为:&#123;&#125;&quot;</span>, str, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="comment">//TODO 业务逻辑处理</span></span><br><span class="line">            <span class="comment">// 这里模拟一个异常,出现异常后进行手动不确认并且不重新投递设置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 消费者的手动确认:false表示只确认当前消息;改成true为批量确认标志号小于当前标志号的所有消息</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;接收着出现问题:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 消费者的手动不确认:参数3为false表示不重新入队(不重新投递),就会变成死信;为true表示是重新入队</span></span><br><span class="line">                channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：模拟异常，发现消息未重新入队，而是进入了死信队列</p><h3 id="消费者拒绝消息"><a href="#消费者拒绝消息" class="headerlink" title="消费者拒绝消息"></a>消费者拒绝消息</h3><p>开启手动确认模式并拒绝消息，不重新投递，则进入死信队列</p><p>配置<code>yaml</code>时需要开启消费者手动确认模式，配置同上述消息不进行重新投递</p><p><strong>定义MQ</strong></p><p>这里的队列无需设置队列的过期时间，因为消费者拒绝后如果不重新投递就直接进入死信队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.QUEUE_DLX_NAME);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(str.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NORMAL_NAME, </span><br><span class="line">                                      RabbitMQConstant.NORMAL_KEY, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕:发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义消费者</strong></p><p>消费者拒绝消息后不进行重新投递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听正常的那个队列的名字,不是监听那个死信队列</span></span><br><span class="line"><span class="comment">     * 我们从正常的队列接收消息,但是对消息不进行确认,并且不对消息进行重新投递,此时消息就进入死信队列</span></span><br><span class="line"><span class="comment">     * channel 消息信道(是连接下的一个消息信道,一个连接下有多个消息信息,发消息/接消息都是通过信道完成的)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NORMAL_NAME&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message, Channel channel)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的消息:&quot;</span> + message);</span><br><span class="line">        <span class="comment">// 获取消息属性</span></span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> message.getMessageProperties();</span><br><span class="line">        <span class="comment">// 获取消息的唯一标识,类似身份证或者学号</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> messageProperties.getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">            log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;,接收时间为:&#123;&#125;&quot;</span>, str, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="comment">// TODO 业务逻辑处理</span></span><br><span class="line">            <span class="comment">// 这里模拟一个业务异常,出现异常后进入消费者拒绝设置,不进行重新投递</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 消费者的手动确认:false是只确认当前消息;改成true为批量确认标志号小于当前标志号的所有消息</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;接收着出现问题:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 拒绝消息:参数1是消息的标识,参数2是否重新入队(false表示拒绝后不重新入队),不可以批量处理</span></span><br><span class="line">                channel.basicReject(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：拒绝后的消息不再入队，正常和死信队列都没有了</p><h3 id="死信应用场景"><a href="#死信应用场景" class="headerlink" title="死信应用场景"></a>死信应用场景</h3><ul><li>监听死信消息以便查找问题</li><li>可以实现延时队列业务</li></ul><hr><h1 id="RabbitMQ-队列"><a href="#RabbitMQ-队列" class="headerlink" title="RabbitMQ 队列"></a>RabbitMQ 队列</h1><h2 id="队列属性"><a href="#队列属性" class="headerlink" title="队列属性"></a>队列属性</h2><ol><li><p>Type：设置队列的队列类型;</p></li><li><p>Name：队列名称，就是一个字符串，随便一个字符串就可以；</p></li><li><p>Durability：声明队列是否持久化，代表队列在服务器重启后是否还存在；</p></li><li><p>Auto delete：是否自动删除。true表示当没有消费者连接到这个队列时，队列会自动删除；</p></li><li><p>Exclusive：该属性的队列只对第一个连接它的消费者可见（之后其它消费者无法访问该队列），连接断开时自动删除。基本设置成false</p></li><li><p>Arguments：队列的其他属性，例如指定DLX(死信交换机等)；</p><ol><li><p><code>x-expires:Number</code>：当Queue(队列)在指定的时间未被访问则队列将被自动删除</p></li><li><p><code>x-message-ttl:Number</code>：发布的消息在队列中存在多长时间后被取消(单位毫秒)</p></li><li><p><code>x-overflow:String</code>：设置队列溢出行为，当达到队列的最大长度时消息的处理方式</p><ol><li><code>drop-head</code>：删除头部消息</li><li><code>reject-publish</code>：超过队列长度后，后面发布的消息会被拒绝接收</li><li><code>reject-publish-dlx</code>：超过队列长度后，后面发布的消息会被拒绝接收并发布到死信交换机</li></ol><p>仲裁队列类型仅支持:drop-head and reject-publish两种</p></li><li><p><code>x-max-length:Number</code>：队列所能容下消息的最大长度，当超出长度后新消息将会覆盖最前面的消息</p></li><li><p><code>x-max-length-bytes:Number</code>：队列在开始从头部删除就绪消息之前可以包含的总正文大小。受限于内存大小，超过该阈值则从队列头部开始删除消息</p></li><li><p><code>x-single-active-consumer</code>：表示队列是否是只能有一个消费者。设置为true时注册的消费组内只有一个消费者消费消息，其他被忽略设置为false时消息循环分发给所有消费者(默认false)</p></li><li><p><code>x-dead-letter-exchange:String</code>：指定队列关联的死信交换机。队列消息达上限后溢出消息不被删掉，而保存到另一队列；</p></li><li><p><code>x-dead-letter-routing-key:String</code>：指定死信交换机的路由键，一般和7一起定义</p></li><li><p><code>x-queue-mode:String</code>：队列类型<code>x-queue-mode=lazy</code>懒队列，在磁盘上尽可能多地保留消息以减少RAM使用。如果未设置则队列将保留内存缓存以尽可能快地传递消息；如果设置则队列消息将保存在磁盘上，消费时从磁盘上读取消费</p></li><li><p><code>x-queue-master-locator:String</code>(用的较少)：在集群模式下设置队列分配到的主节点位置信息；</p><p>每个queue都有一个master节点，所有对于queue的操作都是事先在master上完成，之后再slave上进行相同的操作；</p><p>每个不同的queue可以坐落在不同的集群节点上，这些queue如果配置了镜像队列，那么会有1个master和多个slave</p><p>基本上所有的操作都落在master上，那么如果这些queues的master都落在个别的服务节点上，而其他的节点又很空闲，这样就无法做到负载均衡，那么势必会影响性能；</p><p>关于master queue host 的分配有几种策略，可以在queue声明的时候使用x-queue-master-locator参数，或者在policy上设置queue-master-locator，或者直接在rabbitmq的配置文件中定义queue_master_locator有三种可供选择的策略</p><ol><li><code>min-masters</code>：选择master queue数最少的那个服务节点host；</li><li><code>client-local</code>：选择与client相连接的那个服务节点host；</li><li><code>random</code>:随机分配；</li></ol></li></ol></li></ol><h2 id="属性测试"><a href="#属性测试" class="headerlink" title="属性测试"></a>属性测试</h2><h3 id="非持久化属性测试"><a href="#非持久化属性测试" class="headerlink" title="非持久化属性测试"></a>非持久化属性测试</h3><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.properties.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME1</span> <span class="operator">=</span> <span class="string">&quot;queue.properties.test1.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME2</span> <span class="operator">=</span> <span class="string">&quot;queue.properties.test1.2&quot;</span>;</span><br><span class="line">    <span class="comment">// 路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME1</span> <span class="operator">=</span> <span class="string">&quot;key.properties.test1.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME2</span> <span class="operator">=</span> <span class="string">&quot;key.properties.test1.2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例中，各个示例的编号分别顺次为1,2,3,4,5...</span></span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列 不持久化、不设置名字</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列 不持久化、设置名字</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(RabbitMQConstant.QUEUE_NAME1).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal1</span><span class="params">(DirectExchange normalExchange, Queue normalQueue1)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue1).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal2</span><span class="params">(DirectExchange normalExchange, Queue normalQueue2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue2).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world1&quot;</span>.getBytes()).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world2&quot;</span>.getBytes()).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME2, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发行消息查看控制台发现。设置了名字的会使用自定义名字，未设置名字的队列会自动生成名字</span><br><span class="line">不持久化的队列在服务器重启后队列会消失</span><br></pre></td></tr></table></figure><h3 id="持久化测试"><a href="#持久化测试" class="headerlink" title="持久化测试"></a>持久化测试</h3><p>是否自动删除。如果为true，当没有消费者连接到这个队列的时候，队列会自动删除</p><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机同上</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正常队列 持久化、不设置名字</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列 持久化、设置名字</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发行消息查看控制台发现。设置了名字的会使用自定义名字，未设置名字的队列会自动生成名字</span><br><span class="line">持久化的队列在服务器重启后队列依然存在</span><br></pre></td></tr></table></figure><h3 id="自动删除测试"><a href="#自动删除测试" class="headerlink" title="自动删除测试"></a>自动删除测试</h3><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机同上</span></span><br><span class="line">    <span class="comment">// 正常队列 持久化、不设置名字</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1)</span><br><span class="line">            .autoDelete()<span class="comment">// 设置自动删除</span></span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列 持久化、设置名字</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME2)</span><br><span class="line">            <span class="comment">// .autoDelete()// 设置不自动删除,默认就是不自动删除</span></span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceivemessageService</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME1&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg1</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;1接收到的消息为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME2&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg2</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;2接收到的消息为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：设置为自动删除的队列1在没有消费者连接后被自动删除</p><h3 id="可见性测试"><a href="#可见性测试" class="headerlink" title="可见性测试"></a>可见性测试</h3><p>普通队列允许的消费者没有限制，多个消费者绑定到同一个队列时，RabbitMQ会采用轮询进行投递。如果需要消费者独占队列，在队列创建的时候，设定属性exclusive为true。</p><p>exclusive有两个作用</p><ul><li><p>当连接关闭时connection.close()该队列是否会自动删除；</p></li><li><p>该队列是否是私有的private</p></li></ul><p>如果设置为false则可以使用两个消费者都访问同一个队列，没有任何问题；如果设置为true则会对当前队列加锁,其他连接connection是不能访问的，同一个连接的不同channel是可以访问的。如果强制访问会报如下异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">It could be originally declared on another connection or the exclusive property value does not match that of the original declaration., class-id=60, method-id=20)</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1)</span><br><span class="line">                .exclusive()<span class="comment">//声明只有第一个连接的消费者可见,(之后其它消费者无法访问该队列),并且在连接断开时自动删除</span></span><br><span class="line">                <span class="comment">//.autoDelete()// 设置自动删除</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal1</span><span class="params">(DirectExchange normalExchange, Queue normalQueue1)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue1).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><p>这里的消费者表示在同一个Connection中消费消息的多个消费者，测试是否同一个Connection中的多个消费者可以消费。代码同上。</p><p><strong>发送消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rabbitmq08Properties04Application</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Rabbitmq08Properties04Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SendMessageService sendMessageService;</span><br><span class="line">    <span class="comment">// 程序一启动就会运行该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sendMessageService.sendMsg();</span><br><span class="line"></span><br><span class="line">        &#123;    <span class="comment">// 1.创建连接工厂</span></span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            <span class="comment">// 2.设置工厂参数</span></span><br><span class="line">            factory.setHost(<span class="string">&quot;192.168.1.101&quot;</span>);</span><br><span class="line">            factory.setPort(<span class="number">5672</span>);</span><br><span class="line">            factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            factory.setVirtualHost(<span class="string">&quot;longdidi&quot;</span>);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.创建channel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">                <span class="comment">// 回调方法 当收到信息 自动执行该方法consumerTag</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, </span></span><br><span class="line"><span class="params">                                           AMQP.BasicProperties properties, </span></span><br><span class="line"><span class="params">                                           <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接1接收到信息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            channel.basicConsume(RabbitMQConstant.QUEUE_NAME1, <span class="literal">true</span>, consumer);</span><br><span class="line">            <span class="comment">// 6.释放资源</span></span><br><span class="line">            channel.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1.创建连接工厂</span></span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            <span class="comment">// 2.设置工厂参数</span></span><br><span class="line">            factory.setHost(<span class="string">&quot;192.168.1.101&quot;</span>);</span><br><span class="line">            factory.setPort(<span class="number">5672</span>);</span><br><span class="line">            factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            factory.setVirtualHost(<span class="string">&quot;longdidi&quot;</span>);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">            <span class="comment">// 3.创建channel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">                <span class="comment">// 回调方法 当收到信息 自动执行该方法 consumerTag</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span><br><span class="line"><span class="params">                                           AMQP.BasicProperties properties, </span></span><br><span class="line"><span class="params">                                           <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接2接收到信息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            channel.basicConsume(RabbitMQConstant.QUEUE_NAME1, <span class="literal">true</span>, consumer);</span><br><span class="line">            <span class="comment">// 6.释放资源</span></span><br><span class="line">            channel.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.启动程序，如果有多个Connection连接会报错：channel error;protocol method:#method...</span><br><span class="line">2.注释掉主程序中的两个Connection连接代码重启测试，发现同一Connection内的多个消费者可以连接消费，输出如下</span><br><span class="line">消息发送完毕，发送时间为:Thu Jul 31 14:20:30 GMT+08:00 2025</span><br><span class="line">消息发送完毕，发送时间为:Thu Jul 31 14:20:30 GMT+08:00 2025</span><br><span class="line">消费者1接收到的消息为:hello world2</span><br><span class="line">消费者2接收到的消息为:hello world1</span><br><span class="line">3.停止程序运行查看队列是否自动删除：当连接关闭时队列自动删除</span><br></pre></td></tr></table></figure><h3 id="Arguments测试"><a href="#Arguments测试" class="headerlink" title="Arguments测试"></a>Arguments测试</h3><h4 id="删除属性测试"><a href="#删除属性测试" class="headerlink" title="删除属性测试"></a>删除属性测试</h4><p><code>x-expires</code>属性：当Queue(队列)在指定的时间未被访问则队列将被自动删除。</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.properties.normal.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.properties.dlx.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME1</span> <span class="operator">=</span> <span class="string">&quot;queue.properties.normal.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DLX_NAME1</span> <span class="operator">=</span> <span class="string">&quot;queue.properties.dlx.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME1</span> <span class="operator">=</span> <span class="string">&quot;key.properties.normal.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_DLX_NAME1</span> <span class="operator">=</span> <span class="string">&quot;key.properties.dlx.1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-expires&quot;</span>, <span class="number">10000L</span>); <span class="comment">// 当Queue(队列)在指定的时间未被访问则队列将被自动删除</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常交换机和正常队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：启动应用查看控制台,生成了队列，等待10s之后刷新控制台，队列被删除</p><h4 id="设置队列过期时间"><a href="#设置队列过期时间" class="headerlink" title="设置队列过期时间"></a>设置队列过期时间</h4><p>发布的消息在队列中存在多长时间后被取消(单位毫秒)，参考 <a href="#%E9%98%9F%E5%88%97%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F">队列设置过期</a></p><h4 id="设置队列长度"><a href="#设置队列长度" class="headerlink" title="设置队列长度"></a>设置队列长度</h4><p><code>x-max-length:Number</code>：队列所能容下消息的最大长度，当超出长度后新消息将会覆盖最前面的消息。参考 <a href="#%E9%98%9F%E5%88%97%E5%88%B0%E8%BE%BE%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6">队列到达最大长度</a></p><h4 id="设置队列溢出行为"><a href="#设置队列溢出行为" class="headerlink" title="设置队列溢出行为"></a>设置队列溢出行为</h4><p>当达到队列的最大长度时消息的处理方式：有效值为drop-head(删除头部消息)、reject-publish(拒绝发布)或reject-publish-dlx(拒绝发布到死信交换机)。仲裁队列类型仅支持<code>drop-head</code> and <code>reject-publish</code>两种。</p><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, </span></span><br><span class="line">        <span class="comment">// @Nullable Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">5</span>);<span class="comment">// 队列的溢出行为,删除头部</span></span><br><span class="line">        <span class="comment">// 队列的溢出行为,删除头部(默认行为)</span></span><br><span class="line">        <span class="comment">// arguments.put(&quot;x-overflow&quot;, &quot;drop-head&quot;);</span></span><br><span class="line">        <span class="comment">// 队列的溢出行为,拒绝发布</span></span><br><span class="line">        <span class="comment">//arguments.put(&quot;x-overflow&quot;, &quot;reject-publish&quot;);</span></span><br><span class="line">        <span class="comment">// 队列的溢出行为,拒绝接收消息,超过长度的消息会被发送到死信交换机而不是拒绝接收</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-overflow&quot;</span>, <span class="string">&quot;reject-publish-dlx&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1)</span><br><span class="line">                .withArguments(arguments)</span><br><span class="line">                .deadLetterExchange(RabbitMQConstant.EXCHANGE_DLX_NAME)</span><br><span class="line">                .deadLetterRoutingKey(RabbitMQConstant.ROUTING_DLX_NAME1)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常交换机和正常队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlxExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_DLX_NAME1).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死信交换机和死信队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDlx</span><span class="params">(DirectExchange dlxExchange, Queue dlxQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(dlxQueue).to(dlxExchange).with(RabbitMQConstant.ROUTING_DLX_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.当属性设置为drop-head时</span><br><span class="line">如果超过队列长度,先入队的消息会被先删除(如果配置了死信交换机则会移至死信交换机)</span><br><span class="line">2.当属性设置为reject-publish时</span><br><span class="line">该模式下当队列达到最天长度后会拒绝收消息,也不会将队头的消息移至死信队列(如果配置了死信队列的话),超长的消息未被接收</span><br><span class="line">3.当属性设置为reject-publish-dlx时</span><br><span class="line">拒绝接收后面的消息并将拒绝的消息放到死信交换机中，后面发送的消息会存储到死信队列中</span><br></pre></td></tr></table></figure><h4 id="设置队列内存大小"><a href="#设置队列内存大小" class="headerlink" title="设置队列内存大小"></a>设置队列内存大小</h4><p><code>x-max-length-bytes:Number</code>：队列在开始从头部删除就绪消息之前可以包含的总正文大小。受限于内存大小，超过该阈值则从队列头部开始删除消息</p><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-max-length-bytes&quot;</span>, <span class="number">30</span>); <span class="comment">// 队列的内存大小</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;你好我好大家好&quot;</span> + i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(str.getBytes()).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(str.getBytes()).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">            log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：队列中只剩3条信息，先入队的超过内存的限制的消息被删除了</p><h4 id="设置单一消费者"><a href="#设置单一消费者" class="headerlink" title="设置单一消费者"></a>设置单一消费者</h4><p>表示队列是否是只能有一个消费者。设置为true时注册的消费组内只有一个消费者消费消息，其他被忽略；设置为false时消息循环分发给所有消费者(默认false)。</p><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-single-active-consumer&quot;</span>, <span class="literal">true</span>);<span class="comment">//队列的最大长度</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceivemessageService</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME1&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg1</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;消费者1接收到的消息为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME1&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg2</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;消费者2接收到的消息为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：只有消费者1收到了消息</p><h4 id="设置死信交换机"><a href="#设置死信交换机" class="headerlink" title="设置死信交换机"></a>设置死信交换机</h4><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机同上</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, RabbitMQConstant.EXCHANGE_DLX_NAME);<span class="comment">//死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, RabbitMQConstant.ROUTING_DLX_NAME1);<span class="comment">//死信路由key</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1)</span><br><span class="line">                .ttl(<span class="number">5000</span>) <span class="comment">// 设置超时时间</span></span><br><span class="line">                .withArguments(arguments)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：超时的消息放入了死信队列</p><hr><h1 id="RabbitMQ-消息可靠性"><a href="#RabbitMQ-消息可靠性" class="headerlink" title="RabbitMQ 消息可靠性"></a>RabbitMQ 消息可靠性</h1><h2 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h2><h3 id="Confirm模式简介"><a href="#Confirm模式简介" class="headerlink" title="Confirm模式简介"></a>Confirm模式简介</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250731150818210.png" alt="image-20250731150818210"></p><ol><li>代表消息从生产者发送到Exchange;</li><li>代表消息从Exchange路由到Queue；</li><li>代表消息在Queue中存储；</li><li>代表消费者监听Queue并消费消息；</li></ol><p>可能因为网络或者Broker的问题导致①失败，而此时应该让生产者知道消息是否正确发送到了Broker的exchange中；</p><p>有两种解决方案：</p><ul><li>开启Confirm(确认)模式；(异步)</li><li>开启Transaction(事务)模式；(性能低，实际项目中很少用)</li></ul><p>消息的confirm确认机制,是指生产者投递消息后，到达了消息<a href="https://so.csdn.net/so/search?q=%E6%9C%8D%E5%8A%A1%E5%99%A8&spm=1001.2101.3001.7020">服务器</a>Broker里面的exchange交换机，则会给生产者一个应答生产者接收到应答，用来确定这条消息是否正常的发送到Broker的exchange中，这也是消息可靠性投递的重要保障；</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250731150944952.png" alt="image-20250731150944952"></p><h3 id="Confirm模式实现"><a href="#Confirm模式实现" class="headerlink" title="Confirm模式实现"></a>Confirm模式实现</h3><ul><li><p>开启生产者确认模式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启生产者的确认模式,设置关联模式</span></span><br></pre></td></tr></table></figure></li><li><p>实现RabbitTemplate.ConfirmCallback交界口,重写confirm()方法</p><p>判断成功和失败的ack结果,可以根据具体的结果,如果ack为false,对消息进行重新发送或记录日志等处理</p></li><li><p>设置rabbitTemplate的确认回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setConfirmCallback(messageConfirmCallBack);</span><br></pre></td></tr></table></figure></li></ul><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.confirm.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME1</span> <span class="operator">=</span> <span class="string">&quot;queue.confirm.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME1</span> <span class="operator">=</span> <span class="string">&quot;key.confirm.normal.1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外部类实现"><a href="#外部类实现" class="headerlink" title="外部类实现"></a>外部类实现</h4><p><strong>生产者</strong>：设置回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MyConfirmCallBack confirmCallBack;</span><br><span class="line">    <span class="comment">// 构造方法执行后会调用一次该方法,只调用一次,起到初始化的作用</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(confirmCallBack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        <span class="comment">// 关联数据对象</span></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(); <span class="comment">//关联数据</span></span><br><span class="line">        <span class="comment">// 比如设置一个订单ID,到时候在confirm回调里面就可以知道是哪个订单没有发送到交换机上去</span></span><br><span class="line">        correlationData.setId(<span class="string">&quot;order_123456&quot;</span>); <span class="comment">// 发送订单信息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME + <span class="string">&quot;error&quot;</span>, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1, message, correlationData);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfirmCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机收到消息后,会回调该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 相关联的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack 有两个取值,true和false,true表示成功：消息正确地到达交换机,反之false就是消息没有正确地到达交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause 消息没有正确地到达交换机的原因是什么</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;关联id为：&#123;&#125;&quot;</span>, correlationData.getId() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息正确的达到交换机&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ack =false 没有到达交换机</span></span><br><span class="line">            log.error(<span class="string">&quot;消息没有到达交换机,原因为：&#123;&#125;&quot;</span>, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者实现"><a href="#生产者实现" class="headerlink" title="生产者实现"></a>生产者实现</h4><p><strong>生产者</strong>：生产者直接实现<code>RabbitTemplate.ConfirmCallback</code>接口，重写confirm()方法并设置回调函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(); <span class="comment">//关联数据</span></span><br><span class="line">        correlationData.setId(<span class="string">&quot;order_123456&quot;</span>); <span class="comment">// 发送订单信息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME + <span class="string">&quot;error&quot;</span>,</span><br><span class="line">                                      RabbitMQConstant.QUEUE_NAME1, message, correlationData);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;关联id为：&#123;&#125;&quot;</span>, correlationData.getId() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息正确的达到交换机&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.error(<span class="string">&quot;消息没有到达交换机,原因为：&#123;&#125;&quot;</span>, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部内实现"><a href="#匿名内部内实现" class="headerlink" title="匿名内部内实现"></a>匿名内部内实现</h4><p><strong>生产者</strong>：生产者使用匿名内部类实现<code>RabbitTemplate.ConfirmCallback</code>接口,重写confirm()方法并设置回调函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;关联id为：&#123;&#125;&quot;</span>, correlationData.getId() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">                            log.info(<span class="string">&quot;消息正确的达到交换机&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        log.error(<span class="string">&quot;消息没有到达交换机,原因为：&#123;&#125;&quot;</span>, cause);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(); <span class="comment">//关联数据</span></span><br><span class="line">        correlationData.setId(<span class="string">&quot;order_123456&quot;</span>); <span class="comment">//发送订单信息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME + <span class="string">&quot;error&quot;</span>, </span><br><span class="line">                                      RabbitMQConstant.QUEUE_NAME1, message, correlationData);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambad-实现"><a href="#Lambad-实现" class="headerlink" title="Lambad 实现"></a>Lambad 实现</h4><p><strong>生产者</strong>：生产者使用lambda实现<code>RabbitTemplate.ConfirmCallback</code>接口，重写confirm()方法并设置回调函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(</span><br><span class="line">            <span class="comment">// 使用lambda 表达式</span></span><br><span class="line">            (correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;关联id为：&#123;&#125;&quot;</span>, correlationData.getId() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;消息正确的达到交换机&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                log.error(<span class="string">&quot;消息没有到达交换机,原因为：&#123;&#125;&quot;</span>, cause);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(); <span class="comment">//关联数据</span></span><br><span class="line">        correlationData.setId(<span class="string">&quot;order_123456&quot;</span>); <span class="comment">//发送订单信息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME + <span class="string">&quot;error&quot;</span>,</span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1, message, correlationData);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：写错交换机的名字，查看日志输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关联id为:order_123456</span><br><span class="line">消息没有到达交换机，原因为:channel error;protocol method:#method&lt;channel</span><br></pre></td></tr></table></figure><h2 id="交换机确认"><a href="#交换机确认" class="headerlink" title="交换机确认"></a>交换机确认</h2><p>可能因为路由关键字错误，或者队列不存在，或者队列名称错误导致②失败；</p><p>使用return模式可以实现消息无法路由的时候返回给生产者，消息从 exchange –&gt; queue 投递失败则会返回一个 returnCallback，利用这个callback控制消息的可靠性投递；</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250731150818210.png" alt="image-20250731150818210"></p><h3 id="return模式实现"><a href="#return模式实现" class="headerlink" title="return模式实现"></a>return模式实现</h3><ul><li><p>开启return确认模式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启生产者的确认模式,设置关联模式</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#开启return模式</span></span><br></pre></td></tr></table></figure></li><li><p>实现RabbitTemplate.ReturnsCallback接口并重写returnedMessage()方法</p></li><li><p>设置回调</p><p>使用rabbitTemplate.setReturnCallback设置退回函数</p><p>当消息从exchange路由到queue失败后,则会将消息退回给producer,并执行回调函数returnedMessage；</p></li></ul><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.return.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME1</span> <span class="operator">=</span> <span class="string">&quot;queue.return.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME1</span> <span class="operator">=</span> <span class="string">&quot;key.return.normal.1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外部类实现-1"><a href="#外部类实现-1" class="headerlink" title="外部类实现"></a>外部类实现</h4><p><strong>生产者</strong>：设置回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MyReturnCallBack myReturnCallBack;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(myReturnCallBack); <span class="comment">//设置回调</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1 + <span class="string">&quot;error&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>外部实现接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReturnCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当消息从交换机 没有正确地 到达队列,则会触发该方法</span></span><br><span class="line"><span class="comment">     * 如果消息从交换机 正确地 到达队列了,那么就不会触发该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnedMessage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息从交换机没有正确的路由到(投递到)队列,原因为：&#123;&#125;&quot;</span>, returnedMessage.getReplyText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者实现-1"><a href="#生产者实现-1" class="headerlink" title="生产者实现"></a>生产者实现</h4><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="built_in">this</span>); <span class="comment">// 设置回调</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1 + <span class="string">&quot;error&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息从交换机没有正确的路由到(投递到)队列,原因为：&#123;&#125;&quot;</span>, returnedMessage.getReplyText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类实现"><a href="#匿名内部类实现" class="headerlink" title="匿名内部类实现"></a>匿名内部类实现</h4><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">                <span class="comment">// 匿名内部类 实现了接口</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;消息从交换机没有正确的路由到(投递到)队列,原因为：&#123;&#125;&quot;</span>, </span><br><span class="line">                                  returnedMessage.getReplyText());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        ); <span class="comment">// 设置回调</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes()).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1 + <span class="string">&quot;error&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lambda实现"><a href="#lambda实现" class="headerlink" title="lambda实现"></a>lambda实现</h4><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">                message -&gt; &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;消息从交换机没有正确的路由到(投递到)队列,原因为：&#123;&#125;&quot;</span>, message.getReplyText());</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1 + <span class="string">&quot;error&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Thu Jul 31 15:32:48 GMT+08:00 2025</span><br><span class="line">消息从交换机没有正确的路由到(投递到)队列，原因为:NO_ROUTE</span><br></pre></td></tr></table></figure><h3 id="使用备用交换机"><a href="#使用备用交换机" class="headerlink" title="使用备用交换机"></a>使用备用交换机</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250731150818210.png" alt="image-20250731150818210"></p><p>使用备份交换机(alternate-exchange)，无法路由的消息会发送到这个备用交换机上；</p><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.normal.backup.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 备用交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_BACKUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.backup.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 正常队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.normal.backup.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 备用队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_BACKUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue.backup.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_WARNING_KEY</span> <span class="operator">=</span> <span class="string">&quot;info1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义MQ</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder <span class="comment">// 默认为持久化的,默认不自动删除</span></span><br><span class="line">                .directExchange(RabbitMQConstant.EXCHANGE_NORMAL_NAME) <span class="comment">// 交换机的名字</span></span><br><span class="line">                .alternate(RabbitMQConstant.EXCHANGE_BACKUP_NAME) <span class="comment">// 设置备用交换机 alternate-exchange</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueNormal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NORMAL_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意 ROUTING_WARNING_KEY</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(DirectExchange normalExchange, Queue queueNormal)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueNormal)</span><br><span class="line">            .to(normalExchange)</span><br><span class="line">            .with(RabbitMQConstant.ROUTING_WARNING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">alternateExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(RabbitMQConstant.EXCHANGE_BACKUP_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">alternateQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_BACKUP_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingAlternate</span><span class="params">(FanoutExchange alternateExchange, Queue alternateQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(alternateQueue).to(alternateExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：消息存储到了备用队列</p><h2 id="消息持久化存储"><a href="#消息持久化存储" class="headerlink" title="消息持久化存储"></a>消息持久化存储</h2><p>消息的可靠性投递就是要保证消息投递过程中每一个环节都要成功，那么这肯定会牺牲一些性能，性能与可靠性是无法兼得的；</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250731150818210.png" alt="image-20250731150818210"></p><p>可能因为系统宕机、重启、关闭等等情况导致存储在队列的消息丢失，即③出现问题；</p><p>解决方案：</p><ol><li><p>队列持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueBuilder.durable(<span class="string">&quot;队列名称&quot;</span>).build();</span><br></pre></td></tr></table></figure></li><li><p>交换机持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExchangeBuilder.directExchange(<span class="string">&quot;交换机名称&quot;</span>).durable(<span class="literal">true</span>).build();</span><br></pre></td></tr></table></figure></li><li><p>消息持久化，默认就是持久化的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line"><span class="comment">// 设置消息持久化,当然它默认就是持久化,所以可以不用设置</span></span><br><span class="line">messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br></pre></td></tr></table></figure></li></ol><h2 id="消费者手动确认"><a href="#消费者手动确认" class="headerlink" title="消费者手动确认"></a>消费者手动确认</h2><h3 id="手动确认消息"><a href="#手动确认消息" class="headerlink" title="手动确认消息"></a>手动确认消息</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250731150818210.png" alt="image-20250731150818210"></p><p>采用消息消费时的<code>手动ack确认机制</code>来保证；如果消费者收到消息后未来得及处理即发生异常，或者处理过程中发生异常，会导致④失败。为了保证消息从队列可靠地达到消费者，RabbitMQ提供了<strong>消息确认机制</strong>(<code>message acknowledgement</code>)；</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启生产者的确认模式,设置关联模式</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#开启return模式</span></span><br><span class="line">    <span class="comment"># 开启消费者手动确认</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><p>消费者在订阅队列时,通过上面的配置，不自动确认，采用手动确认，RabbitMQ会等待消费者显式地回复确认信号后才从队列中删除消息；如果消息消费失败，也可以调用basicReject()或者basicNack()来拒绝当前消息而不是确认。如果requeue参数设置为true，可以把这条消息重新存入队列，以便发给下一个消费者(当然只有一个消费者的时候，这种方式可能会出现无限循环重复消费的情况，可以投递到新的队列中，或者只打印异常日志)；</p><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 开启生产者的确定模式</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(</span><br><span class="line">                (correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;消息没有到达交换机,原因为：&#123;&#125;&quot;</span>, cause);</span><br><span class="line">                        <span class="comment">// TODO 重发消息或者记录错误日志</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 开启交换机确认模式</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">                returnedMessage -&gt; &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;消息没有从交换机正确的投递(路由)到队列,原因为：&#123;&#125;&quot;</span>, returnedMessage.getReplyText());</span><br><span class="line">                    <span class="comment">// TODO 记录错误日志,给程序员发短信或者或者邮件</span></span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">        <span class="comment">// 设置单条消息的持久化,默认就是持久化</span></span><br><span class="line">        messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes())</span><br><span class="line">                .andProperties(messageProperties).build();</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                      RabbitMQConstant.ROUTING_NAME1+<span class="string">&quot;1&quot;</span>, message);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME1&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message, Channel channel)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取消息的唯一标识</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;接收到的消息为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">            <span class="comment">// TODO 插入订单等</span></span><br><span class="line">            <span class="comment">// int a=10/0;</span></span><br><span class="line">            <span class="comment">// 手动确认</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息处理出现问题&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息的幂等性（消息不被重复消费）"><a href="#消息的幂等性（消息不被重复消费）" class="headerlink" title="消息的幂等性（消息不被重复消费）"></a>消息的幂等性（消息不被重复消费）</h3><p>同一个消息，第一次接收，正常处理业务，如果该消息第二次再接收，那就不能再处理业务，否则就处理重复了；</p><p><strong>幂等性</strong>：对于一个资源，不管请求一次还是多次，对该资源本身造成的影响应该是相同的，不能因重复请求而对该资源重复造成影响；</p><p><strong>以接口幂等性举例</strong>：</p><p><strong>接口幂等性</strong>：一个接口用同样的参数反复调用，不会造成业务错误，那么这个接口就是具有幂等性的；</p><p>比如同一个订单我支付两次,但是只会扣款一次,第二次支付不会扣款,这说明这个支付接口是具有幂等性的；</p><p><strong>如何避免消息的重复消费问题?(消息消费时的幂等性)</strong></p><p>全局唯一ID + Redis：生产者在发送消息时，为每条消息设置一个全局唯一的messageId，消费者拿到消息后，使用setnx命令（<code>setnx(messageId, 1)</code>），将messageId作为key放到redis中，若返回1，说明之前没有消费过，正常消费；若返回0，说明这条消息之前已消费过，抛弃；</p><p><strong>实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal orderMoney;</span><br><span class="line">    <span class="keyword">private</span> Date orderTime; <span class="comment">// 下单时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 这个对象可以进行序列化和反序列化(json格式)</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 开启生产者的确定模式</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(</span><br><span class="line">                (correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;消息没有到达交换机,原因为：&#123;&#125;&quot;</span>, cause);</span><br><span class="line">                        <span class="comment">// TODO 重发消息或者记录错误日志</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">                returnedMessage -&gt; &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;消息没有从交换机正确的投递(路由)到队列,原因为：&#123;&#125;&quot;</span>, returnedMessage.getReplyText());</span><br><span class="line">                    <span class="comment">// TODO 记录错误日志,给程序员发短信或者或者邮件</span></span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建订单</span></span><br><span class="line">            <span class="type">Orders</span> <span class="variable">orders1</span> <span class="operator">=</span> Orders.builder()</span><br><span class="line">                    .orderId(<span class="string">&quot;order_12345&quot;</span>)</span><br><span class="line">                    .orderName(<span class="string">&quot;买的手机&quot;</span>)</span><br><span class="line">                    .orderMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">2356</span>))</span><br><span class="line">                    .orderTime(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">// 转成json</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">strOrders1</span> <span class="operator">=</span> objectMapper.writeValueAsString(orders1);</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            <span class="comment">// 设置单条消息的持久化,默认就是持久化</span></span><br><span class="line">            messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(strOrders1.getBytes())</span><br><span class="line">                    .andProperties(messageProperties).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Orders</span> <span class="variable">orders2</span> <span class="operator">=</span> Orders.builder()</span><br><span class="line">                    .orderId(<span class="string">&quot;order_12345&quot;</span>)</span><br><span class="line">                    .orderName(<span class="string">&quot;买的手机&quot;</span>)</span><br><span class="line">                    .orderMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">2356</span>))</span><br><span class="line">                    .orderTime(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="type">String</span> <span class="variable">strOrders2</span> <span class="operator">=</span> objectMapper.writeValueAsString(orders2);</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            <span class="comment">// 设置单条消息的持久化,默认就是持久化</span></span><br><span class="line">            messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(strOrders2.getBytes())</span><br><span class="line">                    .andProperties(messageProperties).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME1&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取消息的唯一标识</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="comment">// 使用objectmapper把字节数组反序列化成对象</span></span><br><span class="line">        <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> objectMapper.readValue(message.getBody(), Orders.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;接收到的消息为：&#123;&#125;&quot;</span>, orders.toString());</span><br><span class="line">            <span class="comment">// 如果不存在就在redis中存储</span></span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">setResult</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(<span class="string">&quot;idempotent:&quot;</span> + orders.getOrderId(), orders.getOrderId());</span><br><span class="line">            <span class="keyword">if</span> (setResult) &#123;</span><br><span class="line">                <span class="comment">// TODO 向数据库插入订单等</span></span><br><span class="line">                log.info(<span class="string">&quot;向数据库插入订单&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 手动确认</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息处理出现问题&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Thu Jul 31 16:04:07 GMT+08:00 2025</span><br><span class="line">接收到的消息为:0rders(orderId=order_12345,orderName=买的手机,rderMoney=2356...</span><br><span class="line">向数据库插入订单</span><br><span class="line">接收到的消息为:0rders(orderId=order_12345,orderName=买的手机,rderMoney=2356...</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;是实现了高级&lt;a href=&quot;https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4751675?fromModule=lemma_inlink</summary>
      
    
    
    
    <category term="Middleware" scheme="https://southernfish.github.io/categories/Middleware/"/>
    
    <category term="MQ" scheme="https://southernfish.github.io/categories/Middleware/MQ/"/>
    
    
    <category term="RabbitMQ" scheme="https://southernfish.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="https://southernfish.github.io/pages/middleware/rabbitmq/"/>
    <id>https://southernfish.github.io/pages/middleware/rabbitmq/</id>
    <published>2025-07-29T08:15:36.000Z</published>
    <updated>2025-09-20T11:18:48.148Z</updated>
    
    <content type="html"><![CDATA[<p><strong>RabbitMQ</strong>是实现了高级<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4751675?fromModule=lemma_inlink">消息队列</a>协议（<a href="https://baike.baidu.com/item/AMQP/8354716?fromModule=lemma_inlink">AMQP</a>）的开源消息代理软件（亦称面向消息的<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240?fromModule=lemma_inlink">中间件</a>）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang/0?fromModule=lemma_inlink">Erlang</a>语言编写的，而集群和<a href="https://baike.baidu.com/item/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/14768924?fromModule=lemma_inlink">故障转移</a>是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0/15696499?fromModule=lemma_inlink">开放电信平台</a>框架上的，支持高并发处理和分布式部署。所有主要的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131?fromModule=lemma_inlink">编程语言</a>均有与代理接口通讯的客户端库。RabbitMQ本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，更适合于企业级的开发。它还实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队，通过队列机制实现应用程序间的异步通信与数据传输，常用于流量削峰、系统解耦及异步处理场景。对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。多用于进行企业级的ESB整合。</p><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/qidaii/articles/17282475.html">RabbitMQ</a></p><p><a href="https://blog.csdn.net/weixin_64940494/article/details/126134203">RabbitMQ安装Erlang安装 windows</a></p><p><a href="https://blog.csdn.net/qq_42262444/article/details/121701485">【超级详细】RabbitMQ安装教程</a></p><p><a href="https://blog.csdn.net/qq_42262444/article/details/121854422">【详细步骤】Springboot整合RabbitMQ</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146038326">4.RabbitMQ工作模型</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146038909">6.RabbitMQ死信队列</a></p><p><a href="https://blog.csdn.net/u011488477/article/details/146042812">10.RabbitMQ集群</a></p><p><a href="https://blog.csdn.net/CYK_byte/article/details/133135103">RabbitMQ 集群 - 普通集群、镜像集群、仲裁队列</a></p></blockquote><h1 id="RabbitMQ-介绍"><a href="#RabbitMQ-介绍" class="headerlink" title="RabbitMQ 介绍"></a>RabbitMQ 介绍</h1><p>2007 年发布，是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。<br>RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue 高级消息队列协议 ）的开源实现，由于erlang 语言的高并发特性，性能较好，本质是个队列，FIFO 先入先出，里面存放的内容是message<br>RabbitMQ 是一个消息中间件：它接收消息并且转发，就类似于一个快递站，卖家把快递通过快递站，送到我们的手上，MQ也是这样，接收并存储消息，再转发。</p><h2 id="RabbitMQ的特点"><a href="#RabbitMQ的特点" class="headerlink" title="RabbitMQ的特点"></a>RabbitMQ的特点</h2><p>AMQP：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言灯条件的限制。</p><ul><li><code>可靠性(Reliablity)：</code>使用了一些机制来保证可靠性，比如持久化、传输确认、发布确认。</li><li><code>灵活的路由(Flexible Routing)：</code>在消息进入队列之前，通过Exchange来路由消息。对于典型的路由功能，Rabbit已经提供了一些内置的Exchange来实现。针对更复杂的路由功能，可以将多个Exchange绑定在一起，也通过插件机制实现自己的Exchange。</li><li><code>消息集群(Clustering)：</code>多个RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li><li><code>高可用(Highly Avaliable Queues)</code>：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li><li><code>多种协议(Multi-protocol)：</code>支持多种消息队列协议，如STOMP、MQTT等。</li><li><code>多种语言客户端(Many Clients)：</code>几乎支持所有常用语言，比如Java、.NET、Ruby等。</li><li><code>管理界面(Management UI)</code>：提供了易用的用户界面，使得用户可以监控和管理消息Broker的许多方面。</li><li><code>跟踪机制(Tracing)</code>：如果消息异常，RabbitMQ提供了消息的跟踪机制，使用者可以找出发生了什么。</li><li><code>插件机制(Plugin System)</code>：提供了许多插件，来从多方面进行扩展，也可以编辑自己的插件。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>抢购活动，削峰填谷，防止系统崩塌</strong>。<br><strong>延迟信息处理</strong>，比如 10 分钟之后给下单未付款的用户<strong>发送邮件提醒</strong>。<br><strong>解耦系统</strong>，对于<strong>新增的功能可以单独写模块扩展</strong>，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p><h3 id="流量消峰"><a href="#流量消峰" class="headerlink" title="流量消峰"></a>流量消峰</h3><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但比不能下单的体验要好。<br>简单来说： 就是在访问量剧增的情况下，但是应用仍然不能停，比如“双十一”下单的人多，但淘宝这个应用仍然要运行，所以就可以使用消息中间件采用队列的形式减少突然访问的压力</p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中间用户感受不到物流系统的故障，提升系统的可用性。</p><p>如图，把支付，库存，物流都交给MQ</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729152629973.png" alt="image-20250729152629973"></p><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。<br><strong>这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题</strong>，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729153106900.png" alt="image-20250729153106900"></p><ul><li><p>同步是阻塞的(会造成等待)</p><p>采用同步方式，用户从注册到响应成功，需要先保存注册信息，再发送邮件通知，邮件发送成功后再发送短信通知，短信发送成功后才通知用户成功，用户体验不好</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729191446438.png" alt="image-20250729191446438"></p></li><li><p>异步是非阻塞的(不会等待)</p><p>采用异步方式，保存用户信息后，短信通知和邮件通知消息写入MQ(耗时极短)，极大的缩短了响应时间</p></li></ul><p>大流量高并发请求、批量数据传递,就可以采用异步处理,提升系统吞吐量；</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729191621315.png" alt="image-20250729191621315"></p><h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><p>主要是用kafka这个服务器来做；日志处理是指将消息队列用于在日志处理中</p><ul><li><p>Kafka解决大量日志传输的问题</p></li><li><p>loger.info(…)</p></li><li><p>ELK 日志处理解决方案</p></li></ul><p>loger.error(…)  → logstash收集消息 → 发送消息的kafka → elastic search(es) → Kibana ELK日志处理平台</p><h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><h3 id="RabbitMQ-的重要角色"><a href="#RabbitMQ-的重要角色" class="headerlink" title="RabbitMQ 的重要角色"></a>RabbitMQ 的重要角色</h3><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p><ul><li><strong>生产者：</strong>消息的创建者，负责<strong>创建和推送数据</strong>到消息服务器；</li><li><strong>消费者：</strong>消息的接收方，用于<strong>处理数据和确认消息</strong>；</li><li><strong>代理(broker)：</strong>就是 <strong><code>RabbitMQ</code> 本身</strong>，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li></ul><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>产生数据发送消息的程序是生产者</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个由交换机类型决定。交换机类型：</p><ol><li><code>direct Exchange</code>(直接交换机)：匹配路由键，只有完全匹配消息才会被转发</li><li><code>Fanout Excange</code>(扇出交换机)：将消息发送至所有的队列</li><li><code>Topic Exchange</code>(主题交换机)：将路由按模式匹配，此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.” 只会匹配到“abc.def”。</li><li><code>Header Exchange</code>：在绑定Exchange和Queue的时候指定一组键值对，header为键，根据请求消息中携带的header进行路由</li></ol><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。</p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729153839738.png" alt="image-20250729153839738"></p><h3 id="RabbitMQ-的重要组件"><a href="#RabbitMQ-的重要组件" class="headerlink" title="RabbitMQ 的重要组件"></a>RabbitMQ 的重要组件</h3><ol><li><p><code>Producer</code>（生产者）：发送消息的应用；它将消息发送到 RabbitMQ 的交换器中</p></li><li><p><code>Consumer</code>（消费者）消费者是消息的接收方,它从 RabbitMQ 的队列中获取消息并进行处理</p></li><li><p><code>Broker</code>：标识消息队列服务器实体。接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p><ul><li><p>Broker = VHost1+Vhost2+Vhost3+…</p></li><li><p>Virtual Host = Exchange + Queue +Binding</p></li></ul></li><li><p><code>Message</code>（消息）：消息是不具名的，它是由消息头和消息体组成。消息体是不透明的，而消息头则是由一系列的可选属性组成。消息可以是任何数据(字符串、user对象，json串等)</p><ul><li><p>消息=消息头+消息体，根据routekey发送到指定的交换机 Exchange</p></li><li><p>消息头：含各种属性 routing-key(路由键)、priority(优先级)、delivery-mode(指出该消息可能需要持久性存储[路由模式])等。</p></li></ul></li><li><p><code>Connection</code>（网络连接）：publisher／consumer 和 broker 之间的 TCP 连接。</p><p>断开连接的操作只会在client端进行，Broker不会断开连接，除非出现网络故障或broker服务出现问题。</p></li><li><p><code>ConnectionFactory</code>（连接管理器）：<strong>应用程序与Rabbit之间建立连接的管理器</strong>，程序代码中使用。</p></li><li><p><code>Channel</code>（信道）：<strong>消息推送使用的通道</strong>，是多路复用连接中的一条独立的双向数据流通道。</p><ul><li>如果每次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。</li><li>Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，</li><li>AMQP method 包含了 channel id 帮助客户端和 message broker 识channel，所以 channel 之间是完全隔离的。</li><li>Channel 作为轻量级的Connection 极大减少了操作系统建立 TCP connection 的开销。</li></ul></li><li><p><code>Virtual host</code>（虚拟主机）：逻辑分组机制，类似nacos中的命名空间的概念(在代码中就是一个字符串)。出于多租户和安全因素设计，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同用户使用同一个RabbitMQ server提供的服务时，可划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等。</p><ul><li>Virtual 即 VHost</li><li>默认目录 /</li></ul></li><li><p><code>vHost</code>（虚拟主机）：每个 RabbitMQ 都能创建很多 <code>vhost</code>，每个虚拟主机其实都是 <strong>mini 版的RabbitMQ</strong>，它拥有自己的 “交换机exchange、绑定Binding、队列Queue”，更重要的是每一个vhost拥有独立的权限机制，这样就能安全地使用一个RabbitMQ服务器来服务多个应用程序，其中每个vhost服务一个应用程序。</p></li><li><p><code>Exchange</code>（交换机）：用于<strong>接受、分配消息</strong>。message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：<code>direct (point-to-point)</code>, <code>topic (publish-subscribe)</code> and <code>fanout (multicast)</code>。</p></li><li><p><code>Routing Key</code>（路由键）：用于把生成者的数据<strong>分配到交换器</strong>上。生产者将消息发送到交换机时会携带一个key，来指定路由规则。</p></li><li><p><code>Binding</code>（绑定）：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。在绑定Exchange和Queue时，会指定一个BindingKey，生产者发送消息携带的RoutingKey会和bindingKey对比，若一致就将消息分发至这个队列。</p></li><li><p><code>BindingKey</code>（绑定键）用于<strong>把交换器的消息绑定到队列</strong>上。</p></li><li><p><code>Queue</code>（队列）：用于<strong>存储</strong>生产者的消息。消息最终被送到这里等待 consumer 取走。一个message可被同时拷贝到多个queue。</p></li></ol><h3 id="RabbitMQ-的消息是怎么发送的"><a href="#RabbitMQ-的消息是怎么发送的" class="headerlink" title="RabbitMQ 的消息是怎么发送的"></a>RabbitMQ 的消息是怎么发送的</h3><p>首先客户端必须<strong>连接到 <code>RabbitMQ</code> 服务器</strong>才能发布和消费消息，<strong>客户端和 <code>rabbit server</code> 之间会创建一个 <code>tcp 连接</code><strong>，一旦 <strong><code>tcp</code> 打开并通过了认证</strong>（认证就是你发送给 rabbit 服务器的用户名和密码），你的</strong>客户端和 <code>RabbitMQ</code> 就创建了一条 <code>amqp 信道</code>（channel）</strong>，信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p><h2 id="工作模式（七种）"><a href="#工作模式（七种）" class="headerlink" title="工作模式（七种）"></a>工作模式（七种）</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180401408.png" alt="image-20250729180401408"></p><h3 id="simple-简单模式"><a href="#simple-简单模式" class="headerlink" title="simple (简单模式)"></a>simple (简单模式)</h3><p>一个消费者消费一个生产者生产的信息，消息只能被消费⼀次<br>RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。<br>RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。</p><h3 id="Work-queues-工作模式"><a href="#Work-queues-工作模式" class="headerlink" title="Work queues(工作模式)"></a>Work queues(工作模式)</h3><p>或者竞争消费者模式。工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多工人时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。<br><strong>总之</strong>：让多个消费者绑定到一个队列，共同消费队列中的消息。队列中的消息一旦消费，就会消失，消息不会重复分配给不同的消费者。</p><p><strong>适⽤场景</strong>：集群环境中做异步处理</p><h3 id="Publish-Subscribe（发布订阅模式）"><a href="#Publish-Subscribe（发布订阅模式）" class="headerlink" title="Publish/Subscribe（发布订阅模式）"></a>Publish/Subscribe（发布订阅模式）</h3><p>生产者首先投递消息到交换机，订阅了这个交换机的队列就会收到生产者投递的消息</p><p><strong>特点</strong>：</p><ul><li><p>Exchange(交换机)</p><p>只负责转发消息，不具备存储消息的能力，因此若没有任何队列与Exchange绑定，或者没有符合路由规则的队列，消息就会丢失</p></li><li><p>RoutingKey(路由键)</p><p>⽣产者将消息发给交换器时，指定的⼀个字符串，⽤来告诉交换机应该如何处理这个消息</p></li><li><p>Binding Key(绑定)</p><p>RabbitMQ中通过Binding(绑定)将交换器与队列关联起来，在绑定的时候⼀般会指定⼀个Binding Key，这样RabbitMQ就知道如何正确地将消息路由到队列了</p></li></ul><p><strong>适合场景</strong>：消息需要被多个消费者同时接收的场景(如: 实时通知或者⼴播消息)</p><h3 id="Routing（路由模式）"><a href="#Routing（路由模式）" class="headerlink" title="Routing（路由模式）"></a>Routing（路由模式）</h3><p>生产者生产消息投递到direct交换机中，扇出交换机会根据消息携带的routing Key匹配相应的队列</p><p>路由模式是发布订阅模式的变种，在发布订阅基础上，增加路由key。Exchange根据RoutingKey的规则，将数据筛选后发给对应的消费者队列。</p><p><strong>适合场景</strong>：需要根据特定规则分发消息的场景</p><p>比如系统打印日志(⽇志等级分为error, warning, info,debug)就可以通过该模式把不同⽇志发送到不同的队列, 最终输出到不同的⽂件</p><h3 id="Topics（主题模式）"><a href="#Topics（主题模式）" class="headerlink" title="Topics（主题模式）"></a>Topics（主题模式）</h3><p>生产者生产消息投递到topic交换机中，上面是完全匹配路由键，而主题模式是模糊匹配，只要有合适规则的路由就会投递给消费者。</p><p>路由模式的升级版，在routingKey的基础上，增加了通配符的功能，使之更加灵活。也称<strong>通配符模式</strong>。</p><p>Topics和Routing的基本原理相同，即⽣产者将消息发给交换机，交换机根据RoutingKey将消息转发给与RoutingKey匹配的队列，类似于正则表达式的⽅式来定义Routingkey的模式</p><p><strong>适合场景</strong>：需要灵活匹配和过滤消息的场景。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729160102405.png" alt="image-20250729160102405"></p><h3 id="RPC模式"><a href="#RPC模式" class="headerlink" title="RPC模式"></a>RPC模式</h3><p>在RPC通信的过程中, 没有⽣产者和消费者, ⽐较像咱们RPC远程调⽤, ⼤概就是通过两个队列实现了⼀个可回调的过程。</p><ul><li><p><strong>客户端：</strong></p><ol><li><p>发送请求（携带replyTo，correlationId）</p></li><li><p>接收响应（验证correlationId）</p></li></ol></li><li><p><strong>服务器：</strong></p><ol><li><p>接收请求 进行响应</p></li><li><p>发送响应（按客户端指定的replyTo，设置correlationId）</p></li></ol></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729194101402.png" alt="image-20250729194101402"></p><h3 id="发布确认模式"><a href="#发布确认模式" class="headerlink" title="发布确认模式"></a>发布确认模式</h3><p>消息丢失其中一种情况是⽣产者问题：因为应⽤程序故障、⽹络抖动等各种原因, ⽣产者没有成功向broker发送消息，可以采⽤发布确认(Publisher Confirms)机制实现。发送方确认机制好处在于它是异步的，⽣产者可以同时发布消息和等待信道返回确认消息。当消息最终得到确认之后，⽣产者可以通过回调⽅法来处理该确认消息。<br>如果RabbitMQ因自身内部错误导致消息丢失，就会发送⼀条nack(Basic.Nack)命令，⽣产者同样<strong>可以在回调方法中处理该nack命令</strong>使用发送确认机制必须要信道设置成confirm(确认)模式。发布确认有<strong>3种策略</strong>：</p><ul><li><p>单独确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Individually</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(Constants.HOST);</span><br><span class="line">        connectionFactory.setPort(Constants.PORT);                     <span class="comment">// 需要提前开放端口号</span></span><br><span class="line">        connectionFactory.setUsername(Constants.USER_NAME);            <span class="comment">// 账号</span></span><br><span class="line">        connectionFactory.setPassword(Constants.PASSWORD);          <span class="comment">// 密码</span></span><br><span class="line">        connectionFactory.setVirtualHost(Constants.VIRTUAL_HOST);     <span class="comment">// 虚拟主机</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">// 1.开启信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 2. 设置信道为confirm模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">// 3.声明队列</span></span><br><span class="line">        channel.queueDeclare(Constants.PUBLISHER_CONFIRMS_QUEUE1, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 4.发送消息，并等待确认</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Constants.MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello publisher confirms&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, Constants.PUBLISHER_CONFIRMS_QUEUE1, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">            <span class="comment">// 等待确认</span></span><br><span class="line">            channel.waitForConfirmsOrDie(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.printf(<span class="string">&quot;单独确认策略, 消息条数: %d, 耗时: %d ms \n&quot;</span>, </span><br><span class="line">                          Constants.MESSAGE_COUNT, end - start);</span><br><span class="line">        <span class="comment">// 5.关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>批量确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Batches</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 发送消息, 并进行确认</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">outstandingMessageCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Constants.MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello publisher confirms&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, Constants.PUBLISHER_CONFIRMS_QUEUE2, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">            outstandingMessageCount++;</span><br><span class="line">            <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">                channel.waitForConfirmsOrDie(<span class="number">5000</span>);</span><br><span class="line">                outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            channel.waitForConfirmsOrDie(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异步确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Asynchronously</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 4. 监听confirm</span></span><br><span class="line">        <span class="comment">// 集合中存储的是未确认的消息ID</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        SortedSet&lt;Long&gt; confirmSeqNo = Collections.synchronizedSortedSet(<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;());</span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> <span class="title class_">ConfirmListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                    confirmSeqNo.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    confirmSeqNo.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                    confirmSeqNo.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    confirmSeqNo.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 业务需要根据实际场景进行处理, 比如重发, 此处代码省略</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Constants.MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello publisher confirms&quot;</span> + i;</span><br><span class="line">            <span class="type">long</span> <span class="variable">seqNo</span> <span class="operator">=</span> channel.getNextPublishSeqNo();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, Constants.PUBLISHER_CONFIRMS_QUEUE3, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">            confirmSeqNo.add(seqNo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!confirmSeqNo.isEmpty()) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="RabbitMQ-保证消息的稳定性"><a href="#RabbitMQ-保证消息的稳定性" class="headerlink" title="RabbitMQ 保证消息的稳定性"></a>RabbitMQ 保证消息的稳定性</h1><p>提供了<strong>事务</strong>的功能。通过<strong>将 <code>channel</code> 设置为 <code>confirm</code>（确认）模式</strong>。</p><p><strong>RabbitMQ 怎么避免消息丢失</strong></p><ul><li><strong>把消息持久化磁盘</strong>，保证服务器重启消息不丢失。</li><li><strong>每个集群中至少有一个物理磁盘，保证消息落入磁盘</strong>。</li></ul><h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>RabbitMQ的消息默认存在内存中的，一旦服务器意外挂掉，消息就会丢失。消息持久化需做到三点：</p><blockquote><p>1.Exchange设置持久化：消息<strong>已经到达持久化交换器</strong>。<br>2.Queue设置持久化：<strong>声明队列</strong>必须<strong>设置持久化 <code>durable</code> 设置为 <code>true</code><strong>。消息</strong>已经到达持久化队列</strong>。<br>3.Message持久化发送：发送消息设置发送模式deliveryMode=2，代表持久化消息</p></blockquote><p><strong>RabbitMQ 持久化的缺点</strong></p><p><strong>降低了服务器的吞吐量</strong>，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可**尽量使用 <code>ssd 硬盘</code>**来缓解吞吐量的问题。</p><h2 id="ACK确认机制"><a href="#ACK确认机制" class="headerlink" title="ACK确认机制"></a>ACK确认机制</h2><p>多个消费者同时收取消息，收取消息到一半，突然某个消费者挂掉，要保证此条消息不丢失，就需要<code>acknowledgement</code>机制，就是消费者消费完成要通知服务端，服务端才将数据删除</p><p>这样就解决了，即使一个消费者出了问题，没有同步消息给服务端，还有其他的消费端去消费，保证了消息不丢的case。</p><h2 id="设置集群镜像模式"><a href="#设置集群镜像模式" class="headerlink" title="设置集群镜像模式"></a>设置集群镜像模式</h2><p>我们先来介绍下RabbitMQ三种部署模式：</p><blockquote><p>1.单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。</p><p>2.普通模式：默认的集群模式，某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。</p><p>3.镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案</p></blockquote><p>为什么设置镜像模式集群，因为队列的内容仅仅存在某一个节点上面，不会存在所有节点上面，所有节点仅仅存放消息结构和元数据。</p><h2 id="消息补偿机制"><a href="#消息补偿机制" class="headerlink" title="消息补偿机制"></a>消息补偿机制</h2><p><strong>持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？</strong></p><blockquote><p>产线网络环境太复杂，故未知数太多，消息补偿机制需要建立在消息要写入DB日志，发送日志，接受日志，两者的状态必须记录。</p><p>然后根据DB日志记录check 消息发送消费是否成功，不成功，进行消息补偿措施，重新发送消息处理。</p></blockquote><h1 id="RabbitMQ-如何实现延迟队列"><a href="#RabbitMQ-如何实现延迟队列" class="headerlink" title="RabbitMQ 如何实现延迟队列"></a>RabbitMQ 如何实现延迟队列</h1><p>RabbitMQ本身没有延迟队列，需要靠TTL和DLX模拟出延迟的效果。延迟队列的实现有两种方式：</p><ul><li>通过<strong>消息过期后进入死信交换器，再由交换器转发到延迟消费队列</strong>，实现延迟功能；</li><li>使用 <code>RabbitMQ-delayed-message-exchange</code> 插件实现延迟功能。</li></ul><h2 id="过期消息-TTL（Time-To-Live）"><a href="#过期消息-TTL（Time-To-Live）" class="headerlink" title="过期消息 TTL（Time To Live）"></a>过期消息 TTL（Time To Live）</h2><p>RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter</p><p>RabbitMQ针对队列中的消息过期时间有两种方法可以设置。</p><blockquote><ol><li><p>通过队列属性设置，队列中所有消息都有相同的过期时间。决定了在没有任何消费者的情况下，队列中的消息可以存活多久。</p></li><li><p>对消息进行单独设置，每条消息TTL可以不同。决定了在没有任何消费者消费时，消息可以存活多久。</p></li><li><p>如果消息和对列都设置过期时间，则消息的TTL以两者之间较小的那个数值为准。</p></li></ol></blockquote><h2 id="死信队列-DLX-Dead-Letter-Exchange"><a href="#死信队列-DLX-Dead-Letter-Exchange" class="headerlink" title="死信队列 DLX (Dead-Letter-Exchange)"></a>死信队列 DLX (Dead-Letter-Exchange)</h2><p>RabbitMQ的Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，如果队列内出现了dead letter，则按照这两个参数重新路由。</p><blockquote><ol><li><p>x-dead-letter-exchange：出现dead letter之后将dead letter重新发送到指定exchange</p></li><li><p>x-dead-letter-routing-key：指定routing-key发送</p></li></ol></blockquote><p>队列出现dead letter的情况有：</p><blockquote><p>1.消息或者队列的TTL过期。消息积压太多消费不过来；没有对应的消费者</p><p>2.队列达到最大长度，先到达的消息仍没有被消费</p><p>3.消息被消费端拒绝（basic.reject or basic.nack）并且requeue=false，没有让消息重新入队</p></blockquote><p>利用DLX，当消息在一个队列中变成死信后，它能被重新publish到另一个Exchange。这时候消息就可以重新被消费。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729195949777.png" alt="image-20250729195949777"></p><hr><h1 id="RabbitMQ实战（SpringBoot）"><a href="#RabbitMQ实战（SpringBoot）" class="headerlink" title="RabbitMQ实战（SpringBoot）"></a>RabbitMQ实战（SpringBoot）</h1><h2 id="Windows-环境安装"><a href="#Windows-环境安装" class="headerlink" title="Windows 环境安装"></a>Windows 环境安装</h2><p>首先可以进入rabbitMQ官网上查看 <a href="https://www.rabbitmq.com/which-erlang.html">RabbitMQ 版本要求</a> 。定位到<code>RabbitMQ and Erlang/OTP Compatibility Matrix</code>，发现当前RabbitMQ的最新版本是4.1.2，要求Erlang版本最低是26.2，最高是27.0。安装最新版RabbitMQ也就是4.1.2。</p><p>因为RabbitMQ 用Erlang 语音开发的，所以先安装Erlang 。</p><p><strong>下载安装Erlang</strong></p><ol><li><p>安装<a href="https://so.csdn.net/so/search?q=Erlang&spm=1001.2101.3001.7020">Erlang</a> （因为RabbitMQ 用Erlang 语音开发的，所已我们先安装Erlang ）。进入到Erlang官网下载 <a href="https://www.erlang.org/downloads">Erlang下载地址</a> 。选择Erlang27.0 windows 64位的<a href="https://so.csdn.net/so/search?q=%E5%AE%89%E8%A3%85%E5%8C%85&spm=1001.2101.3001.7020">安装包</a>，点击下载。</p></li><li><p>找到下载的Erlang安装包，右键以管理员身份运行。按照步骤next , 安装路径D:\IDEA\tools下，注意这里的路径<strong>不能包含中文</strong>。</p></li><li><p>安装完成后配置环境变量</p><blockquote><p>新建系统变量ERLANG_HOME，变量值为D:\IDEA\tools\Erlang OTP。</p><p>path中添加环境变量 %ERLANG_HOME%\bin 。</p></blockquote></li><li><p>验证Erlang是否安装成功，打开cmd 输入 erl 。出现版本信息则说明安装成功</p></li></ol><p><strong>安装RabbitMQ</strong></p><ol><li><p>进入到RabbitMQ官网下载安装包，<a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v4.1.2/rabbitmq-server-4.1.2.exe">RabbitMQ下载地址</a> ，或者GitHUb下载：<a href="https://github.com/rabbitmq/rabbitmq-server/releases">GitHub</a>。</p></li><li><p>找到下载的安装包右键以管理员身份运行。按照步骤next , 安装路径D:\IDEA\tools下</p></li><li><p>安装完成后，在win菜单下找到 RabbitMQ command prompt。</p></li><li><p>输入命令，激活rabbitmq的ui界面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins.bat <span class="built_in">enable</span> rabbitmq_management </span><br></pre></td></tr></table></figure></li><li><p>激活完成后，重启rabbitmq。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop RabbitMQ</span><br><span class="line">net start RabbitMQ</span><br></pre></td></tr></table></figure></li><li><p>重启完成后，验证是否成功，登录到 localhost:15672,出现如下图登录页面即安装成功。</p></li><li><p>RabbitMQ默认的登录用户和密码为 guest guest 。</p></li><li><p>登录成功后进入到页面，RabbitMQ的安装就算完成。</p></li></ol><h2 id="Linux-环境安装"><a href="#Linux-环境安装" class="headerlink" title="Linux 环境安装"></a>Linux 环境安装</h2><ol><li><p>进入到RabbitMQ官网下载安装包，<a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v4.1.2/rabbitmq-server-4.1.2-1.el8.noarch.rpm">RabbitMQ下载地址</a> 。</p></li><li><p>进入<a href="https://github.com/rabbitmq/erlang-rpm/releases">GitHub|rabbitmq|erlang-rpm</a>选择RabbitMQ支持的版本下载，或者进入到Erlang官网下载 <a href="https://www.erlang.org/downloads">Erlang下载地址</a> 。</p></li><li><p><strong>将下载好的安装文件 上传到服务器</strong>，上传在/root目录下</p></li><li><p>安装Erlang</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum -y install esl-erlang_23.0.2-1_centos_7_amd64.rpm </span><br><span class="line"><span class="comment"># 验证是否安装成功</span></span><br><span class="line">erl</span><br></pre></td></tr></table></figure></li><li><p>安装RabbitMQ</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum -y install rabbitmq-server-3.8.5-1.el7.noarch.rpm </span><br><span class="line"><span class="comment"># 安装RabbitMQ 可视化管理控制台 它是以插件的形式存在的。查看所有的插件列表</span></span><br><span class="line">rabbitmq-plugins list</span><br><span class="line"><span class="comment"># [ ] rabbitmq_management x.x.x 为管理系统的插件，安装命令如下</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure></li><li><p>启动RabbitMQ</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动RabbitMQ</span></span><br><span class="line">systemctl start rabbitmq-server.service</span><br><span class="line"><span class="comment"># 确认是否启动成功</span></span><br><span class="line">systemctl status rabbitmq-server.service</span><br></pre></td></tr></table></figure></li><li><p>访问RabbitMQ</p><p>端口为：15672，默认的用户名：guest 密码：guset。访问地址是：自己的服务器的ip+端口（如 <a href="http://192.168.10.11:15672）">http://192.168.10.11:15672）</a></p><p>如果不是在localhost本机登录会提示错误：User can only log in via localhost。<strong>解决办法： 让它可以进行远程登录，需要回到安装RabbitMQ的服务器</strong>进行如下操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /etc/rabbitmq/</span></span><br><span class="line">[root@localhost rabbitmq]<span class="comment"># ll</span></span><br><span class="line"><span class="comment"># 发现只有一个文件 enabled_plugins</span></span><br><span class="line"><span class="comment"># 编辑rabbitmq.config 添加[&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].</span></span><br><span class="line">[root@localhost rabbitmq]<span class="comment"># vi rabbitmq.config</span></span><br><span class="line"><span class="comment"># 添加[&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].后保存并退出，然后重启RabbitMQ</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl restart rabbitmq-server.service</span></span><br></pre></td></tr></table></figure><p>这时候再访问并登录就可以了</p></li></ol><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><h2 id="RabiitMQ-依赖引入"><a href="#RabiitMQ-依赖引入" class="headerlink" title="RabiitMQ 依赖引入"></a>RabiitMQ 依赖引入</h2><p>首先在已经搭建好的SpringBoot项目的pom.xml 中引入RabiitMQ的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- AMQO 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="RabbitMQ-配置"><a href="#RabbitMQ-配置" class="headerlink" title="RabbitMQ 配置"></a>RabbitMQ 配置</h2><ol><li><p>在application.yml配置文件中进行<a href="https://so.csdn.net/so/search?q=RabbitMQ&spm=1001.2101.3001.7020">RabbitMQ</a>的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment">#  服务器</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span></span><br><span class="line">    <span class="comment">#  用户名</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment">#  密码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment">#  虚拟主机</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="comment">#  端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="comment">#  监听相关配置</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="comment">#  消费者的最小数量</span></span><br><span class="line">        <span class="attr">concurrency:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment">#  消费者的最大数量</span></span><br><span class="line">        <span class="attr">max-concurrency:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment">#  限制消费者 每次只处理一条消息，处理完毕后再处理下一条消息</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#  启动时是否默认启动容器 默认true</span></span><br><span class="line">        <span class="attr">auto-startup:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">#  当消息被拒绝时，是否重新进入队列</span></span><br><span class="line">        <span class="attr">default-requeue-rejected:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">#  模板相关配置</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="comment">#  开启重试  默认false</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">#  重试时间 默认1000ms</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span></span><br><span class="line">        <span class="comment">#  重试的次数  默认是3</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span></span><br><span class="line">        <span class="comment">#  重试时间的最大间隔时间 默认10000ms</span></span><br><span class="line">        <span class="attr">max-interval:</span> <span class="string">10000ms</span></span><br><span class="line">        <span class="comment">#  重试的间隔乘数  比如配2.0 第一次就间隔10s 第二次 间隔20s 第三次间隔40s ****</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>创建配置类 RabbitMQConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;queue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>封装发送消息和接收消息的类：对消息的发送和消息的接受我们都分别进行封装</p><p>MqSender：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqSender</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;发送消息&quot;</span>+msg);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;queue&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MqReceiver：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqReceiver</span>&#123;</span><br><span class="line">    <span class="comment">//监听配置的队列</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(Object msg)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收消息：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="RabbitMQ-测试"><a href="#RabbitMQ-测试" class="headerlink" title="RabbitMQ 测试"></a>RabbitMQ 测试</h2><ol><li><p>随便在一个Contoller类中写一个测试方法。此处在TUserController中添加一个测试方法如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TUserController</span> &#123;</span><br><span class="line">      <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MqSender mqSender;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/mq&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mq</span><span class="params">()</span>&#123;</span><br><span class="line">        mqSender.send(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动项目进行测试</p><p>测试路径为 <a href="http://localhost:8080/user/mq%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0IEAR%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BC%9A%E8%BE%93%E5%87%BA%E6%88%91%E4%BB%AC%E7%9A%84%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%A6%82%E4%B8%8B">http://localhost:8080/user/mq，可以看到IEAR控制台会输出我们的测试数据如下</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... com.xxxxx.seckilldemo.rabbitmq.MqSender  : 发送消息Hello</span><br><span class="line">... com.xxxxx.seckilldemo.rabbitmq.MqReceiver  : 接收消息：(Body:<span class="string">&#x27;Hello&#x27;</span> MessageProperties [headers=&#123;&#125;, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=<span class="literal">false</span>, receivedExchange=, receivedRoutingKey=queue, deliveryTag=1, consumerTag=amq.ctag-IrqC4b7RL3mg1rMy8NefPQ, consumerQueue=queue])</span><br></pre></td></tr></table></figure><p>项目启动后RabiitMQ的控制台会显示有一个连接如下图</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180214185.png" alt="image-20250729180214185"></p></li></ol><hr><h1 id="RabbitMQ-集群"><a href="#RabbitMQ-集群" class="headerlink" title="RabbitMQ 集群"></a>RabbitMQ 集群</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RabbitMQ 的集群分两种模式，一种是默认集群模式，一种是镜像集群模式；</p><p>在RabbitMQ集群中所有的节点(一个节点就是一个RabbitMQ的broker服务器) 被归为两类：一类是磁盘节点,一类是内存节点； </p><p>磁盘节点会把集群的所有信息(比如交换机、绑定、队列等信息)持久化到磁盘中，而内存节点只会将这些信息保存到内存中，如果该节点宕机或重启，内存节点的数据会全部丢失，而磁盘节点的数据不会丢失；</p><p><strong>RabbitMQ 集群主要有以下两个用途：</strong></p><ul><li><strong>高可用：</strong>某个服务器出现问题，整个 <code>RabbitMQ</code> 还可以继续使用；</li><li><strong>高容量：</strong>集群可以承载更多的消息量。</li></ul><p><strong>RabbitMQ 集群搭建需要注意的问题</strong></p><p>各<strong>节点之间使用<code>“–link”</code>连接</strong>，此属性不能忽略。<br>各节点使用的 <strong><code>erlang cookie</code> 值必须相同</strong>，此值相当于“秘钥”的功能，<strong>用于各节点的认证</strong>。<br><strong>整个集群中必须包含一个磁盘节点</strong>。</p><h2 id="默认集群模式"><a href="#默认集群模式" class="headerlink" title="默认集群模式"></a>默认集群模式</h2><h3 id="默认集群简介"><a href="#默认集群简介" class="headerlink" title="默认集群简介"></a>默认集群简介</h3><p>默认集群模式也叫 <strong>普通集群模式</strong>、或者 <strong>内置集群模式</strong>；普通集群，也叫做标准集群（classic cluster）</p><p><strong>元数据</strong></p><p><strong>队列元数据</strong>：队列名称和属性(是否可持久化,是否自动删除)</p><p><strong>交换器元数据</strong>：交换器名称、类型和属性</p><p><strong>绑定元数据</strong>：交换器和队列的绑定列表</p><p><strong>vhost元数据</strong>：vhost内的相关属性，如安全属性等;</p><p>当用户访问其中任何一个RabbitMQ节点时，查询到的<code>queue／user／exchange/vhost</code>等信息都是相同的；</p><p><strong>数据同步特点</strong></p><p>RabbitMQ默认集群模式只会把交换机、队列、虚拟主机等元数据信息在各个节点同步，而具体队列中的消息内容不会在各个节点中同步，队列的具体信息数据只在队列的拥有者节点保存，其他节点只知道队列的元数据和指向该节点的指针，所以其他节点接收到不属于该节点队列的消息时会将该消息传递给该队列的拥有者节点上；</p><p>集群不复制队列内容和状态到所有节点的原因</p><ul><li><p>节省存储空间；</p></li><li><p>提升性能；</p></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180016020.png" alt="image-20250729180016020"></p><p>若消息需要复制到集群中每个节点，网络开销不可避免，持久化消息还需要写磁盘，占用磁盘空间。</p><p><strong>数据访问过程</strong></p><p>若有一个消息生产者或者消息消费者通过<code>amqp-client</code>的客户端连接到节点1进行消息的发送或接收，那么此时集群中的消息收发只与节点1相关，这个没有任何问题；</p><p>若消息生产者所连接的是节点2或者节点3，此时队列1的完整数据不在该两个节点上，那么在发送消息过程中这两个节点主要起了一个路由转发作用，根据这两个节点上的元数据（也就是<code>指向queue</code>的<code>owner node</code>的指针）转发至节点1上，最终发送的消息还是会存储至节点1的队列1上；</p><p>同样，若消息消费者所连接的节点2或者节点3，那这两节点也会作为路由节点起转发作用，将会从节点1的队列1中获取消息进行消费；</p><h3 id="默认集群特征"><a href="#默认集群特征" class="headerlink" title="默认集群特征"></a>默认集群特征</h3><ol><li><p>集群中的各个节点是可以共享数据的，比如交换机信息、队列元信息，但不包含队列中的消息。</p><p>什么是元信息？ 元信息，就是指队列的描述信息，队列名、队列在哪一个节点中，但是不包括消息本身。</p><p>不包括消息本身是什么意思？ 假设我现在两个节点 mq1 和 mq2，然后有一个消费者订阅了 mq2 中的一个队列，但该消费者在访问时，不想小心访问到了 mq1，不过由于在 mq1 上持有 mq2 的元信息，所以他知道 mq2 在哪，因此就可以通过这个元数据找到 mq2 这个节点，然后拿到我们想要的数据（这就类似于 mq1 上有 指向 mq2 的指针，通过指针就可以找到 mq2）。</p></li><li><p>基于第一个特点的元信息，可以在访问集群中的某个节点时，发现队列不在该节点，就可以通过要访问数据的所在节点的元信息，进一步的拿到这个节点的所有数据。</p></li><li><p>如果队列所在节点宕机，那么消息就会丢失。</p><p> 这里有点类似于 redis 集群中的分片处理，每一个集群上存储全集队列的一部分队列，因此这个节点挂了，消息必然会丢失.</p></li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>安装三台RabbitMQ机器：先安装一台MQ，然后克隆两台就行</p></li><li><p>设置IP地址：启动并设置三台机器的IP</p><p><strong>修改配置文件方式</strong></p></li><li><h5 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hostnamectl set-hostname rabbit11</span><br></pre></td></tr></table></figure></li><li><h5 id="修改-etc-hosts-文件"><a href="#修改-etc-hosts-文件" class="headerlink" title="修改/etc/hosts 文件"></a>修改/etc/hosts 文件</h5><p>首先需要配置一下hosts文件，因为RabbitMQ集群节点名称是读取hosts文件得到的；注意三台机机器都需要配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line">192.168.1.11 rabbit11</span><br><span class="line">192.168.1.12 rabbit12</span><br><span class="line">192.168.1.13 rabbit13</span><br></pre></td></tr></table></figure></li><li><h5 id="重启网络"><a href="#重启网络" class="headerlink" title="重启网络"></a>重启网络</h5><p>三台机器均重启网络,使节点名生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart NetworkManager</span><br><span class="line"><span class="comment"># 低版本CentOS使用如下命令</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure></li><li><h5 id="重新连接xshell"><a href="#重新连接xshell" class="headerlink" title="重新连接xshell"></a>重新连接xshell</h5><p>重启后三台机器的xshell均退出，然后再重新连接，这样才能刷新主机的名字</p></li><li><h5 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h5><p>三台机器均需关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld  <span class="comment">##关闭防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld  <span class="comment">##开机不启动防火墙</span></span><br><span class="line">systemctl status firewalld    <span class="comment">##查看防火墙状态</span></span><br></pre></td></tr></table></figure></li><li><h5 id="修改-erlang-cookie文件"><a href="#修改-erlang-cookie文件" class="headerlink" title="修改.erlang.cookie文件"></a>修改.erlang.cookie文件</h5><p>三台机器 .erlang.cookie文件保持一致。<strong>由于是clone出的三台机器，所以肯定是一样的</strong></p><ul><li><p>如果使用解压缩方式安装的RabbitMQ，那么该文件会在用户名目录下，也就是{用户名}/.erlang.cookie；</p></li><li><p>如果使用rpm安装包方式进行安装,那么这个文件会在/var/lib/rabbitmq目录下；</p></li><li><p><strong>注意 .erlang.cookie的权限为400，目前已经是400</strong></p></li></ul></li><li><h5 id="启动MQ"><a href="#启动MQ" class="headerlink" title="启动MQ"></a>启动MQ</h5><p>分别启动三台机器上的rabbitmq</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure></li><li><h5 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h5><ul><li><p><strong>查看rabbitmq状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl status</span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">Status of node rabbit@rabbit11...</span><br><span class="line">[]</span><br><span class="line">Runtime</span><br></pre></td></tr></table></figure></li><li><p><strong>查看集群状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br><span class="line"><span class="comment"># 输出如下： rabbit@rabbit11集群节点名称，Disk Nodes节点类型是磁盘节点</span></span><br><span class="line">Cluster status of node rabbit@rabbit11</span><br><span class="line">Basics</span><br><span class="line">rabbitarabbit11Cluster name:Total CPU cores available cluster-wide: 4</span><br><span class="line">Cluster Tags</span><br><span class="line">(none)</span><br><span class="line">Disk Nodes</span><br><span class="line">rabbitarabbit11</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="构建集群"><a href="#构建集群" class="headerlink" title="构建集群"></a>构建集群</h5><ul><li><p>加入节点1</p><p>在rabbitmq12机器上执行命令，让12的rabbitmq加入集群</p><p>注意：一定要先停止节点，将节点重置之后才能加入集群，否则数据同步会出现混乱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先停止rabbitmq</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="comment"># 重置rabbitmq</span></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"><span class="comment"># 节点加入集群:rabbit@rabbit11是主节点的节点名,在集群状态中可以查看到节点名称</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@rabbit11 --ram</span><br><span class="line"><span class="comment"># 启动节点</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></li><li><p>添加节点2</p><p>在rabbit13节点上也<strong>执行同样的命令</strong>，使rabbit13节点也加入到集群中。当然也可以让rabbit13作为一个磁盘节点</p></li></ul></li><li><h5 id="添加用户和权限"><a href="#添加用户和权限" class="headerlink" title="添加用户和权限"></a>添加用户和权限</h5><p>操作一个节点，添加用户和权限等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出用户</span></span><br><span class="line">rabbitmqctl list_users</span><br><span class="line"><span class="comment"># 添加用户</span></span><br><span class="line">rabbitmqctl add_user admin 123456</span><br><span class="line"><span class="comment"># 查看权限</span></span><br><span class="line">rabbitmqctl list_permissions</span><br><span class="line"><span class="comment"># 设置权限</span></span><br><span class="line">rabbitmqctl set_permissions admin <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span><br><span class="line"><span class="comment"># 设置角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure></li><li><h5 id="启动web控制台"><a href="#启动web控制台" class="headerlink" title="启动web控制台"></a>启动web控制台</h5><p>启动web控制台插件。注意：三台机器都要启动，因为插件不属于元数据，因此需要分别启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入插件目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/rabbitmq_server-4.0.7/plugins/</span><br><span class="line"><span class="comment"># 启动web端插件</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management </span><br></pre></td></tr></table></figure></li><li><h5 id="创建虚拟主机"><a href="#创建虚拟主机" class="headerlink" title="创建虚拟主机"></a>创建虚拟主机</h5><p>使用web浏览器添加一个虚拟主机：longdidi</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180621236.png" alt="image-20250729180621236"></p></li><li><h5 id="再次查看集群状态"><a href="#再次查看集群状态" class="headerlink" title="再次查看集群状态"></a>再次查看集群状态</h5><p>当执行完操作以后在浏览器访问web管控台来看看效果；随便在哪个节点打开web管控台都能看到集群环境各节点的信息；也可以使用”rabbitmqctl cluster_status”查看集群状态；</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180657444.png" alt="image-20250729180657444"></p></li><li><h5 id="验证集群"><a href="#验证集群" class="headerlink" title="验证集群"></a>验证集群</h5><ol><li><p>创建队列</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180728567.png" alt="image-20250729180728567"></p></li><li><p>创建交换机</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729180804318.png" alt="image-20250729180804318"></p></li><li><p>绑定交换机与队列</p><ul><li><p>进入交换机</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181126120.png" alt="image-20250729181126120"></p></li><li><p>绑定交换机与队列</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181204097.png" alt="image-20250729181204097"></p></li></ul></li><li><p>发布消息</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181229138.png" alt="image-20250729181229138"></p></li><li><p>查看消息</p><p>在任意节点查看消息</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181259889.png" alt="image-20250729181259889"></p></li><li><p>停止主节点rabbit@rabbit11节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poweroff</span><br><span class="line"><span class="comment"># Connection Closing...socket close.</span></span><br><span class="line"><span class="comment"># Connection closed by foreign host.</span></span><br></pre></td></tr></table></figure></li><li><p>再在其它节点查看消息</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729181458290.png" alt="image-20250729181458290"></p></li></ol></li><li><h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmgctl stop_app</span><br><span class="line">rabbitmgctl reset</span><br><span class="line">rabbitmgctl start_app</span><br><span class="line">rabbitmgctl cluster_status</span><br><span class="line">rabbitmgctl forget_cluster_node rabbit@node2 <span class="comment"># (node1节点上执行)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="节点原理"><a href="#节点原理" class="headerlink" title="节点原理"></a>节点原理</h3><p>RabbitMQ底层是通过Erlang架构来实现的，所以rabbitmqctl会启动Erlang节点，并基于Erlang节点来使用Erlang系统连接RabbitMQ节点，在连接过程中需要正确的Erlang Cookie和节点名称，Erlang节点通过交换Erlang Cookie以获得认证。</p><h2 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h2><h3 id="镜像集群模式简介"><a href="#镜像集群模式简介" class="headerlink" title="镜像集群模式简介"></a>镜像集群模式简介</h3><p>镜像模式是基于默认集群模式加上一定的配置得来的；在默认模式下的RabbitMQ集群，它会把所有节点的交换机、绑定、队列的元数据进行复制确保所有节点都有一份相同的元数据信息，但是队列数据分为两种：</p><ul><li><p>一种是队列的元数据信息(比如队列的最大容量,队列的名称等配置信息)</p></li><li><p>一种是队列里面的消息</p></li></ul><p>镜像模式则是把所有的队列数据完全同步，包括元数据信息和消息数据信息，当然这对性能肯定会有一定影响，当对数据可靠性要求较高时，可以使用镜像模式。</p><h3 id="镜像集群模式特征"><a href="#镜像集群模式特征" class="headerlink" title="镜像集群模式特征"></a>镜像集群模式特征</h3><p>镜像集群，本质上就是主从模式。主要有以下几个特性：</p><ol><li><p><strong>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份</strong></p><p>这里就和之前的普通交换机不一样了，不仅仅是交换机可以共享，队列中的消息大家也可以共享了。</p></li><li><p><strong>创建队列的节点被称为该队列的主节点，备份到的其它节点叫做该队列的镜像节点</strong></p><p>比如现在有三个节点，现在我再 mq1 上创建了一个队列 q1，因此 mq1 就是主节点，那么还可以给他挑一个镜像节点，比如我再 mq2 上做一个镜像，那么 mq2 就会去找 mq1 同步 q1 的所有数据。</p></li><li><p><strong>一个队列的主节点可能是另一个队列的镜像节点</strong></p><p>也就是说，主节点和镜像节点是可以相互备份的。比如 q1 在 mq1 上，给 mq2 备份了一份，q2 实在 mq2 上，给 mq3 备份了一份，q3 在 mq3 上的，给 mq1 备份了一份，那么这个时候，mq1 就是 q1 的主节点，同时也是 q3 的镜像节点。</p></li><li><p><strong>所有操作都是主节点完成，然后同步给镜像节点 。</strong></p></li><li><p>主节点宕机后，镜像节点会替代成新的主节点</p></li></ol><h3 id="镜像模式配置-3-X版本"><a href="#镜像模式配置-3-X版本" class="headerlink" title="镜像模式配置 3.X版本"></a>镜像模式配置 3.X版本</h3><p>在默认集群模式的基础上执行如下命令就可以把一个默认的集群模式变成镜像集群模式。镜像队列配置语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority]</span><br></pre></td></tr></table></figure><ul><li><p>rabbitmqctl set_policy：固定写法</p></li><li><p>-p Vhost：可选参数,设置虚拟主机的名字(针对指定vhost下的queue进行设置)</p></li><li><p>Name:：设置策略的名称(自己取个名字就可以)</p></li><li><p>Pattern:：queue的匹配模式(正则表达式)；^表示所有的队列都是镜像队列</p></li><li><p>Definition：镜像定义(json格式)，包括三个部分ha-mode、ha-params、ha-sync-mode</p><ul><li><p>ha-mode：指明镜像队列的模式，有效值为 all/exactly/nodes</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all：表示在集群中所有的节点上进行镜像</span><br><span class="line">exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span><br><span class="line">nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</span><br></pre></td></tr></table></figure></li><li><p>ha-params：ha-mode模式需要用到的参数</p></li><li><p>ha-sync-mode：队列中消息的同步方式,有效值为automatic(自动向master同步数据)和manual(手动向master同步数据)</p></li></ul></li><li><p>priority：可选参数，指的是policy策略的优先级；</p></li></ul><p>示例：比如想配置所有名字开头为policy_的队列进行镜像，镜像数量为2，那么命令如下(在任意节点执行如下命令)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy -p longdidi my_policy <span class="string">&quot;^policy_&quot;</span>  <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span>  </span><br></pre></td></tr></table></figure><ol><li><p><strong>同步所有数据</strong></p><p>所有节点、所有虚拟主机、所有队列 都进行镜像。如果要在所有节点所有队列上进行镜像则在任意节点执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy my-all <span class="string">&quot;^&quot;</span>  <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span>   </span><br></pre></td></tr></table></figure></li><li><p><strong>同步指定数据</strong></p><p>针对某个虚拟主机进行镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy -p longdidi my-all <span class="string">&quot;^&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;: &quot;exactly&quot;, &quot;ha-params&quot;: 2, &quot;ha-sync-mode&quot;: &quot;automatic&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="镜像模式配置-4-X版本"><a href="#镜像模式配置-4-X版本" class="headerlink" title="镜像模式配置 4.X版本"></a>镜像模式配置 4.X版本</h3><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250729182945585.png" alt="image-20250729182945585"></p><h2 id="仲裁队列"><a href="#仲裁队列" class="headerlink" title="仲裁队列"></a>仲裁队列</h2><p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p><ol><li>与镜像队列一样，都是主从模式，支持主从数据同步</li><li>使用非常简单，没有复杂的配置</li><li>主从同步基于Raft协议，强一致</li></ol><p>在 SpringAMQP 中创建仲裁队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">quorumQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;quorum.queue&quot;</span>)     <span class="comment">// 持久化 </span></span><br><span class="line">            .quorum()                     <span class="comment">// 仲裁队列</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringAMQP连接集群，只需要在yaml中配置即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8071,</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8072,</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8073</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">1111</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><h2 id="SpringBoot集成集群"><a href="#SpringBoot集成集群" class="headerlink" title="SpringBoot集成集群"></a>SpringBoot集成集群</h2><h3 id="重点连接配置"><a href="#重点连接配置" class="headerlink" title="重点连接配置"></a>重点连接配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment"># 连接单台rabbitmq 服务器的地址</span></span><br><span class="line">    <span class="comment"># host: 192.168.1.101</span></span><br><span class="line">    <span class="comment"># 连接单台rabbitmq 服务器的端口</span></span><br><span class="line">    <span class="comment"># port: 5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启生产者的确认模式,设置关联模式</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#开启return模式</span></span><br><span class="line">    <span class="comment"># 开启消费者手动确认</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span><span class="string">:5672,192.168.1.12:5672,192.1.13:5672</span></span><br></pre></td></tr></table></figure><p>测试模块:rabbitmq-10-cluster-01</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置MQ"><a href="#配置MQ" class="headerlink" title="配置MQ"></a>配置MQ</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cluster-learn01</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment"># 连接单台rabbitmq 服务器的地址</span></span><br><span class="line">    <span class="comment"># host: 192.168.1.101</span></span><br><span class="line">    <span class="comment"># 连接单台rabbitmq 服务器的端口</span></span><br><span class="line">    <span class="comment"># port: 5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">longdidi</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启生产者的确认模式,设置关联模式</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#开启return模式</span></span><br><span class="line">    <span class="comment"># 开启消费者手动确认</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span><span class="string">:5672,192.168.1.12:5672,192.1.13:5672</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.4</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="comment">#password: 123456</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># 0号数据库</span></span><br></pre></td></tr></table></figure><h3 id="定义MQ队列"><a href="#定义MQ队列" class="headerlink" title="定义MQ队列"></a>定义MQ队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.longdidi.constants.RabbitMQConstant;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机,使用durable()方法设置持久化</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(RabbitMQConstant.EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常队列,durable()方法就是持久化</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, @Nullable Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(RabbitMQConstant.QUEUE_NAME1).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常交换机和正常队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingNormal</span><span class="params">(DirectExchange normalExchange, Queue normalQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(RabbitMQConstant.ROUTING_NAME1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建生产者、消费者"><a href="#创建生产者、消费者" class="headerlink" title="创建生产者、消费者"></a>创建生产者、消费者</h3><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.longdidi.constants.RabbitMQConstant;</span><br><span class="line"><span class="keyword">import</span> com.longdidi.vo.Orders;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageDeliveryMode;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 这个对象可以进行序列化和反序列化(json格式)</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法执行后自动执行</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 开启生产者的确定模式</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(</span><br><span class="line">                (correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;消息没有到达交换机,原因为:&#123;&#125;&quot;</span>, cause);</span><br><span class="line">                        <span class="comment">// TODO 重发消息或者记录错误日志</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.setReturnsCallback(</span><br><span class="line">                returnedMessage -&gt; &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;消息没有从交换机正确的投递(路由)到队列,原因为:&#123;&#125;&quot;</span>, returnedMessage.getReplyText());</span><br><span class="line">                    <span class="comment">// TODO 记录错误日志,给程序员发短信或者或者邮件</span></span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建订单</span></span><br><span class="line">            <span class="type">Orders</span> <span class="variable">orders1</span> <span class="operator">=</span> Orders.builder()</span><br><span class="line">                    .orderId(<span class="string">&quot;order_12345&quot;</span>).orderName(<span class="string">&quot;买的手机&quot;</span>)</span><br><span class="line">                    .orderMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">2356</span>)).orderTime(<span class="keyword">new</span> <span class="title class_">Date</span>()).build();</span><br><span class="line">            <span class="comment">//转成json</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">strOrders1</span> <span class="operator">=</span> objectMapper.writeValueAsString(orders1);</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            <span class="comment">//设置单条消息的持久化,默认就是持久化</span></span><br><span class="line">            messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(strOrders1.getBytes())</span><br><span class="line">                    .andProperties(messageProperties).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Orders</span> <span class="variable">orders2</span> <span class="operator">=</span> Orders.builder() .orderId(<span class="string">&quot;order_12345&quot;</span>).orderName(<span class="string">&quot;买的手机&quot;</span>)</span><br><span class="line">                    .orderMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">2356</span>)).orderTime(<span class="keyword">new</span> <span class="title class_">Date</span>()).build();</span><br><span class="line">            <span class="type">String</span> <span class="variable">strOrders2</span> <span class="operator">=</span> objectMapper.writeValueAsString(orders2);</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">            <span class="comment">//设置单条消息的持久化,默认就是持久化</span></span><br><span class="line">            messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(strOrders2.getBytes())</span><br><span class="line">                    .andProperties(messageProperties).build();</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitMQConstant.EXCHANGE_NAME, </span><br><span class="line">                                          RabbitMQConstant.ROUTING_NAME1, message);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完毕,发送时间为:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.longdidi.constants.RabbitMQConstant;</span><br><span class="line"><span class="keyword">import</span> com.longdidi.vo.Orders;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConstant.QUEUE_NAME1&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取消息的唯一标识</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="comment">// 使用objectmapper把字节数组反序列化成对象</span></span><br><span class="line">        <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> objectMapper.readValue(message.getBody(), Orders.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;接收到的消息为:&#123;&#125;&quot;</span>, orders.toString());</span><br><span class="line">            <span class="comment">// 如果不存在就在redis中存储</span></span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">setResult</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(<span class="string">&quot;idempotent:&quot;</span> + orders.getOrderId(), orders.getOrderId());</span><br><span class="line">            <span class="keyword">if</span> (setResult) &#123;</span><br><span class="line">                <span class="comment">// TODO 向数据库插入订单等</span></span><br><span class="line">                log.info(<span class="string">&quot;向数据库插入订单&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 手动确认</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息处理出现问题&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义常量、实体类"><a href="#定义常量、实体类" class="headerlink" title="定义常量、实体类"></a>定义常量、实体类</h3><p><strong>定义常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConstant</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange.idempotent.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME1</span> <span class="operator">=</span> <span class="string">&quot;queue.idempotent.normal.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_NAME1</span> <span class="operator">=</span> <span class="string">&quot;key.idempotent.normal.1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal orderMoney;</span><br><span class="line">    <span class="keyword">private</span> Date orderTime; <span class="comment">// 下单时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong>发送消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.longdidi.service.SendMessageService;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rabbitmq10Cluster01Application</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Rabbitmq10Cluster01Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SendMessageService sendMessageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序一启动就会运行该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sendMessageService.sendMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消息发送完毕，发送时间为:Tue Jul 29 18:41:22 GMT+08:00 2025</span><br><span class="line">接收到的消息为:0rders(orderId=order_12345,orderName=买的手机,orderMoney=2356....</span><br><span class="line">接收到的消息为:0rders(orderId=order_12345,orderName=买的手机,orderMoney=2356....</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ-节点的类型"><a href="#RabbitMQ-节点的类型" class="headerlink" title="RabbitMQ 节点的类型"></a>RabbitMQ 节点的类型</h2><p><strong>磁盘节点：</strong>消息会存储到磁盘。<br><strong>内存节点：</strong>消息都存储在内存中，<strong>重启服务器消息丢失，性能高于磁盘类型</strong>。</p><h2 id="RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h2><p>不是，原因有以下两个：</p><ul><li><strong>存储空间的考虑：</strong>若每个节点都拥有所有队列的完全拷贝，新增节点不但没有新增存储空间，反而<strong>增加了冗余数据</strong>；</li><li><strong>性能的考虑：</strong>若每条消息都需要完整拷贝到每一个集群节点，那新增节点并<strong>没有提升处理消息的能力</strong>，最多是保持和单节点相同的性能<strong>甚至是更糟</strong>。</li></ul><h2 id="RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么"><a href="#RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么" class="headerlink" title="RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么"></a>RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么</h2><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p><ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li></ul><p>唯一磁盘节点崩溃了，<strong>集群可以保持运行，但不能更改任何东西</strong></p><h2 id="RabbitMQ-对集群节点停止顺序有要求吗"><a href="#RabbitMQ-对集群节点停止顺序有要求吗" class="headerlink" title="RabbitMQ 对集群节点停止顺序有要求吗"></a>RabbitMQ 对集群节点停止顺序有要求吗</h2><p><code>RabbitMQ</code> 对集群的停止顺序是有要求的，应该<strong>先关闭内存节点，最后再关闭磁盘节点。若顺序恰好相反的话，可能会造成消息的丢失</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;是实现了高级&lt;a href=&quot;https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4751675?fromModule=lemma_inlink</summary>
      
    
    
    
    <category term="Middleware" scheme="https://southernfish.github.io/categories/Middleware/"/>
    
    <category term="MQ" scheme="https://southernfish.github.io/categories/Middleware/MQ/"/>
    
    
    <category term="RabbitMQ" scheme="https://southernfish.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="https://southernfish.github.io/pages/framwork/mybatis/"/>
    <id>https://southernfish.github.io/pages/framwork/mybatis/</id>
    <published>2025-07-29T05:25:36.000Z</published>
    <updated>2025-09-20T11:18:48.141Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis 是一款优秀的<a href="https://baike.baidu.com/item/%E6%8C%81%E4%B9%85%E5%B1%82/3584971?fromModule=lemma_inlink">持久层</a>框架，它支持定制化 <a href="https://baike.baidu.com/item/SQL/86007?fromModule=lemma_inlink">SQL</a>、<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1240317?fromModule=lemma_inlink">存储过程</a>以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取<a href="https://baike.baidu.com/item/%E7%BB%93%E6%9E%9C%E9%9B%86/11040011?fromModule=lemma_inlink">结果集</a>。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 <a href="https://baike.baidu.com/item/POJOs/6656035?fromModule=lemma_inlink">POJOs</a>(Plain Ordinary Java Object，普通的 Java对象)映射成数据库中的记录。本文简单记录一些关于MyBatis的问题。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/125818307">Maven基础&amp;MyBatis</a></p><p><a href="https://sayyy.blog.csdn.net/article/details/87878690">【spring boot】 mybatis配置双数据源/多数据源</a></p></blockquote><h1 id="Mybatis概述"><a href="#Mybatis概述" class="headerlink" title="Mybatis概述"></a>Mybatis概述</h1><h2 id="Mybatis、持久层、框架简介"><a href="#Mybatis、持久层、框架简介" class="headerlink" title="Mybatis、持久层、框架简介"></a>Mybatis、持久层、框架简介</h2><p><a href="https://mybatis.net.cn/">MyBatis中文网</a></p><ul><li>MyBatis 是一款优秀的<strong>持久层框架</strong>，用于<strong>简化 JDBC 开发</strong></li><li>MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github</li><li>官网：<a href="https://mybatis.org/mybatis-3/zh/index.html">mybatis – MyBatis 3 | 简介</a></li></ul><p><strong>持久层：</strong></p><ul><li><p>负责将数据保存到数据库的那一层代码。</p><p>以后开发我们会<strong>将操作数据库的Java代码作为持久层</strong>。而<strong>Mybatis就是对jdbc代码进行了封装</strong>。</p></li><li><p>JavaEE三层架构：表现层做页面展示、业务层做逻辑处理、持久层对数据持久化</p></li><li><p>下图是持久层框架的使用占比。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250728215016340.png" alt="image-20250728215016340"></p></li></ul><p><strong>框架：</strong></p><ul><li>框架就是一个半成品软件，是一套<strong>可重用的、通用的、软件基础代码模型</strong></li><li>在框架的基础之上构建软件编写更加高效、规范、通用、可扩展</li></ul><h2 id="Mybatis对比JDBC"><a href="#Mybatis对比JDBC" class="headerlink" title="Mybatis对比JDBC"></a>Mybatis对比JDBC</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250729124941788.png" alt="image-20250729124941788"></p><hr><h1 id="核心配置文件mybatis-config-xml"><a href="#核心配置文件mybatis-config-xml" class="headerlink" title="核心配置文件mybatis-config.xml"></a>核心配置文件mybatis-config.xml</h1><p>核心配置文件标签必须有向后顺序（相比之下，SQL映射配置文件的同级标签没有先后顺序），如下</p><ul><li>configuration(配置)<ul><li>properties(属性)</li><li>settings(设置)</li><li>typeAliases(类型别名)</li><li>typeHandlers(类型处理器)</li><li>objectFactory(对象工厂)</li><li>plugins(插件)</li><li>environments(环境配置)<ul><li>environment(环境变量)<ul><li>transactionManager(事务管理器)</li><li>dataSource(数据源)</li></ul></li></ul></li><li>databaseldProvider(数据库厂商标识)</li><li>mappers(映射器)</li></ul></li></ul><h2 id="configuration【根标签】"><a href="#configuration【根标签】" class="headerlink" title="configuration【根标签】"></a>configuration【根标签】</h2><p>所有子标签均需书写在当前根标签内部</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--根标签configuration--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    typeAliases类型别名--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;package1.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment</span></span><br><span class="line"><span class="comment">    尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    default是每个environment默认使用的环境 ID--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        指定每个 environment 元素定义的环境 ID--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        注意：环境可以随意命名，但务必保证默认的环境 ID 要匹配其中一个环境 ID。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            事务管理器transactionManager的配置，不用太在意，事务管理之后是用Spring接管--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            在 MyBatis 中有两种类型的事务管理器（也就是 type=&quot;[JDBC|MANAGED]&quot;）：--&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--            JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            数据源dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。--&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--            大多数 MyBatis 应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            有三种内建的数据源类型（也就是 type=&quot;[UNPOOLED|POOLED|JNDI]&quot;）：--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            POOLED– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            UNPOOLED– 这个数据源的实现会每次请求时打开和关闭连接。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            JNDI – 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--加载sql映射文件，告诉MyBatis 去哪寻找映射SQL 的语句。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        Maven项目编译后，java和resources下的目录和文件都在同一个跟目录下，所以路径是这样的，注意路径是/，不是.--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource=&quot;package1/mapper/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        扫描包指定name的包下所有mapper配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;package1.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="properties【属性标签】"><a href="#properties【属性标签】" class="headerlink" title="properties【属性标签】"></a>properties【属性标签】</h2><p>作用：<strong>将数据库配置属性从dataSource标签内部提取到外部</strong><br>属性：<br><code>resource</code>：设置外部属性文件类路径<br><code>url</code>：设置外部属性文件真实路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--    属性标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;druid.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    设置数据库环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置事务管理器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置数据源--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;initialSize&#125;&quot;/&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="settings【设置标签】"><a href="#settings【设置标签】" class="headerlink" title="settings【设置标签】"></a>settings【设置标签】</h2><p>作用： 是mybatis中极为重要的调整设置，他们会<strong>改变mybatis的运行时行为</strong></p><p>mapUnderscoreToCamelCase：开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。<br>默认值为false,当设置为true时开启驼峰命名<br>注意：只能将a_bc与aBc自动映射，不能将a_b与aBc自动映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启驼峰式命名自动映射--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="typeAliases【类型别名】"><a href="#typeAliases【类型别名】" class="headerlink" title="typeAliases【类型别名】"></a>typeAliases【类型别名】</h2><p><strong>alias译为别名</strong><br>作用 ：类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。<br>自定义别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Comment&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Comment&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Post&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Section&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Section&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Tag&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Tag&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以指定一个包名进行扫描，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    typeAliases类型别名--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    给指定name包下的所有类起一个别名，--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;package1.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样sql映射文件resultType属性就可以省略路径package1.pojo:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 映射配置文件 UserMapper.xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace名称空间，该命名空间和对应mapper接口的全限定名一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;package1.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType=&quot;User&quot;或&quot;user&quot;也可以，因为核心配置文件中有给package1.pojo起别名，且有别名后不区分大小写 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;package1.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="typeHandlers【类型处理器】"><a href="#typeHandlers【类型处理器】" class="headerlink" title="typeHandlers【类型处理器】"></a>typeHandlers【类型处理器】</h2><h2 id="objectFactory【对象工厂】"><a href="#objectFactory【对象工厂】" class="headerlink" title="objectFactory【对象工厂】"></a>objectFactory【对象工厂】</h2><h2 id="plugins（插件）"><a href="#plugins（插件）" class="headerlink" title="plugins（插件）"></a>plugins（插件）</h2><h2 id="environments【数据库环境设置】"><a href="#environments【数据库环境设置】" class="headerlink" title="environments【数据库环境设置】"></a>environments【数据库环境设置】</h2><p>作用：<strong>配置数据库连接环境信息。</strong></p><blockquote><ul><li>可以配置多个environment。</li><li>环境可以随意命名，但务必保证默认的环境 ID 要匹配其中一个环境 ID。这样通过default属性切换不同的environment环境<strong>。</strong></li><li>尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</li></ul></blockquote><p><strong>属性说明</strong>：</p><blockquote><p><strong>environments</strong>属性default是每个environment默认使用的环境 ID</p><p><strong>environment</strong>属性id是指定该 environment 元素定义的环境 ID。</p><p><strong>事务管理器transactionManager</strong>属性<strong>type有两种</strong>（type=”[JDBC|MANAGED]”））：<br>JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。<br>MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。</p><p><strong>数据源 dataSource 元素</strong>使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。<br><strong>type有三种</strong>（type=”[UNPOOLED|POOLED|JNDI]”）：<br>POOLED– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。<br>UNPOOLED– 这个数据源的实现会每次请求时打开和关闭连接。<br>JNDI – 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- default是每个environment默认使用的环境 ID--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定每个environment元素定义的环境ID，注意：环境可随意命名，但务必保证默认环境ID要匹配其中一个环境 ID。--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 事务管理器transactionManager的配置，不用太在意，事务管理之后是用Spring接管 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 大多 MyBatis 应用程序会按示例中例子配置数据源。数据源配置可选，但要启用延迟加载特性就必须配置数据源。--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 数据库连接信息 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="databaseIdProvider（数据库厂商标识）"><a href="#databaseIdProvider（数据库厂商标识）" class="headerlink" title="databaseIdProvider（数据库厂商标识）"></a>databaseIdProvider（数据库厂商标识）</h2><h2 id="mappers-【映射器】"><a href="#mappers-【映射器】" class="headerlink" title="mappers 【映射器】"></a>mappers 【映射器】</h2><p>作用：加载映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载sql映射文件，告诉MyBatis 去哪寻找映射SQL 的语句。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 或者也可以扫描包寻找sql映射文件文件，推荐这种方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;package1.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="Mybatis入门案例（不用mapper）"><a href="#Mybatis入门案例（不用mapper）" class="headerlink" title="Mybatis入门案例（不用mapper）"></a>Mybatis入门案例（不用mapper）</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>需求：查询user表中所有的数据</strong></p><ol><li><p><strong>创建user表，添加数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database mybatis;</span><br><span class="line">use mybatis;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    password <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">    addr <span class="type">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;234&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;天津&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;西安&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>创建模块，导入坐标</strong></p><p>在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis 依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql 驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加slf4j日志api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加logback-classic依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加logback-core依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实依赖<strong>只需要导入mybatis,mysql即可，其他是日志、测试之类的</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  CONSOLE ：表示当前的日志信息是可以输出到控制台的。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%level]  %cyan([%thread]) %boldGreen(%logger&#123;15&#125;) - %msg %n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里要改，包名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;package1&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF ， 默认debug</span></span><br><span class="line"><span class="comment">      &lt;root&gt;可以包含零个或多个&lt;appender-ref&gt;元素，标识这个输出位置将会被本日志级别控制。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>需要在项目的 resources 目录下创建logback的配置文件</p></blockquote><p>slf4j，simple logging facade for java的缩写，翻译为java的简单日志外观。slf4j是一个开源项目，它提供我们一个一致的API来使用不同的日志框架，比如： java.util.logging，logback，log4j等。slf4j使用户可以在运行时嵌入他们想使用的日志框架。从名字中可以看出，它其实使用的是facade设计模式来实现的。 </p><p>Logback是SpringBoot内置的日志处理框架，你会发现spring-boot-starter其中包含了spring-boot-starter-logging，该依赖内容就是 Spring Boot 默认的日志框架 logback。官方文档：<a href="http://logback.qos.ch/manual/">http://logback.qos.ch/manual/</a></p></li><li><p><strong>编写 MyBatis 核心配置文件</strong> – &gt; 替换连接信息 解决硬编码问题</p><p>在模块下的 resources 目录下创建mybatis的配置文件 <code>mybatis-config.xml</code>，内容如<a href="#configuration%E3%80%90%E6%A0%B9%E6%A0%87%E7%AD%BE%E3%80%91">configuration【根标签】</a>。</p></li><li><p><strong>编写 SQL 映射文件</strong> –&gt; 统一管理sql语句，解决硬编码问题</p><p>在模块的 <code>resources</code> 目录下创建映射配置文件 <code>UserMapper.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 映射配置文件 UserMapper.xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace名称空间，该命名空间和对应mapper接口的全限定名一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;package1.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>另外，可通过resultMap实现对数据库列名起别名</strong>，以解决数据库列名和User类属性命名法不对应问题（数据库标识符不区分大小写，采用下划线命名法，java标识符常用驼峰命名法）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 统一起别名，resultMap标签的id为自定义的唯一标识，type为package1.pojo.User，</span></span><br><span class="line"><span class="comment">    若核心配置有typeAliases扫描pojo包，user --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对数据库的指定列起别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;passWord&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 起别名了，resultType改成resultMap，值为上面resultMap的id--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>根标签</strong>【mapper】<br>作用：所用子标签均需书写在mapper内部<br>namespace与接口全路径类名【类的全限定名】一致</p><p><strong>八大子标签</strong>：</p><p>insert：定义增加SQL语句<br>delete：定义删除SQL语句<br>update：定义修改语句<br>select：定义查询SQL语句<br>sql：定义SQL语句块<br>resultMap：定义结果集映射【resultType解决不了时，使用resultMap】<br>cache：定义缓冲类<br>cache-ref：定义引用缓存</p></li><li><p><strong>在package1.pojo包下创建 User类</strong></p><p><a href="https://so.csdn.net/so/search?q=POJO&spm=1001.2101.3001.7020">POJO</a>(Plain Old Java Objects)译为，简单的Java对象，其实就是<strong>没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的，没有遵从特定的Java对象模型、约定或框架（如EJB）的不受任何限制的java对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">// 下面两个passWord改成password</span></span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String addr;</span><br><span class="line">    <span class="comment">// 省略了 setter 和 getter</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, passWord=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, addr=&#x27;&quot;</span> + addr + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在package1包下编写 MybatisDemo 测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 加载mybatis的核心配置文件，获取 SqlSessionFactory，session译为“会话”，factory译为“工厂”。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        <span class="comment">// 2. 获取SqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// sqlSession = sqlSessionFactory.openSession(true); // 设置自动提交事务，这种情况不需要手动提交事务了</span></span><br><span class="line">        <span class="comment">// 3. 执行sql，这步不用记，一般这步都是使用mapper代理开发       </span></span><br><span class="line">        sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">// 参数是一个字符串，该字符串必须是映射配置文件的namespace.id</span></span><br><span class="line">        List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;test.selectAll&quot;</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="comment">// 4.要手动提交，不然会回滚事务。如果前面sqlSessionFactory.openSession(true)，就不用再提交事务了  </span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        <span class="comment">// 5. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>第三步执行SQL前的代码在所有案例中都是一样的，直接复制粘贴即可。而且整合Spring后就只剩mapper优化后的执行方法</strong></p></blockquote></li><li><p><strong>回顾对比一下jdbc：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 注册驱动</span></span><br><span class="line">        <span class="comment">// Class.forName(&quot;com.mysql.jdbc.Driver&quot;);// 通过反射获取Driver实现类对象，从而加载驱动</span></span><br><span class="line">        <span class="comment">// 注册驱动语句DriverManager.registerDriver(driver)在Driver的静态代码块里做过了。</span></span><br><span class="line">        <span class="comment">// 此句仅在mysql可省略，其他数据库不能省略</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取连接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/db1?useSSL=false&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">passWord</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, passWord);</span><br><span class="line">        <span class="comment">// 3. 定义sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update student set age = 80 where name=&#x27;xiaohua&#x27;&quot;</span>;</span><br><span class="line">        <span class="comment">// 4. 获取执行sql的对象 Statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="comment">// 5. 执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);<span class="comment">//受影响的行数</span></span><br><span class="line">        <span class="comment">// 6. 处理结果</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">// 7. 释放资源</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="SqlSessionFactory工具类抽取"><a href="#SqlSessionFactory工具类抽取" class="headerlink" title="SqlSessionFactory工具类抽取"></a>SqlSessionFactory工具类抽取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure><p>第三步执行SQL前的代码在所有案例中都是一样的，这些重复代码就会造成一些问题:</p><ol><li><p>重复代码不利于后期的维护</p></li><li><p>SqlSessionFactory工厂类进行重复创建</p></li><li><p>资源消耗非常大但性能却非常低。</p></li></ol><p><strong>解决方案</strong></p><ul><li>代码重复可以<strong>抽取工具类</strong></li><li>对指定代码只需要执行一次可以使用<strong>静态代码块</strong> </li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">// sqlSession = sqlSessionFactory.openSession(true); // 设置自动提交事务，这种情况不需要手动提交事务了</span></span><br></pre></td></tr></table></figure><p>虽然上面语句也重复，但不能抽取到工具类里。因为SqlSession是一个连接、会话，每次连接数据库时候创建一次会话是合适，如果所有连接都共用一个会话会互相影响。</p><p>SqlSession是一个会话，相当于JDBC中的一个Connection对象，Mybatis中所有的数据库交互都由SqlSession来完成。</p></blockquote><p><strong>抽取工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代码块会随着类的加载而自动执行，且只执行一次，静态代码块不能抛异常，要用try-catch</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory <span class="title function_">getSqlSessionFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> SqlSessionFactoryUtils.getSqlSessionFactory();</span><br></pre></td></tr></table></figure><h2 id="IDEA连接数据库"><a href="#IDEA连接数据库" class="headerlink" title="IDEA连接数据库"></a>IDEA连接数据库</h2><p><strong>解决SQL映射文件的警告提示：</strong></p><p>在入门案例映射配置文件中存在报红的情况：数据表显示红色</p><ul><li>产生的原因：Idea和数据库没有建立连接，不识别表信息。但是大家一定要记住，它并不影响程序的执行。</li><li>解决方式：在Idea中配置MySQL数据库连接。</li></ul><p><strong>IDEA中配置MySQL数据库连接</strong></p><ul><li><p>点击IDEA右边框的 <code>Database</code> ，在展开的界面点击 <code>+</code> 选择 <code>Data Source</code> ，再选择 <code>MySQL</code></p></li><li><p>在弹出的界面进行基本信息的填写</p></li><li><p>点击完成后就能看到数据库编译器界面</p></li><li><p>而此界面就和 <code>navicat</code> 工具一样可以进行数据库的操作。也可以编写SQL语句</p></li></ul><p>如果发现写表名时没有提示：<strong>打开File的settings，把SQL Dialects选项的右边那个None改为你的默认数据库。</strong></p><hr><h1 id="Mapper代理开发"><a href="#Mapper代理开发" class="headerlink" title="Mapper代理开发"></a>Mapper代理开发</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>解决原生方式中的硬编码</li><li>简化后期执行SQL</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.执行sqL</span></span><br><span class="line">List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;test.selectAll&quot;</span>);</span><br><span class="line">System.out.println(users);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.获取接口代理对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="comment">// 4.执行方法，其实就是执行sql语句</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br></pre></td></tr></table></figure><h2 id="使用mapper实现查询"><a href="#使用mapper实现查询" class="headerlink" title="使用mapper实现查询"></a>使用mapper实现查询</h2><ol><li><p>定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下。如下图放就可以，因为编译Maven后java和resources下的目录和文件都在同一个根目录下。</p><blockquote><p>注意：在resources下建多层文件夹要用斜杠，例如aa/bb，不能aa.bb。如果直接建aa.bb，则只建了一个名为aa.bb的文件夹，而不是两个。</p></blockquote></li><li><p>设置SQL映射文件的namespace属性为Mapper接口全限定名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 映射配置文件 UserMapper.xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace名称空间，该命名空间和对应mapper接口的全限定名一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;package1.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;package1.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致</p></li><li><p>Mapper代理开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取SqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 3. 执行sql</span></span><br><span class="line">        <span class="comment">// 参数是一个字符串，该字符串必须是映射配置文件的namespace.id</span></span><br><span class="line">        <span class="comment">// List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;);</span></span><br><span class="line">        <span class="comment">// 3.1获取UserMapper接口的代理对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">// 3.2调用sql方法</span></span><br><span class="line">        List&lt;User&gt; users = userMapper.selectAll();</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用在核心配置文件mybatis-config.xml中用<strong>包扫描</strong>的方式简化SQL映射文件的加载。示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载sql映射文件，告诉MyBatis 去哪寻找映射SQL 的语句。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Maven项目编译后，java和resources下的目录和文件都在同一个跟目录下，所以路径是这样的，注意路径是/，不是.--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;package1/mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>简化成</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描包指定name的包下所有mapper配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;package1.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="配置文件实现增删改查"><a href="#配置文件实现增删改查" class="headerlink" title="配置文件实现增删改查"></a>配置文件实现增删改查</h1><h2 id="MybatisX插件、占位符、XML特殊字符转义"><a href="#MybatisX插件、占位符、XML特殊字符转义" class="headerlink" title="MybatisX插件、占位符、XML特殊字符转义"></a>MybatisX插件、占位符、XML特殊字符转义</h2><p><strong>安装MybatisX插件：</strong>Setting–Plugins–MybatisX</p><p>作用是通过小鸟图标，方便mapper接口和mapper配置文件之间代码的统一。</p><p><strong>参数占位符：</strong>参数占位符里的内容为传入的参数名，或者参数的成员变量名，或map的键名。</p><p>mybatis提供了两种参数占位符：</p><ul><li>#{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值。底层使用的是 <code>PreparedStatement</code></li><li>${} ：拼接SQL。底层使用的是 <code>Statement</code>，会存在SQL注入问题。  </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from tb_user where id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>#{}和 ${} 的区别</strong></p><p><code>\#&#123;&#125;</code>是预编译处理，<code>$&#123;&#125;</code>是字符替换。在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 <code>PreparedStatement</code> 的 set 方法赋值，这样可以有效防止 SQL 注入，保证程序的运行安全。</p><p><strong>特殊字符处理：</strong></p><ol><li><p>转义字符。XML中，需要转义的字符有： </p><blockquote><p>&amp;　　  <code>&amp;amp;</code> </p><p>&lt;　  　<code>&amp;lt;</code> </p><p>&gt;　  　<code>&amp;gt;</code> </p><p>＂　　<code>&amp;quot;</code> </p><p>＇　　<code>&amp;apos;</code> </p></blockquote></li><li><p>CDATA区</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from tb_user where id &lt;![CDATA[</span><br><span class="line">        &gt;        </span><br><span class="line">    ]]&gt; #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="resultMap给列起别名并查询所有"><a href="#resultMap给列起别名并查询所有" class="headerlink" title="resultMap给列起别名并查询所有"></a>resultMap给列起别名并查询所有</h2><blockquote><p> 适用于数据库字段名和实体类属性名不同的情况。 </p></blockquote><p>SQL语句下划线命名法的<strong>列名</strong>和java实体类驼峰命名法的<strong>成员变量不同</strong>，会导致数据库给成员变量无法赋值的问题。<strong>通过resultMap标签给数据库列名起别名，可以解决这个问题。</strong></p><h2 id="多条件动态查询（动态SQL）"><a href="#多条件动态查询（动态SQL）" class="headerlink" title="多条件动态查询（动态SQL）"></a>多条件动态查询（动态SQL）</h2><p><strong>动态SQL：</strong>SQL语句随着用户的输入或外部条件的变化而变化，称为动态SQL。</p><p>Mybatis关于动态SQL的<strong>标签</strong>：</p><blockquote><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul></blockquote><p><strong>if 标签</strong>的test 属性：逻辑表达式</p><p>为了防止出现SQL语句where 后直接跟and的情况，给所有条件加了and，并且where后跟了1=1。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from tb_brand</span><br><span class="line">    <span class="comment">&lt;!-- 这里1=1是防止where后直接跟and的情况发生，更好的办法是用where标签，根据语法动态去and或where关键字 --&gt;</span></span><br><span class="line">    where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">        and status = #&#123;status&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        and company_name like #&#123;companyName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        and brand_name like #&#123;brandName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>where 标签</strong>作用：</p><ul><li>替换where关键字</li><li>会动态的去掉第一个条件前的 and</li><li>如果所有的参数没有值则不加where关键字</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">     select * from tb_brand</span><br><span class="line">     <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  where标签下注意所有if都要加and--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">             and status = #&#123;status&#125;</span><br><span class="line">         <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">             and company_name like #&#123;companyName&#125;</span><br><span class="line">         <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">             and brand_name like #&#123;brandName&#125;</span><br><span class="line">         <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="单条件动态查询（动态SQL）"><a href="#单条件动态查询（动态SQL）" class="headerlink" title="单条件动态查询（动态SQL）"></a>单条件动态查询（动态SQL）</h2><p>先选择，再输入查询。</p><p><strong><code>choose（when，otherwise）</code><strong>标签</strong>类似于Java 中的switch</strong>语句，自带break。  </p><blockquote><p> <strong>注意：</strong></p><p>choose-when是多选一，一项<when>满足条件后其他就不判断了。</p><p><if>可以多层判断。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByConditionSingle&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from tb_brand</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 相当于switch --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 相当于case --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span> </span><br><span class="line">                status = #&#123;status&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">                company_name like #&#123;companyName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                brand_name like #&#123;brandName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p><strong>返回主键</strong>：在 insert 标签上添加如下属性</p><ul><li>useGeneratedKeys：是够获取自动增长的主键值。true表示获取</li><li>keyProperty ：指定将获取到的主键值封装到哪儿个属性里  </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line">    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brandMapper.add(brand);</span><br><span class="line">System.out.println(brand.getId());</span><br></pre></td></tr></table></figure><h2 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h2><p>获取到修改后的数据和id，修改此id对应的一行数据。在修改界面用户可能只修改部分属性， 所以加条件<if>判断每个属性修改框用户有没有填写，用<set>防止更新语句最后一行有逗号。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">    update tb_brand</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            brand_name = #&#123;brandName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            company_name = #&#123;companyName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ordered != null&quot;</span>&gt;</span></span><br><span class="line">            ordered = #&#123;ordered&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;description != null and description != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            description = #&#123;description&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">            status = #&#123;status&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><p>编写SQL时需要遍历数组来拼接SQL语句。Mybatis 提供了 <code>foreach</code> 标签供我们使用</p><p><strong>foreach 标签</strong></p><p>用来迭代任何可迭代的对象（如数组，集合）。</p><ul><li>collection 属性：指定遍历的数组<ul><li>mybatis会将数组参数，封装为一个Map集合。<ul><li>默认：array = 数组，key是array而不是数组名，如collection=”array”和void deleteByIds(int[] ids);</li><li>用@Param注解改变map集合的默认key的名称为数组名，如collection=”ids”和void deleteByIds(@Param(“ids”) int[] ids);</li></ul></li></ul></li><li>item 属性：本次迭代获取到的元素，如item=”id”。</li><li>separator 属性：集合项迭代之间的分隔符。<code>foreach</code> 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。如separator=”,”</li><li>open 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次。如open=”(“</li><li>close 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次。如close=”)”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(<span class="type">int</span>[] ids)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">    delete from tb_brand where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="Mybatis参数传递"><a href="#Mybatis参数传递" class="headerlink" title="Mybatis参数传递"></a>Mybatis参数传递</h1><p>Mybatis 接口方法中可以接收各种各样的参数，如下：</p><ul><li>多个参数</li><li>单个参数：单个参数又可以是如下类型<ul><li><strong>POJO 类型，传入对象</strong></li><li>Map 集合类型，传入map</li><li>Collection 集合类型</li><li>List 集合类型</li><li>Array 类型</li><li>其他类型</li></ul></li></ul><blockquote><p>注意：单个参数不用@Param注解起别名，会自动识别要传的参数。</p><p>mapper传参数，如果<strong>参数包括对象和散装参数</strong>，那么<strong>对象必须也注解</strong>，写SQL语句时候不能忘记<code>对象.属性</code>，例如brand.status.</p></blockquote><ol><li><p><strong>散装参数</strong>：使用 <code>@Param(&quot;参数名称&quot;)</code> 标记每一个参数，在映射配置文件中就需要使用 <code>#&#123;参数名称&#125;</code> 进行占位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByPageAndCondition</span><span class="params">(<span class="meta">@Param(&quot;begin&quot;)</span> <span class="type">int</span> begin,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@Param(&quot;size&quot;)</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@Param(&quot;brand&quot;)</span> Brand brand)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    where status = #&#123;brand.status&#125;</span><br><span class="line">    limit #&#123;begin&#125;, #&#123;size&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>实体类封装参数</strong>：将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，里面的<strong>内容必须和实体类属性名保持一致</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>map集合</strong>：将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，里面的<strong>内容必须和map集合中键的名称一致</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Map map)</span>;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注解底层，了解即可</strong> </p><p>我们在接口方法中定义多个参数，Mybatis 会将这些参数封装成 Map 集合对象，值就是参数值，而键在没有使用 <code>@Param</code> 注解时有以下命名规则：</p><ul><li><p>以 arg 开头 ：第一个参数就叫 arg0，第二个参数就叫 arg1，以此类推。如：</p><blockquote><p>map.put(“arg0”，参数值1);</p><p>map.put(“arg1”，参数值2);</p></blockquote></li><li><p>以 param 开头 ： 第一个参数就叫 param1，第二个参数就叫 param2，依次类推。如：</p><blockquote><p>map.put(“param1”，参数值1);</p><p>map.put(“param2”，参数值2);</p></blockquote></li><li><p>在映射配合文件的SQL语句中使用用 <code>arg</code> 开头的和 <code>param</code> 书写，代码的可读性会变的特别差，此时可以使用 <code>@Param</code> 注解。在接口方法参数上使用 <code>@Param</code> 注解，Mybatis 会将 <code>arg</code> 开头的键名替换为对应注解的属性值。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User <span class="title function_">select</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, String password)</span>;</span><br></pre></td></tr></table></figure><p>Mybatis 在封装 Map 集合时，键名就会变成如下：</p><p>map.put(“username”，参数值1);</p><p>map.put(“arg1”，参数值2);</p><p>map.put(“param1”，参数值1);</p><p>map.put(“param2”，参数值2);</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from tb_user where username=#&#123;username&#125; and password=#&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行程序结果没有报错。而如果将 <code>#&#123;&#125;</code> 中的 <code>username</code> 还是写成 <code>arg0</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from tb_user where username=#&#123;arg0&#125; and password=#&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行程序则可以看到报错：Parameter ‘arg0’ not found.</p></blockquote></li></ul><p><strong>结论：以后接口参数是多个时，在每个参数上都使用 <code>@Param</code> 注解。</strong></p><hr><h1 id="注解实现增删改查"><a href="#注解实现增删改查" class="headerlink" title="注解实现增删改查"></a>注解实现增删改查</h1><p>如果<strong>SQL语句简单</strong>，使用注解开发会比配置文件开发更加<strong>方便</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(value = &quot;select * from tb_user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">select</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li>注解后是没有分号的。</li><li>注解是用来替换映射配置文件方式配置的，所以使用了注解，就不需要再映射配置文件中书写对应的 <code>statement</code></li></ul></blockquote><p>Mybatis 针对 CURD 操作都提供了对应的注解，已经做到见名知意。如下：</p><ul><li>查询 ：@Select</li><li>添加 ：@Insert</li><li>修改 ：@Update</li><li>删除 ：@Delete</li></ul><p><strong>注意：</strong>在官方文档中 <code>入门</code> 中有这样的一段话：使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。</p><p>所以<strong>注解完成简单功能，配置文件完成复杂功能。</strong></p><p>而我们之前写的动态 SQL 就是复杂的功能，如果用注解，就需要使用到 Mybatis 提供的SQL构建器来完成，而对应的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">    SELECT(<span class="string">&quot;P.ID,P.USERNAME,P.PASSWORD, P.FIRST NAME, P.LAST NAME&quot;</span>)FROM(<span class="string">&quot;PERSON P&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="literal">null</span>) &#123;</span><br><span class="line">        WHERE(<span class="string">&quot;P.ID like #&#123;id&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (firstName != <span class="literal">null</span>) &#123;</span><br><span class="line">        WHERE(<span class="string">&quot;P.FIRST NAME like #&#123;firstName&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastName != <span class="literal">null</span>) &#123;</span><br><span class="line">        WHERE(<span class="string">&quot;P.LAST NAME like #&#123;lastName&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ORDER <span class="title function_">BY</span><span class="params">(<span class="string">&quot;P.LAST NAME&quot;</span>)</span>;</span><br><span class="line">&#125;&#125;.tostring();</span><br></pre></td></tr></table></figure><p>上述代码将java代码和SQL语句融到了一块，使得代码的可读性大幅度降低。</p><hr><h1 id="MyBatis-多数据源"><a href="#MyBatis-多数据源" class="headerlink" title="MyBatis 多数据源"></a>MyBatis 多数据源</h1><h3 id="一、配置双数据源"><a href="#一、配置双数据源" class="headerlink" title="一、配置双数据源"></a>一、配置双数据源</h3><ol><li><p>禁用Spring Boot数据源自动装配，在启动类@SpringBootApplication添加<code>exclude = &#123;DataSourceAutoConfiguration.class&#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, MybatisAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>application.properties配置文件添加两个数据源配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.db1.driverClassName</span> =<span class="string">oracle.jdbc.OracleDriver</span></span><br><span class="line"><span class="attr">spring.datasource.db1.jdbcUrl</span>=<span class="string">jdbc:oracle:thin:@&lt;db1 ip&gt;/db1</span></span><br><span class="line"><span class="attr">spring.datasource.db1.username</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.datasource.db1.password</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.datasource.db1.platform</span>=<span class="string">oracle</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.db2.driverClassName</span> =<span class="string">oracle.jdbc.OracleDriver</span></span><br><span class="line"><span class="attr">spring.datasource.db2.jdbcUrl</span>=<span class="string">jdbc:oracle:thin:@&lt;db2 ip&gt;/db2</span></span><br><span class="line"><span class="attr">spring.datasource.db2.username</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.datasource.db2.password</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.datasource.db2.platform</span>=<span class="string">oracle</span></span><br></pre></td></tr></table></figure></li><li><p>添加oracle数据源配置类PrimaryDataSourceConfig，下面的pg数据源配置类DmpDataSourceConfig，添加对应数据源的bean</p><ul><li><p>PrimaryDataSourceConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = &quot;primaryDataSource&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db1&quot;)</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;config primaryDataSource success.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DmpDataSourceConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = &quot;db2DataSource&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;config db2DataSource success.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="二、配置两个Mybatis"><a href="#二、配置两个Mybatis" class="headerlink" title="二、配置两个Mybatis"></a>二、配置两个Mybatis</h3><ol><li><p>禁用Mybatis自动装配，启动类@SpringBootApplication注解添加exclude = {DataSourceAutoConfiguration.class, MybatisAutoConfiguration.class}，如上</p></li><li><p>在application.properties配置文件添加两个Mybatis的配置和对应的配置类</p><ul><li><p>主数据源的mybatis配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.db1.extend.mybatisMapperLocations</span>=<span class="string">classpath:config/mybatis/mapper/*.xml</span></span><br></pre></td></tr></table></figure></li><li><p>主数据源的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db1.extend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimaryMybatisProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mybatisMapperLocations;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMybatisMapperLocations</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mybatisMapperLocations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMybatisMapperLocations</span><span class="params">(String mybatisMapperLocations)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mybatisMapperLocations = mybatisMapperLocations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数据源2的配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.db2.extend.mybatisMapperLocations</span>=<span class="string">classpath:config/mybatis/mapper2/*.xml</span></span><br></pre></td></tr></table></figure></li><li><p>数据源2的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db1.extend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DmpMybatisProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mybatisMapperLocations;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMybatisMapperLocations</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mybatisMapperLocations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMybatisMapperLocations</span><span class="params">(String mybatisMapperLocations)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mybatisMapperLocations = mybatisMapperLocations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置两个Mybatis的SqlSessionFactory</p><p>主数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123; &quot;xxx.db.mapper&quot; &#125;,sqlSessionFactoryRef=&quot;primarySqlSessionFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimaryMybatisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PrimaryMybatisProperties property;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;primaryDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db1&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;config primaryDataSource success.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;primarySqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;primaryDataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">            sessionFactory.setDataSource(dataSource);</span><br><span class="line">            sessionFactory.setMapperLocations(<span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>()</span><br><span class="line">                    .getResources(<span class="built_in">this</span>.property.getMybatisMapperLocations()));</span><br><span class="line">            log.info(<span class="string">&quot;config primarySqlSessionFactory success.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;config primarySqlSessionFactory failure.&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean(name = &quot;primarySqlSessionTemplate&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionTemplate <span class="title function_">testSqlSessionTemplate</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;primarySqlSessionFactory&quot;)</span> SqlSessionFactory sqlSessionFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean(name = &quot;primaryTransactionManager&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">transactionManager</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;primaryDataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据源2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123; &quot;xxx.db2.mapper&quot; &#125;,sqlSessionFactoryRef=&quot;db2SqlSessionFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Db2MybatisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Db2MybatisProperties property;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2DataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;config db2DataSource success.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2SqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;db2DataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">            sessionFactory.setDataSource(dataSource);</span><br><span class="line">            sessionFactory.setMapperLocations(<span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>()</span><br><span class="line">                    .getResources(<span class="built_in">this</span>.property.getMybatisMapperLocations()));</span><br><span class="line">            log.info(<span class="string">&quot;config db2SqlSessionFactory success.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;config db2SqlSessionFactory failure.&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2SqlSessionTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionTemplate <span class="title function_">testSqlSessionTemplate</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;db2SqlSessionFactory&quot;)</span> SqlSessionFactory sqlSessionFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2TransactionManager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">transactionManager</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;db2DataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="三、配置两个mybatis-PageHelper"><a href="#三、配置两个mybatis-PageHelper" class="headerlink" title="三、配置两个mybatis PageHelper"></a>三、配置两个mybatis PageHelper</h3><p>pagehelper spring boot AutoConfigure提供的PageHelperAutoConfiguration类，自动配置Mybatis的分页插件。因此，先禁用PageHelperAutoConfiguration类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123; </span></span><br><span class="line"><span class="meta">        DataSourceAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">        MybatisAutoConfiguration.class, </span></span><br><span class="line"><span class="meta">        PageHelperAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要配置两个mybatis的分页插件，需要做如下操作：</p><ol><li><p>在<code>application.properties</code>配置文件中添加如下两个mybatis分页插件的配置和对应的<code>@Configuration</code>类。<br>使用db1数据源的mybatis分页插件的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.db1.extend.pagehelperDialect=Oracle</span><br><span class="line">spring.datasource.db1.extend.pagehelperReasonable=true</span><br><span class="line">spring.datasource.db1.extend.pagehelperSupportMethodsArguments=true</span><br><span class="line">spring.datasource.db1.extend.pagehelperOffsetAsPageNum=true</span><br><span class="line">spring.datasource.db1.extend.pagehelperRowBoundsWithCount=true</span><br><span class="line">spring.datasource.db1.extend.pagehelperParams=count=countSql;pageNum=pageNumKey;pageSize=pageSizeKey;</span><br></pre></td></tr></table></figure><p>使用db1数据源的mybatis分页插件的@Configuration类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db1.extend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimaryMybatisProperties</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String mybatisMapperLocations;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperDialect;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperReasonable;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperSupportMethodsArguments;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperParams;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperOffsetAsPageNum;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperRowBoundsWithCount;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用db2数据源的mybatis分页插件的配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.db2.extend.pagehelperDialect</span>=<span class="string">Oracle</span></span><br><span class="line"><span class="attr">spring.datasource.db2.extend.pagehelperReasonable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.db2.extend.pagehelperSupportMethodsArguments</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.db2.extend.pagehelperOffsetAsPageNum</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.db2.extend.pagehelperRowBoundsWithCount</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.db2.extend.pagehelperParams</span>=<span class="string">count=countSql;pageNum=pageNumKey;pageSize=pageSizeKey;</span></span><br></pre></td></tr></table></figure><p>使用db2数据源的mybatis分页插件的@Configuration类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.db2.extend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Db2MybatisProperties</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String mybatisMapperLocations;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperDialect;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperReasonable;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperSupportMethodsArguments;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperParams;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperOffsetAsPageNum;</span><br><span class="line">    <span class="keyword">private</span> String pagehelperRowBoundsWithCount;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置两个mybatis的SqlSessionFactory，增加分页插件<br>PrimaryMybatisConfiguration，添加PageHelper，其余不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimaryMybatisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;primarySqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;primaryDataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">            sessionFactory.setDataSource(dataSource);</span><br><span class="line">            sessionFactory.setMapperLocations(<span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>()</span><br><span class="line">                    .getResources(<span class="built_in">this</span>.property.getMybatisMapperLocations()));</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">// 分页插件</span></span><br><span class="line">            <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageInterceptor</span>();</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.setProperty(<span class="string">&quot;helperDialect&quot;</span>, <span class="built_in">this</span>.property.getPagehelperDialect());</span><br><span class="line">            properties.setProperty(<span class="string">&quot;reasonable&quot;</span>, <span class="built_in">this</span>.property.getPagehelperReasonable());</span><br><span class="line">            properties.setProperty(<span class="string">&quot;supportMethodsArguments&quot;</span>,</span><br><span class="line">                                   <span class="built_in">this</span>.property.getPagehelperSupportMethodsArguments());</span><br><span class="line">            properties.setProperty(<span class="string">&quot;params&quot;</span>,<span class="built_in">this</span>.property.getPagehelperParams());</span><br><span class="line">            interceptor.setProperties(properties);</span><br><span class="line">            sessionFactory.setPlugins(<span class="keyword">new</span> <span class="title class_">Interceptor</span>[] &#123;interceptor&#125;);</span><br><span class="line">         </span><br><span class="line">            log.info(<span class="string">&quot;config primarySqlSessionFactory success.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;config primarySqlSessionFactory failure.&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Db2MybatisConfiguration，添加PageHelper，其余不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Db2MybatisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2SqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;db2DataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">            sessionFactory.setDataSource(dataSource);</span><br><span class="line">            sessionFactory.setMapperLocations(<span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>()</span><br><span class="line">                    .getResources(<span class="built_in">this</span>.property.getMybatisMapperLocations()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分页插件</span></span><br><span class="line">            <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageInterceptor</span>();</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.setProperty(<span class="string">&quot;helperDialect&quot;</span>, <span class="built_in">this</span>.property.getPagehelperDialect());</span><br><span class="line">            properties.setProperty(<span class="string">&quot;reasonable&quot;</span>, <span class="built_in">this</span>.property.getPagehelperReasonable());</span><br><span class="line">            properties.setProperty(<span class="string">&quot;supportMethodsArguments&quot;</span>,</span><br><span class="line">                                   <span class="built_in">this</span>.property.getPagehelperSupportMethodsArguments());</span><br><span class="line">            properties.setProperty(<span class="string">&quot;params&quot;</span>,<span class="built_in">this</span>.property.getPagehelperParams());</span><br><span class="line">            interceptor.setProperties(properties);</span><br><span class="line">            sessionFactory.setPlugins(<span class="keyword">new</span> <span class="title class_">Interceptor</span>[] &#123;interceptor&#125;);</span><br><span class="line">            </span><br><span class="line">            log.info(<span class="string">&quot;config db2SqlSessionFactory success.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;config db2SqlSessionFactory failure.&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="四、配置两个mybatis-generator"><a href="#四、配置两个mybatis-generator" class="headerlink" title="四、配置两个mybatis generator"></a>四、配置两个mybatis generator</h3><ol><li><p>在pom.xml中引入mybatis generator</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis generator 自动生成代码插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle.jdbc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc7<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>12.1.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置2个mybatis generator配置文件。<br>使用db1数据源的mybatis generator的配置文件generatorConfig.xml<br>使用db1数据源的mybatis generator的配置文件generatorConfig2.xml</p></li><li><p>使用mvn执行mybatis generator命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用db1数据源的mybatis generator生成代码命令</span></span><br><span class="line">mvn -Dmybatis.generator.configurationFile=src/main/resources/generatorConfig.xml mybatis-generator:generate</span><br><span class="line"><span class="comment"># 使用db2数据源的mybatis generator生成代码命令</span></span><br><span class="line">mvn -Dmybatis.generator.configurationFile=src/main/resources/generatorConfig2.xml mybatis-generator:generate</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="MyBatis-编写自定义插件"><a href="#MyBatis-编写自定义插件" class="headerlink" title="MyBatis 编写自定义插件"></a>MyBatis 编写自定义插件</h1><h2 id="MyBatis-分页插件的实现原理"><a href="#MyBatis-分页插件的实现原理" class="headerlink" title="MyBatis 分页插件的实现原理"></a>MyBatis 分页插件的实现原理</h2><p>分页插件的基本原理是使用 <code>MyBatis</code> 提供的插件接口，实现自定义插件，<strong>在插件的拦截方法内拦截待执行的 SQL</strong>，然后重写 SQL，根据 <code>dialect</code> 方言，<strong>添加对应的物理分页语句和物理分页参数</strong>。</p><h2 id="自定义插件实现原理"><a href="#自定义插件实现原理" class="headerlink" title="自定义插件实现原理"></a>自定义插件实现原理</h2><p>MyBatis 自定义插件针对 MyBatis 四大对象(<code>Executor</code>、<code>StatementHandler</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>)进行拦截：<br><strong>Executor：</strong>拦截<strong>内部执行器</strong>，它负责<strong>调用 <code>StatementHandler</code> 操作数据库，并把结果集通过 <code>ResultSetHandler</code> 进行自动映射，另外它还处理了二级缓存的操作</strong>；<br><strong>StatementHandler：</strong>拦截 <strong>SQL 语法构建的处理</strong>，它是MyBatis直接和数据库执行 <code>SQL脚本</code>的对象，它也<strong>实现了 MyBatis 的一级缓存</strong>；<br><strong>ParameterHandler：</strong>拦截<strong>参数的处理</strong>；<br><strong>ResultSetHandler：</strong>拦截<strong>结果集的处理</strong>。</p><h2 id="自定义插件实现关键"><a href="#自定义插件实现关键" class="headerlink" title="自定义插件实现关键"></a>自定义插件实现关键</h2><p><code>MyBatis插件</code>要实现 <code>Interceptor</code> 接口，接口包含的方法，如下代码所示：<br><strong><code>setProperties</code> 方法：</strong>在 MyBatis 进行配置插件的时候可配置自定义相关属性，即：<strong>接口实现对象的参数配置</strong>；<br><strong><code>plugin</code> 方法：</strong>插件用于<strong>封装目标对象</strong>的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：<code>return Plugin. wrap(target, this)</code>；<br><strong><code>intercept</code> 方法：</strong>是要<strong>进行拦截的时候要执行的方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interfaceInterceptor&#123;</span><br><span class="line">  object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">  object <span class="title function_">plugin</span><span class="params">(object target)</span>;</span><br><span class="line">  voidsetProperties(Properties properties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Intercepts(&#123;@signature(type = Executor.class, method = &quot;query&quot;, </span></span><br><span class="line"><span class="meta">    args = &#123;Mappedstatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span></span><br><span class="line">publicclassTestInterceptorimplementsInterceptor &#123;</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> invocation.getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> invocation.getMethod();<span class="comment">//代理方法</span></span><br><span class="line">    Object[] args = invocation.getArgs() <span class="comment">// 方法参数</span></span><br><span class="line">    <span class="comment">// do something ...... 方法拦截前执行代码块</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span>invocation.proceed():</span><br><span class="line">    <span class="comment">// do something ...... 方法拦截后执行代码块</span></span><br><span class="line">    <span class="keyword">return</span> result:</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> object <span class="title function_">plugin</span><span class="params">(object target)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><h2 id="MyBatis-的分页方式"><a href="#MyBatis-的分页方式" class="headerlink" title="MyBatis 的分页方式"></a>MyBatis 的分页方式</h2><p><strong>分页方式：</strong>逻辑分页和物理分页。</p><ul><li><strong>逻辑分页：</strong>使用 <code>MyBatis</code> 自带的 <code>RowBounds</code> 进行分页，它是<strong>一次性查询很多数据，然后在数据中再进行检索</strong>。</li><li><strong>物理分页：</strong>手写 SQL 分页或使用分页插件 <code>PageHelper</code>，去数据库<strong>查询指定条数的分页数据</strong>的形式。</li></ul><h2 id="MyBatis-逻辑分页和物理分页的区别"><a href="#MyBatis-逻辑分页和物理分页的区别" class="headerlink" title="MyBatis 逻辑分页和物理分页的区别"></a>MyBatis 逻辑分页和物理分页的区别</h2><p><strong>逻辑分页</strong>是一次性查询很多数据，然后在结果中检索分页的数据。这样<strong>需要消耗大量的内存、有内存溢出的风险、对数据库压力较大</strong>。<br><strong>物理分页</strong>是从数据库<strong>查询指定条数的数据</strong>，弥补了一次性全部查出的所有数据的缺点，如需要大量内存，数据库查询压力较大等问题。</p><h2 id="RowBounds-是一次性查询全部结果吗？为什么？"><a href="#RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="RowBounds 是一次性查询全部结果吗？为什么？"></a>RowBounds 是一次性查询全部结果吗？为什么？</h2><p><code>RowBounds</code> 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 <em>MyBatis 是对 jdbc 的封装</em>，<strong>在 jdbc 驱动中有一个 <code>Fetch Size</code> 的配置，它规定了每次最多从数据库查询多少条数据</strong>，假如你要查询更多数据，它会在你<strong>执行 next()的时候，去查询更多的数据</strong>。<br>就好比去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()时会自动完成查询工作。这样做的好处可以<strong>有效防止内存溢出</strong>。</p><h2 id="MyBatis-是否支持延迟加载及延迟加载的原理"><a href="#MyBatis-是否支持延迟加载及延迟加载的原理" class="headerlink" title="MyBatis 是否支持延迟加载及延迟加载的原理"></a>MyBatis 是否支持延迟加载及延迟加载的原理</h2><p><code>MyBatis</code> 支持延迟加载，设置 <code>lazyLoadingEnabled=true</code> 。<br><strong>延迟加载的原理</strong>是<strong>调用的时候触发加载</strong>，而不是在初始化的时候就加载信息。<br>比如调用 <code>a. getB(). getName()</code>，这个时候发现 <code>a. getB()</code> 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 <code>a. setB(b)</code>，而这时候再调用 <code>a. getB(). getName()</code> 就有值了，这就是延迟加载的基本原理。</p><h2 id="MyBatis-的一级缓存和二级缓存"><a href="#MyBatis-的一级缓存和二级缓存" class="headerlink" title="MyBatis 的一级缓存和二级缓存"></a>MyBatis 的一级缓存和二级缓存</h2><p><strong>一级缓存：基于<code>PerpetualCache</code>的<code>HashMap</code>本地缓存</strong>，其声明周期和 SQLSession 一致，有多个 SQLSession 或者分布式的环境中数据库操作，<strong>可能会出现脏数据</strong>。<strong>当 <code>Session flush 或 close</code> 之后，该 Session 中的所有 Cache 就将清空</strong>，默认一级缓存开启。<br><strong>二级缓存：</strong>也是<strong>基于 <code>PerpetualCache</code> 的 <code>HashMap</code> 本地缓存</strong>，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，**要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)**。<br><strong>开启二级缓存数据查询流程：</strong><code>二级缓存 -&gt; 一级缓存 -&gt; 数据库</code>。<br><strong>缓存更新机制：</strong>当某一作用域(一级缓存Session/二级缓存Mapper)<strong>进行C/U/D 操作后，默认该作用域下所有select中的缓存将被clear</strong>。</p><h2 id="MyBatis-和-hibernate-的区别"><a href="#MyBatis-和-hibernate-的区别" class="headerlink" title="MyBatis 和 hibernate 的区别"></a>MyBatis 和 hibernate 的区别</h2><p><strong>灵活性：</strong>MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。<br><strong>可移植性：</strong><code>MyBatis</code> 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以<strong>可移植性比较差</strong>。<br><strong>学习和使用门槛：</strong>MyBatis 入门比较简单，使用门槛也更低。<br><strong>二级缓存：</strong><code>hibernate 拥有更好的二级缓存，可以自行更换为第三方的二级缓存</code>。</p><h2 id="MyBatis-有哪些执行器（Executor）"><a href="#MyBatis-有哪些执行器（Executor）" class="headerlink" title="MyBatis 有哪些执行器（Executor）"></a>MyBatis 有哪些执行器（Executor）</h2><p>MyBatis 有<strong>三种</strong>基本的Executor执行器：<br><strong><code>SimpleExecutor：</code><strong>每执行一次 <code>update 或 select</code> 就开启一个 <code>Statement</code> 对象，</strong>用完立刻关闭</strong> Statement 对象；<br><strong><code>ReuseExecutor：</code><strong>执行 <code>update 或 select</code>，</strong>以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建</strong>，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是<strong>重复使用 Statement 对象</strong>；<br>**<code>BatchExecutor：</code>*<em>执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（<code>addBatch()</code>），等待统一执行（<code>executeBatch()</code>），它</em>缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理*，与 jdbc 批处理相同。</p>]]></content>
    
    
    <summary type="html">MyBatis是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="MyBatis" scheme="https://southernfish.github.io/categories/Framwork/MyBatis/"/>
    
    
    <category term="MyBatis" scheme="https://southernfish.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>构建工具Maven</title>
    <link href="https://southernfish.github.io/pages/java/java-maven/"/>
    <id>https://southernfish.github.io/pages/java/java-maven/</id>
    <published>2025-07-29T00:30:00.000Z</published>
    <updated>2025-09-20T11:18:48.147Z</updated>
    
    <content type="html"><![CDATA[<p>Maven项目<a href="https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/1772960?fromModule=lemma_inlink">对象模型</a>(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的<a href="https://baike.baidu.com/item/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/6854630?fromModule=lemma_inlink">项目管理工具</a>软件。</p><p>Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的<a href="https://baike.baidu.com/item/%E5%8F%AF%E9%87%8D%E7%94%A8%E6%80%A7/53650612?fromModule=lemma_inlink">可重用性</a>，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 <a href="https://baike.baidu.com/item/Apache/6265?fromModule=lemma_inlink">Apache</a> <a href="https://baike.baidu.com/item/Jakarta/15952232?fromModule=lemma_inlink">Jakarta</a> 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</p><blockquote><p>参考文章：<a href="https://blog.csdn.net/qq_40991313/article/details/125818307">Maven基础&amp;MyBatis</a></p></blockquote><h1 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h1><p><strong>Maven</strong>是专门用于<strong>管理和构建Java项目</strong>的工具。</p><p><strong>传统项目管理缺点：</strong></p><ul><li>jar包版本不统一、不兼容</li><li>工程升级维护过程操作繁琐</li></ul><p><strong>Maven介绍：</strong></p><p>Maven 的本质是一个<strong>项目管理工具</strong>，将项目开发和管理过程抽象成一个项目对象模型（POM）。</p><p>maven是用java语言写的，它管理的项目都以面对对象形式设计，最终<strong>把一个项目看成一个对象</strong>，即POM。</p><p>**POM:**（Project Object Model）：项目对象模型</p><h2 id="作用和功能"><a href="#作用和功能" class="headerlink" title="作用和功能"></a>作用和功能</h2><p><strong>作用：</strong></p><ul><li><strong>项目构建：</strong>提供标准的、<strong>跨平台</strong>的自动化项目构建方式</li><li><strong>依赖管理：</strong>方便快捷的管理项目依赖的资源（jar包），避免资源间的版本冲突问题</li><li><strong>统一开发结构：</strong>提供标准的、统一的项目结构</li></ul><p><strong>功能</strong>：Maven是专门用于管理和构建Java项目的工具，它的主要功能有：</p><ul><li><p>提供了一套标准化的项目结构</p><p>每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。</p><p>而Maven提供了一套标准化的项目结构，所有的IDE使用Maven构建的项目完全一样，所以IDE创建的Maven项目可以通用。</p></li><li><p><strong>提供了一套标准化的构建流程</strong></p><p>编译，测试，打包，发布……</p></li><li><p><strong>提供了一套依赖管理机制</strong></p><p>Maven使用标准的<strong>坐标</strong>配置来管理各种依赖， 只需要简单的配置就可以完成依赖管理</p></li></ul><h2 id="Maven模型"><a href="#Maven模型" class="headerlink" title="Maven模型"></a>Maven模型</h2><ul><li>项目对象模型pom (Project Object Model)</li><li>依赖管理模型(Dependency)</li><li>插件(Plugin)</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250728212853171.png" alt="image-20250728212853171"></p><p><strong>项目对象模型pom</strong>就是将我们自己抽象成一个对象模型，有自己专属的坐标，是唯一标识。</p><p>项目对象模型pom通过xml格式保存的pom.xml文件。该文件用于管理：源代码、配置文件、开发者的信息和角色、问题追踪系统、组织信息、项目授权、项目的url、项目的依赖关系等等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ReviewTest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>依赖管理模型</strong>则是使用坐标来描述当前项目依赖哪些第三方jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>项目管理模型和依赖管理模型结合起来，体现Maven方便的依赖管理。</p><p><strong>构建生命周期和插件部分</strong>用来完成 <strong><code>标准化构建流程</code></strong> 。</p><p>如我们需要<strong>编译</strong>，Maven提供了一个编译插件供我们使用。我们需要<strong>打包</strong>，Maven就提供了一个打包插件提供我们使用等。 </p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>Maven用坐标配置管理依赖。</p><p>依赖jar包则其实存储在本地仓库中，项目运行时从本地仓库中拿需要的依赖jar包。</p><ul><li><strong>本地仓库</strong>：自己电脑上存储资源的仓库（是个目录），连接远程仓库获取资源</li><li><strong>中央仓库</strong>：由Maven团队维护的全球唯一的仓库，Maven团队维护，存储所有资源的仓库<ul><li>地址： <a href="https://repo1.maven.org/maven2/">Central Repository:</a></li></ul></li><li>**远程仓库(私服)**：一般由公司团队搭建的私有仓库。部门/公司范围内存储资源的仓库，从中央仓库获取资源</li></ul><p><strong>私服的作用：</strong></p><ul><li>保存具有版权的资源，包含购买或自主研发的jar。中央仓库中的jar都是开源的，不能存储具有版权的资源</li><li>一定范围内共享资源，仅对内部开放，不对外共享</li></ul><p>当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包：</p><ul><li>如果有，则在项目直接引用;</li><li>如果没有，则去中央仓库中下载对应的jar包到本地仓库。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250728213201201.png" alt="image-20250728213201201"></p><p>如果还可以搭建远程仓库，将来jar包的查找顺序则变为：</p><blockquote><p>本地仓库 –&gt; 远程仓库–&gt; 中央仓库</p></blockquote><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250728213219867.png" alt="image-20250728213219867"></p><h3 id="Maven-坐标详解"><a href="#Maven-坐标详解" class="headerlink" title="Maven 坐标详解"></a>Maven 坐标详解</h3><p><strong>什么是坐标？</strong></p><ul><li>Maven 中的坐标是<strong>资源的唯一标识</strong></li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul><p><strong>所有坐标官网（需要梯子）：</strong><a href="https://mvnrepository.com/">Maven Repository</a></p><p>Maven 坐标主要组成</p><p>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</p><p>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）</p><p>version：定义当前项目版本号</p><p>scope：范围，像Servlet、jsp依赖都需要设置范围为provided</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      此处为什么需要添加该标签?</span></span><br><span class="line"><span class="comment">      provided指的是在编译和测试过程中有效,在运行时无效，最后生成的war包时不会加入</span></span><br><span class="line"><span class="comment">       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li>上面所说的资源可以是插件、依赖、当前项目。</li><li>我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</li></ul></blockquote><h1 id="Maven基本使用"><a href="#Maven基本使用" class="headerlink" title="Maven基本使用"></a>Maven基本使用</h1><h2 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h2><p>compile ：编译，生成target目录</p><p>clean：清理，删除target目录</p><p>test：测试，执行test文件下测试代码</p><p>package：打包，将当前项目打包成的jar包</p><p>install：安装，将当前项目打成jar包，并安装到本地仓库</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250728213443172.png" alt="image-20250728213443172"></p><p><strong>编译命令 mvn compile</strong></p><p>首次编译会先从阿里云（之前conf/settings.xml配置了阿里云私服）下载编译需要插件的jar包，在本地仓库（之前conf/settings.xml配置了本地仓库位置）也能看到下载好的插件。</p><p>在项目下会生成一个 <code>target</code> 目录，里面保存编译后的字节码文件。</p><p><strong>清理命令 mvn clean</strong></p><ul><li>从阿里云下载清理需要的插件jar包</li><li>删除项目下的 <code>target</code> 目录</li></ul><h2 id="Maven-生命周期"><a href="#Maven-生命周期" class="headerlink" title="Maven 生命周期"></a>Maven 生命周期</h2><blockquote><p><strong>简洁版：</strong></p><ul><li><strong>clean：</strong>清理上次构建结果</li><li><strong>valide：</strong>校验工程信息是否正确</li><li><strong>comple：</strong>编译工程</li><li><strong>test：</strong>执行工程测试流程(标注的test的程序)</li><li><strong>package：</strong>打包工程</li><li><strong>verify：</strong>验证包的有效性</li><li><strong>install：</strong>安装包到本地仓库</li><li><strong>deploy：</strong>推送包到远程仓库</li></ul></blockquote><p>Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件</p><p>Maven 对项目构建的生命周期划分为3套：</p><ul><li><strong>clean ：</strong>项目清理的处理，移除所有上一次构建生成的文件。</li><li><strong>default(或 build)</strong> ：核心工作，例如编译，测试，打包，安装等。</li><li><strong>site</strong> ： 产生报告，发布站点等。这套生命周期一般不会使用。</li></ul><p><strong>Clean 生命周期</strong></p><p>执行 mvn post-clean 命令时，Maven 调用 clean 生命周期，它包含以下阶段：</p><ul><li>pre-clean：执行一些需要在clean之前完成的工作</li><li>clean：移除所有上一次构建生成的文件</li><li>post-clean：执行一些需要在clean之后立刻完成的工作</li></ul><p><strong>default生命周期</strong> </p><table><thead><tr><th align="left">阶段</th><th align="left">处理</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">验证 validate</td><td align="left">验证项目</td><td align="left">验证项目是否正确且所有必须信息是可用的</td></tr><tr><td align="left">编译 compile</td><td align="left">执行编译</td><td align="left">源代码编译在此阶段完成</td></tr><tr><td align="left">测试 Test</td><td align="left">测试</td><td align="left">使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td align="left">包装 package</td><td align="left">打包</td><td align="left">创建JAR/WAR包如在 pom.xml 中定义提及的包</td></tr><tr><td align="left">检查 verify</td><td align="left">检查</td><td align="left">对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td align="left">安装 install</td><td align="left">安装</td><td align="left">安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td align="left">部署 deploy</td><td align="left">部署</td><td align="left">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr></tbody></table><blockquote><p><strong>注意：</strong></p><ul><li><strong>打包前先clean是好习惯，能够保证上一次构建的输出不会影响到本次构建。</strong></li><li><strong>同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如执行安装会先执行打包。</strong></li></ul></blockquote><p><strong>site构建生命周期：</strong></p><ul><li>pre-site：执行一些需要在生成站点文档之前完成的工作</li><li>site：生成项目的站点文档</li><li>post-site： 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li><li>site-deploy：将生成的站点文档部署到特定的服务器上</li></ul><h2 id="pom文件配置编码及JDK版本"><a href="#pom文件配置编码及JDK版本" class="headerlink" title="pom文件配置编码及JDK版本"></a><strong>pom文件配置编码及JDK版本</strong></h2><p> 在pom.xml配置如下代码，适用于项目要在不同项目移动：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">maven.compiler.encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Maven依赖管理"><a href="#Maven依赖管理" class="headerlink" title="Maven依赖管理"></a>Maven依赖管理</h1><h2 id="依赖概述"><a href="#依赖概述" class="headerlink" title="依赖概述"></a>依赖概述</h2><p><strong>依赖</strong>指当前项目运行所需的jar，一个项目可以设置多个依赖。</p><p>groupId：依赖所属群组id。</p><p>artifactId：依赖所属项目id。</p><p>version：依赖版本号。</p><p>scope：依赖生效范围。</p><p>optional：为true时是可选依赖，指对外隐藏当前所依赖的资源——不透明。设置后其他依赖引用本项目时候将无法看到这个依赖。控制别人能不能看到你用到你。</p><p>exclusions-exclusion：排除依赖指主动断开依赖的资源，被排除的资源无需指定版本。控制你引用的项目中需要排除的依赖。</p><p><strong>依赖范围scope</strong></p><p>依赖的jar默认在任何地方使用，通过scope便签设定其范围。</p><p>通过设置坐标的依赖范围(scope)，可以设置对应jar包的作用范围：编译环境、测试环境、运行环境。</p><p>如下图所示给 <code>junit</code> 依赖通过 <code>scope</code> 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>依赖范围scope可取值：</strong></p><table><thead><tr><th align="left"><strong>依赖范围</strong></th><th align="left">编译classpath</th><th align="left">测试classpath</th><th align="left">运行classpath</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left"><strong>compile</strong></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">logback</td></tr><tr><td align="left"><strong>test</strong></td><td align="left">-</td><td align="left">Y</td><td align="left">-</td><td align="left">Junit</td></tr><tr><td align="left"><strong>provided</strong></td><td align="left">Y</td><td align="left">Y</td><td align="left">-</td><td align="left">servlet-api</td></tr><tr><td align="left"><strong>runtime</strong></td><td align="left">-</td><td align="left">Y</td><td align="left">Y</td><td align="left">jdbc驱动</td></tr><tr><td align="left"><strong>system</strong></td><td align="left">Y</td><td align="left">Y</td><td align="left">-</td><td align="left">存储在本地的jar包</td></tr></tbody></table><p>配置后可以在依赖中看到：org.mybatis:mybatis:3.5.3 (runtime)</p><p><strong>依赖具有传递性</strong></p><p><strong>直接依赖</strong>：在当前项目中通过依赖配置建立的依赖关系</p><p><strong>间接依赖</strong>：被资源的资源如果依赖其他资源，当前项目间接依赖其他资源</p><p><strong>依赖传递冲突问题</strong></p><p><strong>路径优先：</strong>当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高</p><p><strong>声明优先：</strong>当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的</p><p><strong>特殊优先：</strong>当同级配置了相同资源的不同版本，<strong>后配置的覆盖先配置的</strong></p><p><strong>可选依赖</strong>optional</p><p>可选依赖指对外隐藏当前所依赖的资源——不透明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>排除依赖</strong>exclusions-exclusion</p><p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exClusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="依赖jar包引用，设置自动刷新"><a href="#依赖jar包引用，设置自动刷新" class="headerlink" title="依赖jar包引用，设置自动刷新"></a>依赖jar包引用，设置自动刷新</h2><p>使用坐标引入依赖的jar包</p><ol><li><p>在项目的 pom.xml 中编写 <code>&lt;dependencies&gt;</code> 标签</p></li><li><p>在 <code>&lt;dependencies&gt;</code> 标签中 使用 <code>&lt;dependency&gt;</code> 引入坐标</p></li><li><p>定义坐标的 groupId，artifactId，version</p></li></ol><blockquote><p><strong>groupId：</strong>定义当前<a href="https://so.csdn.net/so/search?q=Maven&spm=1001.2101.3001.7020">Maven</a>项目隶属的实际项目。</p><p>例如org.sonatype.nexus，此id前半部分org.sonatype代表此项目隶属的组织或公司，后部分代表项目的名称。</p><p>如果此项目多模块话开发的话就子模块可以分为org.sonatype.nexus.plugins和org.sonatype.nexus.utils等。特别注意的是groupId不应该对应项目隶属的组织或公司，也就是说groupId不能只有org.sonatype而没有nexus。</p><p><strong>artifactId：</strong>构件ID。该元素定义实际项目中的一个Maven项目或者是子模块，如上面官方约定中所说，<strong>构建名称必须小写字母，没有其他的特殊字符</strong>，推荐使用“<strong>实际项目名称－模块名称</strong>”的方式定义，例如：spirng-mvn、spring-core等。</p></blockquote><p><strong>快捷方式引入jar包</strong></p><ol><li>在 pom.xml 中 按 alt + insert，选择 Dependency</li><li>在弹出的面板中搜索对应坐标，然后双击选中对应坐标</li><li>点击刷新按钮，使坐标生效</li></ol><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能。</li><li>默认maven在各个生命周期上绑定有预设的功能。</li><li>通过插件可以自定义其他功能。</li></ul><p><strong>示例：Tomcat部署的插件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Maven项目&lt;a href=&quot;https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/1772960?fromModule=lemma_inlink&quot;&gt;对象模型&lt;/a&gt;(POM)，可以通过一小段描</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="maven" scheme="https://southernfish.github.io/tags/maven/"/>
    
  </entry>
  
</feed>
