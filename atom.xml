<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Southern Fish</title>
  
  
  <link href="https://southernfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://southernfish.github.io/"/>
  <updated>2025-07-23T14:14:12.453Z</updated>
  <id>https://southernfish.github.io/</id>
  
  <author>
    <name>Southern Fish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>反射</title>
    <link href="https://southernfish.github.io/2025/07/24/java/java-base-10-reflection/"/>
    <id>https://southernfish.github.io/2025/07/24/java/java-base-10-reflection/</id>
    <published>2025-07-24T04:08:36.000Z</published>
    <updated>2025-07-23T14:14:12.453Z</updated>
    
    <content type="html"><![CDATA[<p>反射机制主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用，并在Lisp和<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089?fromModule=lemma_inlink">面向对象</a>方面取得了成绩。其中LEAD/LEAD++ 、OpenC++ 、<a href="https://baike.baidu.com/item/MetaXa/7854221?fromModule=lemma_inlink">MetaXa</a>和OpenJava等就是基于反射机制的语言。适用于计算机科学领域关于应用反射性的研究。本文简单整理了一些关于反射的相关问题。</p><p>原文链接：<a href="https://blog.csdn.net/qq_40991313/article/details/140324927">https://blog.csdn.net/qq_40991313/article/details/140324927</a></p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p><strong>反射：</strong>在程序运行期间<strong>动态地获取类的信息并对类进行操作</strong>的机制。在运行状态中，<em>对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性</em>。</p><p><strong>通过反射机制可以实现：</strong></p><ul><li><p><strong>获取类或对象的Class对象：</strong>程序运行时，可以通过反射获得任意一个类的Class对象，并通过这个对象查看这个类的所有方法和属性（包括私有，私有需要给该字段调用<code>setAccessible(true)</code>方法开启私有权限）。注意类的class对象是运行时生成的，类的class字节码文件是编译时生成的。</p></li><li><p><strong>创建实例：</strong>程序运行时，可以利用反射先创建类的Class对象再创建该类的实例，并访问该实例的成员；Xxx.class.newInstance() ;例如在Spring容器类源码里，Bean实例化就是通过Bean类的Class对象。Bean类的Class对象是从BeanDefinition对象的type成员变量取的。BeanDefinition对象存储一些Bean的类型、名称、作用域等声明信息。</p></li><li><p><strong>生成动态代理类或对象：</strong>程序运行时,可以通过反射机制生成一个类的动态代理类或动态代理对象。例如JDK中Proxy类的newProxyInstance静态方法，可以通过它创建基于接口的动态代理对象。</p></li></ul><blockquote><p><strong>类的字节码文件和Class对象的区别：</strong></p><ul><li>类的class字节码文件是编译时生成的，类的class对象是运行时生成的。</li><li>类的字节码文件是存储在电脑硬盘中的文件，如Test.class；类的Class对象是存放在内存中的数据，可快速获取其中的信息；</li><li>两者都存储类的各种信息；</li></ul></blockquote><p><strong>获取类Class对象的JVM底层：</strong>如果该类没有被加载过，会首先通过JVM实现类的加载过程，即加载、链接（验证、准备、解析）、初始化，加载阶段会生成类的Class对象。</p><p><strong>获取类Class对象的方法：</strong><code>dog.getClass();</code>，<code>Dog.class;</code>，<code>Class.forName(&quot;package1.Dog&quot;);</code></p><p><strong>特点：</strong></p><ul><li><strong>访问私有成员：</strong>构造方法、成员变量、方法对象取消访问检查可以访问私有成员；public void setAccessible(boolean flag):值为true，取消访问检查</li><li><strong>越过泛型检查：</strong>反射可以越过泛型检查，例如在ArrayList<Integer>中添加字符串</li></ul><p><strong>反射的优缺点：</strong></p><ul><li><strong>优点</strong>：<ul><li><strong>运行时获取属性：</strong>运行期间能够动态的获取类，提高代码的灵活性。</li><li><strong>访问私有成员：</strong>构造方法、成员变量、方法对象取消访问检查可以访问私有成员；public void setAccessible(boolean flag):值为true，取消访问检查</li><li><strong>越过泛型检查：</strong>反射可以越过泛型检查，例如在ArrayList<Integer>中添加字符串</li></ul></li><li><strong>缺点：性能差。</strong>性能比直接的Java代码要差很多。 </li></ul><p><strong>应用场景：</strong></p><ul><li><strong>JDBC加载数据库的驱动：</strong>使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；</li><li><strong>Bean的生命周期：</strong><ul><li><strong>实例化xml解析出的类：</strong>多数框架都支持注解或XML配置来定义应用程序中的类，从xml配置中解析出来的类是字符串，需要利用反射机制实例化；如Spring通过<code>&lt;bean id=&quot;xx&quot; class=&quot;类全限定名&quot;&gt;</code>和<code>&lt;property name=&quot;按名称注入&quot; ref=&quot;被注入Bean的id&quot;&gt;</code>定义bean，然后通过<code>Class.forName(&quot;xxx.Xxx&quot;)</code>获取类的class对象，然后创建实例。</li><li><strong>注解容器类加载Bean、实例化Bean：</strong>Bean的生命周期中，注解容器类的构造方法会遍历<code>@ComponentScan(&quot;扫描路径&quot;)</code>下的.class文件，通过<code>类加载器.load(&quot;类名&quot;)</code>方式获得类的class对象，存入beanDefinitionMap。然后遍历beanDefinitionMap，通过class对象实例化等。</li></ul></li><li><strong>AOP创建动态代理对象：</strong>面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理对象，这必须由反射机制来实现。</li></ul><p><strong>验证反射可以绕过泛型检查：</strong></p><p>基于反射，我们可以给<code>ArrayList&lt;Integer&gt;</code>对象中，加入字符串 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, </span><br><span class="line">                                                InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&gt; aClass = integers.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">        add.invoke(integers, <span class="number">1</span>);</span><br><span class="line">        add.invoke(integers, <span class="number">2</span>);</span><br><span class="line">        add.invoke(integers, <span class="number">3</span>);</span><br><span class="line">        add.invoke(integers, <span class="number">4</span>);</span><br><span class="line">        add.invoke(integers, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(integers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1,2,3,4,hello]</span></span><br></pre></td></tr></table></figure><hr><h1 id="反射获取Class对象"><a href="#反射获取Class对象" class="headerlink" title="反射获取Class对象"></a>反射获取Class对象</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>Class类的对象：</strong>程序运行时,可以通过反射获得任意一个类的Class对象,并通过这个对象查看这个类的所有方法和属性（包括私有，私有需要给该字段调用setAccessible(true)方法开启私有权限）。</p><p>注意类的class对象是运行时生成的，类的class字节码文件是编译时生成的。</p><p><strong>获取类Class对象：</strong></p><ul><li><strong>对象.getClass()：</strong>Object是一切类的根类，Object类有个getClass()方法可以获取类的Class对象。例如dog.getClass();</li><li><strong>类名.class（推荐）：</strong>例如Dog.class;</li><li><strong>Class.forName(“类名”)：</strong>例如Class.forName(“package1.Dog”);</li></ul><p><strong>Class对象的常用方法：</strong></p><ul><li><strong>获取类的信息</strong>：<ul><li><strong>String getName()：</strong>返回类的全限定名。<strong>全限定名</strong>包含包名和类名，用于唯一标识类或接口。例如package1.Dog、java.lang.String、java.util.Map$Entry</li><li><strong>String getSimpleName()：</strong>返回类的简单名。例如Dog</li><li><strong>tring getCanonicalName()：</strong>返回类的规范名。<strong>规范名</strong>是类的规范字符串形式，常用于打印和日志记录。例如package1.Dog、java.lang.String、java.util.Map.Entry</li><li><strong>Package getPackage()：</strong>返回此类所属的包。</li><li>ClassLoader getClassLoader()：返回该类的类加载器。</li><li>Class&lt;? super T&gt; getSuperclass()：返回表示类的超类的 Class 对象。</li><li>Class&lt;?&gt;[] getInterfaces()：返回类实现的所有接口。</li><li><strong>boolean isInterface()：</strong>判断是否是接口。</li><li>boolean isAnnotation()：判断是否是注解类型。</li><li>boolean isEnum()：判断是否是枚举类型。</li><li>Annotation[] getAnnotations()：返回此元素上存在的所有注解。</li><li>Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注解。</li><li>T getAnnotation(Class<T> annotationClass)：返回指定类型的注解，如果该注解存在于此元素上，否则返回 null。例如Spring源码中，ApplicaitonContext构造器判断一个类是不是Bean，是通过这个方法判断类有没有@Comonent等注解，从而判断它是不是Bean。</li></ul></li><li><strong>获取成员：</strong><ul><li><strong>Field[] getFields()：</strong>返回类的所有公共字段，包括从父类继承的字段。</li><li><strong>Field[] getDeclaredFields()：</strong>返回类声明的所有字段，不包括继承的字段。</li><li><strong>Method[] getMethods()：</strong>返回类的所有公共方法，包括从父类继承的方法。</li><li><strong>Method[] getDeclaredMethods()：</strong>返回类声明的所有方法，不包括继承的方法。</li><li><strong>Constructor&lt;?&gt;[] getConstructors()：</strong>返回类的所有公共构造方法。</li><li><strong>Constructor&lt;?&gt;[] getDeclaredConstructors()：</strong>返回类声明的所有构造方法。</li></ul></li><li><strong>其他方法</strong>：<ul><li><strong>T newInstance()：</strong>创建此 Class 对象所表示的类的一个新实例（使用默认构造方法）。</li></ul></li></ul><blockquote><p><strong>Spring源码：</strong>Bean初始化时判断类是否Bean、判断属性是否需要填充都用到了反射</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/137231482">Spring框架中Bean是如何加载的？从底层源码入手，详细解读Bean的创建流程-CSDN博客</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="comment">// 其他定义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取类的Class对象： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//方法1：类的class属性</span></span><br><span class="line">        Class&lt;Dog&gt; c1=Dog.class;</span><br><span class="line">        <span class="comment">//方法2：对象的getClass方法</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">wangCaiDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>, <span class="string">&quot;旺财&quot;</span>);</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; c2= wangCaiDog.getClass();</span><br><span class="line">        <span class="comment">//方法3：Class类的静态方法forName</span></span><br><span class="line">        Class&lt;?&gt; c3= Class.forName(<span class="string">&quot;package1.Dog&quot;</span>);</span><br><span class="line">        <span class="comment">// 方法4：使用类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        Class&lt;?&gt; c5 = systemClassLoader.loadClass(<span class="string">&quot;package1.Dog&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出：class package1.Dog</span></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        <span class="comment">//三种方式获取到Class对象地址是完全一致的</span></span><br><span class="line">        <span class="comment">// 输出：true</span></span><br><span class="line">        System.out.println(c1==c2&amp;&amp;c1==c3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取类的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exceptionn &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; dogClass = Dog.class;</span><br><span class="line">        System.out.println(dogClass.getName());</span><br><span class="line">        System.out.println(dogClass.getSimpleName());</span><br><span class="line">        System.out.println(dogClass.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全限定名和规范名"><a href="#全限定名和规范名" class="headerlink" title="全限定名和规范名"></a>全限定名和规范名</h2><p><strong>全限定名和规范名：</strong></p><p>外部类的全限定名和规范名是一样的，都是“xxx.类名”。区别主要在内部类，内部类的全限定名是“xxx.外部类名$内部类名”，规范名是“xxx.外部类名.内部类名”。</p><ul><li><strong>简单名：</strong>只包含类名。例如Dog、String、Entry</li><li><strong>全限定名：</strong>包含包名和类名，用于唯一标识类或接口，通过全限定名能找到唯一一个类。例如package1.Dog、java.lang.String、java.util.Map$Entry</li><li><strong>规范名：</strong>类的规范字符串形式，常用于打印和日志记录。例如package1.Dog、java.lang.String、java.util.Map.Entry</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// java.util.Map</span></span><br><span class="line">    System.out.println(Map.class.getName());</span><br><span class="line">    <span class="comment">// java.util.Map</span></span><br><span class="line">    System.out.println(Map.class.getCanonicalName());</span><br><span class="line">    <span class="comment">// 输出 &quot;java.util.Map$Entry&quot;</span></span><br><span class="line">    System.out.println(Map.Entry.class.getName());</span><br><span class="line">    <span class="comment">// 输出 &quot;java.util.Map.Entry&quot;</span></span><br><span class="line">    System.out.println(Map.Entry.class.getCanonicalName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="反射获取成员"><a href="#反射获取成员" class="headerlink" title="反射获取成员"></a>反射获取成员</h1><h2 id="反射获取构造方法"><a href="#反射获取构造方法" class="headerlink" title="反射获取构造方法"></a>反射获取构造方法</h2><p><strong>Class对象获取构造器：</strong></p><ul><li><strong>getConstructor(Class&lt;?&gt;… parameterTypes)：</strong>获取指定参数类型的公共构造方法。返回值是<strong>Constructor类</strong>。</li><li><strong>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)：</strong>获取指定参数类型的构造方法（包括私有构造方法）。</li><li><strong>getConstructors()：</strong>获取所有公共构造方法。</li><li><strong>getDeclaredConstructors()：</strong>获取所有构造方法（包括私有构造方法）。</li><li>**newInstance()**：创建类的新实例。<ul><li><strong>Class类的newInstance()：</strong>只能够调用无参构造函数；</li><li><strong>Constructor类的newInstance()：</strong>可以根据传入的参数，调用任意构造函数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有构造器对象：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;Dog&gt; dogClass = Dog.class;</span><br><span class="line">    Constructor&lt;?&gt;[] cons = dogClass.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor&lt;?&gt; con:cons)&#123;</span><br><span class="line">        System.out.println(con);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取单个构造器并实例化： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line">        Class&lt;Dog&gt; dogClass=Dog.class;</span><br><span class="line">        <span class="comment">//获取单个构造方法对象</span></span><br><span class="line">        Constructor&lt;?&gt; con=dogClass.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//构造方法对象实例化，会调用无参构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">dogObject</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line">        <span class="comment">// 无参构造器实例化，也可以直接用Class对象的newInstance方法，带参就不行了</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> dogClass.newInstance();</span><br><span class="line">        <span class="comment">//重写了Dog类的to_String，所以输出：Dog&#123;weight=0, name=&#x27;null&#x27;&#125;</span></span><br><span class="line">        System.out.println(dogObject);</span><br><span class="line">        System.out.println(dog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射获取字段"><a href="#反射获取字段" class="headerlink" title="反射获取字段"></a>反射获取字段</h2><p><strong>Class对象获取字段：</strong></p><ul><li>getField(String name)：返回指定名称的公共字段。返回类型是字段类Field。</li><li><strong>getDeclaredField(String name)：</strong>返回指定名称的字段<strong>（包括私有字段）</strong>。</li><li>getFields()：返回所有公共字段。</li><li><strong>getDeclaredFields()：</strong>返回所有字段<strong>（包括私有字段）</strong>。</li></ul><p><strong>字段类Field常用方法：</strong></p><p><strong>获取字段信息</strong>：</p><ul><li><strong>getName()：</strong>返回字段的名称。</li><li><strong>getType()：</strong>返回字段的类型。</li><li><strong>getModifiers()：</strong>返回字段的修饰符。</li><li><strong>getDeclaringClass()：</strong>返回声明该字段的类的 Class 对象。</li></ul><p><strong>获取和设置字段值</strong>：</p><ul><li><strong>get(Object obj)：</strong>返回指定对象上此字段的值。</li><li><strong>getBoolean(Object obj)：</strong>返回指定对象上此字段的值（如果字段类型是 boolean）。</li><li>getByte(Object obj)：返回指定对象上此字段的值（如果字段类型是 byte）。</li><li>getChar(Object obj)：返回指定对象上此字段的值（如果字段类型是 char）。</li><li>getDouble(Object obj)：返回指定对象上此字段的值（如果字段类型是 double）。</li><li>getFloat(Object obj)：返回指定对象上此字段的值（如果字段类型是 float）。</li><li>getInt(Object obj)：返回指定对象上此字段的值（如果字段类型是 int）。</li><li>getLong(Object obj)：返回指定对象上此字段的值（如果字段类型是 long）。</li><li>getShort(Object obj)：返回指定对象上此字段的值（如果字段类型是 short）。</li><li><strong>set(Object obj, Object value)：</strong>设置指定对象上此字段的值。注意私有字段默认不允许赋值，要赋值必须给私有字段setAccessible(true)。</li><li><strong>setBoolean(Object obj, boolean value)：</strong>设置指定对象上此字段的值（如果字段类型是 boolean）。</li><li>setByte(Object obj, byte value)：设置指定对象上此字段的值（如果字段类型是 byte）。</li><li>setChar(Object obj, char value)：设置指定对象上此字段的值（如果字段类型是 char）。</li><li>setDouble(Object obj, double value)：设置指定对象上此字段的值（如果字段类型是 double）。</li><li>setFloat(Object obj, float value)：设置指定对象上此字段的值（如果字段类型是 float）。</li><li>setInt(Object obj, int value)：设置指定对象上此字段的值（如果字段类型是 int）。</li><li>setLong(Object obj, long value)：设置指定对象上此字段的值（如果字段类型是 long）。</li><li>setShort(Object obj, short value)：设置指定对象上此字段的值（如果字段类型是 short）。</li></ul><p><strong>其他方法</strong>：</p><ul><li><strong>isAccessible()：</strong>返回字段是否可访问。</li><li><strong>setAccessible(boolean flag)：</strong>设置字段的可访问性。通过这个方法可以让私有字段也可以赋值。</li><li>oGenericString()：返回字段的描述，包括泛型信息。</li><li>getAnnotatedType()：返回此字段的带注释的类型。</li><li>getAnnotations()：返回字段的所有注解。</li><li><strong>getAnnotation(Class<T> annotationClass)：</strong>返回字段的指定类型的注解，如果该注解不存在，则返回 null。例如Spring源码中依赖注入这一块，就是基于反射获取类中字段有没有@Resource、@Component等注解，有的话就是要注入Bean.</li><li>getDeclaredAnnotations()：返回直接存在于此字段上的所有注解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员变量对象并赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 1.获取Class对象，并实例化</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; dogClass = Dog.class;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> dogClass.newInstance();</span><br><span class="line">        <span class="comment">// 2.获取字段对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> dogClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">weightField</span> <span class="operator">=</span> dogClass.getDeclaredField(<span class="string">&quot;weight&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.给字段对象赋值</span></span><br><span class="line">        nameField.set(dog, <span class="string">&quot;旺财&quot;</span>);</span><br><span class="line">        <span class="comment">// 注意私有字段默认不允许赋值，要赋值必须给私有字段设置可访问</span></span><br><span class="line">        weightField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        weightField.set(dog, <span class="number">10</span>);</span><br><span class="line">        System.out.println(dog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过Field获取的Class类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">        Class&lt;Dog&gt; dogClass=Dog.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">weightField</span> <span class="operator">=</span> dogClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; dogClassByField = weightField.getDeclaringClass();</span><br><span class="line">        <span class="comment">// 通过字段获取到的class对象和源class对象是地址是一样的，事实上一个类的所有Class对象都是一个实例</span></span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line">        System.out.println(dogClassByField==dogClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射获取普通方法"><a href="#反射获取普通方法" class="headerlink" title="反射获取普通方法"></a>反射获取普通方法</h2><p>Class对象获取成员方法的方法： </p><ul><li><p><strong>getMethod(String name, Class&lt;?&gt;… parameterTypes)：</strong>返回指定名称和参数类型的公共方法。返回值是<strong>方法类Method。</strong></p></li><li><p><strong>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)：</strong>返回指定名称和参数类型的方法（包括私有方法）。</p></li><li><p><strong>getMethods()：</strong>返回所有公共方法（包括从父类<strong>继承的方法</strong>）。</p></li><li><p><strong>getDeclaredMethods()：</strong>返回所有方法（包括<strong>私有方法</strong>）。</p></li><li><p><strong>Method类的方法：</strong></p><ul><li><strong>获取方法信息</strong>：<ul><li>getName()：返回方法的名称。</li><li>getReturnType()：返回方法的返回类型。</li><li>getParameterTypes()：返回方法参数类型的数组。</li><li>getModifiers()：返回方法的修饰符。</li><li>getDeclaringClass()：返回声明此方法的类的 Class 对象。</li></ul></li></ul></li><li><p><strong>调用方法</strong>：</p><ul><li><strong>Object invoke(Object obj, Object… args)：</strong>调用指定对象上此 Method 对象表示的基础方法。</li></ul></li><li><p><strong>其他方法</strong>：</p><ul><li><strong>isAccessible()：</strong>返回方法是否可访问。</li><li><strong>setAccessible(boolean flag)：</strong>设置方法的可访问性。</li><li><strong>getAnnotations()：</strong>返回此方法的所有注解。例如Spring源码中通过此方法判断一个类中</li><li>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)：判断此方法是否被指定的注解类型注释。</li><li>getAnnotation(Class<T> annotationClass)：返回该方法的指定类型的注解。</li><li>getExceptionTypes()：返回此方法抛出的异常类型的数组。</li><li>toGenericString()：返回方法的描述，包括泛型信息。</li></ul></li></ul><p><strong>获取成员变量对象并调用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取构造方法对象并实例化</span></span><br><span class="line">Class&lt;?&gt; c= Class.forName(<span class="string">&quot;train.Dog&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; con=c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"><span class="comment">// 2.获取成员方法对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line"><span class="comment">// 3.通过成员方法对象的invoke方法，调用构造方法对象的成员方法</span></span><br><span class="line"><span class="comment">// 无参无返回值方法</span></span><br><span class="line">eat.invoke(obj);</span><br><span class="line"><span class="comment">// 带参有返回值方法</span></span><br><span class="line">Object sucess= eat.invoke(obj,<span class="string">&quot;food&quot;</span>);</span><br><span class="line">System.out.println((<span class="type">boolean</span>)sucess);</span><br></pre></td></tr></table></figure><hr><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><h2 id="什么是-Java-序列化？什么情况下需要序列化？"><a href="#什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="什么是 Java 序列化？什么情况下需要序列化？"></a>什么是 Java 序列化？什么情况下需要序列化？</h2><p>Java 序列化是<strong>为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来</strong>。<br>以下情况需要使用 Java 序列化：</p><ul><li>想把内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>想用套接字在网络上传送对象的时候；</li><li>想通过RMI（远程方法调用）传输对象的时候。</li></ul><h2 id="动态代理是什么？有哪些应用？实现原理？"><a href="#动态代理是什么？有哪些应用？实现原理？" class="headerlink" title="动态代理是什么？有哪些应用？实现原理？"></a><strong>动态代理是什么？有哪些应用？实现原理？</strong></h2><p><strong>动态代理：</strong>运行时动态创建代理对象的技术，通过反射机制生成代理类，无需手动编写代理代码即可实现对目标对象的间接访问和控制。</p><p><strong>动态代理应用：</strong>实现<em>AOP、日志记录、权限校验、hibernate 数据查询、测试框架的后端 mock、rpc</em>等功能</p><p><strong>实现原理：</strong>包括<strong>JDK动态代理（基于接口）和CGLIB动态代理（基于类继承）</strong>。</p>]]></content>
    
    
    <summary type="html">Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>锁</title>
    <link href="https://southernfish.github.io/2025/07/24/java/java-base-9-lock/"/>
    <id>https://southernfish.github.io/2025/07/24/java/java-base-9-lock/</id>
    <published>2025-07-24T02:28:36.000Z</published>
    <updated>2025-07-23T14:14:03.966Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 多线程环境中，锁是<strong>确保共享资源线程安全</strong>的重要手段。</p><p>参考文章：<a href="https://blog.csdn.net/qq_45675973/article/details/147740830">Java锁详解</a>、参考链接：<a href="https://blog.csdn.net/qq_40991313/article/details/140324927">https://blog.csdn.net/qq_40991313/article/details/140324927</a></p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><h2 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h2><p>在 Java 多线程环境中，锁是<strong>确保共享资源线程安全</strong>的重要手段。 当线程要操作共享资源时，需先获取对应的锁，以此保证在操作过程中，该资源不会被其他线程访问。待操作结束后，线程释放锁，使其他线程有机会获取并操作该资源。 </p><h2 id="为什么需要锁"><a href="#为什么需要锁" class="headerlink" title="为什么需要锁"></a>为什么需要锁</h2><p>锁可以确保多个线程之间对共享资源的访问是互斥的，也就是同一时刻只有一个线程能够访问被保护的共享资源，从而避免并发访问带来的数据不一致性和竞态条件等问题，是解决线程安全问题常用手段之一。</p><h2 id="什么是死锁及如何防止死锁"><a href="#什么是死锁及如何防止死锁" class="headerlink" title="什么是死锁及如何防止死锁"></a>什么是死锁及如何防止死锁</h2><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。防止死锁有如下方式：</p><ul><li>尽量使用 <code>tryLock(long timeout, TimeUnit unit)</code> 的方法 (ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li><li>尽量<strong>使用 Java. util. concurrent 并发类</strong>代替自己手写锁。</li><li>尽量<strong>降低锁的使用粒度</strong>，尽量不要几个功能用同一把锁。</li><li>尽量<strong>减少同步的代码块</strong>。</li></ul><h1 id="Synchronized锁"><a href="#Synchronized锁" class="headerlink" title="Synchronized锁"></a>Synchronized锁</h1><p>synchronized 由<strong>一对 monitorenter/monitorexit 指令实现，monitor 对象是同步的基本实现单元</strong>。<br>在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的<strong>互斥锁</strong>，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。可以作用于实例方法、静态方法、代码块，能够保证同一个时刻只有一个线程执行该段代码，保证线程安全。 在执行完或者出现异常时自动释放锁。synchronized锁基于对象头、CAS、Monitor对象，<br>在 Java 6 的时候，Java 虚拟机提供了三种 monitor 实现：<strong>偏向锁（Biased Locking）、轻量级锁和重量级锁</strong>，改进了性能。</p><p><strong>作用于三个位置：</strong></p><ol><li><p>作用在静态方法上,则锁是当前类的Class对象。</p></li><li><p>作用在普通方法上,则锁是当前的实例（this）。</p></li><li><p>作用在代码块上,则需要在关键字后面的小括号里,显式指定锁对象，例如this、Xxx.class。</p></li></ol><p><strong>对象头存储锁信息：</strong> synchronized的底层是采用对象头的Mark Word来存储锁信息的。Hotspot 虚拟机（JVM默认虚拟机）中每个对象都有一个对象头(Object Header)，包含Mark Word（标记字段） 和 Class Pointer（类型指针）。</p><ul><li><p><strong>Mark Word（标记字段）：</strong>存储哈希码、GC分代年龄、锁信息、GC标记（标志位，标记可达对象或垃圾对象）等。<strong>锁信息包括：</strong></p><ul><li><p><strong>锁标志位：</strong>64位的二进制数，通过末尾能判断锁状态。01未锁定、01可偏向、00轻量级锁、10重量级锁、11垃圾回收标记</p></li><li><p><strong>偏向锁线程ID、时间戳等；</strong></p></li><li><p><strong>轻量级锁的指针：</strong>指向锁记录的指针</p></li><li><p><strong>重量级锁的指针：</strong>指向Monitor锁的指针</p></li></ul></li><li><p><strong>类型指针：</strong>指向它的类元数据的指针，用于找到对象所在的类</p></li></ul><p>不考虑共享资源是类变量等特殊情况的话，有共享资源的多个线程通常都属于同一个对象。</p><p><strong>Monitor对象：</strong>每个 Java 对象都可以关联一个 Monitor 对象，也称为监视器锁或Monitor锁。Monitor锁用于控制线程对共享资源的访问，开发人员不能直接访问Monitor对象。当一个线程获取了Monitor的锁后，其他试图获取该锁的线程就会被阻塞，直到当前线程释放锁为止。</p><p>当一个线程执行synchronized方法或代码块并升级成<strong>重量级锁</strong>时，当前对象会关联一个Monitor对象，线程须获得该对象的Monitor锁才能执行。Monitor有<code>Owner、EntryList、WaitSet</code>三个字段，分别表示Monitor的<strong>持有者线程(获得锁的线程)、阻塞队列、和等待队列</strong>。</p><p><strong>线程通信：</strong>synchronized通过Monitor对象，利用Object的wait，notify，notifyAll等方法来实现线程通信。</p><p><strong>锁升级：</strong>JDK6之前synchronized只有无锁和重量级锁两个状态，JDK6引入偏向锁、轻量级锁两个状态，锁可以根据竞争程度从无锁状态慢慢升级到重量级锁。当竞争小的时候，只需以较小的代价加锁，直到竞争加剧，才使用重量级锁，从而减小了加锁带来的开销。</p><ul><li><strong>锁升级顺序：</strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</li><li><strong>无锁：</strong>没有线程访问同步代码块时。没有对资源进行锁定，所有的线程都能访问并不断修改同一个资源，但同时只有一个线程能修改成功，失败线程会不断重试。</li><li><strong>偏向锁：</strong>当有一个线程访问同步代码块时升级为偏向锁。一段同步代码块一直被一个线程所访问，那么该线程id会CAS写入对象头，下次再访问同步代码块时对象头检查到该线程id，就不用加锁解锁了，降低获取锁的代价。</li><li><strong>轻量级锁（自旋锁）：</strong>有锁竞争时升级为轻量级锁。其他线程会通过自旋的形式尝试通过CAS将对象头中Mark Word替换为指向线程栈帧里锁记录的指针，从而获得锁；同时线程锁记录里存放Mark Word信息。竞争的线程不会阻塞但会一直自旋，消耗CPU性能，但速度快。</li><li><strong>重量级锁：</strong>锁膨胀（自旋失败10次）时升级为重量级锁。Mark Word中存储的是指向Monitor锁的指针，对象Mark Word信息也会保存在Monitor锁里，当一个线程获取了Monitor锁后，竞争线程会被阻塞，不再自旋，不消耗CPU，速度慢。</li></ul><h2 id="多线程中-synchronized-锁升级的原理"><a href="#多线程中-synchronized-锁升级的原理" class="headerlink" title="多线程中 synchronized 锁升级的原理"></a>多线程中 synchronized 锁升级的原理</h2><p><strong>synchronized 锁升级原理：</strong>在锁对象的对象头里面有一个 <strong>threadid</strong> 字段，在第一次访问的时候 <strong>threadid 为空，jvm 让其持有偏向锁</strong>，并将 threadid 设置为其线程 id，再次进入的时候会先<strong>判断 threadid 是否与其线程 id 一致</strong>，如果一致则可以直接使用此对象，如果<strong>不一致，则升级偏向锁为轻量级锁</strong>，通过<strong>自旋循环</strong>一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁<strong>从轻量级升级为重量级锁</strong>，此过程就构成了 synchronized 锁的升级。<br><strong>锁的升级的目的：</strong>锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h2 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a>synchronized 和 volatile 的区别</h2><p>volatile 是<strong>变量修饰符</strong>；synchronized 是<strong>修饰类、方法、代码段</strong>。<br>volatile 仅能实现<strong>变量的修改可见性但不能保证原子性</strong>；而 synchronized 则可以<strong>保证变量的修改可见性和原子性</strong>。<br>volatile 不会造成线程的阻塞；synchronized 可能<strong>会造成线程的阻塞</strong>。</p><h2 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h2><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但在 Java 6 中对 synchronized 进行了非常多的改进。主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰类、方法、代码块等。</li></ul><h2 id="atomic-的原理"><a href="#atomic-的原理" class="headerlink" title="atomic 的原理"></a>atomic 的原理</h2><p>atomic 主要利用 CAS (Compare And Wap) 、 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><hr><h1 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h1><p>Lock提供比同步方法和代码块更广泛的锁定操作。</p><ul><li><strong>lock()：</strong>获取锁。如果锁不可用，则当前线程将被禁用，直到获取锁为止。</li><li><strong>tryLock()：</strong>尝试获取锁，如果锁可用，则获取并立即返回 true；如果锁不可用，则立即返回 false，不会等待。</li><li><strong>tryLock(long time, TimeUnit unit)：</strong>尝试在指定的时间内获取锁。如果锁可用，则获取并立即返回 true；如果在指定时间内锁不可用，则等待直到超时，然后返回 false。</li><li><strong>unlock()：</strong>释放锁。</li><li><strong>newCondition()：</strong>返回一个绑定到此 Lock 实例的新 Condition 实例，可以用于线程之间的协调等待。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTicket</span> <span class="variable">sellTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized-和-Lock-的区别"><a href="#synchronized-和-Lock-的区别" class="headerlink" title="synchronized 和 Lock 的区别"></a>synchronized 和 Lock 的区别</h2><p>Lock和synchronized有以下几点不同：</p><ul><li><strong>作用范围</strong>。synchronized 可以给类、方法、代码块加锁；而 <strong>lock 只能给代码块加锁</strong>。</li><li><strong>接口和关键字。</strong>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现。</li><li><strong>死锁问题。</strong>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁。</li><li><strong>让等待锁的线程响应中断。</strong>Lock可以可以通过lockInterruptibly()获取锁的方法让等待锁的线程响应中断。而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。</li><li><strong>得知是否成功获取锁。</strong>通过Lock可以通过tryLock()知道有没有成功获取锁，而synchronized却无法办到。</li><li><strong>性能对比。</strong>两者性能差不多。JDK6之前synchronized没有锁升级，线程竞争非常激烈时Lock的性能要远远优于synchronized；而JDK6引入锁升级后，线程竞争激烈时候两者性能也相差无几。</li></ul><p><strong>lock锁中断线程：</strong>若有线程已拿到锁，其他线程使用lock()获取锁时会阻塞，使用<code>lockInterruptibly()</code>获取锁时会直接中断抛出<code>InterruptedException</code>异常。</p><p><strong>lock锁编码习惯：</strong>加锁代码要放到try外面。如果放在try里面的话，加锁失败抛异常或者加锁前的代码抛异常后，执行finally里的解锁代码，而其实加锁都没成功，最终解锁就也不合适了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();         <span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>/<span class="number">0</span>;            <span class="comment">// 这里抛异常会直接进入finally</span></span><br><span class="line">lock.lock();         <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分布式锁：</strong>SETNX、Redisson。Redisson基于Redis协议，可以实现可重入锁、公平锁、读写锁、信号量、闭锁（计数器），支持看门狗自动续期。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>反射：</strong>在程序运行期间<strong>动态地获取类的信息并对类进行操作</strong>的机制。</p><p><strong>通过反射机制可以实现：</strong></p><ul><li><p><strong>获取类或对象的Class对象：</strong>程序运行时，可以通过反射获得任意一个类的Class对象，并通过这个对象查看这个类的所有方法和属性（包括私有，私有需要给该字段调用<code>setAccessible(true)</code>方法开启私有权限）。注意类的class对象是运行时生成的，类的class字节码文件是编译时生成的。</p></li><li><p><strong>创建实例：</strong>程序运行时，可以利用反射先创建类的Class对象再创建该类的实例，并访问该实例的成员；Xxx.class.newInstance() ;例如在Spring容器类源码里，Bean实例化就是通过Bean类的Class对象。Bean类的Class对象是从BeanDefinition对象的type成员变量取的。BeanDefinition对象存储一些Bean的类型、名称、作用域等声明信息。</p></li><li><p><strong>生成动态代理类或对象：</strong>程序运行时,可以通过反射机制生成一个类的动态代理类或动态代理对象。例如JDK中Proxy类的newProxyInstance静态方法，可以通过它创建基于接口的动态代理对象。</p></li></ul><blockquote><p><strong>类的字节码文件和Class对象的区别：</strong></p><ul><li>类的class字节码文件是编译时生成的，类的class对象是运行时生成的。</li><li>类的字节码文件是存储在电脑硬盘中的文件，如Test.class；类的Class对象是存放在内存中的数据，可快速获取其中的信息；</li><li>两者都存储类的各种信息；</li></ul></blockquote><p><strong>获取类Class对象的JVM底层：</strong>如果该类没有被加载过，会首先通过JVM实现类的加载过程，即加载、链接（验证、准备、解析）、初始化，加载阶段会生成类的Class对象。</p><p><strong>获取类Class对象的方法：</strong><code>dog.getClass();</code>，<code>Dog.class;</code>，<code>Class.forName(&quot;package1.Dog&quot;);</code></p><p><strong>特点：</strong></p><ul><li><strong>访问私有成员：</strong>构造方法、成员变量、方法对象取消访问检查可以访问私有成员；public void setAccessible(boolean flag):值为true，取消访问检查</li><li><strong>越过泛型检查：</strong>反射可以越过泛型检查，例如在ArrayList<Integer>中添加字符串</li></ul><p><strong>反射的优缺点：</strong></p><ul><li><strong>优点</strong>：<ul><li><strong>运行时获取属性：</strong>运行期间能够动态的获取类，提高代码的灵活性。</li><li><strong>访问私有成员：</strong>构造方法、成员变量、方法对象取消访问检查可以访问私有成员；public void setAccessible(boolean flag):值为true，取消访问检查</li><li><strong>越过泛型检查：</strong>反射可以越过泛型检查，例如在ArrayList<Integer>中添加字符串</li></ul></li><li><strong>缺点：性能差。</strong>性能比直接的Java代码要差很多。 </li></ul><p><strong>应用场景：</strong></p><ul><li><strong>JDBC加载数据库的驱动：</strong>使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；</li><li><strong>Bean的生命周期：</strong><ul><li><strong>实例化xml解析出的类：</strong>多数框架都支持注解或XML配置来定义应用程序中的类，从xml配置中解析出来的类是字符串，需要利用反射机制实例化；如Spring通过<code>&lt;bean id=&quot;xx&quot; class=&quot;类全限定名&quot;&gt;</code>和<code>&lt;property name=&quot;按名称注入&quot; ref=&quot;被注入Bean的id&quot;&gt;</code>定义bean，然后通过<code>Class.forName(&quot;xxx.Xxx&quot;)</code>获取类的class对象，然后创建实例。</li><li><strong>注解容器类加载Bean、实例化Bean：</strong>Bean的生命周期中，注解容器类的构造方法会遍历<code>@ComponentScan(&quot;扫描路径&quot;)</code>下的.class文件，通过<code>类加载器.load(&quot;类名&quot;)</code>方式获得类的class对象，存入beanDefinitionMap。然后遍历beanDefinitionMap，通过class对象实例化等。</li></ul></li><li><strong>AOP创建动态代理对象：</strong>面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理对象，这必须由反射机制来实现。</li></ul><p><strong>验证反射可以绕过泛型检查：</strong></p><p>基于反射，我们可以给<code>ArrayList&lt;Integer&gt;</code>对象中，加入字符串 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, </span><br><span class="line">                                                InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&gt; aClass = integers.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">        add.invoke(integers, <span class="number">1</span>);</span><br><span class="line">        add.invoke(integers, <span class="number">2</span>);</span><br><span class="line">        add.invoke(integers, <span class="number">3</span>);</span><br><span class="line">        add.invoke(integers, <span class="number">4</span>);</span><br><span class="line">        add.invoke(integers, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(integers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1,2,3,4,hello]</span></span><br></pre></td></tr></table></figure><h2 id="反射获取Class对象"><a href="#反射获取Class对象" class="headerlink" title="反射获取Class对象"></a>反射获取Class对象</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>Class类的对象：</strong>程序运行时,可以通过反射获得任意一个类的Class对象,并通过这个对象查看这个类的所有方法和属性（包括私有，私有需要给该字段调用setAccessible(true)方法开启私有权限）。</p><p>注意类的class对象是运行时生成的，类的class字节码文件是编译时生成的。</p><p><strong>获取类Class对象：</strong></p><ul><li><strong>对象.getClass()：</strong>Object是一切类的根类，Object类有个getClass()方法可以获取类的Class对象。例如dog.getClass();</li><li><strong>类名.class（推荐）：</strong>例如Dog.class;</li><li><strong>Class.forName(“类名”)：</strong>例如Class.forName(“package1.Dog”);</li></ul><p><strong>Class对象的常用方法：</strong></p><ul><li><strong>获取类的信息</strong>：<ul><li><strong>String getName()：</strong>返回类的全限定名。<strong>全限定名</strong>包含包名和类名，用于唯一标识类或接口。例如package1.Dog、java.lang.String、java.util.Map$Entry</li><li><strong>String getSimpleName()：</strong>返回类的简单名。例如Dog</li><li><strong>tring getCanonicalName()：</strong>返回类的规范名。<strong>规范名</strong>是类的规范字符串形式，常用于打印和日志记录。例如package1.Dog、java.lang.String、java.util.Map.Entry</li><li><strong>Package getPackage()：</strong>返回此类所属的包。</li><li>ClassLoader getClassLoader()：返回该类的类加载器。</li><li>Class&lt;? super T&gt; getSuperclass()：返回表示类的超类的 Class 对象。</li><li>Class&lt;?&gt;[] getInterfaces()：返回类实现的所有接口。</li><li><strong>boolean isInterface()：</strong>判断是否是接口。</li><li>boolean isAnnotation()：判断是否是注解类型。</li><li>boolean isEnum()：判断是否是枚举类型。</li><li>Annotation[] getAnnotations()：返回此元素上存在的所有注解。</li><li>Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注解。</li><li>T getAnnotation(Class<T> annotationClass)：返回指定类型的注解，如果该注解存在于此元素上，否则返回 null。例如Spring源码中，ApplicaitonContext构造器判断一个类是不是Bean，是通过这个方法判断类有没有@Comonent等注解，从而判断它是不是Bean。</li></ul></li><li><strong>获取成员：</strong><ul><li><strong>Field[] getFields()：</strong>返回类的所有公共字段，包括从父类继承的字段。</li><li><strong>Field[] getDeclaredFields()：</strong>返回类声明的所有字段，不包括继承的字段。</li><li><strong>Method[] getMethods()：</strong>返回类的所有公共方法，包括从父类继承的方法。</li><li><strong>Method[] getDeclaredMethods()：</strong>返回类声明的所有方法，不包括继承的方法。</li><li><strong>Constructor&lt;?&gt;[] getConstructors()：</strong>返回类的所有公共构造方法。</li><li><strong>Constructor&lt;?&gt;[] getDeclaredConstructors()：</strong>返回类声明的所有构造方法。</li></ul></li><li><strong>其他方法</strong>：<ul><li><strong>T newInstance()：</strong>创建此 Class 对象所表示的类的一个新实例（使用默认构造方法）。</li></ul></li></ul><blockquote><p><strong>Spring源码：</strong>Bean初始化时判断类是否Bean、判断属性是否需要填充都用到了反射</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/137231482">Spring框架中Bean是如何加载的？从底层源码入手，详细解读Bean的创建流程-CSDN博客</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="comment">// 其他定义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取类的Class对象： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//方法1：类的class属性</span></span><br><span class="line">        Class&lt;Dog&gt; c1=Dog.class;</span><br><span class="line">        <span class="comment">//方法2：对象的getClass方法</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">wangCaiDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>, <span class="string">&quot;旺财&quot;</span>);</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; c2= wangCaiDog.getClass();</span><br><span class="line">        <span class="comment">//方法3：Class类的静态方法forName</span></span><br><span class="line">        Class&lt;?&gt; c3= Class.forName(<span class="string">&quot;package1.Dog&quot;</span>);</span><br><span class="line">        <span class="comment">// 方法4：使用类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        Class&lt;?&gt; c5 = systemClassLoader.loadClass(<span class="string">&quot;package1.Dog&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出：class package1.Dog</span></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        <span class="comment">//三种方式获取到Class对象地址是完全一致的</span></span><br><span class="line">        <span class="comment">// 输出：true</span></span><br><span class="line">        System.out.println(c1==c2&amp;&amp;c1==c3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取类的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exceptionn &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; dogClass = Dog.class;</span><br><span class="line">        System.out.println(dogClass.getName());</span><br><span class="line">        System.out.println(dogClass.getSimpleName());</span><br><span class="line">        System.out.println(dogClass.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全限定名和规范名"><a href="#全限定名和规范名" class="headerlink" title="全限定名和规范名"></a>全限定名和规范名</h3><p><strong>全限定名和规范名：</strong></p><p>外部类的全限定名和规范名是一样的，都是“xxx.类名”。区别主要在内部类，内部类的全限定名是“xxx.外部类名$内部类名”，规范名是“xxx.外部类名.内部类名”。</p><ul><li><strong>简单名：</strong>只包含类名。例如Dog、String、Entry</li><li><strong>全限定名：</strong>包含包名和类名，用于唯一标识类或接口，通过全限定名能找到唯一一个类。例如package1.Dog、java.lang.String、java.util.Map$Entry</li><li><strong>规范名：</strong>类的规范字符串形式，常用于打印和日志记录。例如package1.Dog、java.lang.String、java.util.Map.Entry</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// java.util.Map</span></span><br><span class="line">    System.out.println(Map.class.getName());</span><br><span class="line">    <span class="comment">// java.util.Map</span></span><br><span class="line">    System.out.println(Map.class.getCanonicalName());</span><br><span class="line">    <span class="comment">// 输出 &quot;java.util.Map$Entry&quot;</span></span><br><span class="line">    System.out.println(Map.Entry.class.getName());</span><br><span class="line">    <span class="comment">// 输出 &quot;java.util.Map.Entry&quot;</span></span><br><span class="line">    System.out.println(Map.Entry.class.getCanonicalName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射获取成员"><a href="#反射获取成员" class="headerlink" title="反射获取成员"></a>反射获取成员</h2><h3 id="反射获取构造方法"><a href="#反射获取构造方法" class="headerlink" title="反射获取构造方法"></a>反射获取构造方法</h3><p><strong>Class对象获取构造器：</strong></p><ul><li><strong>getConstructor(Class&lt;?&gt;… parameterTypes)：</strong>获取指定参数类型的公共构造方法。返回值是<strong>Constructor类</strong>。</li><li><strong>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)：</strong>获取指定参数类型的构造方法（包括私有构造方法）。</li><li><strong>getConstructors()：</strong>获取所有公共构造方法。</li><li><strong>getDeclaredConstructors()：</strong>获取所有构造方法（包括私有构造方法）。</li><li>**newInstance()**：创建类的新实例。<ul><li><strong>Class类的newInstance()：</strong>只能够调用无参构造函数；</li><li><strong>Constructor类的newInstance()：</strong>可以根据传入的参数，调用任意构造函数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有构造器对象：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;Dog&gt; dogClass = Dog.class;</span><br><span class="line">    Constructor&lt;?&gt;[] cons = dogClass.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor&lt;?&gt; con:cons)&#123;</span><br><span class="line">        System.out.println(con);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取单个构造器并实例化： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line">        Class&lt;Dog&gt; dogClass=Dog.class;</span><br><span class="line">        <span class="comment">//获取单个构造方法对象</span></span><br><span class="line">        Constructor&lt;?&gt; con=dogClass.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//构造方法对象实例化，会调用无参构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">dogObject</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line">        <span class="comment">// 无参构造器实例化，也可以直接用Class对象的newInstance方法，带参就不行了</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> dogClass.newInstance();</span><br><span class="line">        <span class="comment">//重写了Dog类的to_String，所以输出：Dog&#123;weight=0, name=&#x27;null&#x27;&#125;</span></span><br><span class="line">        System.out.println(dogObject);</span><br><span class="line">        System.out.println(dog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取字段"><a href="#反射获取字段" class="headerlink" title="反射获取字段"></a>反射获取字段</h3><p><strong>Class对象获取字段：</strong></p><ul><li>getField(String name)：返回指定名称的公共字段。返回类型是字段类Field。</li><li><strong>getDeclaredField(String name)：</strong>返回指定名称的字段<strong>（包括私有字段）</strong>。</li><li>getFields()：返回所有公共字段。</li><li><strong>getDeclaredFields()：</strong>返回所有字段<strong>（包括私有字段）</strong>。</li></ul><p><strong>字段类Field常用方法：</strong></p><p><strong>获取字段信息</strong>：</p><ul><li><strong>getName()：</strong>返回字段的名称。</li><li><strong>getType()：</strong>返回字段的类型。</li><li><strong>getModifiers()：</strong>返回字段的修饰符。</li><li><strong>getDeclaringClass()：</strong>返回声明该字段的类的 Class 对象。</li></ul><p><strong>获取和设置字段值</strong>：</p><ul><li><strong>get(Object obj)：</strong>返回指定对象上此字段的值。</li><li><strong>getBoolean(Object obj)：</strong>返回指定对象上此字段的值（如果字段类型是 boolean）。</li><li>getByte(Object obj)：返回指定对象上此字段的值（如果字段类型是 byte）。</li><li>getChar(Object obj)：返回指定对象上此字段的值（如果字段类型是 char）。</li><li>getDouble(Object obj)：返回指定对象上此字段的值（如果字段类型是 double）。</li><li>getFloat(Object obj)：返回指定对象上此字段的值（如果字段类型是 float）。</li><li>getInt(Object obj)：返回指定对象上此字段的值（如果字段类型是 int）。</li><li>getLong(Object obj)：返回指定对象上此字段的值（如果字段类型是 long）。</li><li>getShort(Object obj)：返回指定对象上此字段的值（如果字段类型是 short）。</li><li><strong>set(Object obj, Object value)：</strong>设置指定对象上此字段的值。注意私有字段默认不允许赋值，要赋值必须给私有字段setAccessible(true)。</li><li><strong>setBoolean(Object obj, boolean value)：</strong>设置指定对象上此字段的值（如果字段类型是 boolean）。</li><li>setByte(Object obj, byte value)：设置指定对象上此字段的值（如果字段类型是 byte）。</li><li>setChar(Object obj, char value)：设置指定对象上此字段的值（如果字段类型是 char）。</li><li>setDouble(Object obj, double value)：设置指定对象上此字段的值（如果字段类型是 double）。</li><li>setFloat(Object obj, float value)：设置指定对象上此字段的值（如果字段类型是 float）。</li><li>setInt(Object obj, int value)：设置指定对象上此字段的值（如果字段类型是 int）。</li><li>setLong(Object obj, long value)：设置指定对象上此字段的值（如果字段类型是 long）。</li><li>setShort(Object obj, short value)：设置指定对象上此字段的值（如果字段类型是 short）。</li></ul><p><strong>其他方法</strong>：</p><ul><li><strong>isAccessible()：</strong>返回字段是否可访问。</li><li><strong>setAccessible(boolean flag)：</strong>设置字段的可访问性。通过这个方法可以让私有字段也可以赋值。</li><li>oGenericString()：返回字段的描述，包括泛型信息。</li><li>getAnnotatedType()：返回此字段的带注释的类型。</li><li>getAnnotations()：返回字段的所有注解。</li><li><strong>getAnnotation(Class<T> annotationClass)：</strong>返回字段的指定类型的注解，如果该注解不存在，则返回 null。例如Spring源码中依赖注入这一块，就是基于反射获取类中字段有没有@Resource、@Component等注解，有的话就是要注入Bean.</li><li>getDeclaredAnnotations()：返回直接存在于此字段上的所有注解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员变量对象并赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 1.获取Class对象，并实例化</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; dogClass = Dog.class;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> dogClass.newInstance();</span><br><span class="line">        <span class="comment">// 2.获取字段对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> dogClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">weightField</span> <span class="operator">=</span> dogClass.getDeclaredField(<span class="string">&quot;weight&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.给字段对象赋值</span></span><br><span class="line">        nameField.set(dog, <span class="string">&quot;旺财&quot;</span>);</span><br><span class="line">        <span class="comment">// 注意私有字段默认不允许赋值，要赋值必须给私有字段设置可访问</span></span><br><span class="line">        weightField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        weightField.set(dog, <span class="number">10</span>);</span><br><span class="line">        System.out.println(dog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过Field获取的Class类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">        Class&lt;Dog&gt; dogClass=Dog.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">weightField</span> <span class="operator">=</span> dogClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; dogClassByField = weightField.getDeclaringClass();</span><br><span class="line">        <span class="comment">// 通过字段获取到的class对象和源class对象是地址是一样的，事实上一个类的所有Class对象都是一个实例</span></span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line">        System.out.println(dogClassByField==dogClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取普通方法"><a href="#反射获取普通方法" class="headerlink" title="反射获取普通方法"></a>反射获取普通方法</h3><p>Class对象获取成员方法的方法： </p><ul><li><p><strong>getMethod(String name, Class&lt;?&gt;… parameterTypes)：</strong>返回指定名称和参数类型的公共方法。返回值是<strong>方法类Method。</strong></p></li><li><p><strong>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)：</strong>返回指定名称和参数类型的方法（包括私有方法）。</p></li><li><p><strong>getMethods()：</strong>返回所有公共方法（包括从父类<strong>继承的方法</strong>）。</p></li><li><p><strong>getDeclaredMethods()：</strong>返回所有方法（包括<strong>私有方法</strong>）。</p></li><li><p><strong>Method类的方法：</strong></p><ul><li><strong>获取方法信息</strong>：<ul><li>getName()：返回方法的名称。</li><li>getReturnType()：返回方法的返回类型。</li><li>getParameterTypes()：返回方法参数类型的数组。</li><li>getModifiers()：返回方法的修饰符。</li><li>getDeclaringClass()：返回声明此方法的类的 Class 对象。</li></ul></li></ul></li><li><p><strong>调用方法</strong>：</p><ul><li><strong>Object invoke(Object obj, Object… args)：</strong>调用指定对象上此 Method 对象表示的基础方法。</li></ul></li><li><p><strong>其他方法</strong>：</p><ul><li><strong>isAccessible()：</strong>返回方法是否可访问。</li><li><strong>setAccessible(boolean flag)：</strong>设置方法的可访问性。</li><li><strong>getAnnotations()：</strong>返回此方法的所有注解。例如Spring源码中通过此方法判断一个类中</li><li>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)：判断此方法是否被指定的注解类型注释。</li><li>getAnnotation(Class<T> annotationClass)：返回该方法的指定类型的注解。</li><li>getExceptionTypes()：返回此方法抛出的异常类型的数组。</li><li>toGenericString()：返回方法的描述，包括泛型信息。</li></ul></li></ul><p><strong>获取成员变量对象并调用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取构造方法对象并实例化</span></span><br><span class="line">Class&lt;?&gt; c= Class.forName(<span class="string">&quot;train.Dog&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; con=c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"><span class="comment">// 2.获取成员方法对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line"><span class="comment">// 3.通过成员方法对象的invoke方法，调用构造方法对象的成员方法</span></span><br><span class="line"><span class="comment">// 无参无返回值方法</span></span><br><span class="line">eat.invoke(obj);</span><br><span class="line"><span class="comment">// 带参有返回值方法</span></span><br><span class="line">Object sucess= eat.invoke(obj,<span class="string">&quot;food&quot;</span>);</span><br><span class="line">System.out.println((<span class="type">boolean</span>)sucess);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Java 多线程环境中，锁是&lt;strong&gt;确保共享资源线程安全&lt;/strong&gt;的重要手段。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://blog.csdn.net/qq_45675973/article/details/147740830&quot;&gt;Java锁</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用多线程解决问题</title>
    <link href="https://southernfish.github.io/2025/07/24/java/java-base-8-thread-impl/"/>
    <id>https://southernfish.github.io/2025/07/24/java/java-base-8-thread-impl/</id>
    <published>2025-07-24T01:25:36.000Z</published>
    <updated>2025-07-23T14:13:51.314Z</updated>
    
    <content type="html"><![CDATA[<p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同<a href="https://baike.baidu.com/item/%E4%B8%80%E6%97%B6%E9%97%B4/3618565?fromModule=lemma_inlink">一时间</a>执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括<a href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA/10375153?fromModule=lemma_inlink">对称多处理机</a>、<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%A0%B8%E5%BF%83/1013410?fromModule=lemma_inlink">多核心</a>处理器以及<a href="https://baike.baidu.com/item/%E8%8A%AF%E7%89%87%E7%BA%A7%E5%A4%9A%E5%A4%84%E7%90%86/924724?fromModule=lemma_inlink">芯片级多处理</a>或<a href="https://baike.baidu.com/item/%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B/22689341?fromModule=lemma_inlink">同时多线程</a>处理器。在一个程序中，这些独立运行的程序片段叫作“<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fromModule=lemma_inlink">线程</a>”（Thread），利用它编程的概念就叫作“多线程处理” 。本文简单记录一些关于线程、多线程的问题。本文记录了关于一些常见多线程业务问题处理。</p><h2 id="多线程问题-1"><a href="#多线程问题-1" class="headerlink" title="多线程问题 1"></a>多线程问题 1</h2><p><strong>问题：</strong>100个线程并发向1个银行账户中存入1元钱,并在全部完成后，打印银行账户的金额。</p><p><strong>思路：</strong>创建100个线程（<code>线程池</code>）；保证线程安全，同一时刻只有一个线程对账户进行操作（<code>Lock</code> 或者 <code>synchronized</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种加锁 synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="comment">// 获得账户余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁 存钱方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> <span class="built_in">this</span>.balance + money;</span><br><span class="line">        <span class="built_in">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种锁 lock</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="comment">// 获得账户余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁 存钱方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        reentrantLock.lock;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newBalance = balance + money;</span><br><span class="line">            balance = newBalance;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">          reentrantLock.unlock();  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存钱的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadSaveAccount</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TheadSaveAccount</span><span class="params">(Account account, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁 整个账户</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            account.deposit(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadSave</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            service.execute( <span class="keyword">new</span> <span class="title class_">TheadSaveAccount</span>(account, <span class="number">1</span>) );</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">        <span class="keyword">if</span> (service.isTerminated()) &#123;</span><br><span class="line">            System.out.println(account.getBalance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多线程是并行化的一种形式，或者是拆分工作以便同时进行处理。线程化的程序将工作拆分到多个软件线程，而不是将大量工作交给单个内核。这些线程由不同的 CPU 内核并行处理，以节省时间。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="https://southernfish.github.io/2025/07/24/java/java-base-8-thread/"/>
    <id>https://southernfish.github.io/2025/07/24/java/java-base-8-thread/</id>
    <published>2025-07-24T00:28:36.000Z</published>
    <updated>2025-07-23T14:13:38.082Z</updated>
    
    <content type="html"><![CDATA[<p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同<a href="https://baike.baidu.com/item/%E4%B8%80%E6%97%B6%E9%97%B4/3618565?fromModule=lemma_inlink">一时间</a>执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括<a href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA/10375153?fromModule=lemma_inlink">对称多处理机</a>、<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%A0%B8%E5%BF%83/1013410?fromModule=lemma_inlink">多核心</a>处理器以及<a href="https://baike.baidu.com/item/%E8%8A%AF%E7%89%87%E7%BA%A7%E5%A4%9A%E5%A4%84%E7%90%86/924724?fromModule=lemma_inlink">芯片级多处理</a>或<a href="https://baike.baidu.com/item/%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B/22689341?fromModule=lemma_inlink">同时多线程</a>处理器。在一个程序中，这些独立运行的程序片段叫作“<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fromModule=lemma_inlink">线程</a>”（Thread），利用它编程的概念就叫作“多线程处理” 。本文简单记录一些关于线程、多线程的问题。参考文章：<a href="https://blog.csdn.net/qq_46154326/article/details/148100902">多线程下如何保证事务的一致性</a>、<a href="https://blog.csdn.net/m0_53157173/article/details/127423286">Spring在多线程环境下如何确保事务一致性</a>、<a href="https://www.51cto.com/article/768896.html">详解Spring多线程下如何保证事务的一致性</a>、参考链接：<a href="https://blog.csdn.net/qq_40991313/article/details/140324927">https://blog.csdn.net/qq_40991313/article/details/140324927</a></p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><h2 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h2><p>并行：多个处理器或多核处理器同时处理多个任务。<br>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</p><h2 id="线程和进程的关系"><a href="#线程和进程的关系" class="headerlink" title="线程和进程的关系"></a>线程和进程的关系</h2><p><strong>进程</strong>：是操作系统分配资源的基本单位，有独立的地址空间（内存空间的一部分，用于存储进程中的代码、数据和堆栈等信息）和内存空间，进程之间不能共享资源，上下文切换慢，并发低，能独立执行（有程序入口、执行序列、出口），更健壮（因为进程崩溃后不会影响其他进程）。</p><p><strong>线程</strong>：是操作系统调度的基本单位，没有独立的地址空间和内存空间（只有自己的堆栈和局部变量，只能共享所在进程的内存空间），线程之间可以共享进程内的资源，上下文切换快，并发高，不能独立执行（应用程序控制多线程执行，进程通过管理线程优先级间接控制线程执行），不健壮（因为一个线程崩溃会导致整个进程崩溃）。</p><p><strong>关系</strong>：一个程序运行后至少包括一个进程，一个进程至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><blockquote><p>运行时数据区包括本地方法栈、虚拟机栈、方法区、堆、程序计数器。每个线程都有独自的本地方法栈、虚拟机栈、程序计数器。各线程共享进程的方法区和堆。</p><p><strong>JVM运行时数据区参考：</strong><a href="https://blog.csdn.net/qq_40991313/article/details/134742377?spm=1001.2014.3001.5501">什么是JVM的内存模型？详细阐述Java中局部变量、常量、类名等信息在JVM中的存储位置_jvm中主要用于存储类的元数据(类型信息(类的描述信息 类的元数据))、静态变量、常-CSDN博客</a></p></blockquote><h2 id="线程状态（state）"><a href="#线程状态（state）" class="headerlink" title="线程状态（state）"></a>线程状态（state）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEW 线程创建但尚未启动</span><br><span class="line">RUNNABLE 就绪或者正在执行中</span><br><span class="line">BLOCKED 阻塞的（被同步锁或者IO锁阻塞），等待获取锁</span><br><span class="line">WAITING 永久等待状态，等待其他线程唤醒（如wait()）</span><br><span class="line">TIMED_WAITING 等待指定的时间重新被唤醒的状态，定时等待（如sleep(long)）</span><br><span class="line">TERMINATED 线程执行完成</span><br></pre></td></tr></table></figure><h2 id="守护线程（Daemon-Thread）"><a href="#守护线程（Daemon-Thread）" class="headerlink" title="守护线程（Daemon Thread）"></a>守护线程（Daemon Thread）</h2><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><ul><li><strong>作用</strong>：为其他线程提供服务（如垃圾回收线程）</li><li><strong>特性</strong>：当所有非守护线程结束时，守护线程自动终止。</li><li><strong>设置</strong>：thread.setDaemon(true)必须在start()前调用</li></ul><h2 id="中断（Interruption）"><a href="#中断（Interruption）" class="headerlink" title="中断（Interruption）"></a>中断（Interruption）</h2><ul><li><p><strong>作用</strong>：通知线程应该终止，但线程可选择忽略。</p></li><li><p><strong>方法</strong>：</p><ul><li><p><code>thread.interrupt()</code>：中断线程。</p></li><li><p><code>Thread.interrupted()</code>：检查并清除中断状态。 </p></li><li><p><code>thread.isInterrupted()</code>：检查中断状态。</p></li></ul></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>一个程序运行后至少包括一个进程，一个进程至少有一个线程，一个进程下有多个线程并发地处理任务，称为多线程。</p><p><strong>多线程的好处：</strong>当一个线程进入阻塞或者等待状态时，其他的线程可以获取CPU的执行权，提高了CPU的利用率。</p><p><strong>多线程的缺点：</strong></p><ul><li><strong>死锁</strong>：多个进程或线程相互等待对方释放所持有的资源，从而无法继续执行的情况。若无外力作用，它们都将无法推进下去。死锁用占用CPU、内存等系统资源，导致资源浪费，死锁会导致程序无法正常退出，导致系统性能差。</li><li><strong>上下文频繁切换</strong>：频繁的上下文切换可能会造成资源的浪费；</li><li><strong>串行</strong>：如果因为资源的限制，多线程串行执行，可能速度会比单线程更慢。</li></ul><p> <strong>线程的优先级</strong>：java是抢占式调度模型，每一个 Java 线程都有一个优先级，优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p><blockquote><p><strong>注意</strong>：优先级高的线程只是获取CPU时间片的几率高，但并不能保证先执行。</p></blockquote><h2 id="ThreadLocal-及使用场景"><a href="#ThreadLocal-及使用场景" class="headerlink" title="ThreadLocal 及使用场景"></a>ThreadLocal 及使用场景</h2><p><code>ThreadLocal</code> 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><p><code>TransactionSynchronizationManager</code>类内部默认提供了下面六个ThreadLocal属性，分别保存当前线程对应的不同事务资源:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存当前事务关联的资源</span></span><br><span class="line"><span class="comment">// 默认只会在新建事务的时候保存当前获取到的DataSource和当前事务对应Connection的映射关系</span></span><br><span class="line"><span class="comment">// 这里Connection被包装为了ConnectionHolder</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Transactional resources&quot;</span>);</span><br><span class="line"><span class="comment">// 事务监听者</span></span><br><span class="line"><span class="comment">// 在事务执行到某个阶段的过程中，会去回调监听者对应的回调接口(典型观察者模式的应用)</span></span><br><span class="line"><span class="comment">// 默认为空集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Transaction synchronizations&quot;</span>);</span><br><span class="line"><span class="comment">// 存放当前事务名字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Current transaction name&quot;</span>);</span><br><span class="line"><span class="comment">// 存放当前事务是否是只读事务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Current transaction read-only status&quot;</span>);</span><br><span class="line"><span class="comment">// 存放当前事务的隔离级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Current transaction isolation level&quot;</span>);</span><br><span class="line"><span class="comment">// 存放当前事务是否处于激活状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Actual transaction active&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="需要多线程的业务场景"><a href="#需要多线程的业务场景" class="headerlink" title="需要多线程的业务场景"></a>需要多线程的业务场景</h2><table><thead><tr><th align="center"></th><th>场景</th><th>实现</th><th>优势或示例</th></tr></thead><tbody><tr><td align="center">高并发Web服务器</td><td>处理大量HTTP请求，每个请求独立处理</td><td>使用线程池处理请求，避免频繁创建线程</td><td>示例：Tomcat、Netty等服务器的线程模型。</td></tr><tr><td align="center">批处理任务</td><td>批量处理大量数据（如ETL作业）</td><td>将数据分片，每个线程处理一部分数据</td><td><strong>优势</strong>：显著提高处理速度</td></tr><tr><td align="center">异步IO操作</td><td>文件读写、网络通信等IO密集型操作</td><td>使用异步线程执行IO操作，主线程继续处理其他任务</td><td>示例：数据库查询、HTTP请求调用</td></tr><tr><td align="center">定时任务调度</td><td>定期执行任务（如数据备份、统计报表生成）</td><td>使用<code>ScheduledExecutorService</code>或Spring的<code>@Scheduled</code>注解</td><td>示例：每天凌晨执行数据同步任务</td></tr><tr><td align="center">实时数据处理</td><td>实时分析数据流（如日志分析、监控数据处理）</td><td>使用多线程并行处理数据流</td><td>示例：电商平台实时计算商品销量排行</td></tr><tr><td align="center">图形界面应用</td><td>保持UI响应性的同时执行耗时操作</td><td>将耗时操作放在后台线程执行</td><td>示例：文件下载进度显示、复杂计算</td></tr><tr><td align="center">分布式缓存更新</td><td>缓存失效时，异步更新缓存数据</td><td>使用后台线程重新加载数据到缓存</td><td><strong>优势</strong>：避免用户请求等待缓存更新</td></tr><tr><td align="center">消息队列消费者</td><td>从消息队列（如Kafka、RabbitMQ）消费消息</td><td>多线程并行消费，提高吞吐量</td><td>示例：订单处理、日志收集</td></tr><tr><td align="center">搜索引擎索引构建</td><td>构建大规模索引（如Elasticsearch索引）</td><td>多线程并行处理文档，加速索引构建</td><td><strong>优势</strong>：缩短索引构建时间，提高搜索服务可用性</td></tr><tr><td align="center">游戏服务器</td><td>处理多个玩家的并发操作</td><td>每个玩家会话由独立线程处理</td><td>示例：多人在线游戏的服务器端逻辑</td></tr></tbody></table><hr><h1 id="创建线程方法"><a href="#创建线程方法" class="headerlink" title="创建线程方法"></a>创建线程方法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>创建线程有4种方式：</p><ul><li> <strong>继承Thread类：</strong>继承Thread类，重写run()方法；然后创建线程对象调用start()方法开启线程。start()方法里包括了run()方法，用于开启线程。注意如果直接调用run()方法的话，将是普通方法调用，无法起到开启线程的效果</li><li><strong>实现Runnable接口：</strong>实现Runnable接口并重写run()方法，将实现类作为构造参数创建Thread对象。推荐，因为Java是单继承，线程类实现接口的同时，还可以继承其他类实现其他接口。</li><li><strong>实现Callable：</strong>实现Callable<T>接口，重写带返回值的call()方法；将实现类对象作为构造参数创建FutureTask<T>对象；将FutureTask对象作为构造参数创建Thread对象。所以此方法可以获取线程执行完后的返回值，而前两种方式不能。</li><li><strong>ExecutorService的submit或execute方法：</strong>execute和submit都是ExecutorService接口的方法，用于线程池提交任务。所有线程池都直接或间接实现ExecutorService接口。<ul><li><strong>execute：</strong>参数只能是Runnable，没有返回值</li><li><strong>submit：</strong>参数可以是Runnable、Callable，返回值是FutureTask</li></ul></li></ul><h2 id="方法1：继承Thread类"><a href="#方法1：继承Thread类" class="headerlink" title="方法1：继承Thread类"></a>方法1：继承Thread类</h2><p><strong>创建并启动线程的步骤：</strong> </p><ol><li>创建一个继承了 Thread类的线程类，重写的run()方法是线程执行体。</li><li>创建这个类的对象。</li><li>调用线程对象的start()方法来启动该线程（之后Java虚拟机会调用该线程run方法）。</li></ol><p><strong>run()和start()区别：</strong></p><ul><li><strong>run()：</strong>封装线程执行的代码，直接调用相当于普通方法的调用。</li><li><strong>start()：</strong>启动线程，虚拟机<strong>调用</strong>该线程的**run()**方法。</li></ul><p><strong>构造方法：</strong></p><ul><li><strong>Thread():</strong> 创建一个新的线程对象。</li><li><strong>Thread(String name):</strong> 创建一个新的线程对象并将其名称设置为指定的名称。</li><li><strong>Thread(Runnable target):</strong> 创建一个新的线程对象并将其目标设置为指定的 Runnable 对象。主要用于后面通过Runable接口创建线程。</li><li><strong>Thread(Runnable target, String name):</strong> 创建一个新的线程对象，将其目标设置为指定的 Runnable 对象，并将其名称设置为指定的名称。</li></ul><p><strong>常用方法：</strong></p><ul><li><strong>void start():</strong> 使线程开始执行；Java 虚拟机调用此线程的 run 方法。</li><li><strong>void run():</strong> 如果此线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，此方法不执行任何操作并返回。</li><li>**void join():**等待该线程执行完成。A线程调用B线程的join()方法，A线程将被阻塞，直到B线程执行完。可以用于线程之间的通信。</li><li>void join(long millis): 等待该线程终止的时间最长为 millis 毫秒。</li><li>void join(long millis, int nanos): 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。</li><li><strong>void interrupt():</strong> 中断该线程。</li><li>boolean isInterrupted(): 测试当前线程是否已中断。</li><li><strong>boolean isAlive():</strong> 测试线程是否处于活动状态。</li><li><strong>static void sleep(long millis):</strong> 使当前正在执行的线程休眠（暂停执行）指定的毫秒数。</li><li>static void sleep(long millis, int nanos): 使当前正在执行的线程休眠（暂停执行）指定的毫秒数加指定的纳秒数。</li></ul><p><strong>属性方法：</strong></p><ul><li><strong>void setName(String name):</strong> 改变线程名称，使之与参数 name 相同。</li><li><strong>String getName():</strong> 返回该线程的名称。</li><li><strong>void setPriority(int newPriority):</strong> 更改该线程的优先级。</li><li><strong>int getPriority():</strong> 返回该线程的优先级。</li><li><strong>Thread.State getState():</strong> 返回该线程的状态。</li><li><strong>void setDaemon(boolean on):</strong> 将该线程标记为守护线程或用户线程。</li><li><strong>boolean isDaemon():</strong> 测试该线程是否为守护线程。用户线程是普通的线程，它们通常是应用程序执行任务的主要线程。守护线程为其他线程提供后台支持。当所有用户线程结束时，JVM 会自动退出，无论守护线程是否仍在运行。</li></ul><p><strong>代码示例</strong>：<strong>继承 Thread 重写 run 方法：</strong>代码简单，但该类无法集成别的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程执行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.主线程设置名字并查看</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建并启动线程</span></span><br><span class="line"><span class="comment">// 线程类：打印数字线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNumberThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 打印1-100</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造方法 @param name 线程名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintNumberThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建并启动线程 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNumberThread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumberThread</span> (<span class="string">&quot;a&quot;</span>), b = <span class="keyword">new</span> <span class="title class_">PrintNumberThread</span> (<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 两个线程是随机交替打印的，因为它们获取CPU的调度是随机的</span></span><br></pre></td></tr></table></figure><h2 id="方法2：实现-Runnable-接口"><a href="#方法2：实现-Runnable-接口" class="headerlink" title="方法2：实现 Runnable 接口"></a>方法2：实现 Runnable 接口</h2><p><strong>步骤：</strong> </p><ol><li>定义Runnable接口的实现类，并实现该接口的run()方法，该方法将作为线程执行体。</li><li>创建Runnable实现类的实例，并将其作为参数来创建Thread对象，Thread对象为线程对象。</li><li>调用线程对象的start()方法来启动该线程。</li></ol><p><strong>这种办法更好，优点：</strong></p><ul><li><strong>避免Java 单继承局限性：</strong>Java是单继承，使用这种方法，线程类实现接口的同时，还可以继承其他类、实现其他接口。</li><li><strong>逻辑和数据更好分离：</strong>通过实现 Runnable 接口的方法创建多线程更加适合<strong>同一个资源被多段业务逻辑并行处理</strong>的场景。在同一个资源被多个线程逻辑异步、并行处理的场景中，通过实现 Runnable 接口的方式设计多个 target 执行目标类可以更加方便、清晰地将执行逻辑和数据存储分离，更好地体现了面向对象的设计思想。</li></ul><p><strong>代码示例</strong>：<strong>实现 Runnable 接口：</strong>继承其他类；同一实现该接口的实例可以共享资源。但代码复杂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程执行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码实践</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印数字Runnable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNumberRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方法1：使用普通方式实现Runnable接口</span></span><br><span class="line">        <span class="type">PrintNumberRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumberRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;a&quot;</span>), b = <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// 方法2：使用Lambda表达式实现Runnable接口，无需再创建PrintNumberRunnable类</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        d.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法3：实现-Callable接口"><a href="#方法3：实现-Callable接口" class="headerlink" title="方法3：实现 Callable接口"></a>方法3：实现 Callable接口</h2><p>通过<strong>实现Callable接口</strong>来创建线程的步骤如下</p><ul><li>实现Callable<T>接口，重写带返回值的call()方法；</li><li>将实现类对象作为构造参数创建FutureTask<T>对象；</li><li>将FutureTask对象作为构造参数创建Thread对象。</li></ul><p>相比于前两种方法，此方法可以<strong>获取线程执行完后的返回值</strong>，而前两种方式不能，因为call()方法是有返回值的。 </p><p><strong>代码示例</strong>：<strong>实现 Callable 接口：</strong>可以获得异步任务的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">FutureTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br></pre></td></tr></table></figure><p><strong>代码实践</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;执行结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法4：线程池"><a href="#方法4：线程池" class="headerlink" title="方法4：线程池"></a>方法4：线程池</h2><p>线程池（Thread Pool）是一种多线程处理方式，用于减少创建和销毁线程的开销，提高系统资源利用率和处理效率。</p><p><strong>线程池作用：</strong> </p><ul><li><strong>管理线程数量：</strong>它可以管理线程的数量，可以避免无节制的创建线程，导致超出系统负荷直至崩溃。</li><li><strong>让线程复用：</strong>它还可以让线程复用，可以大大地减少创建和销毁线程所带来的开销。</li></ul><p><strong>线程池的两种创建方法：</strong></p><ul><li>执行器工具类Executors；</li><li>自定义线程池ThreadPoolExecutor </li></ul><p><strong>线程池两种提交任务的方法</strong>：</p><p>execute和submit都是ExecutorService接口的方法，用于线程池提交任务。所有线程池都直接或间接实现ExecutorService接口。</p><ul><li><strong>execute</strong>：参数只能是Runnable，没有返回值</li><li><strong>submit</strong>：参数可以是Runnable、Callable，返回值是FutureTask </li></ul><p><strong>代码示例</strong>：<strong>两种创建线程池的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池工具类，创建固定大小的线程池：</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程&quot;</span>+Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 自定义线程池:实现自动化装配，易于管理，循环利用资源。</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>( </span><br><span class="line">    <span class="number">5</span>,                                        <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="number">200</span>,                                    <span class="comment">// 最大线程数量，控制资源并发</span></span><br><span class="line">    <span class="number">10</span>,                                        <span class="comment">// 存活时间</span></span><br><span class="line">    TimeUnit.SECONDS,                        <span class="comment">// 时间单位</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(  <span class="number">100000</span>),    <span class="comment">// 任务队列，大小100000个</span></span><br><span class="line">Executors.defaultThreadFactory(),            <span class="comment">// 线程的创建工厂</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());        <span class="comment">// 拒绝策略</span></span><br><span class="line"><span class="comment">// 任务1</span></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--helloWorld_001--&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>参数作用 ：</p><ul><li><code>corePoolSize</code>：线程池的基本大小，当<strong>提交的任务数小于此值时，直接创建新线程</strong>执行任务。 </li><li><code>maximumPoolSize</code>：线程池允许的最大线程数，当<strong>任务队列满且线程数小于此值时，会创建新线程</strong>。 </li><li><code>keepAliveTime</code>：当<strong>线程数大于核心线程数</strong>时，多余的<strong>空闲线程在终止前等待新任务的最长时间</strong>。 </li><li><code>workQueue</code>：用于<strong>保存等待执行的任务的阻塞队列</strong>，常见类型有： <ul><li><code>ArrayBlockingQueue</code>：有界队列</li><li><code>LinkedBlockingQueue</code>：无界队列（需注意<code>OOM</code>风险） </li><li><code>SynchronousQueue</code>：直接提交队列   </li></ul></li><li><code>threadFactory</code>：创建线程的工厂，可自定义线程名称、优先级等。 </li><li><code>handler</code>：当<strong>任务队列和线程池都满时的拒绝策略</strong>，默认有四种： <ul><li><code>AbortPolicy</code>：直接抛出异常（默认）</li><li><code>CallerRunsPolicy</code>：由调用线程处理任务</li><li><code>DiscardPolicy</code>：丢弃最新的任务</li><li><code>DiscardOldestPolicy</code>：丢弃最老的任务</li></ul></li></ul><hr><h1 id="知识加油站"><a href="#知识加油站" class="headerlink" title="知识加油站"></a>知识加油站</h1><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>Java线程在运行的生命周期中,在任意给定的时刻,只能处于下列6种状态之一：</p><ul><li><strong>NEW ：初始状态</strong>，线程被创建，但是还没有调用start方法。</li><li><strong>RUNNABLE：可运行状态</strong>，等待调度或运行。线程正在JVM中执行，但是有可能在等待操作系统的调度。</li><li><strong>BLOCKED ：阻塞状态</strong>，线程正在等待获取监视器锁。</li><li><strong>WAITING ：等待状态</strong>，线程正在等待其他线程的通知或中断。线程等待状态不占用 CPU 资源，被唤醒后进入可运行状态（等待调度或运行）。</li><li><strong>TIMED_WAITING：超时等待状态</strong>，在WAITING的基础上增加了超时时间，即超出时间自动返回。<code>Thread.sleep(1000);</code>让线程超时等待1s。</li><li><strong>TERMINATED：终止状态</strong>，线程已经执行完毕。</li></ul><p><strong>线程的运行过程：</strong></p><p>线程在创建之后默认为NEW（初始状态），在调用start方法之后进入RUNNABLE（可运行状态）。</p><blockquote><p><strong>注意：</strong>可运行状态不代表线程正在运行，它有可能正在等待操作系统的调度。</p></blockquote><p>WAITING （等待状态）的线程需要其他线程的通知才能返回到可运行状态，而TIMED_WAITING（超时等待状态）相当于在等待状态的基础上增加了超时限制，除了他线程的唤醒，在超时时间到达时也会返回运行状态。</p><p>此外，线程在执行同步方法时，在没有获取到锁的情况下，会进入到BLOCKED（阻塞状态）。线程在执行完run方法之后，会进入到TERMINATED（终止状态）。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250723122520457.png" alt="image-20250723122520457"></p><blockquote><p> <strong>等待状态如何被唤醒</strong></p><p> Object类：</p><ul><li>wait()方法让线程进入等待状态</li><li>notify()唤醒该对象上的随机一个线程</li><li>notifyAll()唤醒该对象上的所有线程。</li></ul><p> 这3个方法必须处于<strong>synchronized</strong>代码块或方法中，否则会抛出<code>IllegalMonitorStateException</code>异常。因为调用这三个方法之前必须拿要到当前锁对象的监视器（Monitor对象），synchronized基于对象头和Monitor对象。</p><p> 另外，也可以通过<strong>Condition类的 await/signal/signalAll</strong>方法实现线程的等待和唤醒，从而实现线程的通信，令线程之间协作处理任务。这两个方法依赖于Lock对象。</p><p> <strong>notify() 和 notifyAll() 的区别</strong></p><p> <code>notifyAll()</code>会唤醒所有的线程，<code>notify()</code>之后唤醒一个线程。<br> notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 <code>notify()</code>只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><p> <strong>sleep() 和 wait() 的区别</strong></p><ul><li><strong>类的不同：</strong>sleep() 来自 Thread，wait() 来自 Object。</li><li><strong>释放锁：</strong>sleep() 不释放锁；wait() 释放锁。</li><li><strong>用法不同：</strong>sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll() 直接唤醒。</li></ul></blockquote><h2 id="线程的通信方式"><a href="#线程的通信方式" class="headerlink" title="线程的通信方式"></a>线程的通信方式</h2><p><strong>线程通信：</strong>用于多个线程之间协作工作，共同完成某个任务<strong>。</strong>多个线程在并发执行的时候，他们在CPU中是随机切换执行的，想多个线程一起来完成一件任务，就需要线程之间的通信。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250723122705785.png" alt="image-20250723122705785"></p><p><strong>线程通信方式：</strong> </p><ul><li><strong>通过 volatile 关键字：</strong>多个线程同时监听一个volatile变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。利用了volatile可见性，即一旦修改变量则立即刷新到共享内存中。</li><li><strong>通过Object类的 wait/notify/notifyAll 方法：</strong>当我们使用synchronized同步时就会使用Monitor来实现线程通信，这里的Monitor其实就是锁对象，其利用Object类的wait，notify，notifyAll等方法来实现线程通信。Monitor是Java虚拟机实现锁的一种底层机制，用于控制线程对共享资源的访问。</li><li><strong>通过Condition类的 await/signal 方法：</strong>而使用Lock进行同步时就是使用Condition对象来实现线程通信，Condition对象通过Lock的lock.newCondition()方法创建，使用其await，sign或signAll方法实现线程通信。Condition 是一个与锁 Lock 相关联的条件对象，可以让等待线程在某个条件被满足时被唤醒，从而达到线程协作的目的。</li><li><strong>通过Semaphore的acquire/release方法：</strong> Semaphore是一个计数信号量，用于控制同时访问某个资源的线程数量。线程可以通过acquire()方法获取许可，release()方法释放许可。</li><li><strong>通过Thread类的join()方法：</strong>join() 方法等待该线程执行完成。A线程调用B线程的join()方法，A线程将被阻塞，直到B线程执行完。</li></ul><p><strong>应用场景：</strong></p><ul><li><p><strong>线程交替打印：</strong>在多线程交替打印A/B、或者交替打印1到100时，需要在锁中使用线程通信。如果不使用lock.notify()和lock.wait()，可能导致当前线程释放锁后立刻又拿回锁（因为多线程是CPU随机切换的），从而达不到交替打印的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个线程，例如打印A</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 1.临界值校验：到临界值唤醒其他线程，防止其他线程永远等待；</span></span><br><span class="line">                    <span class="comment">// 2.打印判断：如果需要打印，则打印、操作原子类。 </span></span><br><span class="line">                        <span class="comment">// 如果用的当前行值原子类，则加1；如果用的总行数原子类，则减1</span></span><br><span class="line">                    <span class="comment">// 4.线程通信：唤醒、等待。</span></span><br><span class="line">                    <span class="comment">// 如果删除下面两行代码，可能导致当前线程释放锁后立刻又拿到锁了，从而达不到交替打印的效果</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span>-<span class="keyword">catch</span>&#123; lock.wait(); &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">).start();</span><br><span class="line"><span class="comment">//另一个线程，例如打印B...</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>为了对多线程进行统一的管理，Java引入了线程池，它通过限制并发线程的数量、将待执行的线程放入队列、销毁空闲线程，来控制资源消耗，使线程更合理地运行，避免系统因为创建过多线程而崩溃。</p><p><strong>线程池作用：</strong> </p><ul><li><strong>管理线程数量：</strong>它可管理线程的数量，可避免无节制的销毁、创建线程，导致额外的性能损耗、或线程数超出系统负荷直至崩溃。</li><li><strong>提高性能：</strong>当有新任务到来时，可直接从线程池中取出一个空闲线程来执行任务，而不需要等待创建新线程，从而减少了响应时间。</li><li><strong>让线程复用：</strong>它还可以让线程复用，可以大大地减少创建和销毁线程所带来的开销。</li><li><strong>合理的拒绝策略</strong>：线程池提供了多种拒绝策略，当线程池队列满了时，可采用不同的策略进行处理，如抛出异常、丢弃任务或调用者运行等。</li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>通常线程池的生命周期包含5个状态，对应状态值分别是：-1、0、1、2、3，这些状态只能由小到大迁移，不可逆。</p><ol><li><strong>RUNNING：运行。</strong>线程池处于正常状态，可以接受新的任务，同时会按照预设的策略来处理已有任务的执行。</li><li><strong>SHUTDOWN：关闭。</strong>线程池处于关闭状态，不再接受新的任务，但是会<strong>继续执行</strong>已有任务直到执行完成。执行线程池对象的shutdown()时进入该状态。</li><li><strong>STOP：停止。</strong>线程池处于关闭状态，不再接受新的任务，同时会<strong>中断</strong>正在执行的任务，<strong>清空</strong>线程队列。执行shutdownNow()时进入该状态。</li><li><strong>TIDYING：整理。</strong>所有任务已经执行完毕，线程池进入该状态会开始进行一些结尾工作，比如及时清理线程池的一些资源。</li><li><strong>TERMINATED：终止。</strong>线程池已经完全停止，所有的状态都已经结束了，线程池处于最终的状态。</li></ol><h3 id="创建线程池的方式1：线程池工具类"><a href="#创建线程池的方式1：线程池工具类" class="headerlink" title="创建线程池的方式1：线程池工具类"></a>创建线程池的方式1：线程池工具类</h3><p><strong>执行器工具类Executors创建线程池：</strong> 底层都是return new ThreadPoolExecutor(…)。一般不使用这种方式，参数配置死了不可控。</p><ul><li>**newCachedThreadPool()**：缓存线程池（无限大）。一种用来处理大量短时间工作任务的线程池。<ul><li><strong>核心线程数是0，最大线程数无限大：</strong>最大线程数<code>Integer.MAX_VALUE</code>。线程数量可以无限扩大，所有线程都是非核心线程。</li><li><strong>空闲线程存活时间60s：</strong>keepAliveTime为60S，空闲线程超过60s会被杀死。</li><li><strong>同步队列：</strong>因为最大线程数无限大，所以也用不到阻塞队列，所以设为没有存储空间的SynchronousQueue同步队列。它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程。这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。</li></ul></li><li><strong>newFixedThreadPool(int nThreads)：固定大小的线程池。</strong>重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。<ul><li><strong>核心线程数：</strong>所有线程都是核心线程（通过构造参数指定），最大线程数=核心线程数。</li><li><strong>存活时间0s：</strong>因为所有线程都是核心线程，所以用不到存活时间，线程都会一直存活。<code>keepAliveTime</code>为0S。</li><li><strong>链表阻塞队列：</strong>超出的线程会在<code>LinkedBlockingQueue</code>队列中等待空闲线程出现。即若有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads</li></ul></li><li><strong>newScheduledThreadPool(int corePoolSize)：定时任务线程池。</strong>创建定长线程池， 支持定时及周期性任务执行。可指定核心线程数，最大线程数。和 <code>newSingleThreadScheduledExecutor()</code> 类似，创建的是个 <code>ScheduledExecutorService</code>，区别在于单一工作线程还是多个工作线程。</li><li><strong>newSingleThreadExecutor()：单线程化的线程池。</strong>核心线程数与最大线程数都只有一个，操作一个无界的工作队列，不回收。后台从<code>LinkedBlockingQueue</code>队列中获取任务。创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务， 保证所有任务按照指定顺序（<code>FIFO, LIFO, 优先级</code>）执行。 </li><li><strong>newWorkStealingPool(int parallelism)：</strong>这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li><li><strong>ThreadPoolExecutor()：</strong>是最原始的线程池创建，上面的创建方式几乎都是对 ThreadPoolExecutor 的封装。（最核心）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//源码</span></span><br><span class="line">FixedThredPool: <span class="keyword">new</span> <span class="title class_">ThreadExcutor</span>(n, n, <span class="number">0L</span>, ms, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runable&gt;()</span><br><span class="line">SingleThreadExecutor: <span class="keyword">new</span> <span class="title class_">ThreadExcutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, ms, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runable&gt;())</span><br><span class="line">CachedTheadPool: <span class="keyword">new</span> <span class="title class_">ThreadExcutor</span>(<span class="number">0</span>, max_valuem, <span class="number">60L</span>, s, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">ScheduledThreadPoolExcutor: ScheduledThreadPool, SingleThreadScheduledExecutor.</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>： 一般要搭配计数器<code>CountDownLatch，await(时间)</code>让主线程等待，直到任务线程都执行完（计数器减为零），或者到达超时时间，防止无线等待。</p></blockquote><h3 id="创建线程池的方式2：自定义线程池（推荐）"><a href="#创建线程池的方式2：自定义线程池（推荐）" class="headerlink" title="创建线程池的方式2：自定义线程池（推荐）"></a>创建线程池的方式2：<strong>自定义线程池（推荐）</strong></h3><p><strong>线程池执行器ThreadPoolExecutor创建自定义线程池：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>( </span><br><span class="line">         <span class="number">5</span>,                                        <span class="comment">// 核心线程数</span></span><br><span class="line">         <span class="number">200</span>,                                    <span class="comment">// 最大线程数量，控制资源并发</span></span><br><span class="line">         <span class="number">10</span>,                                    <span class="comment">// 存活时间</span></span><br><span class="line">        TimeUnit.SECONDS,                       <span class="comment">// 时间单位</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(  <span class="number">100000</span>),    <span class="comment">// 任务队列，大小100000个</span></span><br><span class="line">Executors.defaultThreadFactory(),                <span class="comment">// 线程的创建工厂</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());            <span class="comment">// 拒绝策略</span></span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;    <span class="comment">// 开启异步编排，有返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;, threadPoolExecutor).thenApplyAsync(res -&gt; &#123;    <span class="comment">// 串行化，接收参数并有返回值</span></span><br><span class="line">    <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">&#125;, threadPoolExecutor);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> future.get();    <span class="comment">// 获取返回值</span></span><br></pre></td></tr></table></figure><p><strong>七个参数：</strong></p><ul><li><p><strong>corePoolSize：核心线程数</strong>。创建以后，会一直存活到线程池销毁，空闲时也不销毁。</p></li><li><p><strong>maximumPoolSize：最大线程数量</strong>。阻塞队列满了</p></li><li><p><strong>keepAliveTime： 存活时间</strong>。释放空闲时间超过“存活时间”的线程，仅留核心线程数量的线程。</p></li><li><p><strong>TimeUnitunit：时间单位</strong></p></li><li><p><strong>workQueue： 任务队列。</strong>如果线程数超过核心数量，就把剩余的任务放到队列里。只要有线程空闲，就会去队列取出新的任务执行。new LinkedBlockingDeque()队列大小默认是Integer的最大值，内存不够，所以建议指定队列大小。</p><ul><li><p>SynchronousQueue是一个同步队列，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。</p></li><li><p><strong>LinkedBlockingQueue</strong>是一个无界队列，可以缓存无限多的任务。由于其无界特性，因此需要合理地处理好任务的生产速率和线程池中线程的数量，以避免内存溢出等异常问题。无限缓存，拒绝策略就能随意了。</p></li><li><p><strong>ArrayBlockingQueue</strong>是一个有界（容量固定）队列，只能缓存固定数量的任务。通过固定队列容量，可以避免任务过多导致线程阻塞，保证线程池资源的可控性和稳定性。<strong>推荐</strong>，有界队列能增加系统的稳定性和预警能力。可以根据需要设大一点，比如几千，新任务丢弃后未来重新入队。</p></li><li><p>PriorityBlockingQueue是一个优先级队列，能够对任务按照优先级进行排序，当任务数量超过队列容量时，会根据元素的Comparable或Comparator排序规则进行丢弃或抛异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>&lt;&gt;((o1, o2) -&gt; o1.length() - o2.length());</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>threadFactory：线程的创建工厂</strong>。可以使用默认的线程工厂Executors.defaultThreadFactory()，也可以自定义线程工厂（实现ThreadFactory接口）</p></li><li><p><strong>RejectedExecutionHandler handler：拒绝策略。</strong>如果任务队列和最大线程数量满了，按照指定的拒绝策略执行任务。</p><ul><li><strong>Abort（默认）：</strong>直接抛异常（拒绝执行异常RejectedExecutionException）</li><li><strong>CallerRuns：</strong>直接同步调用线程run()方法，不创建线程了</li><li><strong>DiscardOldest：</strong>丢弃最老任务</li><li><strong>Discard：</strong>直接丢弃新任务</li><li>实现拒绝执行处理器接口（RejectedExecutionHandler），自定义拒绝策略。</li></ul></li></ul><h3 id="如何为线程池设置合适的线程数"><a href="#如何为线程池设置合适的线程数" class="headerlink" title="如何为线程池设置合适的线程数"></a>如何为线程池设置合适的线程数</h3><p>下面的参数只是一个预估值，适合初步设置，具体的线程数需要经过压测确定，压榨（更好的利用）CPU的性能。</p><p><strong>CPU核心数为N；</strong></p><p><strong>核心线程数：</strong></p><ul><li>CPU密集型：N+1。数量与CPU核数相近是为了不浪费CPU，并防止频繁的上下文切换，加1是为了有线程被阻塞后还能不浪费CPU的算力。</li><li><strong>I/O密集型：</strong>2N，或N/(1-阻塞系数)。I/O密集型任务CPU使用率并不是很高，可以让CPU在等待I/O操作的时去处理别的任务，充分利用CPU，所以数量就比CPU核心数高一倍。</li><li>有些公司会考虑阻塞系数，阻塞系数是任务线程被阻塞的比例，一般是0.8~0.9。</li><li><strong>实际开发中更适合的公式：</strong>N*((线程等待时间+线程计算时间)/线程计算时间)</li></ul><p><strong>最大线程数：</strong>设成核心线程数的2-4倍。数量主要由CPU和IO的密集性、处理的数据量等因素决定。</p><p><strong>需要增加线程的情况：</strong>jstack打印线程快照，如果发现线程池中大部分线程都等待获取任务、则说明线程够用。如果大部分线程都处于运行状态，可以继续适当调高线程数量。</p><p><strong>jstack：</strong>打印指定进程此刻的线程快照。定位线程长时间停顿的原因，例如死锁、等待资源、阻塞。如果有死锁会打印线程的互相占用资源情况。线程快照：该进程内每条线程正在执行的方法堆栈的集合。</p><h3 id="多线程实现的四种方式"><a href="#多线程实现的四种方式" class="headerlink" title="多线程实现的四种方式"></a>多线程实现的四种方式</h3><ol><li><p>继承Thread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">ThreadDemo</span> <span class="variable">threadDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">         threadDemo.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">3</span> ; i &lt; <span class="number">100</span> ; i ++) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.sqrt(i) ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRunnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableDemo</span> <span class="variable">runnableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableDemo).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">3</span> ; i &lt; <span class="number">100</span> ; i ++) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.sqrt(i) ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Callable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallable1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">CallableDemo</span> <span class="variable">callableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableDemo</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callableDemo); </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        List&lt;Integer&gt; lists = (List&lt;Integer&gt;)futureTask.get(); <span class="comment">//获取返回值</span></span><br><span class="line">        <span class="keyword">for</span> (Integer integer : lists) &#123;</span><br><span class="line">            System.out.print(integer + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableDemo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;List&lt;Integer&gt;&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        List&lt;Integer&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">3</span> ; i &lt; <span class="number">100</span> ; i ++) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.sqrt(i) ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                lists.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxj.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        List&lt;Future&lt;List&lt;Integer&gt;&gt;&gt; ints = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            Future&lt;List&lt;Integer&gt;&gt; future = executorService.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">                    List&lt;Integer&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">3</span> ; i &lt; <span class="number">100</span> ; i ++) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.sqrt(i) ; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                                flag = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                            lists.add(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> lists;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ints.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Future&lt;List&lt;Integer&gt;&gt; future : ints) &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="线程池中-submit-和-execute-方法的区别"><a href="#线程池中-submit-和-execute-方法的区别" class="headerlink" title="线程池中 submit() 和 execute() 方法的区别"></a>线程池中 submit() 和 execute() 方法的区别</h3><p><strong>execute()：</strong>只能执行 Runnable 类型的任务。<br><strong>submit()：</strong>可以执行 Runnable 和 Callable 类型的任务。<br>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p><h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><ol><li><p><strong>手动配置线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">createThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">5</span>,                               <span class="comment">// 核心线程数</span></span><br><span class="line">            <span class="number">10</span>,                              <span class="comment">// 最大线程数</span></span><br><span class="line">            <span class="number">60</span>,                              <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),  <span class="comment">// 任务队列大小</span></span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="comment">// 拒绝策略</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Spring Boot自动配置</strong>：在Spring Boot项目中，可通过配置文件设置线程池参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">task:</span></span><br><span class="line">    <span class="attr">execution:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">core-size:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-size:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">queue-capacity:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">keep-alive:</span> <span class="string">60s</span></span><br><span class="line">      <span class="attr">thread-name-prefix:</span> <span class="string">my-task-</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Spring Cloud中的线程池配置</strong>：在微服务架构中，<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%85%8D%E7%BD%AE&spm=1001.2101.3001.7020">线程池配置</a>需考虑服务间调用的特性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AsyncConfig &#123;</span><br><span class="line">    @Bean(name = &quot;asyncExecutor&quot;)</span><br><span class="line">    public ThreadPoolTaskExecutor asyncExecutor() &#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(10);</span><br><span class="line">        executor.setMaxPoolSize(50);</span><br><span class="line">        executor.setQueueCapacity(200);</span><br><span class="line">        executor.setKeepAliveSeconds(300);</span><br><span class="line">        executor.setThreadNamePrefix(&quot;cloud-async-&quot;);</span><br><span class="line">        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        return executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@Async</code>注解启用异步方法：<br><code>@Async</code> 是 Spring 框架提供的注解，用于标记一个方法为异步方法。当调用该方法时，Spring 会将其提交到线程池执行，而不是由调用线程同步执行。这在处理耗时操作时非常有用，可以避免阻塞主线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.scheduling.annotation.Async;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class MyService &#123;</span><br><span class="line">    @Async(&quot;asyncExecutor&quot;)</span><br><span class="line">    public CompletableFuture&lt;String&gt; processAsync() &#123;</span><br><span class="line">        // 异步处理逻辑</span><br><span class="line">        return CompletableFuture.completedFuture(&quot;处理完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h3><p><strong>任务加入时判断的顺序：</strong>核心线程数 、阻塞队列、最大线程数、拒绝策略。</p><p><strong>线程池执原理：</strong> </p><ol><li><p>新加入任务，判断corePoolSize是否到最大值；如果没到最大值就创建核心线程执行新任务，如果到最大值就判断是否有空闲的核心线程；</p></li><li><p>如果有空闲的核心线程，则空闲核心线程执行新任务，如果没空闲的核心线程，则尝试加入FIFO阻塞队列；</p></li><li><p>若加入成功，则等待空闲核心线程将队头任务取出并执行，若加入失败（如队列满了），则判断maximumPoolSize是否到最大值；</p></li><li><p>如果没到最大值就创建非核心线程执行新任务，如果到了最大值就执行丢弃策略，默认丢弃新任务；</p></li><li><p>线程数大于corePoolSize时，空闲线程将在keepAliveTime后回收，直到线程数等于核心线程数。这些核心线程也不会被回收。</p></li></ol><p>实际上线程本身没有核心和非核心的概念，都是靠比较corePoolSize和当前线程数判断一个线程是不是能看作核心线程。</p><p>可能某个线程之前被看作是核心线程，等它空闲了，线程池又有corePoolSize个线程在执行任务，这个线程到keepAliveTime后还是会被回收。</p><h3 id="练习：多线程交替打印A-B-C，每个打印3次"><a href="#练习：多线程交替打印A-B-C，每个打印3次" class="headerlink" title="练习：多线程交替打印A/B/C，每个打印3次"></a>练习：多线程交替打印A/B/C，每个打印3次</h3><p> <strong>核心逻辑：</strong>创建线程，循环加锁，执行以下逻辑：</p><ol><li><strong>临界值判断：</strong>到达临界值后唤醒其他线程并结束锁；</li><li><strong>打印判断：</strong>如果需要打印，则打印、操作原子类（只有打印后才操作原子类，否则就是不满足条件，需要下一步的唤醒等待后，进入下一轮的循环）；</li><li><strong>线程通信：</strong>唤醒、等待。</li></ol><blockquote><p><strong>坑点：</strong></p><ul><li><strong>临界值判断不能放到while里：</strong>防止最后一个线程无法唤醒其他线程，从而导致死锁（其他线程没人唤醒了）。</li><li><strong>必须用线程通信：</strong>防止当前线程释放锁后立刻又拿回锁（因为多线程是CPU随机切换的），从而达不到交替打印的效果</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线交替打印A/B/C</span></span><br><span class="line"><span class="comment">// Object类的wait()和notifyAll()方案、不抽取方法： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>); <span class="comment">// 当前行值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">9</span>; <span class="comment">// 总打印行数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">// 下面创建三个线程可以抽取成一个方法，这里方便理解所以拆开</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// tip：这里条件没必要index.get()&lt;count，因为where不在锁里。</span></span><br><span class="line">            <span class="comment">// 如果临界值判断加到这里，会导致最后一个线程无法唤醒其他线程，从而导致死锁（其他线程没人唤醒了）。</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 1.临界值判断：到达临界值后唤醒其他线程并结束锁；</span></span><br><span class="line">                    <span class="keyword">if</span>(index.get()&gt;=count)&#123;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 2.打印判断：如果需要打印，则打印、操作原子类</span></span><br><span class="line">                    <span class="keyword">if</span> (index.get() % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                        <span class="comment">// 只有打印后才操作原子类，否则就是不满足条件，需要下一步的唤醒等待后，进入下一轮的循环</span></span><br><span class="line">                        index.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 3.线程通信：唤醒、等待</span></span><br><span class="line">                    <span class="comment">// 3.1 唤醒其他线程：不管能不能整除，结束后都唤醒其他线程</span></span><br><span class="line">                    <span class="comment">// notifyAll()唤醒该对象上的所有线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="comment">// 3.2 当前线程等待：Object类的wait()让线程等待，直到其他线程调用notify()或notifyAll()方法唤醒</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程1打印A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(index.get()&gt;=count)&#123;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (index.get() % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                        index.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程2打印B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(index.get()&gt;=count)&#123;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (index.get() % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">                        index.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程3打印C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建和启动线程抽取方法</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>); <span class="comment">// 当前行值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">9</span>; <span class="comment">// 总打印行数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        createAndStartThread(<span class="string">&quot;线程1打印A&quot;</span>, lock, <span class="number">0</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        createAndStartThread(<span class="string">&quot;线程2打印B&quot;</span>, lock, <span class="number">1</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        createAndStartThread(<span class="string">&quot;线程3打印C&quot;</span>, lock, <span class="number">2</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createAndStartThread</span><span class="params">(String threadName, Object lock, <span class="type">int</span> remainder, String output)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (index.get() &gt;= count) &#123;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (index.get() % <span class="number">3</span> == remainder) &#123;</span><br><span class="line">                        System.out.println(output);</span><br><span class="line">                        index.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, threadName).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>其他线程通信方式：</strong></p><ul><li>Object类的wait()和notifyAll()（采用）</li><li><strong>Conditon的await，sign或signAll方法：</strong>创建三个Conditon对象A/B/C，A.await()就是让A线程等待；</li><li><strong>Semaphore的acquire和release方法：</strong>使用三个Semaphore对象，分别初始化为1、0、0，表示A、B、C三个线程的初始许可数。每个线程在打印字母之前，需要调用对应的Semaphore对象的acquire方法，获取许可。每个线程在打印字母之后，需要调用下一个Semaphore对象的release方法，释放许可。</li></ul></blockquote><hr><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>当多个线程访问共享资源时，若不采取同步措施，可能导致数据不一致或其他异常。常见的线程安全问题包括： </p><ul><li><strong>竞态条件</strong>（<code>Race Condition</code>）：多个线程竞争同一资源导致结果不确定。 </li><li><strong>内存可见性</strong>：一个线程修改了共享变量，其他线程可能无法立即看到最新值。 </li><li><strong>指令重排序</strong>：编译器或处理器为优化性能而重新排序指令，可能影响多线程执行顺序。</li></ul><p><strong>线程安全：</strong>程序在多线程环境下可以持续进行正确的处理，不会产生数据竞争（例如死锁）和不一致的问题。<strong>解决方案</strong>：原子类、volatile、锁、线程安全的集合 </p><p><strong>线程安全的解决方案：</strong>按照资源占用情况由轻到重排列：</p><ul><li><strong>原子类：</strong>如<code>AtomicInteger</code>、<code>AtomicLong</code>等，具有原子操作特征（化学中原子是最小单位、不可分割）的类，只能保证单个共享变量的线程安全</li><li><strong>volatile：</strong>只能保证单个共享变量的线程安全</li><li><strong>锁：</strong>可以保证临界区内的多个共享变量线程安全。</li></ul><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>原子类是具有原子操作特征（化学中原子是最小单位、不可分割）的类，原子是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p><p>在java.util.concurrent.atomic包下，有一系列“Atomic”开头的类，统称为原子类。例如AtomicInteger替代int ，底层采用CAS原子指令实现，内部的存储值使用volatile修饰，因此多线程之间是修改可见的。</p><p>以AtomicInteger为例，某线程调用该对象的incrementAndGet()方式自增时采用CAS尝试修改它的值，若此时没有其他线程操作该值便修改成功否则反复执行CAS操作直到修改成功。</p><blockquote><p><strong>CAS：</strong>不断对变量进行原子性比较和交换，从而解决单个变量的线程安全问题。比较内存中值和预期值，如果相等则交换，如果不相等就代表被其他线程改了则重试。 </p></blockquote><p><strong>AtomicInteger常用方法：</strong>  </p><ul><li>构造方法：<ul><li>AtomicInteger (): 创建一个初始值为0的 AtomicInteger。</li><li>AtomicInteger(int initialValue): 创建一个初始值为 initialValue 的 AtomicInteger。</li><li>获取和设置：<ul><li>int get(): 获取当前的值。</li><li>void set(int newValue): 设置为 newValue。</li><li>int getAndSet(int newValue): 获取当前值，并设置为 newValue。 </li></ul></li></ul></li><li><strong>原子更新：</strong><ul><li> boolean compareAndSet(int expect, int update): 如果当前值等于 expect，则更新为 update。</li><li>int getAndIncrement(): 以原子方式将当前值加1，返回的是旧值。</li><li>int incrementAndGet(): 以原子方式将当前值加1，返回的是新值。</li><li>int getAndDecrement(): 以原子方式将当前值减1，返回的是旧值。</li><li>int decrementAndGet(): 以原子方式将当前值减1，返回的是新值。</li><li>int getAndAdd(int delta): 以原子方式将当前值加上 delta，返回的是旧值。</li><li>int addAndGet(int delta): 以原子方式将当前值加上 delta，返回的是新值。</li></ul></li><li><strong>其他方法：</strong> <ul><li> int getAndUpdate(IntUnaryOperator updateFunction): 获取当前值，并按更新函数计算新值设置。</li><li>int updateAndGet(IntUnaryOperator updateFunction): 按更新函数计算新值设置，并返回新值。</li><li>int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction): 获取当前值，并按累加函数计算新值设置。</li><li>int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction): 按累加函数计算新值设置，并返回新值。 </li></ul></li></ul><p><strong>验证原子类的线程安全：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 创建10个线程，分别对atomicInteger进行操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    atomicInteger.incrementAndGet();</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞主线程1s，保证10个线程执行完毕</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(atomicInteger);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行之后，可以看到原子类正常加到100000，而num没有</span></span><br></pre></td></tr></table></figure><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>volatile是一个关键字，被volatile声明的变量存在共享内存中，所有线程要读取、修改这个变量，都是从内存中读取、修改，并且修改操作是原子性的，所以它能保证线程安全。</p><p><strong>volatile特性：</strong></p><ul><li><strong>有序性：</strong>被volatile声明的变量之前的代码一定会比它先执行，而之后的代码一定会比它慢执行。底层是在生成字节码文件时，在指令序列中插入内存屏障防止指令重排序。</li><li><strong>可见性：</strong>一旦修改变量则立即刷新到共享内存中，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的工作空间中读取。每个线程自己的工作空间用于存放堆栈（存方法的参数和返回地址）和局部变量。</li><li><strong>原子性：</strong>volatile变量不能保证完全的原子性，只能保证单次的读/写操作具有原子性（在同一时刻只能被一个线程访问和修改），自增减、复合操作（+=,/=等）则不具有原子性。这也是和synchronized的区别。</li></ul><p><strong>读写内存语义：</strong></p><ul><li><strong>写内存语义：</strong>当写一个volatile变量时，JMM（Java内存模型）会把该线程本地内存中的共享变量的值刷新到主内存中。</li><li><strong>读内存语义：</strong>当读一个volatile变量时，JMM会把该线程本地内存置为无效,使其从主内存中读取共享变量。</li></ul><p><strong>有序性实现机制：</strong></p><p>volatile有序性是通过内存屏障来实现的。内存屏障就是在编译器生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p><strong>机器指令：</strong>JVM包括类加载子系统、运行时数据区、执行引擎。 执行引擎负责将字节码指令转为操作系统能识别的本地机器指令。</p><p><strong>指令重排序：</strong>处理器为了提高运算速度会对指令重排序，重排序分三种类型：编译器优化重排序、处理器指令级并行重排序、内存系统重排序。 </p><ul><li><strong>编译器优化的重排序：</strong>编译器在不改变单线程程序的语义前提下，可以重新安排语句的执行顺序。</li><li><strong>指令级并行的重排序：</strong>现在处理器采用了指令集并行技术，将多条指令重叠执行。如果不存在依赖性，处理器可以改变语句对应的机器指令的执行顺序。</li><li><strong>内存系统的重排序：</strong>由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>加锁的方式有两种，分别是synchronized关键字和Lock接口（在JUC包下）。</p><p><strong>synchronized锁</strong>是互斥锁，可以作用于实例方法、静态方法、代码块，能够保证同一个时刻只有一个线程执行该段代码，保证线程安全。 在执行完或者出现异常时自动释放锁。synchronized锁基于对象头和Monitor对象，在1.6之后引入轻量级锁、偏向锁等优化。</p><p><strong>lock锁</strong>接口可以通过lock、unlock方法锁住一段代码，Lock实现类都是基于AQS实现的。Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">// ToDo: handle exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System. out.println(“释放锁<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    lock. unlock();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><ol><li><strong>Collections工具类：</strong>Collections工具类的synchronizedXxx()方法<strong>，</strong>将ArrayList等集合类包装成线程安全的集合类。</li><li><strong>古老api：</strong>java.util包下性能差的古老api，如Vector、Hashtable</li><li><strong>降低锁粒度的并发容器：</strong>JUC包下Concurrent开头的、以降低锁粒度来提高并发性能的容器，如ConcurrentHashMap。</li><li><strong>复制技术实现的并发容器：</strong>JUC包下以CopyOnWrite开头的、采用写时复制技术实现的并发容器，如CopyOnWriteArrayList。 </li></ol><h2 id="分布式场景下的线程安全"><a href="#分布式场景下的线程安全" class="headerlink" title="分布式场景下的线程安全"></a>分布式场景下的线程安全</h2><p>在分布式系统中，仅靠JVM级别的同步机制无法保证线程安全，需引入分布式锁：</p><ol><li><p><strong>Redis分布式锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;distributed_lock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RELEASE_SCRIPT</span> <span class="operator">=</span> </span><br><span class="line">        <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;   return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisLock</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">(String requestId, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(LOCK_KEY, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">releaseLock</span><span class="params">(String requestId)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(RELEASE_SCRIPT, <span class="number">1</span>, LOCK_KEY, requestId);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1L</span>.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ZooKeeper分布式锁</strong>：使用<code>Apache Curator</code>框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZookeeperLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed_lock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> InterProcessMutex lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZookeeperLock</span><span class="params">(String zkConnectString)</span> &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(</span><br><span class="line">            zkConnectString, </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">        );</span><br><span class="line">        client.start();</span><br><span class="line">        lock = <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, LOCK_PATH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        lock.acquire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>多条语句共享数据时，多线程程序会出现<strong>数据安全问题</strong>。</p><p><strong>线程同步：</strong>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态。</p><p>Java主要通过加锁的方式实现线程同步,而锁有两类,分别是synchronized关键字和Lock接口（在JUC包下）。具体见<a href="#%E9%94%81">锁</a></p><p><strong>对比线程安全和线程同步：</strong>线程同步是实现线程安全的一种手段</p><ul><li><strong>线程安全：</strong>程序在多线程环境下可以持续进行正确的处理，不会产生数据竞争（例如死锁）和不一致的问题。解决方案：原子类、volatile、锁、线程安全的集合</li><li><strong>线程同步：</strong>确保多个线程正确、有序地访问共享资源。解决方案：锁</li></ul><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>同步代码块作用在代码块上,则需要在关键字后面的小括号里,显式指定锁对象，例如this、Xxx.class。</p><p>同步代码块简单来说就是将一段代码用一把锁给锁起来, 只有获得了这把锁的线程才访问, 并且同一时刻, 只有一个线程能持有这把锁, 这样就保证了同一时刻只有一个线程能执行被锁住的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步对象) &#123;</span><br><span class="line">    <span class="comment">//多条语句操作共享数据的代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步代码块的好处：</strong>解决了多线程的数据安全问题</p><p><strong>弊端：</strong>线程很多时，每个线程都会去判断锁，这是很耗费资源和时间的。例如，共有100张票，三个窗口卖票，通过加锁防止超卖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTicket</span> <span class="variable">sellTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><ol><li><p>作用在静态方法上,则锁是当前类的Class对象。</p></li><li><p>作用在普通方法上,则锁是当前的实例（this）。</p></li></ol><p><strong>非静态同步方法的锁对象为this</strong>。下面代码是相同功能的同步方法和同步代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁的粒度是当前对象</span></span><br><span class="line"><span class="comment">// 方法1：实例方法，使用this对象锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sellTicket1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：实例方法，使用this对象锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sellTicket2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 锁的粒度是整个类：</span></span><br><span class="line"><span class="comment">// 静态同步方法的锁对象为：类名.class。下面代码是相同功能的同步方法和同步代码块 </span></span><br><span class="line"><span class="comment">// 方法3：静态方法，使用类对象锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sellTicket3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">        tickets--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4：静态方法，使用类对象锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sellTicket4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SellTicket.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="异步执行时保证事务有效性"><a href="#异步执行时保证事务有效性" class="headerlink" title="异步执行时保证事务有效性"></a>异步执行时保证事务有效性</h1><p>Spring的事务管理基于线程绑定的<code>TransactionSynchronizationManager</code>，而异步方法会在独立线程中执行，导致事务上下文丢失。</p><h2 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a><strong>问题根源</strong></h2><p>Spring事务依赖于线程上下文传递事务信息。当使用<code>@Async</code>时，方法在新线程中执行，与调用线程不在同一个事务上下文： </p><ol><li><strong>事务管理器失效</strong>：新线程没有绑定事务上下文。</li><li><strong>数据库连接丢失</strong>：每个线程使用独立的数据库连接。 </li><li><strong>异常回滚失效</strong>：异步线程的异常无法触发调用线程的事务回滚。</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="独立事务（推荐）"><a href="#独立事务（推荐）" class="headerlink" title="独立事务（推荐）"></a><strong>独立事务</strong>（推荐）</h3><ul><li><p>为每个异步方法创建独立的事务，适用于可容忍部分失败的场景（如批量处理）</p></li><li><p><strong>特点</strong>：</p><ul><li>每个异步任务独立提交/回滚</li><li>适合批量处理大量数据，部分失败不影响整体</li></ul></li><li><p><strong>配置示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line">    <span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span>  <span class="comment">// 创建新事务</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">processData</span><span class="params">(Long recordId)</span> &#123;</span><br><span class="line">        <span class="comment">// 数据库操作</span></span><br><span class="line">        repository.updateStatus(recordId, <span class="string">&quot;PROCESSING&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务逻辑</span></span><br><span class="line">            complexProcessing(recordId);</span><br><span class="line">            repository.updateStatus(recordId, <span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            repository.updateStatus(recordId, <span class="string">&quot;FAILED&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;处理失败&quot;</span>, e);  <span class="comment">// 触发当前事务回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a><strong>事件驱动架构</strong></h3><ul><li><p>将异步操作转为事件，主线程提交事务后再处理事件，确保数据一致性。</p></li><li><p><strong>特点</strong>：</p><ul><li>事务提交后才触发异步处理</li><li>适合耗时操作不影响主线程事务的场景</li></ul></li><li><p><strong>实现步骤</strong>：</p><ul><li><p><strong>定义事件</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataProcessEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long recordId;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataProcessEvent</span><span class="params">(Long recordId)</span> &#123; <span class="built_in">this</span>.recordId = recordId; &#125;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>发布事件（在事务内）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createAndProcessData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建记录（事务内）</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">recordId</span> <span class="operator">=</span> repository.save(<span class="keyword">new</span> <span class="title class_">Record</span>()).getId();</span><br><span class="line">        <span class="comment">// 发布事件（事务提交后触发）</span></span><br><span class="line">        eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">DataProcessEvent</span>(recordId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>异步监听事件</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataProcessListener</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDataProcessEvent</span><span class="params">(DataProcessEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 异步处理（无事务）</span></span><br><span class="line">        processData(event.getRecordId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="手动管理事务（高级）"><a href="#手动管理事务（高级）" class="headerlink" title="手动管理事务（高级）"></a><strong>手动管理事务</strong>（高级）</h3><ul><li><p>在异步方法中手动获取和管理事务，适用于强一致性要求的场景。 </p></li><li><p><strong>特点</strong>：</p><ul><li>完全控制事务边界</li><li>代码复杂度高，需谨慎处理异常</li></ul></li><li><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManualTransactionService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionDefinition transactionDefinition;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">processWithManualTx</span><span class="params">(Long recordId)</span> &#123;</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(transactionDefinition);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 数据库操作</span></span><br><span class="line">            repository.updateStatus(recordId, <span class="string">&quot;PROCESSING&quot;</span>);</span><br><span class="line">            complexProcessing(recordId);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 手动提交事务</span></span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 手动回滚事务</span></span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;处理失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="补偿事务（最终一致性）"><a href="#补偿事务（最终一致性）" class="headerlink" title="补偿事务（最终一致性）"></a><strong>补偿事务</strong>（最终一致性）</h3><ul><li><p>通过补偿机制保证最终一致性，适用于分布式系统</p></li><li><p><strong>特点</strong>：</p><ul><li>保证最终一致性，而非强一致性</li><li>适合跨服务、跨系统的操作</li></ul></li><li><p><strong>实现方案</strong>： </p><ul><li><strong>记录操作日志</strong>：在主事务中记录所有操作。 </li><li><strong>异步执行</strong>：调用外部服务或执行复杂逻辑。 </li><li><strong>补偿逻辑</strong>：若异步操作失败，根据日志执行反向操作</li></ul></li><li><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompensationService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrderWithCompensation</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建订单（主事务）</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">savedOrder</span> <span class="operator">=</span> orderRepository.save(order);</span><br><span class="line">        <span class="comment">// 2. 记录补偿日志（主事务）</span></span><br><span class="line">        compensationLogRepository.save(<span class="keyword">new</span> <span class="title class_">CompensationLog</span>(</span><br><span class="line">            savedOrder.getId(), <span class="string">&quot;CREATE_ORDER&quot;</span>, savedOrder</span><br><span class="line">        ));</span><br><span class="line">        <span class="comment">// 3. 异步处理库存、支付等（无事务）</span></span><br><span class="line">        asyncService.processOrderAsync(savedOrder.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrderAsync</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 扣减库存、调用支付等操作</span></span><br><span class="line">            inventoryService.debitStock(orderId);</span><br><span class="line">            paymentService.processPayment(orderId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 触发补偿逻辑</span></span><br><span class="line">            compensationService.rollbackOrder(orderId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="最佳实践总结"><a href="#最佳实践总结" class="headerlink" title="最佳实践总结"></a>最佳实践总结</h2><ol><li><strong>优先使用独立事务</strong>：为每个异步任务创建独立事务，通过状态跟踪失败记录。 </li><li><strong>避免长事务</strong>：将耗时操作移出事务，减少锁持有时间。 </li><li><strong>使用可靠消息队列</strong>：如<code>RabbitMQ、Kafka</code>，确保事件不丢失。 </li><li><strong>实现幂等性</strong>：异步操作需支持重试（如<code>唯一索引、状态校验</code>）。 </li><li><strong>监控与告警</strong>：记录异步任务状态，及时发现并处理失败。</li></ol><h2 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><ol><li><p><strong>错误配置传播行为</strong>： </p><ul><li><p>使用<code>Propagation.REQUIRED</code>（默认）会导致异步方法加入调用者的事务（但实际上无法加入）。</p></li><li><p>必须使用<code>Propagation.REQUIRES_NEW</code>创建新事务。  </p></li></ul></li><li><p><strong>忽略异步异常</strong>： </p><ul><li>未捕获的异常会导致事务无法回滚。 </li><li>确保在异步方法中处理异常或使用<code>CompletableFuture</code>的异常处理。</li></ul></li><li><p><strong>过度依赖同步事务</strong>：</p><ul><li>在分布式系统中，强一致性难以实现，考虑最终一致性方案</li></ul></li></ol><h2 id="多线程如何保证事务一致性"><a href="#多线程如何保证事务一致性" class="headerlink" title="多线程如何保证事务一致性"></a>多线程如何保证事务一致性</h2><p>‌在多线程环境下保证事务一致性主要通过编程式事务管理、线程资源隔离、分布式事务框架及数据库锁机制等方案实现‌，具体选择需根据业务场景和技术架构灵活适配。‌‌</p><h3 id="核心实现方案：编程式事务管理‌"><a href="#核心实现方案：编程式事务管理‌" class="headerlink" title="核心实现方案：编程式事务管理‌"></a><strong>核心实现方案</strong>：编程式事务管理‌</h3><ol><li><p>通过代码手动控制事务边界，将多个子线程操作纳入统一事务管理框架</p></li><li><p>使用Spring的<code>TransactionTemplate</code>在子线程中执行数据库操作。 </p></li><li><p>主线程等待所有子线程执行完成后统一提交或回滚事务。‌‌‌‌</p></li><li><p><strong>示例代码结构</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Future&lt;?&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">    futures.add(executor.submit(() -&gt;</span><br><span class="line">        transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            <span class="comment">// 事务操作</span></span><br><span class="line">        &#125;);</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查所有子线程结果后决策提交/回滚 (自己判断是提交还是回滚)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="‌关键技术支撑‌"><a href="#‌关键技术支撑‌" class="headerlink" title="‌关键技术支撑‌"></a>‌<strong>关键技术支撑</strong>‌</h3><ul><li><p><strong>事务资源隔离机制</strong>‌</p><ul><li><p>突破默认的<code>ThreadLocal</code>绑定模式，通过自定义<code>TransactionSynchronizationManager</code>实现跨线程Connection共享。‌‌</p></li><li><p>使用<code>@Transactional(propagation = REQUIRES_NEW)</code>创建独立事务上下文。   </p></li></ul></li><li><p><strong>并发控制策略</strong>‌</p><ul><li><p><strong>数据库锁机制</strong>：结合<code>SELECT ... FOR UPDATE</code>实现行级锁，配合事务隔离级别（如<code>REPEATABLE_READ</code>）防止脏写。‌‌</p></li><li><p><strong>Java同步工具</strong>：采用<code>CountDownLatch</code>确保所有子线程就绪后统一提交。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> DataSource dataSource ; </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">cdl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>) ;</span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">txRollback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>) ;</span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      person.setAge(<span class="number">1</span>);</span><br><span class="line">      person.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">      transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          result = jdbcTemplate.update( <span class="string">&quot;insert into t_person (age, name) values (?, ?)&quot;</span>, </span><br><span class="line">                                       person.getAge(), person.getName() );</span><br><span class="line">          <span class="comment">// TODO</span></span><br><span class="line">          <span class="comment">// log.info(1 / 0) ;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          txRollback.set(<span class="literal">true</span>); <span class="comment">// 当发生异常后将状态该为 true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cdl.countDown(); <span class="comment">// 计数减一</span></span><br><span class="line">          cdl.await(); <span class="comment">// 继续等待其它线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (txRollback.get()) &#123; <span class="comment">// 如果回滚状态为 true 说明有线程发生了异常，需要事务回滚</span></span><br><span class="line">          status.setRollbackOnly(); <span class="comment">// 标记当前事务回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;%s Insert Operator Result: %d 次%n&quot;</span>, Thread.currentThread().getName(), result);</span><br><span class="line">        <span class="keyword">return</span> result ;</span><br><span class="line">      &#125;) ;</span><br><span class="line">    &#125;) ;</span><br><span class="line">    transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      person.setAge(<span class="number">2</span>);</span><br><span class="line">      person.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        result = jdbcTemplate.update(<span class="string">&quot;insert into t_person (age, name) values (?, ?)&quot;</span>, </span><br><span class="line">                                     person.getAge(), person.getName()) ;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>) ;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        txRollback.set(<span class="literal">true</span>) ; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cdl.countDown() ;</span><br><span class="line">        cdl.await() ;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (txRollback.get()) &#123;</span><br><span class="line">        status.setRollbackOnly(); <span class="comment">// 回滚</span></span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">&quot;%s Insert Operator Result: %d 次%n&quot;</span>, Thread.currentThread().getName(), result);</span><br><span class="line">      <span class="keyword">return</span> result ;</span><br><span class="line">    &#125;) ;</span><br><span class="line">    cdl.await() ;</span><br><span class="line">    log.info(<span class="string">&quot;Operator Complete...&quot;</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>分布式锁</strong>：通过<code>Redis</code>或<code>ZooKeeper</code>实现跨进程锁协调。‌‌</p></li></ul></li></ul><h3 id="扩展方案选型‌-：分布式事务补偿‌"><a href="#扩展方案选型‌-：分布式事务补偿‌" class="headerlink" title="扩展方案选型‌ ：分布式事务补偿‌"></a>扩展方案选型‌ ：分布式事务补偿‌</h3><ul><li><p><strong>Saga模式：</strong>拆分事务为多个可补偿的本地事务。</p></li><li><p><strong>TCC（Try-Confirm-Cancel）模式：</strong>通过预留资源保证最终一致性。</p></li><li><p>整合<code>Seata</code>等分布式事务框架实现全局事务管理</p></li></ul>]]></content>
    
    
    <summary type="html">多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA I/O流</title>
    <link href="https://southernfish.github.io/2025/07/24/java/java-base-7-io/"/>
    <id>https://southernfish.github.io/2025/07/24/java/java-base-7-io/</id>
    <published>2025-07-24T00:20:36.000Z</published>
    <updated>2025-07-24T08:57:02.601Z</updated>
    
    <content type="html"><![CDATA[<p>java.io是Java编程语言中处理输入输出（I/O）操作的核心类库，定义了数据流模型与多种接口，支持文件操作、网络通信及对象序列化等功能。其通过流（Stream）机制实现数据传输，涵盖字节流、字符流与缓冲处理等设计，为Java标准库的重要组成部分。</p><p>该库将数据源抽象为输入流和输出流，按传输方向分为输入型与输出型，按单位分为字节流（8位字节处理）与字符流（16位字符处理）。功能上包含直接操作设备的节点流和增强功能的过滤流，核心类包括InputStream、OutputStream、Reader、Writer四个抽象类及其子类，形成分层结构的I/O处理体系。</p><p>原文链接：<a href="https://blog.csdn.net/qq_40991313/article/details/137256095">https://blog.csdn.net/qq_40991313/article/details/137256095</a></p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p><strong>什么是I/O流</strong></p><p>I/O流（Input/Output Stream），即输入（Input）和输出（Output）流，是用于处理输入和输出操作的数据流。在Java中，一般用IO流写一个文件输出到操作系统中，或者从操作系统中输入一个文件进行读取。</p><p><strong>IO流分类：</strong></p><p><strong>按数据流向</strong>：</p><ul><li><strong>输入流</strong>：读数据。</li><li><strong>输出流</strong>：写数据。</li></ul><p><strong>按数据类型</strong>：</p><ul><li><strong>字节流</strong>：它处理单元为1个字节（byte），操作字节和字节数组，存储的是二进制文件。<ul><li><strong>使用场景</strong>：在Java中，一般用IO流写一个文件输出到操作系统中，或者从操作系统中输入一个文件进行读取。如果是<strong>音频文件、图片、歌曲</strong>，就用字节流（1byte = 8位）。</li></ul></li><li><strong>字符流</strong>：它处理的单元为2个字节的<code>Unicode</code>字符，<strong>分别操作字符、字符数组或字符串</strong>，字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的。<ul><li><strong>使用场景</strong>：如果是关系到中文（文本）的，用字符流（1Unicode = 2字节 = 16位）；</li></ul></li></ul><p><strong>字节流</strong></p><p><strong>输入字节流</strong> (<code>InputStream</code>)</p><ul><li>**<code>FileInputStream</code>**：基本的文件输入流，用于读取字节文件（如图片、视频）中的数据。</li><li>**<code>FilterInputStream</code>**：过滤输入流，是所有过滤输入流的父类。用于对数据进行解密、校验、转换、过滤、缓存。因为它是抽象类，所以我们一般用它的子类：<ul><li>**<code>BufferedInputStream</code>**：相比于FileInputStream，它的读取性能会高很多。因为它多了一个缓冲区数组（在内存中），在第一次调用read()读取数据时，他会将数据尽可能多的填满缓冲区，这样再次read()时会优先从缓冲区中读，而不用直接在磁盘中读。我们知道内存读写性能是远高于磁盘的，所以它更快。默认缓冲区大小是8192字节，即8KB，超过这个容量就必须在磁盘读取了。</li><li>**<code>DataInputStream</code>**：与相比于FileInputStream，它的读取性能会高很多。因为它直接提供了读取Java中基本数据类型的方法，如 readInt()、readDouble()、readUTF() 等，而不需要额外的解析步骤。</li><li>**<code>SocketInputStream</code>**：网络输入流。</li></ul></li></ul><p><strong>输出字节流</strong> (<code>OutputStream</code>)</p><ul><li>**<code>FileOutputStream</code>**：基本的文件输出流，用于将数据写入字节文件（如图片、视频）。</li><li>**<code>FilterOutputStream</code>**：过滤输出流，是所有过滤输出流的父类，提供了基本的输出流功能。用于压缩数据、加密数据等。因为它是抽象类，所以我们一般用它的子类：<ul><li>**<code>BufferedOutputStream</code>**：为输出流提供缓冲功能，提高写入效率。每次写入数据时，先写进缓冲区，缓冲区满了会自动刷新写入到磁盘中，也可以手动调用flash()方法刷新。</li><li>**<code>DataOutputStream</code>**：性能高，因为它直接提供了写入Java中基本数据类型的方法，如 wirteInt()，而不需要额外的转换步骤。</li><li><strong>SocketOutputStream</strong>；</li></ul></li></ul><p><strong>字符流</strong></p><p>字符流是以字符为单位处理数据的流，分为输入字符流和输出字符流。</p><p><strong>输入字符流</strong> (<code>Reader</code>)</p><ul><li>**<code>InputStreamReader</code>**：输入流读取类，用于将字节流转换为字符流再读取字符数据。使用系统默认字符编码。</li><li>**<code>FileReader</code>**：文件读取类，用于直接从文件中读取字符数据。可以指定字符编码来解码字节流。</li><li>**<code>BufferedReader</code>**：为字符输入流提供缓冲功能，提高读取效率。</li></ul><p><strong>输出字符流</strong> (<code>Writer</code>)</p><ul><li>**<code>OutputStreamWriter</code>**：将字符流转换为字节流。</li><li>**<code>FileWriter</code>**：用于将字符数据写入文件。</li><li>**<code>BufferedWriter</code>**：为字符输出流提供缓冲功能，提高写入效率。</li></ul><hr><h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>File类是用于表示文件和目录路径名的类。</p><blockquote><p> <strong>注意</strong>：File类封装的不是真正的文件，只是路径。所以File类可以对文件进行<strong>创建、删除、重命名、修改时间、文件大小</strong>等操作，但不能对文件里的数据进行读取或者写入，它一般作为输入输出流的构造参数，指明文件的路径。</p></blockquote><p><strong>创建文件示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\1\\2.txt&quot;</span>);</span><br><span class="line">      <span class="comment">//只创建已存在文件夹“D://1”下的2.txt。若“D://1”不存在，报错IOException: 系统找不到指定的路径。</span></span><br><span class="line">        System.out.println(f.createNewFile());  <span class="comment">//true，当目标位置已存在同名文件则创建失败输出false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>文件默认路径：</strong></p><p>在当前包内IO流，使用File类创建文件时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>默认存的位置是在项目文件夹下，而不是包文件夹下。</p><p><strong>关于路径斜杠和反斜杠：</strong></p><p>路径斜杠可以是//,/,\,不能是\，因为它是转义符。 </p><p>正斜杠“/”和“//”都可以，反斜杠必须“\”，因为“\”会ASCII转义，“\”在字符串里才是“\”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://1//1.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/1/2.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\1\\3.txt&quot;</span>);</span><br><span class="line"><span class="comment">// File file3 = new File(&quot;D:\1\4.txt&quot;);          // 这样会报错，单个反斜杠会进行转义</span></span><br><span class="line">System.out.println(file.createNewFile());       <span class="comment">// true</span></span><br><span class="line">System.out.println(file1.createNewFile());       <span class="comment">// true</span></span><br><span class="line">System.out.println(file2.createNewFile());       <span class="comment">// true</span></span><br><span class="line"><span class="comment">// System.out.println(file3.createNewFile());   // false </span></span><br></pre></td></tr></table></figure><p><strong>查看当前路径：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">&quot;user.dir&quot;</span>));    <span class="comment">//D:\workspace\java\test</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>常用方法</strong>：</p><ul><li>**<code>boolean createNewFile()</code>**： 当且仅当具有该名称的文件尚不存在时，原子地（保证线程安全）创建一个由该抽象路径名命名的新空文件。抽象路径名指的是构造 File 对象时传递的路径名字符串。创建File对象时，构造参数的路径并不一定真实存在，可能是虚拟的、等待通过createNewFile等方法进行创建。</li><li><strong><code>boolean mkdir()</code></strong> ：创建目录。如果父目录不存在，则不会创建目录，并返回 false。</li><li>**<code>boolean mkdirs()</code>**： 创建目录。如果父目录不存在，它会一并创建。</li><li>**<code>boolean delete()</code>**： 删除文件或目录。成功删除文件或目录时返回 true，否则返回 false。注意如果要删除目录，该目录必须为空，否则会返回false。</li><li>**<code>boolean isDirectory()</code>**： 测试File是否为目录。</li><li>**<code>boolean isFile()</code>**： 测试File是否为文件。</li><li>**<code>boolean exists()</code>**： 测试File是否真实存在。</li><li>**<code>String getAbsolutePath()</code>**： 返回绝对路径名字符串。</li><li>**<code>String getPath()</code>**： 将抽象路径名。也就是构造 File 对象时传递的路径名字符串，可能是绝对路径，也可能是相对路径。</li><li>**<code>String getName()</code>**： 返回由此抽象路径名表示的文件或目录的名称。</li><li>**<code>String[] list()</code>**： 返回对应目录下所有文件的文件名数组。</li><li>**<code>File[] listFiles()</code>**： 返回对应目录下所有文件的File文件数组。</li></ul><p><strong>举例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1\\2\\3&quot;</span>);</span><br><span class="line">    <span class="comment">// mkdirs()如果父目录不存在，它会一并创建。</span></span><br><span class="line">    System.out.println(f.mkdirs());</span><br><span class="line">    <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1\\2\\3\\4.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(f1.createNewFile());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建失败&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// listFiles()是路径下的所有文件组成的数组，若f文件会报错</span></span><br><span class="line">    File[] f2 = f.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File file : f2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            System.out.println(file.getName() + <span class="string">&quot;,&quot;</span> + file.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="comment">// 删除目录时要确保目录下没文件。</span></span><br><span class="line">    <span class="comment">// f1.delete();</span></span><br><span class="line">    <span class="comment">// f.delete();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 4.txt,1\2\3\4.txt</span></span><br></pre></td></tr></table></figure><hr><h1 id="字节流的超类"><a href="#字节流的超类" class="headerlink" title="字节流的超类"></a>字节流的超类</h1><h2 id="字节输出流OutputStream"><a href="#字节输出流OutputStream" class="headerlink" title="字节输出流OutputStream"></a>字节输出流OutputStream</h2><p><strong>概念：</strong> </p><p>Java中的 InputStream 和 OutputStream 都是 io 包中面向字节操作的顶级<strong>抽象类</strong>。所有字节流类都是他们的子类。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250722203841265.png" alt="image-20250722203841265"></p><p><strong>子类</strong>：</p><ul><li><strong>网络数据传输</strong>：SocketOutputStream</li><li><strong>文件操作</strong>：<code>FileOutputStream</code></li><li><strong>字节数据操作</strong>：DataOutputStream</li></ul><p><strong>常用api</strong>： </p><ul><li><strong><code>void close()</code></strong> ：关闭此输出流并释放与此流相关联的任何系统资源。</li><li><strong><code>void flush()</code></strong> ：刷新此输出流并强制任何缓冲的输出字节被写出。</li><li><strong><code>void write(byte[] b)</code></strong> ：将 b.length 字节从指定的字节数组写入此输出流。</li><li><strong><code>void write(byte[] b, int off, int len)</code></strong> ： 从指定的字节数组写入 len 个字节，从偏移 off 开始输出到此输出流。</li><li><strong><code>abstract void write(int b)</code></strong> ：将指定的字节写入此输出流。</li></ul><h2 id="字节输入流InputStream"><a href="#字节输入流InputStream" class="headerlink" title="字节输入流InputStream"></a>字节输入流InputStream</h2><p><strong>概念</strong>： </p><p>Java中的 InputStream 和 OutputStream 都是 io 包中面向字节操作的顶级抽象类，关于java同步 io字节流的操作都是基于这两个的。</p><p><strong>子类</strong>：</p><ul><li><strong>网络数据传输</strong>：SocketInputStream</li><li><strong>文件操作</strong>：FileInputStream</li><li><strong>字节数据操作</strong>：DataInputStream。与相比于FileInputStream，它的读取性能会高很多。因为它直接提供了读取Java中基本数据类型的方法</li><li><strong>带缓冲区的输入流</strong>：BufferedInputStream</li></ul><p><strong>常用api</strong>： </p><ul><li>**<code>abstract int  read()</code>**：从输入流读取数据的下一个字节。</li><li>**<code>int  read(byte[] b)</code>**：从输入流读取一些字节数，并将它们存储到缓冲区 b，返回值为长度 。</li><li>**<code>int  read(byte[] b, int off, int len)</code>**：从输入流读取最多 len字节的数据到一个字节数组。</li></ul><hr><h1 id="字节文件流"><a href="#字节文件流" class="headerlink" title="字节文件流"></a>字节文件流</h1><h2 id="文件输出流FileOutputStream"><a href="#文件输出流FileOutputStream" class="headerlink" title="文件输出流FileOutputStream"></a>文件输出流FileOutputStream</h2><p>基本的文件输出流，用于将数据写入字节文件（如图片、视频）。输出流是写数据，把数据输出到文件里。</p><p><strong>构造方法</strong>：</p><ul><li>**<code>FileOutputStream(File file)</code>**：创建文件输出流以写入由指定的 File对象表示的文件。</li><li>**<code>FileOutputStream(String name)</code>**：创建文件输出流以指定的名称写入文件</li><li>**<code>FileOutputStream(String name, boolean append)</code>**：创建文件输出流以指定的名称写入文件。append默认是false，即彻底覆盖写入。append为true时是追加写入。</li><li><strong><code>FileOutputStream(File file, boolean append)</code></strong>: 使用文件对象创建文件输出流，并选择是否追加数据。</li></ul><p><strong>写操作方法</strong></p><ul><li><strong><code>void write(int b)</code></strong>: 将指定的字节写入输出流。</li><li><strong><code>void write(byte[] b)</code></strong>: 将字节数组 b 写入输出流。</li><li><strong><code>void write(byte[] b, int off, int len)</code></strong>: 将字节数组 b 中从偏移量 off 开始的 len 个字节写入输出流。</li></ul><p><strong>关闭方法</strong></p><ul><li><strong><code>void close()</code></strong>: 关闭文件输出流并释放与此流有关的所有系统资源。</li></ul><p>示例，将“abcde” 写入1.txt文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        FileOutputStream fos=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://1.txt&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] b =<span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">            fos.write(b);</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="comment">// 实际开发不建议用e.printStackTrace()打日志，而是logger.error()</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 判空，防止创建流的时候就失败，进入catch中</span></span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到D盘下多了个1.txt，内容是abcde</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：写数据时的换行符，windows系统下是\r\n，linux的换行是\n，mac换行\r.</p></blockquote><h2 id="文件输入流-FileInputStream"><a href="#文件输入流-FileInputStream" class="headerlink" title="文件输入流 FileInputStream"></a>文件输入流 FileInputStream</h2><p>基本的文件输入流，用于读取字节文件（如图片、视频）中的数据。</p><p><strong>常用方法</strong>： </p><ul><li>**<code>FileInputStream(File file)</code>**：构造方法，创建一个 FileInputStream，它读取从指定File对象的文件。</li><li>**<code>FileInputStream(String name)</code>**：构造方法，创建一个 FileInputStream，它读取从指定文件路径名的文件</li><li>**<code>int read()</code>**：读取一个字节的数据。返回的int是读取字节的个数，如果到达流的末尾，则返回值 -1。</li><li>**<code>int read(byte[] b)</code>**：读取一定字节（0~b.length，具体长度取决于是否读到了末尾）的数据，将其存储在缓冲区数组 b 中。返回读取的字节数，如果没有可用的字节，则返回 -1。</li><li>**<code>int read(byte[] b, int off, int len)</code>**：最多读取 len 个字节的数据到一个字节数组。尝试读取最多 len 个字节的数据到缓冲区 b 中，从 off 位置开始。返回读取的字节数，如果没有可用的字节，则返回 -1。</li></ul><p><strong>代码示例</strong>：通过文件输入输出流复制图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://1.png&quot;</span>);</span><br><span class="line">        FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://2.png&quot;</span>);</span><br><span class="line">        <span class="type">byte</span> []b=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len=fis.read(b);</span><br><span class="line">        <span class="keyword">while</span>(len!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(b,<span class="number">0</span>,len);len=fis.read(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果就是 D盘多了一个2.png图片</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>扩展</strong></p><p>使用maven后可以导入commons-io包，直接通过工具类复制。</p><p> 使用IOUtils.copy(fis,os)进行流的复制（推荐）</p><p>(1)pom.xml添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2)调用工具类方法实现复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fis:输入流</span></span><br><span class="line"><span class="comment">//os:输出流</span></span><br><span class="line">IOUtils.copy(fis,os);</span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="字节缓冲流（推荐）"><a href="#字节缓冲流（推荐）" class="headerlink" title="字节缓冲流（推荐）"></a>字节缓冲流（推荐）</h1><p><strong>特点</strong>： </p><ul><li><p>字节缓冲流仅提供缓冲区，真正读写数据还要靠基本字节流对象操作。</p></li><li><p>字节缓冲流读写数据比基本字节流快很多，因为它有个存在内存中的字节数组，作为缓冲区，读写时先在缓冲区中读写，性能比直接在磁盘中读写快很多。</p></li></ul><h2 id="字节缓冲输出流BufferedOutputStream"><a href="#字节缓冲输出流BufferedOutputStream" class="headerlink" title="字节缓冲输出流BufferedOutputStream"></a>字节缓冲输出流BufferedOutputStream</h2><p>**<code>BufferedOutputStream</code>**是一个带缓冲区的输出流，它跟FileOutputStream一样，都继承自OutputStream抽象类。</p><p>与普通的OutputStream相比，BufferedOutputStream在写入数据时使用了一个存在内存中的中间缓冲区。当向BufferedOutputStream写入数据时，数据首先会被写入到缓冲区，而不是直接写入到目标输出流（即最终的目标输出，比如文件、网络连接、控制台）。当缓冲区满了、手动刷新flash()、手动关闭close()时，BufferedOutputStream会将缓冲区中的数据一次性写入到目标输出流中。</p><p>这种缓冲机制可以减少实际的物理写操作，从而提高写操作的效率。因为磁盘IO是很慢的，而内存IO是很快的，相比于每次写入一个字节到目标输出流，将多个字节一次性写入会更加高效，磁盘IO次数有效减少。</p><p><strong>构造方法</strong></p><ul><li><strong><code>BufferedOutputStream(OutputStream out)</code></strong> ：创建一个新的缓冲输出流，以将数据写入指定的底层输出流。</li><li>**<code>BufferedOutputStream(OutputStream out, int size)</code>**：创建一个新的缓冲输出流，以将数据写入指定的底层输出流，并具有指定的缓冲区大小。</li></ul><p><strong>写入方法</strong></p><ul><li>**<code>void write(int b)</code>**：将指定的字节写入此缓冲输出流。</li><li>**<code>void write(byte[] b, int off, int len)</code>**：将字节数组中的指定字节写入此缓冲输出流。</li></ul><p><strong>刷新方法</strong></p><ul><li><p>**<code>void flush()</code>**：刷新此缓冲输出流，将任何缓冲的输出字节写出到底层输出流。<br>关闭方法</p></li><li><p>**<code>void close()</code>**：关闭此输出流并释放与此流相关联的任何系统资源。在关闭流之前，会刷新它。<br><strong>构造方法</strong></p></li><li><p>**<code>BufferedInputStream(InputStream in)</code>**：创建一个新的缓冲输入流，以从指定的底层输入流读取数据。</p></li><li><p>**<code>BufferedInputStream(InputStream in, int size)</code>**：创建一个新的缓冲输入流，以从指定的底层输入流读取数据，并具有指定的缓冲区大小。</p></li></ul><p><strong>读取方法</strong></p><ul><li>**<code>int read()</code>**：从输入流中读取数据的下一个字节。</li><li>**<code>int read(byte[] b, int off, int len)</code>**：从输入流中将最多 len 个字节的数据读入一个字节数组。</li><li>**<code>int read(byte[] b)</code>**：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</li></ul><p><strong>跳过和可用</strong></p><ul><li>**<code>long skip(long n)</code>**：跳过和丢弃输入流中最多 n 个字节的数据。</li><li>**<code>int available()</code>**：返回可以不受阻塞地从输入流中读取的剩余字节数。阻塞（Blocking） 是指程序在等待某些操作完成（例如读取数据、写入数据、获取网络响应等）时停止执行其他操作，直到该操作完成。</li></ul><p><strong>标记和重置</strong></p><ul><li>**<code>void mark(int readlimit)</code>**：在输入流中标记当前位置。</li><li>**<code>void reset()</code>**：将流重新定位到上次调用 mark 方法时的位置。</li><li>**boolean markSupported()**：测试输入流是否支持 mark 和 reset 方法。</li></ul><p><strong>关闭</strong></p><ul><li>**<code>void close()</code>**：关闭输入流并释放与此流相关联的任何系统资源。</li></ul><h2 id="字节缓冲输入流BufferedInputStream"><a href="#字节缓冲输入流BufferedInputStream" class="headerlink" title="字节缓冲输入流BufferedInputStream"></a>字节缓冲输入流BufferedInputStream</h2><p>BufferedInputStream是字节缓冲输入流。</p><p>相比于FileInputStream，它的读取性能会高很多。因为它多了一个缓冲区数组（在内存中），在第一次调用read()读取数据时，他会将数据尽可能多的填满缓冲区，这样再次read()时会优先从缓冲区中读，而不用直接在磁盘中读。</p><p>内存读写性能是远高于磁盘的，所以它更快。默认缓冲区大小是8192字节，即8KB，超过这个容量就必须在磁盘读取了。</p><p><strong>代码示例</strong>：使用缓冲流复制图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://1.png&quot;</span>));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://2.png&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">// 读取和写入字节数据</span></span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果就是 D盘多了一个2.png图片</span></span><br></pre></td></tr></table></figure><hr><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p><strong>字符流的继承关系：</strong></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250722203910877.png" alt="image-20250722203910877"></p><h2 id="字符流的编码和解码"><a href="#字符流的编码和解码" class="headerlink" title="字符流的编码和解码"></a>字符流的编码和解码</h2><p><strong>为什么要用字符流</strong></p><p>因为字节流编码不支持汉字。 计算机底层存储数据都是通过二进制的字节文件存储的，所以我们看到的文件信息都是有多少字节、多少KB、多少MB，文本文件需要设置编码是UTF-8、GBK等类型。</p><blockquote><p>GBK编码，一个汉字占用2个字节。<br>utf-8编码，一个汉字占用3个字节。</p></blockquote><p>一个英文字符占一个字节，一个汉字占多个字节，因为字节流都是单字节读取，所以字节流在读中文的时候有可能会读到半个中文,造成乱码，所以这就引入了字符流。</p><p><strong>字符流对字节文件进行编码和解码</strong>：</p><ul><li><strong>编码</strong>：字符输出流将字符编码为字节写入字节文件</li><li><strong>解码</strong>：字符输入流从字节文件解码出字符。 </li></ul><p>这样可以保证写入文件时，写入的格式是字节文件，读取文件时，将字节文件转为字符文件。</p><blockquote><p><strong>字符串的编码解码方法：</strong> 字符串的编码和解码是指在不同字符集之间转换字符数据的过程。</p><ul><li><strong>编码：</strong>将字符串转换为字节数组</li><li><strong>解码：</strong>将字节数组转换为字符串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = str.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 解码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">bytesToString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(bytesToString);</span><br><span class="line">    <span class="comment">// 如果编码设置的不对，设为GBK就会乱码：浣犲ソ</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">bytesToString2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    System.out.println(bytesToString2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 你好</span></span><br><span class="line"><span class="comment">// 浣犲ソ</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="字符输入输出流"><a href="#字符输入输出流" class="headerlink" title="字符输入输出流"></a>字符输入输出流</h2><h3 id="字符输出流OutputStreamWriter"><a href="#字符输出流OutputStreamWriter" class="headerlink" title="字符输出流OutputStreamWriter"></a>字符输出流OutputStreamWriter</h3><p><strong>OutputStreamWriter</strong>：将字符编码为字节，再写入字节文件。</p><p>OutputStreamWriter 是 Java 中一个桥接器类，用于将字符流转换为字节流。它使用指定的字符编码将字符写入字节流。它可以用于写入文件、网络流等。</p><blockquote><p> 桥接器类：指充当中介，用于连接或转换两种不兼容类型的类 </p></blockquote><p><strong>构造方法</strong>：构造参数都有OutputStream，因为要讲字符流编码成字节流OutputStream</p><ul><li><strong><code>OutputStreamWriter(OutputStream out)</code></strong>: 创建一个使用默认字符编码的 OutputStreamWriter。</li><li><strong><code>OutputStreamWriter(OutputStream out, String charsetName)</code></strong>: 创建一个使用指定字符编码的 OutputStreamWriter。</li><li><strong><code>OutputStreamWriter(OutputStream out, Charset cs)</code></strong>: 创建一个使用指定 Charset 的 OutputStreamWriter。</li><li>OutputStreamWriter(OutputStream out, CharsetEncoder enc): 创建一个使用指定 CharsetEncoder 的 OutputStreamWriter。</li></ul><p><strong>写入方法</strong></p><ul><li><strong><code>void write(int c)</code></strong>: 写入单个字符。</li><li><strong><code>void write(char[] cbuf, int off, int len)</code></strong>: 写入字符数组的一部分。</li><li><strong><code>void write(char[] cbuf)</code></strong>: 写入字符数组。</li><li><strong><code>void write(String str, int off, int len)</code></strong>: 写入字符串的一部分。</li><li><strong><code>void write(String str)</code></strong>: 写入整个字符串。</li></ul><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建文件输出流</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://output.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建使用 UTF-8 编码的 OutputStreamWriter</span></span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 写入字符串</span></span><br><span class="line">    osw.write(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    osw.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    osw.write(<span class="string">&quot;这是一个测试。&quot;</span>);</span><br><span class="line">    <span class="comment">// 刷新和关闭流</span></span><br><span class="line">    osw.flush();</span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 文件中会出现以下两行</span></span><br><span class="line"><span class="comment">// Hello, World!</span></span><br><span class="line"><span class="comment">// 这是一个测试。</span></span><br></pre></td></tr></table></figure><h3 id="字符输入流InputStreamReader"><a href="#字符输入流InputStreamReader" class="headerlink" title="字符输入流InputStreamReader"></a>字符输入流InputStreamReader</h3><p><code>InputStreamReader</code> 是 Java 中一个桥接器类，用于从字节文件解码出字符。因为计算机底层存储的数据都是二进制的字节码文件，所以我们要读取文本文件，就需要将其根据编码解析成字符流，才能读取文件中的内容。</p><p><strong>构造方法</strong>：构造参数都有InputStream，因为InputStreamReader作用是将字节文件转为字符</p><ul><li><strong><code>InputStreamReader(InputStream in)</code></strong>: 使用默认字符集将给定的输入流 in 转换为字符流。</li><li><strong><code>InputStreamReader(InputStream in, Charset cs)</code></strong>: 使用指定的字符集 cs 将给定的输入流 in 转换为字符流。</li></ul><p><strong>读取字符</strong>：</p><ul><li><strong><code>int read()</code></strong>: 读取单个字符并返回其 Unicode 编码，如果到达流的末尾，则返回 -1。</li><li><strong><code>int read(char[] cbuf, int offset, int length)</code></strong>: 字符读入数组 cbuf，从 offset 位置开始存放，最多读取 length 个字符。</li></ul><p><strong>其他方法</strong>：</p><ul><li><strong><code>void mark(int readAheadLimit)</code></strong>: 标记流的当前位置，最多可以在流中读取 readAheadLimit 个字符。</li><li><strong><code>void reset()</code></strong>: 将流重置到最后一次标记的位置。</li><li><strong><code>boolean markSupported()</code></strong>: 测试此输入流是否支持标记功能。</li><li><strong><code>void close()</code></strong>: 关闭流并释放与之关联的所有系统资源。</li></ul><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建文件输入流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://output.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建使用 UTF-8 编码的 InputStreamReader</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 读取文件内容并输出</span></span><br><span class="line">    <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">while</span> ((length = isr.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭流</span></span><br><span class="line">    isr.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// Hello, World!</span></span><br><span class="line"><span class="comment">// 这是一个测试。</span></span><br><span class="line"><span class="comment">// 进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h2 id="FileWriter和FileReader：简化字符流"><a href="#FileWriter和FileReader：简化字符流" class="headerlink" title="FileWriter和FileReader：简化字符流"></a>FileWriter和FileReader：简化字符流</h2><p><code>FileWriter</code>是OutputStreamWriter的子类，<code>FileReader</code>是InputStreamReader的子类。这两个类的作用是简化字符输入输出流的构造方法。</p><p>看看FileReader的源码，可以看到它继承了InputStreamReader类，并且只有三个构造方法，这几个构造方法封装了<code>super(new FileInputStream(fileName或者file));</code>，从而可以让我们直接将文件名或者File对象作为构造参数，而不需要再麻烦的创建一个FileInputStream对象，再将它作为构造参数创建InputStreamReader对象了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.io;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(FileDescriptor fd)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面两段代码效果是一样的，都是创建字符输入流，明显FileReader更方便：</p><p><strong>InputStreamReader创建字符输入流方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文件输入流</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://output.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 创建使用 UTF-8 编码的 InputStreamReader</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>FileReader创建字符输入流方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;output.txt&quot;</span>)</span><br></pre></td></tr></table></figure></blockquote><p>除了构造方法外，其他方法和他们的父类一致，这里不再赘述。</p><p><strong><code>FileReader</code>构造方法</strong></p><ul><li><strong><code>FileReader(String fileName)</code></strong>: 创建一个新的 FileReader，读取指定文件。</li><li><strong><code>FileReader(File file)</code></strong>: 创建一个新的 FileReader，读取指定的 File 对象。</li></ul><p><strong><code>FileWriter</code>构造方法</strong></p><ul><li><p><strong><code>FileWriter(String fileName)</code></strong>: 创建一个使用默认字符编码的 FileWriter，将数据写入指定文件。如果文件不存在，则创建新文件；如果文件存在，则覆盖原有内容。</p></li><li><p><strong><code>FileWriter(String fileName, boolean append)</code></strong>: 创建一个使用默认字符编码的 FileWriter，将数据写入指定文件。若 append 为 true，则在文件末尾追加内容，而不是覆盖。</p></li><li><p><strong><code>FileWriter(File file)</code></strong>: 创建一个 FileWriter，将数据写入指定的 File 对象。</p></li><li><p><strong><code>FileWriter(File file, boolean append)</code></strong>: 创建一个 FileWriter，将数据写入指定 File 对象，并选择是否在文件末尾追加。</p></li></ul><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 写文件</span></span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">    writer.write(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    writer.write(<span class="string">&quot;\nWelcome to Java FileWriter.&quot;</span>);</span><br><span class="line">    writer.close();</span><br><span class="line">    <span class="comment">// 读文件</span></span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">    <span class="type">int</span> character;</span><br><span class="line">    <span class="keyword">while</span> ((character = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) character);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// Hello, World!</span></span><br><span class="line"><span class="comment">// Welcome to Java FileWriter</span></span><br></pre></td></tr></table></figure><h2 id="字符缓冲流（推荐）"><a href="#字符缓冲流（推荐）" class="headerlink" title="字符缓冲流（推荐）"></a>字符缓冲流（推荐）</h2><p><code>BufferedWriter</code>和<code>BufferedReader</code>是带缓冲区的字符流，读写效率相对于普通的字符流OutputStreamWriter和InputStreamReader会高很多。</p><p><strong>为什么字符缓冲流读写效率高？</strong></p><p>原因跟字节缓冲流类似，它维护了默认容量8192容量的char类型数组，在写入时会将字符先写进这个存于内存的数组中，等容量满了之后，会一次性将数据写进磁盘，而不是每次写数据都进行磁盘IO一次，有效降低了读写次数，又因为磁盘的IO效率是远低于内存IO效率的，所以字符缓冲流的写效率高。</p><p><code>BufferedReader</code>也一个道理，它在第一次读的时候将数据尽可能多的塞满char类型数组，下次读的时候优先从char数组中读，读的效率肯定比直接在磁盘中读的效率高很多。</p><p><strong>BufferedWriter</strong></p><p><strong>构造方法</strong></p><ul><li><p>BufferedWriter(Writer out): 创建一个使用默认大小输出缓冲区的缓冲字符输出流。默认值8192足够大，可用于大多数用途。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedWriter</span><span class="params">(Writer out)</span> &#123;</span><br><span class="line">    <span class="comment">// 没指定缓冲区容量时，默认是最大长度8192</span></span><br><span class="line">    <span class="built_in">this</span>(out, defaultCharBufferSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BufferedWriter(Writer out, int sz): 创建一个使用指定大小输出缓冲区的缓冲字符输出流。参数sz可以指定缓冲区大小，或者可以接受默认大小8192。</p></li></ul><p><strong>常用方法</strong></p><ul><li><p><strong><code>void write(int c)</code></strong>: 写入单个字符。</p></li><li><p><strong><code>void write(char[] cbuf, int off, int len)</code></strong>: 写入字符数组的某一部分。</p></li><li><p><strong><code>void write(String s, int off, int len)</code></strong>: 写入字符串的某一部分。</p></li><li><p><strong><code>void newLine()</code></strong>: 写入一个行分隔符。</p></li><li><p>```java<br>public void newLine() throws IOException {</p><pre><code>// lineSeparator是本类的一个属性，在构造函数执行时获取当前操作系统的行分隔符并赋值write(lineSeparator);</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **`void flush()`: 刷新该流的缓冲区。**每次写完bw.flush();可以将缓冲字符写入文本，虽然close()也能刷新后关闭，但加上flush更保险。</span><br><span class="line"></span><br><span class="line">- **`void close()`**: 关闭该流，但要先刷新它。</span><br><span class="line"></span><br><span class="line">**BufferedReader**</span><br><span class="line"></span><br><span class="line">**构造方法**：可以指定缓冲区大小，或者可以使用默认大小8192。 默认值足够大，可用于大多数用途。</span><br><span class="line"></span><br><span class="line">- **`BufferedReader(Reader in)`**: 创建一个使用默认大小输入缓冲区的缓冲字符输入流。</span><br><span class="line">- **`BufferedReader(Reader in, int sz)`**: 创建一个使用指定大小输入缓冲区的缓冲字符输入流。</span><br><span class="line"></span><br><span class="line">**常用方法**</span><br><span class="line"></span><br><span class="line">- **`int read()`**: 读取单个字符。</span><br><span class="line">- **`int read(char[] cbuf, int off, int len)`**: 将字符读入数组的某一部分。</span><br><span class="line">- **`String readLine()`**: 读取一个文本行。</span><br><span class="line">- **`boolean ready()`**: 判断输入流是否准备好被读取。</span><br><span class="line">- **`void close()`**: 关闭该流并释放与之关联的所有资源。</span><br><span class="line"></span><br><span class="line">**代码示例**： </span><br><span class="line"></span><br><span class="line">BufferedWriter写入三行文字，然后BufferedReader读出来：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 定义文件路径</span><br><span class="line">    String filePath = &quot;example.txt&quot;;</span><br><span class="line">    // 使用 BufferedWriter 写文件</span><br><span class="line">    // 使用JDK7的异常处理形式，就不需要finally里关闭流对象了，出异常后系统会自动关闭</span><br><span class="line">    try (BufferedWriter bw = new BufferedWriter(new FileWriter(filePath))) &#123;</span><br><span class="line">        bw.write(&quot;你好&quot;);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(&quot;世界&quot;);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(&quot;宇宙&quot;);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        // 实际场景建议用logger.error()，而不是e.printStackTrace()</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用 BufferedReader 读文件</span><br><span class="line">    try (BufferedReader br = new BufferedReader(new FileReader(filePath))) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = br.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 输出结果</span><br><span class="line">// 你好</span><br><span class="line">// 世界</span><br><span class="line">// 宇宙</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>BufferedReader实现读取键盘录入：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 InputStreamReader 包装 System.in，再使用 BufferedReader 包装 InputStreamReader</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">    <span class="comment">// 提示用户输入</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请输入一些文字：&quot;</span>);</span><br><span class="line">    <span class="comment">// 读取用户输入并输出</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;你输入的是：&quot;</span> + input);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭 BufferedReader</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// 请输入一些文字:</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 你输入的是:123</span></span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="I-O流JDK7异常处理"><a href="#I-O流JDK7异常处理" class="headerlink" title="I/O流JDK7异常处理"></a>I/O流JDK7异常处理</h1><p><strong>I/O流的异常处理：</strong></p><p>JDK7之前的常规做法：try…catch…finally</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类名 变量名) &#123;</span><br><span class="line">    <span class="comment">// 异常的处理代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 执行所有清除操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK7改进方案：try-with-resources</p><blockquote><p>因为之前方案，每次都要finally中再次判空、try-catch区关闭IO流，太过麻烦，所以JDK7引入了新的异常处理形式，可以<strong>把流对象放到try()的括号里</strong>，这样就不需要再写finally了，系统会自动释放资源</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (定义流对象) &#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类名 变量名) &#123;</span><br><span class="line">    <span class="comment">// 异常的处理代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动释放资源</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>代码示例:</strong></p><p>使用字符缓冲流写文件后，读文件：</p><p><strong>JDK7之前格式：</strong></p><p>异常处理后，需要在finally里关闭流对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"> <span class="comment">// 使用 BufferedWriter 写文件</span></span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath));</span><br><span class="line">        bw.write(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;Welcome to Java BufferedWriter.&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;This is an example of BufferedWriter.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 实际场景建议用logger.error()，而不是e.printStackTrace()</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bw != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 关闭流时也需要异常处理，防止关闭失败</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// 使用 BufferedReader 读文件</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>JDK7格式：</strong></p><p>异常处理后，不需要再写finally了，系统会自动释放资源，可以看到代码变简洁很多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 定义文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="comment">// 使用 BufferedWriter 写文件</span></span><br><span class="line">    <span class="comment">// 使用JDK7的异常处理形式，就不需要finally里关闭流对象了，出异常后系统会自动关闭</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath))) &#123;</span><br><span class="line">        bw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;世界&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;宇宙&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 实际场景建议用logger.error()，而不是e.printStackTrace()</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 BufferedReader 读文件</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath))) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="特殊操作流"><a href="#特殊操作流" class="headerlink" title="特殊操作流"></a>特殊操作流</h1><h2 id="标准输入输出流：System-in和System-out"><a href="#标准输入输出流：System-in和System-out" class="headerlink" title="标准输入输出流：System.in和System.out"></a>标准输入输出流：System.in和System.out</h2><p> <strong>什么是标准输入输出流？</strong></p><ul><li>标准输出流：System.out。用于指定输出到控制台的数据。</li><li>标准输入流：System.in。用于读取用户在控制台输入的数据。</li></ul><h3 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a><strong>标准输出流</strong></h3><p><strong>基本介绍</strong></p><p>标准输出流：System.out。用于往控制台输出数据。</p><p><strong>常用方法：</strong></p><ul><li><strong>print()</strong>: 打印数据到控制台，不换行。</li><li><strong>println()</strong>: 打印数据到控制台，并换行。</li><li><strong>printf()</strong>: 使用指定的格式字符串和参数将数据格式化并打印到控制台。 </li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 输出 &quot;Hello, &quot; 不换行</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        <span class="comment">// 输出 &quot;World!&quot; 并换行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用格式化输出</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;数字: %d&quot;</span>, <span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用格式化符号<br>使用System.out、String.format可以对字符串格式化。</p><p>常用格式化符号</p><blockquote><p>%d：十进制整数<br>%f：十进制浮点数<br>%e：科学计数法表示的十进制数<br>%g：根据值的大小，自动选择使用普通计数法或科学计数法<br>%s：字符串<br>%c：字符<br>%b：布尔值（true 或 false）<br>%x：整数的十六进制表示<br>%o：整数的八进制表示<br>%t 或 %T：日期和时间（需要与日期时间转换符配合使用）<br>%%：文字百分号（% 本身）</p></blockquote><p>日期和时间转换符</p><blockquote><p>%tF：年-月-日（yyyy-MM-dd）<br>%tD：月/日/年（MM/dd/yy）<br>%tT：时:分:秒（HH:mm:ss）<br>%tR：时:分（HH:mm）<br>%tY：年（四位数）<br>%ty：年（两位数）<br>%tm：月（两位数）<br>%td：日（两位数）<br>%tH：小时（24 小时制，两位数）<br>%tI：小时（12 小时制，两位数）<br>%tM：分钟（两位数）<br>%tS：秒（两位数）<br>%tp：小写上午或下午标记（am 或 pm）<br>%tZ：时区</p></blockquote><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14159</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 格式化输出整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;整数：%d\n&quot;</span>, number);</span><br><span class="line">        <span class="comment">// 格式化输出浮点数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;浮点数（两位小数）：%.2f\n&quot;</span>, pi);</span><br><span class="line">        <span class="comment">// 格式化输出字符串</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;名字：%s\n&quot;</span>, name);</span><br><span class="line">        <span class="comment">// 格式化输出布尔值</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;布尔值：%b\n&quot;</span>, flag);</span><br><span class="line">        <span class="comment">// 格式化输出十六进制整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;十六进制：%x\n&quot;</span>, number);</span><br><span class="line">        <span class="comment">// 格式化输出八进制整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;八进制：%o\n&quot;</span>, number);</span><br><span class="line">        <span class="comment">// 格式化输出百分比</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">percentage</span> <span class="operator">=</span> <span class="number">0.85</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;百分比：%.2f%%\n&quot;</span>, percentage * <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 左对齐和宽度格式化</span></span><br><span class="line">        <span class="comment">// %-10s 用于左对齐并指定宽度为10的字符串</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;左对齐：%-10s|\n&quot;</span>, name);</span><br><span class="line">        <span class="comment">// 右对齐和宽度格式化</span></span><br><span class="line">        <span class="comment">// %10s 用于右对齐并指定宽度为10的字符串</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;右对齐：%10s|\n&quot;</span>, name);</span><br><span class="line">        <span class="comment">// 格式化输出带符号的数值</span></span><br><span class="line">        <span class="comment">// %+d 用于格式化带符号的整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;带符号的整数：%+d\n&quot;</span>, -number);</span><br><span class="line">        <span class="comment">// %+.2f 用于格式化带符号的浮点数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;带符号的浮点数：%+.2f\n&quot;</span>, pi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h3><p><strong>基本介绍</strong></p><p><strong>标准输入流</strong>：System.in。用于读取用户在控制台输入的数据。</p><p><strong>用法：</strong></p><ul><li><strong>字符输入流：</strong>作为构造参数传入字符输入流InputStreamReader中，例如new InputStreamReader(System.in)。</li><li><strong>Scanner：</strong>因为用字符输入流包装太麻烦，所以Java提供了一个工具类实现键盘录入，即Scanner类，专门用于从各种输入源（如控制台、文件、字符串等）读取输入。</li></ul><p><strong>常用方法：</strong></p><ul><li><strong>read()</strong>: 从输入流中读取一个字节。</li><li><strong>read(byte[] b)</strong>: 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</li><li><strong>read(byte[] b, int off, int len)</strong>: 从输入流中将 len 个字节的数据读入一个字节数组。</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 BufferedReader 包装 System.in</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">    <span class="comment">// 提示用户输入</span></span><br><span class="line">    System.out.print(<span class="string">&quot;随便输入一些文字: &quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取用户输入</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="comment">// 输出用户输入</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你输入的内容是： &quot;</span> + text);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 实际场景不建议e.printStackTrace()，而是logger.error()</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Scanner类</strong></p><p>因为用字符输入流包装太麻烦，所以Java提供了一个工具类实现键盘录入，即Scanner类，专门用于从各种输入源（如控制台、文件、字符串等）读取输入。</p><p><strong>构造方法：</strong></p><ul><li><strong>Scanner(InputStream source):</strong> 构造一个新的 Scanner，生成的扫描器从指定的输入流读取数据。用于读取用户在控制台输入的数据。一般用System.in，即标准输入流，用于读取用户在控制台输入的数据。</li><li>Scanner(File source): 构造一个新的 Scanner，生成的扫描器从指定的文件读取数据。</li><li>Scanner(String source): 构造一个新的 Scanner，生成的扫描器从指定的字符串读取数据。</li></ul><p><strong>常用方法：</strong></p><ul><li><strong>nextInt()、nextDouble()、next()：</strong>获取输入的整数、浮点数、字符串（不包括空格）等。</li><li><strong>nextLine()：</strong>获取一行输入（包括空格）。</li><li><strong>hasNextInt()、hasNextDouble()、hasNext()：</strong> 判断下一个输入是否为整数、浮点数、字符串。</li><li><strong>useDelimiter(String pattern)：</strong> 设置分隔符模式，用于指定不同类型数据之间的分隔符，默认为空白字符。</li><li><strong>close()：</strong>关闭扫描器。</li></ul><blockquote><p><strong>示例：</strong></p><p>从控制台输入整数、浮点数、字符串，并在控制台打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象，关联 System.in（标准输入流）</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 从控制台读取整数</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter an integer: &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;You entered: &quot;</span> + intValue);</span><br><span class="line">        <span class="comment">// 从控制台读取浮点数</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter a double: &quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;You entered: &quot;</span> + doubleValue);</span><br><span class="line">        <span class="comment">// 从控制台读取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringValue</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;You entered: &quot;</span> + stringValue);</span><br><span class="line">        <span class="comment">// 关闭 Scanner 对象</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><h3 id="字节打印流：PrintStream"><a href="#字节打印流：PrintStream" class="headerlink" title="字节打印流：PrintStream"></a>字节打印流：PrintStream</h3><p>PrintStream用于将不同的数据类型格式化为字节并写入到输出流，支持自动刷新。它只负责输出数据，不负责读取数据。</p><p>一般情况下，打印数据用System.out.printf()就可以了，PrintStream适用于需要重定向输出的场景，例如将打印的结果写入一个文件中。</p><blockquote><p> <strong>重定向输出：</strong>将输出重定向到文件、网络流或其他输出目标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>))) &#123;</span><br><span class="line">        ps.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        ps.println(<span class="number">123</span>);</span><br><span class="line">        ps.println(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>构造方法：</strong></p><ul><li><strong>PrintStream(OutputStream out):</strong> 创建一个新的打印流，使用指定的输出流。</li><li>PrintStream(OutputStream out, boolean autoFlush): 创建一个新的打印流，使用指定的输出流和自动刷新设置。</li><li>PrintStream(OutputStream out, boolean autoFlush, String encoding): 创建一个新的打印流，使用指定的输出流、自动刷新设置和字符编码。</li><li>PrintStream(String fileName): 创建一个新的打印流，使用指定的文件名。</li><li>PrintStream(String fileName, String encoding): 创建一个新的打印流，使用指定的文件名和字符编码。</li><li>PrintStream(File file): 创建一个新的打印流，使用指定的文件。</li><li>PrintStream(File file, String encoding): 创建一个新的打印流，使用指定的文件和字符编码。</li></ul><p><strong>常用方法：</strong></p><ul><li>void print(String s): 打印字符串。</li><li>PrintStream printf(String format, Object… args): 使用指定的格式字符串和参数，将格式化的字符串输出到该流。</li><li>void println(int i): 打印整数并换行。</li><li>close()：关闭。</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印到控制台：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// true 表示自动刷新</span></span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(System.out, <span class="literal">true</span>);</span><br><span class="line">    ps.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    ps.println(<span class="string">&quot;Hello, World2!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印到文件：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    PrintStream pw= <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pw = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    pw.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    pw.println(<span class="number">23</span>);</span><br><span class="line">    pw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符打印流：PrintWriter"><a href="#字符打印流：PrintWriter" class="headerlink" title="字符打印流：PrintWriter"></a>字符打印流：PrintWriter</h3><p>PrintWriter与 PrintStream 类似，都用于打印数据到文件。主要区别是PrintWriter用于打印字符流，而不是字节流，它可以自动处理字符编码。 </p><p><strong>构造方法</strong>：</p><ul><li><p>PrintWriter(OutputStream out): 创建一个新的 PrintWriter，从现有的 OutputStream 输出字符。</p></li><li><p>PrintWriter(OutputStream out, boolean autoFlush): 创建一个新的 PrintWriter，从现有的 OutputStream 输出字符，并指定是否在调用 println、printf 或 format 方法时自动刷新。</p></li><li><p><strong>PrintWriter(Writer out):</strong> 创建一个新的 PrintWriter，从现有的 Writer 输出字符。</p></li><li><p>PrintWriter(Writer out, boolean autoFlush): 创建一个新的 PrintWriter，从现有的 Writer 输出字符，并指定是否在调用 println、printf 或 format 方法时自动刷新。</p></li><li><p><strong>PrintWriter(String fileName):</strong> 创建一个新的 PrintWriter，将输出写入指定的文件。</p></li><li><p>PrintWriter(String fileName, String csn): 创建一个新的 PrintWriter，将输出写入指定的文件，使用给定的字符集。</p></li><li><p>PrintWriter(File file): 创建一个新的 PrintWriter，将输出写入指定的文件。</p></li><li><p>PrintWriter(File file, String csn): 创建一个新的 PrintWriter，将输出写入指定的文件，使用给定的字符集。</p></li></ul><p><strong>常用方法：</strong></p><ul><li>跟PrintStream基本一致，这里不再赘述。 </li></ul><p><strong>代码示例：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//自动刷新true</span></span><br><span class="line">    PrintWriter pw=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//直接写一行加刷新</span></span><br><span class="line">    pw.println(<span class="string">&quot;hello&quot;</span>);        </span><br><span class="line">    pw.println(<span class="number">23</span>);</span><br><span class="line">    pw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列号流和反序列化流"><a href="#序列号流和反序列化流" class="headerlink" title="序列号流和反序列化流"></a>序列号流和反序列化流</h2><h3 id="Serializable-接口和serialVersionUID变量"><a href="#Serializable-接口和serialVersionUID变量" class="headerlink" title="Serializable 接口和serialVersionUID变量"></a>Serializable 接口和serialVersionUID变量</h3><p><strong>序列化和反序列化：</strong></p><ul><li><strong>序列化：</strong>将对象转换为字节流。转为字节流后可以把它写入文件、数据库，或者传输到网络中。</li><li><strong>反序列化：</strong>序列化的逆过程，也就是将字节流转换回对象。</li></ul><p><strong>不参与序列化的字段：</strong>被transient修饰的成员变量不参与序列化。 </p><p>被序列化的类必须实现Serializable接口，并且声明一个成员变量<strong>serialVersionUID</strong>。 </p><p><strong>Serializable 接口：</strong></p><p>用于标记一个类的对象可被序列化。该接口没有任何方法，它仅仅是一个标记，表明实现这个接口的类可以被 Java 的序列化机制处理。 </p><p>若一个类的对象没有实现这个接口，并且他的对象被序列号，则会报错不能序列号异常<code>java.io.NotSerializableException</code></p><p><strong>erialVersionUID变量：</strong></p><ul><li><strong>作用：</strong>serialVersionUID是类的版本号，类型是长整型数值，该字段的主要作用是检查反序列化时类的版本，与序列化时类的版本是否一致。</li><li><strong>私有：</strong>为了保证不同Java编译器实现之间的一致的serialVersionUID值，一个可序列化的类必须声明一个显式的serialVersionUID值，尽量使用private修饰符。</li><li><strong>序列化类必须包含serialVersionUID：</strong>为了保证不同Java编译器实现之间的一致的serialVersionUID值，一个可序列化的类必须声明一个显式的serialVersionUID值，尽量使用private修饰符。</li><li><strong>建议手动指定</strong>：如果实现了Serializable接口，并且没有指定serialVersionUID，编译器会隐式地自动生成一个serialVersionUID，但是建议手动指定，因为默认的serialVersionUID计算对类详细信息非常敏感，从而出现<strong>InvalidClassException</strong>。</li></ul><p><strong>InvalidClassException异常：</strong></p><p>序列化时版本号不匹配，会抛出无效类异常。例如反序列化时类的版本号，与序列化时类的版本号不一致在序列化之后，类的结构发生了变化，例如添加、删除或修改了字段，导致版本号不匹配。</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个可序列号的Dog类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">// ... 其他定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象序列化流：ObjectOutputStream"><a href="#对象序列化流：ObjectOutputStream" class="headerlink" title="对象序列化流：ObjectOutputStream"></a>对象序列化流：ObjectOutputStream</h3><p>序列化流可以将对象转换为字节流，并保存到文件或者传输到网络。</p><p><strong>构造方法：</strong></p><ul><li><strong>ObjectOutputStream(OutputStream out):</strong> 创建一个写入指定 OutputStream 的 ObjectOutputStream。构造参数是FileOutputStream等OutputStream的子类。</li></ul><p><strong>常用方法：</strong></p><ul><li><strong>void writeObject(Object obj):</strong> 将指定的对象写入 ObjectOutputStream。</li><li>void close(): 关闭输出流并释放与此流相关联的所有系统资源。</li><li>void flush(): 刷新输出流，并强制任何缓冲的输出字节被写出。</li></ul><p><strong>代码示例：</strong>被序列化的类使用上一节创建的Dog类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">5</span>, <span class="string">&quot;旺财&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用JDK7的异常捕获，不需要手动关闭流</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dog.txt&quot;</span>))) &#123;</span><br><span class="line">            oos.writeObject(dog);</span><br><span class="line">            System.out.println(<span class="string">&quot;序列化完成：&quot;</span> + dog);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象反序列化流：ObjectInputStream"><a href="#对象反序列化流：ObjectInputStream" class="headerlink" title="对象反序列化流：ObjectInputStream"></a>对象反序列化流：ObjectInputStream</h3><p>ObjectInputStream是序列化的逆过程，也就是将字节流转换回对象。</p><p><strong>构造方法</strong></p><ul><li>ObjectOutputStream(OutputStream out): 创建一个写入指定 OutputStream 的 ObjectOutputStream。</li></ul><p><strong>常用方法</strong></p><ul><li>void writeObject(Object obj): 将指定的对象写入 ObjectOutputStream。</li><li>void close(): 关闭输出流并释放与此流相关联的所有系统资源。</li><li>void flush(): 刷新输出流，并强制任何缓冲的输出字节被写出。</li></ul><p><strong>代码示例：</strong>反序列化上一节创建的dog.txt：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dog.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">&quot;反序列化完成：&quot;</span> + dog);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 反序列化完成:Dog&#123;weight=0,name=&quot;旺财&quot;&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java.io是Java编程语言中处理输入输出（I/O）操作的核心类库，定义了数据流模型与多种接口，支持文件操作、网络通信及对象序列化等功能。其通过流（Stream）机制实现数据传输，涵盖字节流、字符流与缓冲处理等设计，为Java标准库的重要组成部分。&lt;/p&gt;
&lt;p&gt;该库将</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java中的泛型</title>
    <link href="https://southernfish.github.io/2025/07/23/java/java-base-6-generics/"/>
    <id>https://southernfish.github.io/2025/07/23/java/java-base-6-generics/</id>
    <published>2025-07-23T14:58:36.000Z</published>
    <updated>2025-07-23T14:34:27.991Z</updated>
    
    <content type="html"><![CDATA[<p>Java泛型是J2 SE1.5中引入的一个新特性，其本质是参数化类型，也就是说所操作的数据类型被指定为一个参数（type parameter）这种参数类型可以用在<a href="https://baike.baidu.com/item/%E7%B1%BB/6824577?fromModule=lemma_inlink">类</a>、<a href="https://baike.baidu.com/item/%E6%8E%A5%E5%8F%A3/15422203?fromModule=lemma_inlink">接口</a>和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p><p>原文链接：<a href="https://blog.csdn.net/qq_40991313/article/details/137256095">https://blog.csdn.net/qq_40991313/article/details/137256095</a></p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>泛型，即<strong>参数化类型</strong>。泛型的出现是为了<em>统一集合当中的数据类型</em>。可<em>在编译阶段约束操作的数据类型，并进行检查</em><br><strong>参数化类型：</strong>在方法定义时，<em>将方法签名中的形参数据类型设置为参数</em>（可称之为类型参数：尖括号 &lt;&gt; 中的泛型标识，用于指代任何数据类型），调用该方法时再从外部传入一个具体的数据类型和变量。</p><p><strong>泛型的本质</strong></p><p>将类、接口和方法中具体的类型参数化，并且提供了编译时类型安全检测机制。通过使用泛型，可以避免使用Object类导致的类型转换错误和减少了代码的冗余。泛型使用过程中，数据类型被设置为一个参数，<strong>使用时从外部传入一个数据类型</strong>；而一旦传入了具体的数据类型后，<strong>传入变量（实参）的数据类型若不匹配，编译器就会直接报错</strong>。这种参数化类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。<br><strong>细节：</strong>不能写基本数据类型；指定泛型具体类型后，传递数据时可传该类型和其子类类型；若不写泛型，默认是Object。</p><p><strong>使用场景：</strong>定义类、方法、接口的时候，若类型不确定，可定义泛型；<em>若类型不确定，但知道继承体系，可用泛型通配符 ？</em></p><blockquote><p><strong>注意</strong>：泛型不具备继承性，但数据具备继承性 </p></blockquote><p><strong>泛型的标志</strong></p><p>尖括号<code>&lt;&gt;</code>是泛型的标志，例如<code>ArrayList&lt;E&gt;</code>就是一个泛型，<code>&lt;E&gt;</code>将实际的集合元素类型参数化了，这样我们使用时可以指定<code>new ArrayList&lt;String&gt;</code>，将它指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList&lt;E&gt;是标准的类泛型，在使用时指定这个“E”具体是什么</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在使用ArrayList时，尖括号指定&lt;String&gt;，这样它就只能存String类型的元素了</span></span><br><span class="line"><span class="comment">// 一旦存其他类型，就会在代码下面出现红色波浪线，编译期间就报错</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>若不用泛型，而用<code>public class ArrayList&lt;Object&gt;&#123;&#125;</code>方式声明ArrayList，就可往集合里存所有类型的参数，编译不报错，但可读性很差，不知道它具体应存哪些类型，存的类型非业务所需类型时，编译期间不报错，直到生产环境运行时报错，就会出现不好的影响。</p><p><strong>详细介绍：</strong></p><p><strong>泛型</strong>：将具体的类型参数化，是一种编程范式，提供了编译时类型安全检测机制。</p><p>通过使用泛型，可以将数据类型作为参数传递给类、接口或方法，可以在编译时期进行类型检查，避免在运行时期出现类型转换错误。</p><p><strong>泛型的范围</strong>：泛型接口，泛型类（创建对象时再指定具体类型），泛型方法。</p><p><strong>实现方式</strong>：以泛型类举例。只需要在类名后面使用尖括号&lt;&gt;将一个符号或多个符号包裹起来，这样在类里面就可以使用该符号代替具体类型了。使用泛型类时，调用者实际传进来什么类型，编译时就会将泛型符号擦除，替换成这个实际类型。</p><p><strong>泛型标识：</strong>泛型符号可以是任意符号，但我们约定使用<code>T、E、K、V</code>等符号。Java 常见泛型标识及其代表含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T ：代表一般的任何类。</span><br><span class="line">E ：代表 Element 元素的意思，或者 Exception 异常的意思。</span><br><span class="line">K ：代表 Key 的意思。</span><br><span class="line">V ：代表 Value 的意思，通常与 K 一起配合使用。</span><br><span class="line">S ：代表 Subtype 的意思。</span><br></pre></td></tr></table></figure><hr><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><h2 id="泛型参数类型"><a href="#泛型参数类型" class="headerlink" title="泛型参数类型"></a>泛型参数类型</h2><p>我们可以看见，前面 ArrayList<E>，尖括号内是“E”，然后我们可能看见其他泛型尖括号内是“T”，具体是哪个大写字母，其实并没有特定的要求，只是遵循了某些约定俗成的惯例。</p><p><strong>泛型参数类型的惯例</strong>：</p><ul><li>**<code>&lt;E&gt;</code>**：表示元素（Element），通常在集合类中使用。例如，List<E>，Set<E>。</li><li>**<code>&lt;T&gt;</code>**：表示类型（Type），通常在一般类型中使用。例如，Box<T>，Comparable<T>。</li><li>**<code>&lt;K&gt;</code> 和 <code>&lt;V&gt;</code>**：分别表示键（Key）和值（Value），通常在映射（Map）类中使用。例如，Map&lt;K, V&gt;，Entry&lt;K, V&gt;。</li><li>**<code>&lt;N&gt;</code>**：表示数字（Number），在需要表示数字的泛型中使用。</li></ul><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类定义了一个泛型参数，创建对象时给它传入这个参数的实际类型。 <strong>格式：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList简化版</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="comment">// 当前元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 构造方法，初始化数组和大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyList</span><span class="params">()</span> &#123;</span><br><span class="line">        elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[INITIAL_CAPACITY];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素到列表中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前数组容量不足，则扩容</span></span><br><span class="line">        <span class="keyword">if</span> (size == elementData.length) &#123;</span><br><span class="line">            grow();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将元素添加到数组中，并增加元素数量</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定位置的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> E &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查索引是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span> + index + <span class="string">&quot;, Size: &quot;</span> + size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回元素，强制转换为泛型类型</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回当前元素数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩容方法，将数组容量扩大 1.5 倍</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> elementData.length + (elementData.length &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyList&lt;String&gt; myList = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">        myList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        myList.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        myList.add(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素数量: &quot;</span> + myList.size());</span><br><span class="line">        <span class="comment">// 输出: 第一个元素: Hello</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个元素: &quot;</span> + myList.get(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 输出: 第二个元素: World</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第二个元素: &quot;</span> + myList.get(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 输出: 第三个元素: !</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第三个元素: &quot;</span> + myList.get(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 尝试获取索引越界的元素，抛出 IndexOutOfBoundsException</span></span><br><span class="line">        <span class="comment">// System.out.println(myList.get(3));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口和泛型类类似，也是定义了一个泛型参数。不同的点是，泛型接口在被实现或者被继承时需要指定具体类型。</p><p><strong>如果泛型接口的实现类不是泛型</strong>：</p><ul><li>实现泛型接口时，如果没有省略尖括号“&lt;&gt;”，则必须在接口“&lt;&gt;”中指定类型</li><li>实现泛型接口时，如果省略了尖括号“&lt;&gt;”，则默认“&lt;&gt;”内是Object类</li></ul><p><strong>如果泛型接口的实现类是泛型</strong>：</p><ul><li>实现泛型接口时，实现类也必须是泛型类，并且类型与泛型接口保持一致</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口泛型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceName</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 接口中的方法可以使用类型参数T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGen</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果泛型接口的实现类不是泛型，实现泛型接口时，如果没有省略尖括号“&lt;&gt;”，则必须在接口“&lt;&gt;”中指定类型</span></span><br><span class="line"><span class="comment">// 泛型接口实现类必须指定具体类型，否则会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gen</span> <span class="keyword">implements</span> <span class="title class_">IGen</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果泛型接口的实现类不是泛型，实现泛型接口时，如果省略了尖括号“&lt;&gt;”，则默认“&lt;&gt;”内是Object类</span></span><br><span class="line"><span class="comment">// 泛型接口实现类：如果接口省略&lt;&gt;，则默认是Object</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gen</span> <span class="keyword">implements</span> <span class="title class_">IGen</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果参数不是Object，就报错。因为接口了省略&lt;&gt;，默认是IGen&lt;Object&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(Object integer)</span> &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果泛型接口的实现类是泛型，实现泛型接口时，实现类也必须是泛型类，并且类型与泛型接口保持一致</span></span><br><span class="line"><span class="comment">// 泛型接口实现类也是泛型类时，泛型参数类型必须与泛型接口保持一致，用&lt;E&gt;，而不是&lt;T&gt;等</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gen</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">IGen</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>当在一个方法签名中的返回值前面声明了一个 &lt; T &gt; 时，该方法就被声明为一个泛型方法。</p><p>然后返回类型、参数类型都可以用这个<T>，当然也可以不用。<strong>格式：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法泛型</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; 返回类型 方法名(参数类型 parameter) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法1：返回值和参数可以T</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> T &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">fun1</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法1：参数可以是多个，但类型必须都是T</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> T &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">fun2</span><span class="params">(T a,T b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法2：返回值和参数并不一定是T，也可以是具体类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Integer &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">(Integer integer)</span>&#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="comment">// 实参传入String类型</span></span><br><span class="line">        System.out.println(test.fun1(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">        <span class="comment">// 实参传入int类型</span></span><br><span class="line">        System.out.println(test.fun1(<span class="number">1111</span>));</span><br><span class="line">        <span class="comment">// 实参传入多个String类型</span></span><br><span class="line">        System.out.println(test.fun2(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>));</span><br><span class="line">        test.fun3(<span class="number">2222</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h1><p>类型通配符跟泛型参数<code>&lt;T&gt;、&lt;E&gt;</code>等类似，用于表示不确定的类型，不同的点在于：</p><ul><li><strong>类型参数</strong>：用于声明泛型类、泛型接口或泛型方法。声明时是未知类型，使用时擦除成具体的类型（在编译时泛型擦除）。</li><li><strong>类型通配符</strong>：用于使用泛型时，表示一种未知的类型。</li></ul><p><strong>类型通配符有三种</strong>：</p><ul><li><code>&lt;?&gt; </code>：<strong>无限定的通配符</strong>。可用来表示任何类型。无限定通配符只能读Object类型的值，只能写null类型的值，其他类型都不能读写。</li><li><code>&lt;? extends T&gt;</code> ：<strong>有上界的通配符</strong>。表示继承自T的任何类型，这里上界指的就是T。它通常用于生产者，即返回T。上界通配符只允许读值，不允许写null以外值。</li><li><code>&lt;? super T&gt; </code>：<strong>有下界的通配符</strong>。表示子类是T的任何类型，这里下界指的就是T。它通常用于消费者，即写入T。下界类型通配符只允许写值，不允许读Object以外的值。</li></ul><h2 id="无限定类型通配符：-lt-gt"><a href="#无限定类型通配符：-lt-gt" class="headerlink" title="无限定类型通配符：&lt;?&gt;"></a>无限定类型通配符：&lt;?&gt;</h2><p>例如List&lt;?&gt;：表示元素类型未知的List，它的元素可以匹配任何类型。无限定通配符只能读Object类型的值，只能写null类型的值，其他类型都不能读写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        strings.add(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">        integers.add(<span class="number">23</span>);</span><br><span class="line">        <span class="comment">// 1.无界通配符用作形参，实参可以是任意元素</span></span><br><span class="line">        <span class="comment">// 打印集合：List&lt;?&gt;可以接受所有List元素类型的实参</span></span><br><span class="line">        printList(strings);</span><br><span class="line">        printList(integers);</span><br><span class="line">        List&lt;?&gt; anyList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 正确，因为无限定通配符可以写null类型的值。</span></span><br><span class="line">        anyList.add(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 下面代码会报错，因为无限定通配符只能读Object类型的值，只能写null类型的值，其他类型都不能读写。</span></span><br><span class="line">        <span class="comment">// anyList.add(23);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * * 打印集合：List&lt;?&gt;可以接受所有List元素类型的实参。Collection&lt;?&gt;可以接受任何类型任何元素类型的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 集合元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : c) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上界类型通配符-List-lt-extends-指定类型-gt"><a href="#上界类型通配符-List-lt-extends-指定类型-gt" class="headerlink" title="上界类型通配符:List&lt;? extends 指定类型&gt;"></a>上界类型通配符:List&lt;? extends 指定类型&gt;</h2><p>表示继承自T的任何类型，这里上界指的就是T。它主要用于写入数据的场景。</p><p>上界类型通配符只允许读值，不允许写null以外的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    strings.add(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">    integers.add(<span class="number">23</span>);</span><br><span class="line">    <span class="comment">// 上界通配符可以接受继承于T的类，即T的子类</span></span><br><span class="line">    printNumbers(integers);</span><br><span class="line">    <span class="comment">// 下面会报错，因为上界通配符，元素类型只能是Number的子类</span></span><br><span class="line">    <span class="comment">// printNumbers(strings);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上界通配符可以接受继承于T的类，即T的子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printNumbers</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 下面会报错，因为上界类型通配符只允许读值，不允许写null以外值。</span></span><br><span class="line">    <span class="keyword">for</span> (Number number : list) &#123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下界类型通配符-List-lt-super-指定类型-gt"><a href="#下界类型通配符-List-lt-super-指定类型-gt" class="headerlink" title="下界类型通配符:List&lt;? super 指定类型&gt;"></a>下界类型通配符:List&lt;? super 指定类型&gt;</h2><p>表示子类是T的任何类型，这里下界指的就是T。它主要用于读取数据的场景。</p><p>下界类型通配符只允许写值，不允许读Object以外的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    strings.add(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">    integers.add(<span class="number">23</span>);</span><br><span class="line">    addNumbers(integers);</span><br><span class="line">    printList(integers);</span><br><span class="line">    <span class="comment">// 下面会报错，因为上界通配符，元素类型只能是Number的子类</span></span><br><span class="line">    <span class="comment">// printNumbers(strings);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * * 下界通配符可以接受实现了Integer接口的类，即Integer的父类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addNumbers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 正确。因为下界类型通配符允许写值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 下面会报错，因为下界类型通配符只允许写值，不允许读Object以外类型的值。</span></span><br><span class="line">    <span class="comment">// Number number=list.get(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>(int… a)是将所有int参数封装到a数组里。</p><p> 注意可变参数要放在后面。例如(int a,int… b)正确，(int… a,int b)会报错</p><p><strong>Arrays工具类中有一个静态方法：</strong></p><ul><li><code>public static &lt;T&gt; List&lt;T&gt; asList(T.. a)</code>：返回由指定数组支持的固定大小的列表</li><li>返回的集合不能做增删操作，可以做修改操作</li></ul><p><strong>List接口中有一个静态方法：</strong></p><ul><li><code>public static &lt;E&gt; List&lt;E&gt; of(E.. elements)</code>：返回包含任意数量元素的不可变列表</li><li>返回的集合不能做增删改操作</li></ul><p><strong>Set接口中有一个静态方法：</strong></p><ul><li><code>public static &lt;E&gt;Set&lt;E&gt;of([...elements)</code>：返回一个包含任意数量元素的不可变集合</li><li>在给元素的时候，不能给重复的元素</li><li>返回的集合不能做增删操作，没有修改的方法</li></ul><hr><h1 id="知识加油站"><a href="#知识加油站" class="headerlink" title="知识加油站"></a>知识加油站</h1><h2 id="泛型的向上转型"><a href="#泛型的向上转型" class="headerlink" title="泛型的向上转型"></a>泛型的向上转型</h2><p>泛型类或接口可以向上转型为父类，泛型符号不能向上转型。</p><p>泛型向上转型指的是将一个泛型对象转换为其父类类型或者接口类型的过程。这个过程实际上是将泛型对象的类型参数擦除，重新赋值为其父类或接口类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类或接口可以向上转型：ArrayList&lt;T&gt;可以向上转型为List&lt;T&gt;</span></span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = arrayList;  <span class="comment">// 向上转型为 List&lt;Integer&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型符号不能向上转型：ArrayList&lt;Integer&gt;泛型不可以向上转化为ArrayList&lt;Number&gt;。因为ArrayList&lt;Number&gt;接收ArrayList&lt;float&gt;，但ArrayList&lt; Integer&gt;不可以接收ArrayList&lt; Float&gt;，不能转回来 </span></span><br><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Number&gt; numberList = integerList;  <span class="comment">// 编译错误：不能将 ArrayList&lt;Integer&gt; 向上转型为 ArrayList&lt;Number&gt;</span></span><br></pre></td></tr></table></figure><h2 id="泛型的向下转型"><a href="#泛型的向下转型" class="headerlink" title="泛型的向下转型"></a>泛型的向下转型</h2><p>向下转型和向上转型类似，指的是将一个父类类型的对象转换为子类类型的过程。这种转换需要进行类型检查，确保转换是安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = (ArrayList&lt;Integer&gt;) list;  <span class="comment">// 向下转型为 ArrayList&lt;Integer&gt;</span></span><br></pre></td></tr></table></figure><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p><strong>泛型擦除</strong>：java的泛型是伪泛型，因为<strong>java在编译期间，所有的泛型类型都会被擦掉，并转换为普通类型</strong>。  </p><p>泛型擦除的主要目的是为了<strong>向低版本兼容</strong>，因为Java泛型是在JDK 1.5之后才引入的特性，为了保证旧有的代码能正常运行，Java编译器采用了泛型擦除来兼容之前的代码。</p><h2 id="为什么要有泛型，而不是使用Object类"><a href="#为什么要有泛型，而不是使用Object类" class="headerlink" title="为什么要有泛型，而不是使用Object类"></a>为什么要有泛型，而不是使用Object类</h2><p>因为泛型是在编译时泛型擦除和替换实际类型的，而使用Object类会很麻烦，需要经常强制转换。</p><p>如List集合里，若直接声明存Object类，存的时候可通过多态机制直接向上转型，而取的时候就麻烦了，要强转Object类为String等对象，然后才能访问该对象的成员；而且不知道实际元素到底是String类型还是Integer等其他类型，还要通过<code>i instanceof String</code>判断类型，就更麻烦了。</p><h2 id="泛型的优点"><a href="#泛型的优点" class="headerlink" title="泛型的优点"></a>泛型的优点</h2><ul><li><strong>防止运行时报错</strong>：可以在编译时检查类型安全，防止在程序运行期间出现BUG。</li><li><strong>隐式转换</strong>：所有的强制转换都是自动和隐式的，可以提高代码的重用率。</li></ul><blockquote><p>编译时安全检查：</p><p>Java在1.5版本中引入了泛型，在没有泛型之前，每次从集合中读取对象都必须进行类型转换，而这么做带来的结果就是：如果有人不小心插入了类型错误的对象，那么在运行时转换处理阶段就会出错。<br>在提出泛型之后，我们可以告诉编译器集合中接受哪些对象类型。编译器会自动的为你的插入进行转化，并在编译时告知是否插入了类型错误的对象。这使程序变得更加安全更加清楚。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java泛型是J2 SE1.5中引入的一个新特性，其本质是参数化类型，也就是说所操作的数据类型被指定为一个参数（type parameter）这种参数类型可以用在&lt;a href=&quot;https://baike.baidu.com/item/%E7%B1%BB/6824577?</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>集合体系</title>
    <link href="https://southernfish.github.io/2025/07/23/java/java-base-5-collection/"/>
    <id>https://southernfish.github.io/2025/07/23/java/java-base-5-collection/</id>
    <published>2025-07-23T14:08:36.000Z</published>
    <updated>2025-07-24T08:57:02.600Z</updated>
    
    <content type="html"><![CDATA[<p>集合类是Java数据结构的实现。Java的集合类是<a href="https://baike.baidu.com/item/java.util/5180624?fromModule=lemma_inlink">java.util</a>包中的重要内容，它允许以各种方式将元素分组，并定义了各种使这些元素更容易操作的方法。Java集合类是Java将一些基本的和使用频率极高的基础类进行封装和增强后再以一个类的形式提供。集合类是可以往里面保存多个对象的类，存放的是对象，不同的集合类有不同的功能和特点，适合不同的场合，用以解决一些实际问题。</p><p>原文链接：<a href="https://blog.csdn.net/qq_40991313/article/details/137256095">https://blog.csdn.net/qq_40991313/article/details/137256095</a></p><h1 id="集合体系"><a href="#集合体系" class="headerlink" title="集合体系"></a>集合体系</h1><h2 id="集合和映射"><a href="#集合和映射" class="headerlink" title="集合和映射"></a>集合和映射</h2><p>在Java中，集合是一组用于操作和存储数据的接口和类。 它主要包括Collection和Map两种。</p><p><strong>集合（Collection）</strong>：一组单独的元素。它通常应用了某种规则，例如 List（列表）必须按特定的顺序容纳元素，而一个Set（集）不可包含任何重复的元素。<br><strong>映射（Map）</strong>：一系列“键－值”对的集合。它的存储内容是一系列键值对，如果知道了键（key），我们可以直接获取到这个键所对应的值（value），时间复杂度是O(1)。散列表是Map的一种较为普遍的展现。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250722172620947.png" alt="image-20250722172620947"></p><p>Java中的集合类分为4大类,分别由4个接口来代表,它们是Set、List、Queue、Map。其中,Set、List、Queue接口都继承自Collection接口，Map接口不继承自其他接口。</p><p><code>Set</code>代表<strong>无序的、元素不可重复</strong>的集合。</p><p><code>List</code>代表<strong>有序的、元素可以重复</strong>的集合。有序说的是元素顺序直接由插入顺序决定。</p><p><code>Queue</code>代表<strong>先进先出（FIFO）</strong>的队列。</p><p><code>Map</code>代表<strong>具有映射关系（key-value）</strong>的集合。</p><p>Java提供了众多集合的实现类，它们都是这些接口的直接或间接的实现类，其中比较常用的有：<code>HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap</code>等。</p><h2 id="常见集合的底层和性能对比"><a href="#常见集合的底层和性能对比" class="headerlink" title="常见集合的底层和性能对比"></a>常见集合的底层和性能对比</h2><table><thead><tr><th>集合</th><th>使用场景</th><th>底层</th><th>性能</th></tr></thead><tbody><tr><td>ArrayList</td><td>频繁查询但不经常增删元素</td><td>数组，允许存储多个null值</td><td>查询（get、contains）操作时间复杂度为O(1)，添加（add）和删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为O(n)</td></tr><tr><td>LinkedList</td><td>频繁增删元素但不经常查询</td><td>链表，允许存储多个null值</td><td>查询很慢（需要从头（或尾）遍历链表，查询操作时间复杂度为O(n) ），增删很快（只需调整链表的指针，插入（add）和删除（remove）操作时间复杂度为O(1)）</td></tr><tr><td>Stack</td><td>需要后进先出（LIFO）访问顺序的数据结构，例如递归、回溯算法等。线程安全，因为它是Vector的实现类</td><td>数组（因为它是Vector的实现类），允许存储多个 null 值</td><td>增删改查都是在栈顶操作，所以时间复杂度都是O(1)</td></tr><tr><td>HashSet</td><td>需要高效去重、快速查找、不考虑内存浪费的场景</td><td>哈希表（快速查找）和Set（去重）。它自动对元素进行去重（通过 hashCode 和 equals 方法），并且无序（存入后顺序会乱），允许存储一个null值。</td><td>底层是哈希表，所以插入、删除和查找操作的时间复杂度都是O(1)，代价是浪费一些空间。</td></tr><tr><td>TreeSet</td><td>适用于多读少写、排序的场景</td><td>红黑树（快速查找、排序）和Set（去重），不允许存储null值</td><td>插入、删除、查找操作的时间复杂度为O(log n)，因为操作需要维护树的平衡，所以适用于多读少写的场景。</td></tr><tr><td>HashMap</td><td>适用于多读少写、需要快速读的场景。</td><td>哈希表（快速查找）和Map（键值对），可以存储一个null键（key）和多个null值（value）。</td><td>底层是哈希表，所以插入、删除和查找操作的时间复杂度都是O(1)，代价是浪费一些空间。</td></tr></tbody></table><blockquote><p><strong>Stack常用方法</strong>：</p><ul><li>**push(E item)**：将元素压入栈顶</li><li>**pop()**：移除并返回栈顶元素</li><li>**peek()**：返回栈顶元素但不移除</li><li>**isEmpty()**：检查栈是否为空</li><li>**search(Object o)**：返回元素在栈中的位置，以 1 为基准</li></ul><p><strong>红黑树</strong>： </p><p>近似平衡二叉树，左右子树高差可能大于 1，查找效率略低于平衡二叉树，但增删效率高于平衡二叉树，适合频繁插入删除。</p><ul><li><p>结点非黑即红；</p></li><li><p>根结点是黑色，叶节点是黑色空节点（常省略）；</p></li><li><p>任何相邻节点不能同时为红色；</p></li><li><p>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点；</p></li><li><p>**查询性能稳定O(logN)**，高度最高2log(n+1)；</p></li></ul></blockquote><h2 id="知识加油站"><a href="#知识加油站" class="headerlink" title="知识加油站"></a>知识加油站</h2><h2 id="集合的线程安全性"><a href="#集合的线程安全性" class="headerlink" title="集合的线程安全性"></a>集合的线程安全性</h2><p><strong>线程不安全的集合</strong>：</p><p>Java提供了众多集合的实现类,它们都是这些接口的直接或间接的实现类，其中比较常用的有：HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap等。这些集合都是线程不安全的。</p><p><strong>线程安全的集合</strong>：</p><ol><li><p><strong>Collections工具类</strong>：Collections工具类的<code>synchronizedXxx()</code>方法，将ArrayList等集合类包装成线程安全的集合类。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br></pre></td></tr></table></figure></li><li><p><strong>古老api</strong>：如Vector、Hashtable，在JDK1就出现了，不推荐使用，因为线程安全的方案不成熟，性能差。</p></li><li><p><strong>降低锁粒度的并发容器（推荐）</strong>：JUC包下<code>Concurrent</code>开头的、以降低锁粒度来提高并发性能的容器，如<code>ConcurrentHashMap</code>。适用于读写操作都很频繁的场景。</p></li><li><p><strong>复制技术实现的并发容器</strong>：JUC包下以<code>CopyOnWrite</code>开头的、采用写时写入时复制技术实现的并发容器，如<code>CopyOnWriteArrayList</code>。写操作时，先将当前数组进行一次复制，对复制后的数组进行操作，操作完成后再将原来的数组引用指向复制后的数组。避免了并发修改同一数组的线程安全问题。适用于读操作比写操作频繁且数据量不大的场景。适用于读操作远多于写操作的场景。</p></li></ol><h3 id="什么是线程不安全"><a href="#什么是线程不安全" class="headerlink" title="什么是线程不安全"></a>什么是线程不安全</h3><p>线程不安全是指在多线程环境下，当多个线程并发地访问和修改共享数据时，由于缺乏适当的同步机制，可能导致数据的不一致、错误或者程序行为不可预测的现象。</p><h2 id="Collection常用API"><a href="#Collection常用API" class="headerlink" title="Collection常用API"></a>Collection常用API</h2><ul><li>**add()**：向集合中添加一个元素。</li><li><strong>获取元素</strong>：没有直接提供获取指定位置元素的方法，因为它的实现类元素不一定有序。若需访问，需要通过迭代器iterator()</li><li>**remove()**：从集合中移除一个指定的元素。</li><li>**contains(Object o)**： 检查集合中是否包含指定元素。</li><li>**size()**：返回集合中的元素数量。</li><li>**isEmpty()**：检查集合是否为空。</li><li><strong>clear()</strong>:：移除集合中的所有元素。</li></ul><h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><p>Java 的集合框架提供了许多有用的工具类，用于简化集合的操作。最常见的工具类是 java.util.Collections 和 java.util.Arrays。这些工具类提供了许多静态方法，可以对集合进行排序、搜索、填充、反转等操作</p><h3 id="集合工具类Collections"><a href="#集合工具类Collections" class="headerlink" title="集合工具类Collections"></a>集合工具类Collections</h3><p>Collections工具类常用方法：</p><ul><li><code>sort(List&lt;T&gt; list)</code>：对指定的列表按自然顺序进行升序排序。</li><li>sort(List<T> list, Comparator&lt;? super T&gt; c)：使用指定的比较器对指定的列表进行排序。</li><li><code>reverse(List&lt;?&gt; list)</code>：反转指定列表中元素的顺序。</li><li><code>max(Collection&lt;? extends T&gt; coll)</code>：返回给定集合的最大元素，按自然顺序比较。</li><li>max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)：返回给定集合的最大元素，使用指定的比较器比较。</li><li><code>binarySearch(List&lt;? extends T&gt; list, T key)</code>：使用二分法搜索指定列表以查找指定对象。</li><li><code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code>：将源列表的所有元素复制到目标列表中。</li><li><code>fill(List&lt;? super T&gt; list, T obj)</code>：用指定的元素替换指定列表中的所有元素。</li><li><code>frequency(Collection&lt;?&gt; c, Object o)</code>：返回指定集合中等于指定对象的元素数。</li><li><code>indexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target)</code>：返回指定源列表中首次出现指定目标列表的起始位置。</li><li><code>swap(List&lt;?&gt; list, int i, int j)</code>：交换指定列表中指定位置的元素。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个ArrayList并添加元素</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">5</span>);list.add(<span class="number">3</span>);list.add(<span class="number">8</span>);list.add(<span class="number">1</span>);list.add(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 输出原始列表</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始列表: &quot;</span> + list);</span><br><span class="line">        <span class="comment">// 使用sort方法按自然顺序排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的列表: &quot;</span> + list);</span><br><span class="line">        <span class="comment">// 使用reverse方法反转列表</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;反转后的列表: &quot;</span> + list);</span><br><span class="line">        <span class="comment">// 使用binarySearch方法查找元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Collections.binarySearch(list, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素3的索引: &quot;</span> + index);</span><br><span class="line">        <span class="comment">// 创建一个目标列表并使用copy方法复制元素</span></span><br><span class="line">        List&lt;Integer&gt; destList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Collections.nCopies(list.size(), <span class="number">0</span>));</span><br><span class="line">        Collections.copy(destList, list);</span><br><span class="line">        System.out.println(<span class="string">&quot;复制后的目标列表: &quot;</span> + destList);</span><br><span class="line">        <span class="comment">// 使用fill方法填充列表</span></span><br><span class="line">        Collections.fill(list, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;填充后的列表: &quot;</span> + list);</span><br><span class="line">        <span class="comment">// 使用swap方法交换元素</span></span><br><span class="line">        Collections.swap(destList, <span class="number">0</span>, destList.size() - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;交换后的目标列表: &quot;</span> + destList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.1.3.2 数组工具类Arrays<br>Arrays工具类常用方法：</p><ul><li><p><code>asList(T... a)</code>：将数组转换为固定大小列表。例如Arrays.asList(1,2,3);则返回有三个元素的数组</p><ul><li><p><strong>基本类型数组视作单个元素</strong>：如果传入基本类型数组，会将其整个数组视作单个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">Arrays.asList(nums); </span><br><span class="line"><span class="comment">// 返回列表是List&lt;int[]&gt;类型，只有一个数组元素。而传入对象类型（String、包装类等），则会拆开。</span></span><br><span class="line">Integer[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">Arrays.asList(nums);</span><br><span class="line"><span class="comment">// 返回列表是List&lt;Integer&gt;类型。其实主要原因是List&lt;T&gt;，T只能是包装类、数组、对象，不能是基本数据类型。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>与原数组共享内存</strong>：<code>asList()</code>后，修改列表的元素，变动会同步到原数组。</p></li><li><p><strong>列表固定大小</strong>：因为返回列表与原数组共享数据，所以列表是固定大小的，不能再增删元素。</p></li></ul></li><li><p><code>sort(T[] a)</code>：对指定数组按自然顺序进行升序排序。</p></li><li><p><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code>：使用指定的比较器对数组进行排序。</p></li><li><p><code>binarySearch(T[] a, T key)</code>：使用二分法搜索指定数组以查找指定对象。</p></li><li><p><code>binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)</code>：使用二分法搜索指定数组以查找指定对象，使用指定的比较器。</p></li><li><p><code>copyOf(T[] original, int newLength)</code>：复制指定的数组，截取或填充 null 以使副本具有指定的长度。</p></li><li><p><code>copyOfRange(T[] original, int from, int to)</code>：复制指定的数组，从指定的起始位置开始到终止位置结束。</p></li><li><p><code>equals(Object[] a, Object[] a2)</code>：如果两个指定数组彼此相等，则返回 true。一维数组时比较内容是否一致，多维数组时只比较最外层数组对象的内容。</p></li><li><p><code>deepEquals(Object[] a1, Object[] a2)</code>：如果两个指定数组彼此深度相等，则返回 true。一维和多维数组比较内容是否一致。</p></li><li><p><code>fill(T[] a, T val)</code>：用指定的值填充指定数组。</p></li><li><p><code>toString(T[] a)</code>：返回指定数组内容的字符串表示形式。</p></li><li><p><code>deepToString(Object[] a)</code>：返回指定数组内容的深层字符串表示形式。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用asList方法将数组转换为列表。列表与原数组共享内存，列表固定大小</span></span><br><span class="line">        String[] stringArray = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; stringList = Arrays.asList(stringArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;数组转换为列表: &quot;</span> + stringList);</span><br><span class="line">        <span class="comment">// 使用sort方法对数组进行排序</span></span><br><span class="line">        <span class="type">int</span>[] intArray = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;原数组（直接打印）: &quot;</span> + intArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;原数组（用Arrays.toString()打印）：&quot;</span> + Arrays.toString(intArray));</span><br><span class="line">        Arrays.sort(intArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组: &quot;</span> + Arrays.toString(intArray));</span><br><span class="line">        <span class="comment">// 使用binarySearch方法查找元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(intArray, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素3的索引: &quot;</span> + index);</span><br><span class="line">        <span class="comment">// 使用copyOf方法复制数组</span></span><br><span class="line">        <span class="type">int</span>[] copiedArray = Arrays.copyOf(intArray, intArray.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;复制后的数组: &quot;</span> + Arrays.toString(copiedArray));</span><br><span class="line">        <span class="comment">// 使用deepEquals方法比较多维数组</span></span><br><span class="line">        Integer[][] deepArray1 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">        Integer[][] deepArray2 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">deepEqual</span> <span class="operator">=</span> Arrays.deepEquals(deepArray1, deepArray2);</span><br><span class="line">        System.out.println(<span class="string">&quot;多维数组是否深度相等: &quot;</span> + deepEqual);</span><br><span class="line">        <span class="comment">// 使用fill方法填充数组</span></span><br><span class="line">        <span class="type">int</span>[] fillArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        Arrays.fill(fillArray, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;填充后的数组: &quot;</span> + Arrays.toString(fillArray));</span><br><span class="line">        <span class="comment">// 使用toString方法将数组转换为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">arrayString</span> <span class="operator">=</span> Arrays.toString(intArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;数组的字符串表示: &quot;</span> + arrayString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li><strong>基本介绍：</strong>可以动态修改的数组，没有固定大小的限制。</li><li><strong>使用场景：</strong>频繁查询但不经常增删元素</li><li><strong>底层：</strong>数组 。允许存储多个null值。</li><li><strong>性能：</strong>查询（get、contains）操作时间复杂度为O(1)，添加（add）和删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为O(n)。</li><li><strong>常用API：</strong><ul><li>Collection接口的add()、remove()等方法</li><li><strong>get()：</strong>获取一个指定下标的元素</li><li><strong>subList(int fromIndex, int toIndex)：</strong>返回从 fromIndex（包括）到 toIndex（不包括）之间的部分列表。</li><li><strong>trimToSize()：</strong>将 ArrayList 的容量调整为当前元素的数量，以节省内存。</li></ul></li></ul><p><strong>排序方法：</strong></p><ul><li><strong>Collections工具类的sort()方法：</strong>Collections.sort(list);</li><li><strong>stream流：</strong>list.stream().sort();</li><li><strong>比较器：</strong>list.sort(new Comparator<Integer>() {})</li><li><strong>手写排序：</strong>冒泡排序、选择排序、插入排序、二分法排序、快速排序、堆排序。</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 ArrayList</span></span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 使用 add() 方法向集合中添加元素</span></span><br><span class="line">    arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;添加元素后: &quot;</span> + arrayList);</span><br><span class="line">    <span class="comment">// 使用 get() 方法获取指定索引的元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">elementAtIndex2</span> <span class="operator">=</span> arrayList.get(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;索引 2 处的元素: &quot;</span> + elementAtIndex2);</span><br><span class="line">    <span class="comment">// 使用 set() 方法修改指定索引的元素</span></span><br><span class="line">    arrayList.set(<span class="number">2</span>, <span class="number">35</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改索引 2 后: &quot;</span> + arrayList);</span><br><span class="line">    <span class="comment">// 使用 remove() 方法移除指定索引的元素</span></span><br><span class="line">    arrayList.remove(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;移除索引 1 后: &quot;</span> + arrayList);</span><br><span class="line">    <span class="comment">// 使用 size() 方法获取集合的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> arrayList.size();</span><br><span class="line">    System.out.println(<span class="string">&quot;集合的大小: &quot;</span> + size);</span><br><span class="line">    <span class="comment">// 使用 contains() 方法检查集合中是否包含某个元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">contains30</span> <span class="operator">=</span> arrayList.contains(<span class="number">30</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;集合中是否包含 30: &quot;</span> + contains30);</span><br><span class="line">    <span class="comment">// 使用 isEmpty() 方法检查集合是否为空</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> arrayList.isEmpty();</span><br><span class="line">    System.out.println(<span class="string">&quot;集合是否为空: &quot;</span> + isEmpty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="底层源码和扩容机制"><a href="#底层源码和扩容机制" class="headerlink" title="底层源码和扩容机制"></a>底层源码和扩容机制</h2><p><strong>数组实现：</strong></p><p>ArrayList是<strong>基于数组实现的</strong>，它的内部封装了一个<strong>Object[]数组</strong>。通过<strong>默认构造器</strong>创建容器时,该数组先被<strong>初始化为空数组</strong>，之后在<strong>首次添加数据</strong>时再将其初始化成<strong>长度为10的数组</strong>。我们也可以使用有参构造器来创建容器，并通过参数来显式指定数组的容量，届时该数组被初始化为指定容量的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制的源码中的一部分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default initial capacity. 初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access 底层数组</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>每次扩容1.5倍：</strong></p><p>如果向ArrayList中添加数据会造成超出数组长度限制,则会触发<strong>自动扩容</strong>,然后再添加数据。扩容就是<strong>数组拷贝</strong>,将<strong>旧数组中的数据拷贝到新数组</strong>里,而新数组的长度为原来<strong>长度的1.5倍</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minCapacity 代表着最小扩容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// elementData 是 ArrayList 存储数据的数组，这里是获取当前数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 计算扩容后的数组长度 = 当前数组长度 + (当前数组长度 * 0.5)；也就是扩容到当前的 1.5 倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断新的数组是否满足最小扩容量，如果不满足就将新数组的扩容长度赋值为最小扩容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果扩容后的长度超过了最大数组大小，则将其设置为合适的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity 通常接近于 size，因此这是一个有效的优化</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>手动缩容：</strong></p><p>ArrayList支持缩容,但<strong>不会自动缩容</strong>,即便是ArrayList中只剩下少量数据时也不会主动缩容。如果我们希望缩减ArrayList的容量,则需要自己调用它的<strong>trimToSize()方法</strong>,届时数组将按照元素的实际个数进行缩减，底层也是通过创建新数组拷贝实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 增加modCount，modCount是ArrayList的属性，用于记录集合被修改的次数。</span></span><br><span class="line">    <span class="comment">// 除了ArrayList，LinkedList、HashSet、TreeSet、HashMap、TreeMap等集合都有modCount属性</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果当前大小小于数组的长度，则进行缩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        <span class="comment">// 如果 size 为 0，则将 elementData 置为 EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="comment">// 否则将 elementData 缩容到 size 大小</span></span><br><span class="line">        elementData = (size == <span class="number">0</span>) </span><br><span class="line">            ? EMPTY_ELEMENTDATA </span><br><span class="line">            : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程不安全问题和解决方案"><a href="#线程不安全问题和解决方案" class="headerlink" title="线程不安全问题和解决方案"></a>线程不安全问题和解决方案</h2><p>添加元素add()方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.扩容：判断列表的capacity容量是否足够，是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2.添加：真正将元素放在列表的元素数组里面</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1.某线程刚扩容后就失去调度</strong></p><p>在JVM中，CPU在多个线程中通过程序计数器来回调度，同一时刻一个CPU只能运行一个线程，所以就存在add()时，某个线程在刚刚ensureCapacityInternal()扩容后、还没往数组存元素时被暂停，等待被调度，然后其他线程add()成功把数组存满了，此时原线程恢复运行，执行elementData[size++] = e，因为数组容量已经满了，就会报错数组越界异常ArrayIndexOutOfBoundsException。</p><p><strong>例如：</strong></p><p>表大小为9，线程A新增一个元素，判断容量是不是足够，同时线程B也新增一个元素，判断容量是不是足够，线程A开始进行设置值操作， elementData[size++] = e 操作。此时size变为10，线程B也开始进行设置值操作，它尝试设置elementData[10] = e，而elementData没有进行过扩容，它的下标最大为9。于是此时会报出一个数组越界的异常ArrayIndexOutOfBoundsException。</p><p><strong>2.数组存值时不是原子操作</strong><br>另外第二步 elementData[size++] = e 设置值的操作同样会导致线程不安全。从这儿可以看出，这步操作也不是一个原子操作。</p><p><strong>解决方案：</strong></p><ul><li><p>原子类</p></li><li><p>volatile</p></li><li><p>锁</p></li><li><p><strong>线程安全的集合：</strong></p><ul><li><p><strong>Collections工具类：</strong>Collections工具类的synchronizedXxx()方法<strong>，</strong>将ArrayList等集合类包装成线程安全的集合类。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure></li><li><p><strong>古老api</strong>：java.util包下性能差的古老api，如Vector、Hashtable</p></li><li><p><strong>降低锁粒度的并发容器</strong>：JUC包下Concurrent开头的、以降低锁粒度来提高并发性能的容器，如ConcurrentHashMap。</p></li><li><p><strong>复制技术实现的并发容器</strong>：JUC包下以CopyOnWrite开头的、采用写时复制技术实现的并发容器，如CopyOnWriteArrayList。 </p></li></ul></li></ul><h2 id="六种遍历方法"><a href="#六种遍历方法" class="headerlink" title="六种遍历方法"></a>六种遍历方法</h2><h3 id="常规-for-循环"><a href="#常规-for-循环" class="headerlink" title="常规 for 循环"></a>常规 for 循环</h3><p>普通 for 循环适用于遍历数组和实现了 List 接口的集合。它通过索引访问元素，性能通常较好。</p><p><strong>优点：</strong></p><ul><li><strong>性能高：</strong>性能通常优于增强 for 循环和迭代器，尤其是对于数组和 ArrayList。</li><li><strong>复杂操作：</strong>允许在遍历过程中进行复杂的控制操作。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>可读性差：</strong>代码相对冗长，需要手动管理循环变量。</li><li><strong>只能通过索引访问：</strong>仅适用于可以通过索引下标访问元素的集合。</li></ul><p><strong>通过for循环，用get(下标) 的方法遍历：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 通过arrayList.add(value)增加值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">    System.out.print(arrayList.get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强-for-循环（只遍历不修改）"><a href="#增强-for-循环（只遍历不修改）" class="headerlink" title="增强 for 循环（只遍历不修改）"></a>增强 for 循环（只遍历不修改）</h3><p>在某些情况下，常规的遍历方式容易显得代码臃肿，增强for可以简化数组和Collection集合的遍历，增强代码的可读性。</p><p><strong>增强 for 循环：</strong>一种<strong>简洁</strong>的遍历集合的方法，它适用于遍历数组和实现了 Iterable 接口的所有集合。</p><blockquote><p><strong>Collection实现类都实现了Iterable 接口：</strong></p><p>在标准的 Java Collections Framework 中，所有主要的集合实现类都实现了 Iterable 接口。换句话说，如果一个类实现了 Collection 接口，那么它也会实现 Iterable 接口，因为这是 Collection 接口的一个基本要求。 </p><p><strong>tip：</strong>Map集合没有实现Iterable 接口，因为它也没有实现Collection接口。</p></blockquote><p><strong>IDEA快捷键：</strong>输入iter然后回车</p><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据类型：即遍历对象中元素的数据类型。</span></span><br><span class="line"><span class="comment">// 变量名：遍历时声明的变量，每次遍历得到的元素都会赋值给这个变量。</span></span><br><span class="line"><span class="comment">// 数组或者集合对象：需要遍历的对象。</span></span><br><span class="line"><span class="keyword">for</span> (数据类型 变量名 : 数组或者Collection集合对象) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">    System.out.println(变量名);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><strong>简洁易读</strong>：增强 for 循环语法简洁，代码更容易阅读。</li><li><strong>避免错误</strong>：相比传统的 for 循环，不需要手动管理循环变量，减少了出错的可能性。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>性能略差：</strong>性能略差于普通for循环，以略微的性能代价，提高了可读性 </li><li>不允许修改；</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用增强 for 循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (Integer num : arrayList) &#123;</span><br><span class="line">    System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器-Iterator（遍历并修改）"><a href="#迭代器-Iterator（遍历并修改）" class="headerlink" title="迭代器 Iterator（遍历并修改）"></a>迭代器 Iterator（遍历并修改）</h3><p>迭代器是遍历Collection集合的通用方式，它不需要关注集合和集合内元素的类型，对集合内的元素进行读取、添加、修改操作。  </p><p><strong>基本方法：</strong></p><ul><li><strong>hasNext()：</strong>返回 true 如果还有未遍历的元素。</li><li><strong>next()：</strong>返回下一个元素。</li><li><strong>remove()：</strong>从集合中移除 next() 返回的最后一个元素。</li></ul><p><strong>优点：</strong></p><ul><li><strong>各类型集合统一迭代器</strong>：不需要了解集合的内部实现，通过 Iterator 可以统一遍历不同类型的集合。</li><li><strong>安全</strong>：在遍历过程中，如果其他线程修改了集合，Iterator 可以抛出 ConcurrentModificationException 以防止不一致性。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>性能略差：</strong>性能略差于普通for循环，以略微的性能代价，提高了可读性 </li><li><strong>复杂：</strong>相比增强for，需要next()、hasNext()，麻烦了一些</li><li>不能双向遍历</li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorRemoveExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 ArrayList 并添加一些元素</span></span><br><span class="line">        List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 获取 ArrayList 的迭代器</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = arrayList.iterator();</span><br><span class="line">        <span class="comment">// 使用迭代器遍历 ArrayList 并移除元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用迭代器遍历 ArrayList 并移除元素:&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">30</span>) &#123;</span><br><span class="line">                iterator.remove(); <span class="comment">// 移除大于 30 的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印修改后的 ArrayList</span></span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的 ArrayList:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer num : arrayList) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器-ListIterator-（双向遍历并修改）"><a href="#迭代器-ListIterator-（双向遍历并修改）" class="headerlink" title="迭代器 ListIterator （双向遍历并修改）"></a>迭代器 ListIterator （双向遍历并修改）</h3><p>Set、List、Queue都是Collection的子接口，它们都继承了父接口的iterator()方法,从而具备了迭代的能力。Map使用迭代器必须通过先entrySet()转为Set，然后再使用迭代器或for遍历。</p><p>但相比于另外两个接口，<strong>List</strong>还单独提供了<strong>listIterator()方法</strong>,增强了迭代能力。iterator()方法返回Iterator迭代器，listIterator()方法返回ListIterator迭代器，并且<strong>ListIterator是Iterator的子接口</strong>。</p><p>ListIterator在Iterator的基础上，增加了listIterator.previous()向前遍历的支持，增加了listIterator.set()在迭代过程中修改数据的支持。与 Iterator 相比，ListIterator 提供了更多的方法，但只适用于实现了 List 接口的集合（如 ArrayList 和 LinkedList）。</p><p><strong>常用方法：</strong></p><ul><li>hasNext()：如果列表中有下一个元素，则返回 true。</li><li><strong>next()：</strong>返回列表中的下一个元素。</li><li>hasPrevious()：如果列表中有上一个元素，则返回 true。</li><li><strong>previous()：</strong>返回列表中的上一个元素。</li><li>nextIndex()：返回下一元素的索引。</li><li>previousIndex()：返回上一元素的索引。</li><li>remove()：移除上一个通过 next() 或 previous() 返回的元素。</li><li>set(E e)：替换上一个通过 next() 或 previous() 返回的元素。</li><li>add(E e)：在列表中插入指定元素。 </li></ul><p><strong>优点：</strong></p><ul><li>可读性高；</li><li><strong>安全：</strong>在遍历过程中，如果其他线程修改了集合，迭代器可以抛出 ConcurrentModificationException 以防止不一致性。</li><li>双向遍历；</li></ul><p><strong>缺点：</strong></p><ul><li><strong>只支持List：</strong>只适用于实现了 List 接口的集合（如 ArrayList 和 LinkedList）。</li><li><strong>性能略差：</strong>性能略差于普通for循环，以略微的性能代价，提高了可读性 </li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteratorExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 使用 ListIterator 遍历（正向）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 ListIterator 正向遍历:&quot;</span>);</span><br><span class="line">        ListIterator&lt;Integer&gt; listIterator = arrayList.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(listIterator.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 使用 ListIterator 反向遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 ListIterator 反向遍历:&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasPrevious()) &#123;</span><br><span class="line">            System.out.print(listIterator.previous() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="forEach-Lambda-表达式（只遍历不修改）"><a href="#forEach-Lambda-表达式（只遍历不修改）" class="headerlink" title="forEach + Lambda 表达式（只遍历不修改）"></a>forEach + Lambda 表达式（只遍历不修改）</h3><p>在 Java 8 及以上版本中，forEach 方法与 Lambda 表达式的结合提供了一种简洁、功能强大的方式来遍历集合。forEach 方法<strong>属于 Iterable 接口</strong>，允许对集合中的每个元素执行指定的操作。</p><p><strong>优点：</strong></p><ul><li><strong>简洁：</strong>相比于传统的 for 循环和迭代器，代码更简洁，减少样板代码。</li><li><strong>可读性强：</strong>使用 Lambda 表达式和方法引用，使代码更加易读和表达意图明确。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>性能略差：</strong>性能略差于普通for循环，以略微的性能代价，提高了代码的优雅性可读性 ；同时各个元素之间的遍历是顺序执行的，不像Stream流的forEach是并发执行的，性能略差。</li><li><strong>不允许修改元素：</strong>因为 Lambda 表达式的参数是 final 或等效于 final 的，所以不允许修改集合中的元素。想修改的话，只能创建另一个集合，然后在遍历时将处理后的元素add进另一个集合。</li><li><strong>版本限制：</strong>只适用JDK8及以上；</li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForEachLambdaExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 使用 forEach 方法和 Lambda 表达式遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 forEach 方法和 Lambda 表达式遍历:&quot;</span>);</span><br><span class="line">        arrayList.forEach(num -&gt; System.out.print(num + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream-API-遍历（推荐，并发遍历并修改）"><a href="#Stream-API-遍历（推荐，并发遍历并修改）" class="headerlink" title="Stream API 遍历（推荐，并发遍历并修改）"></a>Stream API 遍历（推荐，并发遍历并修改）</h3><p>Stream 流是 Java 8 引入的一项新特性，用于对集合进行函数式编程风格的操作。它允许我们以声明性方式对数据进行过滤、加工、遍历、排序等操作，而不是以命令式方式逐个操作元素。</p><p><strong>优点：</strong></p><ul><li><strong>简洁：</strong>相比于传统的 for 循环和迭代器，代码更简洁，减少样板代码。</li><li><strong>生成修改后的新集合：</strong>允许通过map()、filter()等方法修改元素，然后收集成一个新集合。</li><li><strong>性能高：</strong>因为是并发的，所以性能高。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>版本限制：</strong>只适用JDK8及以上；</li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 使用 Stream API 遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 Stream API 遍历:&quot;</span>);</span><br><span class="line">        arrayList.stream().forEach(num -&gt; System.out.print(num + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结：六种遍历方法的适用场景"><a href="#小结：六种遍历方法的适用场景" class="headerlink" title="小结：六种遍历方法的适用场景"></a>小结：六种遍历方法的适用场景</h3><ul><li><strong>需要根据索引下标遍历：</strong>普通for</li><li><strong>只需要顺序读取元素：</strong>建议增强for，也可以用其他所有遍历方法</li><li><strong>需要修改元素：</strong>普通for、迭代器、Stream流</li><li><strong>需要双向遍历：</strong>ListIterator </li><li><strong>需要过滤、加工、排序等高级操作：</strong>Stream流</li></ul><hr><h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>参考链接：<a href="https://blog.csdn.net/qq_47980550/article/details/148012216">java基础——java集合list详解</a>、<a href="https://blog.csdn.net/qq_38322527/article/details/114703142">JUC中的List安全类集合</a></p><h2 id="主要实现类"><a href="#主要实现类" class="headerlink" title="主要实现类"></a><strong>主要实现类</strong></h2><p>Collection将集合划分为两大类，即List和Set。</p><p>常见的 List 实现类包括 ArrayList、LinkedList、Vector（JDK1的上古集合，虽然线程安全但性能差，已经基本不用） 和 Stack。 </p><ol><li><p><strong>ArrayList：</strong></p><ul><li><p><strong>使用场景：</strong>频繁查询但不经常增删元素</p></li><li><p><strong>底层：</strong>数组 。允许存储多个null值。</p></li><li><p><strong>性能：</strong>查询（get、contains）操作时间复杂度为O(1)，添加（add）和删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为O(n)。</p></li></ul></li><li><p><strong>LinkedList：</strong></p><ul><li><p><strong>使用场景：</strong>频繁增删元素但不经常查询</p></li><li><p><strong>底层：</strong>链表 。允许存储多个null值。</p></li><li><p><strong>性能：</strong> 查询很慢（需要从头（或尾）遍历链表，查询操作时间复杂度为O(n) ），增删很快（只需调整链表的指针，插入（add）和删除（remove）操作时间复杂度为O(1)）。</p></li></ul></li><li><p><strong>Vector：</strong></p><ul><li><p><strong>使用场景：</strong>需要线程安全且频繁查询的场景（JDK1的上古集合，虽然线程安全但性能差，已经基本不用。</p></li><li><p><strong>线程安全集合：</strong></p><ul><li><strong>Collections工具类：</strong>Collections工具类的synchronizedXxx()方法<strong>，</strong>将ArrayList等集合类包装成线程安全的集合类。</li><li><strong>古老api：</strong>java.util包下性能差的古老api，如Vector、Hashtable</li><li>无序列表<strong>降低锁粒度的并发容器：</strong>JUC包下Concurrent开头的、以降低锁粒度来提高并发性能的容器，如ConcurrentHashMap。</li><li><strong>复制技术实现的并发容器：</strong>JUC包下以CopyOnWrite开头的、采用写时复制技术实现的并发容器，如CopyOnWriteArrayList。 </li></ul></li><li><p><strong>底层：</strong>数组。允许存储多个 null 值。</p><ul><li><strong>性能：</strong> 查询（get、contains）操作时间复杂度为O(1)，添加（add）和删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为O(n)。</li></ul></li></ul></li><li><p><strong>Stack：</strong></p><ul><li><p><strong>使用场景：</strong>需要后进先出（LIFO）访问顺序的数据结构，例如递归、回溯算法等。线程安全，因为它是Vector的实现类</p></li><li><p><strong>底层：</strong>数组（因为它是Vector的实现类）。允许存储多个 null 值。</p></li><li><p><strong>性能：</strong> 增删改查都是在栈顶操作，所以时间复杂度都是O(1)</p></li><li><p><strong>常用方法：</strong></p><ul><li>**push(E item)**：将元素压入栈顶</li><li>**pop()**：移除并返回栈顶元素</li><li>**peek()**：返回栈顶元素但不移除</li><li>**isEmpty()**：检查栈是否为空</li><li>**search(Object o)**：返回元素在栈中的位置，以 1 为基准 </li></ul></li></ul></li></ol><h2 id="ArrayList，LinkedList，Vector-对比"><a href="#ArrayList，LinkedList，Vector-对比" class="headerlink" title="ArrayList，LinkedList，Vector 对比"></a>ArrayList，LinkedList，Vector 对比</h2><table><thead><tr><th></th><th>ArrayList</th><th>LinkedList</th><th>Vector</th></tr></thead><tbody><tr><td>底层结构</td><td>动态数组</td><td>双向链表</td><td>动态数组</td></tr><tr><td>线程安全</td><td>不安全</td><td>不安全</td><td>安全，方法都加了<code>Synchronized</code></td></tr><tr><td>是否允许重复元素</td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td>是否有序</td><td>是</td><td>是</td><td>是</td></tr><tr><td>随机访问</td><td>快O(1)，索引访问</td><td>慢O(n)，需遍历链表</td><td>快O(1)，但因同步影响性能较低</td></tr><tr><td>插入/删除</td><td>慢O(n)，需移动元素</td><td>快O(1)，只需修改指针</td><td>慢，同步开销大</td></tr><tr><td>扩容机制</td><td>默认增长50%</td><td>无需扩容，动态添加节点</td><td>默认翻倍容量</td></tr><tr><td>加载因子</td><td>1</td><td>无</td><td>1</td></tr></tbody></table><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>有序【存储有序】</li><li>可重复</li><li>可以存储 null值</li><li>部分子集合线程安全，部分不安全 例如 ArrayList 和 Vector</li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>List接口继承自<code>Collection</code>接口，提供了额外的功能来处理索引位置上的元素。与Set、Map不同，List允许包含重复的元素，并且可以通过索引来访问或修改特定位置的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 核心接口方法 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> <span class="comment">// 添加指定元素到列表末尾。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span><span class="comment">// 在指定索引处插入指定元素。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> <span class="comment">// 在指定索引 index 处插入集合 c 中的所有元素。</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> <span class="comment">// 移除指定索引处的元素。</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> <span class="comment">// 获取指定索引处的元素。</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> <span class="comment">// 替换指定索引处的元素。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 返回列表中的元素数量。</span></span><br><span class="line"><span class="comment">/* 其他常用方法 */</span> </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断列表是否为空。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> <span class="comment">// 检查列表是否包含指定元素。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> <span class="comment">// 返回指定元素首次出现的索引，如果不存在则返回-1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> <span class="comment">// 返回指定元素最后一次出现的索引，如果不存在则返回-1。</span></span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> <span class="comment">// 获取从fromIndex（包括）到toIndex（不包括）之间的子列表</span></span><br></pre></td></tr></table></figure><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 ArrayList</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 增加元素</span></span><br><span class="line">    list.add(<span class="string">&quot;元素1&quot;</span>);list.add(<span class="string">&quot;元素2&quot;</span>);list.add(<span class="string">&quot;元素3&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;增加元素后：&quot;</span> + list);</span><br><span class="line">    <span class="comment">// 在指定索引插入元素</span></span><br><span class="line">    list.add(<span class="number">1</span>, <span class="string">&quot;元素4&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;在索引1插入元素4后：&quot;</span> + list);</span><br><span class="line">    <span class="comment">// 删除指定索引的元素</span></span><br><span class="line">    list.remove(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除索引2的元素后：&quot;</span> + list);</span><br><span class="line">    <span class="comment">// 修改指定索引的元素</span></span><br><span class="line">    list.set(<span class="number">1</span>, <span class="string">&quot;元素5&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改索引1的元素为元素5后：&quot;</span> + list);</span><br><span class="line">    <span class="comment">// 获取指定索引的元素</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> list.get(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;获取索引2的元素：&quot;</span> + element);</span><br><span class="line">    <span class="comment">// 获取元素的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(<span class="string">&quot;元素5&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;元素5的索引：&quot;</span> + index);</span><br><span class="line">    <span class="comment">// 获取子列表</span></span><br><span class="line">    List&lt;String&gt; subList = list.subList(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;子列表（从索引1到索引2）： &quot;</span> + subList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><ol><li><p><code>for</code>循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：可以灵活控制索引。支持随机访问（适合 ArrayList）。</span></span><br><span class="line"><span class="comment">// 缺点：对于 LinkedList 来说效率较低（因为每次都要从头开始查找元素）。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Index: &quot;</span> + i + <span class="string">&quot;, Value: &quot;</span> + list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：简洁易读。适用于所有实现了 Iterable 接口的集合类。</span></span><br><span class="line"><span class="comment">// 缺点：无法获取索引。不能修改集合结构（如删除元素会抛出异常）。</span></span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Item: &quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Iterator</code>。可以安全地在遍历时进行删除操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;元素：&quot;</span> + iterator.next());</span><br><span class="line">    <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;B&quot;</span>.equals(item)) &#123;</span><br><span class="line">        iterator.remove();  <span class="comment">// 安全删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="去重方式"><a href="#去重方式" class="headerlink" title="去重方式"></a>去重方式</h2><ol><li><p>利用 <code>HashSet</code> 或 <code>LinkedHashSet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet 不保留顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出顺序可能不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashSet 保留插入顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Stream.distinct()</code>，Java 8+ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; uniqueList = list.stream().distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(uniqueList);</span><br></pre></td></tr></table></figure></li></ol><h2 id="List-与数组的转换"><a href="#List-与数组的转换" class="headerlink" title="List 与数组的转换"></a>List 与数组的转换</h2><ul><li><p>List 转数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无类型参数：丢失类型信息</span></span><br><span class="line">Object[] array = list.toArray();</span><br><span class="line"><span class="comment">// 带类型参数：推荐，自动匹配类型</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 函数式写法</span></span><br><span class="line">String[] array = list.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></li><li><p>数组转 List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(array);（只读）</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));（可修改）</span><br></pre></td></tr></table></figure></li></ul><h2 id="List-的元素判断机制"><a href="#List-的元素判断机制" class="headerlink" title="List 的元素判断机制"></a>List 的元素判断机制</h2><p>List的 <code>contains(Object o)</code> 和 <code>indexOf(Object o)</code> 方法通过 <code>equals()</code>而非 <code>==</code> 判断元素是否相等。</p><h2 id="List的安全类"><a href="#List的安全类" class="headerlink" title="List的安全类"></a>List的安全类</h2><p>在单线程应用中，通常采取<code>new ArrayList()</code>，指定一个List集合，用于存放可重复的数据。但<code>ArrayList</code>是不安全的集合。多线程操作同一集合对象信息，往往会出现<code>java.util.ConcurrentModificationException</code>异常报错信息。</p><h3 id="Java的安全类Vector"><a href="#Java的安全类Vector" class="headerlink" title="Java的安全类Vector"></a>Java的安全类Vector</h3><p>java提供了<code>java.util.Vector</code>类，多线程下不会出现<code>java.util.ConcurrentModificationException</code>报错信息。因为采取了 <code>synchronized</code> 针对方法执行调用者加锁，保证add操作的多线程安全性！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建lists集合</span></span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JUC下的安全List集合"><a href="#JUC下的安全List集合" class="headerlink" title="JUC下的安全List集合"></a>JUC下的安全List集合</h3><ol><li><code>Collections.synchronizedList(new ArrayList&lt;&gt;());</code>。该方法返回具有同步包装器的List，保证了对List的操作是安全的。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">( <span class="meta">@NotNull</span> List&lt;T&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(list <span class="keyword">instanceof</span> RandomAccess ? </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list) : </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">synchronizedList</span>&lt;&gt;(list));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断传入的 list 集合类型，判断类型是否为 java.util.RandomAccess，如果是则采取java.util.Collections.SynchronizedRandomAccessList构造集合，如果不是则采取java.util.Collections.SynchronizedList构造集合。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码中对应的add操作逻辑如下所示。采取synchronized同步代码块的方式，对数据的add操作实现加锁！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>&#123; </span><br><span class="line">    synchron1zed (mutex) &#123;</span><br><span class="line">        list.add(index, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>new CopyOnWriteArrayList();</code>。该类中所有修改操作都在一个独立的副本上进行，不会影响原始数据，保证了线程安全。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&quot;</span>+lists);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates an empty list</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyonWriteArrayList</span><span class="params">()</span>&#123; setArray(<span class="keyword">new</span> <span class="title class_">object</span>[<span class="number">0</span>]); &#125;</span><br><span class="line"><span class="comment">// add 逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[]elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copy0f(elements, len +<span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong><code>add</code>逻辑如下所示</strong><br>  1、调用add方法后，拿到<code>java.util.concurrent.locks.ReentrantLock</code>对象信息。<br>  2、调用 <code>lock.lock()</code> 拿到锁！<br>  3、将原数组对象<code>copy</code>操作，并创建<code>原数组大小+1</code>的新数组。<br>  4、将新数据放入新数组中。<br>  5、任何操作<code>finally</code>，都进行锁的释放</p><h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p>面向接口编程（<code>Programming to an Interface</code>）是一种编程原则，它强调使用接口（Interface）而不是具体实现类（Concrete Class）来编写代码。</p><p>具体的使用方法是，声明一个接口的变量（接口的引用）可以指向一个实现类（实现该接口的类）的实例。</p><p><strong>注意：</strong>因为是接口的引用，所以该引用的变量不能使用实现类中有、但接口中没有的方法（实现类中没有重写的方法，自添加的方法）。</p><blockquote><p><strong>以面向接口编程为原则，以多态的形式创建集合对象：</strong></p><p>以下两种方法都可以创建ArrayList，但是更推荐第一种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐，面向接口编程，多态形式，对象实例指向接口引用</span></span><br><span class="line">List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 不推荐，常规创建对象形式</span></span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>因为前者符合设计模式中的依赖倒置原则。即程序要尽量依赖于抽象，不依赖于具体。</p><p>在Java语法中，这种方式符合Java三大特性中的多态，即使用接口引用指向具体实现。<br>依赖倒转的好处是，后期扩展方便。比如，你若希望用LinkedList的实现来替代ArrayList的话，只需改动一行即可，其他的所有的都不需要改动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()；</span><br></pre></td></tr></table></figure></blockquote><p><strong>优点：</strong></p><ul><li><strong>解耦合</strong>：声明的变量与具体实现类解耦。变量只依赖于接口，而不是具体实现，这样可以很容易地替换具体实现类，而不需要修改客户端代码。</li><li><strong>可扩展性</strong>：当需要添加新功能时，只需实现新的接口，让原引用指向新的实现类，而不需要修改现有代码。例如SpringBoot项目中，我们经常用XxxService接口和XxxServiceImpl1、XxxServiceImpl2等业务实现类，在使用时，通常将这个接口引用通过@Autowired等注解注入XxxService，然后通过@Primary、@Qualifier等注解指定具体注入XxxServiceImpl1还是XxxServiceImpl2，方便扩展。</li><li><strong>可测试性</strong>：在单元测试中，可以轻松地使用接口的模拟实现来替换真实的实现，从而进行隔离测试。</li></ul><p><strong>符合设计原则：</strong></p><ul><li><strong>开闭原则OCP(Open－Close Principle)：</strong> 对拓展开放、对修改关闭。</li><li><strong>依赖倒置原则DIP(Dependency Inversion Principle)：</strong> 抽象不应该依赖于细节、细节应该依赖于抽象。例如我们开发中要用Service接口和ServiceImpl实现类，而不是直接一个ServiceImpl类中写业务。</li></ul><blockquote><p><strong>设计原则详细参考：</strong></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130403757?spm=1001.2014.3001.5502">设计模式——设计模式简介和七大原则_理解设计模式的核心思想和基本理念是什么-CSDN博客</a></p></blockquote><hr><h1 id="LinkedList接口"><a href="#LinkedList接口" class="headerlink" title="LinkedList接口"></a>LinkedList接口</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>LinkedList：</strong></p><ul><li><strong>使用场景：</strong>频繁增删元素但不经常查询</li><li><strong>底层：</strong>链表 。允许存储多个null值。</li><li><strong>性能：</strong> 查询很慢（需要从头（或尾）遍历链表，查询操作时间复杂度为O(n) ），增删很快（只需调整链表的指针，插入（add）和删除（remove）操作时间复杂度为O(1)）。</li></ul><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public void add(int index, E element)</td><td>向指定位置插入元素</td></tr><tr><td>public void addFirst(E e)</td><td>元素添加到头部</td></tr><tr><td>public void addLast(E e)</td><td>元素添加到尾部</td></tr><tr><td>public void clear()</td><td>清空链表</td></tr><tr><td>public E remove(int index)</td><td>删除指定位置的元素</td></tr><tr><td>public E removeFirst()</td><td>删除并返回第一个元素</td></tr><tr><td>public E removeLast()</td><td>删除并返回最后一个元素</td></tr><tr><td>public boolean contains(Object o)</td><td>判断是否含有某一元素</td></tr><tr><td>public E getFirst()</td><td>返回第一个元素</td></tr><tr><td>public E getLast()</td><td>返回最后一个元素</td></tr></tbody></table><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedList&lt;String&gt; link=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">    link.addLast(<span class="string">&quot;hello&quot;</span>);link.addLast(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s:link) System.out.println(s);</span><br><span class="line">    System.out.println(link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><table><thead><tr><th><strong>特性</strong></th><th><strong>ArrayList</strong></th><th><strong>LinkedList</strong></th></tr></thead><tbody><tr><td><strong>使用场景</strong></td><td>频繁查询但不经常增删元素</td><td>频繁增删元素但不经常查询</td></tr><tr><td><strong>底层</strong></td><td>数组</td><td>链表</td></tr><tr><td><strong>允许存储 null 值</strong></td><td>是。允许存储多个null值</td><td>是。允许存储多个null值</td></tr><tr><td><strong>查询性能</strong></td><td>快。根据索引查询（get、contains）操作时间复杂度为 O(1)</td><td>慢。根据索引查询很慢（需要从头（或尾）遍历链表，查询操作时间复杂度为 O(n)）</td></tr><tr><td><strong>添加性能</strong></td><td>慢。添加（add）元素时，可能需要移动数组中的元素，导致时间复杂度为 O(n)</td><td>快。插入（add）操作时间复杂度为 O(1)，插入后不需要移动元素</td></tr><tr><td><strong>删除性能</strong></td><td>慢。删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为 O(n)</td><td>快。删除（remove）操作时间复杂度为 O(1)，删除后不需要移动元素</td></tr></tbody></table><hr><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>参考链接：<a href="https://blog.csdn.net/FAQEW/article/details/146542959">HashMap底层原理</a>、<a href="https://blog.csdn.net/winterPassing/article/details/148248794">HashMap安全性问题</a>、<a href="https://blog.csdn.net/qq_42077317/article/details/138009817">Java中的ConcurrentHashMap原理详解</a></p><p>HashMap是基于哈希表实现的键值对存储结构，提供高效的插入和查询操作（平均时间复杂度O(1)），允许null键/值，非线程安全，且不保证元素顺序。其核心实现包括数组+链表（JDK1.7及之前）或数组+链表+红黑树（JDK1.8及之后），通过哈希冲突解决机制（链地址法）和动态扩容优化性能。</p><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>使用场景</strong>: 适用于需要基于键值对快速查找数据的场景。“键”可以理解为钥匙，通过这个钥匙，可以找到它唯一对应的“值”。</p><p><strong>底层</strong>: 哈希表（数组+链表/红黑树）。</p><p><strong>性能</strong>:</p><ul><li><strong>查询性能</strong>: 快，时间复杂度为 O(1)。</li><li><strong>添加性能</strong>: 快，时间复杂度为 O(1)。</li><li><strong>删除性能</strong>: 快，时间复杂度为 O(1)。</li></ul><p><strong>是否允许 null</strong>:</p><ul><li>键可以为 null（但最多一个键为 null）。</li><li>值可以为 null。</li></ul><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><strong>put()：</strong>向映射中添加一个键值对。如果键已经存在，则更新其对应的值<ol><li>计算键的哈希值并定位桶索引。</li><li>桶为空：直接插入新节点。</li><li>桶非空：遍历链表或红黑树，若存在相同键（通过<code>equals</code>判断），则更新值；否则追加节点。</li><li>触发扩容：插入后检查元素总数是否超过阈值</li></ol></li><li><strong>get()：</strong>根据键获取对应的值。根据哈希值定位桶，遍历链表或红黑树，通过<code>equals</code>匹配键</li><li><strong>getOrDefault()：</strong>获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值</li><li><strong>keySet()：</strong>返回所有key的Set集合</li><li><strong>remove(Object key):</strong> 根据键移除键值对</li><li><strong>containsKey(Object key):</strong> 检查是否包含指定键</li><li><strong>containsValue(Object value):</strong> 检查是否包含指定值</li><li><strong>size():</strong> 返回映射中的键值对数量</li><li><strong>isEmpty():</strong> 检查映射是否为空</li><li><strong>clear():</strong> 移除映射中的所有键值对</li></ul><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 HashMap</span></span><br><span class="line">        Map&lt;String, String&gt; fruitColor = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 使用 put() 方法向映射中添加键值对</span></span><br><span class="line">        fruitColor.put(<span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;红色&quot;</span>);fruitColor.put(<span class="string">&quot;香蕉&quot;</span>, <span class="string">&quot;黄色&quot;</span>);fruitColor.put(<span class="string">&quot;樱桃&quot;</span>, <span class="string">&quot;红色&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;添加键值对后: &quot;</span> + fruitColor);</span><br><span class="line">        <span class="comment">// 使用 get() 方法根据键获取对应的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> fruitColor.get(<span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;键 &#x27;香蕉&#x27; 对应的值: &quot;</span> + value);</span><br><span class="line">        <span class="comment">// 遍历 keySet</span></span><br><span class="line">        Set&lt;String&gt; keys = fruitColor.keySet();</span><br><span class="line">        System.out.println(<span class="string">&quot;遍历 keySet:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;水果: &quot;</span> + key + <span class="string">&quot; 颜色: &quot;</span> + fruitColor.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 containsKey() 方法检查是否包含指定键</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">containsKeyBanana</span> <span class="operator">=</span> fruitColor.containsKey(<span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;包含键 &#x27;香蕉&#x27;: &quot;</span> + containsKeyBanana);</span><br><span class="line">        <span class="comment">// 使用 containsValue() 方法检查是否包含指定值</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">containsValueYellow</span> <span class="operator">=</span> fruitColor.containsValue(<span class="string">&quot;黄色&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;包含值 &#x27;黄色&#x27;: &quot;</span> + containsValueYellow);</span><br><span class="line">        <span class="comment">// 使用 size() 方法返回映射中的键值对数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> fruitColor.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;映射的大小: &quot;</span> + size);</span><br><span class="line">        <span class="comment">// 使用 isEmpty() 方法检查映射是否为空</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> fruitColor.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">&quot;映射是否为空: &quot;</span> + isEmpty);</span><br><span class="line">        <span class="comment">// 使用 remove() 方法根据键移除键值对</span></span><br><span class="line">        fruitColor.remove(<span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;移除键 &#x27;香蕉&#x27; 后: &quot;</span> + fruitColor);</span><br><span class="line">        <span class="comment">// 再次使用 size() 方法返回映射中的键值对数量</span></span><br><span class="line">        size = fruitColor.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;移除后映射的大小: &quot;</span> + size);</span><br><span class="line">        <span class="comment">// 使用 clear() 方法移除映射中的所有键值对</span></span><br><span class="line">        fruitColor.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空映射后: &quot;</span> + fruitColor);</span><br><span class="line">        <span class="comment">// 使用 isEmpty() 方法检查映射是否为空</span></span><br><span class="line">        isEmpty = fruitColor.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空后映射是否为空: &quot;</span> + isEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><code>HashMap</code>是基于哈希表实现的键值对存储结构，HashMap的核心实现结合了<code>数组</code>、<code>链表</code>和<code>红黑树</code>。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>数组</code>：默认初始容量为16，数组的每个位置称为一个桶(<code>Bucket</code>)。容量始终为<strong>2的幂次方</strong>(如16、32)，便于通过位运算快速定位索引。<br><code>链表</code>：当多个键的哈希值冲突时，这些键值对以链表形式存储在同一个桶中（链地址法）。<br><code>红黑树</code>：当链表长度超过阈值（默认8）且数组容量≥64时，链表会转换为<code>红黑树</code>，以提高查找效率（从<code>O(n)</code>优化为<code>O(log n)</code>）。</p><h3 id="哈希函数与索引定位"><a href="#哈希函数与索引定位" class="headerlink" title="哈希函数与索引定位"></a>哈希函数与索引定位</h3><p>HashMap通过哈希函数将键映射到数组的索引位置。具体步骤如下：</p><ol><li><p>调用键的<code>hashCode()</code>方法获取哈希值。</p></li><li><p><strong>扰动处理：</strong>将高16位与低16位异或<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，减少哈希碰撞概率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>(n-1) &amp; hash</code>计算桶位置，等价于<code>hash % n</code>，但性能更高‌。</p></li></ol><h3 id="冲突处理机制"><a href="#冲突处理机制" class="headerlink" title="冲突处理机制"></a>冲突处理机制</h3><ol><li><p><strong>链地址法：</strong>冲突的键值对以链表形式链接。在JDK 8之前采用头插法，JDK 8之后采用尾插法以避免多线程下的死循环问题‌</p></li><li><p><strong>红黑树转换：</strong></p><ol><li><p>当链表长度≥8且数组容量≥64时，链表会转换为红黑树‌。</p></li><li><p>红黑树节点数≤6时，退化为链表</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250623125725272.png" alt="image-20250623125725272"></p></li></ol></li></ol><h3 id="动态扩容机制"><a href="#动态扩容机制" class="headerlink" title="动态扩容机制"></a>动态扩容机制</h3><p>HashMap的扩容机制基于负载因子（默认值为0.75）。当元素数量超过<code>容量乘以负载因子</code>时，比如<strong>当数组添加到16*0.75=12时</strong>，HashMap会自动触发扩容，扩容为自身的两倍：16*2=32。扩容步骤如下：</p><ol><li>创建一个新的数组，<code>容量为原容量的两倍</code>（保持2的幂次方）。采用2的指数进行扩容，是为了利用位运算，提高扩容运算的效率。</li><li>重新计算所有元素的位置并放入新数组的对应位置，利用高位快速判断元素是否需要移动（如原索引为<code>oldIndex</code>，新索引可能为<code>oldIndex</code>或<code>oldIndex + oldCapacity</code>）。</li><li>数组每个元素存的是链表头结点地址，链地址法处理冲突，若链表的长度达到了8，红黑树代替链表。扩容后，链表或红黑树可能会被拆分到不同的桶中‌。</li></ol><h3 id="HashMap容量为什么是2的n次方"><a href="#HashMap容量为什么是2的n次方" class="headerlink" title="HashMap容量为什么是2的n次方"></a>HashMap容量为什么是2的n次方</h3><p>2^n-1和2^(n+1)-1的二进制除了第一位，后几位都相同。这样<em>使得添加的元素均匀分布在HashMap的每个位置上，防止哈希碰撞</em>。</p><p><strong>例如</strong>15的二进制为1111，31的二进制为11111，63的二进制为111111，127的二进制为1111111。</p><p>扩容均匀散列演示：从2^4扩容成2^5</p><p>0&amp;(2^4-1)=0；0&amp;(2^5-1)=0</p><p>16&amp;(2^4-1)=0；16&amp;(2^5-1)=16。所以扩容后，key为0的一部分value位置没变，一部分value迁移到扩容后的新位置。</p><p>1&amp;(2^4-1)=1；1&amp;(2^5-1)=1</p><p>17&amp;(2^4-1)=1；17&amp;(2^5-1)=17。所以扩容后，key为1的一部分value位置没变，一部分value迁移到扩容后的新位置。</p><h3 id="put-流程"><a href="#put-流程" class="headerlink" title="put()流程"></a>put()流程</h3><ol><li>计算key存取位置，与运算hash&amp;(2^n-1），实际就是哈希值取余，位运算效率更高。</li><li>判断数组，若发现数组为空，则进行首次扩容为初始容量16。</li><li>判断数组存取位置的头节点，若发现头节点为空，则新建链表节点，存入数组。</li><li>判断数组存取位置的头节点，若发现头节点非空，则看情况将元素覆盖或插入链表（JDK7头插法，JDK8尾插法）、红黑树。</li><li>插入元素后，判断元素的个数，若发现超过阈值则以2的指数再次扩容。</li></ol><p>其中，第3步又可以细分为如下三个小步骤：</p><ol><li><p>若元素的key与头节点的key一致，则直接覆盖头节点。</p></li><li><p>若元素为树型节点，则将元素追加到树中。</p></li><li><p> 若元素为链表节点，则将元素追加到链表中。追加后，需要判断链表长度以决定是否转为红黑树。若链表长度达到8、数组容量未达到64，则扩容。若链表长度达到8、数组容量达到64，则转为红黑树。</p></li></ol><p><strong>哈希表处理冲突：</strong>开放地址法（线性探测、二次探测、再哈希法）、链地址法</p><h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><ul><li><p><strong>遍历EntrySet（键值对）</strong>：支持通过<code>iterator.remove()</code>安全删除元素(优点)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;K, V&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>遍历KeySet（仅键）</strong>：性能低于<code>EntrySet</code>遍历，需多次调用<code>get()</code>（缺点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;K&gt; keyIterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key); <span class="comment">// 需要额外查询值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for-each循环"></a>for-each循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历EntrySet</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历键</span></span><br><span class="line"><span class="keyword">for</span> (K key : map.keySet()) &#123; ... &#125;</span><br><span class="line"><span class="comment">// 遍历值</span></span><br><span class="line"><span class="keyword">for</span> (V value : map.values()) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式遍历（Java-8-）"><a href="#Lambda表达式遍历（Java-8-）" class="headerlink" title="Lambda表达式遍历（Java 8+）"></a>Lambda表达式遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach( (key, value) -&gt; System.out.println(key + <span class="string">&quot; : &quot;</span> + value) );</span><br></pre></td></tr></table></figure><h3 id="Stream-API遍历（Java-8-）"><a href="#Stream-API遍历（Java-8-）" class="headerlink" title="Stream API遍历（Java 8+）"></a>Stream API遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单线程遍历</span></span><br><span class="line">map.entrySet().stream().forEach(entry -&gt; ...);</span><br><span class="line"><span class="comment">// 多线程遍历</span></span><br><span class="line">map.entrySet().parallelStream().forEach(entry -&gt; ...);</span><br></pre></td></tr></table></figure><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><table><thead><tr><th><strong>遍历方式</strong></th><th><strong>时间复杂度</strong></th><th><strong>适用场景</strong></th><th><strong>线程安全</strong></th></tr></thead><tbody><tr><td>EntrySet迭代器</td><td>O(n)</td><td>需要删除元素</td><td>需手动同步</td></tr><tr><td>EntrySet for-each</td><td>O(n)</td><td>常规遍历</td><td>需手动同步</td></tr><tr><td>KeySet遍历</td><td>O(n)（性能较低）</td><td>仅需键</td><td>需手动同步</td></tr><tr><td>Lambda表达式</td><td>O(n)</td><td>代码简洁性优先</td><td>需手动同步</td></tr><tr><td>Stream API</td><td>O(n)</td><td>大数据量处理或并行计算</td><td>需手动同步</td></tr></tbody></table><p><strong>推荐选择</strong>：</p><ul><li><strong>需键值对</strong>：优先使用<code>entrySet()</code>（迭代器或for-each）。</li><li><strong>仅需键或值</strong>：直接遍历<code>keySet()</code>或<code>values()</code>。</li><li><strong>代码简洁性</strong>：Java 8+环境下推荐Lambda表达式。</li><li><strong>线程安全</strong>：改用<code>ConcurrentHashMap</code>或使用同步包装类。</li></ul><h2 id="HashMap和HashSet区别"><a href="#HashMap和HashSet区别" class="headerlink" title="HashMap和HashSet区别"></a>HashMap和HashSet区别</h2><p><strong>相同点：</strong></p><ul><li><p>他们的前缀的是HashXxx，代表他们底层都是哈希表，用hashCode()判断元素是否重复。</p><p>哈希表增删改查的时间复杂度是O(1)，缺点是可能出现冲突。</p><p>HashXxx都使用哈希算法来确定元素的存储位置，因此插入元素的速度通常比较快。哈希表插入时主要看是否发生冲突，如果key通过哈希算法计算后的值所处位置已有元素，则需要根据链地址法或开放地址法处理冲突。</p></li></ul><p><strong>不同点：</strong></p><table><thead><tr><th align="left">特性</th><th align="left">HashMap</th><th align="left">HashSet</th></tr></thead><tbody><tr><td align="left"><strong>接口</strong></td><td align="left">实现了 Map 接口</td><td align="left">实现了 Set 接口</td></tr><tr><td align="left"><strong>存储结构</strong></td><td align="left">存储<strong>键值对</strong>（Key-Value pairs）</td><td align="left">仅存储<strong>对象</strong>（Unique elements）</td></tr><tr><td align="left"><strong>存储方式</strong></td><td align="left">使用 put() 方法将元素放入 Map 中</td><td align="left">使用 add() 方法将元素放入 Set 中</td></tr><tr><td align="left"><strong>底层实现</strong></td><td align="left">基于哈希表，使用数组+链表+红黑树</td><td align="left">基于 <strong>HashMap</strong> 实现<strong>HashMap 的key是每个元素</strong>value是一个私有常量对象PRESENT，仅用于占位。</td></tr><tr><td align="left"><strong>存储内容</strong></td><td align="left">键和值都可以为 null，键最多只能有一个 null</td><td align="left">仅允许一个 null 元素因为它底层是HashMap的key，键只允许一个null</td></tr><tr><td align="left"><strong>是否允许重复</strong></td><td align="left">键不允许重复，值可以重复</td><td align="left">不允许重复元素</td></tr><tr><td align="left"><strong>时间复杂度</strong></td><td align="left">插入、删除、查找的平均时间复杂度为 O(1)</td><td align="left">插入、删除、查找的平均时间复杂度为 O(1)，但 contains() 时间复杂度可能更高</td></tr><tr><td align="left"><strong>插入速度</strong></td><td align="left">比较快，因为底层是哈希表</td><td align="left">比较快，因为底层是哈希表</td></tr><tr><td align="left"><strong>使用场景</strong></td><td align="left">需要键值对映射的场景</td><td align="left">需要存储唯一元素、自动去重的场景</td></tr></tbody></table><h2 id="HashMap安全"><a href="#HashMap安全" class="headerlink" title="HashMap安全"></a>HashMap安全</h2><p>HashMap是线程不安全的，多线程环境下建议使用Collections工具类和JUC包的ConcurrentHashMap。</p><blockquote><ul><li><strong>线程安全：</strong>程序在多线程环境下可以持续进行正确的处理，不会产生数据竞争（例如死锁）和不一致的问题。</li></ul></blockquote><h3 id="HashMap线程不安全的表现"><a href="#HashMap线程不安全的表现" class="headerlink" title="HashMap线程不安全的表现"></a>HashMap线程不安全的表现</h3><ol><li><p><strong>JDK8 put时数据覆盖（丢失）</strong><br><strong>场景：</strong>多线程同时调用 <code>put()</code> 方法插入数据。<br><strong>原因：</strong>两个线程同时计算哈希值并定位到同一个桶(bucket)时，若该位置为空，可能发生数据覆盖。<strong>无锁导致复合操作非原子性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设线程A和线程B同时执行以下代码</span></span><br><span class="line"><span class="keyword">if</span> (table[bucket] == <span class="literal">null</span>) &#123;</span><br><span class="line"> table[bucket] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value); <span class="comment">// 可能被覆盖</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK 1.8 的数据覆盖问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapUnsafeDemo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">             map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">             map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     t1.start();</span><br><span class="line">     t2.start();</span><br><span class="line">     t1.join();</span><br><span class="line">     t2.join();</span><br><span class="line">     System.out.println(<span class="string">&quot;Map size: &quot;</span> + map.size()); <span class="comment">// 结果可能小于 1000</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 底层源码</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)     <span class="comment">// 如果没有 hash 碰撞，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>链表成环</strong>（JDK7 的经典问题）<br><strong>场景：</strong>多线程同时触发 <code>resize()</code>（扩容）。<br><strong>原因：</strong>JDK7 的 HashMap 使用<strong>头插法</strong>迁移链表，<strong>并发扩容时可能导致链表成环</strong>，后续的 <code>get()</code>操作触发死循环。</p><p><strong>单线程扩容流程</strong>：JDK7中，HashMap链地址法处理冲突时采用头插法，在扩容时依然头插法，所以链表里结点顺序会反过来。</p><p>假如有T1、T2两个线程同时对某链表扩容，他们都标记头结点和第二个结点，此时T2阻塞，T1执行完扩容后链表结点顺序反过来，此时T2恢复运行再进行翻转就会产生环形链表，即B.next=A; A.next=B，从而死循环。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250724151230023.png" alt="image-20250724151230023"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.7 的扩容代码（简化）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">     <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">         Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程A执行到这里挂起</span></span><br><span class="line">         e.next = newTable[bucket]; <span class="comment">// 线程B先执行，导致链表成环</span></span><br><span class="line">         newTable[bucket] = e;</span><br><span class="line">         e = next;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK8 尾插法：</strong>JDK8中，HashMap采用尾插法，扩容时链表节点位置不会翻转，解决了扩容死循环问题，但是性能差了一点，因为要遍历链表再查到尾部。 </p></li><li><p><strong>size 不准确</strong><br><strong>场景：</strong>多线程同时调用 <code>put()</code> 或 <code>remove()</code>。<br><strong>原因：</strong>size 变量是非原子操作（如 size++），并发修改可能导致最终值错误。<strong>非原子操作 + 无可见性保证</strong>。</p></li><li><h5 id="modCount非原子性自增问题"><a href="#modCount非原子性自增问题" class="headerlink" title="modCount非原子性自增问题"></a><strong>modCount非原子性自增问题</strong></h5><p>put会执行modCount++操作（modCount是HashMap的成员变量，用于记录HashMap被修改次数），这步操作分为读取、增加、保存，不是一个原子性操作，也会出现线程安全问题。 </p></li></ol><h3 id="HashMap线程不安全的根本原因"><a href="#HashMap线程不安全的根本原因" class="headerlink" title="HashMap线程不安全的根本原因"></a>HashMap线程不安全的根本原因</h3><ol><li><strong>无同步机制</strong><br>HashMap 的设计目标是单线程高性能，未对多线程操作进行同步（如 <code>synchronized</code> 或 <code>CAS</code>）。<br>关键操作（<code>put()、get()、resize()</code>）没有锁保护。</li><li><strong>可见性问题</strong><br>多线程修改共享变量（如 <code>table、size</code>）时，未使用 <code>volatile</code> 关键字，可能导致一个线程的修改对其他线程不可见。</li><li><strong>复合操作非原子性</strong><br>例如 <code>put()</code> 操作包含多个步骤（计算哈希、定位桶、插入节点），多线程交叉执行时可能破坏内部结构。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>原子类、volatile、锁、线程安全的集合 </p><ol><li>使用线程安全的替代类<pre><code>`Collections.synchronizedMap()`：通过包装类对所有方法加锁（性能较差）。`ConcurrentHashMap`：分段锁（JDK 1.7）或 CAS + synchronized（JDK 1.8），高并发性能更好。</code></pre></li><li>避免多线程直接操作 HashMap<br>限制为单线程使用，或通过副本、消息队列等方式隔离并发访问。</li></ol><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>在<code>jdk1.7</code>版本<ul><li>ConcurrentHashMap的数据结构是由一个<code>Segment</code>数组和多个<code>HashEntry</code>组成。</li><li>主要实现原理是实现了<strong>锁分离</strong>的思路，采用<strong>分段锁的机制</strong>，实现并发的更新操作。</li><li>底层采用<strong>数组+链表</strong>的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。</li><li>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到 的锁分离技术。每一个Segment元素存储的是HashEntry 数组+链表（若干个桶），这个和HashMap的数据存储结构一样。</li><li>HashEntry用来封装映射表的键值对，每个桶是由若干个HashEntry对象链接起来的链表。</li></ul></li><li>在<code>jdk1.8</code>后<ul><li>取消了Segment类，直接用table数组存储键值对。采用<code>Node + CAS + Synchronized</code>来保证并发安全。</li><li>Node数据结构比较简单，就是一个链表，但是只允许对数据进行查找，不允许进行修改。</li><li>当HashEntry对象组成的链表长度超过8时，或数组长度小于64 就会扩容，则链表转换为红黑树，提升性能。底层变更为<strong>数组＋链表＋红黑树</strong>。</li></ul></li></ul><h4 id="底层原理（jdk1-8）"><a href="#底层原理（jdk1-8）" class="headerlink" title="底层原理（jdk1.8）"></a>底层原理（jdk1.8）</h4><ol><li><p>Node节点数字用的是<code>volatile</code>修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap使用volatile修饰节点数组，保证其可见性，禁止指令重排。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p>ConcurrentHashMap的<code>put()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put()方法直接调用putVal()方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以直接看putVal()方法。</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            tab = initTable();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;                  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法并未用synchronized修饰。<strong>put过程如下：</strong><br>（1）根据 key 计算出 hashcode，然后开始遍历 table；<br>（2）判断是否需要初始化；<br>（3）f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。<br>（4）如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。<br>（5）如果都不满足，则利用 synchronized 锁写入数据。<br>（6）如果数量大于 TREEIFY_THRESHOLD ，则要转换为红黑树。</p></li><li><p>ConcurrentHashMap的<code>get()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap的get()方法是不加锁的，方法内部也没加锁。</span></span><br><span class="line"><span class="comment">// 因为table有`volatile`关键字修饰，保证每次获取值都是最新的。</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span></span><br></pre></td></tr></table></figure><p>get方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头节点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果头节点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get过程如下：</strong><br>（1）首先根据key计算出来的 hashcode 寻址，如果就在桶上那么直接返回值，<br>（2）如果是红黑树那就按照树的方式获取值，<br>（3）都不满足那就按照链表的方式遍历获取值。</p></li></ol><hr><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>参考链接：<a href="https://blog.csdn.net/m0_37741420/article/details/112407684">Java集合（四）Set的常用实现类</a></p><p>List是有序集合的根接口，Set是无序集合的根接口，无序也就意味着元素不重复。更严格地说，Set集合不包含一对元素e1和e2 ，使得e1.equals(e2) ，并且最多一个空元素。<br>使用Set存储的特点与List相反：<strong>元素无序、不可重复</strong>。常用的实现方式：HashSet、LinkedHashSet和TreeSet。</p><table><thead><tr><th>具体实现</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>HashSet</td><td>底层数据结构是哈希表，可以存储null元素，效率高</td><td>线程不安全，需要重写hashCode()和equals()来保证元素唯一性</td></tr><tr><td>LinkedHashSet</td><td>底层数据结构是链表和哈希表(链表保证了元素的顺序与存储顺序一致，哈希表保证了元素的唯一性)，效率高</td><td>线程不安全</td></tr><tr><td>TreeSet</td><td>底层数据结构是二叉树，元素唯一且已经排好序</td><td>需要重写hashCode和equals()来保证元素唯一性</td></tr></tbody></table><p>当向HashSet结合中存入一个元素时，HashSet会调用该对象的<code>hashCode()</code>方法来得到该对象的hashCode值，然后根据hashCode值来决定该对象在HashSet中存储位置。简单的说，<strong>HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等</strong>。<br>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p><p>在使用Set存储数据时，为保障元素唯一性，常常要重写hashCode。重写hashCode方法时，尽量遵循以下原则：</p><ul><li>相同的对象返回相同的hashCode值。</li><li>不同的对象返回不同的hashCode值，否则，就会增加冲突的概率。</li><li>尽量的让hashCode值散列开（用异或运算可使结果的范围更广）。</li></ul><h2 id="Hashset"><a href="#Hashset" class="headerlink" title="Hashset"></a>Hashset</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>HashSet是一个无序集合，其底层结构是HashMap，简单来说，HashSet是value是固定值（<code>Object PRESENT = new Object()</code>）的HashMap。HashSet的特点(<strong>底层是HashMap/元素无序且不能重复/线程不安全</strong>)：</p><ul><li><p><strong>使用场景：</strong>需要高效去重、快速查找、不考虑内存浪费的场景</p></li><li><p>HashSet的<strong>底层实现是HashMap</strong>（HashSet的值存放于HashMap的key上，HashMap的value是一个统一的值）。</p></li><li><p><strong>底层：</strong>哈希表（快速查找）和Set（去重）。它自动对元素进行去重（通过 hashCode 和 equals 方法），并且无序（存入后顺序会乱），允许存储一个null值。</p></li><li><p><strong>性能：</strong>底层是哈希表，所以插入、删除和查找操作的时间复杂度都是O(1)，代价是浪费一些空间。</p></li><li><p><strong>线程不安全</strong>。如果要保证线程安全，其中一种方法是将其改造成线程安全的类，示例：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>(...));</span><br></pre></td></tr></table></figure></li></ul><p>哈希表是元素为链表的数组，默认容量16，负载因子0.75，处理冲突方法是链地址法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet&lt;String &gt; h = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        h.add(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">        h.add(s1);</span><br><span class="line">        System.out.println(s1 == <span class="string">&quot;nihao&quot;</span>);        <span class="comment">//false</span></span><br><span class="line">        <span class="keyword">for</span>(String s:h) System.out.println(s);     <span class="comment">//不含重复元素 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果Hashset里的元素是对象，若想将成员变量相同视为对象相同，要重写hashCode()：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    <span class="comment">//输出23</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>);</span><br><span class="line">        HashSet&lt;Dog&gt; h = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Dog&gt;();</span><br><span class="line">        h.add(dog1);h.add(dog2);</span><br><span class="line">        <span class="keyword">for</span>(Dog dog:h)&#123;</span><br><span class="line">            System.out.println(dog.weight); </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//         System.out.println(&quot;doggouzaao&quot;);</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> weight)</span>&#123;</span><br><span class="line">         <span class="built_in">this</span>.weight=weight;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;dogname&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// alt+insert生成equals()和hashCode()方法。这里只需重写hashCode方法就能保证自动去重，equals方法用于元素间的比较</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) o;</span><br><span class="line">        <span class="keyword">return</span> weight == dog.weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h3><p><strong>HashSet自动去重的原理：</strong>hashCode值。</p><p>所有Java的类或接口都直接或间接继承了Object类，Object类是一切类的根类。Object类有<code>clone()，HashCode()，equals()，toString()，wait()，notify()</code>等基本方法，可以重写这些方法，对类的特性进行设置。</p><p>例如给测试类新加一个hashCode()方法，而不加@Override注解（用于声明一个方法为重写的方法），编译器将进行警告：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译器将进行警告：hashCode()&#x27;缺少&#x27;@Override&#x27;注解</span></span><br></pre></td></tr></table></figure><p>默认情况下，哈希值是根据对象的地址计算出的一个整数值，故同一对象的哈希值一定相同（因为地址是同一地址），不同对象的哈希值默认不同（因为地址不同）。</p><p>把对象加入HashSet时，HashSet会<strong>先计算对象的hashcode值来判断对象加入的位置</strong>，同时也会与Set中其他元素的hashcode值作比较，如果没有相同的hashcode，HashSet会假设对象没有重复出现。如果发现有相同hashcode值的对象，这时会调用<code>equals</code>方法来检查<strong>hashcode相等的对象是否真的相同</strong>。如果两者相同，HashSet就不再存储该元素。<code>hashCode()</code>与 <code>equals()</code>的相关规定：</p><ul><li>如果两个对象相等，则hashcode一定也是相同的；</li><li>两个对象相等，对两个equals方法返回true；</li><li>两个对象有相同的hashcode值，它们也不一定是相等的；</li><li>如果equals方法被覆盖过，则hashCode方法也必须被覆盖；</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该 class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ul><p>重写hashCode()后哈希值可以相同，例如给Student类重写hashCode()，返回学生的学号，那么学号相同的学生，哈希值就一定相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 hashCode() 方法，返回学号作为哈希值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 equals() 方法，判断学号是否相同</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) obj;</span><br><span class="line">        <span class="keyword">return</span> id == student.id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 toString() 方法，返回学生姓名和学号</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, id=&quot;</span> + id + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 根据重写的 equals() 方法输出</span></span><br><span class="line">        System.out.println(student1.equals(student2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(student1.hashCode()); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(student2.hashCode()); <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// 根据重写的 toString() 方法输出</span></span><br><span class="line">        System.out.println(student1.toString()); <span class="comment">// Student&#123;name=&#x27;Tom&#x27;, id=1&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> <span class="comment">// 默认初始容量为16，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> <span class="comment">// 指定初始容量，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> <span class="comment">// 指定初始容量和负载因子</span></span><br><span class="line"><span class="comment">/* 增、删、包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断Set是否为空    </span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> <span class="comment">//获取迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 返回此集合中的元素数        </span></span><br></pre></td></tr></table></figure><h3 id="知识加油站-1"><a href="#知识加油站-1" class="headerlink" title="知识加油站"></a>知识加油站</h3><h4 id="equals-和hashcode-的关系"><a href="#equals-和hashcode-的关系" class="headerlink" title="equals()和hashcode()的关系"></a>equals()和hashcode()的关系</h4><p><strong>两者在用途上的区别：</strong></p><ul><li>hashCode()方法的主要用途是获取哈希码；</li><li>equals()主要用来比较两个对象是否相等。</li></ul><h4 id="为什么重写equals-就要重写hashcode"><a href="#为什么重写equals-就要重写hashcode" class="headerlink" title="为什么重写equals()就要重写hashcode()"></a><strong>为什么重写equals()就要重写hashcode()</strong></h4><p>因为二者之间有两个约定，<strong>相等对象的哈希码也要相等</strong>。所以equals()方法重写时，通常也要将hashCode()进行重写，使得这两个方法始终满足相关的约定。 例如HashSet排序机制底层就是通过计算哈希码进行排序的，如果只重写equals()将达不到根据哈希码排序的效果。</p><p>如果两个对象相等，它们必须有相同的哈希码；但如果两个对象的哈希码相同，他们却不一定相等。</p><h4 id="与equals-的区别"><a href="#与equals-的区别" class="headerlink" title="==与equals()的区别"></a><code>==</code>与equals()的区别</h4><ul><li><p><strong><code>==</code></strong> 比较基本数据类型时，比较的是两个数值是否相等； 比较引用类型是，比较的是对象的内存地址是否相等。  </p></li><li><p><strong><code>equals()</code></strong> 未重写时，Object类默认以<code>==</code>来实现，即比较两个对象的内存地址是否相等； 重写以后，按照重写的逻辑进行比较。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(0bject obj)</span> &#123; <span class="keyword">return</span>(<span class="built_in">this</span> == obj); &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>LinkedHashSet是有序集合，其底层是通过LinkedHashMap来实现的，LinkedHashMap其实也就是value是固定值的LinkedHashMap。因此LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。LinkedHashSet继承了HashSet。LinkedHashSet的特点(<strong>底层是LinkedHashMap/线程不安全/元素有序</strong>)：</p><ul><li><p>底层是用LinkedHashMap来实现的。</p></li><li><p>线程不安全 。</p></li><li><p>元素有序，是按照插入的顺序排序的。</p></li><li><p>最多只能存一个null。</p></li><li><p>不支持按访问顺序对元素排序</p><p>LinkedHashSet所有的构造方法都是调用HashSet的同一个构造方法：（accessOrder = false）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li><p><strong>使用场景：</strong>适用于多读少写、排序的场景。</p></li><li><p><strong>底层：</strong>红黑树（快速查找、排序）和Set（去重）。<strong>不允许存储null值</strong></p></li><li><p><strong>性能：</strong>插入、删除、查找操作的时间复杂度为O(log n)，因为操作需要维护树的平衡，所以适用于多读少写的场景。</p></li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>TreeSet是一个有序集合，基于TreeMap实现。TreeSet特点(<strong>支持元素排序/线程不安全/去重复</strong>):</p><ul><li><p>TreeSet的基本操作（增删）的时间复杂度是log(n) 。</p></li><li><p>TreeSet是非线程安全的。</p></li><li><p>TreeSet的迭代器是fail-fast策略的。</p></li><li><p>TreeSet中元素不允许为null，不允许重复值。</p></li><li><p>TreeSet有序（自然顺序或自定义排序器）。支持元素自然排序和按照在创建时指定Comparator比较器(外比较器)进行排序：</p><ul><li>TreeSet使用二叉树原理对新增对象按照指定顺序排序，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li></ul></li></ul><pre><code>- TreeSet中存储自定义类的对象时， 自定义的类必须实现Comparable接口，并且覆写相应`compareTo()`函数。- **元素为基本类型时自然有序：**new TreeSet&lt;int&gt;()。如果TreeSet内元素是**基本数据类型**，它会自动去重有序。Integer和String对象都可以进行默认的TreeSet排序。- **元素为类时自然或比较器排序：**new TreeSet&lt;类&gt;(Comperable c)。如果TreeSet内元素是类，要实现去重有序，有两种方法。  - **自然排序：**类要实现Comparable&lt;&gt;接口，并重写compareTo（T）方法；  - **比较器排序：**以比较器作为构造参数，创建TreeSet对象。如果即实现了Comparable&lt;&gt;接口，又指定了比较器，则使用比较器排序。  - 在重写compareTo()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。示例：    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>  <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(student s)</span> &#123;</span><br><span class="line">        <span class="comment">// 主要条件：按照年龄从小到大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="built_in">this</span>.age - s.age;</span><br><span class="line">        <span class="comment">//次要条件：年龄相同时，按照姓名的字母顺序排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num == <span class="number">0</span> ? <span class="built_in">this</span>.name.compareTo(s.name) : num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comparabledemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;student&gt; tree = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;student&gt;();</span><br><span class="line">        <span class="type">student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;wuer&quot;</span>,<span class="number">27</span>);</span><br><span class="line">        <span class="type">student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;weuers&quot;</span>,<span class="number">250</span>);</span><br><span class="line">        tree.add(s1);</span><br><span class="line">        tree.add(s2);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="方法一：自然排序"><a href="#方法一：自然排序" class="headerlink" title="方法一：自然排序"></a>方法一：自然排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗类：按自然排序时要实现Comperable&lt;&gt;并重写compareTo()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span>  <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt;&#123;        </span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    String name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> weight, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123; weight=&quot;</span> + weight + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog dog)</span>&#123;    <span class="comment">// 实参是上一只狗，本狗与上狗做比较</span></span><br><span class="line">        <span class="comment">// 返回正数，即本狗比上只狗大，按存取顺序排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// return -1; 存储逆序排序</span></span><br><span class="line">        <span class="comment">// return 0; 视为相等，后插入的重复元素会被删除。</span></span><br><span class="line">        <span class="comment">// return this.weight-dog.weight; 按体重从小到大排序，后狗-前狗。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建两个小狗对象，让他们按自己compareTo()逻辑排序，即按存取顺序排序</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">45</span>,<span class="string">&quot;abc&quot;</span>); <span class="type">Dog</span> <span class="variable">dog3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">45</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        TreeSet&lt;Dog&gt; dogs = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        dogs.add(dog1);dogs.add(dog2);dogs.add(dog3);</span><br><span class="line">        <span class="comment">// 因为第三只狗和第二只狗存取顺序不同，所以他们被认为是两只狗</span></span><br><span class="line">        <span class="comment">// [Dog&#123;weight=23, name=&#x27;abc&#x27;&#125;, Dog&#123;weight=45, name=&#x27;abc&#x27;&#125;, Dog&#123;weight=45, name=&#x27;abc&#x27;&#125;]</span></span><br><span class="line">        System.out.println(dogs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：比较器排序"><a href="#方法二：比较器排序" class="headerlink" title="方法二：比较器排序"></a>方法二：比较器排序</h3><p>无需Dog类再实现Comparable接口，直接TreeSet类带参构造方式创建对象即可，参数为比较器Comparator&lt;&gt;。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗类：按比较器排序时不需要再实现Comperable&lt;&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> weight, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123; weight=&quot;</span> + weight + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) o;</span><br><span class="line">        <span class="keyword">return</span> weight == dog.weight &amp;&amp; Objects.equals(name, dog.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(weight, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//下面比较器也可以用Lambda表达式形式，即TreeSet&lt;&gt;((a,b)-&gt;&#123;..&#125;)</span></span><br><span class="line">        TreeSet&lt;Dog&gt; dogs=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Dog&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Dog a, Dog b)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a.weight!=b.weight) &#123;</span><br><span class="line">                    <span class="keyword">return</span> a.weight-b.weight;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> a.name.compareTo(b.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">34</span>,<span class="string">&quot;abc&quot;</span>)); dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">26</span>,<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">26</span>,<span class="string">&quot;abcd&quot;</span>)); dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">26</span>,<span class="string">&quot;abcd&quot;</span>));</span><br><span class="line">        <span class="comment">// 可以看见，前三只狗按体重、名称排序，第四只狗被去重了</span></span><br><span class="line">        <span class="comment">// [Dog&#123;weight=26, name=&#x27;abc&#x27;&#125;, Dog&#123;weight=26, name=&#x27;abcd&#x27;&#125;, Dog&#123;weight=34, name=&#x27;abc&#x27;&#125;]</span></span><br><span class="line">        System.out.println(dogs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> <span class="comment">// 创建一个空的 TreeSet，使用自然排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> <span class="comment">// 指定比较器，如果比较器是 null 将使用自然排序</span></span><br><span class="line"><span class="comment">/* 增 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> <span class="comment">// 添加一个元素</span></span><br><span class="line"><span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> <span class="comment">// 添加集合中的元素</span></span><br><span class="line"><span class="comment">/* 删 */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> <span class="comment">// 检索和删除最小（第一个）元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> <span class="comment">// 检索和删除最大（最后）元素</span></span><br><span class="line"><span class="comment">/* 包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 获取特殊元素 */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">last</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">first</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">floor</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中小于或者等于给定元素的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">ceiling</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中大于或者等于给定元素的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">higher</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中大于某个元素的最小的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">lower</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中小于某个元素的最大的元素   </span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 获取TreeSet元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断TreeSet是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空TreeSet</span></span><br></pre></td></tr></table></figure><h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><p><strong>相同点：</strong>元素都可以自动去重</p><p><strong>不同点：</strong></p><table><thead><tr><th align="left"></th><th align="left">HashSet</th><th><strong>TreeSet</strong></th></tr></thead><tbody><tr><td align="left"><strong>实现</strong></td><td align="left">基于哈希表 实现</td><td>基于红黑树 (Red-Black Tree) 实现</td></tr><tr><td align="left"><strong>排序</strong></td><td align="left">不保证顺序</td><td>按自然顺序或指定的比较器排序</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">插入、删除和查找操作的时间复杂度为 O(1)</td><td>插入、删除和查找操作的时间复杂度为 O(log n)</td></tr><tr><td align="left"><strong>是否允许 null 元素</strong></td><td align="left">允许存储一个 null 元素</td><td>不允许存储 null 元素</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">适用于对顺序无要求、自动去重、快速查找和插入的场景</td><td>适用于需要自动有序、去重存储的场景</td></tr><tr><td align="left"><strong>去重原理</strong></td><td align="left">通过复写hashCode()方法和equals()方法来保证</td><td>Treeset通过Compareable接口的compareto来保证。</td></tr></tbody></table><hr><h1 id="ArrayDeque：双端队列"><a href="#ArrayDeque：双端队列" class="headerlink" title="ArrayDeque：双端队列"></a>ArrayDeque：双端队列</h1><p>ArrayDeque 是 Java 中基于动态数组实现的双端队列（<code>Double-Ended Queue</code>），同时支持栈（Stack）和队列（Queue）的操作。在刷力扣等算法题时经常使用这个集合。</p><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul><li>双端操作：可以在队列的头部和尾部高效地插入/删除元素（时间复杂度 O(1)）。</li><li>动态扩容：底层是循环数组，容量不足时自动扩容（默认初始容量为 16）。</li><li>非线程安全：需手动处理并发问题。</li><li>性能高：对比 LinkedList（基于链表），数组结构对 CPU 缓存更友好，随机访问更快。</li></ul><h2 id="作为栈（先进后出）的核心方法"><a href="#作为栈（先进后出）的核心方法" class="headerlink" title="作为栈（先进后出）的核心方法"></a>作为栈（先进后出）的核心方法</h2><table><thead><tr><th>操作类型</th><th>方法名</th><th>功能描述</th><th>返回值/异常</th></tr></thead><tbody><tr><td><strong>增</strong></td><td><strong><code>push(E element)</code></strong></td><td>压栈（元素添加到头部）</td><td>无返回值，队列满时自动扩容</td></tr><tr><td></td><td><code>addFirst(E element)</code></td><td>同 <code>push</code></td><td>队列满时抛出 <code>IllegalStateException</code>（但 <code>ArrayDeque</code> 动态扩容，一般不会）</td></tr><tr><td><strong>删</strong></td><td><strong><code>pop()</code></strong></td><td>弹栈（移除并返回头部元素）</td><td>返回头部元素；栈为空时抛出 <code>NoSuchElementException</code></td></tr><tr><td></td><td><code>removeFirst()</code></td><td>同 <code>pop()</code></td><td>同上</td></tr><tr><td><strong>查</strong></td><td><strong><code>peek()/peekFirst()</code></strong></td><td>查看栈顶元素（不删除）</td><td>返回头部元素；栈为空时返回 <code>null</code></td></tr><tr><td></td><td><strong>peekLast()</strong></td><td><strong>查看栈尾元素</strong>（不删除）</td><td>返回尾部元素；栈为空时返回 <code>null</code></td></tr></tbody></table><h2 id="作为队列（先进先出）的核心方法"><a href="#作为队列（先进先出）的核心方法" class="headerlink" title="作为队列（先进先出）的核心方法"></a>作为队列（先进先出）的核心方法</h2><table><thead><tr><th>操作类型</th><th>方法名</th><th>功能描述</th><th>返回值/异常</th></tr></thead><tbody><tr><td><strong>增</strong></td><td><strong><code>offer(E element)</code></strong></td><td>入队（元素添加到尾部）</td><td>成功返回 <code>true</code>，队列满时返回 <code>false</code>（但 <code>ArrayDeque</code> 动态扩容，总是成功）</td></tr><tr><td></td><td><code>addLast(E element)</code></td><td>同 <code>offer</code></td><td>队列满时抛出 <code>IllegalStateException</code>（理论上不会触发）</td></tr><tr><td><strong>删</strong></td><td><strong><code>poll()</code></strong></td><td>出队（移除并返回头部元素）</td><td>返回头部元素；队列为空时返回 <code>null</code></td></tr><tr><td></td><td><code>removeFirst()</code></td><td>同 <code>poll()</code></td><td>队列为空时抛出 <code>NoSuchElementException</code></td></tr><tr><td><strong>查</strong></td><td><strong><code>peek()/peekFirst()</code></strong></td><td>查看队首元素（不删除）</td><td>返回头部元素；队列为空时返回 <code>null</code></td></tr><tr><td></td><td><strong>peekLast()</strong></td><td><strong>查看队尾元素</strong>（不删除）</td><td>返回尾部元素；队列为空时返回 <code>null</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈</span></span><br><span class="line">ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 压栈</span></span><br><span class="line">stack.push(<span class="number">1</span>); stack.push(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 查看栈顶</span></span><br><span class="line">System.out.println(stack.peek()); <span class="comment">// 输出 2</span></span><br><span class="line"><span class="comment">// 弹栈</span></span><br><span class="line"><span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop(); <span class="comment">// 返回 2，栈中剩余 [1]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line">ArrayDeque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line">queue.offer(<span class="number">1</span>); queue.offer(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 查看队首</span></span><br><span class="line">System.out.println(queue.peek()); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 返回 1，队列中剩余 [2]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;集合类是Java数据结构的实现。Java的集合类是&lt;a href=&quot;https://baike.baidu.com/item/java.util/5180624?fromModule=lemma_inlink&quot;&gt;java.util&lt;/a&gt;包中的重要内容，它允许以各种方式将元</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 异常</title>
    <link href="https://southernfish.github.io/2025/07/23/java/java-base-4-exceptions/"/>
    <id>https://southernfish.github.io/2025/07/23/java/java-base-4-exceptions/</id>
    <published>2025-07-23T13:28:36.000Z</published>
    <updated>2025-07-24T08:57:02.600Z</updated>
    
    <content type="html"><![CDATA[<p>‌Java中的异常（Exception）是程序运行时发生的不正常事件，分为检查异常（Checked Exception）和运行时异常（RuntimeException）。‌ 异常处理机制包括捕获（try-catch）、声明（throws）和抛出（throw），确保程序在错误发生时仍能稳定运行或优雅终止。原文链接：<a href="https://blog.csdn.net/qq_40991313/article/details/137256095">https://blog.csdn.net/qq_40991313/article/details/137256095</a></p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><p>Java中，异常（Exception）是指在程序执行过程中出现问题的一种情况，它可以中断程序的正常执行。异常通常是指<strong>由于错误、非法操作或意外情况导致的问题</strong>，比如文件未找到、数组越界、空指针引用等等。</p><p><strong>异常机制：</strong></p><p>当<em>程序出现异常，程序安全的退出、处理完后继续执行的机制</em>。Java是采用面向对象的方式来处理异常的。<strong>处理过程：</strong></p><ul><li><strong>抛出异常：</strong>在执行一个方法时，如果发生异常，则这个方法<strong>生成代表该异常的一个对象</strong>，停止当前执行路径，并<strong>把异常对象提交给JRE</strong>。</li><li><strong>捕获异常：</strong>JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，<strong>从生成异常的方法开始回溯，直到找到相应的异常处理代码为止</strong></li></ul><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><ul><li><strong><code>Error</code><strong>：错误类，无法通过代码解决，所以也不能处理。通常是</strong>由于系统资源不足或者JVM内部错误等导致</strong>的，需要通过修改环境或者配置等方式来解决。例如系统内存不够时抛出的内存溢出错误<code>OutOfMemoryError</code>，递归栈太深时抛出栈溢出错误<code>StackOverflowError</code>，这些通过代码没法解决，需要提升服务器配置，或者完全重构代码，换一种时间、空间复杂度更低的方案。</li><li><strong><code>Exception</code><strong>：异常类，程序可以处理的问题。它是一个类的实例，用于表示程序在运行过程中出现的意外情况。Java中所有的异常都是<code>Throwable</code>类的子类。Exception分为两种主要类型：</strong>运行时异常（RuntimeException及其子类）和非运行时异常</strong>。当一段代码有异常风险时应该通过<code>try-catch</code>或者<code>throws</code>进行处理，防止程序出现问题。例如往数据库插入记录时要捕获并打日志，从而对违反主键约束之类等问题进行排查。</li><li>**<code>RuntimeException</code>**：运行时异常，编译不出错，运行出错，要<code>try-catch</code>处理。这类异常通常是由程序错误或者逻辑错误导致的，例如空指针引用、数组越界等。由于RuntimeException在编译时不受检查，所以需要在代码编写阶段考虑如何处理这类异常，以确保程序的健壮性。</li><li>**非<code>RuntimeException</code>**：编译时异常，编译时出错使程序不能运行，要<code>try-catch处理或者throws</code>抛出去。它是在编译时必须处理的异常类型，否则程序无法通过编译。这类异常常表示程序运行环境出现的异常情况，如IO异常<code>IOException</code>、数据库操作异常等。</li></ul><h2 id="异常继承体系"><a href="#异常继承体系" class="headerlink" title="异常继承体系"></a><strong>异常继承体系</strong></h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250722170324655.png" alt="image-20250722170324655"></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/1753175232890.jpg" alt="1753175232890"></p><h1 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h1><h2 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h2><p>Java中的Error类表示严重的错误情况，通常由虚拟机或其他底层自身的失效造成的，例如内存溢出、栈溢出，会导致应用程序终止。</p><p>通常程序不应该捕获Error，特定情境下可以捕获OutOfMemoryError处理内存溢出问题。使用try-catch-finally块捕获异常，并在finally块中进行资源清理、销毁、报告错误、终止应用程序等操作。</p><p>常见的错误<code>Error</code>包括：</p><ul><li>**<code>OutOfMemoryError</code>**：内存溢出错误，通常是由于应用程序试图分配比可用内存更多的内存而导致。</li><li>**<code>StackOverflowError</code>**：堆栈溢出错误，发生在方法递归调用所需的堆栈空间已经用完的情况下。 </li><li>**<code>NoClassDefFoundError</code>**：类未找到错误，通常是由于JVM无法找到应用程序尝试使用的某个类而导致。</li><li>**<code>UnsatisfiedLinkError</code>**：链接未满足错误，通常是由于调用本地方法时出现的链接问题而导致。</li></ul><h2 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h2><p>Exception的子类包括编译时异常和运行时异常：</p><p><strong>编译时异常</strong>：在编译阶段就能检查出来的异常。例如FileNotFoundException、ClassNotFoundException、NoSuchFieldException、NoSuchMethodException、SQLException、ParseException（解析异常）等。如果程序要去处理这些异常，必须显式地使用try-catch语句块或者在方法定义中使用throws子句声明异常。</p><p><strong>运行时异常</strong>：在运行时才会出现的异常。例如，NullPointerException、ArrayIndexOutOfBoundsException等。这些异常通常是由程序代码中的逻辑错误引起的，在编程时不会提示，运行时才报错。 因此，在编写程序时，通常无法处理这些异常，但是在程序开发完毕后，需要对这些异常进行一些处理，以防程序运行时崩溃。</p><h2 id="常见的异常类"><a href="#常见的异常类" class="headerlink" title="常见的异常类"></a>常见的异常类</h2><ul><li><code>NullPointerException</code> <strong>空指针异常</strong>；出现原因：访问未初始化的对象或不存在的对象。</li><li><code>ClassNotFoundException</code> <strong>类找不到异常</strong>；出现原因：类的名称和路径加载错误；</li><li><code>NumberFormatException</code> <strong>数字格式化异常</strong>；出现原因：转数字的字符型中包含非数字型字符。</li><li><code>IndexOutOfBoundsException</code> <strong>索引超出边界异常</strong>；出现原因：访问数组越界元素</li><li><code>IllegalArgumentException</code> <strong>不合法参数异常</strong>。出现原因：传递了不合法参数</li><li><code>MethodArgumentNotValidException</code> <strong>方法参数无效异常</strong>。出现原因：JSR303校验不通过</li><li><code>ClassCastException</code> <strong>类转换异常</strong>。出现原因：把对象强制转为没继承关系对象时报错。这个异常是在类加载过程的元数据验证阶段验证继承关系时报错。</li><li><code>ArithmeticException</code> <strong>算术异常</strong>。出现原因：除以0时。 </li><li><code>FileNotFoundException</code> 文件未找到异常</li><li><code>NoSuchMethodException</code> 方法不存在异常</li><li><code>IOException IO</code> 异常</li><li><code>SocketException</code> Socket 异常</li></ul><h1 id="异常的两种处理方式"><a href="#异常的两种处理方式" class="headerlink" title="异常的两种处理方式"></a>异常的两种处理方式</h1><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><ul><li><code>throws</code>：<ul><li><strong>位置</strong>：在方法签名中使用，其后跟着异常类名。</li><li><strong>特点</strong>：它表示方法可能会抛出异常，但并不保证一定会发生这个异常。</li><li><strong>数量</strong>：可以声明抛出多个异常,多个一场之间用逗号隔开</li><li><strong>处理异常</strong>：异常会传递给该方法的调用者来处理。</li></ul></li><li><code>throw</code>：<ul><li><strong>位置</strong>：在方法体内使用，其后跟着异常对象名。</li><li><strong>特点</strong>：它表示方法内部一定已经发生了某种异常情况，并将这个异常抛出。</li><li><strong>数量</strong>：throw语句抛出的是一个异常实例,不是一个异常类,而且每次只能抛出一个异常实例</li><li><strong>处理异常</strong>：执行该关键字必定会抛出异常。异常由方法体内的语句来处理。 </li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// throws可能会抛出异常</span></span><br><span class="line">    <span class="comment">// @throws Exception 抛出异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">possibleException</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 可能会引发空指针异常的代码</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// throw一定会抛出指定的异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">throwException</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;这里一定会抛出一个运行时异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h2><p><strong>throw：</strong>是真实抛出一个异常。<br><strong>throws：</strong>是声明可能会抛出一个异常。</p><h2 id="捕获异常（推荐）"><a href="#捕获异常（推荐）" class="headerlink" title="捕获异常（推荐）"></a>捕获异常（推荐）</h2><p>使用 try 和 catch 关键字可以捕获异常，需要将try/catch 包围在异常可能发生的地方。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. try/catch语法：</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 可能会引发空指针异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">   <span class="comment">// 异常处理代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若还有逻辑，异常被捕获、处理后，程序将不被终止，而是继续执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. try/catch/finally语法：</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 可能会引发空指针异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">   <span class="comment">// 异常处理代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;    </span><br><span class="line">    <span class="comment">// 只要程序不崩溃，不管catch里有没有捕获到异常，finally块中的代码都会在最后执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.可以使用 try-with-resources 语句来自动管理资源，如自动关闭实现了 AutoCloseable 或 Closeable 接口的资源。</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>()) &#123;</span><br><span class="line">    <span class="comment">// 使用资源</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="final、finally、finalize-的区别"><a href="#final、finally、finalize-的区别" class="headerlink" title="final、finally、finalize 的区别"></a>final、finally、finalize 的区别</h2><p><strong>final：</strong>是<strong>修饰符</strong>，如果修饰类，此类<strong>不能被继承</strong>；如果修饰方法和变量，此方法和此变量<strong>不能再被改变</strong>，只能使用。<br><strong>finally：</strong>是 try{} catch{} finally{} 最后一部分，表示<strong>不论发生任何情况都会执行</strong>，finally 部分可以省略，但若 finally 部分存在，则一定会执行 finally 里面的代码。<br><strong>finalize：</strong>是 Object 类的一个方法，在<strong>垃圾收集器执行的时候会调用被回收对象的此方法</strong>。</p><h2 id="try-catch-finally-中哪部分可省"><a href="#try-catch-finally-中哪部分可省" class="headerlink" title="try-catch-finally 中哪部分可省"></a>try-catch-finally 中哪部分可省</h2><p>try-catch-finally 其中 <strong>catch 和 finally 都可以被省略，但不能同时省略</strong>，也就是说有 try 时，必须后面跟一个 catch 或 finally。</p><h2 id="try-catch-finally-在-catch-中-return-了，finally-是否还会执行"><a href="#try-catch-finally-在-catch-中-return-了，finally-是否还会执行" class="headerlink" title="try-catch-finally 在 catch 中 return 了，finally 是否还会执行"></a>try-catch-finally 在 catch 中 return 了，finally 是否还会执行</h2><p><strong>finally 一定会执行</strong>，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p><p><strong>finally块最终执行</strong>：</p><ul><li><strong>只要程序不崩溃，finally块的代码都最终执行</strong>：即使try块、catch块中有return或throw语句，程序也会在执行finally块的代码后再return或throw。这里需要注意，禁止在finally块中使用return或throw。因为若finally块里也使用了return或throw等语句，finally块会终止方法，系统将不会跳回去执行try块、catch块里的任何代码。这将会导致try块、catch块中的return、throw语句失效</li><li>如果程序终止，finally代码块不执行：<ul><li>线程终止：如果一个线程在执行 try 语句块或者catch语句块时被打断interrupted，或者被终止killed，与其相对应的 finally 语句块可能不会执行。</li><li>退出虚拟机：如果在try块或catch块中使用 <code>System.exit(1);</code> 来退出虚拟机，则finally块将失去执行的机会。</li></ul></li></ul><hr><h1 id="自定义异常：继承异常类"><a href="#自定义异常：继承异常类" class="headerlink" title="自定义异常：继承异常类"></a>自定义异常：继承异常类</h1><p>有时候预定义的异常类不能完全满足业务需求，这时就需要自定义异常，以便于在程序出现问题时，可以及时抛出或处理</p><p>例如电商项目的库存不足异常、商品找不到异常，论坛项目中的“帖子找不到异常”、“无效评论异常”等等。</p><p><strong>自定义异常的方法</strong>： 可以通过继承异常根类，或者它们的子类，重写父类的方法，以达到自定义异常的效果：</p><ul><li><strong>编译时异常类</strong>：需要继承 Exception 类。</li><li><strong>运行时异常类</strong>：需要继承 RuntimeException 类。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;‌Java中的异常（Exception）是程序运行时发生的不正常事件，分为检查异常（Checked Exception）和运行时异常（RuntimeException）。‌ 异常处理机制包括捕获（try-catch）、声明（throws）和抛出（throw），确保程序在错误</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程（OOP）</title>
    <link href="https://southernfish.github.io/2025/07/23/java/java-base-3-oop/"/>
    <id>https://southernfish.github.io/2025/07/23/java/java-base-3-oop/</id>
    <published>2025-07-23T12:45:36.000Z</published>
    <updated>2025-07-23T14:15:07.499Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象程序设计(Object Oriented Programming)作为一种新方法，其本质是以建立模型体现出来的抽象思维过程和<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089?fromModule=lemma_inlink">面向对象</a>的方法。模型是用来反映现实世界中事物特征的。任何一个模型都不可能反映客观事物的一切具体特征，只能对事物特征和变化规律的一种抽象，且在它所涉及的范围内更普遍、更集中、更深刻地描述客体的特征。通过建立模型而达到的抽象是人们对客体认识的深化。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>面向对象（<code>Object-Oriented</code>，简称 <code>OOP</code>）是一种程序设计的范式，它基于对象的概念，将数据和操作数据的行为封装在对象中，以模拟现实世界的问题和解决方案。 </p><p><strong>核心概念</strong>： </p><p><strong>对象</strong>（Object）： 对象是现实世界中的实体或概念，在程序中被抽象为<strong>具有状态（属性）和行为（方法）的实例</strong>。 </p><p><strong>类</strong>（Class）： 类是对象的模板，它定义了对象的属性和方法。类是对象的抽象，实际的对象是根据类的定义实例化而来的。 </p><p><strong>封装</strong>（Encapsulation）： 封装是<strong>将对象的属性和方法封装在一个单元内，对外部隐藏对象的具体实现细节</strong>。通过封装，对象的内部实现对外部是不可见的，只有公共接口对外部可见。 </p><p><strong>继承</strong>（Inheritance）： 继承允许一个类（子类）继承另一个类（父类）的属性和方法。子类可以继承父类的属性、重写父类的方法，从而减少代码量。 </p><p><strong>多态</strong>（Polymorphism）： 多态允许不同的对象对同一消息做出响应，提供了灵活性和可扩展性。多态的实现方式包括方法重载和方法重写。 </p><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>类</strong>：现实中一种具有共同属性、行为的事物的抽象。它定义了一组属性（成员变量）和方法（成员方法），用于描述具有相似特征和行为的对象集合。 </p><p><strong>对象</strong>：对象是类的一个实例，是能够看得到摸的着的真实存在的实体。  </p><p><strong>总结起来就是一句话</strong>：类是对象的抽象，对象是类的具体实现。</p><blockquote><p>例如声明一个Person类，有名字和年龄两个属性；然后便可以通过这个类创建两个对象，分别是Alice和Bob，他们的年龄不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="comment">// 成员变量</span></span><br><span class="line"> String name;</span><br><span class="line"> <span class="type">int</span> age;</span><br><span class="line"> <span class="comment">// 构造方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name;</span><br><span class="line">     <span class="built_in">this</span>.age = age;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 成员方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(name + <span class="string">&quot; is working.&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(name + <span class="string">&quot; is studying.&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">// 创建 Person 类的对象</span></span><br><span class="line">     <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">     <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>);</span><br><span class="line">     <span class="comment">// 调用对象的方法</span></span><br><span class="line">     person1.work();</span><br><span class="line">     person2.study();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Alice is working.</span><br><span class="line">Bob is working.</span><br></pre></td></tr></table></figure></blockquote><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p><strong>内部类：</strong>在一个类中定义类。</p><p><strong>分为：</strong></p><ul><li><strong>成员内部类（成员位置）</strong></li><li><strong>局部内部类（成员方法内）</strong></li><li><strong>匿名内部类（方法内）</strong></li></ul><p><strong>匿名内部类</strong>：一个<strong>继承</strong>了其他类<strong>或者实现</strong>了其他接口的子类对象。</p><blockquote><p>内部类可以直接访问外部类私有、公有成员。外部类要访问内部类成员要创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 定义成员内部类：在成员位置定义类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;                                <span class="comment">// 一般private，用外部类访问内部类更安全</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;innershow&quot;</span>+num);    <span class="comment">// 内部类可直接访问外部类成员。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 外部类访问成员内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;        </span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 局部内部类：在成员方法内定义类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner2</span> &#123;                                <span class="comment">// 成员内部类不能public和private</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;成员内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner2 in=<span class="keyword">new</span> <span class="title class_">Inner2</span>();</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匿名内部类：在成员方法内定义子类，实现接口或继承抽象类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>() &#123;                        <span class="comment">// 自己写的Phone接口</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;实现接口的匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;                                            <span class="comment">// 注意是一个语句有分号</span></span><br><span class="line">        p.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部类创建对象（一般内部类私有，使用外部类访问内部类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        i.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建对象的几种方法"><a href="#创建对象的几种方法" class="headerlink" title="创建对象的几种方法"></a>创建对象的几种方法</h2><p>概述： </p><ul><li><strong>new</strong>：例如Person person1 = new Person();</li><li><strong>反射</strong>：先获取类的Class对象，通过newInstance()方法创建对象；</li><li><strong>对象的clone()方法</strong>： 类实现Cloneable 接口，重写 clone()方法， 编写浅拷贝或者深拷贝的逻辑。然后调用对象的clone()方法就可以克隆出对象。</li><li><strong>反序列化</strong>：反序列化对象时，JVM会创建一个单独的对象。需要让类实现Serializable接口，通过ObjectInputStream类的readObject()方法从磁盘中反序列化对象。反序列化创建对象是深拷贝。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用 new 关键字: 这是最常见的创建对象的方式，使用 new 关键字直接调用类的构造方法</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.反射：通过反射机制，可以在运行时获取类的信息，动态创建对象。</span></span><br><span class="line">Class&lt;?&gt; clazz = Person.class;</span><br><span class="line"><span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.对象的 clone() 方法：要实现克隆，类必须实现 Cloneable 接口，并重写 clone() 方法。这种方式可以实现对象的浅拷贝或深拷贝。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// 其他类定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person3</span> <span class="operator">=</span> (Person) person1.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.反序列化：通过反序列化，可以将对象的状态从持久性存储中重新创建出来。需要让类实现 Serializable 接口，并使用 ObjectInputStream 类的 readObject() 方法从文件或网络中反序列化对象。</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person4</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>方法（Method）：</strong>一组执行特定任务的代码块。它可以在类中定义一次，然后在本方法、其他方法中被多次调用。</p><p><strong>作用：</strong>提高代码的可读性和可维护性。</p><blockquote><p>例如小明要吃多顿饭，每顿饭吃的食物不同，可以将“吃饭”这个行为抽象成方法，从而减少代码量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line"> <span class="comment">//  吃饭方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;=====&quot;</span>);</span><br><span class="line">     System.out.println(name + <span class="string">&quot; is eating &quot;</span> + food);</span><br><span class="line">     System.out.println(<span class="string">&quot;=====&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     eat(<span class="string">&quot;西瓜&quot;</span>);</span><br><span class="line">     eat(<span class="string">&quot;白菜&quot;</span>);</span><br><span class="line">     eat(<span class="string">&quot;可乐&quot;</span>);</span><br><span class="line">     eat(<span class="string">&quot;番茄&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>在 Java 中，方法的定义包括以下几个要素：</p><ul><li><strong>修饰符</strong>： 方法可以有访问修饰符，例如 public、private、protected 或默认（包内可见）。</li><li><strong>返回类型</strong>： 方法可以返回一个值，指定返回值的数据类型，如果方法不返回任何值，可以使用 void。</li><li><strong>方法名</strong>： 方法名是方法的标识符，用于在程序中调用方法。</li><li><strong>参数列表</strong>： 方法可以接受零个或多个参数，参数用于向方法传递数据。</li><li><strong>方法体</strong>： 方法体包含实际执行的代码块，实现方法的功能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法的调用：可以通过方法名和参数列表来调用方法。方法调用是程序执行的一个重要步骤，它使代码更具可重用性。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line"><span class="comment">// 返回值：方法可以返回一个值，也可以是 `void`，表示不返回任何值。如果方法返回值，必须使用`return`返回对应类型的值。</span></span><br></pre></td></tr></table></figure><h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><h3 id="重载（Overload）"><a href="#重载（Overload）" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h3><p><strong>重载（Overload）：</strong>指<strong>一个类中</strong>可以有多个方法具有<strong>相同的方法名</strong>，但这些方法的<strong>参数类型不同、个数不同、顺序不同</strong>。</p><blockquote><p><strong>注意：</strong>方法返回值和<a href="https://so.csdn.net/so/search?q=%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6&spm=1001.2101.3001.7020">访问修饰符</a>可以不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">     f();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;3f&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a)</span> &#123;        <span class="comment">// 重载，注意返回值同，参数不同</span></span><br><span class="line">     System.out.println(a);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//    下面两个注释的方法就不是重载，会报错</span></span><br><span class="line"><span class="comment">//    public static int f()&#123;    //返回值不同</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    void f()&#123;    // 修饰符不同</span></span><br><span class="line"><span class="comment">//        return 666;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：求和的数学类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathOperations</span> &#123;</span><br><span class="line"> <span class="comment">// 求和方法，接受两个整数参数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> num1 + num2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 重载的求和方法，接受三个整数参数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2, <span class="type">int</span> num3)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> num1 + num2 + num3;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 重载的求和方法，接受两个双精度浮点数参数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> num1 + num2;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">// 创建 MathOperations 对象</span></span><br><span class="line">     <span class="type">MathOperations</span> <span class="variable">math</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MathOperations</span>();</span><br><span class="line">     <span class="comment">// 使用不同的方法进行求和</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> math.sum(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">     <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> math.sum(<span class="number">3</span>, <span class="number">7</span>, <span class="number">12</span>);</span><br><span class="line">     <span class="type">double</span> <span class="variable">result3</span> <span class="operator">=</span> math.sum(<span class="number">2.5</span>, <span class="number">3.5</span>);</span><br><span class="line">     <span class="comment">// 打印结果</span></span><br><span class="line">     System.out.println(<span class="string">&quot;Sum of two integers: &quot;</span> + result1);</span><br><span class="line">     System.out.println(<span class="string">&quot;Sum of three integers: &quot;</span> + result2);</span><br><span class="line">     System.out.println(<span class="string">&quot;Sum of two doubles: &quot;</span> + result3);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p><strong>重载</strong>：方法名相同且参数列表。重载要求发生在<strong>同一个类</strong>中，多个方法之间方法名相同且参数列表不同。重载与返回类型和访问修饰符无关。方法名相同返回类型不同会直接报错。</p><p><strong>重写</strong>：方法名、参数列表、返回类型与父类相同。重写发生在<strong>父类子类或接口实现类</strong>中，若子类方法想要和父类方法构成重写关系，则它的方法名、参数列表、返回类型必须与父类方法相同。</p><p><strong>重写时</strong>：</p><ul><li>返回值类可以是原返回值类的子类。例如工厂方法设计模式里，抽象工厂类的<code>createObject()</code>方法返回值是抽象产品类，具体工厂类的<code>createObject()</code>方法返回值是具体产品类</li><li>访问权限不能比其父类更为严格</li><li>抛出异常不能比父类更广泛</li></ul><p><strong>注意：</strong>构造方法不能重写。</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>Java 5 以后引入了可变参数（<code>Varargs</code>），允许方法接受可变数量的参数。可变参数在方法的参数列表中使用省略号 <code>...</code> 表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可变参数的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printNumbers</span><span class="params">(<span class="type">int</span>... numbers)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li><p>可变参数必须是方法的最后一个参数。例如void (int a,int… b)正确，而void (int… a,int b)会报错。</p></li><li><p>一个方法最多只能有一个可变参数。</p></li><li><p>可变参数在方法内部被当作数组处理。</p></li></ul><p>示例：求和的数学类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathOperations</span> &#123;</span><br><span class="line">    <span class="comment">// 求和方法（整数数组）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">            result += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求和方法（可变参数）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">            result += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求和方法（双精度浮点数数组）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> num : numbers) &#123;</span><br><span class="line">            result += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求和方法（可变参数）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span>... numbers)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> num : numbers) &#123;</span><br><span class="line">            result += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例：整数求和</span></span><br><span class="line">        <span class="type">int</span>[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">intSum</span> <span class="operator">=</span> sum(intArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;Integer Sum: &quot;</span> + intSum);</span><br><span class="line">        <span class="comment">// 示例：可变参数整数求和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">varArgsIntSum</span> <span class="operator">=</span> sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;VarArgs Integer Sum: &quot;</span> + varArgsIntSum);</span><br><span class="line">        <span class="comment">// 示例：双精度浮点数求和</span></span><br><span class="line">        <span class="type">double</span>[] doubleArray = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line">        <span class="type">double</span> <span class="variable">doubleSum</span> <span class="operator">=</span> sum(doubleArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;Double Sum: &quot;</span> + doubleSum);</span><br><span class="line">        <span class="comment">// 示例：可变参数双精度浮点数求和</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">varArgsDoubleSum</span> <span class="operator">=</span> sum(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;VarArgs Double Sum: &quot;</span> + varArgsDoubleSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法是一种特殊的方法，与类同名，没有返回类型。</p><p>每次创建对象时，都会默认执行一次构造方法。</p><p><strong>特点</strong>：</p><ul><li>与类同名，没有返回类型；</li><li>构造方法在对象创建时执行，用于设置对象的初始状态。 </li><li>每个类都可以有一个或多个构造方法，但通常至少有一个默认构造方法（无参数）。</li><li><strong>默认构造方法</strong>：果在类中没有明确定义任何构造方法，Java 会自动为该类提供一个默认的无参数构造方法。这个默认构造方法执行时不进行特定的初始化操作。</li><li><strong>重载</strong>：和普通方法一样，构造方法也支持重载，即在同一个类中可以定义多个同名但参数列表不同的构造方法。</li></ul><p><strong>简单的构造方法</strong>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String model;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 默认构造方法：创建对象时会直接运行构造方法，输出 Default constructor called.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Default constructor called.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String brand, String model, <span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parameterized constructor called.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Getter 和 Setter 方法（省略）</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用默认构造方法创建对象</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">defaultCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        <span class="comment">// 使用带参数的构造方法创建对象</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">customCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Toyota&quot;</span>, <span class="string">&quot;Camry&quot;</span>, <span class="number">2022</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li><strong>接口</strong>：对行为的抽象，如吃饭类、睡觉类。</li><li><strong>抽象类</strong>：对事物的抽象，如动物类，小狗类。 </li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>接口</strong>：对行为的抽象，如吃饭类、睡觉类。 </p><p><strong>接口的特点</strong>：</p><ul><li>接口没有构造方法。</li><li>接口中的方法会被隐式的指定为 public abstract方法，不能定义静态方法。</li><li>接口中的变量会被隐式的指定为 public static final 变量，不能定义私有成员。因为是final所以也要显式赋初值。</li><li>接口和接口多继承，接口和类多实现。</li><li>接口的实现类：除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">4</span>;        <span class="comment">// 修饰符可省略</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;            <span class="comment">// 修饰符可省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneImpl</span> <span class="keyword">implements</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;                    <span class="comment">// 必须是public，否则报错</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li><p><strong>抽象类</strong>：对事物的抽象，如动物类，小狗类。 </p></li><li><p>抽象类包含抽象方法的类，它不能被实例化，通常用于作为其他类的基类。</p></li><li><p><strong>特点</strong>：抽象类可以包含抽象方法、具体方法、字段和构造方法。</p></li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>建模共性行为</strong>： 当多个类具有相同的行为，可以将这些行为提取到一个抽象类中，以便实现代码的重用。</li><li><strong>规范子类</strong>： 抽象类可以用于规定子类应该实现的一组方法，强制子类提供这些方法的实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 具体方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof! Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Meow! Meow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面对对象三特性"><a href="#面对对象三特性" class="headerlink" title="面对对象三特性"></a>面对对象三特性</h1><p>面向对象的三大基本特征是：<strong>封装、继承、多态。</strong>分别实现了<strong>数据的隐藏与保护、代码的复用扩展以及行为的灵活适配</strong>。‌</p><p><strong>封装</strong>是对数据和行为进行集中管理的过程‌，其核心在于隐藏内部实现细节，仅通过接口与外界交互。主要作用包括：‌</p><ul><li><em>数据保护‌：</em>通过访问权限控制，如 private、protected 限制外部直接修改属性；‌‌‌‌‌</li><li><em>接口标准化‌：</em>提供统一的方法调用入口，如 getter、setter 控制属性访问；‌‌‌</li><li><em>模块化设计‌：</em>将同一类功能封装到同一对象中。</li></ul><p><strong>继承</strong>通过父子类关系实现代码复用和扩展‌，其特点包括：‌</p><ul><li><em>子类复用父类功能‌：</em>子类可直接使用父类的公共属性和方法；‌‌‌‌‌</li><li><em>层级扩展能力‌：</em>子类可新增特性或重写父类方法，如子类用 extends 继承父类并添加特有属性；‌‌‌</li><li><em>访问规则约束‌：</em>父类私有成员（private）不可被子类继承，保证封装性。‌‌‌</li></ul><p><strong>多态</strong>通过统一的接口实现不同类型的差异化行为‌，具体表现为：‌</p><ul><li><em>动态绑定‌：</em>父类引用指向子类对象；‌‌‌</li><li><em>方法重写与重载‌：</em>子类覆写父类方法（重写）或同一类中同名不同参方法（重载）；‌‌‌‌‌</li><li><em>灵活性增强‌：</em>同一方法在不同子类中表现不同。‌</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><strong>封装</strong>：通过private修饰符，将类的某些信息隐藏在类的内部，不允许外部程序直接访问。</p><p>封装将对象的状态和行为包装在一个类中并对外界隐藏实现的细节，可以通过访问修饰符控制成员的访问权限，让外部程序通过该类提供的方法来实现对内部信息的操作和访问。</p><p><strong>示例</strong>：将价格、年龄等信息封装到小狗类中，外部不能直接访问，只能通过get和set方法访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="type">int</span> price;            <span class="comment">// 成员变量在堆内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：安全性和复用性。</p><ul><li><strong>安全性</strong>：通过方法来控制成员变量的操作，提高了代码的安全性</li><li><strong>复用性</strong>：把代码用方法进行封装，提高了代码的复用性，降低了耦合性。</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>继承</strong>：继承是指一个类通过从另一个类继承其属性和方法。这使得子类具有其父类的行为和属性，同时可以扩展或修改这些行为和属性以满足特定的需求。 </p><ul><li><p><strong>优点</strong>：提高代码复用性，维护性，实现代码共享。</p></li><li><p><strong>缺点</strong>：高耦合性，有侵入性，父类改变子类也会改变。</p></li><li><p><strong>特点</strong>：子类拥有父类非 private 的属性、方法。可以拥有自己的属性和方法，即子类可以对父类进行扩展。可以用自己的方式实现父类的方法。</p></li><li><p><strong>注意</strong>： Java 不支持多继承，但支持多重继承。</p></li><li><p>子类所有构造方法会默认先运行super();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> String name;   </span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">3</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123; </span><br><span class="line">        <span class="comment">// 初始化属性值</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;  <span class="comment">// 吃东西方法的具体实现  &#125; </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123; <span class="comment">// 睡觉方法的具体实现  &#125; </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 子类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Penguin</span>  <span class="keyword">extends</span>  <span class="title class_">Animal</span>&#123; </span><br><span class="line">    <span class="type">int</span> age=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Penguin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();            <span class="comment">// 不写也会默认运行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>        <span class="comment">// 注解重写，检查重写是否正确。例如修饰符（子类重写方法的访问权限要≥父类）、函数名错误。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;        <span class="comment">// 重写父类中show(),如果去掉public会报错。想再用super.show();</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">         System.out.println(age);       <span class="comment">// 5,子类可以访问父类非私有成员变量</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.age);    <span class="comment">// 4</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.age);    <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 implements 关键字可以变相的使java具有多继承的特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">A</span>,B &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>多态</strong>：同一行为具有多个不同的表现形式或形态。例如同一个接口，使用不同的实例而执行不同操作。使程序更灵活、易于扩展。</p><p>多态最常用的是接口引用指向实现类对象，这样当之后程序需要更新时候，只需要修改new后面的实现类即可，左边就不用修改了，从而降低耦合。</p><p>简单一句话，多态是：接口引用指向实现类对象。</p><p>在Spring框架中，甚至可以通过配置或注解连实例化的new也不用了，从而更高层次的降低耦合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>这样写的话，等号右边换成<em>Vector 或 LinkedList</em> 时，就可以很少修改代码量，降低耦合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上转型：父类引用指向子类对象。编译看左边（调用子类特有变量、方法会报错），运行看右边（优先运行子类重写后的方法）。</span></span><br><span class="line"><span class="comment">// 向下转型： 子类引用指向父类对象。编译看右边，运行看右边。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line">  <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();      <span class="comment">// 向上转型  </span></span><br><span class="line">  a.eat();                   <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">  <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;            <span class="comment">// 向下转型  </span></span><br><span class="line">  c.work();                    <span class="comment">// 调用的是 Cat 的 work</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">面向对象程序设计(Object Oriented Programming)作为一种新方法，其本质是以建立模型体现出来的抽象思维过程和面向对象的方法。模型是用来反映现实世界中事物特征的。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA的常用类</title>
    <link href="https://southernfish.github.io/2025/07/23/java/java-base-2-class/"/>
    <id>https://southernfish.github.io/2025/07/23/java/java-base-2-class/</id>
    <published>2025-07-23T12:39:36.000Z</published>
    <updated>2025-07-23T12:39:45.090Z</updated>
    
    <content type="html"><![CDATA[<p>Java是一门面向对象的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131?fromModule=lemma_inlink">编程语言</a>，不仅吸收了<a href="https://baike.baidu.com/item/C%2B%2B/99272?fromModule=lemma_inlink">C++</a>语言的各种优点，还摒弃了C++里难以理解的多<a href="https://baike.baidu.com/item/%E7%BB%A7%E6%89%BF/20267560?fromModule=lemma_inlink">继承</a>、<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304?fromModule=lemma_inlink">指针</a>等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。Java具有简单性、面向对象、<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F/19276232?fromModule=lemma_inlink">分布式</a>、<a href="https://baike.baidu.com/item/%E5%81%A5%E5%A3%AE%E6%80%A7/4430133?fromModule=lemma_inlink">健壮性</a>、<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E6%80%A7/7664678?fromModule=lemma_inlink">安全性</a>、平台独立与可移植性、<a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fromModule=lemma_inlink">多线程</a>、动态性等特点。 Java可以编写<a href="https://baike.baidu.com/item/%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/2331979?fromModule=lemma_inlink">桌面应用程序</a>、Web应用程序、<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336?fromModule=lemma_inlink">分布式系统</a>和<a href="https://baike.baidu.com/item/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/186978?fromModule=lemma_inlink">嵌入式系统</a>应用程序等。</p><p>原文链接：<a href="https://blog.csdn.net/qq_40991313/article/details/134564921">https://blog.csdn.net/qq_40991313/article/details/134564921</a></p><h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>String是一个类，用于存储字符串，内部封装了一系列用于操作字符串的方法，底层是<code>final</code>修饰的char数组。</p><p>JDK9开始，为了节省内存，进而减少垃圾回收次数，String底层由<code>char</code>数组改成了<code>byte[]</code>。</p><blockquote><p><strong>Java的String和c++的string区别：</strong></p><ul><li>java中字符串一个汉字长度是1；</li><li>c++中字符串，一个汉字长度是2. </li></ul></blockquote><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建字符串有两种方式，一种是使用字符串直接量，另一种是使用new+构造器。采用new的方式会多创建出一个对象来，占用了更多的内存 ，所以建议采用直接量的方式来创建字符串。</p><p><strong>字符串直接量创建</strong>：JVM会使用常量池来管理这个字符串；<br><strong>new创建</strong>：JVM会先使用常量池来管理字符串直接量（若已有此字符串则直接返回引用，若没有则实例化后再返回引用），再调用String类的构造器来创建一个新的String对象，新创建的String对象会被保存在堆内存中。字符串常量池源码用到了享元设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 直接创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Runoob&quot;</span>;       </span><br><span class="line"><span class="comment">// String 对象创建       </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Runoob&quot;</span>);   </span><br><span class="line"><span class="comment">// 引用赋值的方法创建字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1;                   </span><br></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><blockquote><p><strong>自带方法访问</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过索引访问字符：charAt()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;First Character: &quot;</span> + firstChar);</span><br><span class="line"><span class="comment">// 访问子串：substring()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;0123456789ABCDEFG&quot;</span>;</span><br><span class="line"><span class="comment">// 提取索引 7 到 11 的子串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> str.substring(<span class="number">7</span>, <span class="number">12</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Substring: &quot;</span> + substring);</span><br></pre></td></tr></table></figure><p><strong>遍历字符串每个字母</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用for循环遍历字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用增强for循环遍历字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用while循环遍历字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; str.length()) &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Iterator遍历字符串</span></span><br><span class="line">Iterator&lt;Character&gt; iterator = str.chars().mapToObj(c -&gt; (<span class="type">char</span>) c).iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a><strong>连接</strong></h3><p>字符串可以通过“+”号拼接，拼接过程中可以将数字型转为字符串。字符串拼接数字，数字会转成字符串。</p><p><strong>字符串连接字符数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s = s + <span class="string">&quot;, World!&quot;</span>;</span><br><span class="line"><span class="comment">// 连接字符数组</span></span><br><span class="line"><span class="type">char</span>[] greeting = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span>[] suffix = &#123;<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span>[] result = <span class="keyword">new</span> <span class="title class_">char</span>[greeting.length + suffix.length];</span><br><span class="line">System.arraycopy(greeting, <span class="number">0</span>, result, <span class="number">0</span>, greeting.length);</span><br><span class="line">System.arraycopy(suffix, <span class="number">0</span>, result, greeting.length, suffix.length);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><p>在 Java 中，可以使用 <code>substring()</code> 方法获取字符串的子串： </p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// substring(int beginIndex)： 返回从指定索引开始到字符串末尾的子串。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">originalString</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> originalString.substring(<span class="number">7</span>);          <span class="comment">// 从索引 7 开始到字符串末尾的子串</span></span><br><span class="line">System.out.println(substring);                          <span class="comment">// 输出结果为 &quot;World!&quot;</span></span><br><span class="line"><span class="comment">// substring(int beginIndex, int endIndex)： 返回从指定索引开始到指定索引结束的子串（不包括 endIndex 处的字符）。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">originalString</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> originalString.substring(<span class="number">7</span>, <span class="number">12</span>);      <span class="comment">// 从索引 7 开始到索引 12 结束的子串</span></span><br><span class="line">System.out.println(substring);                          <span class="comment">// 输出结果为 &quot;World&quot;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>因为String是不可变的，对字符串的任何操作都会返回一个新的字符串。所以substring 方法其实是创建了一个字符子串，而不是修改了原始字符串。</p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>Java中字符串没有直接根据索引删除的方法，所以删除字符串中指定索引的字母时，可以通过子串substring()删除。</p><p><strong>示例：</strong>删除字符串中下标是6的字母</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, <span class="number">5</span>) + str.substring(<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Modified String: &quot;</span> + newStr);</span><br></pre></td></tr></table></figure><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>在Java中， 可以使用replaceAll()方法替换字符中的字符：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// replaceAll(String regex, String replacement)：使用给定的替换字符串替换输入字符串中所有匹配正则表达式的部分。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">originalString</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">replacedString</span> <span class="operator">=</span> originalString.replaceAll(<span class="string">&quot;o&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">System.out.println(replacedString);                  <span class="comment">// 输出结果为 &quot;Hell0, W0rld!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// replaceAll(String regex, Function&lt;MatchResult, String&gt; replacer)：使用给定的 Function 替换输入字符串中所有匹配正则表达式的部分。该方法允许更加灵活的替换逻辑，并且可以基于匹配的结果进行自定义的替换。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">originalString</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">replacedString</span> <span class="operator">=</span> originalString.replaceAll(<span class="string">&quot;o&quot;</span>, match -&gt; match.group().toUpperCase());</span><br><span class="line">System.out.println(replacedString);                  <span class="comment">// 输出结果为 &quot;HellO, WOrld!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a><strong>获取长度</strong></h3><p>可以通过length()方法获取字符串的长度。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Java Programming&quot;</span>;</span><br><span class="line">        <span class="comment">// 返回字符串的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> text.length();</span><br><span class="line">        System.out.println(length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>字符串内容的互相比较一般用equals()方法。Java中所有类都直接或间接继承了 Object 类，在 Object 类中，equals() 方法是 Java 中用于比较两个对象的引用是否相等（即内存地址是否相同）。</p><p>在 String 类中，equals() 方法被重写，用于比较两个字符串的内容是否相等。</p><blockquote><p><strong>注意：</strong>尽量不要用<code>==</code>进行比较，<code>==</code>比较的是地址。</p><p>String底层是常量池，使用享元设计模式，新创建的字符串会维护在常量池，下次再创建这个字符串，就直接从常量池取。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.比较地址</span></span><br><span class="line">        <span class="comment">// 只要new，就在堆内存开辟空间。直接赋值字符串在常量池里。</span></span><br><span class="line">        <span class="comment">// 常量池里无“hello”对象，创建“hello”对象，str1指向常量池“hello”对象。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">// 先检查字符串常量池中有没有&quot;hello&quot;</span></span><br><span class="line">            <span class="comment">//  如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，</span></span><br><span class="line">            <span class="comment">//     如果有，则直接将 str1 指向&quot;hello&quot;；</span></span><br><span class="line">        <span class="comment">// 常量池里有“hello”对象，str2直接指向常量池“hello”对象。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">// 堆中new创建了一个对象。假如“hello”在常量池中不存在，Jvm还会常量池中创建这个对象“hello”。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 下面输出true，因为str1和str2指向的是常量池中的同一个内存地址</span></span><br><span class="line">        System.out.println(str1 == str2);</span><br><span class="line">        <span class="comment">// 下面输出false，str1常量池旧地址，str3是new出的新对象，指向一个全新的地址</span></span><br><span class="line">        System.out.println(str1 == str3);</span><br><span class="line">        <span class="comment">// 下面输出false，因为它们引用不同</span></span><br><span class="line">        System.out.println(str4 == str3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.比较内容</span></span><br><span class="line">        <span class="comment">// 下面输出true，因为String类的equals方法重写过，比较的是字符串值</span></span><br><span class="line">        System.out.println(str4.equals(str3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与equals-的区别"><a href="#与equals-的区别" class="headerlink" title="==与equals()的区别"></a><code>==</code>与equals()的区别</h3><p><code>==</code> 比较基本数据类型时，比较的是两个数值是否相等； 比较引用类型是，比较的是对象的内存地址是否相等。<br>equals() 没有重写时，Object默认以<code>==</code>来实现，即比较两个对象的内存地址是否相等； 重写以后，按照重写的逻辑进行比较。<br>示例：String源码中重写的equals()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public final class String</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (anObject <span class="keyword">instanceof</span> String aString)</span><br><span class="line">            &amp;&amp; (!COMPACT_STRINGS || <span class="built_in">this</span>.coder == aString.coder)</span><br><span class="line">            &amp;&amp; StringLatin1.equals(value, aString.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final class stringLatin1</span></span><br><span class="line"><span class="meta">@IntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="type">byte</span>[] value, <span class="type">byte</span>[] other)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length == other.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value[i] != other[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果地址一样，则一定相等；</li><li>如果对比的元素不是String类型，则一定不相等；</li><li>遍历String底层的数组，逐个对比字符是否相等；</li></ul><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>split() 方法是 Java 中 String 类的一个方法，用于将字符串分割成字符串数组，根据给定的正则表达式作为分隔符。该方法有两个重载的版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.split(String regex)： 使用给定的正则表达式作为分隔符，将字符串分割为字符串数组。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> <span class="string">&quot;Hello, World! How are you?&quot;</span>;</span><br><span class="line">String[] words = sentence.split(<span class="string">&quot; &quot;</span>);          <span class="comment">// 使用空格作为分隔符</span></span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">    System.out.println(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.split(String regex, int limit)： 使用给定的正则表达式作为分隔符，将字符串分割为字符串数组，限制分割的次数。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> <span class="string">&quot;apple,orange,banana,grape&quot;</span>;</span><br><span class="line">String[] fruits = sentence.split(<span class="string">&quot;,&quot;</span>, <span class="number">2</span>);      <span class="comment">// 使用逗号作为分隔符，限制分割次数为 2</span></span><br><span class="line"><span class="keyword">for</span> (String fruit : fruits) &#123;</span><br><span class="line">    System.out.println(fruit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// apple</span></span><br><span class="line"><span class="comment">// orange,banana,grape</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：split() 方法的参数是正则表达式，因此在传入正则表达式时，可能需要注意转义字符的使用。例如，如果要以点号 . 作为分隔符，由于点号在正则表达式中有特殊含义，需要使用双反斜杠 \ 进行转义。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> <span class="string">&quot;one.two.three&quot;</span>;</span><br><span class="line">String[] parts = sentence.split(<span class="string">&quot;\\.&quot;</span>);  <span class="comment">// 使用点号作为分隔符，需要转义</span></span><br><span class="line"><span class="keyword">for</span> (String part : parts) &#123;</span><br><span class="line">    System.out.println(part);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Java Programming&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">lowerCase</span> <span class="operator">=</span> text.toLowerCase();</span><br><span class="line"><span class="type">String</span> <span class="variable">upperCase</span> <span class="operator">=</span> text.toUpperCase();</span><br></pre></td></tr></table></figure><h3 id="字符串和数字的互相转换"><a href="#字符串和数字的互相转换" class="headerlink" title="字符串和数字的互相转换"></a>字符串和数字的互相转换</h3><p><strong>1. 字符串转整数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">strNumber</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">// 使用 Integer.parseInt() 方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> Integer.parseInt(strNumber);</span><br><span class="line">System.out.println(<span class="string">&quot;Parsed Integer: &quot;</span> + intValue);</span><br><span class="line"><span class="comment">// 使用 Integer.valueOf() 方法</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integerValue</span> <span class="operator">=</span> Integer.valueOf(strNumber);</span><br><span class="line">System.out.println(<span class="string">&quot;Integer Value: &quot;</span> + integerValue);</span><br></pre></td></tr></table></figure><p><strong>2. 整数转字符串：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="comment">// 使用 String.valueOf() 方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strNumber</span> <span class="operator">=</span> String.valueOf(intValue);</span><br><span class="line">System.out.println(<span class="string">&quot;String Value: &quot;</span> + strNumber);</span><br><span class="line"><span class="comment">// 使用 Integer.toString() 方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strNumber</span> <span class="operator">=</span> Integer.toString(intValue);</span><br><span class="line">System.out.println(<span class="string">&quot;String Value: &quot;</span> + strNumber);</span><br></pre></td></tr></table></figure><h3 id="数组和字符串的互相转换"><a href="#数组和字符串的互相转换" class="headerlink" title="数组和字符串的互相转换"></a><strong>数组和字符串的互相转换</strong></h3><ol><li><strong>数组转List</strong>：List<T> arrayToList(T[] array)</li><li><strong>List转数组</strong>：T[] listToArray(List<T> list, Class<T> elementType)</li><li><strong>数组转Set</strong>：Set<T> arrayToSet(T[] array)</li><li><strong>Set转数组：</strong>T[] setToArray(Set<T> set, Class<T> elementType)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 数组转List</span></span><br><span class="line">String[] array = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; listFromArray = Arrays.asList(array);</span><br><span class="line">System.out.println(<span class="string">&quot;List from Array: &quot;</span> + listFromArray);</span><br><span class="line"><span class="comment">// 2. List转数组</span></span><br><span class="line">List&lt;String&gt; fruitList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">String[] arrayFromList = fruitList.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;Array from List: &quot;</span> + Arrays.toString(arrayFromList));</span><br><span class="line"><span class="comment">// 3. List转Set</span></span><br><span class="line">Set&lt;String&gt; setFromList = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(fruitList);</span><br><span class="line">System.out.println(<span class="string">&quot;Set from List: &quot;</span> + setFromList);</span><br><span class="line"><span class="comment">// 4. Set转List</span></span><br><span class="line">Set&lt;String&gt; fruitSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Set.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">List&lt;String&gt; listFromSet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(fruitSet);</span><br><span class="line">System.out.println(<span class="string">&quot;List from Set: &quot;</span> + listFromSet);</span><br><span class="line"><span class="comment">// 5. Set转数组</span></span><br><span class="line">String[] arrayFromSet = fruitSet.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;Array from Set: &quot;</span> + Arrays.toString(arrayFromSet));</span><br><span class="line"><span class="comment">// 6. 数组转Set</span></span><br><span class="line">Set&lt;String&gt; setFromArray = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(array));</span><br><span class="line">System.out.println(<span class="string">&quot;Set from Array: &quot;</span> + setFromArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为集合后，可以通过集合的api操作各元素。例如：判断数组是否包含某个元素：</span></span><br><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEle</span> <span class="operator">=</span> Arrays.asList(array).contains(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(isEle);</span><br></pre></td></tr></table></figure><h3 id="格式化数字为字符串"><a href="#格式化数字为字符串" class="headerlink" title="格式化数字为字符串"></a>格式化数字为字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">123.456789</span>;</span><br><span class="line"><span class="comment">// 格式化浮点数为字符串，保留两位小数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">formattedString</span> <span class="operator">=</span> String.format(<span class="string">&quot;%.2f&quot;</span>, number);</span><br><span class="line">System.out.println(formattedString);</span><br></pre></td></tr></table></figure><h2 id="知识加油站"><a href="#知识加油站" class="headerlink" title="知识加油站"></a>知识加油站</h2><h3 id="字符串和字符数组的区别"><a href="#字符串和字符数组的区别" class="headerlink" title="字符串和字符数组的区别"></a>字符串和字符数组的区别</h3><ul><li><strong>可变性</strong>：字符串是不可变的。一旦创建，字符串的内容就不能被修改。任何对字符串的修改底层都会创建一个新的字符串对象。而字符数组是可变的。你可以直接修改字符数组的元素。</li><li><strong>方法数量</strong>：String类提供了许多用于处理字符串的方法，如拼接、比较、截取、转换大小写等。而字符数组只有toString()、equals()等简单的数组通用方法。</li><li><strong>性质</strong>：String是类（底层是字节数组），字符数组是数组。</li><li><strong>创建方式</strong>：String str = “Hello”;char[] charArray = {‘H’, ‘e’, ‘l’, ‘l’, ‘o’};</li><li><strong>连接</strong>：字符串通过“+”连接，字符数组通过System.arraycopy()连接。</li><li><strong>使用场景</strong>：String不可变，所以适用于不需要频繁修改字符串内容的情况。字符数组适用于需要频繁修改字符内容的情况</li></ul><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>常量池</strong>：Java虚拟机有一个常量池机制，它会直接把字符串常量放入常量池中，从而实现复用。</p><p><strong>Java字符串存储原理</strong>： </p><p>创建字符串常量时，JVM会通过equals()检查字符串常量池中是否存在这个字符串；<br>若字符串常量池中存在该字符串，则直接返回引用实例；<br>若不存在，先实例化该字符串，并且将该字符串的引用放入字符串常量池中，以便于下次使用时，直接取用，达到缓存快速使用的效果。</p><h3 id="String不可被继承、不可变的原因"><a href="#String不可被继承、不可变的原因" class="headerlink" title="String不可被继承、不可变的原因"></a>String不可被继承、不可变的原因</h3><p><strong>String为什么不可被继承？</strong></p><p>因为String类底层的数组是由final修饰的，所以String类不可被继承。</p><p><strong>String字符串为什么不可被变？</strong></p><p>因为String底层char类型的value数组是private final修饰的。</p><ul><li><strong>final修饰</strong>：导致value不能指向新数组（但无法保证value这个引用变量指向的真实数组不可变）；</li><li><strong>private修饰，且没对外暴露任何修改value的方法</strong>：导致value这个引用变量指向的底层数组不可变；</li></ul><p><strong>不可变的优点</strong>：因为压根不会被改，所以线程安全、节省空间、效率高。 </p><h3 id="new-String-“abc”-创建的字符串对象数量"><a href="#new-String-“abc”-创建的字符串对象数量" class="headerlink" title="new String(“abc”)创建的字符串对象数量"></a>new String(“abc”)创建的字符串对象数量</h3><p>一个或两个。<strong>原因如下</strong>：</p><ul><li><p>首先，new string 这边由于 new 关键字，所以这边肯定会在堆中直接创建一个字符串对象。</p></li><li><p>其次，如果字符串常量池中不存在 “abc”（通过equals比较）这个字符串的引用，则会在字符串常量池中创建一个字符串对象。如果已存在则不创建。注意这边说的在字符串常量池创建对象，最终对象还是在堆中创建，字符串常量池只放引用。</p></li></ul><hr><h1 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>String拼接字符串后原字符串还存在于内存中，浪费内存。</p><p>StringBuffer 类的对象能够被多次的修改，并且不产生新的未使用对象，所以涉及到字符串拼接，优先用StringBuffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>); </span><br><span class="line"><span class="comment">// String转StringBuilder</span></span><br><span class="line">sb.append(<span class="string">&quot;d&quot;</span>).append(<span class="string">&quot;e&quot;</span>).append(<span class="string">&quot;f&quot;</span>); </span><br><span class="line"><span class="comment">// StringBuilder转String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line"><span class="comment">// 反转</span></span><br><span class="line">sb.reverse();</span><br></pre></td></tr></table></figure><h2 id="String、StringBuffer、Stringbuilder的区别"><a href="#String、StringBuffer、Stringbuilder的区别" class="headerlink" title="String、StringBuffer、Stringbuilder的区别"></a>String、StringBuffer、Stringbuilder的区别</h2><p><strong>String</strong>：不可变字符序列，效率低，但是复用率高、线程安全。</p><p>不可变是指String对象创建之后，直到这个对象销毁为止，对象中的字符序列都不能被改变。</p><p>复用率高是指String类型对象创建出来后归常量池管，可以随时从常量池调用同一个String对象。<code>StringBuffer</code>和<code>StringBuider</code>在创建对象后一般要转化成String对象才调用。</p><p><code>StringBuffer</code>和<code>StringBuilder</code>都是字符序列可变的字符串，方法也一样，有共同的父类<code>AbstractStringBuilder</code>。 </p><ul><li><code>StringBuffer</code>：可变字符序列、效率较高(增删)、线程安全</li><li><code>StringBuilder</code>：可变字符序列、效率最高、线程不安全</li></ul><hr><h1 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h1><p>该类用于从各种输入源（如控制台）中获取基本数据类型和字符串，如 int、double、String 等。常用于从控制台、文件等读取数据。</p><p><strong>构造方法</strong>：</p><ul><li><code>Scanner(InputStream source)</code>： 构造一个新的 Scanner，生成的扫描器从指定的输入流读取数据。一般用System.in，即标准输入流，用于读取用户在控制台输入的数据。</li><li><code>Scanner(File source)</code>： 构造一个新的 Scanner，生成的扫描器从指定的文件读取数据。</li><li><code>Scanner(String source)</code>：构造一个新的 Scanner，生成的扫描器从指定的字符串读取数据。</li></ul><p><strong>常用方法</strong>：</p><ul><li><code>nextInt()、nextDouble()、next()</code>：获取输入的整数、浮点数、字符串（不包括空格）等。</li><li><code>nextLine()</code>：获取一行输入（包括空格）。</li><li><code>hasNextInt()、hasNextDouble()、hasNext()</code>： 判断下一个输入是否为整数、浮点数、字符串。</li><li><code>useDelimiter(String pattern)</code>： 设置分隔符模式，用于指定不同类型数据之间的分隔符，默认为空白字符。</li><li><code>close()</code>：关闭扫描器。</li></ul><p><strong>示例：</strong>从控制台输入整数、浮点数、字符串，并在控制台打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象，关联 System.in（标准输入流）</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 从控制台读取整数</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter an integer: &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;You entered: &quot;</span> + intValue);</span><br><span class="line">        <span class="comment">// 从控制台读取浮点数</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter a double: &quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;You entered: &quot;</span> + doubleValue);</span><br><span class="line">        <span class="comment">// 从控制台读取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringValue</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;You entered: &quot;</span> + stringValue);</span><br><span class="line">        <span class="comment">// 关闭 Scanner 对象</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// Enter an integer: 1</span></span><br><span class="line"><span class="comment">// You entered: 1</span></span><br><span class="line"><span class="comment">// Enter a double: 2</span></span><br><span class="line"><span class="comment">// You entered: 2.0</span></span><br><span class="line"><span class="comment">// Enter a string: 4</span></span><br><span class="line"><span class="comment">// You entered: 4</span></span><br></pre></td></tr></table></figure><hr><h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>在 Java 中，Object 类是所有类的根类，所有其他类都直接或间接地继承自 Object 类。</p><p>Object 类定义了一些基本的方法，这些方法可以被所有对象继承和使用：</p><ol><li><p><strong>toString() 方法：</strong> 返回对象的字符串表示。再不重写的情况下，toString() 返回的是对象的类名和散列码的十六进制表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义转字符串逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyClass&#123;&quot;</span> +</span><br><span class="line">               <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用 toString() 方法</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// toString将根据自己重新的逻辑返回字符串，而不是返回对象的类名和散列码的十六进制表示</span></span><br><span class="line">System.out.println(obj.toString());  <span class="comment">// 输出结果为 &quot;MyClass&#123;value=42&#125;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>equals(Object obj) 方法：</strong> 比较对象是否相等。默认情况下，equals() 方法比较的是对象的引用（即内存地址），重写后可以自定义比较逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// ... 其他代码 ...</span></span><br><span class="line">    <span class="comment">// 自定义比较逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><strong>hashCode() 方法：</strong> 返回对象的散列码。hashCode() 方法的默认实现返回对象的内存地址的散列码。通常情况下，如果 equals() 方法被覆盖，那么也应该同时覆盖 hashCode() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li><li><p><strong>getClass() 方法：</strong> 返回对象的类。该方法基于反射，返回类的 Class 对象，该对象包含有关对象的类的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="number">42</span>);</span><br><span class="line">Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line">System.out.println(clazz.getName());  <span class="comment">// 输出结果为 &quot;MyClass&quot;   </span></span><br></pre></td></tr></table></figure></li><li><p><strong>clone() 方法：</strong> 创建并返回对象的拷贝。要实现 clone() 方法，类必须实现 Cloneable 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneableClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneableClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li><li><p><strong>finalize() 方法：</strong> 在对象被垃圾收集器回收之前调用。通常不推荐使用 finalize() 方法，因为它的行为是不确定的，并且可能导致一些问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 执行清理工作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">super</span>.finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="JVM垃圾回收的可达性分析算法"><a href="#JVM垃圾回收的可达性分析算法" class="headerlink" title="JVM垃圾回收的可达性分析算法"></a>JVM垃圾回收的可达性分析算法</h2><p>JVM垃圾回收的可达性分析算法有用到Object类的finalize() 方法。</p><p><strong>可达性分析算法</strong>：</p><p>以根对象集合(GC Roots)的每个跟对象为起始点，根据引用关系向下搜索，将所有与GC Roots直接或间接有引用关系的对象在对象头的Mark Word里标记为可达对象，即不需要回收的有引用关系对象。搜索过程所走过的路径称为“引用链” 。</p><p>**<code>GC Roots</code>**：即GC根节点集合，是一组必须活跃的引用。可作为GC Roots的对象：</p><ul><li><strong>栈引用的对象</strong>：Java方法栈、本地方法栈中的参数引用、局部变量引用、临时变量引用等。临时变量是方法里的中间操作结果。</li><li>方法区中常量、静态变量引用的对象；</li><li>所有被同步锁持有的对象；</li><li>所有线程对象；</li><li>所有跨代引用对象；</li><li><strong>JVM内部的引用</strong>：如基本数据类型对应的Class对象，常驻的异常对象，以及应用程序类类加载器； </li></ul><p><strong>非可达对象被回收需要两次标记</strong>：</p><ol><li><strong>第一次标记后筛选非可达对象</strong>：第一次被标记后，会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，也就是是否有机会自救。假如对象没有覆盖或者已被JVM调用过finalize()方法，也就是说不想自救或已自救过，那么此对象需要被回收；假如对象覆盖并没被JVM调用过finalize()方法，该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</li><li><strong>第二次标记<code>F-Queue</code>里的未自救对象</strong>：稍后，收集器将对F-Queue中的对象进行第二次小规模的标记。如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this）赋值给某个引用类型的类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的F-Queue。如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</li></ol><p><strong><code>finalize()</code>方法</strong>： </p><p>finalize()方法是对象逃脱死亡命运的最后一次机会，需要注意的是，任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。</p><p>另外，finalize()方法的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。</p><h2 id="hashCode-和equals-的区别"><a href="#hashCode-和equals-的区别" class="headerlink" title="hashCode()和equals()的区别"></a>hashCode()和equals()的区别</h2><p><strong>用途：</strong></p><ul><li><code>hashCode()</code>方法的主要用途是获取哈希码；</li><li><code>equals()</code>主要用来比较两个对象是否相等。</li></ul><p><strong>为什么重写equals()就要重写hashcode()？</strong> </p><p>因为二者之间有两个约定，相等对象的哈希码也要相等。</p><p>所以equals()方法重写时，通常也要将<code>hashCode()</code>进行重写，使得这两个方法始终满足相关的约定。 例如<code>HashSet</code>排序机制底层就是通过计算哈希码进行排序的，如果只重写<code>equals()</code>将达不到根据哈希码排序的效果。</p><p>如果两个对象相等,它们必须有相同的哈希码；但如果两个对象的哈希码相同,他们却不一定相等。</p><p><strong>哈希碰撞</strong>：由于哈希码是一个有限的整数，因此有可能会出现不同的对象计算出相同的哈希码的情况。 例如某类里有两个int型成员变量，重写后equals()比较两个变量是否相等，hashcode()是两个变量的和，A对象变量是2和3，B对象变量是1和4，加起来都是5，它们哈希码相等而不equal。</p><hr><h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><p>System 类是 Java 标准库中的一个工具类，提供了与系统相关的一些操作。</p><p>它包含一些静态方法和字段，用于访问系统属性、标准输入输出、垃圾回收等。</p><p>常用方法和字段：</p><blockquote><p>PrintStream、PrintStream等IO流详细看后文的I/O流。</p></blockquote><ol><li><p><strong><code>out</code> 字段</strong>： 是 PrintStream 类的一个实例，用于标准输出。可以使用 System.out.println() 来向标准输出打印信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);  <span class="comment">// 将 &quot;Hello, World!&quot; 输出到标准输出</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>err</code> 字段</strong>： 是 PrintStream 类的一个实例，用于标准错误输出。可以使用 System.err.println() 来向标准错误输出打印错误信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.err.println(<span class="string">&quot;This is an error message.&quot;</span>);  <span class="comment">// 将错误信息输出到标准错误输出</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>in</code> 字段</strong>： 是 InputStream 类的一个实例，用于标准输入。可用 Scanner 或 BufferedReader 等类从标准输入读取用户输入信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;Enter your name: &quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine();</span><br></pre></td></tr></table></figure></li><li><p><strong><code>currentTimeMillis() </code>方法</strong>： 返回当前时间与1970年1月1日午夜之间的毫秒数。通常用于测量代码的执行时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 执行一些操作</span></span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> endTime - startTime;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code> 方法</strong>： 用于复制数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] sourceArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] destinationArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">System.arraycopy(sourceArray, <span class="number">0</span>, destinationArray, <span class="number">0</span>, sourceArray.length);</span><br><span class="line"><span class="comment">// 现在 destinationArray 中包含了 sourceArray 的内容</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>getProperty(String key)</code> 方法</strong>： 获取系统属性。可以用于获取一些系统相关的信息，比如操作系统类型、Java 版本等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Operating System: &quot;</span> + osName);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>exit(int status) </code>方法</strong>： 终止当前运行的 Java 虚拟机。status 参数是一个整数，通常用于指示程序的退出状态。非零值通常表示发生了错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.exit(<span class="number">0</span>);  <span class="comment">// 正常退出程序</span></span><br><span class="line">System.exit(<span class="number">1</span>);  <span class="comment">// 异常退出程序</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>gc()</code> 方法</strong>： 强制调用垃圾回收器。虽然 Java 具有自动垃圾回收机制，但可以使用 System.gc() 来显式地触发垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.gc();  <span class="comment">// 强制调用垃圾回收器</span></span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h1><h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Integer类是 Java 中用于表示整数的包装类，它提供了许多方法来对整数进行操作和转换。</p><p>相比于基本数据类型，包装类的优势：可以有更多的方法操作改数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装箱：基本数据类型转为包装类</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">32</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"><span class="comment">// 拆箱：包装类转为基本数据类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a.intValue();</span><br><span class="line"><span class="comment">// 数字转String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(<span class="number">12</span>);</span><br><span class="line"><span class="comment">// String转数字</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line"><span class="comment">// String转Integer转数字</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> Integer.valueOf(s).intValue();</span><br></pre></td></tr></table></figure><h2 id="包装类的自动拆装箱与自动装箱"><a href="#包装类的自动拆装箱与自动装箱" class="headerlink" title="包装类的自动拆装箱与自动装箱"></a>包装类的自动拆装箱与自动装箱</h2><p><strong>包装类</strong>：包装类的主要作用是用于便于操作基本数据类型，将基本数据类型转换为对象，让基本数据类型拥有对象的特征，例如封装方法、泛型（基本数据类型不能作为泛型参数）、反射。 </p><p>自动装箱是指把一个基本类型的数据直接赋值给对应的包装类型；</p><p>自动拆箱是指把一个包装类型的对象直接赋值给对应的基本类型；</p><p><strong>向上转型</strong>：布尔型外的基本数据类型在互相比较或运算时会向上转型：byte,short,char → int → long → float → double。原理是将低字节数的数据类型转换为高字节数的数据类型，可以保证数据精度不丢失。c语言转型顺序：char→short→int→long→float→double </p><h2 id="什么情况下用包装类？什么情况下用基本数据类型？"><a href="#什么情况下用包装类？什么情况下用基本数据类型？" class="headerlink" title="什么情况下用包装类？什么情况下用基本数据类型？"></a>什么情况下用包装类？什么情况下用基本数据类型？</h2><p><strong>包装类适用场景</strong>： </p><ul><li><strong>实体类属性必须使用包装类</strong>：《阿里规约》规定，所有的 POJO 类属性必须使用包装数据类型，而不是基本数据类型。因为数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险（NullPointerException空指针异常）。</li><li><strong>RPC方法的返回值和参数必须使用包装类</strong>：《阿里规约》规定，RPC 方法的返回值和参数必须使用包装数据类型。因为相比基本数据类型，包装类的null值能展示额外的信息。例如远程调用获取商品价格，如果用包装类，null表示获取失败，0表示价格是0；而如果用基本数据类型，即使获取失败返回值也是0，你就没法知道是价格0还是获取失败了。</li></ul><p><strong>基本数据类型适用场景</strong>： </p><ul><li><strong>局部变量尽量使用基本数据类型</strong>：《阿里规约》建议，所有的局部变量使用基本数据类型。因为包装类对象是引用类型，JVM中，基本数据类型存储在方法栈中，引用数据类型存储堆内存实际对象的地址值，如果局部变量定义为引用数据类型还得根据这个地址值去找值，性能差（每次要new），而且耗费空间，毕竟它的作用域只是方法内。</li></ul><h2 id="包装类和基本数据类型直接如何互相比较？（浮点数等号比较精度丢失问题）"><a href="#包装类和基本数据类型直接如何互相比较？（浮点数等号比较精度丢失问题）" class="headerlink" title="包装类和基本数据类型直接如何互相比较？（浮点数等号比较精度丢失问题）"></a>包装类和基本数据类型直接如何互相比较？（浮点数等号比较精度丢失问题）</h2><p>包装类和基本数据类型：直接通过==比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line"><span class="comment">// true，相等</span></span><br><span class="line">System.out.println(b == integer);</span><br></pre></td></tr></table></figure><p><strong>整型</strong>： </p><ul><li>相同整型包装类必须通过equals()比较。虽然两个通过自动装箱创建的、数值在缓存范围的相同整型包装类可以通过<code>==</code>比较（例如Integer a=1,b=1，则a<code>==</code>b），但《阿里规约》规定整型包装类必须通过equals()比较。包装类和各类型基本类型可以通过<code>==</code>比较。</li><li>不同整型包装类必须转成相同类再通过<code>equals()</code>比较。</li><li>整型基本数据类型用<code>==</code>比较。</li></ul><p><strong>浮点型</strong>：</p><ul><li><p>浮点包装类先都转为<code>BigDecimal</code>，再进行运算、比较。</p></li><li><p>浮点基本类型直接比较，要声明误差，两浮点数差值在此范围内，认为是相等的。 </p></li></ul><p><strong>浮点数正确比较方法</strong>：</p><p><strong>基本数据类型</strong>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">1e-6f</span>;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(a - b) &lt; diff) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a、b相等&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>包装类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了保证高精度</span></span><br><span class="line"><span class="comment">// BigDecimal推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法</span></span><br><span class="line"><span class="comment">// valueOf方法内部其实执行了Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.9</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x.equals(y)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a、b相等&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Integer-a1-127-Integer-a2-127-a1-a2原因"><a href="#Integer-a1-127-Integer-a2-127-a1-a2原因" class="headerlink" title="Integer a1=127;Integer a2=127;a1==a2原因"></a>Integer a1=127;Integer a2=127;a1==a2原因</h2><p><strong>享元模式</strong>： </p><p>Integer 内部有享元模式设计，【-128,127】范围内的数字会被缓存，使用自动装箱方式赋值时，Java默认通过<code>valueOf()</code>方法对127这个数字进行装箱操作，触发缓存机制，使a1和a2指向同一个内存地址。</p><ul><li>Byte、Short、Integer、Long 缓存区间【-128,127】。</li><li>Character 包装类型缓存区间[0,127]。</li><li>浮点型和布尔型没用享元模式，没有缓存区间。</li></ul><hr><h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p><code>Arrays</code> 类包含了一系列用于操作数组的静态方法。可以对数组排序、搜索、比较、转换、填充等。以下是 <code>Arrays</code> 类的一些常用方法：</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort(T[] a)：对数组进行升序排序</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Arrays.sort(numbers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort(T[] a, Comparator&lt;? super T&gt; c)： 使用指定的比较器对数组进行排序</span></span><br><span class="line">String[] names = &#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Eve&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(names, Comparator.reverseOrder());</span><br></pre></td></tr></table></figure><h2 id="查找和判断"><a href="#查找和判断" class="headerlink" title="查找和判断"></a>查找和判断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binarySearch(T[] a, T key)： 在已排序的数组中使用二分查找算法查找指定元素的索引</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// equals(T[] a, T[] a2)： 比较两个数组是否相等</span></span><br><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> Arrays.equals(arr1, arr2);</span><br></pre></td></tr></table></figure><h2 id="批量填充"><a href="#批量填充" class="headerlink" title="批量填充"></a>批量填充</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fill(T[] a, T val)： 使用指定的值填充数组的所有元素</span></span><br><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(numbers, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><h2 id="转换字符串、链表"><a href="#转换字符串、链表" class="headerlink" title="转换字符串、链表"></a>转换字符串、链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toString(T[] a)： 返回包含数组元素的字符串</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">arrayString</span> <span class="operator">=</span> Arrays.toString(numbers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// asList(T... a)： 将数组转换为固定大小的列表</span></span><br><span class="line">String[] names = &#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; nameList = Arrays.asList(names);</span><br></pre></td></tr></table></figure><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copyOf(T[] original, int newLength)： 复制指定长度的数组</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] copiedNumbers = Arrays.copyOf(numbers, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><hr><h1 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h1><p>Date 类是 Java 中用于表示日期和时间的类，位于 java.util 包中。在 Java 8 及之前的版本中，Date 类是主要的日期时间处理类，但在 Java 8 引入了 java.time 包，推荐使用新的日期时间 API（java.time 包中的 LocalDate、LocalTime、LocalDateTime 等类）。尽管如此，我们仍然可以了解 Date 类的基本使用。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><code>getTime()</code>： 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来的毫秒数。<br><code>toString()</code>： 返回日期对象的字符串表示。<br><code>after(Date when)</code>： 判断某个日期是否在指定日期之后<br><code>before(Date when)</code>：判断某个日期是否在指定日期之前<br><code>a.compareTo(b)</code>：对两个日期进行比较 如果a时间在b之后，则返回1 如果a时间在b之前，则返回-1 如果a==b，则返回0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建当前日期和时间的 Date 对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">currentDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">// 输出当前日期和时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Current Date and Time: &quot;</span> + currentDate);</span><br><span class="line">        <span class="comment">// 获取毫秒表示的时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> currentDate.getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;Timestamp: &quot;</span> + timestamp);</span><br><span class="line">        <span class="comment">// 通过时间戳创建 Date 对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">newDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(timestamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;New Date: &quot;</span> + newDate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// Current Date and Time: Tue Jul 22 16:18:49 GMT+08:00 2025</span></span><br><span class="line"><span class="comment">// Timestamp: 1753172329875</span></span><br><span class="line"><span class="comment">// New Date: Tue Jul 22 16:18:49 GMT+08:00 2025</span></span><br></pre></td></tr></table></figure><h2 id="Date类的线程安全问题"><a href="#Date类的线程安全问题" class="headerlink" title="Date类的线程安全问题"></a>Date类的线程安全问题</h2><p><strong>Date类的缺点</strong>：</p><ul><li><p><strong>线程不安全</strong>：Date类可变，在多线程环境中使用时需要额外的同步措施。<strong>解决方案</strong>：</p><ul><li><strong>使用局部变量</strong>：局部变量不会被多个线程同时访问到。</li><li><strong>加锁</strong>：通过synchronized锁或者lock锁，保证线程同步。</li><li><strong>ThreadLocal</strong>：<code>ThreadLocal</code> 可确保每个线程都能得到单独的一个 SimpleDateFormat 的对象，自然也就不存在竞争问题了</li><li><strong>DateTimeFormatter</strong>：如果是Java8应用，可以使用DateTimeFormatter代替SimpleDateFormat，这是一个线程安全的格式化工具类</li></ul></li><li><p><strong>获取时间不方便</strong>：Date类的年份是从 1900 年开始的，月份从 0 开始。</p></li><li><p><strong>没时区</strong>：Date类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。</p></li><li><p><strong>需要格式化</strong>：需要搭配<code>SimpleDateformat</code>类格式化时间，而且SimpleDateformat类也是线程不安全的，如果使用线程安全的DateTimeFormatter类格式化时间，则需要JDK版本在1.8及以上。</p></li></ul><h2 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h2><h3 id="SimpleDateformat类：线程不安全"><a href="#SimpleDateformat类：线程不安全" class="headerlink" title="SimpleDateformat类：线程不安全"></a>SimpleDateformat类：线程不安全</h3><p>SimpleDateformat类用于格式化和解析日期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// throws只是把异常抛出，延迟处理。用trycatch处理比较好</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;    </span><br><span class="line">    <span class="comment">// Date转String</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sdf.format(d);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="comment">// String转Date</span></span><br><span class="line">    d = sdf.parse(str);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>日期格式模式：</p><p>SimpleDateFormat 使用一组模式字母来定义日期时间格式。以下是一些常见的模式字母：</p><ul><li><p>y： 年份（如 “yy” 表示年份的后两位，”yyyy” 表示完整的年份）。</p></li><li><p>M： 月份（1-12，”MM” 表示两位数字，”MMM” 表示缩写，”MMMM” 表示全名）。</p></li><li><p>d： 日期（1-31，”dd” 表示两位数字）。</p></li><li><p>H： 小时（0-23，”HH” 表示两位数字）。</p></li><li><p>m： 分钟（0-59，”mm” 表示两位数字）。</p></li><li><p>s： 秒钟（0-59，”ss” 表示两位数字）。</p></li></ul></blockquote><h3 id="DateTimeFormatter类：线程安全"><a href="#DateTimeFormatter类：线程安全" class="headerlink" title="DateTimeFormatter类：线程安全"></a>DateTimeFormatter类：线程安全</h3><p>DateTimeFormatter 类是 Java 8 引入的日期时间 API（java.time 包）的一部分，用于格式化和解析日期时间对象。</p><p><strong>特点</strong>：</p><ul><li><p>不可变且线程安全</p></li><li><p>支持新的日期时间类</p></li><li><p>适用于 Java 8 及以上版本。</p></li><li><p>异常处理：在解析字符串时，如果字符串的格式与指定的模式不匹配，会抛出 DateTimeParseException 异常，因此需要异常处理。</p></li></ul><p><strong>常用方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.格式化日期时间：format(TemporalAccessor temporal)： 格式化指定的日期时间对象。</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDateTime</span> <span class="operator">=</span> formatter.format(dateTime);</span><br><span class="line"><span class="comment">// 2.解析字符串为日期时间：parse(CharSequence text)： 解析输入的文本，返回一个解析后的日期时间对象。</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateString</span> <span class="operator">=</span> <span class="string">&quot;2023-12-01 15:30:00&quot;</span>;</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">parsedDateTime</span> <span class="operator">=</span> formatter.parse(dateString, LocalDateTime::from);</span><br><span class="line"><span class="comment">// 3.获取格式化/解析模式：toString()： 获取当前格式化/解析器的模式字符串。</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> formatter.toString(); <span class="comment">// 返回 &quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line"><span class="comment">// 4.将当前时间格式化为字符串</span></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 DateTimeFormatter 对象，指定日期时间格式模式</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取当前日期时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">currentDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 格式化日期时间为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedDateTime</span> <span class="operator">=</span> currentDateTime.format(formatter);</span><br><span class="line">        System.out.println(<span class="string">&quot;Formatted Date and Time: &quot;</span> + formattedDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><p>Math 类是数学工具类，提供了一系列用于执行基本数学运算的静态方法。</p><p><strong>基本使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 基本数学运算</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">absoluteValue</span> <span class="operator">=</span> Math.abs(-<span class="number">5.5</span>);  <span class="comment">// 返回绝对值，结果为 5.5</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">ceilValue</span> <span class="operator">=</span> Math.ceil(<span class="number">4.3</span>);      <span class="comment">// 返回不小于参数的最小整数值，结果为 5.0</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">floorValue</span> <span class="operator">=</span> Math.floor(<span class="number">4.9</span>);    <span class="comment">// 返回不大于参数的最大整数值，结果为 4.0</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">maxValue</span> <span class="operator">=</span> Math.max(<span class="number">10.2</span>, <span class="number">5.8</span>);   <span class="comment">// 返回两个参数中的最大值，结果为 10.2</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">minValue</span> <span class="operator">=</span> Math.min(<span class="number">3.5</span>, <span class="number">7.1</span>);    <span class="comment">// 返回两个参数中的最小值，结果为 3.5</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">roundValue</span> <span class="operator">=</span> Math.round(<span class="number">3.8</span>);       <span class="comment">// 返回最接近参数的整数值，四舍五入，结果为 4</span></span><br><span class="line">        <span class="comment">// 指数运算</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">expValue</span> <span class="operator">=</span> Math.exp(<span class="number">2.0</span>);         <span class="comment">// 返回 e 的指数值，结果为 7.3890560989306495</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">logValue</span> <span class="operator">=</span> Math.log(<span class="number">10.0</span>);        <span class="comment">// 返回以 e 为底的对数值，结果为 2.302585092994046</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">powValue</span> <span class="operator">=</span> Math.pow(<span class="number">2.0</span>, <span class="number">3.0</span>);    <span class="comment">// 返回 2 的 3 次方，结果为 8.0</span></span><br><span class="line">        <span class="comment">// 平方根和立方根</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">sqrtValue</span> <span class="operator">=</span> Math.sqrt(<span class="number">25.0</span>);      <span class="comment">// 返回参数的平方根，结果为 5.0</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">cbrtValue</span> <span class="operator">=</span> Math.cbrt(<span class="number">27.0</span>);      <span class="comment">// 返回参数的立方根，结果为 3.0</span></span><br><span class="line">        <span class="comment">// 三角函数</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">sinValue</span> <span class="operator">=</span> Math.sin(Math.PI / <span class="number">6</span>);     <span class="comment">// 返回参数的正弦值，结果为 0.5</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">cosValue</span> <span class="operator">=</span> Math.cos(Math.PI / <span class="number">3</span>);     <span class="comment">// 返回参数的余弦值，结果为 0.5</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">tanValue</span> <span class="operator">=</span> Math.tan(Math.PI / <span class="number">4</span>);     <span class="comment">// 返回参数的正切值，结果为 1.0</span></span><br><span class="line">        <span class="comment">// 角度和弧度转换</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">degreesValue</span> <span class="operator">=</span> Math.toDegrees(Math.PI / <span class="number">2</span>);  <span class="comment">// 将弧度转换为角度，结果为 90.0</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">radiansValue</span> <span class="operator">=</span> Math.toRadians(<span class="number">180.0</span>);        <span class="comment">// 将角度转换为弧度，结果为 π</span></span><br><span class="line">        <span class="comment">// 随机数生成</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">randomValue</span> <span class="operator">=</span> Math.random();  <span class="comment">// 返回一个大于等于 0.0 且小于 1.0 的随机浮点数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h1><h2 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>java.util.Random类：</strong>主要用于生成伪随机数。</p><p><strong>伪随机：</strong>Random类产生的数字是伪随机的，在相同种子数（seed）下的相同次数产生的随机数是相同的。</p><h2 id="代码示例-不指定种子"><a href="#代码示例-不指定种子" class="headerlink" title="代码示例 不指定种子"></a>代码示例 不指定种子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Random 对象</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成 0 到 10（不包括10）之间的随机整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//生成 -1 到 10（不包括10）之间的随机整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>) - <span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;生成 0 到 10（不包括10）之间的随机整数：&quot;</span>+num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机浮点数：生成一个介于 0（包含）和 1（不包含）之间的浮点数</span></span><br><span class="line"><span class="type">double</span> <span class="variable">randomDouble</span> <span class="operator">=</span> random.nextDouble();</span><br><span class="line">System.out.println(<span class="string">&quot;Random Double: &quot;</span> + randomDouble);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机布尔值</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">randomBoolean</span> <span class="operator">=</span> random.nextBoolean();</span><br><span class="line">System.out.println(<span class="string">&quot;Random Boolean: &quot;</span> + randomBoolean);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机字节数组</span></span><br><span class="line"><span class="type">byte</span>[] randomBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">random.nextBytes(randomBytes);</span><br><span class="line">System.out.println(<span class="string">&quot;Random Bytes: &quot;</span> + Arrays.toString(randomBytes));</span><br></pre></td></tr></table></figure><h2 id="代码示例-指定种子"><a href="#代码示例-指定种子" class="headerlink" title="代码示例 指定种子"></a>代码示例 指定种子</h2><blockquote><p>相同种子数（seed）下的相同次数，产生的随机数是相同的。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定种子为42</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">randomWithSeed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(seed);</span><br><span class="line">        <span class="comment">// 生成随机整数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNumber1</span> <span class="operator">=</span> randomWithSeed.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Random Number 1: &quot;</span> + randomNumber1);</span><br><span class="line">        <span class="comment">// 再次生成随机整数，因为种子相同，结果应该相同</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNumber2</span> <span class="operator">=</span> randomWithSeed.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Random Number 2: &quot;</span> + randomNumber2);</span><br><span class="line">        <span class="comment">// 创建另一个 Random 对象，没有指定种子</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">randomWithoutSeed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">// 生成随机整数，因为没有指定种子，结果不受前面的影响</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNumber3</span> <span class="operator">=</span> randomWithoutSeed.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Random Number 3: &quot;</span> + randomNumber3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基本概念和语法</title>
    <link href="https://southernfish.github.io/2025/07/23/java/java-base-1-conception/"/>
    <id>https://southernfish.github.io/2025/07/23/java/java-base-1-conception/</id>
    <published>2025-07-23T12:28:36.000Z</published>
    <updated>2025-07-23T12:27:53.080Z</updated>
    
    <content type="html"><![CDATA[<p>Java是一门面向对象的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131?fromModule=lemma_inlink">编程语言</a>，不仅吸收了<a href="https://baike.baidu.com/item/C%2B%2B/99272?fromModule=lemma_inlink">C++</a>语言的各种优点，还摒弃了C++里难以理解的多<a href="https://baike.baidu.com/item/%E7%BB%A7%E6%89%BF/20267560?fromModule=lemma_inlink">继承</a>、<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304?fromModule=lemma_inlink">指针</a>等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。Java具有简单性、面向对象、<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F/19276232?fromModule=lemma_inlink">分布式</a>、<a href="https://baike.baidu.com/item/%E5%81%A5%E5%A3%AE%E6%80%A7/4430133?fromModule=lemma_inlink">健壮性</a>、<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E6%80%A7/7664678?fromModule=lemma_inlink">安全性</a>、平台独立与可移植性、<a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fromModule=lemma_inlink">多线程</a>、动态性等特点。 Java可以编写<a href="https://baike.baidu.com/item/%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/2331979?fromModule=lemma_inlink">桌面应用程序</a>、Web应用程序、<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336?fromModule=lemma_inlink">分布式系统</a>和<a href="https://baike.baidu.com/item/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/186978?fromModule=lemma_inlink">嵌入式系统</a>应用程序等。</p><p>原文链接：<a href="https://blog.csdn.net/qq_40991313/article/details/134564921">https://blog.csdn.net/qq_40991313/article/details/134564921</a></p><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java的八大基本数据类型分别是：</p><ul><li>整型的byte、short、int、long；</li><li>字符型的char；</li><li>浮点型的float、double；</li><li>布尔型的boolean。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 整型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">byteData</span> <span class="operator">=</span> <span class="number">120</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">shortData</span> <span class="operator">=</span> <span class="number">30000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">intData</span> <span class="operator">=</span> <span class="number">2000000000</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">longData</span> <span class="operator">=</span> <span class="number">9000000000000000000L</span>;</span><br><span class="line">        <span class="comment">// 2. 字符型</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">charData</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="comment">// 3. 浮点型</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">floatData</span> <span class="operator">=</span> <span class="number">3.14f</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">doubleData</span> <span class="operator">=</span> <span class="number">123.456</span>;</span><br><span class="line">        <span class="comment">// 4. 布尔型</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">booleanData</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 访问和输出变量值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;整型：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;byteData: &quot;</span> + byteData);</span><br><span class="line">        System.out.println(<span class="string">&quot;shortData: &quot;</span> + shortData);</span><br><span class="line">        System.out.println(<span class="string">&quot;intData: &quot;</span> + intData);</span><br><span class="line">        System.out.println(<span class="string">&quot;longData: &quot;</span> + longData);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符型：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;charData: &quot;</span> + charData);</span><br><span class="line">        System.out.println(<span class="string">&quot;浮点型：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;floatData: &quot;</span> + floatData);</span><br><span class="line">        System.out.println(<span class="string">&quot;doubleData: &quot;</span> + doubleData);</span><br><span class="line">        System.out.println(<span class="string">&quot;布尔型：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;booleanData: &quot;</span> + booleanData);</span><br><span class="line">        <span class="comment">// 操作变量</span></span><br><span class="line">        intData++; <span class="comment">// 增加 intData 的值</span></span><br><span class="line">        doubleData *= <span class="number">2</span>; <span class="comment">// 将 doubleData 的值乘以 2</span></span><br><span class="line">        <span class="comment">// 输出修改后的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n操作后的整型和浮点型变量：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;intData: &quot;</span> + intData);</span><br><span class="line">        System.out.println(<span class="string">&quot;doubleData: &quot;</span> + doubleData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">整型：</span><br><span class="line">byteData: 120</span><br><span class="line">shortData: 30000</span><br><span class="line">intData: 2000000000</span><br><span class="line">longData: 9000000000000000000</span><br><span class="line">字符型：</span><br><span class="line">charData: A</span><br><span class="line">浮点型：</span><br><span class="line">floatData: 3.14</span><br><span class="line">doubleData: 123.456</span><br><span class="line">布尔型：</span><br><span class="line">booleanData: true</span><br><span class="line">操作后的整型和浮点型变量：</span><br><span class="line">intData: 2000000001</span><br><span class="line">doubleData: 246.912</span><br></pre></td></tr></table></figure><h2 id="基本数据类型和引用类型"><a href="#基本数据类型和引用类型" class="headerlink" title="基本数据类型和引用类型"></a>基本数据类型和引用类型</h2><p><strong>基本数据类型</strong> </p><p>基本数据类型共有八大类，这八大数据类型又可分为四小类，分别是整数类型（byte/short/int/long）、浮点类型（float、double）、字符类型（char）和布尔类型（boolean）。</p><p><strong>引用类型</strong></p><p>引用类型包括数组引用、类引用、接口引用，还有一种特殊的null类型，所谓引用数据类型就是对一个对象的引用，对象包括实例和数组两种。</p><p><strong>区别</strong>：</p><table><thead><tr><th>特征</th><th>基本数据类型</th><th>引用类型</th></tr></thead><tbody><tr><td>存储方式</td><td>直接存储数据值</td><td>存储对象的引用，实际数据存储在堆内存中</td></tr><tr><td>默认值</td><td>有默认值，不可为null</td><td>有默认值为null</td></tr><tr><td>赋值方式</td><td>直接赋值</td><td>使用new关键字创建对象</td></tr><tr><td>内存分配</td><td>栈上分配</td><td>在堆上分配</td></tr><tr><td>大小</td><td>固定大小，与具体类型有关</td><td>大小不固定，由对象本身和其内容决定</td></tr><tr><td>效率</td><td>更高效，直接操作数据</td><td>相对较低，需要间接操作对象引用</td></tr><tr><td>比较</td><td>用==比较</td><td>通常使用equals方法比较</td></tr><tr><td>范围</td><td>有限，具体范围取决于数据类型</td><td>无限，取决于系统的内存大小</td></tr><tr><td>传递方式</td><td>值传递，传递的是实际的数据值</td><td>引用传递，传递的是对象的引用</td></tr><tr><td>示例</td><td><code>int num = 42;</code></td><td><code>String str = new String(&quot;Hello&quot;);</code></td></tr><tr><td>JVM存储位置</td><td>方法参数和局部变量：存在本地方法栈的局部变量表；final常量、静态变量：存在类常量池</td><td>堆</td></tr></tbody></table><h2 id="基本数据类型的内存空间"><a href="#基本数据类型的内存空间" class="headerlink" title="基本数据类型的内存空间"></a>基本数据类型的内存空间</h2><p>对于基本数据类型，你需要了解每种类型所占据的内存空间，这是面试官喜欢追问的问题：</p><ul><li><code>byte</code>：1字节（8位）,数据范围是 <code>-2^7 ~ 2^7-1</code>。</li><li><code>short</code>：2字节（16位）,数据范围是 <code>-2^15 ~ 2^15-1</code>。</li><li><code>int</code>：4字节（32位）,数据范围是 <code>-2^31 ~ 2^31-1</code>。</li><li><code>long</code>：8字节（64位）,数据范围是 <code>-2^63 ~ 2^63-1</code>。c语言里long占4字节，long long占8字节。</li><li><code>float</code>：4字节（32位）,数据范围大约是 <code>-3.4*10^38 ~ 3.4*10^38</code>。</li><li><code>double</code>：8字节（64位）,数据范围大约是 <code>-1.8*10^308 ~ 1.8*10^308</code>。</li><li><code>char</code>：2字节（16位）,数据范围是 <code>\u0000 ~ \uffff</code>，<code>unicode</code>编码英文和中文都占两个字节。C语言使用ASCII编码char占1字节，不能存汉字。ASCII编码是Unicode的一个子集，因此它们存在一些字符码值是相等的。</li><li><code>boolean</code>：Java规范没有明确的规定,不同的JVM有不同的实现机制。</li></ul><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="数组的两种创建方式"><a href="#数组的两种创建方式" class="headerlink" title="数组的两种创建方式"></a>数组的两种创建方式</h3><p><strong>一维数组</strong>：数组命名有两种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一（推荐，符合阿里规约）：a和b都是一维数组 </span></span><br><span class="line"><span class="type">int</span>[] a,b;    </span><br><span class="line"><span class="comment">// 方式二：c和d都是一维数组，不推荐这种命名方法</span></span><br><span class="line"><span class="type">int</span> c[],d[];</span><br></pre></td></tr></table></figure><p><strong>二维数组</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] x;</span><br></pre></td></tr></table></figure><p><strong>阿里规约</strong>：【强制】 类型与中括号紧挨相连来表示数组。</p><ol><li><p>正例： 定义整形数组 int[] arrayDemo;</p></li><li><p>反例： 在 main 参数中，使用 String args[]来定义</p></li></ol><h3 id="数组的创建原理"><a href="#数组的创建原理" class="headerlink" title="数组的创建原理"></a>数组的创建原理</h3><p><strong>JVM内存模型</strong>：<a href="https://blog.csdn.net/qq_40991313/article/details/134742377?spm=1001.2014.3001.5501">什么是JVM的内存模型？详细阐述Java中局部变量、常量、类名等信息在JVM中的存储位置</a></p><p>数组存放在JVM的堆中，是一片连续的存储空间，下标依次为0,1,2,3,4…</p><p><strong>数组在JVM中的创建过程</strong>： </p><ol><li>main方法进入方法栈执行</li><li>创建数组，JVM会在堆内存中开辟空间，存储数组</li><li>数组在内存中会有自己的内存地址，以十六进制数表示</li><li>数组中有3个元素，默认值为0</li><li>JVM将数组的内存地址赋值给引用类型变量array</li><li>变量array保存的是数组内存中的地址，而不是一个具体数值，因此称为引用数据类型。</li></ol><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Java数组初始化有两种方式，分别是静态初始化、动态初始化。</p><ol><li><p>静态初始化：不指定数组长度，由JVM自己识别</p></li><li><p>动态初始化：指定数组长度</p></li></ol><h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><p><strong>静态初始化</strong>：不指定数组长度，由JVM自己识别</p><p><strong>格式</strong>：数据类型[]  数组名=new 数据类型 {元素1,元素2,元素3…}；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态初始化：不指定长度，由系统猜</span></span><br><span class="line"><span class="comment">// 简写格式（推荐）</span></span><br><span class="line"><span class="type">int</span>[] c = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 完整格式</span></span><br><span class="line"><span class="type">int</span>[] ff = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h3><p><strong>动态初始化</strong>：指定数组长度</p><p><strong>格式</strong>：数据类型[] 数组名=new 数据类型[数组的长度]; </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态初始化：指定长度</span></span><br><span class="line"><span class="type">int</span>[] ff = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><h3 id="基本访问方式"><a href="#基本访问方式" class="headerlink" title="基本访问方式"></a>基本访问方式</h3><p>通过下标访问数组元素：</p><p>数组存放在JVM的堆中，是一片连续的存储空间，下标依次为0,1,2,3,4…</p><p>使用数组的索引（下标）来访问特定位置的元素。数组的索引从 0 开始，一直到数组长度减一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 访问索引为 2 的元素，即数组中的第三个元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> numbers[<span class="number">2</span>];         </span><br><span class="line">System.out.println(element);     <span class="comment">// 输出：3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用循环结构（如 for 或 foreach）遍历数组，访问每个元素</span></span><br><span class="line"><span class="comment">// 使用 for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    System.out.println(numbers[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 foreach 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高级访问方式：迭代器、Stream流、toString"><a href="#高级访问方式：迭代器、Stream流、toString" class="headerlink" title="高级访问方式：迭代器、Stream流、toString"></a>高级访问方式：迭代器、Stream流、toString</h3><p><strong>遍历：迭代器</strong></p><p>对于集合类（如 <code>ArrayList</code>），可以使用迭代器来访问元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历：Java 8 的 Stream</strong></p><p>使用 Java 8 引入的 Stream API 进行数组遍历和操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Stream.forEach</span></span><br><span class="line">Arrays.stream(numbers).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>打印全部：Arrays 类的 toString 方法</strong></p><p>使用 <code>Arrays</code> 类的 <code>toString</code> 方法将整个数组转换为字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 输出：[1, 2, 3, 4, 5]</span></span><br><span class="line">System.out.println(Arrays.toString(numbers));</span><br><span class="line"><span class="comment">// 直接输出数组会输出地址：[I@433c675d</span></span><br><span class="line">System.out.println(numbers);    </span><br></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>数组本身的方法很少，只有equals()、stream()等简单方法，一些对数组的高级操作，可将数组转为String或集合，操作后再转回数组。 </p><h3 id="数组和字符串的互相转换"><a href="#数组和字符串的互相转换" class="headerlink" title="数组和字符串的互相转换"></a><strong>数组和字符串的互相转换</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组转字符串：Arrays.toString(数组名)</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(numbers));</span><br><span class="line"><span class="comment">// 字符串转数组： stringToIntArray(String str)、stringToCharArray(String str)等</span></span><br><span class="line"><span class="comment">// 字符串转整型数组</span></span><br><span class="line"><span class="type">int</span>[] intArray = stringToIntArray(<span class="string">&quot;1 2 3 4 5&quot;</span>);</span><br><span class="line"><span class="comment">// 字符串转字符数组 </span></span><br><span class="line"><span class="type">char</span>[] charArray = stringToCharArray(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="数组和集合的互相转换"><a href="#数组和集合的互相转换" class="headerlink" title="数组和集合的互相转换"></a>数组和集合的互相转换</h3><ol><li><strong>数组转List</strong>：List<T> arrayToList(T[] array)</li><li><strong>List转数组</strong>：T[] listToArray(List<T> list, Class<T> elementType)</li><li><strong>数组转Set</strong>：Set<T> arrayToSet(T[] array)</li><li><strong>Set转数组：</strong>T[] setToArray(Set<T> set, Class<T> elementType)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 数组转List</span></span><br><span class="line">String[] array = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; listFromArray = Arrays.asList(array);</span><br><span class="line">System.out.println(<span class="string">&quot;List from Array: &quot;</span> + listFromArray);</span><br><span class="line"><span class="comment">// 2. List转数组</span></span><br><span class="line">List&lt;String&gt; fruitList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">String[] arrayFromList = fruitList.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;Array from List: &quot;</span> + Arrays.toString(arrayFromList));</span><br><span class="line"><span class="comment">// 3. List转Set</span></span><br><span class="line">Set&lt;String&gt; setFromList = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(fruitList);</span><br><span class="line">System.out.println(<span class="string">&quot;Set from List: &quot;</span> + setFromList);</span><br><span class="line"><span class="comment">// 4. Set转List</span></span><br><span class="line">Set&lt;String&gt; fruitSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Set.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">List&lt;String&gt; listFromSet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(fruitSet);</span><br><span class="line">System.out.println(<span class="string">&quot;List from Set: &quot;</span> + listFromSet);</span><br><span class="line"><span class="comment">// 5. Set转数组</span></span><br><span class="line">String[] arrayFromSet = fruitSet.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;Array from Set: &quot;</span> + Arrays.toString(arrayFromSet));</span><br><span class="line"><span class="comment">// 6. 数组转Set</span></span><br><span class="line">Set&lt;String&gt; setFromArray = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(array));</span><br><span class="line">System.out.println(<span class="string">&quot;Set from Array: &quot;</span> + setFromArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为集合后，可以通过集合的api操作各元素。例如：判断数组是否包含某个元素：</span></span><br><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEle</span> <span class="operator">=</span> Arrays.asList(array).contains(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(isEle);</span><br></pre></td></tr></table></figure><hr><h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>流程控制语句分类：</p><ul><li>顺序结构</li><li>分支结构（if、switch）</li><li>循环结构（for、while、do…while）</li></ul><h2 id="IF分支语句"><a href="#IF分支语句" class="headerlink" title="IF分支语句"></a>IF分支语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (关系表达式<span class="number">1</span>) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (关系表达式<span class="number">2</span>) &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句体n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程：</strong></p><ol><li>首先计算关系表达式1的值</li><li>如果值为true就执行语句体1；如果值为false就计算关系表达式2的值</li><li>如果值为true就执行语句体2；如果值为false就计算关系表达式3的值 …</li><li>如果没有任何关系表达式值为true就执行语句体n+1</li></ol><h2 id="switch分支语句"><a href="#switch分支语句" class="headerlink" title="switch分支语句"></a>switch分支语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        语句体<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        语句体<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句体n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">//最后一个可以省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>格式说明</strong>：</p><ol><li><p>表达式：取值为byte、short、int、char，JDK5以后可以是枚举，JDK7以后可以是String</p></li><li><p>case：后面跟的是要跟表达式比较的值</p></li><li><p>break：表示中断结束的意思，用来结束switch语句</p></li><li><p>default：表示所有情况都不匹配的时候，就执行该处内容，和if语句中的else相似</p></li></ol><p><strong>执行流程</strong>：</p><ol><li><p>首先计算表达式的值</p></li><li><p>以此和case后面的值进行比较，如果有对应值，就会执行相应语句，在执行过程中，遇到break就会结束</p></li><li><p>如果所有的case的值和表达式的值都不匹配，就会执行default里面的语句体，然后程序结束</p></li></ol><p>注意事项：在switch语句中，如果case控制的语句后面不写break，将会出现”穿透”现象。</p><hr><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><ul><li><code>public</code> : 对所有类可见。使用对象：类、接口、变量、方法</li><li><code>protected</code> : 对同包可见、对不同包子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li><li><code>default</code> : 同包可见。使用对象：类、接口、变量、方法。</li><li><code>private</code>: 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li></ul><table><thead><tr><th>修饰符</th><th>当前类</th><th>同一包内</th><th>子孙类(同一包)</th><th>子孙类(不同包)</th><th>其他包</th></tr></thead><tbody><tr><td><code>public</code></td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td><code>protected</code></td><td>Y</td><td>Y</td><td>Y</td><td>Y/N（<a href="https://www.runoob.com/java/java-modifier-types.html#protected-desc">说明</a>）</td><td>N</td></tr><tr><td><code>default</code></td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td><code>private</code></td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><p><strong>private</strong></p><p>在同一类内可见，保护成员不被别的类使用。可以修饰变量、方法。 注意：不能修饰类（外部类）</p><p>private变量不能被其他类直接访问，但可以通过get和set方法间接访问：</p><ol><li><code>get变量名()</code>方法：获取成员变量的值，方法用public修饰</li><li><code>set变量名(参数)</code>方法：设置成员变量的值，方法用public修饰</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="type">int</span> price; <span class="comment">// 成员变量在堆内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 或者用this</span></span><br><span class="line"><span class="comment">//    public void setAge(int age) &#123;</span></span><br><span class="line"><span class="comment">//        this.age = age;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        p.setAge(<span class="number">12</span>);</span><br><span class="line">        System.out.println(p.getAge());</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>静态成员变量被所有对象共享，可用类名调用。局部变量不能被声明为 static 变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> price;  <span class="comment">// 成员变量在堆内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        Phone.price=<span class="number">4</span>;</span><br><span class="line">        <span class="comment">//fun();会报错，静态方法只能访问静态方法或变量。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">fun</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态方法只能访问静态变量和方法。非静态方法都可以访问。</p><p>静态方法中不能使用 this 关键字，因为在静态方法的局部变量表中并不存在this变量。</p><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p><strong>static可以修饰什么？</strong></p><p>Java类中包含了成员变量、方法、构造器、初始化块和内部类（包括接口、枚举）5种成员。</p><p>static关键字可以修饰成员变量、方法、初始化块和内部类，<strong>不能修饰构造器</strong>。</p><p><strong>static访问规则</strong>：</p><p>被static修饰的成员先于对象存在，所以又称为类变量。</p><p>类成员不能访问实例成员，即静态不能访问非静态，静态中也没有this关键字。this是随着对象的创建存在的。</p><p><strong>类加载过程中类变量是怎样创建的？</strong></p><p>在类加载过程中的链接-准备阶段，JVM会给类变量赋零值，初始化阶段为类变量赋初值，执行静态代码块。</p><blockquote><p><strong>类加载过程：</strong>加载、链接（验证、准备、解析）、初始化。这个过程是在类加载子系统完成的。</p><p><strong>加载：</strong>生成类的Class对象。</p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流（即编译时生成的类的class字节码文件）</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。包括创建运行时常量池，将类常量池的部分符号引用放入运行时常量池。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类各种数据的访问入口。注意类的class对象是运行时生成的，类的class字节码文件是编译时生成的。</li></ol><p><strong>链接：</strong>将类的二进制数据合并到JRE中。该过程分为以下3个阶段：</p><ul><li><p><strong>验证</strong>：</p><p>确保代码符合JAVA虚拟机规范和安全约束。包括文件格式验证、元数据验证、字节码验证、符号引用验证。</p><ul><li><p><strong>文件格式验证</strong>：验证字节码文件是否符合规范。</p><ul><li><p><strong>魔数：</strong>是否魔数0xCAFEBABE开头</p></li><li><p><strong>版本号：</strong>版本号是否在JVM兼容范围</p><p><strong>常量类型：</strong>类常量池里常量类型是否合法</p><p><strong>索引值：</strong>索引值是否指向不存在或不符合类型的常量。</p></li></ul></li><li><p><strong>元数据验证</strong>：元数据是字节码里类的全名、方法信息、字段信息、继承关系等。</p><ul><li><strong>标识符：</strong>验证类名接口名标识符有没有符合规范</li><li><strong>接口实现方法：</strong>有没有实现接口的所有方法</li><li><strong>抽象类实现方法：</strong>有没有实现抽象类的所有抽象方法</li><li><strong>final类：</strong>是不是继承了final类。</li></ul></li><li><p><strong>指令验证</strong>：主要校验类的方法体，通过数据流和控制流分析，保证方法在运行时不会危害虚拟机安全。</p><ul><li>类型转换：保证方法体中的类型转换是否有效。例如把某个类强转成没继承关系的类</li><li>跳转指令：保证跳转指令不会跳转到方法体以外的字节码指令上；</li><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。</li></ul></li><li><p><strong>符号引用验证</strong>：确保后面解析阶段能正常执行。</p><ul><li><strong>类全限定名地址：</strong>验证类全限定名是否能找到对应的类字节码文件</li><li><strong>引用地址：</strong>引用指向地址是否存在实例</li><li><strong>引用权限：</strong>是否有权引用</li></ul></li></ul></li><li><p><strong>准备：</strong>为类变量（即static变量）分配内存并赋零值。</p></li><li><p><strong>解析：</strong>将方法区-运行时常量池内的符号引用（类的名字、成员名、标识符）转为直接引用（实际内存地址，不包含任何抽象信息，因此可以直接使用）。</p></li></ul><p><strong>初始化：</strong>类变量赋初值、执行静态语句块。</p></blockquote><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>一个类不能同时被 abstract 和 final 修饰，抽象类的唯一目的是为了将来对该类进行扩充。<br>抽象类可以包括抽象方法和非抽象方法，抽象方法只能存在于抽象类中。<br>非抽象子类必须重写抽象父类中的所有抽象方法，抽象子类可以直接继承。</p><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><p><strong>设计目的</strong>： </p><ul><li>接口作为系统与外界交互的窗口，体现了一种规范。它只能定义抽象方法及常量，而不允许存在初始化块、构造器、成员变量。</li><li>抽象类是系统中多个子类的共同父类，它体现了一种模板式设计，可被当作系统实现过程中的中间产品，必须要有更进一步的完善。</li></ul><p><strong>相同点</strong>：</p><ul><li><strong>实例化</strong>：接口和抽象类都不能被实例化,它们都位于继承树的顶端,用于被其它类实现和继承</li><li><strong>抽象方法</strong>：接口和抽象类都可以有抽象方法,实现接口或继承抽象类的普通子类都必须实现这些抽象方法</li><li><strong>静态方法：</strong>在JDK8引入接口静态方法后，接口和抽象类都可以有静态方法。</li></ul><p><strong>不同点</strong>：</p><ul><li><strong>普通方法</strong>：接口里只能包含抽象方法和默认方法,不能为普通方法提供方法实现；抽象类则可以包含普通方法。</li><li><strong>普通成员变量</strong>：接口里只能定义静态常量（会自动加static final，final常量必须显示的指定初始值），不能定义普通成员变量；抽象类里既可以定义普通成员变量,也可以定义静态常量</li><li><strong>构造器</strong>：接口里不包含构造器；抽象类可以包含构造器,但抽象类的构造器并不是用于创建对象,而是让其子类调用这些构造器来完成属于抽象类的初始化操作</li><li><strong>初始化块</strong>：接口里不能包含初始化块,抽象类则可以包含初始化块（静态代码块和实例代码块）</li><li><strong>单继承多实现</strong>：一个类最多能有一个父类，包括抽象类；但一个类可直接实现多个接口，通过实现多个接口可弥补Java单继承的不足</li></ul><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ol><li>final 变量必须显式指定初始值，不能被重新赋值（非final成员变量都会自动有默认值）。</li><li>final方法不能被子类重写。</li><li>final类不能被继承。</li><li>final引用不能变地址值，可以变地址内容。如<code>final M m=new M();m.age=12;</code>是正确，引用m始终指向对象M的内存地址。</li></ol><h1 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this指代当前对象的引用。通过this可以获取当前对象中的成员变量、方法。常可以用于方法的形参与成员变量同名时进行区分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 如果这个方法是static的，则会报错。</span></span><br><span class="line">    <span class="comment">// 因为this指向当前对象的引用，不是指向当前类的引用。static方法是类方法，类方法不创建对象就可以通过类名调用。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this指代构造方法的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造方法。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">//先执行一次带参构造方法</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;带参构造方法，年龄：&quot;</span>+age);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//带参构造方法创建对象</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p><strong>指代仅包括父类特征的当前对象的引用。可以看做是父类的引用。</strong></p><p>通过super可以获取当前对象的父对象的成员变量、方法。</p><p>以age变量为例，父类的age变量是3，子类的age变量是4，子类方法的age局部变量是5。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 吃东西方法的具体实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 子类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 输出5 访问上一行的局部变量</span></span><br><span class="line">         System.out.println(age);   </span><br><span class="line">        <span class="comment">// 输出4 通过this访问当前对象的成员变量age</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.age);</span><br><span class="line">        <span class="comment">// 输出3 通过super访问当前对象的父对象的成员变量age</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指代父类构造方法的调用</strong></p><p>通过super()，可以调用父类的各个构造方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 吃东西方法的具体实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物类带参构造方法&quot;</span>+name);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 睡觉方法的具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> age,String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的带参构造方法</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;带参构造方法&quot;</span>+age+<span class="string">&quot;,&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>,<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h2><p>this和super的区别： </p><ul><li>this 是当前对象的引用，super 是当前对象的父对象的引用。</li><li>this()是构造方法中调用本类其他的构造方法，super()是当前对象构造方法中去调用自己父类的构造方法。</li><li>静态中没有this和super关键字。this指向当前实例，super指向父类实例，是随着对象的创建存在的。</li></ul><p><strong>注意</strong>：子类所有无参、带参构造方法第一行都会隐式或显式地加super()。this()和super()方法不能显式的共存，但可以隐式的共存，且都只能显式地出现在构造方法的第一行。</p><ul><li>如果都不加，则系统会隐式加super()；</li><li>如果加super()或super(带参)，系统不会再隐式加super()；</li><li>如果加this()，则系统会隐式在this()前加super()；</li></ul>]]></content>
    
    
    <summary type="html">Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>定时任务</title>
    <link href="https://southernfish.github.io/2025/07/14/java/java-job/"/>
    <id>https://southernfish.github.io/2025/07/14/java/java-job/</id>
    <published>2025-07-14T06:18:36.000Z</published>
    <updated>2025-07-15T06:56:13.058Z</updated>
    
    <content type="html"><![CDATA[<p>定时任务在实际的开发中特别常见，比如电商平台 30 分钟后自动取消未支付的订单，以及凌晨的数据汇总和备份等，都需要借助定时任务来实现，本文记录了定时任务常见的几种实现方式。转载文章：<a href="https://cloud.tencent.com/developer/article/1686312">定时任务最简单的3种实现方法（Java）</a>、参考文章：<a href="https://blog.csdn.net/weixin_43192102/article/details/97885979">Java实现定时任务</a>、<a href="https://cloud.tencent.com/developer/article/1979863">Quartz 定时任务（Scheduler）的 3 种实现方式</a>，推荐文章：<a href="https://cloud.tencent.com/developer/article/2279210">任务调度框架Quartz（三）任务调度框架Quartz实例详解深入理解Scheduler,Job,Trigger,JobDetail</a></p><h1 id="Java-语言实现定时任务"><a href="#Java-语言实现定时任务" class="headerlink" title="Java 语言实现定时任务"></a>Java 语言实现定时任务</h1><p>在  Java  语言中，实现定时任务有几种常用的方法： </p><ol><li><code>java.util.Timer</code> 类：这是Java标准库提供的一个类，可以用来安排任务以后在后台线程中执行。使用 Timer 类，你可以创建一个 TimerTask 任务，然后使用 schedule 或 scheduleAtFixedRate 方法来安排任务的执行。</li><li><code>ScheduledExecutorService</code>  接口：这是Java并发包中的一部分，提供了更灵活的定时任务调度能力。你可以使用 Executors 类创建一个 ScheduledExecutorService 实例，然后使用 schedule 或 scheduleAtFixedRate 方法来安排任务。 </li><li>Spring框架的 <code>@Scheduled</code> 注解：如果你在使用Spring框架，可以利用 @Scheduled 注解来简化定时任务的配置。Spring的调度器会根据注解的参数来执行相应的方法。 </li><li><code>Quartz Scheduler</code>：这是一个开源的作业调度库，提供了比Java标准库更强大的定时任务功能。Quartz允许你配置复杂的调度策略，如cron表达式，并支持集群。</li></ol><h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>Timer 是 JDK 自带的定时任务执行类，无论任何项目都可以直接使用 Timer 来实现定时任务，所以 Timer 的优点就是使用方便.</p><h2 id="定时任务的实现代码"><a href="#定时任务的实现代码" class="headerlink" title="定时任务的实现代码"></a>定时任务的实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTimerTask</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123; <span class="comment">// 定义一个任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Run timerTask：&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(); <span class="comment">// 计时器</span></span><br><span class="line">        <span class="comment">// 添加执行任务（延迟 1s 执行，每 3s 执行一次）</span></span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Run timerTask：Mon Aug 17 21:29:25 CST 2020</span><br><span class="line">Run timerTask：Mon Aug 17 21:29:28 CST 2020</span><br><span class="line">Run timerTask：Mon Aug 17 21:29:31 CST 2020</span><br></pre></td></tr></table></figure><h2 id="Timer-缺点分析"><a href="#Timer-缺点分析" class="headerlink" title="Timer 缺点分析"></a>Timer 缺点分析</h2><h3 id="任务执行时间长影响其他任务"><a href="#任务执行时间长影响其他任务" class="headerlink" title="任务执行时间长影响其他任务"></a><strong>任务执行时间长影响其他任务</strong></h3><p>当一个任务的执行时间过长时，会影响其他任务的调度，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTimerTask</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123; <span class="comment">// 定义任务 1</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;进入 timerTask 1：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">// 休眠 5 秒</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;Run timerTask 1：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;  <span class="comment">// 定义任务 2</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Run timerTask 2：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(); <span class="comment">// 计时器</span></span><br><span class="line">        <span class="comment">// 添加执行任务（延迟 1s 执行，每 3s 执行一次）</span></span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">        timer.schedule(timerTask2, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">进入 timerTask 1：Mon Aug 17 21:44:08 CST 2020</span><br><span class="line">Run timerTask 1：Mon Aug 17 21:44:13 CST 2020</span><br><span class="line">Run timerTask 2：Mon Aug 17 21:44:13 CST 2020</span><br><span class="line">进入 timerTask 1：Mon Aug 17 21:44:13 CST 2020</span><br><span class="line">Run timerTask 1：Mon Aug 17 21:44:18 CST 2020</span><br><span class="line">进入 timerTask 1：Mon Aug 17 21:44:18 CST 2020</span><br><span class="line">Run timerTask 1：Mon Aug 17 21:44:23 CST 2020</span><br><span class="line">Run timerTask 2：Mon Aug 17 21:44:23 CST 2020</span><br><span class="line">进入 timerTask 1：Mon Aug 17 21:44:23 CST 2020</span><br></pre></td></tr></table></figure><p><strong>当任务 1 运行时间超过设定的间隔时间时，任务 2 也会延迟执行。</strong>原本任务 1 和任务 2 的执行时间间隔都是 3s，但因为任务 1 执行了 5s，因此任务 2 的执行时间间隔也变成了 10s（和原定时间不符）。</p><h3 id="任务异常影响其他任务"><a href="#任务异常影响其他任务" class="headerlink" title="任务异常影响其他任务"></a><strong>任务异常影响其他任务</strong></h3><p>使用 Timer 类实现定时任务时，当一个任务抛出异常，其他任务也会终止运行，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTimerTask</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123; <span class="comment">// 定义任务 1</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;进入 timerTask 1：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                <span class="comment">// 模拟异常</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">8</span> / <span class="number">0</span>;</span><br><span class="line">                log.info(<span class="string">&quot;Run timerTask 1：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123; <span class="comment">// 定义任务 2</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Run timerTask 2：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(); <span class="comment">// 计时器</span></span><br><span class="line">        <span class="comment">// 添加执行任务（延迟 1s 执行，每 3s 执行一次）</span></span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">        timer.schedule(timerTask2, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进入 timerTask 1：Mon Aug 17 22:02:37 CST 2020</span><br><span class="line">Exception in thread &quot;Timer-0&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">    at com.example.MyTimerTask$1.run(MyTimerTask.java:21)</span><br><span class="line">    at java.util.TimerThread.mainLoop(Timer.java:555)</span><br><span class="line">    at java.util.TimerThread.run(Timer.java:505)</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Timer 类实现定时任务的优点是方便，因为它是 JDK 自定的定时任务，但缺点是任务如果执行时间太长或者是任务执行异常，会影响其他任务调度，所以在生产环境下建议谨慎使用。</p><hr><h1 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h1><p>ScheduledExecutorService 也是 JDK 1.5 自带的 API，我们可以使用它来实现定时任务的功能，也就是说 ScheduledExecutorService 可以实现 Timer 类具备的所有功能，并且它可以解决了 Timer 类存在的所有问题。</p><h2 id="实现定时任务的代码"><a href="#实现定时任务的代码" class="headerlink" title="实现定时任务的代码"></a>实现定时任务的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyScheduledExecutorService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建任务队列</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span></span><br><span class="line">                Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123; <span class="comment">// 执行任务 1</span></span><br><span class="line">            log.info(<span class="string">&quot;进入 Schedule：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">// 休眠 5 秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;Run Schedule：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 1s 后开始执行，每 3s 执行一次</span></span><br><span class="line">        </span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123; <span class="comment">// 执行任务 2</span></span><br><span class="line">            log.info(<span class="string">&quot;Run Schedule2：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 1s 后开始执行，每 3s 执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Run Schedule：Mon Aug 17 21:44:23 CST 2020</span><br><span class="line">Run Schedule：Mon Aug 17 21:44:26 CST 2020</span><br><span class="line">Run Schedule：Mon Aug 17 21:44:29 CST 2020</span><br></pre></td></tr></table></figure><h2 id="可靠性测试"><a href="#可靠性测试" class="headerlink" title="可靠性测试"></a>可靠性测试</h2><h3 id="1、任务超时执行测试"><a href="#1、任务超时执行测试" class="headerlink" title="1、任务超时执行测试"></a>1、任务超时执行测试</h3><p>首先，测试当一个任务执行时间过长，会不会对其他任务造成影响，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyScheduledExecutorService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建任务队列</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span></span><br><span class="line">                Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123; <span class="comment">// 执行任务 1</span></span><br><span class="line">            log.info(<span class="string">&quot;进入 Schedule：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">// 休眠 5 秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;Run Schedule：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 1s 后开始执行，每 3s 执行一次</span></span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123; <span class="comment">// 执行任务 2</span></span><br><span class="line">            log.info(<span class="string">&quot;Run Schedule2：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 1s 后开始执行，每 3s 执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Run Schedule2：Mon Aug 17 11:27:55 CST 2020</span><br><span class="line">进入 Schedule：Mon Aug 17 11:27:55 CST 2020</span><br><span class="line">Run Schedule2：Mon Aug 17 11:27:58 CST 2020</span><br><span class="line">Run Schedule：Mon Aug 17 11:28:00 CST 2020</span><br><span class="line">进入 Schedule：Mon Aug 17 11:28:00 CST 2020</span><br><span class="line">Run Schedule2：Mon Aug 17 11:28:01 CST 2020</span><br><span class="line">Run Schedule2：Mon Aug 17 11:28:04 CST 2020</span><br></pre></td></tr></table></figure><p>测试结果：当任务 1 执行时间 5s 超过了执行频率 3s 时，并没有影响任务 2 的正常执行。 所以 ScheduledExecutorService 可以解决 Timer 任务之间相应影响的缺点</p><h3 id="2、任务异常测试"><a href="#2、任务异常测试" class="headerlink" title="2、任务异常测试"></a>2、任务异常测试</h3><p>其次，测试在一个任务异常时，是否会对其他任务造成影响，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyScheduledExecutorService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建任务队列</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span></span><br><span class="line">                Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123; <span class="comment">// 执行任务 1</span></span><br><span class="line">            log.info(<span class="string">&quot;进入 Schedule：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="comment">// 模拟异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">8</span> / <span class="number">0</span>;</span><br><span class="line">            log.info(<span class="string">&quot;Run Schedule：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 1s 后开始执行，每 3s 执行一次</span></span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123; <span class="comment">// 执行任务 2</span></span><br><span class="line">            log.info(<span class="string">&quot;Run Schedule2：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 1s 后开始执行，每 3s 执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入 Schedule：Mon Aug 17 22:17:37 CST 2020</span><br><span class="line">Run Schedule2：Mon Aug 17 22:17:37 CST 2020</span><br><span class="line">Run Schedule2：Mon Aug 17 22:17:40 CST 2020</span><br><span class="line">Run Schedule2：Mon Aug 17 22:17:43 CST 2020</span><br></pre></td></tr></table></figure><p>测试结果：当任务 1 出现异常时，并不会影响任务 2 的执行。 </p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>在单机生产环境下建议使用 ScheduledExecutorService 来执行定时任务，它是 JDK 1.5 之后自带的 API，因此使用起来也比较方便，并且使用 ScheduledExecutorService 来执行任务，不会造成任务间的相互影响。</p><hr><h1 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h1><p>如果使用的是 Spring 或 Spring Boot 框架，可以直接使用 Spring Framework 自带的定时任务，<strong>使用上面两种定时任务的实现方式，很难实现设定了具体时间的定时任务，比如当我们需要每周五来执行某项任务</strong>时，但如果使用 Spring Task 就可轻松的实现此需求。 以 Spring Boot 为例，实现定时任务只需两步： </p><h2 id="开启定时任务"><a href="#开启定时任务" class="headerlink" title="开启定时任务"></a>开启定时任务</h2><p>开启定时任务只需要在 Spring Boot 的启动类上声明  @EnableScheduling  即可，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 启用定时任务支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="comment">// do someing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加定时任务"><a href="#添加定时任务" class="headerlink" title="添加定时任务"></a>添加定时任务</h2><p>添加定时任务 定时任务的添加只需要使用  @Scheduled  注解标注即可，如果有多个定时任务可以创建多个  @Scheduled  注解标注的方法，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 把此类托管给 Spring，不能省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskUtils</span> &#123;</span><br><span class="line">    <span class="comment">// 添加定时任务</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;59 59 23 0 0 5&quot;)</span> <span class="comment">// cron 表达式，每周五 23:59:59 执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是定时任务~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：定时任务是自动触发的无需手动干预，也就是说 Spring Boot 启动后会自动加载并执行定时任务。 </p><h2 id="Cron表达式"><a href="#Cron表达式" class="headerlink" title="Cron表达式"></a><strong>Cron表达式</strong></h2><p>Spring Task 的实现需要使用 cron 表达式来声明执行的频率和规则，cron 表达式是由 6 位或者 7 位组成的（最后一位可以省略），每位之间以空格分隔，表达式语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[秒] [分] [小时] [日] [月] [周] [年]</span><br></pre></td></tr></table></figure><p>每位从左到右代表的含义如下表所示，其中<code>* 和 ?</code>号都表示匹配所有的时间。</p><table><thead><tr><th>字段</th><th>允许值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>秒(Seconds)</td><td>0~59的整数</td><td>, - * /                  四个字符</td></tr><tr><td>分(Minutes)</td><td>0~59的整数</td><td>, - * /                  四个字符</td></tr><tr><td>小时(Hours)</td><td>0~23的整数</td><td>, - * /                  四个字符</td></tr><tr><td>日期(DayofMonth)</td><td>1~31的整数(但是你需要考虑你月的天数)</td><td>, - * ? / L W C     八个字符</td></tr><tr><td>月份(Month)</td><td>1~12的整数或者 JAN-DEC</td><td>, - * /                   四个字符</td></tr><tr><td>星期(Dayofweek)</td><td>1~7的整数或者 SUN-SAT (1=SUN)</td><td>, - * ? / L C #       八个字符</td></tr><tr><td>年(可选，留空)(Year)</td><td>1970~2099</td><td>, - * /                    四个字符</td></tr></tbody></table><p>cron 表达式在线生成地址：<a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></p><h2 id="通配符说明"><a href="#通配符说明" class="headerlink" title="通配符说明"></a>通配符说明</h2><ol><li><code>*</code> 表示<strong>所有值</strong>。 例如:在分的字段上设置 *,表示每一分钟都会触发。</li><li><code>?</code> 表示<strong>不指定值</strong>。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ?</li><li><code>-</code> 表示<strong>区间</strong>。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。</li><li><code>,</code> 表示<strong>指定多个值</strong>，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发</li><li><code>/</code> 用于<strong>递增触发</strong>。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。</li><li><code>L</code> 表示<strong>最后</strong>的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五”</li><li><code>W</code> 表示<strong>离指定日期的最近那个工作日</strong>(周一至周五). 例如在日字段上置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)。</li><li><code>#</code> 序号(<strong>表示每月的第几个周几</strong>)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；小提示：’L’和 ‘W’可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即MON与mon相同。</li></ol><h2 id="常用Cron表达式"><a href="#常用Cron表达式" class="headerlink" title="常用Cron表达式"></a><strong>常用Cron表达式</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0/2 * * * * ?                         表示每2秒 执行任务</span><br><span class="line">0 0/2 * * * ?                         表示每2分钟 执行任务</span><br><span class="line">0 0 2 1 * ?                         表示在每月的1日的凌晨2点调整任务</span><br><span class="line">0 15 10 ? * MON-FRI                 表示周一到周五每天上午10:15执行作业</span><br><span class="line">0 15 10 ? 6L 2002-2006                 表示2002-2006年的每个月的最后一个星期五上午10:15执行作</span><br><span class="line">0 0 10,14,16 * * ?                     每天上午10点，下午2点，4点</span><br><span class="line">0 0/30 9-17 * * ?                     朝九晚五工作时间内每半小时</span><br><span class="line">0 0 12 ? * WED                        表示每个星期三中午12点</span><br><span class="line">0 0 12 * * ?                         每天中午12点触发</span><br><span class="line">0 15 10 ? * *                         每天上午10:15触发</span><br><span class="line">0 15 10 * * ?                         每天上午10:15触发</span><br><span class="line">0 15 10 * * ?                         每天上午10:15触发</span><br><span class="line">0 15 10 * * ? 2005                     2005年的每天上午10:15触发</span><br><span class="line">0 * 14 * * ?                         在每天下午2点到下午2:59期间的每1分钟触发</span><br><span class="line">0 0/5 14 * * ?                         在每天下午2点到下午2:55期间的每5分钟触发</span><br><span class="line">0 0/5 14,18 * * ?                     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</span><br><span class="line">0 0-5 14 * * ?                        在每天下午2点到下午2:05期间的每1分钟触发</span><br></pre></td></tr></table></figure><h2 id="cron表达式支持占位符"><a href="#cron表达式支持占位符" class="headerlink" title="cron表达式支持占位符"></a>cron表达式支持占位符</h2><p><strong>配置文件</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">time:</span></span><br><span class="line">  <span class="attr">cron:</span> <span class="string">*/5</span> <span class="string">*</span> <span class="string">*</span> <span class="string">*</span> <span class="string">*</span> <span class="string">*</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>主程序</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron=&quot;$&#123;time.cron&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">task1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 具体业务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scheduled(cron=&quot;*/$&#123;time.interval&#125; * * * * *&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">task2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 具体业务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p> <em><strong>zone</strong></em>：时区，接收一个<code>java.util.TimeZone</code>。<code>cron</code>表达式会基于该时区解析。默认是一个空字符串，即取服务器所在地的时区。比如我们一般使用的时区<code>Asia/Shanghai</code>。该字段一般留空。</p></li><li><p><strong>fixedDelay</strong>：上一次执行完毕时间点之后多长时间再执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedDelay = 5000)</span> <span class="comment">// 上一次执行完毕时间点之后5秒再执行</span></span><br></pre></td></tr></table></figure></li><li><p><em><strong>fixedDelayString</strong></em>：与 <code>fixedDelay</code> 意思相同，只是使用字符串的形式。唯一不同的是支持占位符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedDelayString = &quot;$&#123;time.fixedDelay&#125;&quot;)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>fixedRate</strong>：上一次开始执行时间点之后多长时间再执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedRate = 5000)</span> <span class="comment">// 上一次开始执行时间点之后5秒再执行</span></span><br></pre></td></tr></table></figure></li><li><p><strong>fixedRateString</strong>：与 <code>fixedRate</code> 意思相同，只是使用字符串的形式。唯一不同的是支持占位符。 </p></li><li><p><strong>initialDelay</strong>： 第一次延迟多长时间后再执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(initialDelay=1000, fixedRate=5000)</span> <span class="comment">// 第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次</span></span><br></pre></td></tr></table></figure></li><li><p><strong>initialDelayString</strong>： 与 <code>initiaDelay</code> 意思相同，只是使用字符串的形式。唯一不同的是支持占位符。</p></li></ol><hr><h1 id="Quartz-Scheduler"><a href="#Quartz-Scheduler" class="headerlink" title="Quartz Scheduler"></a>Quartz Scheduler</h1><p><code>Quartz Scheduler</code> 是一个开源的作业调度库，提供了比Java标准库更强大的定时任务功能。Quartz允许配置复杂的调度策略，如cron表达式，并支持集群。Spring boot 官网文档：<a href="https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/htmlsingle/#boot-features-quartz">Quartz Scheduler</a> ,推荐文章：<a href="https://blog.csdn.net/wangmx1993328/article/details/105057405">Quartz-scheduler 定时器概述、核心 API 与 快速入门</a></p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- quartz 定时任务调度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz-jobs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- quartz 定时器 https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-quartz --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实现方式一"><a href="#实现方式一" class="headerlink" title="实现方式一"></a>实现方式一</h2><ol><li><p>定义好定时任务的业务内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service(&quot;show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Show</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext arg0)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;\n\n-------------------------------\n It is running and the time is : &#123;&#125;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\n-------------------------------\n&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明定时任务，并关联业务实现类 。在 <code>JobDetail jb = JobBuilder.newJob(Show.class) </code>中关联业务类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service(&quot;schedulerTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.创建Scheduler的工厂</span></span><br><span class="line">            <span class="type">SchedulerFactory</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">            <span class="comment">// 2.从工厂中获取调度器实例</span></span><br><span class="line">            <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> sf.getScheduler();</span><br><span class="line">            <span class="comment">// 3.创建JobDetail</span></span><br><span class="line">            <span class="type">JobDetail</span> <span class="variable">jb</span> <span class="operator">=</span> JobBuilder.newJob(Show.class) <span class="comment">// Show 为一个job,是要执行的一个任务。</span></span><br><span class="line">                    .withDescription(<span class="string">&quot;这是我的测试定时任务。&quot;</span>) <span class="comment">// job的描述</span></span><br><span class="line">                    .withIdentity(<span class="string">&quot;jy2Job&quot;</span>, <span class="string">&quot;jy2Group&quot;</span>) <span class="comment">// job 的name和group</span></span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">// 任务运行的时间，SimpleSchedle类型触发器有效</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="number">3</span> * <span class="number">1000L</span>; <span class="comment">// 3秒后启动任务</span></span><br><span class="line">            <span class="type">Date</span> <span class="variable">statTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">            <span class="comment">// 4.创建Trigger</span></span><br><span class="line">            <span class="comment">// 使用SimpleScheduleBuilder或者CronScheduleBuilder</span></span><br><span class="line">            <span class="type">Trigger</span> <span class="variable">t</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                    .withDescription(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .withIdentity(<span class="string">&quot;jyTrigger&quot;</span>, <span class="string">&quot;jyTriggerGroup&quot;</span>)</span><br><span class="line">                    <span class="comment">//.withSchedule(SimpleScheduleBuilder.simpleSchedule())</span></span><br><span class="line">                    .startAt(statTime)  <span class="comment">// 默认当前时间启动 ,也可以写为：.startNow();</span></span><br><span class="line">                    .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/2 * * * * ?&quot;</span>)) <span class="comment">// 两秒执行一次</span></span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">// 5.注册任务和定时器</span></span><br><span class="line">            scheduler.scheduleJob(jb, t);</span><br><span class="line">            <span class="comment">// 6.启动 调度器</span></span><br><span class="line">            scheduler.start();</span><br><span class="line">            log.info(<span class="string">&quot;启动时间 ：&#123;&#125;&quot;</span> , <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;定时任务出现异常 ： &#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="实现方式二"><a href="#实现方式二" class="headerlink" title="实现方式二"></a>实现方式二</h2><ol><li><p>定义好定时任务的业务内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service(&quot;show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Show</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext arg0)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;\n\n-------------------------------\n It is running and the time is : &#123;&#125;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\n-------------------------------\n&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义好定时任务的触发类，调用业务类中的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSyncTask</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    Show show;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cronDepartmentsAndUsersJob</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;\n\n 定时--开始，当前时间： &#123;&#125;&quot;</span>, dateFormat().format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            show.execute(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JobExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;\n\n 定时--结束，当前时间：&#123;&#125;&quot;</span>, dateFormat().format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> SimpleDateFormat <span class="title function_">dateFormat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件中：配置触发类和任务执行频率</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:task</span>=<span class="string">&quot;http://www.springframework.org/schema/task&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定时任务触发类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userSyncTask&quot;</span> <span class="attr">class</span>=<span class="string">&quot;gentle.test.UserSyncTask&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--执行频率--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">task:scheduled-tasks</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--每 2 秒执行一次--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">&quot;userSyncTask&quot;</span> <span class="attr">method</span>=<span class="string">&quot;cronDepartmentsAndUsersJob&quot;</span> <span class="attr">cron</span>=<span class="string">&quot;0/2 * * * * ?&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="实现方式三"><a href="#实现方式三" class="headerlink" title="实现方式三"></a>实现方式三</h2><ol><li><p>引入 jar , 同上</p></li><li><p> 运行类，代码中给 2 个注解： </p></li></ol><p>   <code>@EnableScheduling</code>  // 开启定时器</p><p>   <code>@Scheduled(fixedDelay = 2000)</code>  或者 <code>@Scheduled(cron = &quot;* * 2 * * ?&quot;)</code>   // 每 2s 执行 1 次 。</p><ol start="3"><li> 代码：</li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gentle.util.DateUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 注册为一个bean</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 2000)</span> <span class="comment">// 每 2s 执行1次。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot; \n------------------------\n 定时任务内容 ：&#123;&#125;\n------------------------\n&quot;</span>,</span><br><span class="line">                    DateUtil.dateFormat().format(<span class="keyword">new</span> <span class="title class_">Date</span>()) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="拓展：分布式定时任务"><a href="#拓展：分布式定时任务" class="headerlink" title="拓展：分布式定时任务"></a>拓展：分布式定时任务</h1><p>以上都是关于单机定时任务的实现，如果是分布式环境可以使用 Redis 来实现定时任务。 使用 Redis 实现延迟任务的方法大体可分为两类：通过 ZSet 的方式和键空间通知的方式。</p><h2 id="ZSet-实现方式"><a href="#ZSet-实现方式" class="headerlink" title="ZSet 实现方式"></a>ZSet 实现方式</h2><p>通过 <code>ZSet</code> 实现定时任务的思路是，将定时任务存放到 ZSet 集合中，并且将过期时间存储到 ZSet 的 Score 字段中，然后通过一个无线循环来判断当前时间内是否有需要执行的定时任务，如果有则进行执行，具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_KEY</span> <span class="operator">=</span> <span class="string">&quot;myTaskQueue&quot;</span>; <span class="comment">// zset key</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">delayTime</span> <span class="operator">=</span> Instant.now().plusSeconds(<span class="number">30</span>).getEpochSecond(); <span class="comment">// 30s 后执行</span></span><br><span class="line">        jedis.zadd(_KEY, delayTime, <span class="string">&quot;order_1&quot;</span>);</span><br><span class="line">        <span class="comment">// 继续添加测试数据</span></span><br><span class="line">        jedis.zadd(_KEY, Instant.now().plusSeconds(<span class="number">2</span>).getEpochSecond(), <span class="string">&quot;order_2&quot;</span>);</span><br><span class="line">        jedis.zadd(_KEY, Instant.now().plusSeconds(<span class="number">2</span>).getEpochSecond(), <span class="string">&quot;order_3&quot;</span>);</span><br><span class="line">        jedis.zadd(_KEY, Instant.now().plusSeconds(<span class="number">7</span>).getEpochSecond(), <span class="string">&quot;order_4&quot;</span>);</span><br><span class="line">        jedis.zadd(_KEY, Instant.now().plusSeconds(<span class="number">10</span>).getEpochSecond(), <span class="string">&quot;order_5&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        doDelayQueue(jedis); <span class="comment">// 开启定时任务队列</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务队列消费  @param jedis Redis 客户端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doDelayQueue</span><span class="params">(Jedis jedis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Instant</span> <span class="variable">nowInstant</span> <span class="operator">=</span> Instant.now(); <span class="comment">// 当前时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">lastSecond</span> <span class="operator">=</span> nowInstant.plusSeconds(-<span class="number">1</span>).getEpochSecond(); <span class="comment">// 上一秒时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> nowInstant.getEpochSecond();</span><br><span class="line">            <span class="comment">// 查询当前时间的所有任务</span></span><br><span class="line">            Set&lt;String&gt; data = jedis.zrangeByScore(_KEY, lastSecond, nowSecond);</span><br><span class="line">            <span class="keyword">for</span> (String item : data) &#123;</span><br><span class="line">                <span class="comment">// 消费任务</span></span><br><span class="line">                log.info(<span class="string">&quot;消费：&#123;&#125;&quot;</span>, item);</span><br><span class="line">            &#125;</span><br><span class="line">            jedis.zremrangeByScore(_KEY, lastSecond, nowSecond); <span class="comment">// 删除已经执行的任务</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 每秒查询一次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="键空间通知"><a href="#键空间通知" class="headerlink" title="键空间通知"></a>键空间通知</h2><p>我们可以通过 Redis 的键空间通知来实现定时任务，它的实现思路是给所有的定时任务设置一个过期时间，等到了过期之后，我们通过订阅过期消息就能感知到定时任务需要被执行了，此时我们执行定时任务即可。 默认情况下 Redis 是不开启键空间通知的，需要我们通过  <code>config set notify-keyspace-events Ex</code>  的命令手动开启，开启之后定时任务的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPubSub;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_TOPIC</span> <span class="operator">=</span> <span class="string">&quot;__keyevent@0__:expired&quot;</span>; <span class="comment">// 订阅频道名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 执行定时任务</span></span><br><span class="line">        doTask(jedis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅过期消息，执行定时任务 @param jedis Redis 客户端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="comment">// 订阅过期消息</span></span><br><span class="line">        jedis.psubscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPMessage</span><span class="params">(String pattern, String channel, String message)</span> &#123;</span><br><span class="line">                <span class="comment">// 接收到消息，执行定时任务</span></span><br><span class="line">                log.info(<span class="string">&quot;收到消息：&#123;&#125;&quot;</span>, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, _TOPIC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定时任务部署-xxl-job"><a href="#定时任务部署-xxl-job" class="headerlink" title="定时任务部署 xxl-job"></a>定时任务部署 xxl-job</h1><h2 id="参考文章链接"><a href="#参考文章链接" class="headerlink" title="参考文章链接"></a><strong>参考文章链接</strong></h2><p>参考文章：<a href="https://blog.csdn.net/MinggeQingchun/article/details/142462738">SpringBoot整合Xxl-job实现定时任务</a>、<a href="https://blog.csdn.net/MinggeQingchun/article/details/141923978">Linux - Linux安装部署xxl-job</a>、<a href="https://blog.csdn.net/MinggeQingchun/article/details/129883009">Java – XXL-JOB分布式任务调度平台</a></p><p>XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 </p><p>单机并且定时任务不多时，可选择Timer注解@Scheduled或者Cron工具类等方式来实现，但是这时候定时任务会写死在代码中，一旦启动，就不能暂停或者修改。若需修改，整个项目都要重新编译。</p><h2 id="部署xxl-job调度中心"><a href="#部署xxl-job调度中心" class="headerlink" title="部署xxl-job调度中心"></a>部署xxl-job调度中心</h2><h3 id="（一）下载源码"><a href="#（一）下载源码" class="headerlink" title="（一）下载源码"></a>（一）<strong>下载源码</strong></h3><p>xxl-job 源码地址：<br><a href="https://github.com/xuxueli/xxl-job">GitHub - xuxueli/xxl-job: A distributed task scheduling framework.（分布式任务调度平台XXL-JOB）</a></p><p>2.4.1版本为例：<a href="https://github.com/xuxueli/xxl-job/archive/refs/tags/2.4.1.tar.gz">https://github.com/xuxueli/xxl-job/archive/refs/tags/2.4.1.tar.gz</a> </p><p>xxl-job 文档地址： <a href="https://www.xuxueli.com/xxl-job/">分布式任务调度平台XXL-JOB</a></p><h3 id="（二）初始化数据库"><a href="#（二）初始化数据库" class="headerlink" title="（二）初始化数据库"></a>（二）<strong>初始化数据库</strong></h3><p>找到 xxl-job 安装包<code>xxl-job-2.4.1/doc/db/</code>路径下的<code>tables_xxl_job.sql</code>文件，连接到mysql数据库，导入到mysql中</p><p> 执行 sql 脚本后，会生成以下8张表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xxl_job_group</span><br><span class="line">xxl_job_info</span><br><span class="line">xxl_job_lock</span><br><span class="line">xxl_job_log</span><br><span class="line">xxl_job_log_report</span><br><span class="line">xxl_job_logglue</span><br><span class="line">xxl_job_registry</span><br><span class="line">xxl_job_user</span><br></pre></td></tr></table></figure><h3 id="（三）修改配置文件"><a href="#（三）修改配置文件" class="headerlink" title="（三）修改配置文件"></a>（三）修改配置文件</h3><ol><li><p>修改server.port，服务端口号，修改数据库的URL和账号密码（xxl-job-admin 下的配置文件<code>application.properties</code>）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改成自己的服务端口号</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8666</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/xxl-job-admin</span></span><br><span class="line"><span class="comment"># 修改数据库的URL和账号密码</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql:127.0;0.1:3306/xxl_job?useUnicode=true</span></span><br><span class="line"><span class="attr">pring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure></li><li><p>然后打包（lifecycle → clean → package）上传，并运行jar包，使服务运行起来</p></li><li><p>测试：地址栏输入<a href="http://ip或者`域名:8666/xxl-job-admin/%60">http://IP或者`域名:8666/xxl-job-admin/`</a></p><p>xxl-job-admin Web界面的<strong>账号:admin 密码:123456</strong> （默认的情况）</p><p>因为账号密码默认在代码里写死了，可在<code>JobInfoControllerTest</code> 的<code>login</code>方法修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobInfoControllerTest</span> <span class="keyword">extends</span> <span class="title class_">AbstractSpringMvcTest</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(JobInfoControllerTest.class);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> Cookie cookie;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@BeforeEach</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">MvcResult</span> <span class="variable">ret</span> <span class="operator">=</span> mockMvc.perform(</span><br><span class="line">        post(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">            .contentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">            .param(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;admin&quot;</span>)</span><br><span class="line">            .param(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">    ).andReturn();</span><br><span class="line">    cookie = ret.getResponse().getCookie(LoginService.LOGIN_IDENTITY_KEY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="部署SpringBoot项目"><a href="#部署SpringBoot项目" class="headerlink" title="部署SpringBoot项目"></a>部署SpringBoot项目</h2><h3 id="（一）引入Maven依赖"><a href="#（一）引入Maven依赖" class="headerlink" title="（一）引入Maven依赖"></a>（一）引入Maven依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="（二）修改项目关于xxl-job的配置文件"><a href="#（二）修改项目关于xxl-job的配置文件" class="headerlink" title="（二）修改项目关于xxl-job的配置文件"></a>（二）修改项目关于xxl-job的配置文件</h3><p>在springboot项目的 application-dev.yml 配置文件中新增 xxl-job 配置信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Xxl-Job分布式定时任务调度中心</span></span><br><span class="line"><span class="attr">xxl:</span></span><br><span class="line">  <span class="attr">job:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="comment"># 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。 </span></span><br><span class="line">      <span class="attr">addresses:</span> <span class="string">http://localhost:8666/xxl-job-admin</span></span><br><span class="line">      <span class="comment"># addresses: http://IP:8666/xxl-job-admin</span></span><br><span class="line">    <span class="comment"># 执行器通讯TOKEN [选填]：非空时启用 系统默认 default_token</span></span><br><span class="line">    <span class="attr">accessToken:</span> <span class="string">default_token</span></span><br><span class="line">    <span class="attr">executor:</span></span><br><span class="line">      <span class="comment"># 执行器的应用名称</span></span><br><span class="line">      <span class="attr">appname:</span> <span class="string">test-xxl-job</span></span><br><span class="line">      <span class="comment"># 执行器注册 [选填]：优先使用该配置作为注册地址</span></span><br><span class="line">      <span class="attr">address:</span> </span><br><span class="line">      <span class="comment"># 执行器IP [选填]：默认为空表示自动获取IP</span></span><br><span class="line">      <span class="attr">ip:</span> </span><br><span class="line">      <span class="comment"># 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line">      <span class="comment"># 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span></span><br><span class="line">      <span class="attr">logpath:</span> <span class="string">D:\Codes\logs</span></span><br><span class="line">      <span class="comment">#logpath: /data/logs/mls/job</span></span><br><span class="line">      <span class="comment"># 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span></span><br><span class="line">      <span class="attr">logretentiondays:</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：若 <code>accessToken</code> 不设置最好注释掉，或输入xxl-job 默认的 <code>default_token</code> ，否则调用时易引起获取不到 token 的报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxl-job registry fail, registryParam:RegistryParam&#123;registryGroup=‘EXECUTOR’, registryKey=‘xxl-job-invoice-api’, registryValue=‘http:<span class="comment">//xx:9990/’&#125;, registryResult:ReturnT [code=500, msg=The access token is wrong., content=null]</span></span><br></pre></td></tr></table></figure><p><strong>另外需要注意的几个点</strong>：</p><ol><li><p><code>xxl.job.admin.address</code>是xxl-job-admin服务部署的IP地址</p></li><li><p>确认执行器的注册地址正确无误。检查两个地址是否均正确录入并与执行器实际部署的地址对应。</p></li><li><p>确认执行器的注册成功。可以在<code>xxl-job-admin</code>的”<strong>执行器管理</strong>“页面确认两个执行器均处于在线状态。</p></li><li><p>检查任务调度配置。在任务调度配置中，确保你的任务绑定了正确的执行器，并且任务的<code>JobHandler</code>名称与执行器中注册的<code>JobHandler</code>名称一致。</p><ul><li><p>在<code>xxl-job-admin</code>的”任务管理”页面，找到你的任务并编辑</p></li><li><p>在任务编辑页面的”基本设置”中，<strong>确认”任务路由策略”选择了”单一机器”或”故障转移”，</strong>以便指定任务绑定的执行器</p></li><li><p>在”GLUE类型”为Bean模式下，确保”<strong>JobHandler</strong>“字段的值与执行器中注册的 JobHandler 名称完全匹配</p></li></ul></li><li><p>检查执行器配置。在执行器部署的服务器上，确认<code>xxl.job.executor.appname</code>、<code>xxl.job.executor.address</code>和<code>xxl.job.executor.ip</code>等属性的配置与<code>xxl-job-admin</code>上的执行器配置一致</p><ul><li><p>确认执行器的appname与xxl-job-admin中的执行器配置相同</p></li><li><p>确认执行器的address和ip与xxl-job-admin中的执行器配置相同</p></li><li><p>执行器即SpringBoot项目中带有<code>@XxlJob(&quot;xxlJobTest&quot;)</code>注解</p></li><li><p>执行器的IP地址即SpringBoot项目中带有<code>@XxlJob(&quot;xxlJobTest&quot;)</code>注解部署服务的IP地址</p></li></ul></li></ol><h3 id="（三）创建配置类"><a href="#（三）创建配置类" class="headerlink" title="（三）创建配置类"></a>（三）创建配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（四）创建执行器"><a href="#（四）创建执行器" class="headerlink" title="（四）创建执行器"></a>（四）创建执行器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobTest</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;xxlJobTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">xxlJobTest</span><span class="params">(String date)</span> &#123;</span><br><span class="line">         log.info(<span class="string">&quot;---------xxlJobTest定时任务执行成功--------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过调度中心进行任务调度"><a href="#通过调度中心进行任务调度" class="headerlink" title="通过调度中心进行任务调度"></a>通过调度中心进行任务调度</h2><ol><li><p>执行器管理–新增执行器</p><p>根据 application-dev.yml 中 xxl-job 的配置，去填写appName，机器地址，自己命名执行器名称 。</p></li><li><p>任务管理–新增任务</p><p>执行器选择已经新增的执行器，调度类型选择<code>CRON</code>，选择或输入 cron 设置定时任务执行的频率；运行模式选择<code>BEAN</code>，JobHandler填写执行器方法上<code>@XxlJob</code>注解中的<code>value</code>值</p></li><li><p>任务调度中心发起任务调度</p><p>可以在任务管理列表每个任务的操作栏选择执行一次、启动，选择启动之后会按照配置的执行频率执行任务。</p></li></ol><h2 id="配置告警邮件通知"><a href="#配置告警邮件通知" class="headerlink" title="配置告警邮件通知"></a>配置告警邮件通知</h2><p>项目上线后，调度任务执行失败，当无告警信息时，只有再数据出现错误，进行问题定位和分析时，才会知道执行结果信息，每次出现问题，不能及时的知晓对于运维而言，很不友好。但<code>xxl-job</code>中具备这个能力，具体配置项参考下面详细信息。</p><p><code>xxl-job-admin</code>服务配置在<code>application.properties</code>中针对邮件告警配置项有如下信息：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### xxl-job, email</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.qq.com</span></span><br><span class="line"><span class="attr">spring.mail.port</span>=<span class="string">25</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">xxxx@qq.com</span></span><br><span class="line"><span class="attr">spring.mail.from</span>=<span class="string">xxxx@qq.com</span></span><br><span class="line"><span class="comment"># 这里需要注意一点： spring.mail.password 不是设置密码，是设置 **授权码**</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">xxxxx</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.auth</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.required</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.socketFactory.class</span>=<span class="string">javax.net.ssl.SSLSocketFactory</span></span><br></pre></td></tr></table></figure><p>这里的配置信息，是配置一个邮件发送方信息。也就是：出现告警信息时，邮件发送者。 在任务管理里面针对任务在<strong>报警邮件</strong>栏输入邮件地址，保存即可。</p>]]></content>
    
    
    <summary type="html">本文简单记录一些关于java中定时任务的问题。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="https://southernfish.github.io/2025/07/10/middleware/dubbo/"/>
    <id>https://southernfish.github.io/2025/07/10/middleware/dubbo/</id>
    <published>2025-07-10T08:11:36.000Z</published>
    <updated>2025-07-10T12:42:23.649Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo(读音[ˈdʌbəʊ])是阿里巴巴公司开源的一个高性能优秀的服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。 Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。本文参考文章：<a href="https://blog.csdn.net/huyuyang6688/article/details/76407440">Dubbo介绍、原理</a>、<a href="https://blog.csdn.net/weixin_45404884/article/details/137697450">Dubbo（从入门到掌握）看完这一篇就够了</a>、<a href="https://codeease.top/blog/pages/e8a5c9/">Dubbo两小时快速上手教程（直接代码、Spring、SpringBoot）</a>、<a href="https://cloud.tencent.com/developer/article/2021745?policyId=1004">从原理到选型，一文带你搞懂RPC</a>。</p><h1>Dubbo</h1><h2 id="什么是Dubbo">什么是Dubbo</h2><p>Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案，支持多种传输和序列化方案。Dubbo最常用的应用就是远程调用。 官网地址：<a href="http://dubbo.apache.org">http://dubbo.apache.org</a></p><p>Dubbo中<strong>服务端最核心的对象</strong>有四个：</p><ul><li><strong>ApplicationConfig</strong>：配置当前应用信息</li><li><strong>ProtocolConfig</strong>：配置提供服务的协议信息</li><li><strong>RegistryConfig</strong>：配置注册相关信息</li><li><strong>ServiceConfig</strong>：配置暴露的服务信息</li></ul><p>Dubbo<strong>客户端中核心的对象</strong>有两个：</p><ul><li><strong>ApplicationConfig</strong>：配置当前应用信息</li><li><strong>ReferenceConfig</strong>：配置引用的服务信息</li></ul><h2 id="核心部件">核心部件</h2><p><strong>Remoting</strong>：网络通信框架，实现了 <code>sync-over-async</code> 和 <code>request-response</code> 消息机制</p><p><strong>RPC</strong>：一个远程过程调用的抽象，支持负载均衡、容灾和集群功能</p><p><strong>Registry</strong>：服务目录框架用于服务的注册和服务事件发布和订阅</p><h2 id="Dubbo是为了解决什么问题">Dubbo是为了解决什么问题</h2><ul><li>当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。</li><li>当进一步发展，服务间依赖关系变得错踪复杂，分不清哪个应用要在哪个应用之前启动，架构师都不能完整描述应用的架构关系。</li><li>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</li></ul><hr><h1>Dubbo原理</h1><h2 id="架构">架构</h2><ol><li><p><strong>节点角色</strong></p><p><strong>Provider</strong>：暴露服务方称之为<strong>服务提供者</strong></p><p><strong>Consumer</strong>：调用远程服务方称之为<strong>服务消费者</strong></p><p><strong>Container</strong>：服务<strong>运行容器</strong></p><p><strong>Registry</strong>：服务注册与发现的中心目录服务称之为<strong>服务注册中心</strong></p><p><strong>Monitor</strong>：统计服务的调用次数和调用时间的日志服务称之为<strong>服务监控中心</strong></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250710175959362.png" alt="image-20250710175959362"></p></li><li><p><strong>工作过程</strong>（Dubbo服务启动，调用，暴露消费的过程）：</p><ul><li><strong>服务容器</strong>负责启动，加载，运行服务提供者。</li><li><strong>服务提供者</strong>在启动时，向注册中心注册自己提供的服务。</li><li><strong>服务消费者</strong>在启动时，向注册中心订阅自己所需的服务。</li><li><strong>注册中心</strong>返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者<ul><li><em>注册中心，服务提供者，服务消费者三者之间均为长连接</em>，监控中心除外。</li><li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者。</li><li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。</li></ul></li><li><strong>服务消费者</strong>，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li><strong>服务消费者和提供者</strong>，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul></li><li><p><strong>Dubbo层</strong>（10层）：</p><ul><li><strong>服务接口层</strong>（<code>Service</code>）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。</li><li><strong>配置层</strong>（<code>Config</code>）：对外配置接口，以<code>ServiceConfig</code>和<code>ReferenceConfig</code>为中心<ul><li>可以直接<code>new配置类</code>，也可以通过<code>spring解析配置</code>生成配置类。</li></ul></li><li><strong>服务代理层</strong>（<code>Proxy</code>）：负责服务注册与查询服务，以及注册服务的本地缓存。<ul><li>服务接口透明代理，生成服务的<code>客户端Stub</code>和<code>服务器端Skeleton</code>，以<code>ServiceProxy</code>为中心，扩展接口为<code>ProxyFactory</code>。</li></ul></li><li><strong>服务注册层</strong>（<code>Registry</code>）：负责生成消费者的代理对象和服务提供方的<code>Invoker</code>。<ul><li>封装服务地址的注册与发现,以服务URL为中心，扩展接口为<code>RegistryFactory、Registry和RegistryService</code>。</li><li>可能没有服务注册中心，此时服务提供方直接暴露服务。</li></ul></li><li><strong>集群层</strong>（<code>Cluster</code>）：负责负载均衡的策略，以及失败的策略。<ul><li>封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为<code>Cluster、Directory、Router和LoadBalance</code>。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。</li></ul></li><li><strong>监控层</strong>（<code>Monitor</code>）：RPC调用次数和调用时间监控，以<code>Statistics</code>为中心，扩展接口为<code>MonitorFactory、Monitor和MonitorService</code>。</li><li><strong>远程调用层</strong>（<code>Protocol</code>）：封将RPC调用，支持多种RPC协议（不包含IO通信部分）。以<code>Invocation和Result</code>为中心，扩展接口为<code>Protocol、Invoker和Exporter</code>。<ul><li><code>Protocol</code>是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。</li><li><code>Invoker</code>是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</li></ul></li><li><strong>信息交换层</strong>（<code>Exchange</code>）：封装请求响应模式，同步转异步。<ul><li>处理各种协议的通信请求，支持<code>netty、mina、http</code>等，默认采用<code>netty</code>进行通信。</li><li>以<code>Request和Response</code>为中心，扩展接口为<code>Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer</code>。</li></ul></li><li><strong>网络传输层</strong>（<code>Transport</code>）：抽象<code>mina和netty</code>为统一接口，以Message为中心，扩展接口为<code>Channel、Transporter、Client、Server和Codec</code>。</li><li><strong>数据序列化层</strong>（<code>Serialize</code>）：数据序列化层和可复用的一些工具，dubbo 协议缺省为 hessian2，rmi 缺省为 java，http 缺省为 json。扩展接口为<code>Serialization、 ObjectInput、ObjectOutput和ThreadPool</code>。</li></ul></li></ol><h2 id="启动时检查">启动时检查</h2><ul><li>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=“true”。</li><li>可以通过 check=“false” 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。</li><li>另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=“false”，总是会返回引用，当服务恢复时，能自动连上。</li></ul><h2 id="集群容错">集群容错</h2><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250710180009155.png" alt="image-20250710180009155"></p><h3 id="各节点的关系">各节点的关系</h3><ol><li><code>Invoker</code> 是 Provider 的一个可调用 Service 的抽象，Invoker 封装了 Provider 地址及 Service 接口信息。</li><li><code>Directory</code> 代表多个 Invoker，可以把它看成 List ，但与 List 不同的是，它的值可能是<strong>动态变化</strong>的，比如注册中心推送变更。</li><li><code>Cluster</code> 将 Directory 中的多个 Invoker 伪装成一个 Invoker，对上层透明，伪装过程<strong>包含了容错逻辑</strong>，调用失败后重试另一个。</li><li><code>Router</code> 负责从多个 Invoker 中<strong>按路由规则选出子集</strong>，比如读写分离，应用隔离等。</li><li><code>LoadBalance</code> 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程<strong>包含了负载均衡算法</strong>，调用失败后，需要重选。</li></ol><h3 id="集群容错模式">集群容错模式</h3><ol><li><p>**Failover Cluster：**失败自动切换（默认），当出现失败，重试其它服务器。</p><p>通常用于<strong>读操作</strong>，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。由<code>FailoverClusterInvoker</code>实现，原理是先获得retries的值，再通过for循环依次调用服务，如果成功则返回，如果失败则循环调用直至循环结束。</p></li><li><p>**Failfast Cluster：**快速失败，只发起一次调用，失败立即报错。</p><p>通常用于<strong>非幂等性的写操作</strong>，比如新增记录。由<code>FailfastClusterInvoker</code>实现，原理是直接调用一次。</p></li><li><p>**Failsafe Cluster：**失败安全，出现异常时，直接忽略。</p><p>通常用于<strong>写入审计日志等操作</strong>。由<code>FailsaveClusterInvoker</code>实现。</p></li><li><p>**Failback Cluster：**失败自动恢复，后台记录失败请求，定时重发。</p><p>通常用于<strong>消息通知操作</strong>。由<code>FailbackClusterInvoker</code>实现，原理是，执行调用，出现异常后把错误放入<code>ConcurrentHashMap</code>，用任务调度线程池延迟5秒来重新执行调用，如果再失败，记录日志，不再调用。</p></li><li><p>**Forking Cluster：**并行调用多个服务器，只要一个成功即返回。</p><p>通常用于<strong>实时性要求较高的读操作</strong>，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。</p></li><li><p>**Broadcast Cluster：**广播调用所有提供者，逐个调用，任意一台报错则报错。</p><p>通常用于<strong>通知所有提供者</strong>更新缓存或日志等本地资源信息。</p></li></ol><h2 id="负载均衡">负载均衡</h2><p>（1）<strong>随机</strong>（<code>Random LoadBalance</code>）按照权重设置随机概率（默认）。<br>（2）<strong>轮询</strong>（<code>RoundRobin LoadBalance</code>）<br>（3）<strong>最少活跃调用数</strong>（<code>LeastActive LoadBalance</code>），相同活跃调用数的随机<br>（4）<strong>一致性Hash</strong>（<code>ConsistencyHash LoadBalance</code>）一致性Hash，相同参数的请求总是发到同一提供者</p><h2 id="多协议">多协议</h2><p>Dubbo 允许配置多协议，在不同服务上或者同一服务上同时支持多种协议。</p><ol><li><p>在不同服务上支持不同协议<br>不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;world&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;registry&quot;</span> <span class="attr">address</span>=<span class="string">&quot;10.20.141.150:9090&quot;</span> <span class="attr">username</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">password</span>=<span class="string">&quot;hello1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多协议配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;rmi&quot;</span> <span class="attr">port</span>=<span class="string">&quot;1099&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用dubbo协议暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;dubbo&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用rmi协议暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.hello.api.DemoService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;rmi&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在同一服务上支持多种协议<br>需要与 http 客户端互操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;world&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;registry&quot;</span> <span class="attr">address</span>=<span class="string">&quot;10.20.141.150:9090&quot;</span> <span class="attr">username</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">password</span>=<span class="string">&quot;hello1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多协议配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;hessian&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用多个协议暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;dubbo,hessian&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th>协议</th><th>稳定性</th><th>优点</th><th>缺点</th><th>建议</th></tr></thead><tbody><tr><td>Dubbo协议</td><td>Stable</td><td>采用NIO复用单一长连接，并使用线程池并发处理请求，减少握手和加大并发效率，性能较好（推荐使用）</td><td>在大文件传输时，单一连接会成为瓶颈</td><td>可用于生产环境</td></tr><tr><td>Rmi协议</td><td>Stable</td><td>可与原生RMI互操作，基于TCP协议</td><td>偶尔会连接失败，需重建Stub</td><td>可用于生产环境</td></tr><tr><td>Hessian协议</td><td>Stable</td><td>可与原生Hessian互操作，基于HTTP协议</td><td>需hessian.jar支持，http短连接的开销大</td><td>可用于生产环境</td></tr></tbody></table><p>此外还支持webservice、http、Thrift、memcached、redis、rest等协议。</p><h2 id="Dubbo序列化">Dubbo序列化</h2><table><thead><tr><th>协议</th><th>稳定性</th><th>优点</th><th>缺点</th><th>建议</th></tr></thead><tbody><tr><td>Hessian Serialization</td><td>Stable</td><td>性能较好，多语言支持（推荐使用）</td><td>Hessian的各版本兼容性不好，可能和应用使用的Hessian冲突，Dubbo内嵌了hessian3.2.1的源码</td><td>可用于生产环境</td></tr><tr><td>Dubbo Serialization</td><td>Stable</td><td>通过不传送POJO的类元信息，在大量POJO传输时，性能较好</td><td>当参数对象增加字段时，需外部文件声明</td><td>试用</td></tr><tr><td>Json Serialization</td><td>Stable</td><td>纯文本，可跨语言解析，缺省采用FastJson解析</td><td>性能较差</td><td>试用</td></tr><tr><td>Java Serialization</td><td>Stable</td><td>Java原生支持</td><td>性能较差</td><td>可用于生产环境</td></tr></tbody></table><h2 id="注册中心">注册中心</h2><p>Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。另外，注册中心是支持自定义扩展的。</p><table><thead><tr><th>协议</th><th>稳定性</th><th>优点</th><th>缺点</th><th>建议</th></tr></thead><tbody><tr><td>Zookeeper注册中心</td><td>Stable</td><td>支持基于网络的集群方式，有广泛周边开源产品，建议使用dubbo-2.3.3以上版本（推荐使用）</td><td>依赖于Zookeeper的稳定性</td><td>可用于生产环境</td></tr><tr><td>Redis注册中心</td><td>Stable</td><td>支持基于客户端双写的集群方式，性能高</td><td>要求服务器时间同步，用于检查心跳过期脏数据</td><td>可用于生产环境</td></tr><tr><td>Multicast注册中心</td><td>Tested</td><td>去中心化，不需要安装注册中心</td><td>依赖于网络拓扑和路由，跨机房有风险</td><td>小规模应用或开发测试环境</td></tr><tr><td>Simple注册中心</td><td>Tested</td><td>Dogfooding，注册中心本身也是一个标准的RPC服务</td><td>没有集群支持，可能单点故障</td><td>试用</td></tr></tbody></table><h2 id="Dubbo服务降级">Dubbo服务降级</h2><p>可以通过服务降级功能 临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。<br>服务降级就是当服务响应超时或连接请求超时，不用继续等下去，而采用降级措施，返回一个我们自己定义好的提示。而为什么要使用服务降级，这是防止分布式服务发生雪崩效应。当一个请求发生超时，一直等待着服务响应，那么在高并发情况下，很多请求都是因为这样一直等着响应，直到服务资源耗尽产生宕机，而宕机之后会导致分布式其他服务调用该宕机的服务也会出现资源耗尽宕机，这样下去将导致整个分布式服务都瘫痪。集群环境下，当一台服务宕机之后，其他流量分发到其他集群机器上，压力也会随之加大，时间久了整个集群也会垮了，这只是个时间问题。为了防止产生了雪崩效应那么就该对服务配置降级，一旦请求超过规定时间立即返回自定义好的提示，无需继续等待。<br>dubbo中有提供一个叫做mock的配置，mock只在出现非业务异常(比如超时，网络异常等)时执行。mock的配置支持两种：<br>（1）采用return null,返回简单的空<br>打开项目里的consumer.xml修改dubbo:reference配置即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.cwh.service.UserService&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;3000&quot;</span> <span class="attr">mock</span>=<span class="string">&quot;return null&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在服务提供者例如UserServiceImpl中的getUser方法打个断点来模拟请求超时。然后浏览器访问，断点不过，一致等待，当时间超过3秒，直接返回了空，这样就已经实现了一个简单的服务降级了<br>（2）采用自定义提示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.cwh.service.UserService&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;3000&quot;</span> <span class="attr">mock</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在service包下也就是同UserService目录下新建一个UserServiceMock，注意这里名字一点要是该接口名+Mock：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceMock</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt;getUser(String name)&#123;</span><br><span class="line">        <span class="comment">//throw new RuntimeException(&quot;服务降级-----&quot;);</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserName(<span class="string">&quot;服务降级啦&quot;</span>);</span><br><span class="line">        user.setUserAge(<span class="string">&quot;500&quot;</span>);</span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">        list.add(user);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dubbo灰度发布">Dubbo灰度发布</h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用，用法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.dubbo.demo.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>利用dubbo该特性，我们能够实现一些功能的灰度发布，实现步骤如下：</p><ol><li>接口旧的实现定义version=“1.0.0”，接口新的实现version=“2.0.0”</li><li>Consumer端定义version=“*”</li><li>这样定义Provider和Consumer后，新旧接口实现各承担50%的流量</li><li>利用dubbo该特性，还能完成不兼容版本迁移：<ol><li>在低压力时间段，先升级一半Provider为新版本；</li><li>再将所有消费者升级为新版本；</li><li>然后将剩下的一半提供者升级为新版本。</li></ol></li></ol><h2 id="Dubbo异步调用">Dubbo异步调用</h2><p>默认是同步等待结果阻塞的，支持异步调用。通过<code>asyanc</code>属性设置异步，若设置异步，则无需等待该方法返回值，程序即可往下进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Methoda();</span><br><span class="line">Sysout(o);</span><br><span class="line">Methodb();</span><br></pre></td></tr></table></figure><p>(1) 打印结果为null     (2) Timeout不会超时，所以不会重试</p><p>Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。异步调用流程图如下：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250710180027041.png" alt="image-20250710180027041"></p><hr><h1>Dubbo实践</h1><h2 id="Dubbo快速入门">Dubbo快速入门</h2><ol><li>创建服务提供者<code>Provider</code>模块</li><li>创建服务消费者<code>Consumer</code>模块</li><li>在服务提供者模块编写<code>UserServiceImpl</code>提供服务</li><li>在服务消费者中的<code>UserController</code>远程调用<code>UserServiceImpl</code>提供的服务</li><li>分别启动两个服务，测试</li></ol><h2 id="企业中如何通过Dubbo实现分布式调用">企业中如何通过Dubbo实现分布式调用</h2><p>在企业中，如果消费者直接通过RPC去调用提供者，理论上需要把提供者的整个Jar包引入到项目中。但是这样的话服务提供这种的其他无关代码也会被引入其中，导致代码污染。</p><p>因此实际开发过程中，服务提供者和调用者之间会增加一层Client模块。这个Client中主要写的是Service的接口定义，接口的返回实例对象以及接口的请求实例对象。简单来讲，所有的定义都在Client中完成。 使用时，服务提供者引入这个Client，然后写实现方法，服务消费者引入这个Client，然后通过dubbo直接调用即可。</p><p>另外企业开发中，可能会出现多个接口实现，这种情况下可以给Service设定group、version等进行区分。</p><h2 id="dubbo-client-模块">dubbo-client 模块</h2><p>定义一个<strong>公共的客户端服务</strong>，命名为<code>dubbo-client</code>，这个服务里存放的是service接口，整体代码结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dubbo-client</span><br><span class="line">    src</span><br><span class="line">        main</span><br><span class="line">            java</span><br><span class="line">                entity</span><br><span class="line">                    User</span><br><span class="line">                service</span><br><span class="line">                    UserService(interface)</span><br><span class="line">            resources</span><br><span class="line">                application.yml</span><br></pre></td></tr></table></figure><p>UserService接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    User <span class="title function_">getUser</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义User类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">9206514891359830486L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dubbo-provider-模块">dubbo-provider 模块</h2><p>服务提供者引入 dubbo-client 工程，写实现类，提供dubbo接口，见后文配置文件编写。</p><p>服务提供者需要写服务的实现类，这里需要注意**@Service注解采用的是dubbo包下**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.javayz.client.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.javayz.client.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setName(<span class="string">&quot;javayz&quot;</span>);</span><br><span class="line">        user.setSex(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在启动类上添加一个<code>@EnableDubbo</code>注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootproviderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootproviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dubbo-consumer-模块">dubbo-consumer 模块</h2><p>服务消费者引入 dubbo-client 工程，通过这个工程的service接口调用，见后文配置文件编写。</p><p>服务的消费者同样是先编辑好配置文件，如上，接着通过**@Reference注解将service对象引进来**:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootconsumerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootconsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ApplicationRunner <span class="title function_">getBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            System.out.println(userService.getUser(<span class="number">1L</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="provider-与-consumer-配置文件">provider 与 consumer 配置文件</h2><h3 id="pom-xml">pom.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入项目 dubbo-client --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.javayz<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 zookeeper --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!-- 引入 dubbo --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SpringBoot方式">SpringBoot方式</h3><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">dubbo-provider</span></span><br><span class="line"><span class="comment"># 若是替换成消费者 dubbo-consumer</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.protocol.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">20880</span></span><br></pre></td></tr></table></figure><p>或者 application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span>   <span class="comment"># 自己的zookeeper服务器的IP:默认端口号</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-zookeeper-producer1</span> <span class="comment"># 注册进去的名字 服务提供者</span></span><br><span class="line">    <span class="comment"># name: dubbo-zookeeper-consumer1 # 若是消费者替换成dubbo-zookeeper-consumer1</span></span><br><span class="line">  <span class="attr">protocol:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo</span>     <span class="comment"># 设置类型</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">-1</span>      <span class="comment"># 因为dubbo的服务器端口号是不能唯一的，所以，设置为-1会帮我们自动改变端口号</span></span><br><span class="line">  <span class="attr">config-center:</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">120000</span>  <span class="comment"># 超时时间  （毫秒）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line">  <span class="comment"># port: 8083  # 若是消费者替换成8083</span></span><br></pre></td></tr></table></figure><h3 id="Spring方式">Spring方式</h3><p>在resource文件夹下新建两个配置文件： provider.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;sample-provider&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用zookeeper广播注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://192.168.78.128:2181&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.javayz.client.service.UserService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javayz.example1.service.impl.UserServiceImpl&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>consumer.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;sample-consumer&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://192.168.78.128:2181&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.javayz.client.service.UserService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着是服务的提供者和消费者配置注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务提供者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDubboProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;provider.xml&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务已经暴露&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDubboConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;consumer.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        System.out.println(bean.getUser(<span class="number">1L</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dubbo的常用配置">dubbo的常用配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span>/&gt;</span> 用于配置当前应用信息</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:register</span>/&gt;</span> 用于配置连接注册相关信息</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span>/&gt;</span> 用于配置提供服务的协议信息，提供者指定协议，消费者被动接受</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span>/&gt;</span> 用于暴露一个服务，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span>/&gt;</span> 当ProtocolConfig和ServiceConfig某属性没有配置时，采用此缺省值</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span>/&gt;</span> 当ReferenceConfig某属性没有配置时，采用此缺省值</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span>/&gt;</span> 用于创建一个远程服务代理</span><br></pre></td></tr></table></figure><h2 id="直接代码">直接代码</h2><h3 id="引入依赖">引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.javayz<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 若使用注册中心，以zookeeper为例，需引入zookeeper相关依赖： zk客户端依赖：curator --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写服务提供者">编写服务提供者</h3><p>服务提供者主要配置以下几个属性：</p><ol><li><strong><code>application</code></strong>：设置应用的名称等信息</li><li><strong><code>protocol </code></strong>：设置服务的协议</li><li><strong><code>register</code></strong>：设置服务的连接方式</li><li><strong><code>service</code></strong>：将需要暴露的服务注册出来</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//暴露UserService服务</span></span><br><span class="line">        <span class="comment">//1、application</span></span><br><span class="line">        ApplicationConfig applicationConfig=<span class="keyword">new</span> <span class="title class_">ApplicationConfig</span>(<span class="string">&quot;sample-provider&quot;</span>);</span><br><span class="line">        <span class="comment">//2、protocol -dubbo协议</span></span><br><span class="line">        <span class="type">ProtocolConfig</span> <span class="variable">protocolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolConfig</span>();</span><br><span class="line">        protocolConfig.setName(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">        protocolConfig.setPort(<span class="number">20880</span>);</span><br><span class="line">        <span class="comment">//3、register</span></span><br><span class="line">        <span class="comment">//直连的方式，不暴露到注册中心</span></span><br><span class="line">        RegistryConfig registryConfig=<span class="keyword">new</span> <span class="title class_">RegistryConfig</span>(RegistryConfig.NO_AVAILABLE);</span><br><span class="line">        <span class="comment">//通过注册中心暴露dubbo</span></span><br><span class="line">        RegistryConfig registryConfig=<span class="keyword">new</span> <span class="title class_">RegistryConfig</span>(<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>); </span><br><span class="line">        <span class="comment">//4、service</span></span><br><span class="line">        ServiceConfig serviceConfig=<span class="keyword">new</span> <span class="title class_">ServiceConfig</span>();</span><br><span class="line">        serviceConfig.setInterface(UserService.class);</span><br><span class="line">        serviceConfig.setRef(<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>());</span><br><span class="line">        <span class="comment">//5、将application、protocol、register注册到service</span></span><br><span class="line">        serviceConfig.setRegistry(registryConfig);</span><br><span class="line">        serviceConfig.setProtocol(protocolConfig);</span><br><span class="line">        serviceConfig.setApplication(applicationConfig);</span><br><span class="line">        serviceConfig.export();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务已经暴露&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写服务消费者">编写服务消费者</h3><p>消费者的实现主要就三步：</p><ol><li>**配置<code>application</code>：**设置应用的名称等信息</li><li>**配置<code>reference</code>：**主要配置要引用的信息</li><li>获取到接口，调用服务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1、application</span></span><br><span class="line">        ApplicationConfig applicationConfig=<span class="keyword">new</span> <span class="title class_">ApplicationConfig</span>(<span class="string">&quot;sample-consumer&quot;</span>);</span><br><span class="line">        <span class="comment">//2、配置reference</span></span><br><span class="line">        ReferenceConfig referenceConfig=<span class="keyword">new</span> <span class="title class_">ReferenceConfig</span>();</span><br><span class="line">        referenceConfig.setApplication(applicationConfig);</span><br><span class="line">        referenceConfig.setInterface(UserService.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// referenceConfig.setUrl(&quot;dubbo://172.18.2.49:20880/com.javayz.client.service.UserService?anyhost=true&amp;application=sample&amp;bind.ip=172.18.2.49&amp;bind.port=20880&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=com.javayz.client.service.UserService&amp;methods=getUser&amp;pid=5936&amp;release=2.7.4.1&amp;side=provider&amp;timestamp=1618036935244&quot;);</span></span><br><span class="line">        <span class="comment">// 或者 将referenceConfig中的setUrl方法替换为zookeeper</span></span><br><span class="line">        RegistryConfig registryConfig=<span class="keyword">new</span> <span class="title class_">RegistryConfig</span>(<span class="string">&quot;zookeeper://192.168.78.128:2181&quot;</span>);</span><br><span class="line">        referenceConfig.setRegistry(registryConfig);</span><br><span class="line">        </span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) referenceConfig.get();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUser(<span class="number">1L</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动提供者，再启动消费者，如果user信息打印出来了就说明调用成功。</p><h1>Dubbo &amp; Spring Cloud</h1><h2 id="Dubbo特点">Dubbo特点</h2><ul><li><strong>远程通讯</strong>：提供对多种基于长连接的 NIO 框架抽象封装（非阻塞 I/O 的通信方式，Mina/Netty/Grizzly），包括多种线程模型，序列化（Hessian2/ProtoBuf），以及“请求-响应”模式的信息交换方式。</li><li><strong>集群容错</strong>：提供基于接口方法的透明远程过程调用（RPC），包括多协议支持（自定义 RPC 协议），以及软负载均衡（Random/RoundRobin），失败容错（Failover/Failback），地址路由，动态配置等集群支持。</li><li><strong>自动发现</strong>：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ul><h2 id="Spring-Cloud">Spring Cloud</h2><p>Spring Cloud 基于 Spring Boot，为微服务体系开发中的架构问题，提供了一整套的解决方案——服务注册与发现，服务消费，服务保护与熔断，网关，分布式调用追踪，分布式配置管理等。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/3e222e0786824db289336b44de42cb1.png" alt="3e222e0786824db289336b44de42cb1"></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/df9a39637a9f01e8fb2d0e6cc490967.png" alt="df9a39637a9f01e8fb2d0e6cc490967"></p><h2 id="Dubbo-vs-Spring-Cloud">Dubbo vs Spring Cloud</h2><table><thead><tr><th></th><th>Dubbo</th><th>Spring Cloud</th></tr></thead><tbody><tr><td>服务注册中心</td><td>Zookeeper</td><td>Spring Cloud Netflix Eureka</td></tr><tr><td>服务调用方式</td><td>RPC</td><td>REST API</td></tr><tr><td>服务监控</td><td>Dubbo-monitor</td><td>Spring Boot Admin</td></tr><tr><td>断路器</td><td>不完善</td><td>Spring Cloud Netflix Hystrix</td></tr><tr><td>服务网关</td><td>无</td><td>Spring Cloud Netflix Zuul</td></tr><tr><td>分布式配置</td><td>无</td><td>Spring Cloud Config</td></tr><tr><td>服务跟踪</td><td>无</td><td>Spring Cloud Sleuth</td></tr><tr><td>消息总线</td><td>无</td><td>Spring Cloud Bus</td></tr><tr><td>数据流</td><td>无</td><td>Spring Cloud Stream</td></tr><tr><td>批量任务</td><td>无</td><td>Spring Cloud Task</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>使用 Dubbo 构建的微服务架构就像组装电脑，各环节的选择自由度很高，但最终结果很有可能因为一条内存质量不行就点不亮了；而 Spring Cloud 就像品牌机，在 Spring Source 的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但若要在使用非原装组件外的东西，就需要对其基础有足够的了解。</p><p>Spring Cloud是真正的微服务框架、提供整套的组件支持、使用简单方便、强大的社区支持等等，另外考虑到 .NET/.NET Core 的兼容处理，RPC 并不能很好的实现跨语言（需要借助跨语言库，比如 gRPC、Thrift，但因为 Dubbo 本身就是“gRPC”，在 Dubbo 之上再包一层 gRPC，有点重复封装了），而 HTTP REST 本身就是支持跨语言实现，所以，Spring Cloud 这一点还是非常好的（Dubbox 也支持，但性能相比要差一些）。</p><p>凡事无绝对，每件事物有好的地方也有不好的地方，总的来说，Dubbo 和 Spring Cloud 的主要不同体现在两个方面：服务调用方式不同和专注点不同（生态不同）。</p>]]></content>
    
    
    <summary type="html">Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案及SOA服务治理方案。</summary>
    
    
    
    <category term="Middleware" scheme="https://southernfish.github.io/categories/Middleware/"/>
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="Dubbo" scheme="https://southernfish.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>远程过程调用</title>
    <link href="https://southernfish.github.io/2025/07/09/middleware/rpc/"/>
    <id>https://southernfish.github.io/2025/07/09/middleware/rpc/</id>
    <published>2025-07-09T11:35:36.000Z</published>
    <updated>2025-07-10T12:40:42.922Z</updated>
    
    <content type="html"><![CDATA[<p>RPC（Remote Procedure Call）是一种允许程序像调用本地方法一样调用远程服务的通信协议，其核心价值在于屏蔽网络通信的底层复杂性，这与中间件“连接异构系统、简化开发”的核心目标完全一致。本文参考文章：<a href="https://blog.csdn.net/yuiezt/article/details/140190124">什么是RPC？有哪些RPC框架？</a>、<a href="https://cloud.tencent.com/developer/article/1506792">一文搞定理解RPC</a>、<a href="https://blog.csdn.net/weixin_53580595/article/details/142744919">—RPC介绍一篇就够了&amp;RPC的选择</a>。推荐文章：<a href="https://cloud.tencent.com/developer/article/2021745?policyId=1004">从原理到选型，一文带你搞懂RPC</a></p><h1>RPC</h1><h2 id="简介-2">简介</h2><p>RPC是远程过程调用（Remote Procedure Call）的缩写，是一种允许运行在一台计算机上的程序调用另一台计算机上子程序的技术。SAP系统RPC调用的原理其实很简单，有一些类似于三层构架的C/S系统，第三方的客户程序通过接口调用SAP内部的标准或自定义函数，获得函数返回的数据进行处理后显示或打印。远程过程调用（RPC）跨越了开放系统互连（OSI）网络通信模型中的传输层和应用层。</p><p>**完整的RPC框架：**服务发现、负载、容错、网络传输、序列化等组件</p><h2 id="RPC协议">RPC协议</h2><p>常说的RPC其实是RPC协议，即一种专门为服务间远程调用而设计的一种通用协议。该协议基于其它已有的传输协议，规定通信方式为C/S架构；并且在代码开发过程中要屏蔽掉底层通信细节，让开发者像调用本地方法一样，调用远程服务。RPC机制使得开发者能够构建分布式计算系统，其中不同的组件可以分布在不同的计算机上，但它们之间可以像在同一台机器上一样相互调用。</p><h2 id="RPC组成">RPC组成</h2><p>基于RPC协议内容的说明来看RPC的主要组成：</p><ul><li>确定一个已有的传输协议（TCP\UDP\HTTP\Websocket等）</li><li>一个客户端通信实现模块(即客户端stub)</li><li>一个服务端通信实现模块(即服务端stub)</li><li>选择一个RPC内容协议（如：json、xml、protobuf等）</li></ul><p>RPC主要有 5 个部分组成，分别是：<em>客户端、客户端 Stub、网络传输模块、服务端 Stub、服务端</em>等。<br>**客户端(Client)：**服务调用方。<br>**客户端存根(Client Stub)：**存放服务端地址信息，将客户端请求参数数据信息打包成网络消息，通过网络传输发送给服务端。<br>**服务端存根(Server Stub)：**接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。<br>**服务端(Server)：**服务的真正提供者。<br>**Network Service：**底层传输，可以是 TCP 或 HTTP。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250619112443294.png" alt="image-20250619112443294"></p><h2 id="现代化RPC框架的特点">现代化RPC框架的特点</h2><ul><li><strong>高性能</strong>：现代RPC框架通常采用高效的序列化协议和网络传输协议，以提高通信性能。</li><li><strong>跨语言支持</strong>：支持多种编程语言，使得不同语言编写的服务可以无缝通信。</li><li><strong>可扩展性</strong>：提供负载均衡、服务注册与发现等功能，以支持大规模分布式系统的部署和运维。</li><li><strong>安全性</strong>：支持加密传输和身份验证等安全机制，保障通信过程中的数据安全和隐私保护。</li></ul><h2 id="为什么需要RPC">为什么需要RPC</h2><p>微服务、分布式应用的开发越来越常见，RPC可以<strong>解决各个节点之间的服务调用以及通信问题</strong>。</p><p><strong>RPC框架会帮助我们做这些事情</strong>：</p><ul><li>客户端stub、服务端stub的实现</li><li>通信内容的序列化与反序列化实现（json、xml、protobuf）</li><li>服务的注册与发现</li><li>服务方负载均衡</li><li>并发性能调优</li></ul><p>有了RPC框架后，不需要再单独为项目开发这些基础功能了，这样开发具有RPC功能的客户端、服务端都跟开发普通本地模块一样方便。</p><p><strong>RPC优点</strong>：</p><ul><li>调用远程服务像调用本地方法一样方便</li><li>多种传输协议可以选择</li><li>为系统提供较强可扩展性、高可用性、维护性</li></ul><p><strong>治理功能</strong>，比如连接管理、健康检测、负载均衡、优雅启停机、异常重试、业务分组以及熔断限流等等</p><h2 id="RPC协议的实现">RPC协议的实现</h2><p><code>dubbo</code>、<code>grpc</code>、<code>restful</code>、<code>thrift</code>、<code>http</code></p><p><code>rmi</code>、<code>hessian</code>、<code>webserivice</code>、<code>memcached</code>、<code>redis</code>、<code>rest</code>、<code>jsonrpc</code>、<code>motan</code>、<code>yar</code></p><p>这些协议可以适用于不同的业务场景，比如：<code>dubbo</code>协议适合高频的小数据量调用，<code>hessian</code>则适合文件传输，而<code>jsonrpc</code>、<code>grpc</code>则适合跨语言的应用。这些协议也与TCP等协议类似，都规定了自己的<code>头信息</code>和<code>body</code>部分，用于约定通信的规则。</p><h2 id="RPC实现思路">RPC实现思路</h2><p>首先远程调用的大致链路其实都是大同小异的，大概可以分解出以下几个步骤：</p><ul><li><strong>定义接口和数据类型</strong>：首先需要定义接口和数据类型，包括接口方法名、参数类型、返回值类型等。这些定义通常使用IDL（Interface Definition Language）语言来描述，以便于不同语言之间的调用和序列化。</li><li><strong>生成代码</strong>：根据接口和数据类型的定义，生成客户端和服务器端的代码。这些代码通常包括序列化和反序列化方法、网络传输方法等，以便于客户端和服务器端进行数据交换和通信。</li><li><strong>实现服务器端</strong>（被调用方）：在服务器端实现接口方法，根据客户端请求进行相应的处理，并将处理结果返回给客户端。服务器端还需要实现服务注册和发现、负载均衡、容错等机制，以提高系统的可用性和可靠性。</li><li><strong>实现客户端</strong>（调用方）：在客户端调用远程接口方法，将参数序列化并通过网络发送给服务器端，然后等待服务器端返回处理结果，并将结果反序列化后返回给调用方。客户端还需要实现服务发现和选择、负载均衡、重试等机制，以提高系统的可用性和可靠性。</li><li><strong>集成框架</strong>：将生成的代码和实现的服务器端、客户端集成到RPC框架中，并提供相应的API和工具，以便于开发人员使用和集成。</li><li><strong>测试和优化</strong>：对实现的RPC框架进行测试和优化，包括性能测试、功能测试、安全测试等，以确保系统的稳定性、可靠性和安全性。</li></ul><h2 id="RPC与HTTP的区别">RPC与HTTP的区别</h2><p>RPC 和 HTTP 本质上是<strong>面向不同场景的产物</strong>。而RPC也可以基于HTTP协议来实现信息内容的传输。<br>RPC 和 HTTP 还有如下典型的区别：</p><ul><li>RPC 可以基于 TCP、HTTP、WebStock 等作为基础传输协议，而 HTTP 只能是 http 协议</li><li>RPC 使用二进制来传输信息内容（体积更小），HTTP 则使用文本格式</li><li>RPC 的二进制序列化效率高，HTTP 的文本序列化（如json）则耗时多</li><li>RPC 基于 TCP 时可以网络 IO 多路复用，HTTP 不能很好的支持</li><li>RPC 可以很方便支持服务治理，而 HTTP 则需要单独实现支持</li></ul><p>简而言之，就是RPC在远程调用的场景下，比 HTTP 更高效，更简洁、附加特性更强大，更适合分布式和微服务的场景。</p><h2 id="RPC的应用">RPC的应用</h2><p>RPC在分布式系统中的系统环境建设和应用程序设计中有着广泛的应用，应用包括如下方面：</p><ol><li><strong>分布式操作系统的进程间通讯</strong><br>进程间通讯是操作系统必须提供的基本设施之一，分布式操作系统必须提供分布于异构的结点机上进程间的通讯机制，RPC是实现消息传送模式的分布式进程间通讯的手段之一。</li><li><strong>构造分布式计算的软件环境</strong><br>由于分布式软件环境本身地理上的分布性，它的各个组成成份之间存在大量的交互和通讯，RPC 是其基本的实现方法之一。ONC+和DCE两个流行的分式布计算软件环境都是使用RPC构造的，其它一些分布式软件环境也采用了RPC方式。</li><li><strong>远程数据库服务</strong><br>在分布式数据库系统中，数据库一般驻存在服务器上，客户机通过远程数据库服务功能访问数据库服务器，现有的远程数据库服务是使用RPC模式的。例如，<code>Sybase</code>和<code>Oracle</code>都提供了存储过程机制，系统与用户定义的存储过程存储在数据库服务器上，<em>用户在客户端使用RPC模式调用存储过程</em>。</li><li><strong>分布式应用程序设计</strong><br>RPC机制与RPC工具为分布式应用程序设计提供了手段和方便, 用户可以无需知道网络结构和协议细节而直接使用RPC工具设计分布式应用程序。</li><li><strong>分布式程序的调试</strong><br>RPC可用于分布式程序的调试。使用反向RPC使服务器成为客户并向它的客户进程发出RPC，可以调试分布式程序。例如，在服务器上运行一个远端调试程序，它不断接收客户端的RPC，当遇到一个调试程序断点时，它向客户机发回一个RPC，通知断点已经到达，这也是RPC用于进程通讯的例子。</li></ol><hr><h1>RPC 原理</h1><h2 id="RPC-调用流程">RPC 调用流程</h2><ol><li><strong>服务消费者(Client 客户端)<strong>通过本地调用的方式</strong>调用服务</strong>。</li><li>**客户端存根(Client Stub)<strong>接收到调用请求后负责将方法、入参等</strong>信息序列化(组装)**成能够进行网络传输的消息体。</li><li><strong>客户端存根(Client Stub)<strong>找到远程的服务地址，并且将消息通过网络</strong>发送给服务端</strong>。</li><li><strong>服务端存根(Server Stub)<strong>收到消息后进行</strong>解码(反序列化)</strong>。</li><li>**服务端存根(Server Stub)**根据解码结果调用本地的服务进行相关处理</li><li><strong>服务端(Server)<strong>本地服务</strong>业务处理</strong>。并将处理结果返回给服务端存根(Server Stub)。</li><li>**服务端存根(Server Stub)**序列化结果。</li><li><strong>服务端存根(Server Stub)<strong>将结果通过网络</strong>发送至消费方</strong>。</li><li><strong>客户端存根(Client Stub)<strong>接收到消息，并进行</strong>解码(反序列化)</strong>。</li><li><strong>服务消费者(Client 客户端)<strong>服务消费方得到</strong>最终结果</strong>。</li></ol><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250619112546216.png" alt="image-20250619112546216"></p><p>RPC 框架提供了一系列的功能来支持上述过程，包括但不限于：</p><ul><li><strong>接口定义</strong>：定义服务端和客户端之间的接口，确保双方能够正确理解和调用。</li><li><strong>数据序列化与反序列化</strong>：将调用信息和结果转换为网络可传输的格式，并在接收时进行还原。</li><li><strong>网络通信</strong>：封装底层的网络通信逻辑，使得开发者无需关心具体的网络细节。</li><li><strong>负载均衡</strong>：在多个服务实例之间分配请求，提高系统的可扩展性和可用性。</li><li><strong>服务注册与发现</strong>：在分布式系统中，自动发现可用的服务实例。</li></ul><h2 id="透明化远程服务调用-实现">透明化远程服务调用 实现</h2><p>对java来说就是使用代理！java代理有两种方式： <strong>jdk 动态代理</strong>和<strong>字节码生成</strong>。尽管字节码生成方式实现的代理更为强大和高效，但代码维护不易，大部分公司实现RPC框架时还是选择动态代理方式。</p><p>通过动态代理模式，在执行该方法的前后对数据进行封装和解码等，让用于感觉就像是直接调用该方法一样，殊不知，我们对方法前后都经过了复杂的处理。</p><p>需要实现RPCProxyClient代理类，代理类的invoke方法中封装了与远端服务通信的细节，消费方首先从RPCProxyClient获得服务提供方的接口，当执行helloWorldService.sayHello(“test”)方法时就会调用invoke方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RPCProxyClient</span> <span class="keyword">implements</span> <span class="title class_">java</span>.lang.reflect.InvocationHandler&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RPCProxyClient</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj=obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到被代理对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> java.lang.reflect.Proxy.newProxyInstance(obj.getClass().getClassLoader(),</span><br><span class="line">                obj.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">RPCProxyClient</span>(obj));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用此方法执行</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 结果参数</span></span><br><span class="line">        <span class="comment">// ...执行通信相关逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;         </span><br><span class="line">     <span class="type">HelloWorldService</span> <span class="variable">helloWorldService</span> <span class="operator">=</span> (HelloWorldService)RPCProxyClient.getProxy(HelloWorldService.class);</span><br><span class="line">     helloWorldService.sayHello(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>RPC框架</h1><p>封装好参数编组、消息解组、底层网络通信的RPC程序开发框架，带来的便捷是可以直接在其基础上只需要专注于过程代码编写。</p><h2 id="目前常用的RPC框架">目前常用的RPC框架</h2><ol><li><p><strong>Dubbo</strong>：Dubbo是一个分布式服务框架，以及SOA治理方案。</p><p>其功能主要包括：高性能<code>NIO</code>通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。</p><p>Dubbo是阿里巴巴内部的SOA服务化治理方案的核心框架，Dubbo自2011年开源后，已被许多非阿里系公司使用。</p></li><li><p><strong>Spring Cloud</strong>：Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。Spring Cloud基于Spring Boot, 使得开发部署极其简单。</p></li><li><p><strong>gRPC</strong>: 一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。</p></li><li><p><strong>Thrift</strong> :是一种轻量级的跨语言 RPC 通信方案，支持多达 25 种编程语言，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。</p></li></ol><h2 id="常见RPC框架对比">常见RPC框架对比</h2><table><thead><tr><th></th><th>gRPC</th><th>Apache Dubbo</th><th>Apache Thrift</th><th>Motan</th></tr></thead><tbody><tr><td>开发者</td><td>Google</td><td>阿里巴巴</td><td>Apache</td><td>新浪微博开源</td></tr><tr><td>协议</td><td>使用HTTP/2协议作为底层传输协议，HTTP/2支持多路复用、头部压缩和服务器推送等特性，可提高性能和效率<br />使用<code>Protocol Buffers</code>（ProtoBuf）作为序列化协议，protobuf是一种高效紧凑的二进制序列化协议，适合高性能通信</td><td>支持多种传输协议，包括dubbo、rmi、http、hessian、webservice、rest等。<br/>支持多种序列化协议，如hessian、json、protobuf等</td><td>支持多种传输协议和序列化协议，如<code>TBinaryProtocol</code>、<code>TCompactProtocol</code>等</td><td>——</td></tr><tr><td>支持语言</td><td>支持多语言，包括C++、Java、Python、Go、Ruby、C#、Node.js等</td><td>主要基于Java，但可以通过扩展支持其他语言</td><td>支持多语言，包括C++、Java、Python、Go、Ruby、C#、Node.js等。</td><td>——</td></tr><tr><td>特点</td><td>提供强大的<code>IDL</code>（接口定义语言）和自动代码生成工具。<br/>支持双向流、流式传输等特性。<br/>适用于大规模分布式系统，要求高性能和跨语言支持的场景。<br/>适用于需要使用<code>Protocol Buffers</code>进行高效数据序列化的场景。</td><td>提供高性能、透明化的远程方法调用。<br/>支持负载均衡、服务发现、集群容错等特性。<br/>提供了REST风格的远程调用。<br/>适用于Java生态系统中的分布式应用，尤其是基于Spring的应用。<br/>适用于需要提供多协议支持和高度可扩展性的场景。</td><td>使用<code>IDL</code>进行接口定义，提供代码生成工具。<br/>支持异步和同步的通信方式。<br/>可以在不同语言之间进行跨语言通信。<br/>适用于异构系统中不同语言之间的远程调用。<br/>适用于需要高度定制和支持多种传输协议的场景。</td><td>是一个Java框架，具有高性能和可扩展性。<br/>在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。<br/>提供了丰富的功能和良好的性能表现。</td></tr><tr><td>优点</td><td>高性能、低延迟、跨语言支持、多种通信协议、流式传输支持。</td><td>丰富的服务治理功能、高度可扩展、支持大规模分布式系统、灵活的扩展机制。</td><td>跨语言支持、多种序列化方式、代码生成工具、高效的数据传输。</td><td>——</td></tr><tr><td>适用场景</td><td>大规模分布式系统、跨语言通信、需要高性能和低延迟的实时通信场景。</td><td>Java应用程序的分布式服务、需要服务治理功能的场景。</td><td>跨语言通信、大数据分析、需要高效数据传输的场景。</td><td>——</td></tr></tbody></table><h2 id="其他RPC框架">其他RPC框架</h2><p><strong>其他框架</strong>：如<code>Tars</code>（腾讯内部使用并开源）、<code>ZeroMQ</code>（高性能异步消息传递库，非专门RPC框架）、<code>Akka</code>（并发编程框架，提供Actor模型实现）等。<br><strong>特点</strong>：</p><ul><li>这些框架各有特色，如 Tars 特别支持 C++ 语言，适合高性能要求的应用场景。</li><li>ZeroMQ 适用于构建高度异步、消息驱动的系统。</li><li>Akka 适用于构建高并发、分布式、容错性强的系统。</li></ul><h2 id="RPC协议选择">RPC协议选择</h2><p>平时搭建业务一般可以通过业务上所需要的通信特点进行去选择。例如：</p><ul><li>如果是im场景下 WebRTC去提高通讯效率</li><li>如果是大型电商那种分布式系统的话可以使用gRPC，java则使用Dubbo</li><li>如果是搭建数据中心考虑跨语言则去选择Apache Thrift，</li><li>如果最简单平常的也可以直接利用Springcloud中的Spring Cloud Netflix项目实现的多种组件，如Ribbon、Feign、Hystrix等，用于构建分布式系统中的服务通信和治理。</li></ul><h2 id="序列化协议">序列化协议</h2><p>对于<strong>如何标识数据的做法</strong>是将交互双方所涉及的数据转换为某种<strong>事先约定好的中立数据流格式</strong>来进行传输，将数据流转换回不同语言中对应的数据类型来进行使用，就是序列化协议的初衷。一个好的序列化协议作用如下：</p><ul><li><strong>跨语言和跨平台</strong>： 分布式系统中，不同计算机可能使用不同编程语言和操作系统，因此需要一种通用的数据格式，以便跨语言和跨平台进行数据传输和交互。序列化协议<em>将数据转换为一种通用的格式</em>，使得不同计算机之间可以正确地对数据进行编码和解码。</li><li><strong>数据压缩</strong>： 在网络传输过程中，数据的大小会影响网络带宽和传输速度，因此需要对数据进行压缩。序列化协议可以**将数据压缩为更小的二进制格式*，从而减少网络传输的数据量，提高网络传输效率。</li><li><strong>数据安全</strong>： 在网络传输过程中，数据可能会被篡改或窃取，因此需要对数据进行加密和解密。序列化协议可以<em>将数据转换为二进制格式，并进行加密和解密操作</em>，从而保证数据的安全性和完整性。</li><li><strong>数据可读性</strong>： 在调试和排错过程中，需要查看网络传输的数据内容，以便于定位问题。序列化协议可以<em>将数据转换为文本格式</em>，使得数据更易于读取和理解。</li></ul><h2 id="几个常见的-rpc-的地址">几个常见的 rpc 的地址</h2><p>grpc中文文档：<a href="https://doc.oschina.net/grpc">https://doc.oschina.net/grpc</a></p><p>grpc官方文档：<a href="https://grpc.io/docs/">https://grpc.io/docs/</a></p><p>dubbo官方文档：<a href="https://cn.dubbo.apache.org/zh-cn/overview/home/">https://cn.dubbo.apache.org/zh-cn/overview/home/</a></p><p>Apache Thrift官方文档：<a href="https://thrift.apache.org/">https://thrift.apache.org/</a></p><p>WebRTC官方文档：<a href="https://webrtc.org/?hl=zh-cn">https://webrtc.org/?hl=zh-cn</a></p>]]></content>
    
    
    <summary type="html">RPC（Remote Procedure Call）是一种允许程序像调用本地方法一样调用远程服务的通信协议。</summary>
    
    
    
    <category term="Middleware" scheme="https://southernfish.github.io/categories/Middleware/"/>
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="RPC" scheme="https://southernfish.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>SkyWalking</title>
    <link href="https://southernfish.github.io/2025/07/09/middleware/skywalking/"/>
    <id>https://southernfish.github.io/2025/07/09/middleware/skywalking/</id>
    <published>2025-07-09T11:35:36.000Z</published>
    <updated>2025-07-21T14:23:27.085Z</updated>
    
    <content type="html"><![CDATA[<p>SkyWalking 不是传统意义上的中间件，但属于分布式追踪系统，主要用于监控微服务架构中的服务调用链路和性能分析。它提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案，支持微服务、云原生架构，提供了总览、拓扑、应用、服务视图及链路追踪、告警等功能，能够串联用户请求到后端各系统节点的处理流程，帮助快速定位问题。本文参考文章：<a href="https://cloud.tencent.com/developer/article/1953242">分布式链路追踪原理详解及SkyWalking、Zipkin介绍</a>、<a href="https://blog.csdn.net/AMimiDou_212/article/details/104749448">分布式全链路追踪 SkyWalking基本原理</a>、<a href="https://developer.aliyun.com/article/1611839">链路跟踪-SkyWalking系列</a></p><h1 id="SkyWalking"><a href="#SkyWalking" class="headerlink" title="SkyWalking"></a>SkyWalking</h1><h2 id="应用监控和链路跟踪"><a href="#应用监控和链路跟踪" class="headerlink" title="应用监控和链路跟踪"></a>应用监控和链路跟踪</h2><p>随着微服务架构的流行，开发的运维压力增大，经常需要面临这些问题： </p><ol><li><strong>链路较长</strong>：在微服务场景下，整个链路会变得很长，服务出问题时，往往不能第一时间排查出问题。 </li><li><strong>缺少监控</strong>：缺少对于服务器，应用组件的实时运行信息，做到心中有数。</li><li><strong>预警不及时，粒度较大</strong>：经常在服务器响应延迟甚至宕机后，才能发现问题，同时粒度较大，无法在接口层面进行预警。 </li></ol><p>基于Agent技术，SkyWalking提供了例如吞吐量，QPS，JVM信息等丰富的指标供参考，做到有效同时地告警，利用其丰富的插件，能帮助我们跟踪Dubbo，ElasticSearch，Redis等这些组件的调用链路。 通过SkyWalking做链路跟踪，系统监控，异常告警的落地，解决了开发过程中问题定位慢的痛点。</p><p>整个分布式追踪的目的是为了最终在<strong>页面上、UI上、和数据上能够复现分布式系统中服务调用的整个过程</strong>。在做分布式追踪时需要拿到完整的信息，包括<strong>精确的响应时间，访问的方法、访问的 circle，访问的 Redis 的 key</strong>等，最终展现出一个完整的链路。</p><p>一个请求完整的调用链路： 那么在业务规模不断增大，服务不断增多以及频繁变更的情况下，面对复杂的调用链路就带来一系列问题： </p><ol><li>如何快速发现问题？</li><li>如何判断故障影响范围？ </li><li>如何梳理服务依赖以及依赖的合理性？ </li><li>如何分析链路性能以及实时容量规划？ </li><li>吞吐量，根据拓扑可计算相应组件，平台，物理设备的实时吞吐量 </li><li>响应时间，包括整体调用的响应时间和各个服务的响应时间等。 </li><li>错误记录，根据服务返回统计单位时间异常次数。</li></ol><p>全链路性能监控从整体维度到局部维度展示各个指标，将跨应用的所有调用链路性能信息集中展现，可方便度量整体和局部性能，并且方便找到故障产生的源头，生产上可极大缩短故障排查时间。 有了全链路监控工具，能够达到：</p><ol><li><strong>请求链路跟踪，故障快速定位</strong>：可以通过调用链路结合业务日志快速定位错误信息。</li><li><strong>可视化</strong>：各个阶段耗时，进行性能分析</li><li><strong>依赖优化</strong>：各个调用环节的可用性，梳理服务依赖关系以及优化</li><li><strong>数据分析，优化链路</strong>：可以得到用户的行为路径，汇总分析应用在很多业务场景。</li></ol><h2 id="APM"><a href="#APM" class="headerlink" title="APM"></a>APM</h2><p>APM（Application Performance Management）应用性能管理，通过各种探针采集并上报数据，收集关键指标，同时搭配数据展示以实现对应用程序性能管理和故障管理的系统化解决方案。 </p><p>目前主要的一些 APM 工具有：Cat、Zipkin、Pinpoint、SkyWalking，这里主要介绍 SkyWalking ，它是一款优秀的国产 APM 工具，包括了分布式追踪、性能指标分析、应用和服务依赖分析等。 </p><p>Zabbix、Premetheus、open-falcon等监控系统主要关注服务器硬件指标与系统服务运行状态等，而APM系统则更重视程序内部执行过程指标和服务之间链路调用情况的监控，APM更有利于深入代码找到请求响应“慢”的根本问题，与 Zabbix 之类的监控是互补关系。</p><h2 id="Apache-SkyWalking-Incubator"><a href="#Apache-SkyWalking-Incubator" class="headerlink" title="Apache SkyWalking(Incubator)"></a>Apache SkyWalking(Incubator)</h2><p>Apache SkyWalking：</p><ul><li><p>分布式系统的应用程序性能监视工具，专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计。</p></li><li><p>Apache Skywalking(Incubator) 专门为微服务架构和云原生架构系统而设计并且支持分布式链路追踪的APM系统。Apache Skywalking(Incubator)通过加载 <strong>探针-非侵入式</strong> 的方式收集应用调用链路信息，并对采集的调用链路信息进行分析，生成应用间关系和服务间关系以及服务指标。</p></li><li><p>Apache Skywalking (Incubating)目前支持多种语言，其中包括Java，.Net Core，Node.js和Go语言。</p></li></ul><p>Skywalking已经支持从<strong>6个可视化维度</strong>剖析分布式系统的运行情况。</p><ul><li><strong>总览视图</strong>(<code>Global view</code>)是应用和组件的全局视图，其中包括组件和应用数量，应用的告警波动，慢服务列表以及应用吞吐量；</li><li><strong>拓扑图</strong>(<code>topology view</code>)从应用依赖关系出发，展现整个应用的拓扑关系；</li><li><strong>应用视图</strong>则是从单个应用的角度，展现应用的上下游关系，TopN的服务和服务器，JVM的相关信息以及对应的主机信息。</li><li><strong>服务视图</strong>关注单个服务入口的运行情况以及此服务的上下游依赖关系，依赖度，帮助用户针对单个服务的优化和监控；</li><li><strong>调用链</strong>(<code>trace</code>)展现了调用的单次请求经过的所有埋点以及每个埋点的执行时长；</li><li><strong>告警视图</strong>(<code>alarm</code>)根据配置阈值针对应用、服务器、服务进行实时告警。</li></ul><h2 id="什么是-SkyWalking"><a href="#什么是-SkyWalking" class="headerlink" title="什么是 SkyWalking"></a>什么是 SkyWalking</h2><ul><li>是观察性分析平台和应用性能管理系统。</li><li>提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案</li><li>支持Java， .Net Core，PHP，NodeJS，Golang，LUA语言探针</li><li>支持<code>Envoy + Istio</code>构建的 Service Mesh</li></ul><h2 id="javaAgent探针技术使用场景"><a href="#javaAgent探针技术使用场景" class="headerlink" title="javaAgent探针技术使用场景"></a>javaAgent探针技术使用场景</h2><ol><li>无入侵  <strong>链路跟踪</strong> </li><li>无入侵 <strong>动态线程池</strong> </li><li>无入侵  <code>TransmitThreadLocal </code></li><li>无入侵的  <strong>命令行交互模式JVM诊断Arthas</strong></li></ol><h2 id="SkyWalking-原理架构图"><a href="#SkyWalking-原理架构图" class="headerlink" title="SkyWalking 原理架构图"></a>SkyWalking 原理架构图</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250711122919890.png" alt="image-20250711122919890"></p><p> <strong>SkyWalking支持三种探针：</strong></p><ol><li><strong>Agent</strong>：基于ByteBuddy字节码增强技术实现，通过jvm的agent参数加载，并在程序启动时拦截指定的方法来 收集数据。 (最推荐) </li><li><strong>SDK</strong>：程序中显式调用SkyWalking提供的SDK来收集数据，对应用有侵入。 </li><li><strong>Service Mesh</strong>：通过Service mesh的网络代理来收集数据。</li></ol><p> <strong>后端（Backend）</strong> </p><p>接受探针发送过来的数据，进行度量分析，调用链分析和存储。后端主要分为两部分： </p><p><strong>OAP</strong>（<code>Observability Analysis Platform</code>）：进行度量分析和调用链分析的后端平台，并支持将数据存储到各种数据库中，如：ElasticSearch，MySQL，InfluxDB等。</p><p><strong>OAL</strong>（<code>Observability Analysis Language</code>）：用来进行度量分析的DSL，类似于SQL，用于查询度量分析结果和警报。</p><h2 id="SkyWalking-核心模块"><a href="#SkyWalking-核心模块" class="headerlink" title="SkyWalking 核心模块"></a>SkyWalking 核心模块</h2><p>SkyWalking采用组件式开发，易于扩展，主要组件作用如下： </p><ol><li><strong>Skywalking Agent：</strong>链路数据采集<strong>tracing（调用链数据）和metric（指标）信息</strong>并上报，上报通过HTTP或者 gRPC 方式发送数据到Skywalking Collector </li><li><strong>Skywalking Collector ：</strong> 链路数据收集器，对agent传过来的<code>tracing</code>和<code>metric</code>数据进行整合分析通过<code>Analysis Core</code>模块处理并落入相关的数据存储中，同时会通过<code>Query Core</code>模块进行二次统计和监控告警 </li><li><strong>Storage：</strong> Skywalking的存储，支持以<code>ElasticSearch、Mysql、TiDB、H2</code>等主流存储作为存储介质进行数据存储，H2仅作为临时演示单机用。 </li><li><strong>SkyWalking UI：</strong> Web可视化平台，用来展示落地的数据，目前官方采纳了<code>RocketBot</code>作为SkyWalking的主UI</li></ol><h2 id="SkyWalking-UI组件视图"><a href="#SkyWalking-UI组件视图" class="headerlink" title="SkyWalking UI组件视图"></a>SkyWalking UI组件视图</h2><ol><li><p><strong>仪表盘</strong>：查看全局服务基本性能指标 仪表盘主要包含Service Dashboard和Database Dashboard </p><ul><li><p><strong>Service Dashboard：</strong>有Global、Service、Endpoint、Instance面板，展示了<strong>全局以及服务、端点、实例</strong>的详细信息</p></li><li><p><strong>Database Dashboard：</strong>展示数据库的<strong>响应时间、响应时间分布、吞吐量、SLA、慢SQL</strong>等详细信息，便于直观展示数据库状态</p></li></ul></li><li><p><strong>拓扑图</strong>：展示分布式服务之间调用关系： </p><ul><li><p>SkyWalking 能根据获取的数据自动绘制服务之间的调用关系图，并识别常见的服务显示在图标上，如 tomcat、CAS 服务  </p></li><li><p>每条连线的颜色反应了服务之间的调用延迟情况，可以非常直观的看到服务与服务之间的调用状态，连线中间的点能点击，可显示两个服务之间链路的平均响应时间、吞吐率以及SLA等信息，还可以展示服务的性能数据。</p></li></ul></li><li><p><strong>链路追踪</strong>：可以根据需求，查看链路调用过程</p><ul><li>显示请求的响应内部执行情况，一个完整的请求都经过了哪些服务、执行了哪些代码方法、每个方法的执行时间、执行状态等详细信息，快速定位代码问题。</li></ul></li></ol><ol start="4"><li><strong>告警提示</strong></li><li> <strong>指标数据对比</strong></li></ol><h2 id="SkyWalking的特点"><a href="#SkyWalking的特点" class="headerlink" title="SkyWalking的特点"></a>SkyWalking的特点</h2><ol><li><strong>性能好</strong>：针对单实例5000tps的应用，在全量采集的情况下，只增加10%的CPU开销 </li><li>支持多语言探针</li><li>无入侵，支持自动以及手动探针</li></ol><p><strong>自动探针</strong>：java支持的中间件，框架与类库列表<br><strong>手动探针</strong>：OpenTrackingApi，@Trace注解，traceId集成到日志中</p><h2 id="SkyWalking三大架构模式"><a href="#SkyWalking三大架构模式" class="headerlink" title="SkyWalking三大架构模式"></a><strong>SkyWalking三大架构模式</strong></h2><ol><li>AOP架构模式</li><li>插件式架构模式</li><li>微内核架构模式</li></ol><p>一个组件具有高扩展架构的话，需要具有微内核架构/插件式架构/无入侵架构，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">高扩展架构</span><br><span class="line">    微内核架构</span><br><span class="line">        SkyWalking</span><br><span class="line">    插件式架构</span><br><span class="line">        SkyWalking</span><br><span class="line">        shardingJdbc</span><br><span class="line">        Spring、SpringBoot</span><br><span class="line">    无入侵架构</span><br><span class="line">        SkyWalking</span><br><span class="line">        Arthas</span><br></pre></td></tr></table></figure><hr><h1 id="SkyWalking-安装部署"><a href="#SkyWalking-安装部署" class="headerlink" title="SkyWalking 安装部署"></a>SkyWalking 安装部署</h1><p>存储到ES需要先安装 ElasticSearch</p><h2 id="SkyWalking-安装"><a href="#SkyWalking-安装" class="headerlink" title="SkyWalking 安装"></a>SkyWalking 安装</h2><ol><li><p>下载 <a href="https://www.apache.org/dyn/closer.cgi/skywalking/6.6.0/apache-skywalking-apm-6.6.0.tar.gz">压缩包</a></p></li><li><p>解压安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@example apache-skywalking-apm-bin]<span class="comment"># tar -xvf apache-skywalking-apm-6.6.0.tar.gz -C /opt/</span></span><br><span class="line"><span class="comment"># ll 查看详细列表</span></span><br><span class="line">agent        <span class="comment"># 探针客户端，Java -jar启动时参数指向agent里面的skywalking探针jar包</span></span><br><span class="line">bin            <span class="comment"># 启动脚本</span></span><br><span class="line">config        <span class="comment"># skyWalking 配置目录</span></span><br><span class="line">logs        <span class="comment"># 日志目录</span></span><br><span class="line">webapp        <span class="comment"># skyWalking ul</span></span><br></pre></td></tr></table></figure></li><li><p>配置UI端口</p><p><strong>config：</strong>配置文件，主要修改application.yml里的agent采集的信息要存存储到哪里，默认H2，现改为ES。修改namespace为ES集群名，clusterNodes为ES集群各节点URL即可，其他暂时默认即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">    <span class="attr">selector:</span> <span class="string">$&#123;SW_STORAGE:elasticsearch7&#125;</span></span><br><span class="line">    <span class="attr">elasticsearch7:</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">$&#123;NAMESPACE:&quot;elasticsearch&quot;&#125;</span></span><br><span class="line">        <span class="attr">clusterNodes:</span> <span class="string">$&#123;SSW_STORAGEE_ES_CLUSTER_NODES:localhost:9200&#125;</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">$&#123;SSW_STORAGE_ES_HTTP_PROTOCOL:&quot;http&quot;&#125;</span></span><br><span class="line">        <span class="attr">trustStorePath:</span> <span class="string">$&#123;SISW_STORAGE_ES_SSL_JKS_PATH:&quot;&quot;&#125;</span></span><br><span class="line">        <span class="attr">trustStorePass:</span> <span class="string">$&#123;SISW_STORAGE_ES_SSL_JKS_PASS:&quot;&quot;&#125;</span></span><br><span class="line">        <span class="comment"># Represent the number of days in the one minute/hour/day index.</span></span><br><span class="line">        <span class="attr">dayStep:</span> <span class="string">$&#123;SW_STORAGE_DAY_STEP:l&#125;</span></span><br><span class="line">        <span class="attr">user:</span> <span class="string">$&#123;SW_ES_USER:&quot;&quot;&#125;</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">$&#123;SW_ES_PASSWORD:&quot;&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#    segmentQueryMaxSize: $&#123;SW_STORAGE_ES_QUERY_SEGMENT_SIZE:200&#125;</span></span><br><span class="line">    <span class="attr">h2:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">$&#123;SW_STORAGE_H2_DRIVER:org.h2.jdbcx.JdbcDataSource&#125;</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">$&#123;SW_STORAGE_H2_URL:jdbc:h2:mem:skywalking-oap-db&#125;</span></span><br><span class="line">        <span class="attr">user:</span> <span class="string">$&#123;SW_STORAGE_H2_USER:sa&#125;</span></span><br><span class="line">        <span class="attr">metadataQueryMaxSize:</span> <span class="string">$&#123;SW_STORAGE_H2_QUERY_MAX_SIZE:5000&#125;</span></span><br></pre></td></tr></table></figure><p><strong>webapp：</strong>将ES里的数据展示出来的UI项目基本配置，修改一下webapp.yml的server.port端口，默认8080</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 最好是改掉，因默认8080端口经常被占用，比如 8888</span></span><br><span class="line"><span class="attr">collector:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/graphql</span></span><br><span class="line">    <span class="attr">ribbon:</span></span><br><span class="line">        <span class="attr">ReadTimeout:</span> <span class="number">10000</span></span><br><span class="line">        <span class="comment"># Point to all backend&#x27;s restHost:restPort, split by</span></span><br><span class="line">        <span class="attr">listofservers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:12800</span></span><br></pre></td></tr></table></figure><p>bin启动脚本，startup.sh同时启动 oap（主要是将探针采集的数据上传到ES）和webapp（相当于zipkin-ui）两个服务，也可单独启动。<strong>注意：</strong>.bat 为windows 启动脚本；.sh为Linux 启动脚本；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@example apache-skywalking-apm-bin]<span class="comment"># ll bin</span></span><br><span class="line">total 40</span><br><span class="line">-rwxr-xr-x. 1 nginx 1002 1352 Dec 24 01:10 oapService.bat</span><br><span class="line">-rwxr-xr-x. 1 nginx 1002 1364 Dec 24 01:10 oapServiceInit.bat</span><br><span class="line">-rwxr-xr-x. 1 nginx 1002 1597 Dec 24 01:10 oapServiceInit.sh</span><br><span class="line">-rwxr-xr-x. 1 nginx 1002 1367 Dec 24 01:10 oapServiceNoInit.bat</span><br><span class="line">-rwxr-xr-x. 1 nginx 1002 1616 Dec 24 01:10 oapServiceNoInit.sh</span><br><span class="line">-rwxr-xr-x. 1 nginx 1002 1599 Dec 24 01:10 oapService.sh          <span class="comment"># oapService 服务启动脚本</span></span><br><span class="line">-rwxr-xr-x. 1 nginx 1002  941 Dec 24 01:10 startup.bat</span><br><span class="line">-rwxr-xr-x. 1 nginx 1002  934 Dec 24 01:10 startup.sh              <span class="comment"># 启动oap 和UI 服务</span></span><br><span class="line">-rwxr-xr-x. 1 nginx 1002 1426 Dec 24 01:10 webappService.bat</span><br><span class="line">-rwxr-xr-x. 1 nginx 1002 1630 Dec 24 01:10 webappService.sh      <span class="comment"># Web UI 启动脚本</span></span><br></pre></td></tr></table></figure></li><li><p>默认使用H2存储，启动SkyWalking的UI控制台，出现如下则证明启动成功，即可通过<a href="http://localhost:8080/">http://localhost:8080</a> 访问Web UI。如果启动失败，查询apache-skywalking-apm-bin/logs目录下日志skywalking-oap-server.log和SkyWalking UI日志webapp.log，跟进错误提示进行分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@example apache-skywalking-apm-bin]<span class="comment"># bin/startup.sh</span></span><br><span class="line">SkyWalking OAP started successfully!</span><br><span class="line">SkyWalking Web Application started successfully!</span><br></pre></td></tr></table></figure></li><li><p>配置后端存储</p></li></ol><h2 id="JavaAgent-部署"><a href="#JavaAgent-部署" class="headerlink" title="JavaAgent 部署"></a>JavaAgent 部署</h2><p>通过操作 Instrumentation 的 API 就可以实现不重启服务对单个类进行简单的修改。 通常有两种方式拿到 Instrumentation 对象：</p><ol><li>在 JVM 启动时指定 agent，Instrumentation 对象会通过 agent 的 premain 方法传递。</li><li>在 JVM 启动后通过 JVM 提供的机制加载 agent，Instrumentation 对象会通过 agent 的 agentmain 方法传递。</li></ol><p>Skywalking 就是通过在 JVM 启动时指定 agent，这样其实对于业务来说会减少一些不确定性，如果在运行期间侵入，至少在启动的过程中能预判一些不确定性，具体详情代码请参考：org.apache.skywalking.apm.agent.SkyWalkingAgent。 </p><p>业务应用在 Skywalking 中如何被零侵入，配置属性文件 env.properties，内容如下，注意将 skywalking-agent.jar 放到指定的路径上。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">JAVA_HOME</span>=<span class="string">&quot;/data/java/jdk1.8.0_161&quot;</span></span><br><span class="line"><span class="attr">JAVA_PARAMS</span>=<span class="string">&quot;$JAVA_PARAMS -DSW_AGENT_NAME=application-name&quot;</span></span><br><span class="line"><span class="attr">JAVA_PARAMS</span>=<span class="string">&quot;$JAVA_PARAMS -javaagent:/data/skywalking/skywalking-agent.jar&quot;</span></span><br></pre></td></tr></table></figure><p>部署 JavaAgent 探针流程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.Agent 用于JDK1.6-12</span></span><br><span class="line"><span class="comment"># 2.在SkyWalking 目录下找到agent目录</span></span><br><span class="line"><span class="comment"># 3.在config/agent.config修改agent.service_name名称，显示在UI控制台的名称， service_name填写微服务名称即可</span></span><br><span class="line"><span class="comment"># 4.设置后端Service 采集器 collector.backend_service，127.0.0.1:8080仅用于本地后端收集器。</span></span><br><span class="line">    <span class="comment"># 实际需要设置为SkyWalking服务器的地址和端口</span></span><br><span class="line"><span class="comment"># 5.添加 -javaagent:/path/to/skywalking-package/agent/skywalking-agent.jar到JVM参数之前，确保在 -jar之前。</span></span><br><span class="line"><span class="comment"># 6.启动应用</span></span><br></pre></td></tr></table></figure><p>Agent包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+-- agent</span><br><span class="line">    +-- activations</span><br><span class="line">         apm-toolkit-log4j-1.x-activation.jar</span><br><span class="line">         ...</span><br><span class="line">    +-- config</span><br><span class="line">         agent.config  </span><br><span class="line">    +-- plugins</span><br><span class="line">         apm-dubbo-plugin.jar</span><br><span class="line">         .....</span><br><span class="line">    +-- optional-plugins</span><br><span class="line">         apm-gson-2.x-plugin.jar</span><br><span class="line">         .....</span><br><span class="line">    +-- bootstrap-plugins</span><br><span class="line">         jdk-http-plugin.jar</span><br><span class="line">         .....</span><br><span class="line">    +-- logs</span><br><span class="line">    skywalking-agent.jar</span><br></pre></td></tr></table></figure><p>高级功能： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.默认日志输出到 logs 目录下。</span></span><br><span class="line"><span class="comment"># 2.所有支持的插件都存在 agent/plugins 目录下，在这个目录下移除插件jar包，这个插件将被禁用。（支持可插拔）</span></span><br></pre></td></tr></table></figure><h2 id="在Tomcat-上部署-JavaAgent"><a href="#在Tomcat-上部署-JavaAgent" class="headerlink" title="在Tomcat 上部署 JavaAgent"></a>在Tomcat 上部署 JavaAgent</h2><p>上传Agent目录到指定的Tomcat 器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]<span class="comment"># ll</span></span><br><span class="line">total 20248</span><br><span class="line">drwxrwxr-x.  8 mysql 1002      143 Mar  8 22:01 agent</span><br></pre></td></tr></table></figure><p>配置Agent配置文件，conf/agent.conf 设置<code>agent.service_name</code>、<code>collector.backend_service</code>;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]<span class="comment"># vim /opt/agent/config/agent.config</span></span><br><span class="line"><span class="comment"># The service name in UI</span></span><br><span class="line">agent.service_name=<span class="variable">$&#123;SW_AGENT_NAME:Tomcat-9&#125;</span></span><br><span class="line"><span class="comment"># Backend service addresses.  # 你的远程SkyWalking 服务器</span></span><br><span class="line">collector.backend_service=<span class="variable">$&#123;SW_AGENT_COLLECTOR_BACKEND_SERVICES:127.0.0.1:11800&#125;</span></span><br></pre></td></tr></table></figure><p>启动Tomcat服务。</p><p>在远程SkyWalking 服务器通过端口查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@example ~]<span class="comment"># netstat -natpl| grep java</span></span><br><span class="line">tcp6       0      0 192.168.2.106:11800     192.168.2.115:42108     ESTABLISHED 4091/java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注： 正常启动java应用，带上如下参数：</span></span><br><span class="line">java -javaagent:/path/to/agent/skywalking-agent.jar <span class="variable">$yourApp</span>.jar</span><br></pre></td></tr></table></figure><h2 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h2><ol><li>先启动 <code>ElasticSearch</code></li><li>再启动 <code>SkyWalking</code></li><li>最后启动加入探针的微服务程序</li></ol><hr><h1 id="其他配置案例"><a href="#其他配置案例" class="headerlink" title="其他配置案例"></a>其他配置案例</h1><h2 id="SpringCloud集成SkyWalking"><a href="#SpringCloud集成SkyWalking" class="headerlink" title="SpringCloud集成SkyWalking"></a>SpringCloud集成SkyWalking</h2><p>参考文章<a href="https://blog.csdn.net/WALK_MAN_wubiao/article/details/105426926">SpringCloud集成Skywalking</a></p><ol><li><p>下载解压apache-skywalking-apm-bin，比如安装解压在 D:/IDEA/skywalking/apache-skywalking-apm-bin</p></li><li><p>更新SpringBoot启动参数，可以在IDEA里面直接添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:D:/IDEA/skywalking/apache-skywalking-apm-bin/agent/skywalking-agent.jar </span><br><span class="line">-Dskywalking.agent.service_name=test-demo-eureka             <span class="comment"># 名称自定义，一般和application.name一致</span></span><br><span class="line">-Dskywalking.collector.backend_service=localhost:11800         <span class="comment"># 端口IP指向部署skywalking，skywalking-oap</span></span><br></pre></td></tr></table></figure></li><li><p>重新启动应用，再Skywalking管理台查看服务和应用探针是否正常</p></li></ol><h2 id="在Java服务中配置-Agent"><a href="#在Java服务中配置-Agent" class="headerlink" title="在Java服务中配置 Agent"></a>在Java服务中配置 Agent</h2><p>参考文章<a href="https://blog.csdn.net/xjk201/article/details/104988958">skywalking的接入微服务</a>、推荐文章<a href="https://www.alibabacloud.com/help/zh/opentelemetry/user-guide/use-skywalking-to-report-java-application-data#1aa421c948t3t">通过SkyWalking上报Java应用数据</a></p><p><strong>1.配置</strong></p><p>将apache-skywalking-apm-bin/agent下文件copy到Java服务器上，放到指定目录下，配置agent/config/agent.config，设置skywalking服务地址，见下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The service name in UI</span></span><br><span class="line">agent.service_name=<span class="variable">$&#123;SW_AGENT_NAME:Your_ApplicationName&#125;</span></span><br><span class="line"><span class="comment"># Backend service addresses.  # 你的远程SkyWalking 服务器</span></span><br><span class="line">collector.backend_service=<span class="variable">$&#123;SW_AGENT_COLLECTOR_BACKEND_SERVICES:127.0.0.1:11800&#125;</span></span><br></pre></td></tr></table></figure><p>在agent.service_name配置你的服务名称，用于在skywalking UI显示，配置collector.backend_service选项，配置skywalking服务地址和端口，用于agient上报数据。 </p><p><strong>2.启动</strong></p><p>在java启动命令里加上 -javaagent:[jar包目录]/agent/skywalking-agent.jar<br>启动完成后，可以观察 Web UI看数据是否上报OK</p><h2 id="Docker部署Agent"><a href="#Docker部署Agent" class="headerlink" title="Docker部署Agent"></a>Docker部署Agent</h2><p>转载自<a href="https://blog.csdn.net/WALK_MAN_wubiao/article/details/105426867">Docker安装Skywalking</a></p><ol><li><p>下载镜像：我本地下载的镜像打了tag </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/anoy/skywalking-ui </span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/anoy/skywalking-oap</span><br></pre></td></tr></table></figure></li><li><p>运行镜像：账户密码（admin/admin，密码自己定义） </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name skywalking-oap -p 11800:11800 -e TZ=Asia/Shanghai skywalking-oap </span><br><span class="line">docker run -d --name skywalking-ui --<span class="built_in">link</span> skywalking-oap:skywalking-oap -p 8088:8080 -e TZ=Asia/Shanghai skywalking-ui --collector.ribbon.listOfServers=skywalking-oap:12800 --security.user.admin.password=admin</span><br></pre></td></tr></table></figure></li><li><p>查看应用是否正常启动</p></li></ol><h2 id="SkyWalking-透传-kafka的-Agent"><a href="#SkyWalking-透传-kafka的-Agent" class="headerlink" title="SkyWalking 透传 kafka的 Agent"></a>SkyWalking 透传 kafka的 Agent</h2><ol><li><p><strong>‌安装Kafka和Zookeeper‌</strong>  </p><p>Kafka和Zookeeper是SkyWalking使用Kafka进行数据传输所必需的。 </p></li><li><p><strong>移动Kafka插件‌</strong></p><p>将Kafka插件移动到plugins目录‌：将SkyWalking agent的optional-reporter-plugins目录下的kafka-reporter-plugin-x.x.x.jar（x.x.x代表版本号）移动到plugins目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> optional-reporter-plugins/kafka-reporter-plugin-x.x.x.jar plugins/</span><br></pre></td></tr></table></figure></li><li><p><strong>编辑agent.conf‌</strong></p><p>在SkyWalking agent的config目录下，找到agent.conf配置文件。需要添加或修改以下配置项以启用Kafka上报:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># agent.conf 文件中的部分配置</span></span><br><span class="line"><span class="attr">plugin.kafka.bootstrap_servers</span>=<span class="string">localhost:9092</span></span><br><span class="line"><span class="attr">plugin.kafka.namespace</span>=<span class="string">skywalking-logs</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 另外配置了地址的，用引用方式</span></span><br><span class="line"><span class="comment"># 配置Kafka服务地址</span></span><br><span class="line"><span class="attr">plugin.kafka.bootstrap_servers</span>=<span class="string">$&#123;SW_KAFKA_BOOTSTRAP_SERVERS:localhost:9092&#125;</span></span><br><span class="line"><span class="comment"># 配置Kafka的Topic</span></span><br><span class="line"><span class="attr">plugin.kafka.namespace</span>=<span class="string">$&#123;SW_KAFKA_NAMESPACE:skywalking-logs&#125;</span></span><br></pre></td></tr></table></figure><p>注意：确保Kafka服务正在运行，并且你使用的端口与bootstrap_servers配置中的端口相匹配。</p></li><li><p><strong>启动应用</strong>‌：<br>使用带有SkyWalking agent的JVM参数启动你的应用。SkyWalking agent将开始收集数据，并通过Kafka发送到OAP服务器。  </p></li><li><p> <strong>验证Kafka透传是否成功</strong></p></li></ol><p>   要验证Kafka透传是否成功，你可以使用Kafka命令行工具来检查数据是否已被成功发送到指定的Topic中。你可以使用如下命令：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic skywalking-logs --from-beginning</span><br></pre></td></tr></table></figure><p>   如果一切配置正确，你将能看到SkyWalking agent发送的跟踪数据在控制台上滚动显示。</p><h2 id="skywalking监控中间件redis"><a href="#skywalking监控中间件redis" class="headerlink" title="skywalking监控中间件redis"></a>skywalking监控中间件redis</h2><p>参考文章<a href="https://blog.51cto.com/u_16213425/8958628">skywalking监控中间件redis</a></p><ol><li><p>配置SkyWalking Agent：步骤同上 Java Agent 部署</p></li><li><p>配置Redis</p><p>在监控Redis之前，需要为Redis启用Trace功能，并配置Trace的采样率。 对于使用Spring Boot的应用程序，你可以在<code>application.properties</code>文件中添加以下配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">your-application-name</span></span><br><span class="line"><span class="comment"># SkyWalking配置</span></span><br><span class="line"><span class="attr">skywalking.trace.redis.host</span>=<span class="string">your-redis-host</span></span><br><span class="line"><span class="attr">skywalking.trace.redis.port</span>=<span class="string">your-redis-port</span></span><br><span class="line"><span class="attr">skywalking.trace.redis.sample-rate</span>=<span class="string">0.5</span></span><br></pre></td></tr></table></figure></li><li><p>启动SkyWalking Agent</p><p>在Agent安装目录下，找到skywalking-agent.jar的文件。通过以下命令启动Agent：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar skywalking-agent.jar</span><br></pre></td></tr></table></figure></li><li><p>查看监控数据</p><p>一旦SkyWalking Agent启动成功，它将会开始收集和发送监控数据到SkyWalking服务器。 你可以通过访问SkyWalking的Web界面来查看监控数据。在浏览器中输入<a href="http://localhost:8080，即可访问SkyWalking的控制台。">http://localhost:8080，即可访问SkyWalking的控制台。</a> 在控制台中选择查看Redis相关的监控数据，如请求数、响应时间等。</p></li></ol><hr><h1 id="SkyWalking探针采集数据如何收集"><a href="#SkyWalking探针采集数据如何收集" class="headerlink" title="SkyWalking探针采集数据如何收集"></a>SkyWalking探针采集数据如何收集</h1><p>参考文章<a href="https://blog.csdn.net/huxian1234/article/details/135568041">布式链路追踪：Skywalking 探针模型设计</a></p><p>既然是分布式链路平台，那么数据收集肯定的核心功能，在 Skywalking 中，数据是通过探针侵入业务，然后通过通信通道传输到 OAP Server 端。针对每一个探针，其实收集的逻辑都不太一样，这里我就重点分析下常用技术中间件的探针数据是如何收集的。</p><h2 id="gateway-2-1-x-plugin"><a href="#gateway-2-1-x-plugin" class="headerlink" title="gateway-2.1.x-plugin"></a>gateway-2.1.x-plugin</h2><p>Spring Cloud Gateway 是一个非常火的服务治理网关，所以 Skywalking 肯定是要支持对它的性能数据的采集。</p><ol><li><strong>定义探针</strong> <code>FilteringWebHandlerInstrumentation</code>，用于增强 org.springframework.cloud.gateway.handler.FilteringWebHandler，拦截 FilteringWebHandler 中以 handle 开头的方法。</li><li><strong>定义拦截器</strong> <code>FilteringWebHandlerInterceptor</code>，在 beforeMethod 方法中植入需要采集的数据，从 allArguments 参数中，获取到当前网关路由的 ServerWebExchange，然后拼装 operationName，例如： operationName + route.getId()。</li><li>**<code>HttpClientOperationsSendInterceptor</code>**，创建 AbstractSpan 并设置组件类型为 ComponentsDefine.SPRING_CLOUD_GATEWAY，最后调用 ContextManager.stopSpan(span) 存储链路数据。</li></ol><h2 id="dubbo-2-7-x-plugin"><a href="#dubbo-2-7-x-plugin" class="headerlink" title="dubbo-2.7.x-plugin"></a>dubbo-2.7.x-plugin</h2><p>Dubbo 框架肯定是得支持的，如何支持？</p><ol><li><strong>定义探针</strong> <code>DubboInstrumentation</code>，并增强类 org.apache.dubbo.monitor.support.MonitorFilter，这个类是 Dubbo 服务治理的核心类，拦截的方法必须是要含有 invoke 字段。</li><li><strong>拦截器</strong> <code>DubboInterceptor</code>，通过 beforeMethod，获取到 Invoker、Invocation 和 RpcContext，然后再区分是消费者还是提供者，如果是消费者，那么就是 ExitSpan，如果是提供者就是 EntrySpan，从链路数据流向来看，消费者是出去，而提供者流量是流入。createExitSpan 和 createEntrySpan，就会植入一些性能采集指标，比如 RT 等。</li></ol><h2 id="jedis-2-x-plugin"><a href="#jedis-2-x-plugin" class="headerlink" title="jedis-2.x-plugin"></a>jedis-2.x-plugin</h2><ol><li><strong>定义探针</strong>:<code>JedisInstrumentation</code>，这个探针用于植入类 redis.clients.jedis.Jedis。</li><li><strong>定义一批特殊处理的拦截器</strong>——最常规的拦截器就是 <code>JedisMethodInterceptor</code>，并通过 beforeMethod、afterMethod 和 handleMethodException 采集链路信息。</li></ol><p>其他组件基本都是一样的，都是通过基于字节码的 AOP 技术来植入链路采集数据。</p><p>关于 Skywalking 探针的链路数据采集我们需要知道底层核心，我在这里就列举下：</p><ol><li><p><strong>StaticMethodsInter</strong></p><p>用于拦截类实例方法的实际字节 buddy 拦截器。这个类用于连接 Byte-buddy 和 Skywalking plugin。</p></li><li><p><strong>ConstructorInter</strong></p><p>用于拦截构造函数方法的实际字节 buddy 拦截器，然后通过自定义 intercept 方法逻辑，调用拦截器的 onConstruct 逻辑，完成基于构造函数的请求拦截。</p></li><li><p><strong>InstMethodsInter</strong></p><p>用于拦截实例方法的实际字节 buddy 拦截器，自定义 intercept 方法，然后再方法中国封装拦截器对 beforeMethod、handleMethodException 和 afterMethod 这三个方法的调用。</p></li></ol>]]></content>
    
    
    <summary type="html">SkyWalking 属于中间件范畴，主要用于分布式系统中的链路追踪和性能监控。</summary>
    
    
    
    <category term="Middleware" scheme="https://southernfish.github.io/categories/Middleware/"/>
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="SkyWalking" scheme="https://southernfish.github.io/tags/SkyWalking/"/>
    
  </entry>
  
  <entry>
    <title>Springboot项目+JDK17打包exe</title>
    <link href="https://southernfish.github.io/2025/07/08/blog/jar-jpackage-exe/"/>
    <id>https://southernfish.github.io/2025/07/08/blog/jar-jpackage-exe/</id>
    <published>2025-07-08T07:27:36.000Z</published>
    <updated>2025-07-09T06:58:59.932Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了在Java17环境下，使用java14引入的jpackage工具，生成包含所有依赖的Java应用程序映像，包括支持Windows和macOS平台，包括exe、dmg和msi格式。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ol><li><p>使用 mvn package 打包成 jar</p><p>在项目下生成target目录，且包含打包成的jar（例如：standard-0.0.1-SNAPSHOT.jar）,确认这个jar能使用”java -jar ***.jar”运行。用<code>idea2025</code>打开项目，进入界面右侧的<code>maven</code>目录，使用嗯项目的<code>lifecycle</code>目录下的<code>package</code>。</p></li><li><p>下载安装 JDK<br>JPackage指令是JAVA 14新增的，所以安装的JAVA版本必须14+，我是用的是 jdk-17.0.12_windows-x64_bin.zip。JDK17的环境变量配置：</p><pre><code>新增系统变量：JAVA_HOME，值为D:\IDEA\Java\jdk-17（安装路径）；新增系统变量：CLASSPATH，值为.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar，注意最前面的小黑点不能省.在系统变量Path下新增两条配置：%JAVA_HOME%\bin和%JAVA_HOME%\jre\bin</code></pre></li><li><p>下载安装 wix314.exe</p><p>下载路径为：<a href="https://github.com/wixtoolset/wix3/releases">Release WiX Toolset v3.14</a>找到<code>Assets</code>下载即可。安装前需要在电脑的 控制面板 →  程序和功能 →  启用或关闭Windows功能 →  勾选<code>.NET Framework 3.5 (包括 ,NET 2.0 和 3.0)</code> →  确定，等待执行完成。之后再双击下载的<code>wix314.exe</code>，正常安装。</p></li></ol><h2 id="JPackage-指令"><a href="#JPackage-指令" class="headerlink" title="JPackage 指令"></a>JPackage 指令</h2><ol><li><p>打包exe(亲测有效)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\jpackage --<span class="built_in">type</span> exe --name csresUtil --input E:\WorkSpace\ByMyself\standard-util\target --main-jar standard-0.0.1-SNAPSHOT.jar --java-options <span class="string">&quot;-Dserver.port=8888  -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005&quot;</span> --win-console --win-dir-chooser --win-shortcut --win-shortcut-prompt --dest E:\dist</span><br></pre></td></tr></table></figure></li><li><p>打包msi</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\jpackage --<span class="built_in">type</span> msi --win-dir-chooser --name csresUtil --app-image E:\dist --dest E:\distmsi</span><br></pre></td></tr></table></figure></li><li><p>打包app-image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\jpackage --<span class="built_in">type</span> app-image --name import --input E:\WorkSpace\ByMyself\standard-util\target --main-jar standard-0.0.1-SNAPSHOT.jar --java-options <span class="string">&quot;-Dserver.port=8888 -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005&quot;</span> --win-console --dest E:\dist</span><br></pre></td></tr></table></figure></li><li><p>查看帮助：jpackage -h （以下Windows平台Java17下部分参数说明。 )</p><table><thead><tr><th>参数</th><th>作用</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>–type</td><td>打包类型</td><td>app-image</td><td>可选：”app-image”, “exe”, “msi”，这里使用app-image，选择另外两个选项需要安装WiX</td></tr><tr><td>–name</td><td>应用名称</td><td>spring</td><td>打包后的名称，如”sping.exe”</td></tr><tr><td>–input</td><td>输入目录</td><td>target</td><td>该目录所有文件打包到应用目录中</td></tr><tr><td>–main-jar</td><td>应用主jar</td><td>spring-1.0.jar</td><td>–input目录里的jar程序</td></tr><tr><td>-icon</td><td>指定图标</td><td>-icon</td><td>指定图标(如：avatar.ico)</td></tr><tr><td>–win-console</td><td>运行时启动控制台</td><td>–win-console</td><td>打开应用程序时，打开控制台。如果不启用在后台运行，关闭只能从任务管理器中结束任务</td></tr><tr><td>–win-dir-chooser</td><td>在安装程序的时候可以选安装目录</td><td>–win-dir-chooser</td><td>在安装程序的时候可以选安装目录</td></tr><tr><td>–win-shortcut</td><td>创建桌面快捷方式</td><td>–win-shortcut</td><td>创建桌面快捷方式</td></tr><tr><td>–win-shortcut-prompt</td><td>在安装程序的时候可以选择是否创建桌面快捷方式</td><td>–win-shortcut-prompt</td><td>在安装程序的时候可以选择是否创建桌面快捷方式</td></tr><tr><td>–dest</td><td>输出目录</td><td>dist</td><td>输出到该目录，不要和–input同个目录，否则会无限循环复制目录</td></tr></tbody></table></li></ol>]]></content>
    
    
    <summary type="html">本文以 jpackage+ wix314.exe + jar包 打包一个可执行exe文件。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="jpackage" scheme="https://southernfish.github.io/tags/jpackage/"/>
    
  </entry>
  
  <entry>
    <title>ElasticStack Kafka 缓冲区</title>
    <link href="https://southernfish.github.io/2025/07/01/server/elatsticstack-kafka/"/>
    <id>https://southernfish.github.io/2025/07/01/server/elatsticstack-kafka/</id>
    <published>2025-07-01T12:30:36.000Z</published>
    <updated>2025-07-01T10:55:24.008Z</updated>
    
    <content type="html"><![CDATA[<p>‌Elastic Stack（原ELK Stack）是一套由Elastic公司开发的开源数据搜索、分析和可视化工具集合，核心组件包括Elasticsearch、Kibana、Beats和Logstash‌，广泛应用于日志分析、安全监控、业务智能等领域。‌‌‌‌ Logstash 能够动态地采集、转换和传输数据，不受格式或复杂度的影响。利用 Grok 从非结构化数据中派生出结构，从 IP 地址解码出地理坐标，匿名化或排除敏感字段，并简化整体处理过程。 参考文章：<a href="https://blog.csdn.net/Tracycoder/article/details/147423614">ElasticSearch深入解析（一）：Elastic Stack全景</a>、<a href="https://blog.csdn.net/shjwkzkzk/article/details/148403336">ElasticStack对接kafka集群</a></p><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kafka 是一种高性能的分布式消息队列系统，通过合理的配置和管理，可有效利用 Kafka 特性，满足企业对大规模<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E6%B5%81%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020">数据流处理</a>的需求。</p><ul><li><strong>高吞吐<code>(海量读写数据,缺点：不支持对象类型传输...)</code>、</strong><a href="https://cloud.tencent.com/product/ckafka?from_column=20065&from=20065"><strong>分布式消息系统</strong></a></li><li><strong>概念：<code>Producer：生产者(消息的来源)</code></strong> <strong><code>Consumer：消费者(消息输出)</code></strong> <strong><code>Topic：主题(消息传递的约定)</code></strong></li><li><strong>消息系统介绍</strong> 一个消息系统负责将数据从一个应用传递到另外一个应用， 应用只需关注于数据，无需关注数据在两个或多个应用间是如何传递的。 <strong>有两种主要的消息传递模式：<code>点对点传递模式、</code></strong> <strong><code>发布-订阅模式。(kafka采用)</code></strong></li></ul><h2 id="ELK-为什么要结合Kafka"><a href="#ELK-为什么要结合Kafka" class="headerlink" title="ELK 为什么要结合Kafka"></a>ELK 为什么要结合Kafka</h2><p>‌ELK（Elasticsearch、Logstash、Kibana）结合 Kafka的主要原因是为了解决日志采集和处理的性能和扩展性问题‌。 在Kafka中，每个topic都有一个或多个partition，而每个partition都有一个Leader副本。Leader副本负责处理该partition的所有读写请求。当Kafka集群中的节点发生故障时，Leader副本会进行选举，以确保集群的稳定性和数据的持久性。</p><p><strong>Kafka在ELK架构中的作用</strong></p><ul><li><strong>数据缓冲和扩展性‌：</strong>Kafka 作为一个高吞吐量的分布式消息系统，能够<strong>均衡网络传输，降低网络闭塞的风险</strong>，确保数据不丢失，并且为系统之间的解耦提供了更好的灵活性和扩展性‌。 </li><li><strong>异步处理‌：</strong>通过 Kafka 进行日志的异步传输，可以<strong>减少对本地磁盘I/O的影响</strong>，提高系统的整体性能和稳定性‌。 </li><li><strong>峰值处理能力‌：</strong>Kafka 能够使关键组件顶住突发的访问压力，避免因突发超负荷请求而崩溃‌。  </li></ul><p><strong>Kafka在日志处理流程中的具体作用</strong> </p><ul><li><strong>日志收集‌：</strong> Filebeat收集日志，并将其发送到Kafka‌。 </li><li><strong>日志传输‌：</strong>Kafka作为消息队列，缓存日志数据，确保数据的可靠传输和存储‌。 </li><li><strong>日志处理‌：</strong> Logstash订阅 Kafka 的主题，获取日志消息内容，并将其格式化和存储到 Elasticsearch 中‌。</li></ul><hr><h1 id="Kafka集群部署"><a href="#Kafka集群部署" class="headerlink" title="Kafka集群部署"></a>Kafka集群部署</h1><h2 id="单点部署-Kafka"><a href="#单点部署-Kafka" class="headerlink" title="单点部署 Kafka"></a>单点部署 Kafka</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.下载并解压</span></span><br><span class="line"><span class="comment"># 下载 Kafka</span></span><br><span class="line">wget https://dlcdn.apache.org/kafka/3.9.0/kafka_2.13-3.9.0.tgz</span><br><span class="line"><span class="comment"># 解压 Kafka</span></span><br><span class="line">tar xf kafka_2.13-3.9.0.tgz -C /usr/local/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.修改配置文件</span></span><br><span class="line"><span class="comment"># Kafka 的唯一标识</span></span><br><span class="line">broker.id=91 </span><br><span class="line"><span class="comment"># 修改数据目录</span></span><br><span class="line">log.dirs=/var/lib/kafka</span><br><span class="line"><span class="comment"># 指定 Kafka 的元数据存储在 Zookeeper 集群的路径(znodes)</span></span><br><span class="line">zookeeper.connect=10.0.0.91:2181,10.0.0.92:2181,10.0.0.93:2181/oldboyedu-kafka-3.9.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.配置环境变量</span></span><br><span class="line">[root@elk91 ~]<span class="comment"># cat /etc/profile.d/kafka.sh</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">export</span> KAFKA_HOME=/usr/local/kafka_2.13-3.9.0</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$KAFKA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.启动并验证是否成功</span></span><br><span class="line"><span class="comment"># 启动 kafka</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/kafka.sh</span><br><span class="line">kafka-server-start.sh -daemon <span class="variable">$KAFKA_HOME</span>/config/server.properties </span><br><span class="line"><span class="comment"># 验证 Kafka 是否启动成功</span></span><br><span class="line">ss -ntl | grep 9092</span><br><span class="line"><span class="comment"># 出现如下则成功</span></span><br><span class="line"><span class="comment"># LISTEN 0      50                      *:9092             *:*          </span></span><br></pre></td></tr></table></figure><h2 id="集群部署-Kafka"><a href="#集群部署-Kafka" class="headerlink" title="集群部署 Kafka"></a>集群部署 Kafka</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、拷贝 Kafka 数据到集群节点（92/93）</span></span><br><span class="line"><span class="comment"># [root@elk91 ~]# </span></span><br><span class="line">scp -r /usr/local/kafka_2.13-3.9.0/ 10.0.0.92:/usr/local/</span><br><span class="line">scp -r /usr/local/kafka_2.13-3.9.0/ 10.0.0.93:/usr/local/</span><br><span class="line">scp /etc/profile.d/kafka.sh 10.0.0.92:/etc/profile.d/</span><br><span class="line">scp /etc/profile.d/kafka.sh 10.0.0.93:/etc/profile.d/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、修改 92/93 节点的配置文件 </span></span><br><span class="line"><span class="comment"># [root@elk92 ~]# ：2、修改 92 节点的配置文件 </span></span><br><span class="line">sed -i <span class="string">&#x27;/^broker.id/s#91#92#&#x27;</span> /usr/local/kafka_2.13-3.9.0/config/server.properties </span><br><span class="line"><span class="comment"># [root@elk93 ~]# ：修改 93 节点的配置文件</span></span><br><span class="line">sed -i <span class="string">&#x27;/^broker.id/s#91#93#&#x27;</span> /usr/local/kafka_2.13-3.9.0/config/server.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、启动其他节点的 Kafka </span></span><br><span class="line"><span class="comment"># [root@elk92 ~]# ：启动92节点的 Kafka </span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/kafka.sh &amp;&amp; kafka-server-start.sh -daemon <span class="variable">$KAFKA_HOME</span>/config/server.properties </span><br><span class="line"><span class="comment"># [root@elk93 ~]# ：启动93节点的 Kafka </span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/kafka.sh &amp;&amp; kafka-server-start.sh -daemon <span class="variable">$KAFKA_HOME</span>/config/server.properties </span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、验证 Zookeeper 集群数据是否写入成功 </span></span><br><span class="line"><span class="comment"># [root@elk91 ~]# </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ls /oldboyedu-kafka-3.9.0&quot;</span> | nc 10.0.0.91 2181</span><br></pre></td></tr></table></figure><hr><h1 id="ELK-对接Kafka集群"><a href="#ELK-对接Kafka集群" class="headerlink" title="ELK 对接Kafka集群"></a>ELK 对接Kafka集群</h1><p>ELK（Elasticsearch、Logstash、Kibana）。</p><p>此处探讨如何通过这一架构优化，实现高效、可靠且可扩展的日志处理解决方案，以应对日益增长的数据量和复杂多变的业务需求，同时减轻Logstash压力并降低其与Filebeat的耦合性，提升整个系统的性能与稳定性，为企业的数据驱动决策提供坚实的技术支撑。</p><p><strong>Kafka集群特性适配 ：</strong>Kafka具备<strong>高吞吐量</strong>（如单机每秒可处理10w + /s）、<strong>高可用性</strong>（通过多副本机制保障数据不丢失）、<strong>强扩展性</strong>（可方便地进行集群扩展以应对数据增长）以及<strong>丰富的生态集成能力</strong>（与多种编程语言和工具兼容良好）等特点，使其成为对接ELK的理想选择。其强大的消息队列功能能够很好地<strong>满足日志数据海量、实时性要求高的处理需求</strong>，确保数据在产生端（如Filebeat采集的日志）和消费端（如Logstash后续处理）之间的高效流转和可靠存储。</p><h2 id="架构图解"><a href="#架构图解" class="headerlink" title="架构图解"></a>架构图解</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250630173309605.png" alt="image-20250630173309605"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">为了减轻Logstash压力以及Logstash和filebeat的耦合性，考虑在Logstash前面加一套MQ集群。</span><br><span class="line">所谓的MQ，指的是Message Queue，即消息队列。但是这种架构无疑是给系统增加了负担：</span><br><span class="line">    1.MQ不存在单点问题；</span><br><span class="line">    2.MQ具有很强的处理数据能力；</span><br><span class="line">    3.增加了集群的整体复杂性，运维和开发的同学都得增加学习成本；</span><br><span class="line"></span><br><span class="line">也就是说，这意味消息队列要提供以下特性：</span><br><span class="line">    1.MQ集群吞吐量大，能够承担数据的读写；5台32core，32GB读取处理消息数量23w/s，写速度可以达到220m/s，</span><br><span class="line">    2.MQ集群要提供非常强的高可用性，不能是单点的故障；</span><br><span class="line">    3.文档丰富，社区资源丰富；</span><br><span class="line"></span><br><span class="line">市面上有很多MQ产品，典型代表有：</span><br><span class="line">    RocketMQ【阿里巴巴，有社区版（功能较差，文档不够丰富，仅支持Java相关的API）和SAAS版本（功能强，需要花钱），性能很好，单机每秒能够处理10w+/s】</span><br><span class="line">    ActiveMQ【老牌系统，文档相对丰富，性能一般，单机每秒处理1w+/s】</span><br><span class="line">    Kafka【日志收集，大数据分析，性能非常好，单机每秒处理10w+/s，存在丢失数据的风险，但可以忽略不计，API文档非常丰富，基于Java和Scala语言研发，二次开发比较方便，社区完善了Golang，Python等API】</span><br><span class="line">    RabbitMQ【金融公司，文档丰富，性能较好，单机每秒处理1w+/s，可以做到数据不丢失，API开发相对来说不太友好，基于Erlang语言研发，国内并不流行，因此二次开发招人比较困难。】</span><br></pre></td></tr></table></figure><h2 id="架构实现"><a href="#架构实现" class="headerlink" title="架构实现"></a>架构实现</h2><p>首先需要有一套kafka集群，Elasticsearch、Logstash、Kibana都已安装。</p><ol><li><p><strong>filebeat生产kafka集群数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写filebeat并启动</span></span><br><span class="line">[root@elk93 /etc/filebeat/config]<span class="comment"># cat filebeat_tcp-to-kafka.yaml .</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: tcp</span><br><span class="line">  host: <span class="string">&quot;0.0.0.0:9000&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 数据输出到kafka</span></span><br><span class="line">output.kafka:</span><br><span class="line">  <span class="comment"># 指定kafka集群的地址</span></span><br><span class="line">  hosts: </span><br><span class="line">  - 10.0.0.91:9092</span><br><span class="line">  - 10.0.0.92:9092</span><br><span class="line">  - 10.0.0.93:9092</span><br><span class="line"> </span><br><span class="line">  <span class="comment"># 指定topic</span></span><br><span class="line">  topic: novacao-linux96-kafka</span><br><span class="line">  </span><br><span class="line">[root@elk93 /etc/filebeat/config]<span class="comment"># rm -rf /var/lib/filebeat/</span></span><br><span class="line">[root@elk93 /etc/filebeat/config]<span class="comment"># filebeat -e -c `pwd`/filebeat_tcp-to-kafka.yaml</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 发送测试数据</span></span><br><span class="line">[root@elk91 ~]<span class="comment"># echo helllllllllllllllo |nc 10.0.0.93 9000</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># kafka验证数据</span></span><br><span class="line">[root@elk92 ~]<span class="comment"># kafka-console-consumer.sh --bootstrap-server 10.0.0.93:9092 --topic novacao-linux96-kafka --from-beginning</span></span><br><span class="line">.....</span><br><span class="line">&#123;<span class="string">&quot;@timestamp&quot;</span>:<span class="string">&quot;2025-03-17T12:35:18.320Z&quot;</span>,<span class="string">&quot;@metadata&quot;</span>:&#123;<span class="string">&quot;beat&quot;</span>:<span class="string">&quot;filebeat&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;_doc&quot;</span>,<span class="string">&quot;version&quot;</span>:<span class="string">&quot;7.17.28&quot;</span>&#125;,<span class="string">&quot;log&quot;</span>:&#123;<span class="string">&quot;source&quot;</span>:&#123;<span class="string">&quot;address&quot;</span>:<span class="string">&quot;10.0.0.91:55810&quot;</span>&#125;&#125;,<span class="string">&quot;input&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;tcp&quot;</span>&#125;,<span class="string">&quot;agent&quot;</span>:&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;elk93&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;filebeat&quot;</span>,<span class="string">&quot;version&quot;</span>:<span class="string">&quot;7.17.28&quot;</span>,<span class="string">&quot;hostname&quot;</span>:<span class="string">&quot;elk93&quot;</span>,<span class="string">&quot;ephemeral_id&quot;</span>:<span class="string">&quot;73d1dee2-d555-4955-b689-75d602e1b5e0&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;ced21de3-ed8a-4601-acba-07f0d7db5a5a&quot;</span>&#125;,<span class="string">&quot;ecs&quot;</span>:&#123;<span class="string">&quot;version&quot;</span>:<span class="string">&quot;1.12.0&quot;</span>&#125;,<span class="string">&quot;host&quot;</span>:&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;elk93&quot;</span>&#125;,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;helllllllllllllllo&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Logstash消费kafka集群数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kibana基于开发工具创建账号</span></span><br><span class="line">POST /_security/api_key</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Linux96&quot;</span>, </span><br><span class="line">  <span class="string">&quot;role_descriptors&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;filebeat_monitoring&quot;</span>: &#123; </span><br><span class="line">      <span class="string">&quot;cluster&quot;</span>: [<span class="string">&quot;all&quot;</span>],</span><br><span class="line">      <span class="string">&quot;index&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;names&quot;</span>: [<span class="string">&quot;novacao-logstash-kafka*&quot;</span>],</span><br><span class="line">          <span class="string">&quot;privileges&quot;</span>: [<span class="string">&quot;all&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 生成实例</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;id&quot;</span> : <span class="string">&quot;QSYgpJUBD3ll3qToqN4V&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;Linux96&quot;</span>,</span><br><span class="line">  <span class="string">&quot;api_key&quot;</span> : <span class="string">&quot;EWyBlHEHTnSQlALuB41hpw&quot;</span>,</span><br><span class="line">  <span class="string">&quot;encoded&quot;</span> : <span class="string">&quot;UVNZZ3BKVUJEM2xsM3FUb3FONFY6RVd5QmxIRUhUblNRbEFMdUI0MWhwdw==&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 解码数据</span></span><br><span class="line">[root@elk91 ~]<span class="comment"># echo UVNZZ3BKVUJEM2xsM3FUb3FONFY6RVd5QmxIRUhUblNRbEFMdUI0MWhwdw== |base64 -d ;echo</span></span><br><span class="line">QSYgpJUBD3ll3qToqN4V:EWyBlHEHTnSQlALuB41hpw</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Logstash消费数据</span></span><br><span class="line">[root@elk93 /etc/logstash/conf.d]<span class="comment"># cat 09-logstash-to-ES_api-keys.conf</span></span><br><span class="line">input &#123; </span><br><span class="line">  kafka &#123;</span><br><span class="line">    <span class="comment"># 指定kafka集群的地址</span></span><br><span class="line">    bootstrap_servers =&gt; <span class="string">&quot;10.0.0.91:9092,10.0.0.92:9092,10.0.0.93:9092&quot;</span></span><br><span class="line">    <span class="comment"># 指定从kafka哪个topic拉取数据</span></span><br><span class="line">    topics =&gt; [<span class="string">&quot;novacao-linux96-kafka&quot;</span>]</span><br><span class="line">    <span class="comment"># 指定消费者组</span></span><br><span class="line">    group_id =&gt; <span class="string">&quot;linux96-001&quot;</span></span><br><span class="line">    <span class="comment"># 指定拉取数据offset的位置点，常用值：earliest(从头拉取数据)，latest(从最新的位置拉取数据)</span></span><br><span class="line">    auto_offset_reset =&gt; <span class="string">&quot;earliest&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  json &#123;</span><br><span class="line">    <span class="built_in">source</span> =&gt; <span class="string">&quot;message&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  mutate &#123;</span><br><span class="line">     remove_field =&gt; [ <span class="string">&quot;agent&quot;</span>,<span class="string">&quot;@version&quot;</span>,<span class="string">&quot;ecs&quot;</span>,<span class="string">&quot;input&quot;</span>,<span class="string">&quot;log&quot;</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">output &#123; </span><br><span class="line"> <span class="comment"># stdout &#123; </span></span><br><span class="line"> <span class="comment">#   codec =&gt; rubydebug </span></span><br><span class="line"> <span class="comment"># &#125; </span></span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [<span class="string">&quot;10.0.0.91:9200&quot;</span>,<span class="string">&quot;10.0.0.92:9200&quot;</span>,<span class="string">&quot;10.0.0.93:9200&quot;</span>]</span><br><span class="line">    index =&gt; <span class="string">&quot;novacao-logstash-kafka&quot;</span></span><br><span class="line">    api_key =&gt; <span class="string">&quot;QSYgpJUBD3ll3qToqN4V:EWyBlHEHTnSQlALuB41hpw&quot;</span></span><br><span class="line">    ssl =&gt; <span class="literal">true</span></span><br><span class="line">    ssl_certificate_verification =&gt; <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 启用logstash</span></span><br><span class="line">[root@elk93 /etc/logstash/conf.d]<span class="comment"># logstash -rf 09-logstash-to-ES_api-keys.conf </span></span><br></pre></td></tr></table></figure></li><li><p><strong>Kibana查看数据</strong>：<a href="http://localhost:5601/">http://localhost:5601/</a></p></li></ol>]]></content>
    
    
    <summary type="html">ElasticStack</summary>
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="ElasticStack" scheme="https://southernfish.github.io/tags/ElasticStack/"/>
    
  </entry>
  
  <entry>
    <title>ElasticStack kibana可视化处理</title>
    <link href="https://southernfish.github.io/2025/07/01/server/elatsticstack-kibana/"/>
    <id>https://southernfish.github.io/2025/07/01/server/elatsticstack-kibana/</id>
    <published>2025-07-01T11:00:36.000Z</published>
    <updated>2025-07-02T06:42:14.067Z</updated>
    
    <content type="html"><![CDATA[<p>Kibana 是为 <a href="https://cloud.tencent.com/product/es?from=20065&from_column=20065">Elasticsearch</a>设计的开源分析和可视化平台。你可以使用 Kibana 来搜索，查看存储在 Elasticsearch 索引中的数据并与之交互，容易实现高级的<a href="https://cloud.tencent.com/product/bi?from=20065&from_column=20065">数据分析</a>和可视化，以图标的形式展现出来。在生产环境中，Kibana的仪表盘功能能够帮助运维人员快速发现系统异常和性能瓶颈，为故障排查和性能优化提供有力支持。同时，Kibana的数据可视化功能还能够为业务人员提供直观的数据展示和分析工具，帮助他们更好地了解业务情况。参考文章：<a href="https://blog.csdn.net/wfcxhit/article/details/147591185">k8s部署ELK系列五：集成Kibana实现日志可视化</a>、<a href="https://cloud.tencent.com/developer/inventory/4446/article/1556663">ELK总结——第四篇Kibana的简介</a>、<a href="https://blog.csdn.net/Lemon__ing/article/details/148667480">ELK日志文件分析系统——K(Kibana)</a></p><h1 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kibana是一个基于Web的数据<a href="https://cloud.baidu.com/product/sugar.html">可视化工具</a>，它能够与Elasticsearch无缝集成，通过友好的用户界面为用户提供实时数据分析、监控和可视化等功能。Kibana不仅提供了丰富的图表类型，如柱状图、折线图、饼图等，还支持自定义仪表盘和视图，让用户能够根据自己的需求快速创建和展示数据。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h2><ul><li><p><strong>实时监控</strong>通过 histogram 面板，配合不同条件的多个 queries 可以对一个事件走很多个维度组合出不同的<strong>时间序列</strong>走势。时间序列数据是最常见的监控报警了。</p></li><li><p><strong>问题分析</strong>关于 elk 的用途，可参照其对应的商业产品 splunk 的场景：使用 Splunk 的意义在于使<strong>信息收集和处理智能化</strong>。</p><p>其操作智能化表现在：</p><ul><li><p><strong>搜索</strong>通过下钻数据排查问题，通过分析根本原因来解决问题；</p></li><li><p><strong>实时可见性</strong>可以将对系统的检测和警报结合在一起，便于跟踪 SLA 和性能问题；</p></li><li><p><strong>历史分析</strong>可以从中找出趋势和历史模式，行为基线和阈值，生成一致性报告。</p></li></ul></li></ul><h2 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a><strong>关键特性</strong></h2><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>‌<strong>多维度分析</strong>‌</td><td>支持时间序列、地理空间、文本等多类型数据交叉分析</td></tr><tr><td>‌<strong>实时仪表盘</strong>‌</td><td>可组合多个可视化组件，自动刷新数据（默认15秒间隔）</td></tr><tr><td>‌<strong>Dev Tools</strong>‌</td><td>内置Elasticsearch查询调试界面，支持DSL语法验证</td></tr><tr><td>‌<strong>机器学习集成</strong>‌</td><td>与Elastic ML模块联动，实现异常检测（如流量突增预警）</td></tr></tbody></table><h2 id="应用意义‌"><a href="#应用意义‌" class="headerlink" title="应用意义‌"></a>应用意义‌</h2><ul><li>‌<strong>降低数据分析门槛‌：</strong>通过拖拽界面替代SQL/DSL编写，使非技术人员快速生成报表</li><li>‌<strong>统一监控平台‌：</strong>整合日志（Nginx）、指标（Prometheus）等多源数据，实现全栈可观测性</li><li><strong>‌合规审计支持‌：</strong>记录用户操作日志（如查询历史），满足GDPR等法规要求</li></ul><h1 id="Linux环境下安装Kibana"><a href="#Linux环境下安装Kibana" class="headerlink" title="Linux环境下安装Kibana"></a>Linux环境下安装Kibana</h1><p>安装Kibana非常简单，只需按照官方<a href="https://cloud.baidu.com/product/doc.html">文档</a>的指引进行安装和配置即可。在配置Kibana时，需要指定Elasticsearch的地址和端口，以便Kibana能够与Elasticsearch进行通信。此处 Kibana 与 Elasticsearch 安装在同一主机，安装基本步骤如下：</p><h2 id="环境准备‌"><a href="#环境准备‌" class="headerlink" title="环境准备‌"></a><strong>环境准备</strong>‌</h2><ol><li><p>‌<strong>安装Java依赖（JRE 11+）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install openjdk-11-jre -y     <span class="comment"># 更新包列表并安装OpenJDK JRE</span></span><br><span class="line">java -version                                             <span class="comment"># 验证Java版本，输出需包含&quot;11.x.x&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建专用用户（可选但推荐）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd kibana_user     <span class="comment"># 新建用户避免root权限风险</span></span><br><span class="line">sudo passwd kibana_user     <span class="comment"># 设置用户密码</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="下载与安装‌"><a href="#下载与安装‌" class="headerlink" title="下载与安装‌"></a><strong>下载与安装</strong>‌</h2><ol><li><p>‌<strong>手动下载（通用方式）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-8.13.4-linux-x86_64.tar.gz     <span class="comment"># 下载二进制包</span></span><br><span class="line">tar -zxvf kibana-8.13.4-linux-x86_64.tar.gz -C /opt/                                     <span class="comment"># 解压到/opt目录</span></span><br><span class="line">sudo <span class="built_in">chown</span> -R kibana_user:kibana_user /opt/kibana-8.13.4                                 <span class="comment"># 赋权给专用用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令解析</span></span><br><span class="line">wget                <span class="comment"># 从Elastic官网下载指定版本Kibana。</span></span><br><span class="line">tar -zxvf            <span class="comment"># 解压压缩包（-z解压gzip，-x解包，-v显示过程，-f指定文件）。</span></span><br><span class="line"><span class="built_in">chown</span> -R            <span class="comment"># 递归修改目录所有权，确保Kibana进程权限合规。</span></span><br></pre></td></tr></table></figure></li><li><p>‌<strong>APT安装（Debian/Ubuntu推荐）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -  <span class="comment"># 添加Elastic GPG密钥</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://artifacts.elastic.co/packages/8.x/apt stable main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/elastic.list                                             <span class="comment"># 配置APT仓库</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt install kibana                                         <span class="comment"># 安装Kibana并自动注册服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令解析</span></span><br><span class="line">apt-key add                                                                <span class="comment"># 导入密钥以验证软件包真实性</span></span><br><span class="line"><span class="built_in">tee</span> /etc/apt/sources.list.d/elastic.list                                <span class="comment"># 写入仓库配置到独立文件</span></span><br><span class="line">apt install kibana                                                        <span class="comment"># 自动安装并配置systemd服务</span></span><br></pre></td></tr></table></figure></li><li><p>‌<strong>配置文件解析</strong>‌</p><p>编辑 <code>/etc/kibana/kibana.yml</code>（APT安装）或 <code>/opt/kibana-8.13.4/config/kibana.yml</code>（手动安装）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port:</span> <span class="number">5601</span>                                         <span class="comment"># 监听端口，默认5601</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;0.0.0.0&quot;</span>                                     <span class="comment"># 允许所有IP访问（生产环境可指定内网IP）</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> [<span class="string">&quot;http://192.168.98.201:9200&quot;</span>]     <span class="comment"># Elasticsearch集群地址</span></span><br><span class="line"><span class="attr">i18n.locale:</span> <span class="string">&quot;zh-CN&quot;</span>                                     <span class="comment"># 设置为中文界面</span></span><br><span class="line"><span class="attr">logging.dest:</span> <span class="string">/var/log/kibana.log</span>                         <span class="comment"># 自定义日志路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键参数</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;0.0.0.0&quot;</span>                <span class="comment"># 开放网络访问（默认localhost仅本地访问）。</span></span><br><span class="line"><span class="string">elasticsearch.hosts:[&quot;ip:port&quot;]</span>        <span class="comment"># 必须指向已部署的Elasticsearch节点URL。</span></span><br><span class="line"><span class="attr">i18n.locale:</span> <span class="string">&quot;zh-CN&quot;</span>                <span class="comment"># 本地化支持，提升中文用户体验。</span></span><br></pre></td></tr></table></figure></li><li><p>‌<strong>服务管理与启动</strong></p><ul><li><p><strong>启动服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start kibana             <span class="comment"># 启动Kibana服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> kibana             <span class="comment"># 设置开机自启</span></span><br></pre></td></tr></table></figure></li><li><p><strong>监控状态与日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status kibana             <span class="comment"># 检查运行状态（输出&quot;Active: active&quot;表示成功）</span></span><br><span class="line">journalctl -u kibana -f                 <span class="comment"># 实时查看日志（过滤&quot;Server running&quot;确认启动）</span></span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="部署验证"><a href="#部署验证" class="headerlink" title="部署验证"></a><strong>部署验证</strong></h5><ol><li><p>‌<strong>访问Kibana Web界面</strong>‌：</p><p>浏览器打开 <code>http://&lt;服务器IP&gt;:5601</code>，显示欢迎页即部署成功</p><p>浏览器打开 <code>http://&lt;服务器IP&gt;:5601/api/status</code>返回<a href="https://cloud.tencent.com/developer/techpedia/1569?from=20065&from_column=20065">JSON</a>格式状态信息</p></li><li><p>‌<strong>检查Elasticsearch连接</strong>‌：在Kibana的 ‌<strong>Dev Tools</strong>‌ 中输入 <code>GET /</code>，返回ES集群信息表示通信正常。</p></li></ol></li><li><h5 id="生产调优建议"><a href="#生产调优建议" class="headerlink" title="生产调优建议"></a><strong>生产调优建议</strong></h5><ul><li>‌<strong>资源隔离</strong>‌: 使用专用用户运行Kibana，避免权限冲突。</li><li>‌<strong>配置热重载</strong>‌: 添加 <code>--config.reload.automatic</code> 启动参数，支持动态加载配置变更。</li><li>‌<strong>安全加固</strong>‌: 启用SSL加密（参考 <code>server.ssl</code> 配置）及防火墙规则限制访问IP。</li></ul></li></ol><hr><h1 id="Kibana的基本使用"><a href="#Kibana的基本使用" class="headerlink" title="Kibana的基本使用"></a>Kibana的基本使用</h1><h2 id="1-创建索引模式"><a href="#1-创建索引模式" class="headerlink" title="1.创建索引模式"></a><strong>1.创建索引模式</strong></h2><p>左侧菜单栏找到并进入<strong>Management</strong>，点击“<strong>Create index pattern</strong>”按钮来添加索引模式。第一个索引模式自动配置为默认的索引默认，以后当你有多个索引模式的时候，你就可以选择将哪一个设为默认。（提示：Management &gt; Index Patterns）</p><h2 id="2-用Discover交互式探索数据"><a href="#2-用Discover交互式探索数据" class="headerlink" title="2.用Discover交互式探索数据"></a><strong>2.用Discover交互式探索数据</strong></h2><ul><li><p>可以访问与所选择的索引默认匹配的每个索引中的每个文档，如果你选择的索引模式配置了time字段，则文档随时间的分布将显示在页面顶部的直方图中</p></li><li><p>可以提交<strong>查询请求</strong>，过滤搜索结构，并查看文档数据，可以看到匹配查询请求的文档数量，以及字段值统计信息</p><ul><li>提交一个查询请求时，直方图、文档表和字段列表都会更新，以反映搜索结果。命中（匹配到的文档）总数会显示在工具栏中。文档表格中显示了前500个命中。默认按时间倒序排列，首先显示最新的文档。可以通过点击<code>Time</code>列来逆转排序顺序。</li></ul></li><li><p><strong>设置时间过滤</strong>：Discover &gt; 顶端导航栏右侧 Last 15 minutes &gt; Time Range &gt; Absolute &gt;选择时间</p></li><li><p><strong>搜索数据</strong>：可以在搜索框中输入查询条件来查询当前索引模式匹配的索引。查询时，<strong>使用Kibana标准的查询语言（基于Lucene的查询语法）或者完全基于JSON的Elasticsearch查询语言DSL</strong>。Kibana查询语言<strong>可以使用自动完成和简化的查询语法作为实验特性</strong>，可以在查询栏的**<code>选项</code>**菜单下进行选择。</p></li><li><p><strong>查看文档数据：</strong>Table 列是控制列表显示的字段，在查看文档数据的时候点那个<strong>像书一样的小图标</strong>。</p></li><li><p><strong>查看字段数据统计：</strong>看左侧列表</p></li><li><p><strong>查看文档上下文：</strong>View surrounding documents</p></li></ul><h2 id="3-Lucene查询语法"><a href="#3-Lucene查询语法" class="headerlink" title="3.Lucene查询语法"></a><strong>3.Lucene查询语法</strong></h2><p>Kibana查询语言基于Lucene查询语法。下面是一些提示：</p><ol><li><strong>执行一个文本搜索</strong>，可以简单的输入一个文本字符串。例如，如果想搜索web服务器的日志，可以输入关键字”<strong>safari</strong>“，这样就可以搜索到所有有关”safari”的字段</li><li><strong>搜索一个特定字段的特定值</strong>，可以用字段的名称作为前缀。例如，输入”<strong>status:200</strong>“，将会找到所有status字段的值是200的文档</li><li><strong>搜索一个范围值</strong>，可以用括号范围语法，**[START_VALUE TO END_VALUE]<strong>。例如，为了找到状态码是4xx的文档，可以输入</strong>status:[400 TO 499]**</li><li><strong>指定更改复杂的查询条件</strong>，可以用布尔操作符 <strong>AND</strong> , <strong>OR</strong> , 和 <strong>NOT</strong>。例如，为了找到状态码是4xx并且extension字段是php或者html的文档，可以输入<strong>status:[400 TO 499] AND (extension:php OR extension:html)</strong></li></ol><hr><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="服务管理命令"><a href="#服务管理命令" class="headerlink" title="服务管理命令"></a><strong>服务管理命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana --<span class="built_in">help</span>             <span class="comment"># 查看所有支持参数</span></span><br><span class="line"><span class="comment"># 作用：显示Kibana支持的全部命令行参数及简要说明</span></span><br><span class="line"><span class="comment"># 关键输出：包括-e（环境变量）、-c（配置文件路径）等参数说明</span></span><br></pre></td></tr></table></figure><h2 id="启动参数解析"><a href="#启动参数解析" class="headerlink" title="启动参数解析"></a><strong>启动参数解析</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana \</span><br><span class="line"> --host=0.0.0.0 \                                     <span class="comment"># 监听所有网络接口</span></span><br><span class="line"> --port=5601 \                                         <span class="comment"># 指定服务端口（默认5601）</span></span><br><span class="line"> --elasticsearch.hosts=http://es-node:9200 \         <span class="comment"># 强制指定ES集群地址</span></span><br><span class="line"> --logging.json=<span class="literal">true</span>                                 <span class="comment"># 日志输出为JSON格式（便于ELK采集）</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 逐行解释</span></span><br><span class="line">--host=0.0.0.0                                        <span class="comment"># 允许远程访问（默认localhost仅本地访问）</span></span><br><span class="line">--port                                                <span class="comment"># 覆盖kibana.yml中的端口配置</span></span><br><span class="line">--elasticsearch.hosts                                <span class="comment"># 运行时动态指定ES连接地址</span></span><br><span class="line">--logging.json                                        <span class="comment"># 结构化日志输出，适合日志分析系统处理</span></span><br></pre></td></tr></table></figure><h2 id="插件管理命令"><a href="#插件管理命令" class="headerlink" title="插件管理命令"></a><strong>插件管理命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana-plugin list                                 <span class="comment"># 查看已安装插件</span></span><br><span class="line">bin/kibana-plugin install x-pack                     <span class="comment"># 安装X-Pack安全插件</span></span><br><span class="line">bin/kibana-plugin remove timeline                     <span class="comment"># 删除指定插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键参数</span></span><br><span class="line">install                                                <span class="comment"># 支持本地ZIP包或官方插件名称</span></span><br><span class="line">remove                                                <span class="comment"># 卸载后需重启Kibana生效</span></span><br></pre></td></tr></table></figure><h2 id="调试与维护命令"><a href="#调试与维护命令" class="headerlink" title="调试与维护命令"></a><strong>调试与维护命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana --optimize                                 <span class="comment"># 前端资源预编译（生产环境必执行）</span></span><br><span class="line">bin/kibana --no-watch                                 <span class="comment"># 禁用配置文件热重载（调试用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊场景</span></span><br><span class="line">--optimize                                            <span class="comment"># 提升页面加载速度，部署后首次运行需执行</span></span><br><span class="line">--no-watch                                            <span class="comment"># 排查配置问题时关闭自动重载</span></span><br></pre></td></tr></table></figure><h2 id="系统集成命令"><a href="#系统集成命令" class="headerlink" title="系统集成命令"></a><strong>系统集成命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">&#x27;localhost:5601/api/status&#x27;</span>                 <span class="comment"># 检查服务健康状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回字段</span></span><br><span class="line">status.overall.state                                <span class="comment"># green表示服务正常</span></span><br><span class="line">metrics.elasticsearch.client.total_active_sockets    <span class="comment"># ES连接数</span></span><br></pre></td></tr></table></figure><h2 id="生产环境完整示例"><a href="#生产环境完整示例" class="headerlink" title="生产环境完整示例"></a><strong>生产环境完整示例</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana \</span><br><span class="line"> --config=/etc/kibana/prod.yml \                     <span class="comment"># 指定配置文件</span></span><br><span class="line"> --pid.file=/var/run/kibana.pid \                     <span class="comment"># 记录进程ID</span></span><br><span class="line"> --logging.dest=/var/log/kibana-prod.log \             <span class="comment"># 日志重定向</span></span><br><span class="line"> --plugin-path=plugins/alerting                     <span class="comment"># 加载自定义插件目录</span></span><br></pre></td></tr></table></figure><p><strong>参数组合意义</strong>‌：</p><ol><li>使用独立配置文件避免冲突</li><li>通过PID文件便于服务管理</li><li>集中日志输出到指定文件</li><li>扩展自定义告警插件功能</li></ol><h2 id="与Elasticsearch联调命令"><a href="#与Elasticsearch联调命令" class="headerlink" title="与Elasticsearch联调命令"></a><strong>与Elasticsearch联调命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Kibana Dev Tools中执行 </span></span><br><span class="line">GET _cat/indices?v                                                     <span class="comment"># 验证ES索引可访问性</span></span><br><span class="line">POST _sql?format=json &#123;<span class="string">&quot;query&quot;</span>:<span class="string">&quot;SELECT * FROM logs LIMIT 10&quot;</span>&#125;         <span class="comment"># 测试SQL查询翻译</span></span><br></pre></td></tr></table></figure><p>通过合理组合这些命令，可实现从开发调试到生产部署的全生命周期管理。建议配合<code>nohup</code>或systemd实现后台运行。</p><hr><h1 id="Metricbeat"><a href="#Metricbeat" class="headerlink" title="Metricbeat"></a>Metricbeat</h1><h2 id="Windows下安装启动Kibana"><a href="#Windows下安装启动Kibana" class="headerlink" title="Windows下安装启动Kibana"></a>Windows下安装启动Kibana</h2><p>安装Kibana非常简单，只需按照官方<a href="https://cloud.baidu.com/product/doc.html">文档</a>的指引进行安装和配置即可。在配置Kibana时，需要指定Elasticsearch的地址和端口，以便Kibana能够与Elasticsearch进行通信。安装基本步骤如下：</p><ol><li>下载Kibana，下载链接 ：<a href="https://www.elastic.co/cn/downloads/kibana">Download Kibana Free | Get Started Now | Elastic</a>。注意需要保证其版本号与Elasticsearch和Kibana两者的版本号一样，小到小版本号。</li><li>下载后解压。找到<code>kibana/bin</code>目录下面的<code>kibana.bat</code>文件，双击执行它，启动成功后，可在浏览器访问 <a href="http://localhost:5601/%E3%80%82http://localhost:5601/status">http://localhost:5601/。http://localhost:5601/status</a> 可以访问Kibana服务器状态页面。</li><li><strong>注意：kibana数据从Elasticsearch而来，在启动kibana需要先启动Elasticsearch</strong>。</li></ol><h2 id="Metricbeat进行Logstash运行状态的监控"><a href="#Metricbeat进行Logstash运行状态的监控" class="headerlink" title="Metricbeat进行Logstash运行状态的监控"></a>Metricbeat进行Logstash运行状态的监控</h2><p>参考原文链接：<a href="https://zhangphil.blog.csdn.net/article/details/126183984">https://zhangphil.blog.csdn.net/article/details/126183984</a></p><p>metricbeat监控<a href="https://so.csdn.net/so/search?q=logstash&spm=1001.2101.3001.7020">logstash</a>运行状态上报Elasticsearch后<a href="https://so.csdn.net/so/search?q=Kibana&spm=1001.2101.3001.7020">Kibana</a>可视化查看：</p><ol><li><p>首先假定已经启动logstash，Elasticsearch，Kibana。并且已经安装部署metricbeat，本文均基于8.3.3版本。</p><ol><li>logstash配置output输出到Elasticsearch，启动；</li><li>Elasticsearch启动；</li><li>Kibana启动</li></ol></li><li><p>启用<code>logstash-xpack</code> 模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metricbeat modules <span class="built_in">enable</span> logstash-xpack</span><br></pre></td></tr></table></figure><p>此时会在<code>modules.d</code>文件目录（metricbeat/metricbeat-8.3.3/modules.d）下多出一个<code>logstash-xpack.yml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">module:</span> <span class="string">logstash</span></span><br><span class="line">  <span class="attr">xpack.enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">period:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;localhost:9600&quot;</span>]</span><br><span class="line">  <span class="comment">#username: &quot;user&quot;</span></span><br><span class="line">  <span class="comment">#password: &quot;secret&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>命令行启动 Metricbeat：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metricbeat -e</span><br></pre></td></tr></table></figure></li><li><p>在浏览器打开<a href="http://localhost:5601/">http://localhost:5601/</a></p><p>找到<code>stack monitoring</code>点进去，页面会有提示：xpack.monitoring.collection.enabled is set to false ，不管它，直接点进蓝色按钮 <strong>Turn on monitoring</strong> 即可。</p></li><li><p>看到了监控界面，选择<code>logstash</code>版面，这里包括所有正在监控的<code>logstash</code>节点：<strong>总览，节点详情统计图表，数据上报流水线</strong>，均可点进去查看。</p></li></ol><h2 id="Metricbeat发送监控数据到远程Elasticsearch"><a href="#Metricbeat发送监控数据到远程Elasticsearch" class="headerlink" title="Metricbeat发送监控数据到远程Elasticsearch"></a>Metricbeat发送监控数据到远程Elasticsearch</h2><p>参考原文链接：<a href="https://zhangphil.blog.csdn.net/article/details/126231371">https://zhangphil.blog.csdn.net/article/details/126231371</a></p><p>默认metricbeat发送数据到同一台机器的9200端口。</p><p>如果metricbeat与Elasticsearch不在同一台机器（不同IP地址），需要在<code>metricbeat.yml</code>文件里面配置Elasticsearch的主机地址端口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">    <span class="comment"># Array of hosts to connect to.</span></span><br><span class="line">    <span class="string">hosts:[&quot;localhost:9200&quot;]</span></span><br></pre></td></tr></table></figure><p>如果kibana和Elasticsearch在同一台机器上，不必再配置metricbeat到kibana的地址。</p><p>如果Elasticsearch和kibana不在同一台机器上，那么需要在<code>metricbeat.yml</code>里面配置到kibana的主机端口地址:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">setup.kibana:</span></span><br><span class="line"><span class="comment"># Kibana Host</span></span><br></pre></td></tr></table></figure><h2 id="Elasticsearch端口配置"><a href="#Elasticsearch端口配置" class="headerlink" title="Elasticsearch端口配置"></a>Elasticsearch端口配置</h2><p>Elasticsearch默认的http访问端口是9200，若启动时9200端口已被占用，Elasticsearch会自动占用9201端口。如果需要指定一个特别端口，只需要把<code>config/elasticsearch.yml</code>中的<code>http.port</code>注释去掉，重新定义一个端口数值即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http.port:9200</span></span><br></pre></td></tr></table></figure><h2 id="kibana连接Elasticsearch主机端口配置"><a href="#kibana连接Elasticsearch主机端口配置" class="headerlink" title="kibana连接Elasticsearch主机端口配置"></a>kibana连接Elasticsearch主机端口配置</h2><p>Elasticsearch与Kibana在同一台主机，且Elasticsearch的默认启动端口配置不变(9200）时，Kibana启动后会自动识别和寻址9200端口上的Elasticsearch。</p><p>但若Elasticsearch端口修改了，需要在Kibana写明最新的Elasticsearch端口，修改Kibana的配置文件<code>config/kibana.yml</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># elasticsearch.hosts:[&quot;http://localhost:9200&quot;]</span></span><br></pre></td></tr></table></figure><h1 id="Kibana实战部署"><a href="#Kibana实战部署" class="headerlink" title="Kibana实战部署"></a>Kibana实战部署</h1><p>在 Kubernetes 集群中，应用服务的日志对故障排查和性能分析至关重要。为解决不便于集中管理和持久化存储的问题，可采用目前主流日志分析解决方案【ELK（Elasticsearch + Logstash + Kibana）】，其中 Kibana 实现日志可视化展示，是日志分析中不可或缺的工具。</p><h2 id="创建Namespace（elk-namespace-yaml）"><a href="#创建Namespace（elk-namespace-yaml）" class="headerlink" title="创建Namespace（elk-namespace.yaml）"></a>创建Namespace（elk-namespace.yaml）</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的命名空间，用于部署 ELK 相关的资源</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elk</span></span><br></pre></td></tr></table></figure><h2 id="创建Service（kibana-service-yaml）"><a href="#创建Service（kibana-service-yaml）" class="headerlink" title="创建Service（kibana-service.yaml）"></a>创建Service（kibana-service.yaml）</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Kubernetes 服务（Service），以便暴露 Kibana Web 界面</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">elk</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5601</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">5601</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30601</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建ConfigMap（kibana-configmap-yaml）"><a href="#创建ConfigMap（kibana-configmap-yaml）" class="headerlink" title="创建ConfigMap（kibana-configmap.yaml）"></a>创建ConfigMap（kibana-configmap.yaml）</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 ConfigMap 来存储 Kibana 配置文件。配置项包括 Elasticsearch 的地址、Kibana 的日志设置以及访问设置</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">elk</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">kibana.yml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    server.port: 5601</span></span><br><span class="line"><span class="string">    server.host: &quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="string">    elasticsearch.hosts: [&quot;http://elasticsearch-0.elasticsearch-cluster.elk.svc.cluster.local:9200&quot;]</span></span><br><span class="line"><span class="string">    kibana.index: &quot;.kibana&quot;</span></span><br><span class="line"><span class="string">    logging.dest: /usr/share/kibana/logs/kibana.log</span></span><br><span class="line"><span class="string">    i18n.locale: &quot;zh-CN&quot;</span></span><br><span class="line"><span class="string">    server.publicBaseUrl: &quot;http://kibana.elk.svc.cluster.local:5601&quot;</span></span><br></pre></td></tr></table></figure><h2 id="创建Depoyment（kibana-deployment-yaml）"><a href="#创建Depoyment（kibana-deployment-yaml）" class="headerlink" title="创建Depoyment（kibana-deployment.yaml）"></a>创建Depoyment（kibana-deployment.yaml）</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Deployment 方式部署 Kibana，此处我们将 Kibana 配置为与 Elasticsearch 集群通信，并挂载之前创建的 ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">elk</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span>  <span class="comment"># 资源有限，这里配置节点亲和性，尽量调度到node1节点</span></span><br><span class="line">          <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">100</span></span><br><span class="line">            <span class="attr">preference:</span></span><br><span class="line">              <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">node1</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">harbor.local/k8s/kibana:7.17.0</span>  <span class="comment"># 内网仓库镜像</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5601</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ELASTICSEARCH_HOSTS</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;http://elasticsearch-0.elasticsearch-cluster.elk.svc.cluster.local:9200&quot;</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/kibana/config/kibana.yml</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">kibana.yml</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/kibana/logs</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;200m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;500Mi&quot;</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">        <span class="comment"># 如果不开启kibana认证就可以这样配</span></span><br><span class="line">        <span class="comment">#livenessProbe:</span></span><br><span class="line">          <span class="comment">#httpGet:</span></span><br><span class="line">            <span class="comment">#path: /api/status</span></span><br><span class="line">            <span class="comment">#port: 5601</span></span><br><span class="line">          <span class="comment">#initialDelaySeconds: 90</span></span><br><span class="line">          <span class="comment">#periodSeconds: 10</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">bash</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">                curl -u elastic:elastic -fs http://kibana.elk.svc.cluster.local:5601/api/status &gt; /dev/null</span></span><br><span class="line"><span class="string"></span>          <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">kibana-config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs</span></span><br><span class="line">        <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="部署所有资源"><a href="#部署所有资源" class="headerlink" title="部署所有资源"></a>部署所有资源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将上述 YAML 文件保存后，使用以下命令统一部署</span></span><br><span class="line">kubectl apply -f elk-namespace.yaml</span><br><span class="line">kubectl apply -f kibana-service.yaml</span><br><span class="line">kubectl apply -f kibana-configmap.yaml</span><br><span class="line">kubectl apply -f kibana-deployment.yaml</span><br></pre></td></tr></table></figure><h2 id="验证Kibana-Pod状态"><a href="#验证Kibana-Pod状态" class="headerlink" title="验证Kibana Pod状态"></a>验证Kibana Pod状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n elk</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ElasticStack</summary>
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="ElasticStack" scheme="https://southernfish.github.io/tags/ElasticStack/"/>
    
  </entry>
  
  <entry>
    <title>ElasticStack Elasticsearch数据存储</title>
    <link href="https://southernfish.github.io/2025/07/01/server/elatsticstack-elasticsearch/"/>
    <id>https://southernfish.github.io/2025/07/01/server/elatsticstack-elasticsearch/</id>
    <published>2025-07-01T07:00:36.000Z</published>
    <updated>2025-07-01T12:21:47.176Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch<strong>是一个基于</strong><a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=123773"><strong>Lucene</strong></a><strong>的搜索服务器</strong>，包含Windows、<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=2010614">macOS</a>、<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=807585">Linux</a>版等。它提供了一个<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7819465">分布式</a>多用户能力的<strong>全文</strong><a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=15733"><strong>搜索引擎</strong></a>，能很方便地使大量数据具有搜索、分析和探索的能力。本文介绍了如何在windows环境安装Elasticsearch、Kibana和Logstash，然后通过Metricbeat进行Logstash运行状态的监控，kiban的可视化查看，以及一些配置。</p><h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Elasticsearch 是一个分布式、高扩展、高实时的搜索与数据分析引擎。它能很方便的使大量数据具有搜索、分析和探索的能力。充分利用Elasticsearch的水平伸缩性，能使数据在生产环境变得更有价值。</p><p>Elasticsearch是与名为<code>Logstash</code>的<strong>数据收集和日志解析引擎</strong>以及名为<code>Kibana</code>的分析和可视化平台一起开发的。这三个产品被设计成一个集成解决方案，称为<code>Elastic Stack</code>（以前称<code>ELK stack</code>）。</p><p>Elasticsearch可以用于搜索各种文档。它提供可扩展的搜索，具有接近实时的搜索，并支持多租户。Elasticsearch是分布式的，这意味着索引可以被分成分片，每个分片可以有0个或多个副本。每个节点托管一个或多个分片，并充当协调器将操作委托给正确的分片。再平衡和路由是自动完成的。相关数据通常存储在同一个索引中，该索引由一个或多个主分片和零个或多个复制分片组成。一旦创建了索引，就不能更改主分片的数量。</p><p>Elasticsearch使用<code>Lucene</code>，并试图通过<code>JSON</code>和<code>Java API</code>提供其所有特性。它支持<code>facetting</code>和<code>percolating</code>，如果新文档与注册查询匹配，这对于通知非常有用。另一个特性称为<code>“网关”</code>，<strong>处理索引的长期持久性</strong>；例如，在服务器崩溃的情况下，可以从网关恢复索引。Elasticsearch支持实时GET请求，适合作为NoSQL数据存储，但<strong>缺少分布式事务</strong>。</p><p><code>‌Lucene</code>是Apache软件基金会维护的<strong>开源全文检索引擎工具包</strong>，用Java编写，提供高性能的索引和搜索功能，广泛应用于信息检索领域。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>首先用户将<strong>数据提交到Elasticsearch 数据库</strong>中，再通过<strong>分词控制器去将对应的语句分词</strong>，将其<strong>权重和分词结果一并存入数据</strong>，当用户搜索数据时候，再<strong>根据权重将结果排名，打分，再将返回结果呈现给用户</strong>。</p><h2 id="Elasticsearch的主要特点"><a href="#Elasticsearch的主要特点" class="headerlink" title="Elasticsearch的主要特点"></a>Elasticsearch的主要特点</h2><p>Elasticsearch是一个功能强大、易于使用和高性能的搜索和分析引擎，适用于各种大规模数据的搜索、聚合和分析需求。</p><ol><li><strong>分布式架构</strong>：数据可以分布在多个节点上。这样可以实现<strong>高可用性和负载均衡</strong>，同时也<strong>能通过水平扩展来处理大规模数据</strong>。</li><li> <strong>实时搜索和分析：</strong>Elasticsearch能够实时对大规模数据进行搜索和分析，搜索结果的响应时间通常在毫秒级别。它支持<strong>全文搜索、词条搜索、模糊搜索</strong>等多种搜索方式，并提供强大的查询语言。</li><li><strong>多种数据类型支持：</strong>包括<strong>结构化数据、半结构化数据和非结构化数据</strong>。可以处理<strong>文本、数字、日期、地理位置</strong>等多种数据类型。</li><li><strong>强大的全文搜索能力：</strong>Elasticsearch使用倒排索引来加速全文搜索，可以快速地找到包含关键词的文档。它支持<strong>分词、同义词、模糊匹配</strong>等功能，可以灵活地处理各种复杂的查询需求。</li><li><strong>多种数据分析功能：</strong>包括<strong>聚合、过滤、排序、统计</strong>等。它可以对大规模数据进行复杂的统计和分析，帮助用户深入了解数据。</li><li><strong>易于使用和集成：</strong>提供了友好的<code>RESTful API</code>，可以方便地与其他应用程序集成。它还有丰富的客户端库，支持Java、Python、.NET等多种编程语言。</li></ol><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="cluster（集群）"><a href="#cluster（集群）" class="headerlink" title="cluster（集群）"></a>cluster（集群）</h3><p>集群中有多个节点，其中有一个为<strong>主节点</strong>，这个主节点是可以通过<strong>选举产生</strong>的，<strong>主从节点是对于集群内部来说的</strong>。<code>es</code>的一个概念就是去<code>中心化</code>，字面上理解就是无中心节点，这是<strong>对于集群外部来说的</strong>，因为从外部来看<code>es集群</code>，在逻辑上是个整体，你与任何一个节点的通信和与整个<code>es集群</code>通信是等价的。</p><h3 id="shards（索引分片）"><a href="#shards（索引分片）" class="headerlink" title="shards（索引分片）"></a>shards（索引分片）</h3><p><code>es</code>可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。<strong>分片的数量只能在索引创建前指定</strong>，并且索引创建后不能更改。</p><h3 id="replicas（索引副本）"><a href="#replicas（索引副本）" class="headerlink" title="replicas（索引副本）"></a>replicas（索引副本）</h3><p>es可以设置多个索引的副本，副本的作用：</p><ul><li>提高系统的<strong>容错性</strong>，当某个节点某个分片损坏或丢失时可以从副本中恢复。</li><li>提高es的<strong>查询效率</strong>，es会自动对搜索请求进行负载均衡。</li></ul><h3 id="recovery（数据恢复或数据重新分布）"><a href="#recovery（数据恢复或数据重新分布）" class="headerlink" title="recovery（数据恢复或数据重新分布）"></a>recovery（数据恢复或数据重新分布）</h3><p>es在<strong>有节点加入或退出</strong>时会根据机器的负载对索引分片进行<strong>重新分配</strong>，挂掉的节点重新启动时也会进行<strong>数据恢复</strong>。</p><h3 id="river（es的一个数据源）"><a href="#river（es的一个数据源）" class="headerlink" title="river（es的一个数据源）"></a>river（es的一个数据源）</h3><p>代表es的一个数据源，也是其它存储方式（如：数据库）同步数据到es的一个方法。它是以插件方式存在的一个es服务，通过<strong>读取river中的数据并把它索引到es中</strong>，官方的river有<code>couchDB</code>的，<code>RabbitMQ</code>的，<code>Twitter</code>的，<code>Wikipedia</code>的。</p><h3 id="gateway（索引快照的存储方式）"><a href="#gateway（索引快照的存储方式）" class="headerlink" title="gateway（索引快照的存储方式）"></a>gateway（索引快照的存储方式）</h3><p>es默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个es集群关闭再重新启动时就会从gateway中读取索引备份数据。es支持多种类型的gateway，有本地文件系统（默认），分布式文件系统，Hadoop的HDFS和amazon的s3云存储服务。</p><h3 id="discovery-zen（自动发现节点机制）"><a href="#discovery-zen（自动发现节点机制）" class="headerlink" title="discovery.zen（自动发现节点机制）"></a>discovery.zen（自动发现节点机制）</h3><p>es是一个基于<code>p2p</code>的系统，它先通过<strong>广播</strong>寻找存在的节点，再通过<strong>多播协议</strong>进行节点之间的通信，同时也<strong>支持点对点的交互</strong>。</p><h3 id="Transport（内部节点或集群-与客户端的交互方式）"><a href="#Transport（内部节点或集群-与客户端的交互方式）" class="headerlink" title="Transport（内部节点或集群 与客户端的交互方式）"></a>Transport（内部节点或集群 与客户端的交互方式）</h3><p>默认内部是使用<code>tcp协议</code>进行交互，同时它支持<code>http协议（json格式）</code>、<code>thrift</code>、<code>servlet</code>、<code>memcached</code>、<code>zeroMQ</code>等的传输协议（通过插件方式集成）。</p><h2 id="windows下的安装"><a href="#windows下的安装" class="headerlink" title="windows下的安装"></a>windows下的安装</h2><h3 id="安装ElasticSearch："><a href="#安装ElasticSearch：" class="headerlink" title="安装ElasticSearch："></a><strong>安装ElasticSearch：</strong></h3><p>①下载 elasticsearch-6.4.1.zip，下载链接：<a href="https://www.elastic.co/cn/downloads/elasticsearch">Download|Elasticsearch|Elastic</a></p><p>②直接解压至某目录，设置该目录为<code>ES_HOME</code>环境变量</p><p>③安装JDK，并设置<code>JAVA_HOME</code>环境变量</p><p>④在windows下，运行 <code>%ES_HOME%\bin\elasticsearch.bat</code>即可运行（双击运行）</p><p>启动成功后Elasticsearch会占用两个端口，<code>9300</code>是<strong>Elasticsearch集群节点之间通信的端口</strong>，<code>9200</code>是<strong>用户可以通过http（如浏览器）访问数据的入口</strong>。安装完成之后，可以在浏览器访问 <a href="http://127.0.0.1:9200/_cat/indices?v&amp;pretty">http://127.0.0.1:9200/_cat/indices?v&amp;pretty</a> 查询es存储数据状态的命令。</p><h3 id="安装head插件："><a href="#安装head插件：" class="headerlink" title="安装head插件："></a><strong>安装head插件：</strong></h3><p>联网时，直接运行<code>%ES_HOME%\bin\plugin --install mobz/elasticsearch-head</code>。</p><p>不联网时，下载<code>elasticsearch-head</code>的<code>zipball</code>的master包，然后运行<code>%ES_HOME%\bin\plugin --url file:///[path-to-downloadfile] --install head</code>，其中<code>[path-to-downloadfile]</code>是下载后master包的绝对路径。</p><p>安装完成，重启服务，在浏览器打开 <a href="http://localhost:9200/_plugin/head/">http://localhost:9200/_plugin/head/</a> 即可。</p><p>如果报错：<a href="http://localhost:9200/">http://localhost:9200</a> 报错：received plaintext http traffic on an https channel, closing connection <code>Netty4HttpChannel</code>。原因是Elasticsearch在Windows下开启了安全认证，找到 config/ 目录下面的<code>elasticsearch.yml</code>配置文件，把安全认证开关从原先的 true 都改成 false ，实现免密登录访问即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">xpack.security.http.ssl:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="Windows下ES内存配置修改"><a href="#Windows下ES内存配置修改" class="headerlink" title="Windows下ES内存配置修改"></a>Windows下ES内存配置修改</h2><p>Windows环境下elasticsearch起来后占用内存过高，可以通过配置修改elasticsearch占用的内存大小。涉及到elasticsearch的安装目录config文件夹下面的两个配置文件。</p><ul><li>在<code>elasticsearch.yml</code>里面找到 <code># bootstrap.memory_lock: true</code>，去掉#号，使之生效。</li><li>在<code>jvm.options</code>里面，找到 <code>## -Xms4g</code>和<code>## -Xmx4g</code>，把##去掉，将其启用。</li></ul><hr><h1 id="Linux环境搭建Elasticsearch"><a href="#Linux环境搭建Elasticsearch" class="headerlink" title="Linux环境搭建Elasticsearch"></a>Linux环境搭建Elasticsearch</h1><p>参考文章：<a href="https://cloud.tencent.com/developer/article/2442280">分布式日志处理：ELK+Kafka实现日志收集</a></p><ul><li>elasticsearch-6.2.4.tar.gz 安装文件</li><li>elasticsearch-analysis-ik-6.2.4.zip 安装中文文件</li></ul><h2 id="安装-Elasticsearch"><a href="#安装-Elasticsearch" class="headerlink" title="安装 Elasticsearch"></a>安装 Elasticsearch</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w vm.max_map_count=262144          <span class="comment">#设置内存！每次启动都要给个运行内存！</span></span><br><span class="line">tar -zxvf elasticsearch-6.2.4.tar.gz         <span class="comment">#指定目录下 解压</span></span><br><span class="line"><span class="comment"># 解压完成,设置elasticsearch-6.2.4/config/目录下：elasticsearch.yml文件保存这一些配置信息,端口9200...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># linunx 创建一个组 Elasticsearch 不能使用Root用户，需要由一个独立用户！</span></span><br><span class="line">groupadd elsearch    <span class="comment">#创建一个组</span></span><br><span class="line">useradd elsearch -g elsearch -p elasticsearch <span class="comment">#设置密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压elasticsearch中文安装包！</span></span><br><span class="line"><span class="comment"># unzip unzip 解压命令! zip压缩包解压,需要下载应用！ install 在线安装(需要网络！)！</span></span><br><span class="line">yum install unzip    <span class="comment">#下载unzip应用;</span></span><br><span class="line"><span class="comment"># 解压目录下文件！</span></span><br><span class="line">unzip /usr/local/elasticsearch-analysis-ik-6.2.4.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权用户操作elsearch  </span></span><br><span class="line"><span class="built_in">chown</span> -R elsearch:elsearch  elasticsearch-6.2.4</span><br><span class="line"><span class="comment"># 创建一个目录, 把中午解压包放进去。 就可以显示中文了！ </span></span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/elasticsearch-6.2.4/plugins/analysis-ik/    <span class="comment">#elasticsearch-6.2.4/plugins下创建一个文件analysis-ik</span></span><br><span class="line"><span class="comment"># 中文解压文件,直接copy进去</span></span><br><span class="line"><span class="built_in">cp</span> -r /usr/local/elasticsearch/* /usr/local/elasticsearch-6.2.4/plugins/analysis-ik/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Contos还需进行配置：修改 soft    nproc     4096</span></span><br><span class="line">vi /etc/security/limits.d/20-nproc.conf        <span class="comment">#修改 soft    nproc     4096 对应...</span></span><br><span class="line"></span><br><span class="line">vi /etc/security/limits.conf                  <span class="comment">#文件添加：↓↓</span></span><br><span class="line">*               soft    nofile          65536</span><br><span class="line">*               hard    nofile          65536</span><br><span class="line">*               soft    <span class="built_in">nproc</span>           4096</span><br><span class="line">*               hard    <span class="built_in">nproc</span>           4096</span><br><span class="line"><span class="comment">#授权：</span></span><br><span class="line"><span class="built_in">chown</span> -R elsearch:elsearch /usr/local/elasticsearch/</span><br></pre></td></tr></table></figure><h2 id="启动-Elasticsearch"><a href="#启动-Elasticsearch" class="headerlink" title="启动 Elasticsearch"></a>启动 Elasticsearch</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su elsearch</span><br><span class="line"><span class="comment"># 刷新</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment"># 切换路径</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local</span><br><span class="line"><span class="built_in">cd</span> elasticsearch-6.2.4/</span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line"><span class="comment"># elasticsearch  /bin目录下启动 </span></span><br><span class="line">./elasticsearch                <span class="comment"># 启动Elasticsearch</span></span><br></pre></td></tr></table></figure><h2 id="启动问题"><a href="#启动问题" class="headerlink" title="启动问题"></a>启动问题</h2><p><strong>启动莫名奇妙报错了：</strong> ERROR: [1] bootstrap checks failed [1]: max virtual memory areas vm.max_map_</p><ul><li>切换到root用户修改配置sysctl.conf 执行： <code>vi /etc/sysctl.conf</code></li><li>添加下面配置：<code>vm.max_map_count=655360</code></li><li>并执行命令：<code>sysctl -p</code></li><li><strong>然后，重新启动elasticsearch，即可启动成功。</strong></li></ul><hr><h1 id="ElasticSearch实时推送数据"><a href="#ElasticSearch实时推送数据" class="headerlink" title="ElasticSearch实时推送数据"></a>ElasticSearch实时推送数据</h1><h2 id="实时搜索"><a href="#实时搜索" class="headerlink" title="实时搜索"></a>实时搜索</h2><ol><li><p><strong>实时索引更新</strong></p><p>Elasticsearch 提供了实时索引更新功能，<strong>当文档被索引或更新时，它们立即可用于搜索</strong>。这意味着用户可以在提交数据后立即执行搜索，而无需等待索引的重建或更新。</p></li><li><p><strong>近实时搜索</strong></p><p>Elasticsearch 还支持近实时搜索，这意味着<strong>文档在被索引后的短时间内就可以被搜索到</strong>。这通常需要<strong>毫秒级的延迟</strong>，使用户可以几乎即刻获得最新数据。</p></li><li><p><strong>持续查询</strong></p><p>Elasticsearch 支持持续查询（<code>continuous queries</code>），这是一种<strong>持续监视数据更改并在变化发生时立即通知客户端的机制</strong>。这通过 Elasticsearch 的 <code>Watcher</code> 插件来实现，可用于实现<strong>实时监控和报警系统</strong>。</p></li></ol><h2 id="实时推送"><a href="#实时推送" class="headerlink" title="实时推送"></a><strong>实时推送</strong></h2><ol><li><p><strong>基于查询的通知</strong></p><p>Elasticsearch 允许用户<strong>定义特定查询条件，并设置通知规则</strong>。当满足查询条件时，Elasticsearch 可以触发通知，将新数据或结果发送给用户。这可以通过 Elastic Stack 中的组件，如 <code>Logstash</code> 和 <code>Kibana</code>，来实现。</p></li><li><p><strong>集成第三方通知服务</strong></p><p>Elasticsearch 可以与<strong>第三方通知服务集成</strong>（如邮件或短信服务），以通过这些服务向用户发送通知。这可以通过 <code>Elasticsearch Watcher</code> 插件来实现，它可以在数据满足条件时触发通知。</p></li></ol><h2 id="实时推送数据到前端"><a href="#实时推送数据到前端" class="headerlink" title="实时推送数据到前端"></a>实时推送数据到前端</h2><p>Elasticsearch实时推送数据到前端，通常涉及到Elasticsearch的实时数据搜索和更新功能，以及前端的技术栈（如使用<code>JavaScript</code>和<code>WebSocket</code>等技术）来实现实时数据的接收和展示。步骤和方案如下： </p><ol><li><p><strong>步骤 1: 启用Elasticsearch的实时功能</strong> </p><ol><li><p> <strong>使用Elasticsearch的实时搜索功能：</strong> 当你索引或更新文档时，这些变更几乎可以立即反映在搜索结果中。  </p></li><li><p><strong>开启_refresh_interval：</strong> 你可以在索引设置中调整refresh_interval，以控制Elasticsearch索引的刷新频率。默认情况下，这个值是1秒，这意味着每秒Elasticsearch会刷新一次索引，确保最新的文档可以被搜索到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /your_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;index&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;refresh_interval&quot;</span> : <span class="string">&quot;1s&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>步骤 2: 使用Elasticsearch的Watcher或XPack Alerting</strong></p><p>对于更复杂的实时通知需求，可用Elasticsearch的<code>Watcher插件</code>或<code>XPack Alerting</code>功能。它们允许<strong>基于某些条件触发动作</strong>，例如发送HTTP请求到你的前端服务器。 </p><p><strong>设置Watcher：</strong> 创建一个Watcher来监控你的数据变化。例如，当某个字段的值达到特定条件时，触发一个动作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PUT /_watcher/watch/my_watch</span><br><span class="line">&#123;</span><br><span class="line">  &quot;trigger&quot;: &#123;</span><br><span class="line">    &quot;schedule&quot;: &#123;</span><br><span class="line">      &quot;interval&quot;: &quot;10s&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;input&quot;: &#123;</span><br><span class="line">    &quot;search&quot;: &#123;</span><br><span class="line">      &quot;request&quot;: &#123;</span><br><span class="line">        &quot;indices&quot;: [&quot;your_index&quot;],</span><br><span class="line">        &quot;body&quot;: &#123;</span><br><span class="line">          &quot;query&quot;: &#123;</span><br><span class="line">            &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;condition&quot;: &#123;</span><br><span class="line">    &quot;compare&quot;: &#123;</span><br><span class="line">      &quot;ctx.payload.hits.total.value&quot;: &#123;</span><br><span class="line">        &quot;gt&quot;: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;actions&quot;: &#123;</span><br><span class="line">    &quot;notify_frontend&quot;: &#123;</span><br><span class="line">      &quot;http&quot;: &#123;</span><br><span class="line">        &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;http://your-frontend-server/api/update&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>步骤 3: 前端实现实时数据接收</strong> </p><ol><li> <strong>使用WebSocket：</strong> 可以在前端使用WebSocket来<strong>监听后端服务器的实时推送</strong>。后端可以使用如<code>socket.io</code>、<code>websockets</code>等库来实现WebSocket服务器。</li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="title function_">io</span>(<span class="string">&#x27;http://your-backend-server&#x27;</span>); <span class="comment">// 使用socket.io客户端连接后端服务器</span></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123; <span class="comment">// 监听&#x27;data&#x27;事件，接收后端推送的实时数据</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// 处理接收到的数据，例如更新页面显示等</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>轮询：</strong> 另一种简单的方法是使用轮询（<strong>定期从后端获取数据</strong>）。虽然这不是真正的实时推送，但在某些情况下可以作为临时解决方案。可以使用<code>setInterval</code>在 JavaScript 中实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;http://your-backend-server/api/data&#x27;</span>) <span class="comment">// 定期从后端获取数据</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// 处理接收到的数据，例如更新页面显示等</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">10000</span>); <span class="comment">// 每10秒获取一次数据</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>步骤 4: 测试和优化</strong></p><p>确保进行充分的测试，确保实时数据的准确性和性能。监控网络延迟和Elasticsearch的性能，根据需要进行调整。</p></li></ol>]]></content>
    
    
    <summary type="html">ElasticStack</summary>
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="ElasticStack" scheme="https://southernfish.github.io/tags/ElasticStack/"/>
    
  </entry>
  
  <entry>
    <title>ElasticStack Beats数据采集</title>
    <link href="https://southernfish.github.io/2025/07/01/server/elatsticstack-beats/"/>
    <id>https://southernfish.github.io/2025/07/01/server/elatsticstack-beats/</id>
    <published>2025-07-01T04:00:36.000Z</published>
    <updated>2025-07-09T07:11:21.552Z</updated>
    
    <content type="html"><![CDATA[<p>‌<strong>Logstash太费内存</strong>，如果在要采集的服务上都安装，这样资源消耗非常高，所以我们要用<strong>轻量级</strong>的采集工具如（Beats）才更高效，更省资源。 参考文章：<a href="https://blog.csdn.net/shjwkzkzk/article/details/148403336">ELK-beats数据采集</a>、<a href="https://blog.csdn.net/LIUCHUAN01/article/details/144473979">ELK系列-（四）轻量级的日志收集助手-Beat家族</a>、<a href="https://blog.csdn.net/Lemon__ing/article/details/148667821">ELK日志文件分析系统——补充(B——Beats)</a></p><h1 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong><code>Beats</code></strong> 是 Elastic Stack 提供的一组轻量级数据采集器，负责从各种来源采集数据，然后将数据发送到 <strong>Elasticsearch</strong> 或 <strong>Logstash</strong>。这些小工具非常轻巧，占用系统资源少，适用于海量的分布式环境。<a href="https://www.elastic.co/guide/en/beats/libbeat/current/beats-reference.html">Beats官方文档地址</a></p><p><strong>Beats</strong>在实现时选择了<code>Golang</code>，Golang的高效内存管理、简洁语法和并发处理能力，使 Beats 在保证低资源消耗的前提下，提供强大的数据采集和传输能力。</p><ol><li>Golang是编译型语言，它编译后的二进制文件无需依赖虚拟机，因此在资源消耗和启动速度上都比Java更有优势。</li><li>Golang的跨平台特性使得Beats能够原生支持Linux、Windows和macOS等多个操作系统，减少了开发和部署的复杂度。</li><li>Golang的并发模型非常适合处理高并发的日志采集任务，Beats能在多个数据流之间高效地并行处理，而不会因为大量日志数据的收集而导致性能瓶颈。</li></ol><h2 id="Beats的家族成员"><a href="#Beats的家族成员" class="headerlink" title="Beats的家族成员"></a>Beats的家族成员</h2><p>Beats是轻量级的日志收集处理工具，Beats占用资源少。包含<strong>多款轻量级采集器</strong>：</p><ul><li><p><code>Packetbeat</code>： 网络数据（收集网络流量数据）</p><ul><li>用于 <strong>网络数据包</strong> 的捕获和分析，适合做 <strong>网络监控</strong>，可以帮助你分析各种应用层协议（如HTTP、MySQL、Redis、DNS等）的流量</li></ul></li><li><p><code>Metricbeat</code>： 指标 （收集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）</p><ul><li>采集 <strong>系统指标</strong>（如CPU、内存、磁盘、网络等）和 <strong>应用程序指标</strong>（如MySQL、Redis等），并将这些数据发送到 <strong>Elasticsearch</strong> 进行存储和分析。</li></ul></li><li><p><code>Filebeat</code>： 文件（收集日志文件数据）</p><ul><li>主要用于 <strong>日志文件</strong> 的采集，常用于 Web 服务器、应用程序和系统日志的收集。它会实时读取指定的日志文件，并将日志内容发送给 <strong>Elasticsearch</strong> 或 <strong>Logstash</strong>。</li></ul></li><li><p><code>Winlogbeat</code>： windows事件日志（收集 Windows 事件<a href="https://cloud.tencent.com/solution/cloudlog?from_column=20065&from=20065">日志数据</a>）</p><ul><li>专为 <strong>Windows事件日志</strong> 设计，能帮助你采集 Windows 系统的事件日志（如应用程序日志、安全日志等），并发送给 <strong>Elasticsearch</strong> 或 <strong>Logstash</strong>。</li></ul></li><li><p><code>Auditbeat</code>：审计数据 （收集审计日志）</p><ul><li>主要用于 <strong>审计</strong> 和 <strong>系统安全监控</strong>，可以帮助收集有关操作系统文件、用户登录等的详细信息。</li></ul></li><li><p><code>Heartbeat</code>：运行时间监控 （收集系统运行时的数据）</p><ul><li>用于 <strong>服务监控</strong>，它定期发送HTTP、TCP或ICMP请求，监控服务的可用性和响应时间，帮助用户了解服务是否正常工作。</li></ul></li></ul><h2 id="Beats的工作原理"><a href="#Beats的工作原理" class="headerlink" title="Beats的工作原理"></a>Beats的工作原理</h2><p>它们类似<strong>数据搬运工</strong>，从各类系统、应用中采集数据后，送到 Logstash 或 Elasticsearch 进行处理。具体流程如下：</p><ol><li><strong>数据采集：</strong>Beat通过读取指定路径或接口，获取源数据（如日志文件、系统指标、网络流量等）。</li><li><strong>数据传输：</strong>Beat将采集到的数据经过一定的处理后，通过HTTP或其他协议发送到 Logstash 或 Elasticsearch。</li><li><strong>数据处理与分析：</strong>如果是通过 Logstash 发送，Logstash会进一步处理数据（如过滤、转换等），然后将数据发送到 Elasticsearch。</li><li><strong>可视化：</strong>数据被 Elasticsearch 存储后，借助 Kibana 进行可视化展示，帮助用户快速了解系统和应用的运行状况。</li></ol><h2 id="Beats的优势"><a href="#Beats的优势" class="headerlink" title="Beats的优势"></a>Beats的优势</h2><ul><li><strong>轻量级：</strong>Beat具有较小的内存占用和CPU消耗，适合在大规模分布式系统中部署。</li><li><strong>高效：</strong>采集到的数据可以快速传输到Elasticsearch，几乎没有延迟。</li><li><strong>灵活性：</strong>支持多种数据源和输出目标，可以满足不同的数据采集需求。</li></ul><h2 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a><strong>关键特性</strong></h2><table><thead><tr><th><strong>特性</strong>‌</th><th>‌<strong>详细说明</strong>‌</th></tr></thead><tbody><tr><td>‌<strong>专业化分工</strong>‌</td><td>不同 Beat 聚焦特定场景（如 <code>Filebeat</code> 日志、<code>Metricbeat</code> 监控指标）</td></tr><tr><td>‌<strong>低侵入性</strong>‌</td><td>无需改造应用代码，以代理形式部署在主机/容器内</td></tr><tr><td><strong>实时处理能力</strong>‌</td><td>毫秒级延迟传输数据，支持流式分析场景</td></tr><tr><td>‌<strong>安全传输</strong>‌</td><td>原生支持 TLS 加密、身份认证（API Key/OAuth2）</td></tr><tr><td>‌<strong>自动负载均衡</strong>‌</td><td>多节点部署时自动分配采集任务，避免单点故障</td></tr></tbody></table><h2 id="Beats的适用场景"><a href="#Beats的适用场景" class="headerlink" title="Beats的适用场景"></a>Beats的适用场景</h2><ul><li><strong>日志收集：</strong>如Web服务器、应用程序、操作系统日志等。</li><li><strong>系统监控：</strong>如CPU、内存、磁盘等指标采集。</li><li><strong>网络监控：</strong>如分析网络流量、检测应用层协议等。</li><li><strong>安全审计：</strong>如收集操作系统和应用的安全事件。</li></ul><h2 id="filebeat安装"><a href="#filebeat安装" class="headerlink" title="filebeat安装"></a><strong>filebeat安装</strong></h2><p>在需要收集日志的机器（node4，192.168.98.204）上部署filebeat。安装方式如下：</p><ol><li><p><strong>yum安装：</strong>安装ES的时候设置过yum源可以直接使用yum命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node4 ~]# yum -y install filebeat</span><br></pre></td></tr></table></figure></li><li><p><strong>rpm安装</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node4 ~]# rpm -i filebeat-<span class="number">7</span>.<span class="number">6</span>.<span class="number">0</span>-x86_64.rpm </span><br><span class="line">警告：filebeat-<span class="number">7</span>.<span class="number">6</span>.<span class="number">0</span>-x86_64.rpm: 头V4 RSA/SHA512 Signature, 密钥 ID d88e42b4: NOKEY</span><br><span class="line">-i install</span><br></pre></td></tr></table></figure></li><li><p>源码安装（参考官方文档）</p><p>安装目录：/usr/share/filebeat</p><p>配置文件目录： /etc/filebeat</p><p>配置文件：/etc/filebeat/filebeat.yml</p><p>服务启动管理：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node4 ~]# systemctl enable filebeat</span><br><span class="line">Synchronizing state of filebeat.service with SysV service script with /usr/lib/systemd/systemd-sysv-install.</span><br><span class="line"><span class="function">Executing: /<span class="title">usr</span>/<span class="title">lib</span>/<span class="title">systemd</span>/<span class="title">systemd</span>-<span class="title">sysv</span>-<span class="title">install</span> <span class="title">enable</span> <span class="title">filebeat</span></span></span><br><span class="line"><span class="function"><span class="title">Created</span> <span class="title">symlink</span> /<span class="title">etc</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">multi</span>-<span class="title">user.target.wants</span>/<span class="title">filebeat.service</span> → /<span class="title">usr</span>/<span class="title">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">filebeat.service</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 没有修改配置文件，起不来</span></span><br><span class="line"><span class="function">[<span class="title">root</span>@<span class="title">node4</span> ~]# <span class="title">systemctl</span> <span class="title">start</span> <span class="title">filebeat</span></span></span><br></pre></td></tr></table></figure></li></ol><h2 id="filebeat配置文件"><a href="#filebeat配置文件" class="headerlink" title="filebeat配置文件"></a>filebeat配置文件</h2><p>配置文件查看：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node4 ~]# cat /etc/filebeat/filebeat.yml |grep -v &#x27;#&#x27; |grep -v &#x27;^$&#x27;</span><br></pre></td></tr></table></figure><p>filebeat.yml 内容：（ <strong>收集本机messages日志到ElasticSearch</strong>）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span>            <span class="comment"># 默认false，修改为true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="comment"># - /var/log/*.log        # 收集日志的路径</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/log/messages</span>        <span class="comment"># 收集日志的路径 filebeat收集本机messages日志到ES</span></span><br><span class="line"><span class="attr">filebeat.config.modules:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">$&#123;path.config&#125;/modules.d/*.yml</span></span><br><span class="line">  <span class="attr">reload.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">setup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 定义kibana地址</span></span><br><span class="line"><span class="attr">setup.kibana:</span></span><br><span class="line"><span class="comment"># 定义ES地址接收数据</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;192.168.98.201:9200&quot;</span>]</span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">add_host_metadata:</span> <span class="string">~</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">add_cloud_metadata:</span> <span class="string">~</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">add_docker_metadata:</span> <span class="string">~</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">add_kubernetes_metadata:</span> <span class="string">~</span></span><br></pre></td></tr></table></figure><p>修改filebeat配置文件之后需要重启filebeat服务，生效配置</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node4 ~]# systemctl restart filebeat</span><br></pre></td></tr></table></figure><hr><h1 id="Filebeat收集数据上传"><a href="#Filebeat收集数据上传" class="headerlink" title="Filebeat收集数据上传"></a>Filebeat收集数据上传</h1><h3 id="发送ElasticSearch并设置数据索引"><a href="#发送ElasticSearch并设置数据索引" class="headerlink" title="发送ElasticSearch并设置数据索引"></a>发送ElasticSearch并设置<strong>数据索引</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在output.*输出全局中插入下面三行</span></span><br><span class="line"><span class="attr">setup.ilm.enabled:</span> <span class="literal">false</span>                         <span class="comment"># 禁用ilm</span></span><br><span class="line"><span class="attr">setup.template.name:</span> <span class="string">&quot;node4_messages&quot;</span>             <span class="comment"># 设置索引模板名</span></span><br><span class="line"><span class="attr">setup.template.pattern:</span> <span class="string">&quot;node4_messages-*&quot;</span>         <span class="comment"># 索引前缀</span></span><br><span class="line"><span class="comment"># 定义ES地址接收数据</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;192.168.98.201:9200&quot;</span>]                <span class="comment"># ElasticSearch 服务器地址和端口</span></span><br><span class="line">  <span class="attr">index:</span> <span class="string">&quot;node4_messages-<span class="template-variable">%&#123;+yyyy.MM.dd&#125;</span>&quot;</span>         <span class="comment">#定义索引</span></span><br></pre></td></tr></table></figure><h3 id="发送Logstash"><a href="#发送Logstash" class="headerlink" title="发送Logstash"></a>发送Logstash</h3><p>filebeat将采集日志发送给Logstash（node3，192.168.98.203）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义输出到logstash</span></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;192.168.98.203:5044&quot;</span>]                <span class="comment"># Logstash 服务器地址和端口</span></span><br></pre></td></tr></table></figure><p>logstash收到日志添加索引后发送ElasticSearch（node1：192.168.98.201，node2：192.168.98.202）。Logstash配置文件查看：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node3 conf.d]#cat filebeat_to_logstash_es.conf </span><br></pre></td></tr></table></figure><p>Logstash的配置文件 filebeat_to_logstash_es.conf </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">input</span> &#123;</span><br><span class="line">    <span class="string">beats</span> &#123;</span><br><span class="line">        <span class="string">port</span> <span class="string">=&gt;</span> <span class="number">5044</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">output</span> &#123;</span><br><span class="line">    <span class="string">elasticsearch</span> &#123;</span><br><span class="line">        <span class="string">hosts</span> <span class="string">=&gt;</span> [<span class="string">&quot;192.168.98.201:9200&quot;</span>]            <span class="comment"># ElasticSearch 服务器地址和端口</span></span><br><span class="line">        <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">&quot;server_node4-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>&quot;</span>       <span class="comment"># 定义索引</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启filebeat、logstash服务生效配置</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node4 ~]# systemctl restart filebeat</span><br><span class="line">[root@node3 ~]# systemctl restart logstash</span><br></pre></td></tr></table></figure><hr><h1 id="基本部署"><a href="#基本部署" class="headerlink" title="基本部署"></a>基本部署</h1><h2 id="Filebeat-单机部署流程"><a href="#Filebeat-单机部署流程" class="headerlink" title="Filebeat 单机部署流程"></a><strong>Filebeat 单机部署流程</strong></h2><h3 id="安装依赖与下载"><a href="#安装依赖与下载" class="headerlink" title="安装依赖与下载"></a><strong>安装依赖与下载</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update             <span class="comment"># 更新软件源列表</span></span><br><span class="line">sudo apt install wget -y     <span class="comment"># 安装下载工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载二进制包</span></span><br><span class="line">wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-8.13.4-linux-x86_64.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令解析</span></span><br><span class="line">apt update                    <span class="comment"># 获取最新软件包信息，避免版本冲突</span></span><br><span class="line">wget                        <span class="comment"># 从 Elastic 官网下载指定版本 Filebeat（替换版本号适配环境）</span></span><br></pre></td></tr></table></figure><h3 id="解压与权限配置"><a href="#解压与权限配置" class="headerlink" title="解压与权限配置"></a><strong>解压与权限配置</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf filebeat-8.13.4-linux-x86_64.tar.gz -C /opt/        <span class="comment"># 解压至 /opt 目录</span></span><br><span class="line">sudo <span class="built_in">chown</span> -R root:root /opt/filebeat-8.13.4                 <span class="comment"># 所有权归属 root（安全合规）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键参数：</span></span><br><span class="line">-zxvf         <span class="comment"># -z 解压 gzip，-x 解包，-v 显示过程，-f 指定文件</span></span><br><span class="line"><span class="built_in">chown</span> -R    <span class="comment"># 递归修改目录所有权，避免权限不足导致采集失败</span></span><br></pre></td></tr></table></figure><h3 id="配置文件修改‌"><a href="#配置文件修改‌" class="headerlink" title="配置文件修改‌"></a><strong>配置文件修改</strong>‌</h3><p>编辑 <code>/opt/filebeat-8.13.4/filebeat.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">filestream</span></span><br><span class="line">   <span class="attr">paths:</span> <span class="bullet">-</span> <span class="string">/var/log/*.log</span>                 <span class="comment"># 监控所有 .log 文件</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line"> <span class="attr">hosts:</span> [<span class="string">&quot;192.168.98.202:9200&quot;</span>]         <span class="comment"># ES 集群地址</span></span><br><span class="line"><span class="attr">logging.level:</span> <span class="string">warning</span>                     <span class="comment"># 减少日志量（生产环境推荐</span></span><br></pre></td></tr></table></figure><ul><li>‌配置要点：<ul><li><code>paths</code>：支持通配符（如 <code>/var/log/nginx/*.log</code> 采集 Nginx 日志）。</li><li><code>hosts</code>：多节点集群可配置负载均衡（<code>[&quot;http://node1:9200&quot;, &quot;http://node2:9200&quot;]</code>）。</li></ul></li></ul><h3 id="‌启动"><a href="#‌启动" class="headerlink" title="‌启动"></a>‌<strong>启动</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/filebeat-8.13.4         <span class="comment"># 到安装目录下</span></span><br><span class="line">./filebeat -e -c filebeat.yml    <span class="comment"># 前台启动（-e 输出日志到控制台）</span></span><br></pre></td></tr></table></figure><h3 id="‌验证‌"><a href="#‌验证‌" class="headerlink" title="‌验证‌"></a>‌验证‌</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:5066/stats | jq .filebeat.harvesting    <span class="comment"># 检查采集状态（需安装 jq）</span></span><br></pre></td></tr></table></figure><hr><h2 id="Filebeat-集群化部署关键步骤"><a href="#Filebeat-集群化部署关键步骤" class="headerlink" title="Filebeat 集群化部署关键步骤"></a>Filebeat 集群化部署关键步骤</h2><h3 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a><strong>统一配置管理</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp filebeat.yml root@node4:/opt/filebeat-8.13.4/        <span class="comment"># 分发配置文件到集群节点</span></span><br></pre></td></tr></table></figure><p><strong>需同步项</strong>‌：配置文件 <code>filebeat.yml</code>、证书文件（若启用 TLS）</p><h3 id="注册系统服务（所有节点）"><a href="#注册系统服务（所有节点）" class="headerlink" title="注册系统服务（所有节点）"></a><strong>注册系统服务（所有节点）</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo ./filebeat setup --service                            <span class="comment"># 生成 systemd 服务文件</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now filebeat                    <span class="comment"># 启动并设置开机自启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务管理命令：</span></span><br><span class="line">systemctl status filebeat                                <span class="comment"># 检查运行状态</span></span><br><span class="line">journalctl -u filebeat -f                                <span class="comment"># 实时追踪日志</span></span><br></pre></td></tr></table></figure><h2 id="Kubernetes-部署DaemonSet-模式"><a href="#Kubernetes-部署DaemonSet-模式" class="headerlink" title="Kubernetes 部署DaemonSet 模式"></a>Kubernetes 部署DaemonSet 模式</h2><h3 id="部署-Filebeat-DaemonSet"><a href="#部署-Filebeat-DaemonSet" class="headerlink" title="部署 Filebeat DaemonSet"></a>部署 Filebeat DaemonSet</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">filebeat</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">template:</span></span><br><span class="line">     <span class="attr">spec:</span></span><br><span class="line">         <span class="attr">containers:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">filebeat</span></span><br><span class="line">           <span class="attr">image:</span> <span class="string">docker.elastic.co/beats/filebeat:8.13.4</span></span><br><span class="line">           <span class="attr">volumeMounts:</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">             <span class="attr">mountPath:</span> <span class="string">/var/log</span> <span class="comment"># 挂载宿主机日志目录</span></span><br><span class="line">           <span class="bullet">-</span> <span class="string">name:config</span></span><br><span class="line">             <span class="attr">mountPath:</span> <span class="string">/usr/share/filebeat/filebeat.yml</span></span><br><span class="line">           <span class="attr">volumes:</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">             <span class="attr">hostPath: path:</span> <span class="string">/var/log</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">             <span class="attr">configMap: name:</span> <span class="string">filebeat-config</span> <span class="comment"># 通过 ConfigMap 管理配置</span></span><br></pre></td></tr></table></figure><p><strong>关键设计</strong>‌：</p><ul><li><code>DaemonSet</code>：确保每个 Node 运行一个 Pod，采集节点日志。</li><li><code>hostPath</code>：直接挂载宿主机日志目录，避免日志遗漏。</li></ul><h3 id="生成-ConfigMap"><a href="#生成-ConfigMap" class="headerlink" title="生成 ConfigMap"></a><strong>生成 ConfigMap</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap filebeat-config --from-file=filebeat.yml <span class="comment"># 从本地配置创建</span></span><br></pre></td></tr></table></figure><h2 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h2><table><thead><tr><th><strong>问题现象</strong>‌</th><th>‌<strong>诊断命令</strong>‌</th><th>解释说明</th></tr></thead><tbody><tr><td>‌<strong>日志采集中断</strong>‌</td><td><code>grep &quot;ERR&quot; /var/log/filebeat/filebeat</code></td><td>过滤错误日志</td></tr><tr><td><strong>ES 连接失败</strong>‌</td><td><code>telnet es-host 9200</code></td><td>验证网络连通性</td></tr><tr><td>‌<strong>CPU 占用过高</strong>‌</td><td><code>./filebeat export config</code></td><td>检查冗余 input 配置</td></tr></tbody></table><h2 id="生产环境调优参数"><a href="#生产环境调优参数" class="headerlink" title="生产环境调优参数"></a><strong>生产环境调优参数</strong></h2><p>在 <code>filebeat.yml</code> 中增加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">queue.mem.events:</span> <span class="number">4096</span>                         <span class="comment"># 内存队列大小（防突发流量）</span></span><br><span class="line"> <span class="attr">processors:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">drop_fields:</span>                         <span class="comment"># 删除无用字段减负</span></span><br><span class="line">     <span class="attr">fields:</span> [<span class="string">&quot;agent.ephemeral_id&quot;</span>]</span><br></pre></td></tr></table></figure><ul><li>‌调优效果：<ul><li>提升吞吐量 30%+，降低 ES 索引压力。</li><li>减少网络带宽消耗（尤其对云环境）。</li></ul></li></ul><p><strong>操作原则</strong>‌：</p><ol><li>单机测试使用 <code>-e</code> 前台启动快速验证；</li><li>生产环境务必注册为 systemd 服务保障高可用；</li><li>Kubernetes 需配置资源限制（CPU/Memory）。</li></ol><hr><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="基础命令结构"><a href="#基础命令结构" class="headerlink" title="基础命令结构"></a><strong>基础命令结构</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./filebeat [全局选项] &lt;子命令&gt; [子命令选项]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令层级：</span></span><br><span class="line">    <span class="comment"># 全局选项：影响所有子命令行为（如 `-c` 指定配置文件）</span></span><br><span class="line">    <span class="comment"># 子命令：执行特定功能（如 `run` 启动采集）</span></span><br><span class="line">    <span class="comment"># 子命令选项：针对子命令的细化配置。</span></span><br></pre></td></tr></table></figure><h2 id="核心子命令解析‌"><a href="#核心子命令解析‌" class="headerlink" title="核心子命令解析‌"></a><strong>核心子命令解析</strong>‌</h2><p>‌<strong>1. 运行日志采集（<code>run</code>）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./filebeat run \</span><br><span class="line"> -e \                                                        <span class="comment"># 日志输出到标准错误（调试用）</span></span><br><span class="line"> -c /etc/filebeat.yml \                                     <span class="comment"># 指定配置文件路径</span></span><br><span class="line"> -E <span class="string">&quot;output.elasticsearch.hosts=[&#x27;http://es-node:9200&#x27;]&quot;</span>     <span class="comment"># 动态覆盖配置</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数意义：</span></span><br><span class="line">-e                    <span class="comment"># 禁用系统日志，直接输出到终端，便于实时调试。</span></span><br><span class="line">-c                    <span class="comment"># 显式指定配置文件，避免默认路径冲突。</span></span><br><span class="line">-E                    <span class="comment"># 运行时动态修改配置项（优先级高于配置文件）。</span></span><br></pre></td></tr></table></figure><p><strong>2.配置测试（<code>test</code>）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./filebeat <span class="built_in">test</span> config \         <span class="comment"># 验证配置文件语法</span></span><br><span class="line"> -c ./filebeat-prod.yml \         <span class="comment"># 测试非默认配置文件</span></span><br><span class="line"> -d <span class="string">&quot;publish&quot;</span>                     <span class="comment"># 仅调试&quot;publish&quot;相关组件</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调试选择器</span></span><br><span class="line">-d <span class="string">&quot;*&quot;</span>                            <span class="comment"># 启用全部组件调试日志。</span></span><br><span class="line">-d <span class="string">&quot;input&quot;</span>                        <span class="comment"># 聚焦输入模块问题排查。</span></span><br></pre></td></tr></table></figure><p><strong>3.环境初始化（<code>setup</code>）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./filebeat setup \</span><br><span class="line"> --dashboards \                             <span class="comment"># 自动创建Kibana仪表盘</span></span><br><span class="line"> --pipelines \                                 <span class="comment"># 部署Elasticsearch Ingest管道</span></span><br><span class="line"> -E <span class="string">&quot;setup.kibana.host=kibana:5601&quot;</span>         <span class="comment"># 指定Kibana地址</span></span><br></pre></td></tr></table></figure><p><strong>典型场景</strong>‌：</p><ul><li>首次部署时预加载索引模板、仪表盘等资源。</li><li>需提前配置 <code>output.elasticsearch</code> 连接信息。</li></ul><h2 id="模块管理命令"><a href="#模块管理命令" class="headerlink" title="模块管理命令"></a><strong>模块管理命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./filebeat modules <span class="built_in">enable</span> nginx \             <span class="comment"># 启用Nginx日志模块</span></span><br><span class="line">./filebeat modules list \                     <span class="comment"># 查看已启用模块</span></span><br><span class="line">./filebeat modules <span class="built_in">disable</span> system             <span class="comment"># 停用系统监控模块</span></span><br></pre></td></tr></table></figure><ul><li>‌模块配置：<ul><li>模块路径：<code>/etc/filebeat/modules.d/*.yml</code>。</li><li>支持动态覆盖：<code>-M &quot;nginx.access.var.paths=[/var/log/nginx/*.log]&quot;</code>。</li></ul></li></ul><h2 id="高级调试命令"><a href="#高级调试命令" class="headerlink" title="高级调试命令"></a><strong>高级调试命令</strong></h2><p>‌<strong>1. 性能分析</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./filebeat <span class="built_in">export</span> config \                     <span class="comment"># 导出最终生效配置（含默认值）</span></span><br><span class="line">./filebeat -v \                             <span class="comment"># 显示详细版本信息（含依赖库）</span></span><br></pre></td></tr></table></figure><p>‌<strong>2. 密钥管理</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./filebeat keystore create \                 <span class="comment"># 创建密钥库（存储敏感信息）</span></span><br><span class="line">./filebeat keystore add ES_PWD                 <span class="comment"># 交互式添加Elasticsearch密码</span></span><br></pre></td></tr></table></figure><p><strong>安全建议</strong>‌：</p><ul><li>用密钥库替代配置文件中的明文密码。</li><li>密钥库文件默认位于 <code>$FILEBEAT_PATH/data/keystore</code></li></ul><h2 id="生产环境常用组合"><a href="#生产环境常用组合" class="headerlink" title="生产环境常用组合"></a><strong>生产环境常用组合</strong></h2><p>‌<strong>1. 安全启动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./filebeat run \</span><br><span class="line"> --strict.perms=<span class="literal">false</span> \                     <span class="comment"># 放宽文件权限检查</span></span><br><span class="line"> --path.data=/mnt/filebeat_data             <span class="comment"># 自定义数据存储路径</span></span><br></pre></td></tr></table></figure><p>‌<strong>2. 多配置文件加载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat -c config.yml -c inputs.d/*.yml     <span class="comment"># 主配置+分片配置</span></span><br></pre></td></tr></table></figure><h2 id="命令输出解析示例‌"><a href="#命令输出解析示例‌" class="headerlink" title="命令输出解析示例‌"></a><strong>命令输出解析示例</strong>‌</h2><p>执行 <code>./filebeat test output</code> 后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Elasticsearch: http://es-node:9200...</span><br><span class="line"> Connection OK. Cluster UUID: xyz123         <span class="comment"># ES连接正常</span></span><br><span class="line">Logstash: tcp://logstash:5044...</span><br><span class="line"> Connection failed: dial <span class="built_in">timeout</span>             <span class="comment"># Logstash连接失败</span></span><br></pre></td></tr></table></figure><h2 id="关键参数速查表"><a href="#关键参数速查表" class="headerlink" title="关键参数速查表"></a><strong>关键参数速查表</strong></h2><table><thead><tr><th>‌<strong>参数</strong>‌</th><th>‌<strong>作用</strong>‌</th><th>‌<strong>示例</strong>‌</th></tr></thead><tbody><tr><td><code>-E</code></td><td>动态覆盖配置</td><td><code>-E &quot;queue.mem.events=2048&quot;</code></td></tr><tr><td><code>-M</code></td><td>覆盖模块配置</td><td><code>-M &quot;system.syslog.enabled=false&quot;</code></td></tr><tr><td><code>--path.*</code></td><td>自定义路径（配置、数据、日志）</td><td><code>--path.logs=/var/log/filebeat</code></td></tr><tr><td><code>--once</code></td><td>采集一次后退出（测试用）</td><td><code>./filebeat --once</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">ElasticStack Beats</summary>
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="ElasticStack" scheme="https://southernfish.github.io/tags/ElasticStack/"/>
    
  </entry>
  
</feed>
