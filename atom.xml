<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Southern Fish</title>
  
  
  <link href="https://southernfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://southernfish.github.io/"/>
  <updated>2025-07-10T12:47:35.024Z</updated>
  <id>https://southernfish.github.io/</id>
  
  <author>
    <name>Southern Fish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dubbo</title>
    <link href="https://southernfish.github.io/2025/07/10/middleware/dubbo/"/>
    <id>https://southernfish.github.io/2025/07/10/middleware/dubbo/</id>
    <published>2025-07-10T08:11:36.000Z</published>
    <updated>2025-07-10T12:47:35.024Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo(读音[ˈdʌbəʊ])是阿里巴巴公司开源的一个高性能优秀的服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。 Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。本文参考文章：<a href="https://blog.csdn.net/huyuyang6688/article/details/76407440">Dubbo介绍、原理</a>、<a href="https://blog.csdn.net/weixin_45404884/article/details/137697450">Dubbo（从入门到掌握）看完这一篇就够了</a>、<a href="https://codeease.top/blog/pages/e8a5c9/">Dubbo两小时快速上手教程（直接代码、Spring、SpringBoot）</a>、<a href="https://cloud.tencent.com/developer/article/2021745?policyId=1004">从原理到选型，一文带你搞懂RPC</a>。</p><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><h2 id="什么是Dubbo"><a href="#什么是Dubbo" class="headerlink" title="什么是Dubbo"></a>什么是Dubbo</h2><p>Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案，支持多种传输和序列化方案。Dubbo最常用的应用就是远程调用。 官网地址：<a href="http://dubbo.apache.org/">http://dubbo.apache.org</a></p><p>Dubbo中<strong>服务端最核心的对象</strong>有四个： </p><ul><li><strong>ApplicationConfig</strong>：配置当前应用信息 </li><li><strong>ProtocolConfig</strong>：配置提供服务的协议信息 </li><li><strong>RegistryConfig</strong>：配置注册相关信息 </li><li><strong>ServiceConfig</strong>：配置暴露的服务信息 </li></ul><p>Dubbo<strong>客户端中核心的对象</strong>有两个： </p><ul><li><strong>ApplicationConfig</strong>：配置当前应用信息 </li><li><strong>ReferenceConfig</strong>：配置引用的服务信息</li></ul><h2 id="核心部件"><a href="#核心部件" class="headerlink" title="核心部件"></a>核心部件</h2><p><strong>Remoting</strong>：网络通信框架，实现了 <code>sync-over-async</code> 和 <code>request-response</code> 消息机制</p><p><strong>RPC</strong>：一个远程过程调用的抽象，支持负载均衡、容灾和集群功能</p><p><strong>Registry</strong>：服务目录框架用于服务的注册和服务事件发布和订阅</p><h2 id="Dubbo是为了解决什么问题"><a href="#Dubbo是为了解决什么问题" class="headerlink" title="Dubbo是为了解决什么问题"></a>Dubbo是为了解决什么问题</h2><ul><li>当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。</li><li>当进一步发展，服务间依赖关系变得错踪复杂，分不清哪个应用要在哪个应用之前启动，架构师都不能完整描述应用的架构关系。</li><li>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</li></ul><hr><h1 id="Dubbo原理"><a href="#Dubbo原理" class="headerlink" title="Dubbo原理"></a>Dubbo原理</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ol><li><p><strong>节点角色</strong></p><p><strong>Provider</strong>：暴露服务方称之为<strong>服务提供者</strong></p><p><strong>Consumer</strong>：调用远程服务方称之为<strong>服务消费者</strong></p><p><strong>Container</strong>：服务<strong>运行容器</strong></p><p><strong>Registry</strong>：服务注册与发现的中心目录服务称之为<strong>服务注册中心</strong></p><p><strong>Monitor</strong>：统计服务的调用次数和调用时间的日志服务称之为<strong>服务监控中心</strong></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250710175959362.png" alt="image-20250710175959362"></p></li><li><p><strong>工作过程</strong>（Dubbo服务启动，调用，暴露消费的过程）：</p><ul><li><strong>服务容器</strong>负责启动，加载，运行服务提供者。</li><li><strong>服务提供者</strong>在启动时，向注册中心注册自己提供的服务。</li><li><strong>服务消费者</strong>在启动时，向注册中心订阅自己所需的服务。</li><li><strong>注册中心</strong>返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者<ul><li><em>注册中心，服务提供者，服务消费者三者之间均为长连接</em>，监控中心除外。</li><li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者。</li><li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。</li></ul></li><li><strong>服务消费者</strong>，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li><strong>服务消费者和提供者</strong>，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul></li><li><p><strong>Dubbo层</strong>（10层）：</p><ul><li><strong>服务接口层</strong>（<code>Service</code>）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。</li><li><strong>配置层</strong>（<code>Config</code>）：对外配置接口，以<code>ServiceConfig</code>和<code>ReferenceConfig</code>为中心<ul><li>可以直接<code>new配置类</code>，也可以通过<code>spring解析配置</code>生成配置类。</li></ul></li><li><strong>服务代理层</strong>（<code>Proxy</code>）：负责服务注册与查询服务，以及注册服务的本地缓存。<ul><li>服务接口透明代理，生成服务的<code>客户端Stub</code>和<code>服务器端Skeleton</code>，以<code>ServiceProxy</code>为中心，扩展接口为<code>ProxyFactory</code>。</li></ul></li><li><strong>服务注册层</strong>（<code>Registry</code>）：负责生成消费者的代理对象和服务提供方的<code>Invoker</code>。<ul><li>封装服务地址的注册与发现,以服务URL为中心，扩展接口为<code>RegistryFactory、Registry和RegistryService</code>。</li><li>可能没有服务注册中心，此时服务提供方直接暴露服务。</li></ul></li><li><strong>集群层</strong>（<code>Cluster</code>）：负责负载均衡的策略，以及失败的策略。<ul><li>封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为<code>Cluster、Directory、Router和LoadBalance</code>。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。</li></ul></li><li><strong>监控层</strong>（<code>Monitor</code>）：RPC调用次数和调用时间监控，以<code>Statistics</code>为中心，扩展接口为<code>MonitorFactory、Monitor和MonitorService</code>。</li><li><strong>远程调用层</strong>（<code>Protocol</code>）：封将RPC调用，支持多种RPC协议（不包含IO通信部分）。以<code>Invocation和Result</code>为中心，扩展接口为<code>Protocol、Invoker和Exporter</code>。<ul><li><code>Protocol</code>是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。</li><li><code>Invoker</code>是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</li></ul></li><li><strong>信息交换层</strong>（<code>Exchange</code>）：封装请求响应模式，同步转异步。<ul><li>处理各种协议的通信请求，支持<code>netty、mina、http</code>等，默认采用<code>netty</code>进行通信。</li><li>以<code>Request和Response</code>为中心，扩展接口为<code>Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer</code>。</li></ul></li><li><strong>网络传输层</strong>（<code>Transport</code>）：抽象<code>mina和netty</code>为统一接口，以Message为中心，扩展接口为<code>Channel、Transporter、Client、Server和Codec</code>。</li><li><strong>数据序列化层</strong>（<code>Serialize</code>）：数据序列化层和可复用的一些工具，dubbo 协议缺省为 hessian2，rmi 缺省为 java，http 缺省为 json。扩展接口为<code>Serialization、 ObjectInput、ObjectOutput和ThreadPool</code>。</li></ul></li></ol><h2 id="启动时检查"><a href="#启动时检查" class="headerlink" title="启动时检查"></a>启动时检查</h2><ul><li>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=“true”。</li><li> 可以通过 check=“false” 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。 </li><li>另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=“false”，总是会返回引用，当服务恢复时，能自动连上。</li></ul><h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250710180009155.png" alt="image-20250710180009155"></p><h3 id="各节点的关系"><a href="#各节点的关系" class="headerlink" title="各节点的关系"></a>各节点的关系</h3><ol><li><code>Invoker</code> 是 Provider 的一个可调用 Service 的抽象，Invoker 封装了 Provider 地址及 Service 接口信息。 </li><li><code>Directory</code> 代表多个 Invoker，可以把它看成 List ，但与 List 不同的是，它的值可能是<strong>动态变化</strong>的，比如注册中心推送变更。 </li><li><code>Cluster</code> 将 Directory 中的多个 Invoker 伪装成一个 Invoker，对上层透明，伪装过程<strong>包含了容错逻辑</strong>，调用失败后重试另一个。 </li><li><code>Router</code> 负责从多个 Invoker 中<strong>按路由规则选出子集</strong>，比如读写分离，应用隔离等。 </li><li><code>LoadBalance</code> 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程<strong>包含了负载均衡算法</strong>，调用失败后，需要重选。 </li></ol><h3 id="集群容错模式"><a href="#集群容错模式" class="headerlink" title="集群容错模式"></a>集群容错模式</h3><ol><li><p><strong>Failover Cluster：</strong>失败自动切换（默认），当出现失败，重试其它服务器。</p><p>通常用于<strong>读操作</strong>，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。由<code>FailoverClusterInvoker</code>实现，原理是先获得retries的值，再通过for循环依次调用服务，如果成功则返回，如果失败则循环调用直至循环结束。  </p></li><li><p><strong>Failfast Cluster：</strong>快速失败，只发起一次调用，失败立即报错。</p><p>通常用于<strong>非幂等性的写操作</strong>，比如新增记录。由<code>FailfastClusterInvoker</code>实现，原理是直接调用一次。</p></li><li><p><strong>Failsafe Cluster：</strong>失败安全，出现异常时，直接忽略。</p><p>通常用于<strong>写入审计日志等操作</strong>。由<code>FailsaveClusterInvoker</code>实现。 </p></li><li><p><strong>Failback Cluster：</strong>失败自动恢复，后台记录失败请求，定时重发。</p><p>通常用于<strong>消息通知操作</strong>。由<code>FailbackClusterInvoker</code>实现，原理是，执行调用，出现异常后把错误放入<code>ConcurrentHashMap</code>，用任务调度线程池延迟5秒来重新执行调用，如果再失败，记录日志，不再调用。</p></li><li><p><strong>Forking Cluster：</strong>并行调用多个服务器，只要一个成功即返回。</p><p>通常用于<strong>实时性要求较高的读操作</strong>，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。 </p></li><li><p><strong>Broadcast Cluster：</strong>广播调用所有提供者，逐个调用，任意一台报错则报错。</p><p>通常用于<strong>通知所有提供者</strong>更新缓存或日志等本地资源信息。</p></li></ol><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>（1）<strong>随机</strong>（<code>Random LoadBalance</code>）按照权重设置随机概率（默认）。<br>（2）<strong>轮询</strong>（<code>RoundRobin LoadBalance</code>）<br>（3）<strong>最少活跃调用数</strong>（<code>LeastActive LoadBalance</code>），相同活跃调用数的随机<br>（4）<strong>一致性Hash</strong>（<code>ConsistencyHash LoadBalance</code>）一致性Hash，相同参数的请求总是发到同一提供者</p><h2 id="多协议"><a href="#多协议" class="headerlink" title="多协议"></a>多协议</h2><p>Dubbo 允许配置多协议，在不同服务上或者同一服务上同时支持多种协议。</p><ol><li><p>在不同服务上支持不同协议<br>不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;world&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;registry&quot;</span> <span class="attr">address</span>=<span class="string">&quot;10.20.141.150:9090&quot;</span> <span class="attr">username</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">password</span>=<span class="string">&quot;hello1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多协议配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;rmi&quot;</span> <span class="attr">port</span>=<span class="string">&quot;1099&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用dubbo协议暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;dubbo&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用rmi协议暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.hello.api.DemoService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;rmi&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在同一服务上支持多种协议<br>需要与 http 客户端互操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;world&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;registry&quot;</span> <span class="attr">address</span>=<span class="string">&quot;10.20.141.150:9090&quot;</span> <span class="attr">username</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">password</span>=<span class="string">&quot;hello1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多协议配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;hessian&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用多个协议暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;dubbo,hessian&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th>协议</th><th>稳定性</th><th>优点</th><th>缺点</th><th>建议</th></tr></thead><tbody><tr><td>Dubbo协议</td><td>Stable</td><td>采用NIO复用单一长连接，并使用线程池并发处理请求，减少握手和加大并发效率，性能较好（推荐使用）</td><td>在大文件传输时，单一连接会成为瓶颈</td><td>可用于生产环境</td></tr><tr><td>Rmi协议</td><td>Stable</td><td>可与原生RMI互操作，基于TCP协议</td><td>偶尔会连接失败，需重建Stub</td><td>可用于生产环境</td></tr><tr><td>Hessian协议</td><td>Stable</td><td>可与原生Hessian互操作，基于HTTP协议</td><td>需hessian.jar支持，http短连接的开销大</td><td>可用于生产环境</td></tr></tbody></table><p>此外还支持webservice、http、Thrift、memcached、redis、rest等协议。</p><h2 id="Dubbo序列化"><a href="#Dubbo序列化" class="headerlink" title="Dubbo序列化"></a>Dubbo序列化</h2><table><thead><tr><th>协议</th><th>稳定性</th><th>优点</th><th>缺点</th><th>建议</th></tr></thead><tbody><tr><td>Hessian Serialization</td><td>Stable</td><td>性能较好，多语言支持（推荐使用）</td><td>Hessian的各版本兼容性不好，可能和应用使用的Hessian冲突，Dubbo内嵌了hessian3.2.1的源码</td><td>可用于生产环境</td></tr><tr><td>Dubbo Serialization</td><td>Stable</td><td>通过不传送POJO的类元信息，在大量POJO传输时，性能较好</td><td>当参数对象增加字段时，需外部文件声明</td><td>试用</td></tr><tr><td>Json Serialization</td><td>Stable</td><td>纯文本，可跨语言解析，缺省采用FastJson解析</td><td>性能较差</td><td>试用</td></tr><tr><td>Java Serialization</td><td>Stable</td><td>Java原生支持</td><td>性能较差</td><td>可用于生产环境</td></tr></tbody></table><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。另外，注册中心是支持自定义扩展的。</p><table><thead><tr><th>协议</th><th>稳定性</th><th>优点</th><th>缺点</th><th>建议</th></tr></thead><tbody><tr><td>Zookeeper注册中心</td><td>Stable</td><td>支持基于网络的集群方式，有广泛周边开源产品，建议使用dubbo-2.3.3以上版本（推荐使用）</td><td>依赖于Zookeeper的稳定性</td><td>可用于生产环境</td></tr><tr><td>Redis注册中心</td><td>Stable</td><td>支持基于客户端双写的集群方式，性能高</td><td>要求服务器时间同步，用于检查心跳过期脏数据</td><td>可用于生产环境</td></tr><tr><td>Multicast注册中心</td><td>Tested</td><td>去中心化，不需要安装注册中心</td><td>依赖于网络拓扑和路由，跨机房有风险</td><td>小规模应用或开发测试环境</td></tr><tr><td>Simple注册中心</td><td>Tested</td><td>Dogfooding，注册中心本身也是一个标准的RPC服务</td><td>没有集群支持，可能单点故障</td><td>试用</td></tr></tbody></table><h2 id="Dubbo服务降级"><a href="#Dubbo服务降级" class="headerlink" title="Dubbo服务降级"></a>Dubbo服务降级</h2><p>可以通过服务降级功能 临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。<br>服务降级就是当服务响应超时或连接请求超时，不用继续等下去，而采用降级措施，返回一个我们自己定义好的提示。而为什么要使用服务降级，这是防止分布式服务发生雪崩效应。当一个请求发生超时，一直等待着服务响应，那么在高并发情况下，很多请求都是因为这样一直等着响应，直到服务资源耗尽产生宕机，而宕机之后会导致分布式其他服务调用该宕机的服务也会出现资源耗尽宕机，这样下去将导致整个分布式服务都瘫痪。集群环境下，当一台服务宕机之后，其他流量分发到其他集群机器上，压力也会随之加大，时间久了整个集群也会垮了，这只是个时间问题。为了防止产生了雪崩效应那么就该对服务配置降级，一旦请求超过规定时间立即返回自定义好的提示，无需继续等待。<br>dubbo中有提供一个叫做mock的配置，mock只在出现非业务异常(比如超时，网络异常等)时执行。mock的配置支持两种：<br>（1）采用return null,返回简单的空<br>打开项目里的consumer.xml修改dubbo:reference配置即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.cwh.service.UserService&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;3000&quot;</span> <span class="attr">mock</span>=<span class="string">&quot;return null&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在服务提供者例如UserServiceImpl中的getUser方法打个断点来模拟请求超时。然后浏览器访问，断点不过，一致等待，当时间超过3秒，直接返回了空，这样就已经实现了一个简单的服务降级了<br>（2）采用自定义提示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.cwh.service.UserService&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;3000&quot;</span> <span class="attr">mock</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在service包下也就是同UserService目录下新建一个UserServiceMock，注意这里名字一点要是该接口名+Mock：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceMock</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt;getUser(String name)&#123;</span><br><span class="line">        <span class="comment">//throw new RuntimeException(&quot;服务降级-----&quot;);</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserName(<span class="string">&quot;服务降级啦&quot;</span>);</span><br><span class="line">        user.setUserAge(<span class="string">&quot;500&quot;</span>);</span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">        list.add(user);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dubbo灰度发布"><a href="#Dubbo灰度发布" class="headerlink" title="Dubbo灰度发布"></a>Dubbo灰度发布</h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用，用法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.dubbo.demo.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>利用dubbo该特性，我们能够实现一些功能的灰度发布，实现步骤如下： </p><ol><li>接口旧的实现定义version=“1.0.0”，接口新的实现version=“2.0.0” </li><li>Consumer端定义version=”*” </li><li>这样定义Provider和Consumer后，新旧接口实现各承担50%的流量 </li><li>利用dubbo该特性，还能完成不兼容版本迁移：<ol><li>在低压力时间段，先升级一半Provider为新版本；</li><li>再将所有消费者升级为新版本；</li><li>然后将剩下的一半提供者升级为新版本。</li></ol></li></ol><h2 id="Dubbo异步调用"><a href="#Dubbo异步调用" class="headerlink" title="Dubbo异步调用"></a>Dubbo异步调用</h2><p>默认是同步等待结果阻塞的，支持异步调用。通过<code>asyanc</code>属性设置异步，若设置异步，则无需等待该方法返回值，程序即可往下进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Methoda();</span><br><span class="line">Sysout(o);</span><br><span class="line">Methodb();</span><br></pre></td></tr></table></figure><p>(1) 打印结果为null     (2) Timeout不会超时，所以不会重试</p><p>Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。异步调用流程图如下：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250710180027041.png" alt="image-20250710180027041"></p><hr><h1 id="Dubbo实践"><a href="#Dubbo实践" class="headerlink" title="Dubbo实践"></a>Dubbo实践</h1><h2 id="Dubbo快速入门"><a href="#Dubbo快速入门" class="headerlink" title="Dubbo快速入门"></a>Dubbo快速入门</h2><ol><li>创建服务提供者<code>Provider</code>模块</li><li>创建服务消费者<code>Consumer</code>模块</li><li>在服务提供者模块编写<code>UserServiceImpl</code>提供服务</li><li>在服务消费者中的<code>UserController</code>远程调用<code>UserServiceImpl</code>提供的服务</li><li>分别启动两个服务，测试</li></ol><h2 id="企业中如何通过Dubbo实现分布式调用"><a href="#企业中如何通过Dubbo实现分布式调用" class="headerlink" title="企业中如何通过Dubbo实现分布式调用"></a>企业中如何通过Dubbo实现分布式调用</h2><p>在企业中，如果消费者直接通过RPC去调用提供者，理论上需要把提供者的整个Jar包引入到项目中。但是这样的话服务提供这种的其他无关代码也会被引入其中，导致代码污染。</p><p>因此实际开发过程中，服务提供者和调用者之间会增加一层Client模块。这个Client中主要写的是Service的接口定义，接口的返回实例对象以及接口的请求实例对象。简单来讲，所有的定义都在Client中完成。 使用时，服务提供者引入这个Client，然后写实现方法，服务消费者引入这个Client，然后通过dubbo直接调用即可。 </p><p>另外企业开发中，可能会出现多个接口实现，这种情况下可以给Service设定group、version等进行区分。</p><h2 id="dubbo-client-模块"><a href="#dubbo-client-模块" class="headerlink" title="dubbo-client 模块"></a>dubbo-client 模块</h2><p>定义一个<strong>公共的客户端服务</strong>，命名为<code>dubbo-client</code>，这个服务里存放的是service接口，整体代码结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dubbo-client</span><br><span class="line">    src</span><br><span class="line">        main</span><br><span class="line">            java</span><br><span class="line">                entity</span><br><span class="line">                    User</span><br><span class="line">                service</span><br><span class="line">                    UserService(interface)</span><br><span class="line">            resources</span><br><span class="line">                application.yml</span><br></pre></td></tr></table></figure><p>UserService接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    User <span class="title function_">getUser</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义User类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">9206514891359830486L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dubbo-provider-模块"><a href="#dubbo-provider-模块" class="headerlink" title="dubbo-provider 模块"></a>dubbo-provider 模块</h2><p>服务提供者引入 dubbo-client 工程，写实现类，提供dubbo接口，见后文配置文件编写。</p><p>服务提供者需要写服务的实现类，这里需要注意**@Service注解采用的是dubbo包下**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.javayz.client.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.javayz.client.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setName(<span class="string">&quot;javayz&quot;</span>);</span><br><span class="line">        user.setSex(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在启动类上添加一个<code>@EnableDubbo</code>注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootproviderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootproviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dubbo-consumer-模块"><a href="#dubbo-consumer-模块" class="headerlink" title="dubbo-consumer 模块"></a>dubbo-consumer 模块</h2><p>服务消费者引入 dubbo-client 工程，通过这个工程的service接口调用，见后文配置文件编写。</p><p>服务的消费者同样是先编辑好配置文件，如上，接着通过**@Reference注解将service对象引进来**:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootconsumerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootconsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ApplicationRunner <span class="title function_">getBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            System.out.println(userService.getUser(<span class="number">1L</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="provider-与-consumer-配置文件"><a href="#provider-与-consumer-配置文件" class="headerlink" title="provider 与 consumer 配置文件"></a>provider 与 consumer 配置文件</h2><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入项目 dubbo-client --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.javayz<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 zookeeper --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!-- 引入 dubbo --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SpringBoot方式"><a href="#SpringBoot方式" class="headerlink" title="SpringBoot方式"></a>SpringBoot方式</h3><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">dubbo-provider</span></span><br><span class="line"><span class="comment"># 若是替换成消费者 dubbo-consumer</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.protocol.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">20880</span></span><br></pre></td></tr></table></figure><p>或者 application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span>   <span class="comment"># 自己的zookeeper服务器的IP:默认端口号</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-zookeeper-producer1</span> <span class="comment"># 注册进去的名字 服务提供者</span></span><br><span class="line">    <span class="comment"># name: dubbo-zookeeper-consumer1 # 若是消费者替换成dubbo-zookeeper-consumer1</span></span><br><span class="line">  <span class="attr">protocol:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo</span>     <span class="comment"># 设置类型</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">-1</span>      <span class="comment"># 因为dubbo的服务器端口号是不能唯一的，所以，设置为-1会帮我们自动改变端口号</span></span><br><span class="line">  <span class="attr">config-center:</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">120000</span>  <span class="comment"># 超时时间  （毫秒）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line">  <span class="comment"># port: 8083  # 若是消费者替换成8083</span></span><br></pre></td></tr></table></figure><h3 id="Spring方式"><a href="#Spring方式" class="headerlink" title="Spring方式"></a>Spring方式</h3><p>在resource文件夹下新建两个配置文件： provider.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;sample-provider&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用zookeeper广播注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://192.168.78.128:2181&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.javayz.client.service.UserService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javayz.example1.service.impl.UserServiceImpl&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>consumer.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;sample-consumer&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://192.168.78.128:2181&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.javayz.client.service.UserService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着是服务的提供者和消费者配置注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务提供者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDubboProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;provider.xml&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务已经暴露&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDubboConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;consumer.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        System.out.println(bean.getUser(<span class="number">1L</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dubbo的常用配置"><a href="#dubbo的常用配置" class="headerlink" title="dubbo的常用配置"></a>dubbo的常用配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span>/&gt;</span> 用于配置当前应用信息</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:register</span>/&gt;</span> 用于配置连接注册相关信息</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span>/&gt;</span> 用于配置提供服务的协议信息，提供者指定协议，消费者被动接受</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span>/&gt;</span> 用于暴露一个服务，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span>/&gt;</span> 当ProtocolConfig和ServiceConfig某属性没有配置时，采用此缺省值</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span>/&gt;</span> 当ReferenceConfig某属性没有配置时，采用此缺省值</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span>/&gt;</span> 用于创建一个远程服务代理</span><br></pre></td></tr></table></figure><h2 id="直接代码"><a href="#直接代码" class="headerlink" title="直接代码"></a>直接代码</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.javayz<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 若使用注册中心，以zookeeper为例，需引入zookeeper相关依赖： zk客户端依赖：curator --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写服务提供者"><a href="#编写服务提供者" class="headerlink" title="编写服务提供者"></a>编写服务提供者</h3><p>服务提供者主要配置以下几个属性： </p><ol><li>**<code>application</code>**：设置应用的名称等信息 </li><li>**<code>protocol </code>**：设置服务的协议 </li><li>**<code>register</code>**：设置服务的连接方式 </li><li>**<code>service</code>**：将需要暴露的服务注册出来</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//暴露UserService服务</span></span><br><span class="line">        <span class="comment">//1、application</span></span><br><span class="line">        ApplicationConfig applicationConfig=<span class="keyword">new</span> <span class="title class_">ApplicationConfig</span>(<span class="string">&quot;sample-provider&quot;</span>);</span><br><span class="line">        <span class="comment">//2、protocol -dubbo协议</span></span><br><span class="line">        <span class="type">ProtocolConfig</span> <span class="variable">protocolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolConfig</span>();</span><br><span class="line">        protocolConfig.setName(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">        protocolConfig.setPort(<span class="number">20880</span>);</span><br><span class="line">        <span class="comment">//3、register</span></span><br><span class="line">        <span class="comment">//直连的方式，不暴露到注册中心</span></span><br><span class="line">        RegistryConfig registryConfig=<span class="keyword">new</span> <span class="title class_">RegistryConfig</span>(RegistryConfig.NO_AVAILABLE);</span><br><span class="line">        <span class="comment">//通过注册中心暴露dubbo</span></span><br><span class="line">        RegistryConfig registryConfig=<span class="keyword">new</span> <span class="title class_">RegistryConfig</span>(<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>); </span><br><span class="line">        <span class="comment">//4、service</span></span><br><span class="line">        ServiceConfig serviceConfig=<span class="keyword">new</span> <span class="title class_">ServiceConfig</span>();</span><br><span class="line">        serviceConfig.setInterface(UserService.class);</span><br><span class="line">        serviceConfig.setRef(<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>());</span><br><span class="line">        <span class="comment">//5、将application、protocol、register注册到service</span></span><br><span class="line">        serviceConfig.setRegistry(registryConfig);</span><br><span class="line">        serviceConfig.setProtocol(protocolConfig);</span><br><span class="line">        serviceConfig.setApplication(applicationConfig);</span><br><span class="line">        serviceConfig.export();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务已经暴露&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写服务消费者"><a href="#编写服务消费者" class="headerlink" title="编写服务消费者"></a>编写服务消费者</h3><p>消费者的实现主要就三步： </p><ol><li><strong>配置<code>application</code>：</strong>设置应用的名称等信息</li><li><strong>配置<code>reference</code>：</strong>主要配置要引用的信息 </li><li>获取到接口，调用服务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1、application</span></span><br><span class="line">        ApplicationConfig applicationConfig=<span class="keyword">new</span> <span class="title class_">ApplicationConfig</span>(<span class="string">&quot;sample-consumer&quot;</span>);</span><br><span class="line">        <span class="comment">//2、配置reference</span></span><br><span class="line">        ReferenceConfig referenceConfig=<span class="keyword">new</span> <span class="title class_">ReferenceConfig</span>();</span><br><span class="line">        referenceConfig.setApplication(applicationConfig);</span><br><span class="line">        referenceConfig.setInterface(UserService.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// referenceConfig.setUrl(&quot;dubbo://172.18.2.49:20880/com.javayz.client.service.UserService?anyhost=true&amp;application=sample&amp;bind.ip=172.18.2.49&amp;bind.port=20880&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=com.javayz.client.service.UserService&amp;methods=getUser&amp;pid=5936&amp;release=2.7.4.1&amp;side=provider&amp;timestamp=1618036935244&quot;);</span></span><br><span class="line">        <span class="comment">// 或者 将referenceConfig中的setUrl方法替换为zookeeper</span></span><br><span class="line">        RegistryConfig registryConfig=<span class="keyword">new</span> <span class="title class_">RegistryConfig</span>(<span class="string">&quot;zookeeper://192.168.78.128:2181&quot;</span>);</span><br><span class="line">        referenceConfig.setRegistry(registryConfig);</span><br><span class="line">        </span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) referenceConfig.get();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUser(<span class="number">1L</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动提供者，再启动消费者，如果user信息打印出来了就说明调用成功。</p><h1 id="Dubbo-amp-Spring-Cloud"><a href="#Dubbo-amp-Spring-Cloud" class="headerlink" title="Dubbo &amp; Spring Cloud"></a>Dubbo &amp; Spring Cloud</h1><h2 id="Dubbo特点"><a href="#Dubbo特点" class="headerlink" title="Dubbo特点"></a>Dubbo特点</h2><ul><li><strong>远程通讯</strong>：提供对多种基于长连接的 NIO 框架抽象封装（非阻塞 I/O 的通信方式，Mina/Netty/Grizzly），包括多种线程模型，序列化（Hessian2/ProtoBuf），以及“请求-响应”模式的信息交换方式。 </li><li><strong>集群容错</strong>：提供基于接口方法的透明远程过程调用（RPC），包括多协议支持（自定义 RPC 协议），以及软负载均衡（Random/RoundRobin），失败容错（Failover/Failback），地址路由，动态配置等集群支持。</li><li><strong>自动发现</strong>：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ul><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>Spring Cloud 基于 Spring Boot，为微服务体系开发中的架构问题，提供了一整套的解决方案——服务注册与发现，服务消费，服务保护与熔断，网关，分布式调用追踪，分布式配置管理等。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/3e222e0786824db289336b44de42cb1.png" alt="3e222e0786824db289336b44de42cb1"></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/df9a39637a9f01e8fb2d0e6cc490967.png" alt="df9a39637a9f01e8fb2d0e6cc490967"></p><h2 id="Dubbo-vs-Spring-Cloud"><a href="#Dubbo-vs-Spring-Cloud" class="headerlink" title="Dubbo vs Spring Cloud"></a>Dubbo vs Spring Cloud</h2><table><thead><tr><th></th><th>Dubbo</th><th>Spring Cloud</th></tr></thead><tbody><tr><td>服务注册中心</td><td>Zookeeper</td><td>Spring Cloud Netflix Eureka</td></tr><tr><td>服务调用方式</td><td>RPC</td><td>REST API</td></tr><tr><td>服务监控</td><td>Dubbo-monitor</td><td>Spring Boot Admin</td></tr><tr><td>断路器</td><td>不完善</td><td>Spring Cloud Netflix Hystrix</td></tr><tr><td>服务网关</td><td>无</td><td>Spring Cloud Netflix Zuul</td></tr><tr><td>分布式配置</td><td>无</td><td>Spring Cloud Config</td></tr><tr><td>服务跟踪</td><td>无</td><td>Spring Cloud Sleuth</td></tr><tr><td>消息总线</td><td>无</td><td>Spring Cloud Bus</td></tr><tr><td>数据流</td><td>无</td><td>Spring Cloud Stream</td></tr><tr><td>批量任务</td><td>无</td><td>Spring Cloud Task</td></tr><tr><td>……</td><td>……</td><td>……</td></tr></tbody></table><p>使用 Dubbo 构建的微服务架构就像组装电脑，各环节的选择自由度很高，但最终结果很有可能因为一条内存质量不行就点不亮了；而 Spring Cloud 就像品牌机，在 Spring Source 的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但若要在使用非原装组件外的东西，就需要对其基础有足够的了解。</p><p>Spring Cloud是真正的微服务框架、提供整套的组件支持、使用简单方便、强大的社区支持等等，另外考虑到 .NET/.NET Core 的兼容处理，RPC 并不能很好的实现跨语言（需要借助跨语言库，比如 gRPC、Thrift，但因为 Dubbo 本身就是“gRPC”，在 Dubbo 之上再包一层 gRPC，有点重复封装了），而 HTTP REST 本身就是支持跨语言实现，所以，Spring Cloud 这一点还是非常好的（Dubbox 也支持，但性能相比要差一些）。</p><p>凡事无绝对，每件事物有好的地方也有不好的地方，总的来说，Dubbo 和 Spring Cloud 的主要不同体现在两个方面：服务调用方式不同和专注点不同（生态不同）。</p>]]></content>
    
    
    <summary type="html">Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案及SOA服务治理方案。</summary>
    
    
    
    <category term="Middleware" scheme="https://southernfish.github.io/categories/Middleware/"/>
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="Dubbo" scheme="https://southernfish.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>远程过程调用</title>
    <link href="https://southernfish.github.io/2025/07/09/middleware/rpc/"/>
    <id>https://southernfish.github.io/2025/07/09/middleware/rpc/</id>
    <published>2025-07-09T11:35:36.000Z</published>
    <updated>2025-07-10T12:47:35.024Z</updated>
    
    <content type="html"><![CDATA[<p>RPC（Remote Procedure Call）是一种允许程序像调用本地方法一样调用远程服务的通信协议，其核心价值在于屏蔽网络通信的底层复杂性，这与中间件“连接异构系统、简化开发”的核心目标完全一致。本文参考文章：<a href="https://blog.csdn.net/yuiezt/article/details/140190124">什么是RPC？有哪些RPC框架？</a>、<a href="https://cloud.tencent.com/developer/article/1506792">一文搞定理解RPC</a>、<a href="https://blog.csdn.net/weixin_53580595/article/details/142744919">—RPC介绍一篇就够了&amp;RPC的选择</a>。推荐文章：<a href="https://cloud.tencent.com/developer/article/2021745?policyId=1004">从原理到选型，一文带你搞懂RPC</a></p><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RPC是远程过程调用（Remote Procedure Call）的缩写，是一种允许运行在一台计算机上的程序调用另一台计算机上子程序的技术。SAP系统RPC调用的原理其实很简单，有一些类似于三层构架的C/S系统，第三方的客户程序通过接口调用SAP内部的标准或自定义函数，获得函数返回的数据进行处理后显示或打印。远程过程调用（RPC）跨越了开放系统互连（OSI）网络通信模型中的传输层和应用层。</p><p><strong>完整的RPC框架：</strong>服务发现、负载、容错、网络传输、序列化等组件</p><h2 id="RPC协议"><a href="#RPC协议" class="headerlink" title="RPC协议"></a>RPC协议</h2><p>常说的RPC其实是RPC协议，即一种专门为服务间远程调用而设计的一种通用协议。该协议基于其它已有的传输协议，规定通信方式为C/S架构；并且在代码开发过程中要屏蔽掉底层通信细节，让开发者像调用本地方法一样，调用远程服务。RPC机制使得开发者能够构建分布式计算系统，其中不同的组件可以分布在不同的计算机上，但它们之间可以像在同一台机器上一样相互调用。</p><h2 id="RPC组成"><a href="#RPC组成" class="headerlink" title="RPC组成"></a>RPC组成</h2><p>基于RPC协议内容的说明来看RPC的主要组成： </p><ul><li>确定一个已有的传输协议（TCP\UDP\HTTP\Websocket等）</li><li>一个客户端通信实现模块(即客户端stub) </li><li>一个服务端通信实现模块(即服务端stub) </li><li>选择一个RPC内容协议（如：json、xml、protobuf等）</li></ul><p>RPC主要有 5 个部分组成，分别是：<em>客户端、客户端 Stub、网络传输模块、服务端 Stub、服务端</em>等。<br><strong>客户端(Client)：</strong>服务调用方。<br><strong>客户端存根(Client Stub)：</strong>存放服务端地址信息，将客户端请求参数数据信息打包成网络消息，通过网络传输发送给服务端。<br><strong>服务端存根(Server Stub)：</strong>接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。<br><strong>服务端(Server)：</strong>服务的真正提供者。<br><strong>Network Service：</strong>底层传输，可以是 TCP 或 HTTP。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250619112443294.png" alt="image-20250619112443294"></p><h2 id="现代化RPC框架的特点"><a href="#现代化RPC框架的特点" class="headerlink" title="现代化RPC框架的特点"></a>现代化RPC框架的特点</h2><ul><li><strong>高性能</strong>：现代RPC框架通常采用高效的序列化协议和网络传输协议，以提高通信性能。</li><li><strong>跨语言支持</strong>：支持多种编程语言，使得不同语言编写的服务可以无缝通信。 </li><li><strong>可扩展性</strong>：提供负载均衡、服务注册与发现等功能，以支持大规模分布式系统的部署和运维。</li><li><strong>安全性</strong>：支持加密传输和身份验证等安全机制，保障通信过程中的数据安全和隐私保护。</li></ul><h2 id="为什么需要RPC"><a href="#为什么需要RPC" class="headerlink" title="为什么需要RPC"></a>为什么需要RPC</h2><p>微服务、分布式应用的开发越来越常见，RPC可以<strong>解决各个节点之间的服务调用以及通信问题</strong>。</p><p><strong>RPC框架会帮助我们做这些事情</strong>：</p><ul><li>客户端stub、服务端stub的实现</li><li>通信内容的序列化与反序列化实现（json、xml、protobuf） </li><li>服务的注册与发现</li><li>服务方负载均衡</li><li>并发性能调优</li></ul><p>有了RPC框架后，不需要再单独为项目开发这些基础功能了，这样开发具有RPC功能的客户端、服务端都跟开发普通本地模块一样方便。</p><p><strong>RPC优点</strong>：</p><ul><li>调用远程服务像调用本地方法一样方便</li><li>多种传输协议可以选择</li><li>为系统提供较强可扩展性、高可用性、维护性</li></ul><p><strong>治理功能</strong>，比如连接管理、健康检测、负载均衡、优雅启停机、异常重试、业务分组以及熔断限流等等</p><h2 id="RPC协议的实现"><a href="#RPC协议的实现" class="headerlink" title="RPC协议的实现"></a>RPC协议的实现</h2><p> <code>dubbo</code>、<code>grpc</code>、<code>restful</code>、<code>thrift</code>、<code>http</code></p><p><code>rmi</code>、<code>hessian</code>、<code>webserivice</code>、<code>memcached</code>、<code>redis</code>、<code>rest</code>、<code>jsonrpc</code>、<code>motan</code>、<code>yar</code></p><p>这些协议可以适用于不同的业务场景，比如：<code>dubbo</code>协议适合高频的小数据量调用，<code>hessian</code>则适合文件传输，而<code>jsonrpc</code>、<code>grpc</code>则适合跨语言的应用。这些协议也与TCP等协议类似，都规定了自己的<code>头信息</code>和<code>body</code>部分，用于约定通信的规则。</p><h2 id="RPC实现思路"><a href="#RPC实现思路" class="headerlink" title="RPC实现思路"></a>RPC实现思路</h2><p>首先远程调用的大致链路其实都是大同小异的，大概可以分解出以下几个步骤：</p><ul><li><strong>定义接口和数据类型</strong>：首先需要定义接口和数据类型，包括接口方法名、参数类型、返回值类型等。这些定义通常使用IDL（Interface Definition Language）语言来描述，以便于不同语言之间的调用和序列化。 </li><li><strong>生成代码</strong>：根据接口和数据类型的定义，生成客户端和服务器端的代码。这些代码通常包括序列化和反序列化方法、网络传输方法等，以便于客户端和服务器端进行数据交换和通信。</li><li><strong>实现服务器端</strong>（被调用方）：在服务器端实现接口方法，根据客户端请求进行相应的处理，并将处理结果返回给客户端。服务器端还需要实现服务注册和发现、负载均衡、容错等机制，以提高系统的可用性和可靠性。 </li><li><strong>实现客户端</strong>（调用方）：在客户端调用远程接口方法，将参数序列化并通过网络发送给服务器端，然后等待服务器端返回处理结果，并将结果反序列化后返回给调用方。客户端还需要实现服务发现和选择、负载均衡、重试等机制，以提高系统的可用性和可靠性。 </li><li><strong>集成框架</strong>：将生成的代码和实现的服务器端、客户端集成到RPC框架中，并提供相应的API和工具，以便于开发人员使用和集成。</li><li><strong>测试和优化</strong>：对实现的RPC框架进行测试和优化，包括性能测试、功能测试、安全测试等，以确保系统的稳定性、可靠性和安全性。</li></ul><h2 id="RPC与HTTP的区别"><a href="#RPC与HTTP的区别" class="headerlink" title="RPC与HTTP的区别"></a>RPC与HTTP的区别</h2><p>RPC 和 HTTP 本质上是<strong>面向不同场景的产物</strong>。而RPC也可以基于HTTP协议来实现信息内容的传输。<br>RPC 和 HTTP 还有如下典型的区别： </p><ul><li>RPC 可以基于 TCP、HTTP、WebStock 等作为基础传输协议，而 HTTP 只能是 http 协议</li><li>RPC 使用二进制来传输信息内容（体积更小），HTTP 则使用文本格式</li><li>RPC 的二进制序列化效率高，HTTP 的文本序列化（如json）则耗时多</li><li>RPC 基于 TCP 时可以网络 IO 多路复用，HTTP 不能很好的支持</li><li>RPC 可以很方便支持服务治理，而 HTTP 则需要单独实现支持</li></ul><p>简而言之，就是RPC在远程调用的场景下，比 HTTP 更高效，更简洁、附加特性更强大，更适合分布式和微服务的场景。</p><h2 id="RPC的应用"><a href="#RPC的应用" class="headerlink" title="RPC的应用"></a>RPC的应用</h2><p>RPC在分布式系统中的系统环境建设和应用程序设计中有着广泛的应用，应用包括如下方面： </p><ol><li><strong>分布式操作系统的进程间通讯</strong><br>进程间通讯是操作系统必须提供的基本设施之一，分布式操作系统必须提供分布于异构的结点机上进程间的通讯机制，RPC是实现消息传送模式的分布式进程间通讯的手段之一。 </li><li><strong>构造分布式计算的软件环境</strong><br>由于分布式软件环境本身地理上的分布性，它的各个组成成份之间存在大量的交互和通讯，RPC 是其基本的实现方法之一。ONC+和DCE两个流行的分式布计算软件环境都是使用RPC构造的，其它一些分布式软件环境也采用了RPC方式。</li><li><strong>远程数据库服务</strong><br>在分布式数据库系统中，数据库一般驻存在服务器上，客户机通过远程数据库服务功能访问数据库服务器，现有的远程数据库服务是使用RPC模式的。例如，<code>Sybase</code>和<code>Oracle</code>都提供了存储过程机制，系统与用户定义的存储过程存储在数据库服务器上，<em>用户在客户端使用RPC模式调用存储过程</em>。 </li><li><strong>分布式应用程序设计</strong><br>RPC机制与RPC工具为分布式应用程序设计提供了手段和方便, 用户可以无需知道网络结构和协议细节而直接使用RPC工具设计分布式应用程序。 </li><li><strong>分布式程序的调试</strong><br>RPC可用于分布式程序的调试。使用反向RPC使服务器成为客户并向它的客户进程发出RPC，可以调试分布式程序。例如，在服务器上运行一个远端调试程序，它不断接收客户端的RPC，当遇到一个调试程序断点时，它向客户机发回一个RPC，通知断点已经到达，这也是RPC用于进程通讯的例子。</li></ol><hr><h1 id="RPC-原理"><a href="#RPC-原理" class="headerlink" title="RPC 原理"></a>RPC 原理</h1><h2 id="RPC-调用流程"><a href="#RPC-调用流程" class="headerlink" title="RPC 调用流程"></a>RPC 调用流程</h2><ol><li><strong>服务消费者(Client 客户端)<strong>通过本地调用的方式</strong>调用服务</strong>。</li><li>**客户端存根(Client Stub)<strong>接收到调用请求后负责将方法、入参等</strong>信息序列化(组装)**成能够进行网络传输的消息体。</li><li><strong>客户端存根(Client Stub)<strong>找到远程的服务地址，并且将消息通过网络</strong>发送给服务端</strong>。</li><li>**服务端存根(Server Stub)<strong>收到消息后进行</strong>解码(反序列化)**。</li><li>**服务端存根(Server Stub)**根据解码结果调用本地的服务进行相关处理</li><li><strong>服务端(Server)<strong>本地服务</strong>业务处理</strong>。并将处理结果返回给服务端存根(Server Stub)。</li><li>**服务端存根(Server Stub)**序列化结果。</li><li><strong>服务端存根(Server Stub)<strong>将结果通过网络</strong>发送至消费方</strong>。</li><li>**客户端存根(Client Stub)<strong>接收到消息，并进行</strong>解码(反序列化)**。</li><li><strong>服务消费者(Client 客户端)<strong>服务消费方得到</strong>最终结果</strong>。</li></ol><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250619112546216.png" alt="image-20250619112546216"></p><p>RPC 框架提供了一系列的功能来支持上述过程，包括但不限于：</p><ul><li><strong>接口定义</strong>：定义服务端和客户端之间的接口，确保双方能够正确理解和调用。 </li><li><strong>数据序列化与反序列化</strong>：将调用信息和结果转换为网络可传输的格式，并在接收时进行还原。 </li><li><strong>网络通信</strong>：封装底层的网络通信逻辑，使得开发者无需关心具体的网络细节。 </li><li><strong>负载均衡</strong>：在多个服务实例之间分配请求，提高系统的可扩展性和可用性。</li><li><strong>服务注册与发现</strong>：在分布式系统中，自动发现可用的服务实例。</li></ul><h2 id="透明化远程服务调用-实现"><a href="#透明化远程服务调用-实现" class="headerlink" title="透明化远程服务调用 实现"></a>透明化远程服务调用 实现</h2><p>对java来说就是使用代理！java代理有两种方式： <strong>jdk 动态代理</strong>和<strong>字节码生成</strong>。尽管字节码生成方式实现的代理更为强大和高效，但代码维护不易，大部分公司实现RPC框架时还是选择动态代理方式。 </p><p>通过动态代理模式，在执行该方法的前后对数据进行封装和解码等，让用于感觉就像是直接调用该方法一样，殊不知，我们对方法前后都经过了复杂的处理。</p><p>需要实现RPCProxyClient代理类，代理类的invoke方法中封装了与远端服务通信的细节，消费方首先从RPCProxyClient获得服务提供方的接口，当执行helloWorldService.sayHello(“test”)方法时就会调用invoke方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RPCProxyClient</span> <span class="keyword">implements</span> <span class="title class_">java</span>.lang.reflect.InvocationHandler&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RPCProxyClient</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj=obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到被代理对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> java.lang.reflect.Proxy.newProxyInstance(obj.getClass().getClassLoader(),</span><br><span class="line">                obj.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">RPCProxyClient</span>(obj));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用此方法执行</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 结果参数</span></span><br><span class="line">        <span class="comment">// ...执行通信相关逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;         </span><br><span class="line">     <span class="type">HelloWorldService</span> <span class="variable">helloWorldService</span> <span class="operator">=</span> (HelloWorldService)RPCProxyClient.getProxy(HelloWorldService.class);</span><br><span class="line">     helloWorldService.sayHello(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h1><p>封装好参数编组、消息解组、底层网络通信的RPC程序开发框架，带来的便捷是可以直接在其基础上只需要专注于过程代码编写。</p><h2 id="目前常用的RPC框架"><a href="#目前常用的RPC框架" class="headerlink" title="目前常用的RPC框架"></a>目前常用的RPC框架</h2><ol><li><p><strong>Dubbo</strong>：Dubbo是一个分布式服务框架，以及SOA治理方案。</p><p>其功能主要包括：高性能<code>NIO</code>通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。 </p><p>Dubbo是阿里巴巴内部的SOA服务化治理方案的核心框架，Dubbo自2011年开源后，已被许多非阿里系公司使用。</p></li><li><p><strong>Spring Cloud</strong>：Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。Spring Cloud基于Spring Boot, 使得开发部署极其简单。</p></li><li><p><strong>gRPC</strong>: 一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。</p></li><li><p><strong>Thrift</strong> :是一种轻量级的跨语言 RPC 通信方案，支持多达 25 种编程语言，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。</p></li></ol><h2 id="常见RPC框架对比"><a href="#常见RPC框架对比" class="headerlink" title="常见RPC框架对比"></a>常见RPC框架对比</h2><table><thead><tr><th></th><th>gRPC</th><th>Apache Dubbo</th><th>Apache Thrift</th><th>Motan</th></tr></thead><tbody><tr><td>开发者</td><td>Google</td><td>阿里巴巴</td><td>Apache</td><td>新浪微博开源</td></tr><tr><td>协议</td><td>使用HTTP/2协议作为底层传输协议，HTTP/2支持多路复用、头部压缩和服务器推送等特性，可提高性能和效率<br />使用<code>Protocol Buffers</code>（ProtoBuf）作为序列化协议，protobuf是一种高效紧凑的二进制序列化协议，适合高性能通信</td><td>支持多种传输协议，包括dubbo、rmi、http、hessian、webservice、rest等。<br/>支持多种序列化协议，如hessian、json、protobuf等</td><td>支持多种传输协议和序列化协议，如<code>TBinaryProtocol</code>、<code>TCompactProtocol</code>等</td><td>——</td></tr><tr><td>支持语言</td><td>支持多语言，包括C++、Java、Python、Go、Ruby、C#、Node.js等</td><td>主要基于Java，但可以通过扩展支持其他语言</td><td>支持多语言，包括C++、Java、Python、Go、Ruby、C#、Node.js等。</td><td>——</td></tr><tr><td>特点</td><td>提供强大的<code>IDL</code>（接口定义语言）和自动代码生成工具。<br/>支持双向流、流式传输等特性。<br/>适用于大规模分布式系统，要求高性能和跨语言支持的场景。<br/>适用于需要使用<code>Protocol Buffers</code>进行高效数据序列化的场景。</td><td>提供高性能、透明化的远程方法调用。<br/>支持负载均衡、服务发现、集群容错等特性。<br/>提供了REST风格的远程调用。<br/>适用于Java生态系统中的分布式应用，尤其是基于Spring的应用。<br/>适用于需要提供多协议支持和高度可扩展性的场景。</td><td>使用<code>IDL</code>进行接口定义，提供代码生成工具。<br/>支持异步和同步的通信方式。<br/>可以在不同语言之间进行跨语言通信。<br/>适用于异构系统中不同语言之间的远程调用。<br/>适用于需要高度定制和支持多种传输协议的场景。</td><td>是一个Java框架，具有高性能和可扩展性。<br/>在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。<br/>提供了丰富的功能和良好的性能表现。</td></tr><tr><td>优点</td><td>高性能、低延迟、跨语言支持、多种通信协议、流式传输支持。</td><td>丰富的服务治理功能、高度可扩展、支持大规模分布式系统、灵活的扩展机制。</td><td>跨语言支持、多种序列化方式、代码生成工具、高效的数据传输。</td><td>——</td></tr><tr><td>适用场景</td><td>大规模分布式系统、跨语言通信、需要高性能和低延迟的实时通信场景。</td><td>Java应用程序的分布式服务、需要服务治理功能的场景。</td><td>跨语言通信、大数据分析、需要高效数据传输的场景。</td><td>——</td></tr></tbody></table><h2 id="其他RPC框架"><a href="#其他RPC框架" class="headerlink" title="其他RPC框架"></a>其他RPC框架</h2><p><strong>其他框架</strong>：如<code>Tars</code>（腾讯内部使用并开源）、<code>ZeroMQ</code>（高性能异步消息传递库，非专门RPC框架）、<code>Akka</code>（并发编程框架，提供Actor模型实现）等。<br><strong>特点</strong>：</p><ul><li>这些框架各有特色，如 Tars 特别支持 C++ 语言，适合高性能要求的应用场景。</li><li>ZeroMQ 适用于构建高度异步、消息驱动的系统。</li><li>Akka 适用于构建高并发、分布式、容错性强的系统。</li></ul><h2 id="RPC协议选择"><a href="#RPC协议选择" class="headerlink" title="RPC协议选择"></a>RPC协议选择</h2><p>平时搭建业务一般可以通过业务上所需要的通信特点进行去选择。例如：</p><ul><li>如果是im场景下 WebRTC去提高通讯效率</li><li>如果是大型电商那种分布式系统的话可以使用gRPC，java则使用Dubbo</li><li>如果是搭建数据中心考虑跨语言则去选择Apache Thrift，</li><li>如果最简单平常的也可以直接利用Springcloud中的Spring Cloud Netflix项目实现的多种组件，如Ribbon、Feign、Hystrix等，用于构建分布式系统中的服务通信和治理。</li></ul><h2 id="序列化协议"><a href="#序列化协议" class="headerlink" title="序列化协议"></a>序列化协议</h2><p>对于<strong>如何标识数据的做法</strong>是将交互双方所涉及的数据转换为某种<strong>事先约定好的中立数据流格式</strong>来进行传输，将数据流转换回不同语言中对应的数据类型来进行使用，就是序列化协议的初衷。一个好的序列化协议作用如下： </p><ul><li> <strong>跨语言和跨平台</strong>： 分布式系统中，不同计算机可能使用不同编程语言和操作系统，因此需要一种通用的数据格式，以便跨语言和跨平台进行数据传输和交互。序列化协议<em>将数据转换为一种通用的格式</em>，使得不同计算机之间可以正确地对数据进行编码和解码。</li><li><strong>数据压缩</strong>： 在网络传输过程中，数据的大小会影响网络带宽和传输速度，因此需要对数据进行压缩。序列化协议可以*<em>将数据压缩为更小的二进制格式</em>，从而减少网络传输的数据量，提高网络传输效率。 </li><li><strong>数据安全</strong>： 在网络传输过程中，数据可能会被篡改或窃取，因此需要对数据进行加密和解密。序列化协议可以<em>将数据转换为二进制格式，并进行加密和解密操作</em>，从而保证数据的安全性和完整性。 </li><li><strong>数据可读性</strong>： 在调试和排错过程中，需要查看网络传输的数据内容，以便于定位问题。序列化协议可以<em>将数据转换为文本格式</em>，使得数据更易于读取和理解。</li></ul><h2 id="几个常见的-rpc-的地址"><a href="#几个常见的-rpc-的地址" class="headerlink" title="几个常见的 rpc 的地址"></a>几个常见的 rpc 的地址</h2><p>grpc中文文档：<a href="https://doc.oschina.net/grpc">https://doc.oschina.net/grpc</a> </p><p>grpc官方文档：<a href="https://grpc.io/docs/">https://grpc.io/docs/</a> </p><p>dubbo官方文档：<a href="https://cn.dubbo.apache.org/zh-cn/overview/home/">https://cn.dubbo.apache.org/zh-cn/overview/home/</a> </p><p>Apache Thrift官方文档：<a href="https://thrift.apache.org/">https://thrift.apache.org/</a> </p><p>WebRTC官方文档：<a href="https://webrtc.org/?hl=zh-cn">https://webrtc.org/?hl=zh-cn</a></p>]]></content>
    
    
    <summary type="html">RPC（Remote Procedure Call）是一种允许程序像调用本地方法一样调用远程服务的通信协议。</summary>
    
    
    
    <category term="Middleware" scheme="https://southernfish.github.io/categories/Middleware/"/>
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="RPC" scheme="https://southernfish.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Springboot项目+JDK17打包exe</title>
    <link href="https://southernfish.github.io/2025/07/08/blog/jar-jpackage-exe/"/>
    <id>https://southernfish.github.io/2025/07/08/blog/jar-jpackage-exe/</id>
    <published>2025-07-08T07:27:36.000Z</published>
    <updated>2025-07-10T12:47:35.020Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了在Java17环境下，使用java14引入的jpackage工具，生成包含所有依赖的Java应用程序映像，包括支持Windows和macOS平台，包括exe、dmg和msi格式。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ol><li><p>使用 mvn package 打包成 jar</p><p>在项目下生成target目录，且包含打包成的jar（例如：standard-0.0.1-SNAPSHOT.jar）,确认这个jar能使用”java -jar ***.jar”运行。用<code>idea2025</code>打开项目，进入界面右侧的<code>maven</code>目录，使用嗯项目的<code>lifecycle</code>目录下的<code>package</code>。</p></li><li><p>下载安装 JDK<br>JPackage指令是JAVA 14新增的，所以安装的JAVA版本必须14+，我是用的是 jdk-17.0.12_windows-x64_bin.zip。JDK17的环境变量配置：</p><pre><code>新增系统变量：JAVA_HOME，值为D:\IDEA\Java\jdk-17（安装路径）；新增系统变量：CLASSPATH，值为.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar，注意最前面的小黑点不能省.在系统变量Path下新增两条配置：%JAVA_HOME%\bin和%JAVA_HOME%\jre\bin</code></pre></li><li><p>下载安装 wix314.exe</p><p>下载路径为：<a href="https://github.com/wixtoolset/wix3/releases">Release WiX Toolset v3.14</a>找到<code>Assets</code>下载即可。安装前需要在电脑的 控制面板 →  程序和功能 →  启用或关闭Windows功能 →  勾选<code>.NET Framework 3.5 (包括 ,NET 2.0 和 3.0)</code> →  确定，等待执行完成。之后再双击下载的<code>wix314.exe</code>，正常安装。</p></li></ol><h2 id="JPackage-指令"><a href="#JPackage-指令" class="headerlink" title="JPackage 指令"></a>JPackage 指令</h2><ol><li><p>打包exe(亲测有效)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\jpackage --<span class="built_in">type</span> exe --name csresUtil --input E:\WorkSpace\ByMyself\standard-util\target --main-jar standard-0.0.1-SNAPSHOT.jar --java-options <span class="string">&quot;-Dserver.port=8888  -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005&quot;</span> --win-console --win-dir-chooser --win-shortcut --win-shortcut-prompt --dest E:\dist</span><br></pre></td></tr></table></figure></li><li><p>打包msi</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\jpackage --<span class="built_in">type</span> msi --win-dir-chooser --name csresUtil --app-image E:\dist --dest E:\distmsi</span><br></pre></td></tr></table></figure></li><li><p>打包app-image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\jpackage --<span class="built_in">type</span> app-image --name import --input E:\WorkSpace\ByMyself\standard-util\target --main-jar standard-0.0.1-SNAPSHOT.jar --java-options <span class="string">&quot;-Dserver.port=8888 -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005&quot;</span> --win-console --dest E:\dist</span><br></pre></td></tr></table></figure></li><li><p>查看帮助：jpackage -h （以下Windows平台Java17下部分参数说明。 )</p><table><thead><tr><th>参数</th><th>作用</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>–type</td><td>打包类型</td><td>app-image</td><td>可选：”app-image”, “exe”, “msi”，这里使用app-image，选择另外两个选项需要安装WiX</td></tr><tr><td>–name</td><td>应用名称</td><td>spring</td><td>打包后的名称，如”sping.exe”</td></tr><tr><td>–input</td><td>输入目录</td><td>target</td><td>该目录所有文件打包到应用目录中</td></tr><tr><td>–main-jar</td><td>应用主jar</td><td>spring-1.0.jar</td><td>–input目录里的jar程序</td></tr><tr><td>-icon</td><td>指定图标</td><td>-icon</td><td>指定图标(如：avatar.ico)</td></tr><tr><td>–win-console</td><td>运行时启动控制台</td><td>–win-console</td><td>打开应用程序时，打开控制台。如果不启用在后台运行，关闭只能从任务管理器中结束任务</td></tr><tr><td>–win-dir-chooser</td><td>在安装程序的时候可以选安装目录</td><td>–win-dir-chooser</td><td>在安装程序的时候可以选安装目录</td></tr><tr><td>–win-shortcut</td><td>创建桌面快捷方式</td><td>–win-shortcut</td><td>创建桌面快捷方式</td></tr><tr><td>–win-shortcut-prompt</td><td>在安装程序的时候可以选择是否创建桌面快捷方式</td><td>–win-shortcut-prompt</td><td>在安装程序的时候可以选择是否创建桌面快捷方式</td></tr><tr><td>–dest</td><td>输出目录</td><td>dist</td><td>输出到该目录，不要和–input同个目录，否则会无限循环复制目录</td></tr></tbody></table></li></ol>]]></content>
    
    
    <summary type="html">本文以 jpackage+ wix314.exe + jar包 打包一个可执行exe文件。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="jpackage" scheme="https://southernfish.github.io/tags/jpackage/"/>
    
  </entry>
  
  <entry>
    <title>ElasticStack Kafka 缓冲区</title>
    <link href="https://southernfish.github.io/2025/07/01/server/elatsticstack-kafka/"/>
    <id>https://southernfish.github.io/2025/07/01/server/elatsticstack-kafka/</id>
    <published>2025-07-01T12:30:36.000Z</published>
    <updated>2025-07-10T12:47:35.025Z</updated>
    
    <content type="html"><![CDATA[<p>‌Elastic Stack（原ELK Stack）是一套由Elastic公司开发的开源数据搜索、分析和可视化工具集合，核心组件包括Elasticsearch、Kibana、Beats和Logstash‌，广泛应用于日志分析、安全监控、业务智能等领域。‌‌‌‌ Logstash 能够动态地采集、转换和传输数据，不受格式或复杂度的影响。利用 Grok 从非结构化数据中派生出结构，从 IP 地址解码出地理坐标，匿名化或排除敏感字段，并简化整体处理过程。 参考文章：<a href="https://blog.csdn.net/Tracycoder/article/details/147423614">ElasticSearch深入解析（一）：Elastic Stack全景</a>、<a href="https://blog.csdn.net/shjwkzkzk/article/details/148403336">ElasticStack对接kafka集群</a></p><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kafka 是一种高性能的分布式消息队列系统，通过合理的配置和管理，可有效利用 Kafka 特性，满足企业对大规模<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E6%B5%81%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020">数据流处理</a>的需求。</p><ul><li><strong>高吞吐<code>(海量读写数据,缺点：不支持对象类型传输...)</code>、</strong><a href="https://cloud.tencent.com/product/ckafka?from_column=20065&from=20065"><strong>分布式消息系统</strong></a></li><li><strong>概念：<code>Producer：生产者(消息的来源)</code></strong> <strong><code>Consumer：消费者(消息输出)</code></strong> <strong><code>Topic：主题(消息传递的约定)</code></strong></li><li><strong>消息系统介绍</strong> 一个消息系统负责将数据从一个应用传递到另外一个应用， 应用只需关注于数据，无需关注数据在两个或多个应用间是如何传递的。 <strong>有两种主要的消息传递模式：<code>点对点传递模式、</code></strong> <strong><code>发布-订阅模式。(kafka采用)</code></strong></li></ul><h2 id="ELK-为什么要结合Kafka"><a href="#ELK-为什么要结合Kafka" class="headerlink" title="ELK 为什么要结合Kafka"></a>ELK 为什么要结合Kafka</h2><p>‌ELK（Elasticsearch、Logstash、Kibana）结合 Kafka的主要原因是为了解决日志采集和处理的性能和扩展性问题‌。 在Kafka中，每个topic都有一个或多个partition，而每个partition都有一个Leader副本。Leader副本负责处理该partition的所有读写请求。当Kafka集群中的节点发生故障时，Leader副本会进行选举，以确保集群的稳定性和数据的持久性。</p><p><strong>Kafka在ELK架构中的作用</strong></p><ul><li><strong>数据缓冲和扩展性‌：</strong>Kafka 作为一个高吞吐量的分布式消息系统，能够<strong>均衡网络传输，降低网络闭塞的风险</strong>，确保数据不丢失，并且为系统之间的解耦提供了更好的灵活性和扩展性‌。 </li><li><strong>异步处理‌：</strong>通过 Kafka 进行日志的异步传输，可以<strong>减少对本地磁盘I/O的影响</strong>，提高系统的整体性能和稳定性‌。 </li><li><strong>峰值处理能力‌：</strong>Kafka 能够使关键组件顶住突发的访问压力，避免因突发超负荷请求而崩溃‌。  </li></ul><p><strong>Kafka在日志处理流程中的具体作用</strong> </p><ul><li><strong>日志收集‌：</strong> Filebeat收集日志，并将其发送到Kafka‌。 </li><li><strong>日志传输‌：</strong>Kafka作为消息队列，缓存日志数据，确保数据的可靠传输和存储‌。 </li><li><strong>日志处理‌：</strong> Logstash订阅 Kafka 的主题，获取日志消息内容，并将其格式化和存储到 Elasticsearch 中‌。</li></ul><hr><h1 id="Kafka集群部署"><a href="#Kafka集群部署" class="headerlink" title="Kafka集群部署"></a>Kafka集群部署</h1><h2 id="单点部署-Kafka"><a href="#单点部署-Kafka" class="headerlink" title="单点部署 Kafka"></a>单点部署 Kafka</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.下载并解压</span></span><br><span class="line"><span class="comment"># 下载 Kafka</span></span><br><span class="line">wget https://dlcdn.apache.org/kafka/3.9.0/kafka_2.13-3.9.0.tgz</span><br><span class="line"><span class="comment"># 解压 Kafka</span></span><br><span class="line">tar xf kafka_2.13-3.9.0.tgz -C /usr/local/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.修改配置文件</span></span><br><span class="line"><span class="comment"># Kafka 的唯一标识</span></span><br><span class="line">broker.id=91 </span><br><span class="line"><span class="comment"># 修改数据目录</span></span><br><span class="line">log.dirs=/var/lib/kafka</span><br><span class="line"><span class="comment"># 指定 Kafka 的元数据存储在 Zookeeper 集群的路径(znodes)</span></span><br><span class="line">zookeeper.connect=10.0.0.91:2181,10.0.0.92:2181,10.0.0.93:2181/oldboyedu-kafka-3.9.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.配置环境变量</span></span><br><span class="line">[root@elk91 ~]<span class="comment"># cat /etc/profile.d/kafka.sh</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">export</span> KAFKA_HOME=/usr/local/kafka_2.13-3.9.0</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$KAFKA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.启动并验证是否成功</span></span><br><span class="line"><span class="comment"># 启动 kafka</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/kafka.sh</span><br><span class="line">kafka-server-start.sh -daemon <span class="variable">$KAFKA_HOME</span>/config/server.properties </span><br><span class="line"><span class="comment"># 验证 Kafka 是否启动成功</span></span><br><span class="line">ss -ntl | grep 9092</span><br><span class="line"><span class="comment"># 出现如下则成功</span></span><br><span class="line"><span class="comment"># LISTEN 0      50                      *:9092             *:*          </span></span><br></pre></td></tr></table></figure><h2 id="集群部署-Kafka"><a href="#集群部署-Kafka" class="headerlink" title="集群部署 Kafka"></a>集群部署 Kafka</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、拷贝 Kafka 数据到集群节点（92/93）</span></span><br><span class="line"><span class="comment"># [root@elk91 ~]# </span></span><br><span class="line">scp -r /usr/local/kafka_2.13-3.9.0/ 10.0.0.92:/usr/local/</span><br><span class="line">scp -r /usr/local/kafka_2.13-3.9.0/ 10.0.0.93:/usr/local/</span><br><span class="line">scp /etc/profile.d/kafka.sh 10.0.0.92:/etc/profile.d/</span><br><span class="line">scp /etc/profile.d/kafka.sh 10.0.0.93:/etc/profile.d/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、修改 92/93 节点的配置文件 </span></span><br><span class="line"><span class="comment"># [root@elk92 ~]# ：2、修改 92 节点的配置文件 </span></span><br><span class="line">sed -i <span class="string">&#x27;/^broker.id/s#91#92#&#x27;</span> /usr/local/kafka_2.13-3.9.0/config/server.properties </span><br><span class="line"><span class="comment"># [root@elk93 ~]# ：修改 93 节点的配置文件</span></span><br><span class="line">sed -i <span class="string">&#x27;/^broker.id/s#91#93#&#x27;</span> /usr/local/kafka_2.13-3.9.0/config/server.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、启动其他节点的 Kafka </span></span><br><span class="line"><span class="comment"># [root@elk92 ~]# ：启动92节点的 Kafka </span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/kafka.sh &amp;&amp; kafka-server-start.sh -daemon <span class="variable">$KAFKA_HOME</span>/config/server.properties </span><br><span class="line"><span class="comment"># [root@elk93 ~]# ：启动93节点的 Kafka </span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/kafka.sh &amp;&amp; kafka-server-start.sh -daemon <span class="variable">$KAFKA_HOME</span>/config/server.properties </span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、验证 Zookeeper 集群数据是否写入成功 </span></span><br><span class="line"><span class="comment"># [root@elk91 ~]# </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ls /oldboyedu-kafka-3.9.0&quot;</span> | nc 10.0.0.91 2181</span><br></pre></td></tr></table></figure><hr><h1 id="ELK-对接Kafka集群"><a href="#ELK-对接Kafka集群" class="headerlink" title="ELK 对接Kafka集群"></a>ELK 对接Kafka集群</h1><p>ELK（Elasticsearch、Logstash、Kibana）。</p><p>此处探讨如何通过这一架构优化，实现高效、可靠且可扩展的日志处理解决方案，以应对日益增长的数据量和复杂多变的业务需求，同时减轻Logstash压力并降低其与Filebeat的耦合性，提升整个系统的性能与稳定性，为企业的数据驱动决策提供坚实的技术支撑。</p><p><strong>Kafka集群特性适配 ：</strong>Kafka具备<strong>高吞吐量</strong>（如单机每秒可处理10w + /s）、<strong>高可用性</strong>（通过多副本机制保障数据不丢失）、<strong>强扩展性</strong>（可方便地进行集群扩展以应对数据增长）以及<strong>丰富的生态集成能力</strong>（与多种编程语言和工具兼容良好）等特点，使其成为对接ELK的理想选择。其强大的消息队列功能能够很好地<strong>满足日志数据海量、实时性要求高的处理需求</strong>，确保数据在产生端（如Filebeat采集的日志）和消费端（如Logstash后续处理）之间的高效流转和可靠存储。</p><h2 id="架构图解"><a href="#架构图解" class="headerlink" title="架构图解"></a>架构图解</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250630173309605.png" alt="image-20250630173309605"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">为了减轻Logstash压力以及Logstash和filebeat的耦合性，考虑在Logstash前面加一套MQ集群。</span><br><span class="line">所谓的MQ，指的是Message Queue，即消息队列。但是这种架构无疑是给系统增加了负担：</span><br><span class="line">    1.MQ不存在单点问题；</span><br><span class="line">    2.MQ具有很强的处理数据能力；</span><br><span class="line">    3.增加了集群的整体复杂性，运维和开发的同学都得增加学习成本；</span><br><span class="line"></span><br><span class="line">也就是说，这意味消息队列要提供以下特性：</span><br><span class="line">    1.MQ集群吞吐量大，能够承担数据的读写；5台32core，32GB读取处理消息数量23w/s，写速度可以达到220m/s，</span><br><span class="line">    2.MQ集群要提供非常强的高可用性，不能是单点的故障；</span><br><span class="line">    3.文档丰富，社区资源丰富；</span><br><span class="line"></span><br><span class="line">市面上有很多MQ产品，典型代表有：</span><br><span class="line">    RocketMQ【阿里巴巴，有社区版（功能较差，文档不够丰富，仅支持Java相关的API）和SAAS版本（功能强，需要花钱），性能很好，单机每秒能够处理10w+/s】</span><br><span class="line">    ActiveMQ【老牌系统，文档相对丰富，性能一般，单机每秒处理1w+/s】</span><br><span class="line">    Kafka【日志收集，大数据分析，性能非常好，单机每秒处理10w+/s，存在丢失数据的风险，但可以忽略不计，API文档非常丰富，基于Java和Scala语言研发，二次开发比较方便，社区完善了Golang，Python等API】</span><br><span class="line">    RabbitMQ【金融公司，文档丰富，性能较好，单机每秒处理1w+/s，可以做到数据不丢失，API开发相对来说不太友好，基于Erlang语言研发，国内并不流行，因此二次开发招人比较困难。】</span><br></pre></td></tr></table></figure><h2 id="架构实现"><a href="#架构实现" class="headerlink" title="架构实现"></a>架构实现</h2><p>首先需要有一套kafka集群，Elasticsearch、Logstash、Kibana都已安装。</p><ol><li><p><strong>filebeat生产kafka集群数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写filebeat并启动</span></span><br><span class="line">[root@elk93 /etc/filebeat/config]<span class="comment"># cat filebeat_tcp-to-kafka.yaml .</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: tcp</span><br><span class="line">  host: <span class="string">&quot;0.0.0.0:9000&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 数据输出到kafka</span></span><br><span class="line">output.kafka:</span><br><span class="line">  <span class="comment"># 指定kafka集群的地址</span></span><br><span class="line">  hosts: </span><br><span class="line">  - 10.0.0.91:9092</span><br><span class="line">  - 10.0.0.92:9092</span><br><span class="line">  - 10.0.0.93:9092</span><br><span class="line"> </span><br><span class="line">  <span class="comment"># 指定topic</span></span><br><span class="line">  topic: novacao-linux96-kafka</span><br><span class="line">  </span><br><span class="line">[root@elk93 /etc/filebeat/config]<span class="comment"># rm -rf /var/lib/filebeat/</span></span><br><span class="line">[root@elk93 /etc/filebeat/config]<span class="comment"># filebeat -e -c `pwd`/filebeat_tcp-to-kafka.yaml</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 发送测试数据</span></span><br><span class="line">[root@elk91 ~]<span class="comment"># echo helllllllllllllllo |nc 10.0.0.93 9000</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># kafka验证数据</span></span><br><span class="line">[root@elk92 ~]<span class="comment"># kafka-console-consumer.sh --bootstrap-server 10.0.0.93:9092 --topic novacao-linux96-kafka --from-beginning</span></span><br><span class="line">.....</span><br><span class="line">&#123;<span class="string">&quot;@timestamp&quot;</span>:<span class="string">&quot;2025-03-17T12:35:18.320Z&quot;</span>,<span class="string">&quot;@metadata&quot;</span>:&#123;<span class="string">&quot;beat&quot;</span>:<span class="string">&quot;filebeat&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;_doc&quot;</span>,<span class="string">&quot;version&quot;</span>:<span class="string">&quot;7.17.28&quot;</span>&#125;,<span class="string">&quot;log&quot;</span>:&#123;<span class="string">&quot;source&quot;</span>:&#123;<span class="string">&quot;address&quot;</span>:<span class="string">&quot;10.0.0.91:55810&quot;</span>&#125;&#125;,<span class="string">&quot;input&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;tcp&quot;</span>&#125;,<span class="string">&quot;agent&quot;</span>:&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;elk93&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;filebeat&quot;</span>,<span class="string">&quot;version&quot;</span>:<span class="string">&quot;7.17.28&quot;</span>,<span class="string">&quot;hostname&quot;</span>:<span class="string">&quot;elk93&quot;</span>,<span class="string">&quot;ephemeral_id&quot;</span>:<span class="string">&quot;73d1dee2-d555-4955-b689-75d602e1b5e0&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;ced21de3-ed8a-4601-acba-07f0d7db5a5a&quot;</span>&#125;,<span class="string">&quot;ecs&quot;</span>:&#123;<span class="string">&quot;version&quot;</span>:<span class="string">&quot;1.12.0&quot;</span>&#125;,<span class="string">&quot;host&quot;</span>:&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;elk93&quot;</span>&#125;,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;helllllllllllllllo&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Logstash消费kafka集群数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kibana基于开发工具创建账号</span></span><br><span class="line">POST /_security/api_key</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Linux96&quot;</span>, </span><br><span class="line">  <span class="string">&quot;role_descriptors&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;filebeat_monitoring&quot;</span>: &#123; </span><br><span class="line">      <span class="string">&quot;cluster&quot;</span>: [<span class="string">&quot;all&quot;</span>],</span><br><span class="line">      <span class="string">&quot;index&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;names&quot;</span>: [<span class="string">&quot;novacao-logstash-kafka*&quot;</span>],</span><br><span class="line">          <span class="string">&quot;privileges&quot;</span>: [<span class="string">&quot;all&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 生成实例</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;id&quot;</span> : <span class="string">&quot;QSYgpJUBD3ll3qToqN4V&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;Linux96&quot;</span>,</span><br><span class="line">  <span class="string">&quot;api_key&quot;</span> : <span class="string">&quot;EWyBlHEHTnSQlALuB41hpw&quot;</span>,</span><br><span class="line">  <span class="string">&quot;encoded&quot;</span> : <span class="string">&quot;UVNZZ3BKVUJEM2xsM3FUb3FONFY6RVd5QmxIRUhUblNRbEFMdUI0MWhwdw==&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 解码数据</span></span><br><span class="line">[root@elk91 ~]<span class="comment"># echo UVNZZ3BKVUJEM2xsM3FUb3FONFY6RVd5QmxIRUhUblNRbEFMdUI0MWhwdw== |base64 -d ;echo</span></span><br><span class="line">QSYgpJUBD3ll3qToqN4V:EWyBlHEHTnSQlALuB41hpw</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Logstash消费数据</span></span><br><span class="line">[root@elk93 /etc/logstash/conf.d]<span class="comment"># cat 09-logstash-to-ES_api-keys.conf</span></span><br><span class="line">input &#123; </span><br><span class="line">  kafka &#123;</span><br><span class="line">    <span class="comment"># 指定kafka集群的地址</span></span><br><span class="line">    bootstrap_servers =&gt; <span class="string">&quot;10.0.0.91:9092,10.0.0.92:9092,10.0.0.93:9092&quot;</span></span><br><span class="line">    <span class="comment"># 指定从kafka哪个topic拉取数据</span></span><br><span class="line">    topics =&gt; [<span class="string">&quot;novacao-linux96-kafka&quot;</span>]</span><br><span class="line">    <span class="comment"># 指定消费者组</span></span><br><span class="line">    group_id =&gt; <span class="string">&quot;linux96-001&quot;</span></span><br><span class="line">    <span class="comment"># 指定拉取数据offset的位置点，常用值：earliest(从头拉取数据)，latest(从最新的位置拉取数据)</span></span><br><span class="line">    auto_offset_reset =&gt; <span class="string">&quot;earliest&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  json &#123;</span><br><span class="line">    <span class="built_in">source</span> =&gt; <span class="string">&quot;message&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  mutate &#123;</span><br><span class="line">     remove_field =&gt; [ <span class="string">&quot;agent&quot;</span>,<span class="string">&quot;@version&quot;</span>,<span class="string">&quot;ecs&quot;</span>,<span class="string">&quot;input&quot;</span>,<span class="string">&quot;log&quot;</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">output &#123; </span><br><span class="line"> <span class="comment"># stdout &#123; </span></span><br><span class="line"> <span class="comment">#   codec =&gt; rubydebug </span></span><br><span class="line"> <span class="comment"># &#125; </span></span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [<span class="string">&quot;10.0.0.91:9200&quot;</span>,<span class="string">&quot;10.0.0.92:9200&quot;</span>,<span class="string">&quot;10.0.0.93:9200&quot;</span>]</span><br><span class="line">    index =&gt; <span class="string">&quot;novacao-logstash-kafka&quot;</span></span><br><span class="line">    api_key =&gt; <span class="string">&quot;QSYgpJUBD3ll3qToqN4V:EWyBlHEHTnSQlALuB41hpw&quot;</span></span><br><span class="line">    ssl =&gt; <span class="literal">true</span></span><br><span class="line">    ssl_certificate_verification =&gt; <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 启用logstash</span></span><br><span class="line">[root@elk93 /etc/logstash/conf.d]<span class="comment"># logstash -rf 09-logstash-to-ES_api-keys.conf </span></span><br></pre></td></tr></table></figure></li><li><p><strong>Kibana查看数据</strong>：<a href="http://localhost:5601/">http://localhost:5601/</a></p></li></ol>]]></content>
    
    
    <summary type="html">ElasticStack</summary>
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="ElasticStack" scheme="https://southernfish.github.io/tags/ElasticStack/"/>
    
  </entry>
  
  <entry>
    <title>ElasticStack kibana可视化处理</title>
    <link href="https://southernfish.github.io/2025/07/01/server/elatsticstack-kibana/"/>
    <id>https://southernfish.github.io/2025/07/01/server/elatsticstack-kibana/</id>
    <published>2025-07-01T11:00:36.000Z</published>
    <updated>2025-07-10T12:47:35.025Z</updated>
    
    <content type="html"><![CDATA[<p>Kibana 是为 <a href="https://cloud.tencent.com/product/es?from=20065&from_column=20065">Elasticsearch</a>设计的开源分析和可视化平台。你可以使用 Kibana 来搜索，查看存储在 Elasticsearch 索引中的数据并与之交互，容易实现高级的<a href="https://cloud.tencent.com/product/bi?from=20065&from_column=20065">数据分析</a>和可视化，以图标的形式展现出来。在生产环境中，Kibana的仪表盘功能能够帮助运维人员快速发现系统异常和性能瓶颈，为故障排查和性能优化提供有力支持。同时，Kibana的数据可视化功能还能够为业务人员提供直观的数据展示和分析工具，帮助他们更好地了解业务情况。参考文章：<a href="https://blog.csdn.net/wfcxhit/article/details/147591185">k8s部署ELK系列五：集成Kibana实现日志可视化</a>、<a href="https://cloud.tencent.com/developer/inventory/4446/article/1556663">ELK总结——第四篇Kibana的简介</a>、<a href="https://blog.csdn.net/Lemon__ing/article/details/148667480">ELK日志文件分析系统——K(Kibana)</a></p><h1 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kibana是一个基于Web的数据<a href="https://cloud.baidu.com/product/sugar.html">可视化工具</a>，它能够与Elasticsearch无缝集成，通过友好的用户界面为用户提供实时数据分析、监控和可视化等功能。Kibana不仅提供了丰富的图表类型，如柱状图、折线图、饼图等，还支持自定义仪表盘和视图，让用户能够根据自己的需求快速创建和展示数据。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h2><ul><li><p><strong>实时监控</strong>通过 histogram 面板，配合不同条件的多个 queries 可以对一个事件走很多个维度组合出不同的<strong>时间序列</strong>走势。时间序列数据是最常见的监控报警了。</p></li><li><p><strong>问题分析</strong>关于 elk 的用途，可参照其对应的商业产品 splunk 的场景：使用 Splunk 的意义在于使<strong>信息收集和处理智能化</strong>。</p><p>其操作智能化表现在：</p><ul><li><p><strong>搜索</strong>通过下钻数据排查问题，通过分析根本原因来解决问题；</p></li><li><p><strong>实时可见性</strong>可以将对系统的检测和警报结合在一起，便于跟踪 SLA 和性能问题；</p></li><li><p><strong>历史分析</strong>可以从中找出趋势和历史模式，行为基线和阈值，生成一致性报告。</p></li></ul></li></ul><h2 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a><strong>关键特性</strong></h2><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>‌<strong>多维度分析</strong>‌</td><td>支持时间序列、地理空间、文本等多类型数据交叉分析</td></tr><tr><td>‌<strong>实时仪表盘</strong>‌</td><td>可组合多个可视化组件，自动刷新数据（默认15秒间隔）</td></tr><tr><td>‌<strong>Dev Tools</strong>‌</td><td>内置Elasticsearch查询调试界面，支持DSL语法验证</td></tr><tr><td>‌<strong>机器学习集成</strong>‌</td><td>与Elastic ML模块联动，实现异常检测（如流量突增预警）</td></tr></tbody></table><h2 id="应用意义‌"><a href="#应用意义‌" class="headerlink" title="应用意义‌"></a>应用意义‌</h2><ul><li>‌<strong>降低数据分析门槛‌：</strong>通过拖拽界面替代SQL/DSL编写，使非技术人员快速生成报表</li><li>‌<strong>统一监控平台‌：</strong>整合日志（Nginx）、指标（Prometheus）等多源数据，实现全栈可观测性</li><li><strong>‌合规审计支持‌：</strong>记录用户操作日志（如查询历史），满足GDPR等法规要求</li></ul><h1 id="Linux环境下安装Kibana"><a href="#Linux环境下安装Kibana" class="headerlink" title="Linux环境下安装Kibana"></a>Linux环境下安装Kibana</h1><p>安装Kibana非常简单，只需按照官方<a href="https://cloud.baidu.com/product/doc.html">文档</a>的指引进行安装和配置即可。在配置Kibana时，需要指定Elasticsearch的地址和端口，以便Kibana能够与Elasticsearch进行通信。此处 Kibana 与 Elasticsearch 安装在同一主机，安装基本步骤如下：</p><h2 id="环境准备‌"><a href="#环境准备‌" class="headerlink" title="环境准备‌"></a><strong>环境准备</strong>‌</h2><ol><li><p>‌<strong>安装Java依赖（JRE 11+）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install openjdk-11-jre -y     <span class="comment"># 更新包列表并安装OpenJDK JRE</span></span><br><span class="line">java -version                                             <span class="comment"># 验证Java版本，输出需包含&quot;11.x.x&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建专用用户（可选但推荐）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd kibana_user     <span class="comment"># 新建用户避免root权限风险</span></span><br><span class="line">sudo passwd kibana_user     <span class="comment"># 设置用户密码</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="下载与安装‌"><a href="#下载与安装‌" class="headerlink" title="下载与安装‌"></a><strong>下载与安装</strong>‌</h2><ol><li><p>‌<strong>手动下载（通用方式）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-8.13.4-linux-x86_64.tar.gz     <span class="comment"># 下载二进制包</span></span><br><span class="line">tar -zxvf kibana-8.13.4-linux-x86_64.tar.gz -C /opt/                                     <span class="comment"># 解压到/opt目录</span></span><br><span class="line">sudo <span class="built_in">chown</span> -R kibana_user:kibana_user /opt/kibana-8.13.4                                 <span class="comment"># 赋权给专用用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令解析</span></span><br><span class="line">wget                <span class="comment"># 从Elastic官网下载指定版本Kibana。</span></span><br><span class="line">tar -zxvf            <span class="comment"># 解压压缩包（-z解压gzip，-x解包，-v显示过程，-f指定文件）。</span></span><br><span class="line"><span class="built_in">chown</span> -R            <span class="comment"># 递归修改目录所有权，确保Kibana进程权限合规。</span></span><br></pre></td></tr></table></figure></li><li><p>‌<strong>APT安装（Debian/Ubuntu推荐）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -  <span class="comment"># 添加Elastic GPG密钥</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://artifacts.elastic.co/packages/8.x/apt stable main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/elastic.list                                             <span class="comment"># 配置APT仓库</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt install kibana                                         <span class="comment"># 安装Kibana并自动注册服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令解析</span></span><br><span class="line">apt-key add                                                                <span class="comment"># 导入密钥以验证软件包真实性</span></span><br><span class="line"><span class="built_in">tee</span> /etc/apt/sources.list.d/elastic.list                                <span class="comment"># 写入仓库配置到独立文件</span></span><br><span class="line">apt install kibana                                                        <span class="comment"># 自动安装并配置systemd服务</span></span><br></pre></td></tr></table></figure></li><li><p>‌<strong>配置文件解析</strong>‌</p><p>编辑 <code>/etc/kibana/kibana.yml</code>（APT安装）或 <code>/opt/kibana-8.13.4/config/kibana.yml</code>（手动安装）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port:</span> <span class="number">5601</span>                                         <span class="comment"># 监听端口，默认5601</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;0.0.0.0&quot;</span>                                     <span class="comment"># 允许所有IP访问（生产环境可指定内网IP）</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> [<span class="string">&quot;http://192.168.98.201:9200&quot;</span>]     <span class="comment"># Elasticsearch集群地址</span></span><br><span class="line"><span class="attr">i18n.locale:</span> <span class="string">&quot;zh-CN&quot;</span>                                     <span class="comment"># 设置为中文界面</span></span><br><span class="line"><span class="attr">logging.dest:</span> <span class="string">/var/log/kibana.log</span>                         <span class="comment"># 自定义日志路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键参数</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;0.0.0.0&quot;</span>                <span class="comment"># 开放网络访问（默认localhost仅本地访问）。</span></span><br><span class="line"><span class="string">elasticsearch.hosts:[&quot;ip:port&quot;]</span>        <span class="comment"># 必须指向已部署的Elasticsearch节点URL。</span></span><br><span class="line"><span class="attr">i18n.locale:</span> <span class="string">&quot;zh-CN&quot;</span>                <span class="comment"># 本地化支持，提升中文用户体验。</span></span><br></pre></td></tr></table></figure></li><li><p>‌<strong>服务管理与启动</strong></p><ul><li><p><strong>启动服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start kibana             <span class="comment"># 启动Kibana服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> kibana             <span class="comment"># 设置开机自启</span></span><br></pre></td></tr></table></figure></li><li><p><strong>监控状态与日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status kibana             <span class="comment"># 检查运行状态（输出&quot;Active: active&quot;表示成功）</span></span><br><span class="line">journalctl -u kibana -f                 <span class="comment"># 实时查看日志（过滤&quot;Server running&quot;确认启动）</span></span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="部署验证"><a href="#部署验证" class="headerlink" title="部署验证"></a><strong>部署验证</strong></h5><ol><li><p>‌<strong>访问Kibana Web界面</strong>‌：</p><p>浏览器打开 <code>http://&lt;服务器IP&gt;:5601</code>，显示欢迎页即部署成功</p><p>浏览器打开 <code>http://&lt;服务器IP&gt;:5601/api/status</code>返回<a href="https://cloud.tencent.com/developer/techpedia/1569?from=20065&from_column=20065">JSON</a>格式状态信息</p></li><li><p>‌<strong>检查Elasticsearch连接</strong>‌：在Kibana的 ‌<strong>Dev Tools</strong>‌ 中输入 <code>GET /</code>，返回ES集群信息表示通信正常。</p></li></ol></li><li><h5 id="生产调优建议"><a href="#生产调优建议" class="headerlink" title="生产调优建议"></a><strong>生产调优建议</strong></h5><ul><li>‌<strong>资源隔离</strong>‌: 使用专用用户运行Kibana，避免权限冲突。</li><li>‌<strong>配置热重载</strong>‌: 添加 <code>--config.reload.automatic</code> 启动参数，支持动态加载配置变更。</li><li>‌<strong>安全加固</strong>‌: 启用SSL加密（参考 <code>server.ssl</code> 配置）及防火墙规则限制访问IP。</li></ul></li></ol><hr><h1 id="Kibana的基本使用"><a href="#Kibana的基本使用" class="headerlink" title="Kibana的基本使用"></a>Kibana的基本使用</h1><h2 id="1-创建索引模式"><a href="#1-创建索引模式" class="headerlink" title="1.创建索引模式"></a><strong>1.创建索引模式</strong></h2><p>左侧菜单栏找到并进入<strong>Management</strong>，点击“<strong>Create index pattern</strong>”按钮来添加索引模式。第一个索引模式自动配置为默认的索引默认，以后当你有多个索引模式的时候，你就可以选择将哪一个设为默认。（提示：Management &gt; Index Patterns）</p><h2 id="2-用Discover交互式探索数据"><a href="#2-用Discover交互式探索数据" class="headerlink" title="2.用Discover交互式探索数据"></a><strong>2.用Discover交互式探索数据</strong></h2><ul><li><p>可以访问与所选择的索引默认匹配的每个索引中的每个文档，如果你选择的索引模式配置了time字段，则文档随时间的分布将显示在页面顶部的直方图中</p></li><li><p>可以提交<strong>查询请求</strong>，过滤搜索结构，并查看文档数据，可以看到匹配查询请求的文档数量，以及字段值统计信息</p><ul><li>提交一个查询请求时，直方图、文档表和字段列表都会更新，以反映搜索结果。命中（匹配到的文档）总数会显示在工具栏中。文档表格中显示了前500个命中。默认按时间倒序排列，首先显示最新的文档。可以通过点击<code>Time</code>列来逆转排序顺序。</li></ul></li><li><p><strong>设置时间过滤</strong>：Discover &gt; 顶端导航栏右侧 Last 15 minutes &gt; Time Range &gt; Absolute &gt;选择时间</p></li><li><p><strong>搜索数据</strong>：可以在搜索框中输入查询条件来查询当前索引模式匹配的索引。查询时，<strong>使用Kibana标准的查询语言（基于Lucene的查询语法）或者完全基于JSON的Elasticsearch查询语言DSL</strong>。Kibana查询语言<strong>可以使用自动完成和简化的查询语法作为实验特性</strong>，可以在查询栏的**<code>选项</code>**菜单下进行选择。</p></li><li><p><strong>查看文档数据：</strong>Table 列是控制列表显示的字段，在查看文档数据的时候点那个<strong>像书一样的小图标</strong>。</p></li><li><p><strong>查看字段数据统计：</strong>看左侧列表</p></li><li><p><strong>查看文档上下文：</strong>View surrounding documents</p></li></ul><h2 id="3-Lucene查询语法"><a href="#3-Lucene查询语法" class="headerlink" title="3.Lucene查询语法"></a><strong>3.Lucene查询语法</strong></h2><p>Kibana查询语言基于Lucene查询语法。下面是一些提示：</p><ol><li><strong>执行一个文本搜索</strong>，可以简单的输入一个文本字符串。例如，如果想搜索web服务器的日志，可以输入关键字”<strong>safari</strong>“，这样就可以搜索到所有有关”safari”的字段</li><li><strong>搜索一个特定字段的特定值</strong>，可以用字段的名称作为前缀。例如，输入”<strong>status:200</strong>“，将会找到所有status字段的值是200的文档</li><li><strong>搜索一个范围值</strong>，可以用括号范围语法，**[START_VALUE TO END_VALUE]<strong>。例如，为了找到状态码是4xx的文档，可以输入</strong>status:[400 TO 499]**</li><li><strong>指定更改复杂的查询条件</strong>，可以用布尔操作符 <strong>AND</strong> , <strong>OR</strong> , 和 <strong>NOT</strong>。例如，为了找到状态码是4xx并且extension字段是php或者html的文档，可以输入<strong>status:[400 TO 499] AND (extension:php OR extension:html)</strong></li></ol><hr><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="服务管理命令"><a href="#服务管理命令" class="headerlink" title="服务管理命令"></a><strong>服务管理命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana --<span class="built_in">help</span>             <span class="comment"># 查看所有支持参数</span></span><br><span class="line"><span class="comment"># 作用：显示Kibana支持的全部命令行参数及简要说明</span></span><br><span class="line"><span class="comment"># 关键输出：包括-e（环境变量）、-c（配置文件路径）等参数说明</span></span><br></pre></td></tr></table></figure><h2 id="启动参数解析"><a href="#启动参数解析" class="headerlink" title="启动参数解析"></a><strong>启动参数解析</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana \</span><br><span class="line"> --host=0.0.0.0 \                                     <span class="comment"># 监听所有网络接口</span></span><br><span class="line"> --port=5601 \                                         <span class="comment"># 指定服务端口（默认5601）</span></span><br><span class="line"> --elasticsearch.hosts=http://es-node:9200 \         <span class="comment"># 强制指定ES集群地址</span></span><br><span class="line"> --logging.json=<span class="literal">true</span>                                 <span class="comment"># 日志输出为JSON格式（便于ELK采集）</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 逐行解释</span></span><br><span class="line">--host=0.0.0.0                                        <span class="comment"># 允许远程访问（默认localhost仅本地访问）</span></span><br><span class="line">--port                                                <span class="comment"># 覆盖kibana.yml中的端口配置</span></span><br><span class="line">--elasticsearch.hosts                                <span class="comment"># 运行时动态指定ES连接地址</span></span><br><span class="line">--logging.json                                        <span class="comment"># 结构化日志输出，适合日志分析系统处理</span></span><br></pre></td></tr></table></figure><h2 id="插件管理命令"><a href="#插件管理命令" class="headerlink" title="插件管理命令"></a><strong>插件管理命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana-plugin list                                 <span class="comment"># 查看已安装插件</span></span><br><span class="line">bin/kibana-plugin install x-pack                     <span class="comment"># 安装X-Pack安全插件</span></span><br><span class="line">bin/kibana-plugin remove timeline                     <span class="comment"># 删除指定插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键参数</span></span><br><span class="line">install                                                <span class="comment"># 支持本地ZIP包或官方插件名称</span></span><br><span class="line">remove                                                <span class="comment"># 卸载后需重启Kibana生效</span></span><br></pre></td></tr></table></figure><h2 id="调试与维护命令"><a href="#调试与维护命令" class="headerlink" title="调试与维护命令"></a><strong>调试与维护命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana --optimize                                 <span class="comment"># 前端资源预编译（生产环境必执行）</span></span><br><span class="line">bin/kibana --no-watch                                 <span class="comment"># 禁用配置文件热重载（调试用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊场景</span></span><br><span class="line">--optimize                                            <span class="comment"># 提升页面加载速度，部署后首次运行需执行</span></span><br><span class="line">--no-watch                                            <span class="comment"># 排查配置问题时关闭自动重载</span></span><br></pre></td></tr></table></figure><h2 id="系统集成命令"><a href="#系统集成命令" class="headerlink" title="系统集成命令"></a><strong>系统集成命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">&#x27;localhost:5601/api/status&#x27;</span>                 <span class="comment"># 检查服务健康状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回字段</span></span><br><span class="line">status.overall.state                                <span class="comment"># green表示服务正常</span></span><br><span class="line">metrics.elasticsearch.client.total_active_sockets    <span class="comment"># ES连接数</span></span><br></pre></td></tr></table></figure><h2 id="生产环境完整示例"><a href="#生产环境完整示例" class="headerlink" title="生产环境完整示例"></a><strong>生产环境完整示例</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana \</span><br><span class="line"> --config=/etc/kibana/prod.yml \                     <span class="comment"># 指定配置文件</span></span><br><span class="line"> --pid.file=/var/run/kibana.pid \                     <span class="comment"># 记录进程ID</span></span><br><span class="line"> --logging.dest=/var/log/kibana-prod.log \             <span class="comment"># 日志重定向</span></span><br><span class="line"> --plugin-path=plugins/alerting                     <span class="comment"># 加载自定义插件目录</span></span><br></pre></td></tr></table></figure><p><strong>参数组合意义</strong>‌：</p><ol><li>使用独立配置文件避免冲突</li><li>通过PID文件便于服务管理</li><li>集中日志输出到指定文件</li><li>扩展自定义告警插件功能</li></ol><h2 id="与Elasticsearch联调命令"><a href="#与Elasticsearch联调命令" class="headerlink" title="与Elasticsearch联调命令"></a><strong>与Elasticsearch联调命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Kibana Dev Tools中执行 </span></span><br><span class="line">GET _cat/indices?v                                                     <span class="comment"># 验证ES索引可访问性</span></span><br><span class="line">POST _sql?format=json &#123;<span class="string">&quot;query&quot;</span>:<span class="string">&quot;SELECT * FROM logs LIMIT 10&quot;</span>&#125;         <span class="comment"># 测试SQL查询翻译</span></span><br></pre></td></tr></table></figure><p>通过合理组合这些命令，可实现从开发调试到生产部署的全生命周期管理。建议配合<code>nohup</code>或systemd实现后台运行。</p><hr><h1 id="Metricbeat"><a href="#Metricbeat" class="headerlink" title="Metricbeat"></a>Metricbeat</h1><h2 id="Windows下安装启动Kibana"><a href="#Windows下安装启动Kibana" class="headerlink" title="Windows下安装启动Kibana"></a>Windows下安装启动Kibana</h2><p>安装Kibana非常简单，只需按照官方<a href="https://cloud.baidu.com/product/doc.html">文档</a>的指引进行安装和配置即可。在配置Kibana时，需要指定Elasticsearch的地址和端口，以便Kibana能够与Elasticsearch进行通信。安装基本步骤如下：</p><ol><li>下载Kibana，下载链接 ：<a href="https://www.elastic.co/cn/downloads/kibana">Download Kibana Free | Get Started Now | Elastic</a>。注意需要保证其版本号与Elasticsearch和Kibana两者的版本号一样，小到小版本号。</li><li>下载后解压。找到<code>kibana/bin</code>目录下面的<code>kibana.bat</code>文件，双击执行它，启动成功后，可在浏览器访问 <a href="http://localhost:5601/%E3%80%82http://localhost:5601/status">http://localhost:5601/。http://localhost:5601/status</a> 可以访问Kibana服务器状态页面。</li><li><strong>注意：kibana数据从Elasticsearch而来，在启动kibana需要先启动Elasticsearch</strong>。</li></ol><h2 id="Metricbeat进行Logstash运行状态的监控"><a href="#Metricbeat进行Logstash运行状态的监控" class="headerlink" title="Metricbeat进行Logstash运行状态的监控"></a>Metricbeat进行Logstash运行状态的监控</h2><p>参考原文链接：<a href="https://zhangphil.blog.csdn.net/article/details/126183984">https://zhangphil.blog.csdn.net/article/details/126183984</a></p><p>metricbeat监控<a href="https://so.csdn.net/so/search?q=logstash&spm=1001.2101.3001.7020">logstash</a>运行状态上报Elasticsearch后<a href="https://so.csdn.net/so/search?q=Kibana&spm=1001.2101.3001.7020">Kibana</a>可视化查看：</p><ol><li><p>首先假定已经启动logstash，Elasticsearch，Kibana。并且已经安装部署metricbeat，本文均基于8.3.3版本。</p><ol><li>logstash配置output输出到Elasticsearch，启动；</li><li>Elasticsearch启动；</li><li>Kibana启动</li></ol></li><li><p>启用<code>logstash-xpack</code> 模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metricbeat modules <span class="built_in">enable</span> logstash-xpack</span><br></pre></td></tr></table></figure><p>此时会在<code>modules.d</code>文件目录（metricbeat/metricbeat-8.3.3/modules.d）下多出一个<code>logstash-xpack.yml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">module:</span> <span class="string">logstash</span></span><br><span class="line">  <span class="attr">xpack.enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">period:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;localhost:9600&quot;</span>]</span><br><span class="line">  <span class="comment">#username: &quot;user&quot;</span></span><br><span class="line">  <span class="comment">#password: &quot;secret&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>命令行启动 Metricbeat：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metricbeat -e</span><br></pre></td></tr></table></figure></li><li><p>在浏览器打开<a href="http://localhost:5601/">http://localhost:5601/</a></p><p>找到<code>stack monitoring</code>点进去，页面会有提示：xpack.monitoring.collection.enabled is set to false ，不管它，直接点进蓝色按钮 <strong>Turn on monitoring</strong> 即可。</p></li><li><p>看到了监控界面，选择<code>logstash</code>版面，这里包括所有正在监控的<code>logstash</code>节点：<strong>总览，节点详情统计图表，数据上报流水线</strong>，均可点进去查看。</p></li></ol><h2 id="Metricbeat发送监控数据到远程Elasticsearch"><a href="#Metricbeat发送监控数据到远程Elasticsearch" class="headerlink" title="Metricbeat发送监控数据到远程Elasticsearch"></a>Metricbeat发送监控数据到远程Elasticsearch</h2><p>参考原文链接：<a href="https://zhangphil.blog.csdn.net/article/details/126231371">https://zhangphil.blog.csdn.net/article/details/126231371</a></p><p>默认metricbeat发送数据到同一台机器的9200端口。</p><p>如果metricbeat与Elasticsearch不在同一台机器（不同IP地址），需要在<code>metricbeat.yml</code>文件里面配置Elasticsearch的主机地址端口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">    <span class="comment"># Array of hosts to connect to.</span></span><br><span class="line">    <span class="string">hosts:[&quot;localhost:9200&quot;]</span></span><br></pre></td></tr></table></figure><p>如果kibana和Elasticsearch在同一台机器上，不必再配置metricbeat到kibana的地址。</p><p>如果Elasticsearch和kibana不在同一台机器上，那么需要在<code>metricbeat.yml</code>里面配置到kibana的主机端口地址:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">setup.kibana:</span></span><br><span class="line"><span class="comment"># Kibana Host</span></span><br></pre></td></tr></table></figure><h2 id="Elasticsearch端口配置"><a href="#Elasticsearch端口配置" class="headerlink" title="Elasticsearch端口配置"></a>Elasticsearch端口配置</h2><p>Elasticsearch默认的http访问端口是9200，若启动时9200端口已被占用，Elasticsearch会自动占用9201端口。如果需要指定一个特别端口，只需要把<code>config/elasticsearch.yml</code>中的<code>http.port</code>注释去掉，重新定义一个端口数值即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http.port:9200</span></span><br></pre></td></tr></table></figure><h2 id="kibana连接Elasticsearch主机端口配置"><a href="#kibana连接Elasticsearch主机端口配置" class="headerlink" title="kibana连接Elasticsearch主机端口配置"></a>kibana连接Elasticsearch主机端口配置</h2><p>Elasticsearch与Kibana在同一台主机，且Elasticsearch的默认启动端口配置不变(9200）时，Kibana启动后会自动识别和寻址9200端口上的Elasticsearch。</p><p>但若Elasticsearch端口修改了，需要在Kibana写明最新的Elasticsearch端口，修改Kibana的配置文件<code>config/kibana.yml</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># elasticsearch.hosts:[&quot;http://localhost:9200&quot;]</span></span><br></pre></td></tr></table></figure><h1 id="Kibana实战部署"><a href="#Kibana实战部署" class="headerlink" title="Kibana实战部署"></a>Kibana实战部署</h1><p>在 Kubernetes 集群中，应用服务的日志对故障排查和性能分析至关重要。为解决不便于集中管理和持久化存储的问题，可采用目前主流日志分析解决方案【ELK（Elasticsearch + Logstash + Kibana）】，其中 Kibana 实现日志可视化展示，是日志分析中不可或缺的工具。</p><h2 id="创建Namespace（elk-namespace-yaml）"><a href="#创建Namespace（elk-namespace-yaml）" class="headerlink" title="创建Namespace（elk-namespace.yaml）"></a>创建Namespace（elk-namespace.yaml）</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的命名空间，用于部署 ELK 相关的资源</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elk</span></span><br></pre></td></tr></table></figure><h2 id="创建Service（kibana-service-yaml）"><a href="#创建Service（kibana-service-yaml）" class="headerlink" title="创建Service（kibana-service.yaml）"></a>创建Service（kibana-service.yaml）</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Kubernetes 服务（Service），以便暴露 Kibana Web 界面</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">elk</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5601</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">5601</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30601</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建ConfigMap（kibana-configmap-yaml）"><a href="#创建ConfigMap（kibana-configmap-yaml）" class="headerlink" title="创建ConfigMap（kibana-configmap.yaml）"></a>创建ConfigMap（kibana-configmap.yaml）</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 ConfigMap 来存储 Kibana 配置文件。配置项包括 Elasticsearch 的地址、Kibana 的日志设置以及访问设置</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">elk</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">kibana.yml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    server.port: 5601</span></span><br><span class="line"><span class="string">    server.host: &quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="string">    elasticsearch.hosts: [&quot;http://elasticsearch-0.elasticsearch-cluster.elk.svc.cluster.local:9200&quot;]</span></span><br><span class="line"><span class="string">    kibana.index: &quot;.kibana&quot;</span></span><br><span class="line"><span class="string">    logging.dest: /usr/share/kibana/logs/kibana.log</span></span><br><span class="line"><span class="string">    i18n.locale: &quot;zh-CN&quot;</span></span><br><span class="line"><span class="string">    server.publicBaseUrl: &quot;http://kibana.elk.svc.cluster.local:5601&quot;</span></span><br></pre></td></tr></table></figure><h2 id="创建Depoyment（kibana-deployment-yaml）"><a href="#创建Depoyment（kibana-deployment-yaml）" class="headerlink" title="创建Depoyment（kibana-deployment.yaml）"></a>创建Depoyment（kibana-deployment.yaml）</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Deployment 方式部署 Kibana，此处我们将 Kibana 配置为与 Elasticsearch 集群通信，并挂载之前创建的 ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">elk</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span>  <span class="comment"># 资源有限，这里配置节点亲和性，尽量调度到node1节点</span></span><br><span class="line">          <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">100</span></span><br><span class="line">            <span class="attr">preference:</span></span><br><span class="line">              <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">node1</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">harbor.local/k8s/kibana:7.17.0</span>  <span class="comment"># 内网仓库镜像</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5601</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ELASTICSEARCH_HOSTS</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;http://elasticsearch-0.elasticsearch-cluster.elk.svc.cluster.local:9200&quot;</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/kibana/config/kibana.yml</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">kibana.yml</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/kibana/logs</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;200m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;500Mi&quot;</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">        <span class="comment"># 如果不开启kibana认证就可以这样配</span></span><br><span class="line">        <span class="comment">#livenessProbe:</span></span><br><span class="line">          <span class="comment">#httpGet:</span></span><br><span class="line">            <span class="comment">#path: /api/status</span></span><br><span class="line">            <span class="comment">#port: 5601</span></span><br><span class="line">          <span class="comment">#initialDelaySeconds: 90</span></span><br><span class="line">          <span class="comment">#periodSeconds: 10</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">bash</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">                curl -u elastic:elastic -fs http://kibana.elk.svc.cluster.local:5601/api/status &gt; /dev/null</span></span><br><span class="line"><span class="string"></span>          <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">kibana-config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs</span></span><br><span class="line">        <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="部署所有资源"><a href="#部署所有资源" class="headerlink" title="部署所有资源"></a>部署所有资源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将上述 YAML 文件保存后，使用以下命令统一部署</span></span><br><span class="line">kubectl apply -f elk-namespace.yaml</span><br><span class="line">kubectl apply -f kibana-service.yaml</span><br><span class="line">kubectl apply -f kibana-configmap.yaml</span><br><span class="line">kubectl apply -f kibana-deployment.yaml</span><br></pre></td></tr></table></figure><h2 id="验证Kibana-Pod状态"><a href="#验证Kibana-Pod状态" class="headerlink" title="验证Kibana Pod状态"></a>验证Kibana Pod状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n elk</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ElasticStack</summary>
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="ElasticStack" scheme="https://southernfish.github.io/tags/ElasticStack/"/>
    
  </entry>
  
  <entry>
    <title>ElasticStack Elasticsearch数据存储</title>
    <link href="https://southernfish.github.io/2025/07/01/server/elatsticstack-elasticsearch/"/>
    <id>https://southernfish.github.io/2025/07/01/server/elatsticstack-elasticsearch/</id>
    <published>2025-07-01T07:00:36.000Z</published>
    <updated>2025-07-10T12:47:35.025Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch<strong>是一个基于</strong><a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=123773"><strong>Lucene</strong></a><strong>的搜索服务器</strong>，包含Windows、<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=2010614">macOS</a>、<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=807585">Linux</a>版等。它提供了一个<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7819465">分布式</a>多用户能力的<strong>全文</strong><a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=15733"><strong>搜索引擎</strong></a>，能很方便地使大量数据具有搜索、分析和探索的能力。本文介绍了如何在windows环境安装Elasticsearch、Kibana和Logstash，然后通过Metricbeat进行Logstash运行状态的监控，kiban的可视化查看，以及一些配置。</p><h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Elasticsearch 是一个分布式、高扩展、高实时的搜索与数据分析引擎。它能很方便的使大量数据具有搜索、分析和探索的能力。充分利用Elasticsearch的水平伸缩性，能使数据在生产环境变得更有价值。</p><p>Elasticsearch是与名为<code>Logstash</code>的<strong>数据收集和日志解析引擎</strong>以及名为<code>Kibana</code>的分析和可视化平台一起开发的。这三个产品被设计成一个集成解决方案，称为<code>Elastic Stack</code>（以前称<code>ELK stack</code>）。</p><p>Elasticsearch可以用于搜索各种文档。它提供可扩展的搜索，具有接近实时的搜索，并支持多租户。Elasticsearch是分布式的，这意味着索引可以被分成分片，每个分片可以有0个或多个副本。每个节点托管一个或多个分片，并充当协调器将操作委托给正确的分片。再平衡和路由是自动完成的。相关数据通常存储在同一个索引中，该索引由一个或多个主分片和零个或多个复制分片组成。一旦创建了索引，就不能更改主分片的数量。</p><p>Elasticsearch使用<code>Lucene</code>，并试图通过<code>JSON</code>和<code>Java API</code>提供其所有特性。它支持<code>facetting</code>和<code>percolating</code>，如果新文档与注册查询匹配，这对于通知非常有用。另一个特性称为<code>“网关”</code>，<strong>处理索引的长期持久性</strong>；例如，在服务器崩溃的情况下，可以从网关恢复索引。Elasticsearch支持实时GET请求，适合作为NoSQL数据存储，但<strong>缺少分布式事务</strong>。</p><p><code>‌Lucene</code>是Apache软件基金会维护的<strong>开源全文检索引擎工具包</strong>，用Java编写，提供高性能的索引和搜索功能，广泛应用于信息检索领域。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>首先用户将<strong>数据提交到Elasticsearch 数据库</strong>中，再通过<strong>分词控制器去将对应的语句分词</strong>，将其<strong>权重和分词结果一并存入数据</strong>，当用户搜索数据时候，再<strong>根据权重将结果排名，打分，再将返回结果呈现给用户</strong>。</p><h2 id="Elasticsearch的主要特点"><a href="#Elasticsearch的主要特点" class="headerlink" title="Elasticsearch的主要特点"></a>Elasticsearch的主要特点</h2><p>Elasticsearch是一个功能强大、易于使用和高性能的搜索和分析引擎，适用于各种大规模数据的搜索、聚合和分析需求。</p><ol><li><strong>分布式架构</strong>：数据可以分布在多个节点上。这样可以实现<strong>高可用性和负载均衡</strong>，同时也<strong>能通过水平扩展来处理大规模数据</strong>。</li><li> <strong>实时搜索和分析：</strong>Elasticsearch能够实时对大规模数据进行搜索和分析，搜索结果的响应时间通常在毫秒级别。它支持<strong>全文搜索、词条搜索、模糊搜索</strong>等多种搜索方式，并提供强大的查询语言。</li><li><strong>多种数据类型支持：</strong>包括<strong>结构化数据、半结构化数据和非结构化数据</strong>。可以处理<strong>文本、数字、日期、地理位置</strong>等多种数据类型。</li><li><strong>强大的全文搜索能力：</strong>Elasticsearch使用倒排索引来加速全文搜索，可以快速地找到包含关键词的文档。它支持<strong>分词、同义词、模糊匹配</strong>等功能，可以灵活地处理各种复杂的查询需求。</li><li><strong>多种数据分析功能：</strong>包括<strong>聚合、过滤、排序、统计</strong>等。它可以对大规模数据进行复杂的统计和分析，帮助用户深入了解数据。</li><li><strong>易于使用和集成：</strong>提供了友好的<code>RESTful API</code>，可以方便地与其他应用程序集成。它还有丰富的客户端库，支持Java、Python、.NET等多种编程语言。</li></ol><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="cluster（集群）"><a href="#cluster（集群）" class="headerlink" title="cluster（集群）"></a>cluster（集群）</h3><p>集群中有多个节点，其中有一个为<strong>主节点</strong>，这个主节点是可以通过<strong>选举产生</strong>的，<strong>主从节点是对于集群内部来说的</strong>。<code>es</code>的一个概念就是去<code>中心化</code>，字面上理解就是无中心节点，这是<strong>对于集群外部来说的</strong>，因为从外部来看<code>es集群</code>，在逻辑上是个整体，你与任何一个节点的通信和与整个<code>es集群</code>通信是等价的。</p><h3 id="shards（索引分片）"><a href="#shards（索引分片）" class="headerlink" title="shards（索引分片）"></a>shards（索引分片）</h3><p><code>es</code>可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。<strong>分片的数量只能在索引创建前指定</strong>，并且索引创建后不能更改。</p><h3 id="replicas（索引副本）"><a href="#replicas（索引副本）" class="headerlink" title="replicas（索引副本）"></a>replicas（索引副本）</h3><p>es可以设置多个索引的副本，副本的作用：</p><ul><li>提高系统的<strong>容错性</strong>，当某个节点某个分片损坏或丢失时可以从副本中恢复。</li><li>提高es的<strong>查询效率</strong>，es会自动对搜索请求进行负载均衡。</li></ul><h3 id="recovery（数据恢复或数据重新分布）"><a href="#recovery（数据恢复或数据重新分布）" class="headerlink" title="recovery（数据恢复或数据重新分布）"></a>recovery（数据恢复或数据重新分布）</h3><p>es在<strong>有节点加入或退出</strong>时会根据机器的负载对索引分片进行<strong>重新分配</strong>，挂掉的节点重新启动时也会进行<strong>数据恢复</strong>。</p><h3 id="river（es的一个数据源）"><a href="#river（es的一个数据源）" class="headerlink" title="river（es的一个数据源）"></a>river（es的一个数据源）</h3><p>代表es的一个数据源，也是其它存储方式（如：数据库）同步数据到es的一个方法。它是以插件方式存在的一个es服务，通过<strong>读取river中的数据并把它索引到es中</strong>，官方的river有<code>couchDB</code>的，<code>RabbitMQ</code>的，<code>Twitter</code>的，<code>Wikipedia</code>的。</p><h3 id="gateway（索引快照的存储方式）"><a href="#gateway（索引快照的存储方式）" class="headerlink" title="gateway（索引快照的存储方式）"></a>gateway（索引快照的存储方式）</h3><p>es默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个es集群关闭再重新启动时就会从gateway中读取索引备份数据。es支持多种类型的gateway，有本地文件系统（默认），分布式文件系统，Hadoop的HDFS和amazon的s3云存储服务。</p><h3 id="discovery-zen（自动发现节点机制）"><a href="#discovery-zen（自动发现节点机制）" class="headerlink" title="discovery.zen（自动发现节点机制）"></a>discovery.zen（自动发现节点机制）</h3><p>es是一个基于<code>p2p</code>的系统，它先通过<strong>广播</strong>寻找存在的节点，再通过<strong>多播协议</strong>进行节点之间的通信，同时也<strong>支持点对点的交互</strong>。</p><h3 id="Transport（内部节点或集群-与客户端的交互方式）"><a href="#Transport（内部节点或集群-与客户端的交互方式）" class="headerlink" title="Transport（内部节点或集群 与客户端的交互方式）"></a>Transport（内部节点或集群 与客户端的交互方式）</h3><p>默认内部是使用<code>tcp协议</code>进行交互，同时它支持<code>http协议（json格式）</code>、<code>thrift</code>、<code>servlet</code>、<code>memcached</code>、<code>zeroMQ</code>等的传输协议（通过插件方式集成）。</p><h2 id="windows下的安装"><a href="#windows下的安装" class="headerlink" title="windows下的安装"></a>windows下的安装</h2><h3 id="安装ElasticSearch："><a href="#安装ElasticSearch：" class="headerlink" title="安装ElasticSearch："></a><strong>安装ElasticSearch：</strong></h3><p>①下载 elasticsearch-6.4.1.zip，下载链接：<a href="https://www.elastic.co/cn/downloads/elasticsearch">Download|Elasticsearch|Elastic</a></p><p>②直接解压至某目录，设置该目录为<code>ES_HOME</code>环境变量</p><p>③安装JDK，并设置<code>JAVA_HOME</code>环境变量</p><p>④在windows下，运行 <code>%ES_HOME%\bin\elasticsearch.bat</code>即可运行（双击运行）</p><p>启动成功后Elasticsearch会占用两个端口，<code>9300</code>是<strong>Elasticsearch集群节点之间通信的端口</strong>，<code>9200</code>是<strong>用户可以通过http（如浏览器）访问数据的入口</strong>。安装完成之后，可以在浏览器访问 <a href="http://127.0.0.1:9200/_cat/indices?v&amp;pretty">http://127.0.0.1:9200/_cat/indices?v&amp;pretty</a> 查询es存储数据状态的命令。</p><h3 id="安装head插件："><a href="#安装head插件：" class="headerlink" title="安装head插件："></a><strong>安装head插件：</strong></h3><p>联网时，直接运行<code>%ES_HOME%\bin\plugin --install mobz/elasticsearch-head</code>。</p><p>不联网时，下载<code>elasticsearch-head</code>的<code>zipball</code>的master包，然后运行<code>%ES_HOME%\bin\plugin --url file:///[path-to-downloadfile] --install head</code>，其中<code>[path-to-downloadfile]</code>是下载后master包的绝对路径。</p><p>安装完成，重启服务，在浏览器打开 <a href="http://localhost:9200/_plugin/head/">http://localhost:9200/_plugin/head/</a> 即可。</p><p>如果报错：<a href="http://localhost:9200/">http://localhost:9200</a> 报错：received plaintext http traffic on an https channel, closing connection <code>Netty4HttpChannel</code>。原因是Elasticsearch在Windows下开启了安全认证，找到 config/ 目录下面的<code>elasticsearch.yml</code>配置文件，把安全认证开关从原先的 true 都改成 false ，实现免密登录访问即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">xpack.security.http.ssl:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="Windows下ES内存配置修改"><a href="#Windows下ES内存配置修改" class="headerlink" title="Windows下ES内存配置修改"></a>Windows下ES内存配置修改</h2><p>Windows环境下elasticsearch起来后占用内存过高，可以通过配置修改elasticsearch占用的内存大小。涉及到elasticsearch的安装目录config文件夹下面的两个配置文件。</p><ul><li>在<code>elasticsearch.yml</code>里面找到 <code># bootstrap.memory_lock: true</code>，去掉#号，使之生效。</li><li>在<code>jvm.options</code>里面，找到 <code>## -Xms4g</code>和<code>## -Xmx4g</code>，把##去掉，将其启用。</li></ul><hr><h1 id="Linux环境搭建Elasticsearch"><a href="#Linux环境搭建Elasticsearch" class="headerlink" title="Linux环境搭建Elasticsearch"></a>Linux环境搭建Elasticsearch</h1><p>参考文章：<a href="https://cloud.tencent.com/developer/article/2442280">分布式日志处理：ELK+Kafka实现日志收集</a></p><ul><li>elasticsearch-6.2.4.tar.gz 安装文件</li><li>elasticsearch-analysis-ik-6.2.4.zip 安装中文文件</li></ul><h2 id="安装-Elasticsearch"><a href="#安装-Elasticsearch" class="headerlink" title="安装 Elasticsearch"></a>安装 Elasticsearch</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w vm.max_map_count=262144          <span class="comment">#设置内存！每次启动都要给个运行内存！</span></span><br><span class="line">tar -zxvf elasticsearch-6.2.4.tar.gz         <span class="comment">#指定目录下 解压</span></span><br><span class="line"><span class="comment"># 解压完成,设置elasticsearch-6.2.4/config/目录下：elasticsearch.yml文件保存这一些配置信息,端口9200...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># linunx 创建一个组 Elasticsearch 不能使用Root用户，需要由一个独立用户！</span></span><br><span class="line">groupadd elsearch    <span class="comment">#创建一个组</span></span><br><span class="line">useradd elsearch -g elsearch -p elasticsearch <span class="comment">#设置密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压elasticsearch中文安装包！</span></span><br><span class="line"><span class="comment"># unzip unzip 解压命令! zip压缩包解压,需要下载应用！ install 在线安装(需要网络！)！</span></span><br><span class="line">yum install unzip    <span class="comment">#下载unzip应用;</span></span><br><span class="line"><span class="comment"># 解压目录下文件！</span></span><br><span class="line">unzip /usr/local/elasticsearch-analysis-ik-6.2.4.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权用户操作elsearch  </span></span><br><span class="line"><span class="built_in">chown</span> -R elsearch:elsearch  elasticsearch-6.2.4</span><br><span class="line"><span class="comment"># 创建一个目录, 把中午解压包放进去。 就可以显示中文了！ </span></span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/elasticsearch-6.2.4/plugins/analysis-ik/    <span class="comment">#elasticsearch-6.2.4/plugins下创建一个文件analysis-ik</span></span><br><span class="line"><span class="comment"># 中文解压文件,直接copy进去</span></span><br><span class="line"><span class="built_in">cp</span> -r /usr/local/elasticsearch/* /usr/local/elasticsearch-6.2.4/plugins/analysis-ik/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Contos还需进行配置：修改 soft    nproc     4096</span></span><br><span class="line">vi /etc/security/limits.d/20-nproc.conf        <span class="comment">#修改 soft    nproc     4096 对应...</span></span><br><span class="line"></span><br><span class="line">vi /etc/security/limits.conf                  <span class="comment">#文件添加：↓↓</span></span><br><span class="line">*               soft    nofile          65536</span><br><span class="line">*               hard    nofile          65536</span><br><span class="line">*               soft    <span class="built_in">nproc</span>           4096</span><br><span class="line">*               hard    <span class="built_in">nproc</span>           4096</span><br><span class="line"><span class="comment">#授权：</span></span><br><span class="line"><span class="built_in">chown</span> -R elsearch:elsearch /usr/local/elasticsearch/</span><br></pre></td></tr></table></figure><h2 id="启动-Elasticsearch"><a href="#启动-Elasticsearch" class="headerlink" title="启动 Elasticsearch"></a>启动 Elasticsearch</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su elsearch</span><br><span class="line"><span class="comment"># 刷新</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment"># 切换路径</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local</span><br><span class="line"><span class="built_in">cd</span> elasticsearch-6.2.4/</span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line"><span class="comment"># elasticsearch  /bin目录下启动 </span></span><br><span class="line">./elasticsearch                <span class="comment"># 启动Elasticsearch</span></span><br></pre></td></tr></table></figure><h2 id="启动问题"><a href="#启动问题" class="headerlink" title="启动问题"></a>启动问题</h2><p><strong>启动莫名奇妙报错了：</strong> ERROR: [1] bootstrap checks failed [1]: max virtual memory areas vm.max_map_</p><ul><li>切换到root用户修改配置sysctl.conf 执行： <code>vi /etc/sysctl.conf</code></li><li>添加下面配置：<code>vm.max_map_count=655360</code></li><li>并执行命令：<code>sysctl -p</code></li><li><strong>然后，重新启动elasticsearch，即可启动成功。</strong></li></ul><hr><h1 id="ElasticSearch实时推送数据"><a href="#ElasticSearch实时推送数据" class="headerlink" title="ElasticSearch实时推送数据"></a>ElasticSearch实时推送数据</h1><h2 id="实时搜索"><a href="#实时搜索" class="headerlink" title="实时搜索"></a>实时搜索</h2><ol><li><p><strong>实时索引更新</strong></p><p>Elasticsearch 提供了实时索引更新功能，<strong>当文档被索引或更新时，它们立即可用于搜索</strong>。这意味着用户可以在提交数据后立即执行搜索，而无需等待索引的重建或更新。</p></li><li><p><strong>近实时搜索</strong></p><p>Elasticsearch 还支持近实时搜索，这意味着<strong>文档在被索引后的短时间内就可以被搜索到</strong>。这通常需要<strong>毫秒级的延迟</strong>，使用户可以几乎即刻获得最新数据。</p></li><li><p><strong>持续查询</strong></p><p>Elasticsearch 支持持续查询（<code>continuous queries</code>），这是一种<strong>持续监视数据更改并在变化发生时立即通知客户端的机制</strong>。这通过 Elasticsearch 的 <code>Watcher</code> 插件来实现，可用于实现<strong>实时监控和报警系统</strong>。</p></li></ol><h2 id="实时推送"><a href="#实时推送" class="headerlink" title="实时推送"></a><strong>实时推送</strong></h2><ol><li><p><strong>基于查询的通知</strong></p><p>Elasticsearch 允许用户<strong>定义特定查询条件，并设置通知规则</strong>。当满足查询条件时，Elasticsearch 可以触发通知，将新数据或结果发送给用户。这可以通过 Elastic Stack 中的组件，如 <code>Logstash</code> 和 <code>Kibana</code>，来实现。</p></li><li><p><strong>集成第三方通知服务</strong></p><p>Elasticsearch 可以与<strong>第三方通知服务集成</strong>（如邮件或短信服务），以通过这些服务向用户发送通知。这可以通过 <code>Elasticsearch Watcher</code> 插件来实现，它可以在数据满足条件时触发通知。</p></li></ol><h2 id="实时推送数据到前端"><a href="#实时推送数据到前端" class="headerlink" title="实时推送数据到前端"></a>实时推送数据到前端</h2><p>Elasticsearch实时推送数据到前端，通常涉及到Elasticsearch的实时数据搜索和更新功能，以及前端的技术栈（如使用<code>JavaScript</code>和<code>WebSocket</code>等技术）来实现实时数据的接收和展示。步骤和方案如下： </p><ol><li><p><strong>步骤 1: 启用Elasticsearch的实时功能</strong> </p><ol><li><p> <strong>使用Elasticsearch的实时搜索功能：</strong> 当你索引或更新文档时，这些变更几乎可以立即反映在搜索结果中。  </p></li><li><p><strong>开启_refresh_interval：</strong> 你可以在索引设置中调整refresh_interval，以控制Elasticsearch索引的刷新频率。默认情况下，这个值是1秒，这意味着每秒Elasticsearch会刷新一次索引，确保最新的文档可以被搜索到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /your_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;index&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;refresh_interval&quot;</span> : <span class="string">&quot;1s&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>步骤 2: 使用Elasticsearch的Watcher或XPack Alerting</strong></p><p>对于更复杂的实时通知需求，可用Elasticsearch的<code>Watcher插件</code>或<code>XPack Alerting</code>功能。它们允许<strong>基于某些条件触发动作</strong>，例如发送HTTP请求到你的前端服务器。 </p><p><strong>设置Watcher：</strong> 创建一个Watcher来监控你的数据变化。例如，当某个字段的值达到特定条件时，触发一个动作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PUT /_watcher/watch/my_watch</span><br><span class="line">&#123;</span><br><span class="line">  &quot;trigger&quot;: &#123;</span><br><span class="line">    &quot;schedule&quot;: &#123;</span><br><span class="line">      &quot;interval&quot;: &quot;10s&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;input&quot;: &#123;</span><br><span class="line">    &quot;search&quot;: &#123;</span><br><span class="line">      &quot;request&quot;: &#123;</span><br><span class="line">        &quot;indices&quot;: [&quot;your_index&quot;],</span><br><span class="line">        &quot;body&quot;: &#123;</span><br><span class="line">          &quot;query&quot;: &#123;</span><br><span class="line">            &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;condition&quot;: &#123;</span><br><span class="line">    &quot;compare&quot;: &#123;</span><br><span class="line">      &quot;ctx.payload.hits.total.value&quot;: &#123;</span><br><span class="line">        &quot;gt&quot;: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;actions&quot;: &#123;</span><br><span class="line">    &quot;notify_frontend&quot;: &#123;</span><br><span class="line">      &quot;http&quot;: &#123;</span><br><span class="line">        &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;http://your-frontend-server/api/update&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>步骤 3: 前端实现实时数据接收</strong> </p><ol><li> <strong>使用WebSocket：</strong> 可以在前端使用WebSocket来<strong>监听后端服务器的实时推送</strong>。后端可以使用如<code>socket.io</code>、<code>websockets</code>等库来实现WebSocket服务器。</li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="title function_">io</span>(<span class="string">&#x27;http://your-backend-server&#x27;</span>); <span class="comment">// 使用socket.io客户端连接后端服务器</span></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123; <span class="comment">// 监听&#x27;data&#x27;事件，接收后端推送的实时数据</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// 处理接收到的数据，例如更新页面显示等</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>轮询：</strong> 另一种简单的方法是使用轮询（<strong>定期从后端获取数据</strong>）。虽然这不是真正的实时推送，但在某些情况下可以作为临时解决方案。可以使用<code>setInterval</code>在 JavaScript 中实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;http://your-backend-server/api/data&#x27;</span>) <span class="comment">// 定期从后端获取数据</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// 处理接收到的数据，例如更新页面显示等</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">10000</span>); <span class="comment">// 每10秒获取一次数据</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>步骤 4: 测试和优化</strong></p><p>确保进行充分的测试，确保实时数据的准确性和性能。监控网络延迟和Elasticsearch的性能，根据需要进行调整。</p></li></ol>]]></content>
    
    
    <summary type="html">ElasticStack</summary>
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="ElasticStack" scheme="https://southernfish.github.io/tags/ElasticStack/"/>
    
  </entry>
  
  <entry>
    <title>ElasticStack Beats数据采集</title>
    <link href="https://southernfish.github.io/2025/07/01/server/elatsticstack-beats/"/>
    <id>https://southernfish.github.io/2025/07/01/server/elatsticstack-beats/</id>
    <published>2025-07-01T04:00:36.000Z</published>
    <updated>2025-07-10T12:47:35.025Z</updated>
    
    <content type="html"><![CDATA[<p>‌<strong>Logstash太费内存</strong>，如果在要采集的服务上都安装，这样资源消耗非常高，所以我们要用<strong>轻量级</strong>的采集工具如（Beats）才更高效，更省资源。 参考文章：<a href="https://blog.csdn.net/shjwkzkzk/article/details/148403336">ELK-beats数据采集</a>、<a href="https://blog.csdn.net/LIUCHUAN01/article/details/144473979">ELK系列-（四）轻量级的日志收集助手-Beat家族</a>、<a href="https://blog.csdn.net/Lemon__ing/article/details/148667821">ELK日志文件分析系统——补充(B——Beats)</a></p><h1 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong><code>Beats</code></strong> 是 Elastic Stack 提供的一组轻量级数据采集器，负责从各种来源采集数据，然后将数据发送到 <strong>Elasticsearch</strong> 或 <strong>Logstash</strong>。这些小工具非常轻巧，占用系统资源少，适用于海量的分布式环境。<a href="https://www.elastic.co/guide/en/beats/libbeat/current/beats-reference.html">Beats官方文档地址</a></p><p><strong>Beats</strong>在实现时选择了<code>Golang</code>，Golang的高效内存管理、简洁语法和并发处理能力，使 Beats 在保证低资源消耗的前提下，提供强大的数据采集和传输能力。</p><ol><li>Golang是编译型语言，它编译后的二进制文件无需依赖虚拟机，因此在资源消耗和启动速度上都比Java更有优势。</li><li>Golang的跨平台特性使得Beats能够原生支持Linux、Windows和macOS等多个操作系统，减少了开发和部署的复杂度。</li><li>Golang的并发模型非常适合处理高并发的日志采集任务，Beats能在多个数据流之间高效地并行处理，而不会因为大量日志数据的收集而导致性能瓶颈。</li></ol><h2 id="Beats的家族成员"><a href="#Beats的家族成员" class="headerlink" title="Beats的家族成员"></a>Beats的家族成员</h2><p>Beats是轻量级的日志收集处理工具，Beats占用资源少。包含<strong>多款轻量级采集器</strong>：</p><ul><li><p><code>Packetbeat</code>： 网络数据（收集网络流量数据）</p><ul><li>用于 <strong>网络数据包</strong> 的捕获和分析，适合做 <strong>网络监控</strong>，可以帮助你分析各种应用层协议（如HTTP、MySQL、Redis、DNS等）的流量</li></ul></li><li><p><code>Metricbeat</code>： 指标 （收集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）</p><ul><li>采集 <strong>系统指标</strong>（如CPU、内存、磁盘、网络等）和 <strong>应用程序指标</strong>（如MySQL、Redis等），并将这些数据发送到 <strong>Elasticsearch</strong> 进行存储和分析。</li></ul></li><li><p><code>Filebeat</code>： 文件（收集日志文件数据）</p><ul><li>主要用于 <strong>日志文件</strong> 的采集，常用于 Web 服务器、应用程序和系统日志的收集。它会实时读取指定的日志文件，并将日志内容发送给 <strong>Elasticsearch</strong> 或 <strong>Logstash</strong>。</li></ul></li><li><p><code>Winlogbeat</code>： windows事件日志（收集 Windows 事件<a href="https://cloud.tencent.com/solution/cloudlog?from_column=20065&from=20065">日志数据</a>）</p><ul><li>专为 <strong>Windows事件日志</strong> 设计，能帮助你采集 Windows 系统的事件日志（如应用程序日志、安全日志等），并发送给 <strong>Elasticsearch</strong> 或 <strong>Logstash</strong>。</li></ul></li><li><p><code>Auditbeat</code>：审计数据 （收集审计日志）</p><ul><li>主要用于 <strong>审计</strong> 和 <strong>系统安全监控</strong>，可以帮助收集有关操作系统文件、用户登录等的详细信息。</li></ul></li><li><p><code>Heartbeat</code>：运行时间监控 （收集系统运行时的数据）</p><ul><li>用于 <strong>服务监控</strong>，它定期发送HTTP、TCP或ICMP请求，监控服务的可用性和响应时间，帮助用户了解服务是否正常工作。</li></ul></li></ul><h2 id="Beats的工作原理"><a href="#Beats的工作原理" class="headerlink" title="Beats的工作原理"></a>Beats的工作原理</h2><p>它们类似<strong>数据搬运工</strong>，从各类系统、应用中采集数据后，送到 Logstash 或 Elasticsearch 进行处理。具体流程如下：</p><ol><li><strong>数据采集：</strong>Beat通过读取指定路径或接口，获取源数据（如日志文件、系统指标、网络流量等）。</li><li><strong>数据传输：</strong>Beat将采集到的数据经过一定的处理后，通过HTTP或其他协议发送到 Logstash 或 Elasticsearch。</li><li><strong>数据处理与分析：</strong>如果是通过 Logstash 发送，Logstash会进一步处理数据（如过滤、转换等），然后将数据发送到 Elasticsearch。</li><li><strong>可视化：</strong>数据被 Elasticsearch 存储后，借助 Kibana 进行可视化展示，帮助用户快速了解系统和应用的运行状况。</li></ol><h2 id="Beats的优势"><a href="#Beats的优势" class="headerlink" title="Beats的优势"></a>Beats的优势</h2><ul><li><strong>轻量级：</strong>Beat具有较小的内存占用和CPU消耗，适合在大规模分布式系统中部署。</li><li><strong>高效：</strong>采集到的数据可以快速传输到Elasticsearch，几乎没有延迟。</li><li><strong>灵活性：</strong>支持多种数据源和输出目标，可以满足不同的数据采集需求。</li></ul><h2 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a><strong>关键特性</strong></h2><table><thead><tr><th><strong>特性</strong>‌</th><th>‌<strong>详细说明</strong>‌</th></tr></thead><tbody><tr><td>‌<strong>专业化分工</strong>‌</td><td>不同 Beat 聚焦特定场景（如 <code>Filebeat</code> 日志、<code>Metricbeat</code> 监控指标）</td></tr><tr><td>‌<strong>低侵入性</strong>‌</td><td>无需改造应用代码，以代理形式部署在主机/容器内</td></tr><tr><td><strong>实时处理能力</strong>‌</td><td>毫秒级延迟传输数据，支持流式分析场景</td></tr><tr><td>‌<strong>安全传输</strong>‌</td><td>原生支持 TLS 加密、身份认证（API Key/OAuth2）</td></tr><tr><td>‌<strong>自动负载均衡</strong>‌</td><td>多节点部署时自动分配采集任务，避免单点故障</td></tr></tbody></table><h2 id="Beats的适用场景"><a href="#Beats的适用场景" class="headerlink" title="Beats的适用场景"></a>Beats的适用场景</h2><ul><li><strong>日志收集：</strong>如Web服务器、应用程序、操作系统日志等。</li><li><strong>系统监控：</strong>如CPU、内存、磁盘等指标采集。</li><li><strong>网络监控：</strong>如分析网络流量、检测应用层协议等。</li><li><strong>安全审计：</strong>如收集操作系统和应用的安全事件。</li></ul><h2 id="filebeat安装"><a href="#filebeat安装" class="headerlink" title="filebeat安装"></a><strong>filebeat安装</strong></h2><p>在需要收集日志的机器（node4，192.168.98.204）上部署filebeat。安装方式如下：</p><ol><li><p><strong>yum安装：</strong>安装ES的时候设置过yum源可以直接使用yum命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node4 ~]# yum -y install filebeat</span><br></pre></td></tr></table></figure></li><li><p><strong>rpm安装</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node4 ~]# rpm -i filebeat-<span class="number">7</span>.<span class="number">6</span>.<span class="number">0</span>-x86_64.rpm </span><br><span class="line">警告：filebeat-<span class="number">7</span>.<span class="number">6</span>.<span class="number">0</span>-x86_64.rpm: 头V4 RSA/SHA512 Signature, 密钥 ID d88e42b4: NOKEY</span><br><span class="line">-i install</span><br></pre></td></tr></table></figure></li><li><p>源码安装（参考官方文档）</p><p>安装目录：/usr/share/filebeat</p><p>配置文件目录： /etc/filebeat</p><p>配置文件：/etc/filebeat/filebeat.yml</p><p>服务启动管理：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node4 ~]# systemctl enable filebeat</span><br><span class="line">Synchronizing state of filebeat.service with SysV service script with /usr/lib/systemd/systemd-sysv-install.</span><br><span class="line"><span class="function">Executing: /<span class="title">usr</span>/<span class="title">lib</span>/<span class="title">systemd</span>/<span class="title">systemd</span>-<span class="title">sysv</span>-<span class="title">install</span> <span class="title">enable</span> <span class="title">filebeat</span></span></span><br><span class="line"><span class="function"><span class="title">Created</span> <span class="title">symlink</span> /<span class="title">etc</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">multi</span>-<span class="title">user.target.wants</span>/<span class="title">filebeat.service</span> → /<span class="title">usr</span>/<span class="title">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">filebeat.service</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 没有修改配置文件，起不来</span></span><br><span class="line"><span class="function">[<span class="title">root</span>@<span class="title">node4</span> ~]# <span class="title">systemctl</span> <span class="title">start</span> <span class="title">filebeat</span></span></span><br></pre></td></tr></table></figure></li></ol><h2 id="filebeat配置文件"><a href="#filebeat配置文件" class="headerlink" title="filebeat配置文件"></a>filebeat配置文件</h2><p>配置文件查看：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node4 ~]# cat /etc/filebeat/filebeat.yml |grep -v &#x27;#&#x27; |grep -v &#x27;^$&#x27;</span><br></pre></td></tr></table></figure><p>filebeat.yml 内容：（ <strong>收集本机messages日志到ElasticSearch</strong>）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span>            <span class="comment"># 默认false，修改为true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="comment"># - /var/log/*.log        # 收集日志的路径</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/log/messages</span>        <span class="comment"># 收集日志的路径 filebeat收集本机messages日志到ES</span></span><br><span class="line"><span class="attr">filebeat.config.modules:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">$&#123;path.config&#125;/modules.d/*.yml</span></span><br><span class="line">  <span class="attr">reload.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">setup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 定义kibana地址</span></span><br><span class="line"><span class="attr">setup.kibana:</span></span><br><span class="line"><span class="comment"># 定义ES地址接收数据</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;192.168.98.201:9200&quot;</span>]</span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">add_host_metadata:</span> <span class="string">~</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">add_cloud_metadata:</span> <span class="string">~</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">add_docker_metadata:</span> <span class="string">~</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">add_kubernetes_metadata:</span> <span class="string">~</span></span><br></pre></td></tr></table></figure><p>修改filebeat配置文件之后需要重启filebeat服务，生效配置</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node4 ~]# systemctl restart filebeat</span><br></pre></td></tr></table></figure><hr><h1 id="Filebeat收集数据上传"><a href="#Filebeat收集数据上传" class="headerlink" title="Filebeat收集数据上传"></a>Filebeat收集数据上传</h1><h3 id="发送ElasticSearch并设置数据索引"><a href="#发送ElasticSearch并设置数据索引" class="headerlink" title="发送ElasticSearch并设置数据索引"></a>发送ElasticSearch并设置<strong>数据索引</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在output.*输出全局中插入下面三行</span></span><br><span class="line"><span class="attr">setup.ilm.enabled:</span> <span class="literal">false</span>                         <span class="comment"># 禁用ilm</span></span><br><span class="line"><span class="attr">setup.template.name:</span> <span class="string">&quot;node4_messages&quot;</span>             <span class="comment"># 设置索引模板名</span></span><br><span class="line"><span class="attr">setup.template.pattern:</span> <span class="string">&quot;node4_messages-*&quot;</span>         <span class="comment"># 索引前缀</span></span><br><span class="line"><span class="comment"># 定义ES地址接收数据</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;192.168.98.201:9200&quot;</span>]                <span class="comment"># ElasticSearch 服务器地址和端口</span></span><br><span class="line">  <span class="attr">index:</span> <span class="string">&quot;node4_messages-<span class="template-variable">%&#123;+yyyy.MM.dd&#125;</span>&quot;</span>         <span class="comment">#定义索引</span></span><br></pre></td></tr></table></figure><h3 id="发送Logstash"><a href="#发送Logstash" class="headerlink" title="发送Logstash"></a>发送Logstash</h3><p>filebeat将采集日志发送给Logstash（node3，192.168.98.203）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义输出到logstash</span></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;192.168.98.203:5044&quot;</span>]                <span class="comment"># Logstash 服务器地址和端口</span></span><br></pre></td></tr></table></figure><p>logstash收到日志添加索引后发送ElasticSearch（node1：192.168.98.201，node2：192.168.98.202）。Logstash配置文件查看：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node3 conf.d]#cat filebeat_to_logstash_es.conf </span><br></pre></td></tr></table></figure><p>Logstash的配置文件 filebeat_to_logstash_es.conf </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">input</span> &#123;</span><br><span class="line">    <span class="string">beats</span> &#123;</span><br><span class="line">        <span class="string">port</span> <span class="string">=&gt;</span> <span class="number">5044</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">output</span> &#123;</span><br><span class="line">    <span class="string">elasticsearch</span> &#123;</span><br><span class="line">        <span class="string">hosts</span> <span class="string">=&gt;</span> [<span class="string">&quot;192.168.98.201:9200&quot;</span>]            <span class="comment"># ElasticSearch 服务器地址和端口</span></span><br><span class="line">        <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">&quot;server_node4-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>&quot;</span>       <span class="comment"># 定义索引</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启filebeat、logstash服务生效配置</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node4 ~]# systemctl restart filebeat</span><br><span class="line">[root@node3 ~]# systemctl restart logstash</span><br></pre></td></tr></table></figure><hr><h1 id="基本部署"><a href="#基本部署" class="headerlink" title="基本部署"></a>基本部署</h1><h2 id="Filebeat-单机部署流程"><a href="#Filebeat-单机部署流程" class="headerlink" title="Filebeat 单机部署流程"></a><strong>Filebeat 单机部署流程</strong></h2><h3 id="安装依赖与下载"><a href="#安装依赖与下载" class="headerlink" title="安装依赖与下载"></a><strong>安装依赖与下载</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update             <span class="comment"># 更新软件源列表</span></span><br><span class="line">sudo apt install wget -y     <span class="comment"># 安装下载工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载二进制包</span></span><br><span class="line">wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-8.13.4-linux-x86_64.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令解析</span></span><br><span class="line">apt update                    <span class="comment"># 获取最新软件包信息，避免版本冲突</span></span><br><span class="line">wget                        <span class="comment"># 从 Elastic 官网下载指定版本 Filebeat（替换版本号适配环境）</span></span><br></pre></td></tr></table></figure><h3 id="解压与权限配置"><a href="#解压与权限配置" class="headerlink" title="解压与权限配置"></a><strong>解压与权限配置</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf filebeat-8.13.4-linux-x86_64.tar.gz -C /opt/        <span class="comment"># 解压至 /opt 目录</span></span><br><span class="line">sudo <span class="built_in">chown</span> -R root:root /opt/filebeat-8.13.4                 <span class="comment"># 所有权归属 root（安全合规）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键参数：</span></span><br><span class="line">-zxvf         <span class="comment"># -z 解压 gzip，-x 解包，-v 显示过程，-f 指定文件</span></span><br><span class="line"><span class="built_in">chown</span> -R    <span class="comment"># 递归修改目录所有权，避免权限不足导致采集失败</span></span><br></pre></td></tr></table></figure><h3 id="配置文件修改‌"><a href="#配置文件修改‌" class="headerlink" title="配置文件修改‌"></a><strong>配置文件修改</strong>‌</h3><p>编辑 <code>/opt/filebeat-8.13.4/filebeat.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">filestream</span></span><br><span class="line">   <span class="attr">paths:</span> <span class="bullet">-</span> <span class="string">/var/log/*.log</span>                 <span class="comment"># 监控所有 .log 文件</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line"> <span class="attr">hosts:</span> [<span class="string">&quot;192.168.98.202:9200&quot;</span>]         <span class="comment"># ES 集群地址</span></span><br><span class="line"><span class="attr">logging.level:</span> <span class="string">warning</span>                     <span class="comment"># 减少日志量（生产环境推荐</span></span><br></pre></td></tr></table></figure><ul><li>‌配置要点：<ul><li><code>paths</code>：支持通配符（如 <code>/var/log/nginx/*.log</code> 采集 Nginx 日志）。</li><li><code>hosts</code>：多节点集群可配置负载均衡（<code>[&quot;http://node1:9200&quot;, &quot;http://node2:9200&quot;]</code>）。</li></ul></li></ul><h3 id="‌启动"><a href="#‌启动" class="headerlink" title="‌启动"></a>‌<strong>启动</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/filebeat-8.13.4         <span class="comment"># 到安装目录下</span></span><br><span class="line">./filebeat -e -c filebeat.yml    <span class="comment"># 前台启动（-e 输出日志到控制台）</span></span><br></pre></td></tr></table></figure><h3 id="‌验证‌"><a href="#‌验证‌" class="headerlink" title="‌验证‌"></a>‌验证‌</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:5066/stats | jq .filebeat.harvesting    <span class="comment"># 检查采集状态（需安装 jq）</span></span><br></pre></td></tr></table></figure><hr><h2 id="Filebeat-集群化部署关键步骤"><a href="#Filebeat-集群化部署关键步骤" class="headerlink" title="Filebeat 集群化部署关键步骤"></a>Filebeat 集群化部署关键步骤</h2><h3 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a><strong>统一配置管理</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp filebeat.yml root@node4:/opt/filebeat-8.13.4/        <span class="comment"># 分发配置文件到集群节点</span></span><br></pre></td></tr></table></figure><p><strong>需同步项</strong>‌：配置文件 <code>filebeat.yml</code>、证书文件（若启用 TLS）</p><h3 id="注册系统服务（所有节点）"><a href="#注册系统服务（所有节点）" class="headerlink" title="注册系统服务（所有节点）"></a><strong>注册系统服务（所有节点）</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo ./filebeat setup --service                            <span class="comment"># 生成 systemd 服务文件</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now filebeat                    <span class="comment"># 启动并设置开机自启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务管理命令：</span></span><br><span class="line">systemctl status filebeat                                <span class="comment"># 检查运行状态</span></span><br><span class="line">journalctl -u filebeat -f                                <span class="comment"># 实时追踪日志</span></span><br></pre></td></tr></table></figure><h2 id="Kubernetes-部署DaemonSet-模式"><a href="#Kubernetes-部署DaemonSet-模式" class="headerlink" title="Kubernetes 部署DaemonSet 模式"></a>Kubernetes 部署DaemonSet 模式</h2><h3 id="部署-Filebeat-DaemonSet"><a href="#部署-Filebeat-DaemonSet" class="headerlink" title="部署 Filebeat DaemonSet"></a>部署 Filebeat DaemonSet</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">filebeat</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">template:</span></span><br><span class="line">     <span class="attr">spec:</span></span><br><span class="line">         <span class="attr">containers:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">filebeat</span></span><br><span class="line">           <span class="attr">image:</span> <span class="string">docker.elastic.co/beats/filebeat:8.13.4</span></span><br><span class="line">           <span class="attr">volumeMounts:</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">             <span class="attr">mountPath:</span> <span class="string">/var/log</span> <span class="comment"># 挂载宿主机日志目录</span></span><br><span class="line">           <span class="bullet">-</span> <span class="string">name:config</span></span><br><span class="line">             <span class="attr">mountPath:</span> <span class="string">/usr/share/filebeat/filebeat.yml</span></span><br><span class="line">           <span class="attr">volumes:</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">             <span class="attr">hostPath: path:</span> <span class="string">/var/log</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">             <span class="attr">configMap: name:</span> <span class="string">filebeat-config</span> <span class="comment"># 通过 ConfigMap 管理配置</span></span><br></pre></td></tr></table></figure><p><strong>关键设计</strong>‌：</p><ul><li><code>DaemonSet</code>：确保每个 Node 运行一个 Pod，采集节点日志。</li><li><code>hostPath</code>：直接挂载宿主机日志目录，避免日志遗漏。</li></ul><h3 id="生成-ConfigMap"><a href="#生成-ConfigMap" class="headerlink" title="生成 ConfigMap"></a><strong>生成 ConfigMap</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap filebeat-config --from-file=filebeat.yml <span class="comment"># 从本地配置创建</span></span><br></pre></td></tr></table></figure><h2 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h2><table><thead><tr><th><strong>问题现象</strong>‌</th><th>‌<strong>诊断命令</strong>‌</th><th>解释说明</th></tr></thead><tbody><tr><td>‌<strong>日志采集中断</strong>‌</td><td><code>grep &quot;ERR&quot; /var/log/filebeat/filebeat</code></td><td>过滤错误日志</td></tr><tr><td><strong>ES 连接失败</strong>‌</td><td><code>telnet es-host 9200</code></td><td>验证网络连通性</td></tr><tr><td>‌<strong>CPU 占用过高</strong>‌</td><td><code>./filebeat export config</code></td><td>检查冗余 input 配置</td></tr></tbody></table><h2 id="生产环境调优参数"><a href="#生产环境调优参数" class="headerlink" title="生产环境调优参数"></a><strong>生产环境调优参数</strong></h2><p>在 <code>filebeat.yml</code> 中增加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">queue.mem.events:</span> <span class="number">4096</span>                         <span class="comment"># 内存队列大小（防突发流量）</span></span><br><span class="line"> <span class="attr">processors:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">drop_fields:</span>                         <span class="comment"># 删除无用字段减负</span></span><br><span class="line">     <span class="attr">fields:</span> [<span class="string">&quot;agent.ephemeral_id&quot;</span>]</span><br></pre></td></tr></table></figure><ul><li>‌调优效果：<ul><li>提升吞吐量 30%+，降低 ES 索引压力。</li><li>减少网络带宽消耗（尤其对云环境）。</li></ul></li></ul><p><strong>操作原则</strong>‌：</p><ol><li>单机测试使用 <code>-e</code> 前台启动快速验证；</li><li>生产环境务必注册为 systemd 服务保障高可用；</li><li>Kubernetes 需配置资源限制（CPU/Memory）。</li></ol><hr><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="基础命令结构"><a href="#基础命令结构" class="headerlink" title="基础命令结构"></a><strong>基础命令结构</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./filebeat [全局选项] &lt;子命令&gt; [子命令选项]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令层级：</span></span><br><span class="line">    <span class="comment"># 全局选项：影响所有子命令行为（如 `-c` 指定配置文件）</span></span><br><span class="line">    <span class="comment"># 子命令：执行特定功能（如 `run` 启动采集）</span></span><br><span class="line">    <span class="comment"># 子命令选项：针对子命令的细化配置。</span></span><br></pre></td></tr></table></figure><h2 id="核心子命令解析‌"><a href="#核心子命令解析‌" class="headerlink" title="核心子命令解析‌"></a><strong>核心子命令解析</strong>‌</h2><p>‌<strong>1. 运行日志采集（<code>run</code>）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./filebeat run \</span><br><span class="line"> -e \                                                        <span class="comment"># 日志输出到标准错误（调试用）</span></span><br><span class="line"> -c /etc/filebeat.yml \                                     <span class="comment"># 指定配置文件路径</span></span><br><span class="line"> -E <span class="string">&quot;output.elasticsearch.hosts=[&#x27;http://es-node:9200&#x27;]&quot;</span>     <span class="comment"># 动态覆盖配置</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数意义：</span></span><br><span class="line">-e                    <span class="comment"># 禁用系统日志，直接输出到终端，便于实时调试。</span></span><br><span class="line">-c                    <span class="comment"># 显式指定配置文件，避免默认路径冲突。</span></span><br><span class="line">-E                    <span class="comment"># 运行时动态修改配置项（优先级高于配置文件）。</span></span><br></pre></td></tr></table></figure><p><strong>2.配置测试（<code>test</code>）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./filebeat <span class="built_in">test</span> config \         <span class="comment"># 验证配置文件语法</span></span><br><span class="line"> -c ./filebeat-prod.yml \         <span class="comment"># 测试非默认配置文件</span></span><br><span class="line"> -d <span class="string">&quot;publish&quot;</span>                     <span class="comment"># 仅调试&quot;publish&quot;相关组件</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调试选择器</span></span><br><span class="line">-d <span class="string">&quot;*&quot;</span>                            <span class="comment"># 启用全部组件调试日志。</span></span><br><span class="line">-d <span class="string">&quot;input&quot;</span>                        <span class="comment"># 聚焦输入模块问题排查。</span></span><br></pre></td></tr></table></figure><p><strong>3.环境初始化（<code>setup</code>）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./filebeat setup \</span><br><span class="line"> --dashboards \                             <span class="comment"># 自动创建Kibana仪表盘</span></span><br><span class="line"> --pipelines \                                 <span class="comment"># 部署Elasticsearch Ingest管道</span></span><br><span class="line"> -E <span class="string">&quot;setup.kibana.host=kibana:5601&quot;</span>         <span class="comment"># 指定Kibana地址</span></span><br></pre></td></tr></table></figure><p><strong>典型场景</strong>‌：</p><ul><li>首次部署时预加载索引模板、仪表盘等资源。</li><li>需提前配置 <code>output.elasticsearch</code> 连接信息。</li></ul><h2 id="模块管理命令"><a href="#模块管理命令" class="headerlink" title="模块管理命令"></a><strong>模块管理命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./filebeat modules <span class="built_in">enable</span> nginx \             <span class="comment"># 启用Nginx日志模块</span></span><br><span class="line">./filebeat modules list \                     <span class="comment"># 查看已启用模块</span></span><br><span class="line">./filebeat modules <span class="built_in">disable</span> system             <span class="comment"># 停用系统监控模块</span></span><br></pre></td></tr></table></figure><ul><li>‌模块配置：<ul><li>模块路径：<code>/etc/filebeat/modules.d/*.yml</code>。</li><li>支持动态覆盖：<code>-M &quot;nginx.access.var.paths=[/var/log/nginx/*.log]&quot;</code>。</li></ul></li></ul><h2 id="高级调试命令"><a href="#高级调试命令" class="headerlink" title="高级调试命令"></a><strong>高级调试命令</strong></h2><p>‌<strong>1. 性能分析</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./filebeat <span class="built_in">export</span> config \                     <span class="comment"># 导出最终生效配置（含默认值）</span></span><br><span class="line">./filebeat -v \                             <span class="comment"># 显示详细版本信息（含依赖库）</span></span><br></pre></td></tr></table></figure><p>‌<strong>2. 密钥管理</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./filebeat keystore create \                 <span class="comment"># 创建密钥库（存储敏感信息）</span></span><br><span class="line">./filebeat keystore add ES_PWD                 <span class="comment"># 交互式添加Elasticsearch密码</span></span><br></pre></td></tr></table></figure><p><strong>安全建议</strong>‌：</p><ul><li>用密钥库替代配置文件中的明文密码。</li><li>密钥库文件默认位于 <code>$FILEBEAT_PATH/data/keystore</code></li></ul><h2 id="生产环境常用组合"><a href="#生产环境常用组合" class="headerlink" title="生产环境常用组合"></a><strong>生产环境常用组合</strong></h2><p>‌<strong>1. 安全启动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./filebeat run \</span><br><span class="line"> --strict.perms=<span class="literal">false</span> \                     <span class="comment"># 放宽文件权限检查</span></span><br><span class="line"> --path.data=/mnt/filebeat_data             <span class="comment"># 自定义数据存储路径</span></span><br></pre></td></tr></table></figure><p>‌<strong>2. 多配置文件加载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat -c config.yml -c inputs.d/*.yml     <span class="comment"># 主配置+分片配置</span></span><br></pre></td></tr></table></figure><h2 id="命令输出解析示例‌"><a href="#命令输出解析示例‌" class="headerlink" title="命令输出解析示例‌"></a><strong>命令输出解析示例</strong>‌</h2><p>执行 <code>./filebeat test output</code> 后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Elasticsearch: http://es-node:9200...</span><br><span class="line"> Connection OK. Cluster UUID: xyz123         <span class="comment"># ES连接正常</span></span><br><span class="line">Logstash: tcp://logstash:5044...</span><br><span class="line"> Connection failed: dial <span class="built_in">timeout</span>             <span class="comment"># Logstash连接失败</span></span><br></pre></td></tr></table></figure><h2 id="关键参数速查表"><a href="#关键参数速查表" class="headerlink" title="关键参数速查表"></a><strong>关键参数速查表</strong></h2><table><thead><tr><th>‌<strong>参数</strong>‌</th><th>‌<strong>作用</strong>‌</th><th>‌<strong>示例</strong>‌</th></tr></thead><tbody><tr><td><code>-E</code></td><td>动态覆盖配置</td><td><code>-E &quot;queue.mem.events=2048&quot;</code></td></tr><tr><td><code>-M</code></td><td>覆盖模块配置</td><td><code>-M &quot;system.syslog.enabled=false&quot;</code></td></tr><tr><td><code>--path.*</code></td><td>自定义路径（配置、数据、日志）</td><td><code>--path.logs=/var/log/filebeat</code></td></tr><tr><td><code>--once</code></td><td>采集一次后退出（测试用）</td><td><code>./filebeat --once</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">ElasticStack Beats</summary>
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="ElasticStack" scheme="https://southernfish.github.io/tags/ElasticStack/"/>
    
  </entry>
  
  <entry>
    <title>ElasticStack Logstash日志分析处理</title>
    <link href="https://southernfish.github.io/2025/07/01/server/elatsticstack-logstash/"/>
    <id>https://southernfish.github.io/2025/07/01/server/elatsticstack-logstash/</id>
    <published>2025-07-01T01:30:36.000Z</published>
    <updated>2025-07-10T12:47:35.025Z</updated>
    
    <content type="html"><![CDATA[<p>Logstash是一个开源的服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到指定的存储库中。它支持200多个插件，可以从各种数据源（如 Filebeat、 Kafka 、 JDBC 等）采集数据，并通过过滤器进行数据处理（如 Grok解析、字段脱敏、 GeoIP转换等），最后将处理后的数据输出到多个目的地（如 Elasticsearch、 Kafka 、 S3 等）‌  参考文章：<a href="https://cloud.tencent.com/developer/article/2350026">Elasticsearch系列组件：Logstash强大的日志管理和数据分析工具</a>、<a href="https://blog.csdn.net/shjwkzkzk/article/details/148403336">ElasticStack对接kafka集群</a></p><h1 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h1><p>Logstash 是一个开源的数据收集引擎，具有实时管道功能，主要用于日志数据的收集、分析和处理‌。包含3个主要部分： 输入(inputs)，过滤器(filters)和输出(outputs)。</p><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ol><li><strong>‌数据收集‌：</strong>可以<strong>从多种数据源收集数据</strong>，包括<code>日志文件、系统消息队列、数据库</code>等。它支持多种输入插件，如<code>file</code>、<code>syslog</code>、<code>redis</code>等，能够灵活地从各种来源捕捉事件‌。  </li><li><strong>数据处理‌：</strong>可以<strong>对收集到的数据进行过滤、转换和格式化</strong>。它提供了丰富的<strong>过滤器插件</strong>，可以对数据进行<code>解析、提取字段、去除无效数据</code>等操作。Logstash还支持对数据进行<code>格式化</code>，以满足不同的存储和处理需求‌。  </li><li>‌<strong>数据输出‌：</strong>处理后的数据可以<strong>输出到多种目标系统</strong>，如<code>Elasticsearch 、Kafka 、邮件通知</code>等。Logstash的输出插件支持将数据发送到各种目标，实现了数据的灵活处理和分发‌。  </li><li><strong>插件机制‌：</strong>提供了丰富的插件机制，用户可以按需安装和使用各种插件，扩展其功能，使其可以灵活适应各种复杂的数据处理场景‌。  </li><li><strong>与 Elasticsearch 和 Kibana 的集成‌：</strong>作为 Elastic Stack 的一部分，Logstash可以与Elasticsearch和Kibana紧密集成，实现日志的搜索、存储和可视化。这使得Logstash在日志管理和分析中具有强大的功能‌。</li></ol><h2 id="Logstash工作原理"><a href="#Logstash工作原理" class="headerlink" title="Logstash工作原理"></a>Logstash工作原理</h2><p>Logstash 的工作原理可以分为三个主要步骤：输入（Input）、过滤（Filter）和输出（Output）。 </p><ol><li><strong>输入（Input）：</strong>采集各种样式、大小和来源的数据。Logstash 支持多种类型的输入数据，包括<strong>日志文件、系统消息队列、数据库</strong>等。Logstash 支持<a href="https://www.elastic.co/cn/guide/en/logstash/current/input-plugins.html">各种输入选择</a>，可同时从众多来源捕捉事件。在配置文件中，你可以指定一个或多个输入源。 本文以<code>beat</code>为例。</li><li><strong>过滤（Filter）：</strong>实时解析和转换数据。 数据从源传输到存储库的过程中，Logstash 过滤器能够解析各个事件，识别已命名的字段以构建结构，并将它们转换成通用格式。Logstash 提供了丰富的<a href="https://www.elastic.co/cn/guide/en/logstash/current/filter-plugins.html">筛选器库</a>和功能多样的 <a href="https://www.elastic.co/cn/blog/introducing-the-elastic-common-schema">Elastic Common Schema</a>。例如：使用 <code>grok</code> 插件来解析非结构化的日志数据，将其转换为结构化的数据。使用 <code>mutate</code> 插件来修改数据，如添加新的字段、删除字段、更改字段的值等。总之，Logstash 能够动态地转换和解析数据，不受格式或复杂度的影响：<ul><li>利用 Grok 从非结构化数据中派生出结构</li><li>从 IP 地址破译出地理坐标</li><li>将 PII 数据匿名化，完全排除敏感字段</li><li>简化整体处理，不受数据源、格式或架构的影响</li></ul></li><li><strong>输出（Output）：</strong>处理后的数据可以被发送到一个或多个目标。Logstash 提供<a href="https://www.elastic.co/cn/guide/en/logstash/current/output-plugins.html">众多输出选择</a>，支持多种类型的输出目标，包括 Elasticsearch、Kafka、邮件通知等，并且能够灵活地解锁众多下游用例。本文以Elasticsearch 为例。</li></ol><p>这三个步骤是在 Logstash 的<strong>事件处理管道中顺序执行</strong>的。每个事件（例如，一行日志数据）都会经过输入、过滤和输出这三个步骤。在过滤阶段，如果一个事件被过滤器丢弃，那么它将不会被发送到输出目标。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250701104045193.png" alt="image-20250701104045193"></p><h2 id="Logstash执行模型"><a href="#Logstash执行模型" class="headerlink" title="Logstash执行模型"></a>Logstash执行模型</h2><p>是的，你的理解是正确的。Logstash 的执行模型主要包括以下几个步骤：</p><ol><li><p> 每个 Input 启动一个线程：Logstash 会为每个输入插件启动一个线程，这些线程并行运行，从各自的数据源获取数据。 </p></li><li><p> 数据写入队列：输入插件获取的数据会被写入一个队列。默认情况下，这是一个存储在内存中的有界队列，如果 Logstash 意外停止，队列中的数据会丢失。为了防止</p></li></ol><p>   数据丢失</p><p>   ，Logstash 提供了两个特性： </p><ul><li> Persistent Queues：这个特性会将队列存储在磁盘上，即使 Logstash 意外停止，队列中的数据也不会丢失。 </li><li> Dead Letter Queues：这个特性会保存无法处理的事件。需要注意的是，这个特性只支持 Elasticsearch 作为输出源。 </li></ul><ol start="3"><li> 多个 Pipeline Worker 处理数据：Logstash 会启动多个 Pipeline Worker，每个 Worker 会从队列中取出一批数据，然后执行过滤器和输出插件。Worker 的数量和每次处理的数据量可以在配置文件中设置。</li></ol><h2 id="Windows下安装启动"><a href="#Windows下安装启动" class="headerlink" title="Windows下安装启动"></a>Windows下安装启动</h2><ol><li><p>最新版本下载链接，以及历史版本的下载链接：<a href="https://www.elastic.co/cn/downloads/past-releases#logstash">Past Releases of Elastic Stack Software | Elastic</a>或者<a href="https://www.elastic.co/cn/downloads/logstash">Download Logstash Free | Get Started Now | Elastic</a>。注意：确保 Logstash 与 Elasticsearch 版本一致。</p></li><li></li><li><p>下载完成后，解压。创建配置文件 <code>my_logstash.conf</code> ，名字自定义，放在“home”下，和<code>logstash</code>解压后形成的bin，config，jdk等目录文件夹同层级，内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">input <span class="punctuation">&#123;</span></span><br><span class="line">    stdin<span class="punctuation">&#123;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span> </span><br><span class="line">output <span class="punctuation">&#123;</span></span><br><span class="line">    stdout<span class="punctuation">&#123;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>启动logstash，启动命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logstash -f my_logstash.conf <span class="comment"># 其中logstash是位于bin目录下的Windows执行文件logstash.bat。</span></span><br></pre></td></tr></table></figure></li><li><p>启动成功，那么就可以在浏览器打开地址 <a href="http://localhost:9600/%EF%BC%8C%E4%BC%9A%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8Dlogstash%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF%E3%80%82">http://localhost:9600/，会返回当前logstash的基础信息。</a></p></li></ol><hr><h1 id="Logstash配置说明"><a href="#Logstash配置说明" class="headerlink" title="Logstash配置说明"></a>Logstash配置说明</h1><h2 id="1、Logstash配置介绍"><a href="#1、Logstash配置介绍" class="headerlink" title="1、Logstash配置介绍"></a>1、Logstash配置介绍</h2><p>Logstash 的配置主要分为两部分：<code>Pipeline 配置文件</code>和 <code>Settings 配置文件</code>。</p><ol><li><strong>Pipeline 配置文件：</strong>这是 Logstash 的<strong>核心配置</strong>，用于定义数据处理的流程，包括输入（input）、过滤（filter）和输出（output）三个部分。每个部分都可以使用多种插件来完成特定的任务。例如，输入部分可以使用 file 插件从文件中读取数据，过滤部分可以使用 grok 插件解析日志，输出部分可以使用 elasticsearch 插件将数据发送到 Elasticsearch。</li><li><strong>Settings 配置文件：</strong>这是 Logstash 的<strong>全局配置</strong>，通常在 <code>logstash.yml</code> 文件中设置。这些配置<strong>包括 Logstash 实例的名称、数据存储路径、配置文件路径、自动重载配置、工作线程数量</strong>等。</li></ol><p>这两部分的配置都是以 YAML 格式编写的，可以使用文本编辑器进行编辑。在 Logstash 启动时，它会首先读取 Settings 配置文件，然后加载并执行 Pipeline 配置文件。</p><h2 id="2、Pipeline配置文件-输入"><a href="#2、Pipeline配置文件-输入" class="headerlink" title="2、Pipeline配置文件-输入"></a>2、Pipeline配置文件-输入</h2><p>在 Pipeline 配置文件中，输入（input）部分定义数据来源。Logstash 提供了多种输入插件，可以从各种数据源读取数据。常用插件：</p><ol><li><p><strong>file：</strong>从文件中读取数据。常用的配置项包括 <code>path</code>（文件路径）和 <code>start_position</code>（开始读取的位置）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">input</span> &#123;</span><br><span class="line">  <span class="string">file</span> &#123;</span><br><span class="line">    <span class="string">path</span> <span class="string">=&gt;</span> <span class="string">&quot;/path/to/your/logfile&quot;</span></span><br><span class="line">    <span class="string">start_position</span> <span class="string">=&gt;</span> <span class="string">&quot;beginning&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>beats：</strong>从 Beats 客户端（如 <code>Filebeat</code>、<code>Metricbeat</code> 等）接收数据。常用的配置项包括 <code>port</code>（监听的端口号）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">input</span> &#123;</span><br><span class="line">  <span class="string">beats</span> &#123;</span><br><span class="line">    <span class="string">port</span> <span class="string">=&gt;</span> <span class="number">5044</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>http：</strong>通过 HTTP 请求接收数据。常用的配置项包括 <code>port</code>（监听的端口号）。</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">input</span> &#123;</span><br><span class="line">  <span class="string">http</span> &#123;</span><br><span class="line">    <span class="string">port</span> <span class="string">=&gt;</span> <span class="number">8080</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>jdbc：</strong>从数据库中读取数据。常用的配置项包括 <code>jdbc_driver_library</code>（JDBC 驱动的路径）、<code>jdbc_driver_class</code>（JDBC 驱动的类名）、<code>jdbc_connection_string</code>（数据库连接字符串）、<code>jdbc_user</code>（数据库用户名）和 <code>jdbc_password</code>（数据库密码）。</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">input</span> &#123;</span><br><span class="line">  <span class="string">jdbc</span> &#123;</span><br><span class="line">    <span class="string">jdbc_driver_library</span> <span class="string">=&gt;</span> <span class="string">&quot;/path/to/your/jdbc/driver&quot;</span></span><br><span class="line">    <span class="string">jdbc_driver_class</span> <span class="string">=&gt;</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">    <span class="string">jdbc_connection_string</span> <span class="string">=&gt;</span> <span class="string">&quot;jdbc:mysql://localhost:3306/yourdatabase&quot;</span></span><br><span class="line">    <span class="string">jdbc_user</span> <span class="string">=&gt;</span> <span class="string">&quot;yourusername&quot;</span></span><br><span class="line">    <span class="string">jdbc_password</span> <span class="string">=&gt;</span> <span class="string">&quot;yourpassword&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>kafka：</strong>在这个配置中，<code>bootstrap_servers</code> 参数指定了 Kafka 服务器的地址和端口，<code>topics</code> 参数指定从哪个主题读取数据。<code>kafka</code> 输入插件还有许多其他的配置项，你可以根据实际需求进行设置。例如，你可以设置 <code>group_id</code> 参数来指定消费者组，设置 <code>auto_offset_reset</code> 参数来指定在没有初始偏移量或当前偏移量不存在时该如何定位消费位置等。具体的配置项和可能的值，你可以在 Logstash 的官方文档中找到。</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">input</span> &#123;</span><br><span class="line">  <span class="string">kafka</span> &#123;</span><br><span class="line">    <span class="string">bootstrap_servers</span> <span class="string">=&gt;</span> <span class="string">&quot;localhost:9092&quot;</span></span><br><span class="line">    <span class="string">topics</span> <span class="string">=&gt;</span> [<span class="string">&quot;your_topic&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：</strong>可以在一个配置文件中定义多个输入，Logstash 会<strong>并行处理所有的输入</strong>。</p><h2 id="3、Pipeline配置文件-过滤"><a href="#3、Pipeline配置文件-过滤" class="headerlink" title="3、Pipeline配置文件-过滤"></a>3、Pipeline配置文件-过滤</h2><p>在 Logstash 的 Pipeline 配置文件中，过滤（filter）部分定义了数据处理的规则。过滤器插件可以对数据进行各种操作，如解析、转换、添加和删除字段等。常用的过滤插件及其操作：</p><ol><li><p>grok：grok 过滤器用于解析非结构化的日志数据，将其转换为结构化的数据。它使用模式匹配的方式来解析文本，每个模式是一个名字和正则表达式的组合。例如，grok 过滤器尝试将 <code>message</code>字段的内容匹配为 <code>COMBINEDAPACHELOG</code> 模式，这是一个预定义的模式，用于解析 Apache 日志，配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filter</span> &#123;</span><br><span class="line">  <span class="string">grok</span> &#123;</span><br><span class="line">    <span class="string">match</span> <span class="string">=&gt;</span> &#123; <span class="string">&quot;message&quot;</span> <span class="string">=&gt;</span> <span class="string">&quot;<span class="template-variable">%&#123;COMBINEDAPACHELOG&#125;</span>&quot;</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mutate：mutate 过滤器用于修改事件数据，如添加新的字段、删除字段、更改字段的值等。例如，mutate 过滤器向每个事件添加一个名为 new_field 的新字段，字段的值为 new_value，配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filter</span> &#123;</span><br><span class="line">  <span class="string">mutate</span> &#123;</span><br><span class="line">    <span class="string">add_field</span> <span class="string">=&gt;</span> &#123; <span class="string">&quot;new_field&quot;</span> <span class="string">=&gt;</span> <span class="string">&quot;new_value&quot;</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>date：date 过滤器用于解析日期和时间信息，将其转换为 Logstash 的 @timestamp 字段。例如，在这个配置中，date 过滤器会尝试将 <code>timestamp</code> 字段的内容匹配为<strong>指定的日期和时间格式</strong>，配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filter</span> &#123;</span><br><span class="line">  <span class="string">date</span> &#123;</span><br><span class="line">    <span class="string">match</span> <span class="string">=&gt;</span> [ <span class="string">&quot;timestamp&quot;</span>, <span class="string">&quot;dd/MMM/yyyy:HH:mm:ss Z&quot;</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：</strong>可以在一个配置文件中定义多个过滤器，Logstash 会<strong>按照配置文件中的顺序依次执行</strong>这些过滤器。</p><h2 id="4、Pipeline配置文件-输出"><a href="#4、Pipeline配置文件-输出" class="headerlink" title="4、Pipeline配置文件-输出"></a>4、Pipeline配置文件-输出</h2><p>在 Logstash 的 Pipeline 配置文件中，输出（output）部分定义了处理后的数据应该发送到哪里。Logstash 提供了多种输出插件，可以将数据发送到各种目标。常用的输出插件：</p><ol><li><p>elasticsearch：将数据发送到 Elasticsearch。常用配置项包括 <code>hosts</code>（Elasticsearch 服务器地址和端口）和 <code>index</code>（索引名称）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">output</span> &#123;</span><br><span class="line">  <span class="string">elasticsearch</span> &#123;</span><br><span class="line">    <span class="string">hosts</span> <span class="string">=&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>]                      <span class="comment"># Elasticsearch 服务器地址和端口</span></span><br><span class="line">    <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">&quot;my-index-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>&quot;</span>               <span class="comment"># 索引名称</span></span><br><span class="line">    <span class="comment"># 枚举了一些其他的配置</span></span><br><span class="line">    <span class="string">user</span> <span class="string">=&gt;</span> <span class="string">&quot;your username&quot;</span>                          <span class="comment"># 用户名</span></span><br><span class="line">    <span class="string">password</span> <span class="string">=&gt;</span> <span class="string">&quot;your password&quot;</span>                   <span class="comment"># 用户密码</span></span><br><span class="line">    <span class="string">manage_template</span> <span class="string">=&gt;</span> <span class="literal">true</span>                        <span class="comment"># Logstash将管理Elasticsearch的模板</span></span><br><span class="line">    <span class="string">template_overwrite</span> <span class="string">=&gt;</span> <span class="literal">true</span>                     <span class="comment"># 模板已存在则覆盖</span></span><br><span class="line">    <span class="string">template</span> <span class="string">=&gt;</span> <span class="string">&quot;/path/to/your/template.json&quot;</span>     <span class="comment"># 参数指向模板文件的路径</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>file：将数据写入到文件。常用的配置项包括 <code>path</code>（文件路径）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">output</span> &#123;</span><br><span class="line">  <span class="string">file</span> &#123;</span><br><span class="line">    <span class="string">path</span> <span class="string">=&gt;</span> <span class="string">&quot;/path/to/your/file&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>stdout：将数据输出到标准输出。常用的配置项包括 <code>codec</code>（编码格式），常用的值有 <code>rubydebug</code>（以 Ruby 的调试格式输出）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">output</span> &#123;</span><br><span class="line">  <span class="string">stdout</span> &#123;</span><br><span class="line">    <span class="string">codec</span> <span class="string">=&gt;</span> <span class="string">rubydebug</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>kafka：将数据发送到 Kafka。常用的配置项包括 <code>bootstrap_servers</code>（Kafka 服务器的地址和端口）和 <code>topic_id</code>（主题名称）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">output</span> &#123;</span><br><span class="line">  <span class="string">kafka</span> &#123;</span><br><span class="line">    <span class="string">bootstrap_servers</span> <span class="string">=&gt;</span> <span class="string">&quot;localhost:9092&quot;</span></span><br><span class="line">    <span class="string">topic_id</span> <span class="string">=&gt;</span> <span class="string">&quot;your_topic&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：</strong>可以在一个配置文件中定义多个输出，Logstash 会<strong>将每个事件发送到所有的输出</strong>。</p><h2 id="5、Settings配置文件"><a href="#5、Settings配置文件" class="headerlink" title="5、Settings配置文件"></a>5、Settings配置文件</h2><p>Logstash 的 Settings 配置文件通常是 <code>logstash.yml</code>，这是 Logstash 的全局配置文件，用于设置 Logstash 运行的一些基本参数。具体的配置项和可能的值，可以在 Logstash 的官方文档中找到。以下列举了一些常见的配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">node.name:</span> <span class="string">test</span>                      <span class="comment"># 设置 Logstash 实例的名称，默认值为当前主机的主机名</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/var/lib/logstash</span>         <span class="comment"># 设置 Logstash 存储持久化数据的路径，默认值为 Logstash 安装目录下的 data 文件夹</span></span><br><span class="line"><span class="attr">path.config:</span> <span class="string">/etc/logstash/conf.d/*.conf</span>             <span class="comment"># 设置 Pipeline 配置文件的路径。</span></span><br><span class="line"><span class="attr">config.reload.automatic:</span> <span class="literal">true</span>         <span class="comment"># true 表示 Logstash 会自动检测 Pipeline 配置文件的更改，并重新加载配置。</span></span><br><span class="line"><span class="attr">pipeline.workers:</span> <span class="number">2</span>                 <span class="comment"># 设置处理事件的工作线程数量，通常设置为机器的 CPU 核心数。</span></span><br><span class="line"><span class="attr">pipeline.batch.size:</span> <span class="number">125</span>             <span class="comment"># 设置每个批处理的事件数量，增大这个值可以提高吞吐量，但也会增加处理延迟。</span></span><br><span class="line"><span class="attr">pipeline.batch.delay:</span> <span class="number">50</span>             <span class="comment"># 设置两个批处理之间的最大等待时间（以毫秒为单位）。</span></span><br></pre></td></tr></table></figure><hr><h1 id="Logstash使用示例"><a href="#Logstash使用示例" class="headerlink" title="Logstash使用示例"></a>Logstash使用示例</h1><h2 id="Logstash-Hello-world"><a href="#Logstash-Hello-world" class="headerlink" title="Logstash Hello world"></a>Logstash Hello world</h2><p>在这个示例中，Logstash 使用标准输入作为输入源，标准输出作为输出目标，且不指定任何过滤器。命令行操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> logstash-8.10.2</span><br><span class="line">bin/logstash -e <span class="string">&#x27;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>参数解析：</p><ul><li><code>-e</code> 参数用于指定 Pipeline 配置</li><li><code>input &#123; stdin &#123; &#125; &#125;</code> 表示使用标准输入作为输入源</li><li><code>output &#123; stdout &#123;&#125; &#125;</code> 表示使用标准输出作为输出目标</li></ul><p> Logstash 启动成功后，在控制台输入一些文本，然后 Logstash 会将这些文本作为事件数据处理。 另外， Logstash 会自动为每个事件添加一些字段，如 <code>@version</code>、<code>host</code> 和 <code>@timestamp</code>，然后将处理后的事件输出到标准输出。 例如，输入 “hello world” ，可能输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018-09-18T12:39:38.514Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="日志格式处理"><a href="#日志格式处理" class="headerlink" title="日志格式处理"></a>日志格式处理</h2><p>日志内容作为一个整体被存放在 message 字段中，对后续存储及查询都极为不便。可以为该 pipeline 指定一个 grok filter 来对日志格式进行处理。在  first-pipeline.conf  中增加 filter 配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">input</span> &#123; <span class="string">stdin</span> &#123; &#125; &#125;</span><br><span class="line"><span class="string">filter</span> &#123;</span><br><span class="line">    <span class="string">grok</span> &#123;</span><br><span class="line">        <span class="string">match</span> <span class="string">=&gt;</span> &#123; <span class="string">&quot;message&quot;</span> <span class="string">=&gt;</span> <span class="string">&quot;<span class="template-variable">%&#123;COMBINEDAPACHELOG&#125;</span>&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">output</span> &#123;</span><br><span class="line">   <span class="string">stdout</span> &#123; <span class="string">codec</span> <span class="string">=&gt;</span> <span class="string">rubydebug</span> &#125; <span class="comment"># 用于美化输出</span></span><br><span class="line">   <span class="string">elasticsearch</span> &#123;               <span class="comment"># Elasticsearch 配置</span></span><br><span class="line">        <span class="string">hosts</span> <span class="string">=&gt;</span> [ <span class="string">&quot;localhost:9200&quot;</span> ]</span><br><span class="line">        <span class="string">topic_id</span> <span class="string">=&gt;</span> <span class="string">&quot;logstash&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要<strong>将数据导入Elasticsearch</strong>，只需要在 pipeline 配置文件中增加 Elasticsearch 的 output 即可</p><ol><li><p>验证配置（注意指定配置文件的路径）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/logstash -f first-pipeline.conf --config.test_and_exit </span><br></pre></td></tr></table></figure></li><li><p>启动命令：其中 <code>--config.reload.automatic</code> 选项启用<strong>动态重载配置</strong>功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/logstash -f first-pipeline.conf --config.reload.automatic </span><br></pre></td></tr></table></figure></li><li><p>预期结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [28/Sep/2021:10:00:00 +0800] <span class="string">&quot;GET /test.html HTTP/1.1&quot;</span> 200 2326 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3&quot;</span></span><br></pre></td></tr></table></figure><p>这条日志记录了<strong>一个 HTTP 请求的信息</strong>，包括<strong>客户端 IP 地址、请求时间、请求方法和 URL、HTTP 版本、响应状态码、响应体的字节数、Referer 和 User-Agent</strong> 等。 我们可以将这个日志作为输入，然后 Logstash 会使用我们的配置来处理这个日志。处理后的结果会被输出到标准输出，格式为 Ruby 的调试格式。</p></li><li><p>查询 Elasticsearch 确认数据是否正常上传：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">&#x27;http://localhost:9200/logstash/_search?pretty&amp;q=response=200&#x27;</span></span><br></pre></td></tr></table></figure><p>如果已经配置了kibana，也可以使用 Kibana 查看：<a href="http://localhost:5601/">http://localhost:5601</a></p></li></ol><h2 id="Logstash的Grok模式"><a href="#Logstash的Grok模式" class="headerlink" title="Logstash的Grok模式"></a>Logstash的Grok模式</h2><p>参考原文链接：<a href="https://zhangphil.blog.csdn.net/article/details/125172132">https://zhangphil.blog.csdn.net/article/details/125172132</a></p><p>从字符串中<strong>匹配并提取中括号关键词后面的数据到指定字段</strong>，如[TASKID:***]格式提取到 <code>task_id</code>。在grok <a href="https://so.csdn.net/so/search?q=debugger&spm=1001.2101.3001.7020">debugger</a>里面运行：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sample Data</span></span><br><span class="line"><span class="punctuation">[</span>DEBUG<span class="punctuation">]</span> <span class="punctuation">[</span>TASKID<span class="punctuation">:</span><span class="number">1</span>a<span class="number">-2</span>b_3c<span class="punctuation">]</span> <span class="punctuation">[</span>DATA<span class="punctuation">]</span></span><br><span class="line"><span class="comment">// Grok Pattern 在grok里面写正则</span></span><br><span class="line">(?&lt;task_id&gt;(?&lt;=\<span class="punctuation">[</span>TASKID<span class="punctuation">:</span>).*?(?=\<span class="punctuation">]</span>))</span><br><span class="line"><span class="comment">// Structure Data  输出的结果</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;task id&quot;</span><span class="punctuation">:</span><span class="string">&quot;1a-2b_3c&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>一些命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">结果都最终存放到result字段:</span><br><span class="line">(?&lt;result&gt;(.*)(?=myend)/?)               提取myend之前的数据</span><br><span class="line">(?&lt;result&gt;(?=mybegin)(.*)/?)               提取mybegin之后的数据</span><br><span class="line">(?&lt;result&gt;(?&lt;=mybegin).*?(?=myend))        提取mybegin和myend之间的数据，不包含mybegin和myend</span><br><span class="line">(?&lt;result&gt;(taga).*?(?=tagb))               提取包含taga但不包含tagb的数据</span><br><span class="line">(?&lt;result&gt;(?&lt;=taga).*?(tagb))              提取内容不包含taga但包含tagb</span><br><span class="line">(?&lt;result&gt;(taga).*?(tagb|tagc))          提取以taga开头,以tagb或tagc结尾的、所有包含头尾的数据</span><br><span class="line">(?&lt;result&gt;(taga).*?(?=(tagb|tagc)))      提取以taga开头,以tagb或tagc结尾的不包含头尾的数据</span><br></pre></td></tr></table></figure><h2 id="Logstash上报数据到ElasticSearch"><a href="#Logstash上报数据到ElasticSearch" class="headerlink" title="Logstash上报数据到ElasticSearch"></a>Logstash上报数据到ElasticSearch</h2><p>安装好logstash和elasticsearch后，配置logstash的启动加载文件中的output部分，指明logstash上报到elasticsearch：</p><p>参考原文链接：<a href="https://zhangphil.blog.csdn.net/article/details/126179168">https://zhangphil.blog.csdn.net/article/details/126179168</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">output <span class="punctuation">&#123;</span></span><br><span class="line">    elasticsearch <span class="punctuation">&#123;</span></span><br><span class="line">        hosts =&gt; <span class="punctuation">[</span><span class="string">&quot;http://localhost:9200&quot;</span><span class="punctuation">]</span></span><br><span class="line">        user =&gt; <span class="string">&quot;your username&quot;</span></span><br><span class="line">        password =&gt; <span class="string">&quot;your password&quot;</span></span><br><span class="line">        index =&gt; <span class="string">&quot;fly-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">        template_overwrite =&gt; <span class="string">&quot;false&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    </span><br><span class="line">    stdout<span class="punctuation">&#123;</span></span><br><span class="line">        codec =&gt; json <span class="punctuation">&#123;</span>                                         </span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ElasticStack Logstash‌</summary>
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="ElasticStack" scheme="https://southernfish.github.io/tags/ElasticStack/"/>
    
  </entry>
  
  <entry>
    <title>ElasticStack</title>
    <link href="https://southernfish.github.io/2025/07/01/server/elasticstack/"/>
    <id>https://southernfish.github.io/2025/07/01/server/elasticstack/</id>
    <published>2025-07-01T00:00:36.000Z</published>
    <updated>2025-07-10T12:47:35.025Z</updated>
    
    <content type="html"><![CDATA[<p>‌Elastic Stack（原ELK Stack）是一套由Elastic公司开发的开源数据搜索、分析和可视化工具集合，核心组件包括Elasticsearch、Kibana、Beats和Logstash‌，广泛应用于日志分析、安全监控、业务智能等领域。‌‌‌‌  参考文章：<a href="https://blog.csdn.net/Tracycoder/article/details/147423614">ElasticSearch深入解析（一）：Elastic Stack全景</a>、<a href="https://blog.csdn.net/shjwkzkzk/article/details/148403336">ElasticStack对接kafka集群</a>，另外推荐文章：<a href="https://blog.csdn.net/xiaogengtongxu/article/details/140462468">ELK日志管理</a>、<a href="https://blog.csdn.net/guguai7/article/details/119720423">强大的ELK日志分析系统</a></p><h1 id="Elastic-Stack"><a href="#Elastic-Stack" class="headerlink" title="Elastic Stack"></a>Elastic Stack</h1><h2 id="核心组件与功能"><a href="#核心组件与功能" class="headerlink" title="核心组件与功能"></a>核心组件与功能</h2><ol><li><code>‌Elasticsearch‌</code>。 <strong>分布式搜索和分析引擎</strong>，基于Lucene构建，支持实时全文检索、结构化查询及复杂数据分析。‌‌<strong>特点：</strong>水平扩展、高可用性，适用于海量数据存储与快速检索。   </li><li> ‌<code>Kibana‌</code>。<strong>界面交互开发工具和管理工具，数据可视化分析利器</strong>。数据可视化平台，提供交互式图表、仪表盘和地图，支持对Elasticsearch数据的实时探索与展示。‌‌‌‌<strong>扩展功能：</strong>集群监控、异常检测及机器学习辅助分析。   </li><li><code>Logstash‌</code>。 <strong>数据采集与处理管道</strong>，支持<strong>多源数据输入</strong>（如日志、数据库）、<strong>过滤转换</strong>（如解析JSON）并<strong>输出</strong>至存储库。‌‌插件生态丰富，可集成MySQL、Kafka等第三方系统。   </li><li><code>Beats‌</code>。 <strong>轻量级数据采集器家族</strong>，包括<code>Filebeat</code>（日志）、<code>Metricbeat</code>（指标）、<code>Packetbeat</code>（网络流量）等。‌‌  </li></ol><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/server/image-20250630165350834.png" alt="image-20250630165350834"></p><h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><p>Logstash与Beats作为底层核心引擎，共同构建了数据摄取平台，实现数据标准化处理，为后续分析奠定基础。其中：</p><ul><li><strong>Logstash的定位与功能：</strong>提供免费开源的服务器端数据处理管道（pipeline），支持从多源数据源采集数据，通过过滤（filter）组件按自定义规则解析事件、提取字段并转换为通用格式，最终将标准化数据输出至Elasticsearch等“存储库”。</li><li><strong>灵活的输出能力：</strong>依托可插拔框架，Logstash支持将数据输出至MySQL、Kafka、Redis等多样化目标，满足业务场景的差异化存储与处理需求。</li><li><strong>插件生态与配置模式：</strong>内置超200个插件（如logstash_input_jdbc、logstash_output_elasticsearch等），通过“输入-过滤-输出”三段式模板灵活配置，适配不同类型数据的处理流程，提升数据集成效率。</li></ul><h3 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h3><p>Beats是免费开源的轻量级数据采集平台，通过集成多种单一功能的数据采集器，实现海量机器与系统的数据向Logstash或Elasticsearch的高效传输，具体特点如下：</p><ul><li><p><strong>核心功能与采集器类型：</strong></p><p>作为数据采集层核心组件，支持从数百/数千台设备<strong>实时采集</strong>数据；包含<strong>多款轻量级采集器</strong>：</p><ul><li><p><code>Filebeat</code>：专注日志文件采集，资源占用低，适合大规模日志场景；</p></li><li><p><code>Metricbeat</code>：实时监控服务器CPU、内存、磁盘等性能指标；</p></li><li><p><code>Packetbeat</code>：捕获网络流量数据，解析协议字段以分析网络性能与安全。</p></li></ul></li><li><p><strong>技术优势：</strong></p><ul><li><strong>可扩展框架：</strong>支持自定义采集器扩展，适配多样化数据源；</li><li><strong>高效采集：</strong>预置采集器经过优化，降低数据采集对系统资源的消耗，提升采集效率。</li></ul></li><li><p><strong>与Elastic Stack的协同价值：</strong><br>Beats与Elasticsearch、Logstash、Kibana共同构成Elastic数据平台四大核心产品，实现：</p><ul><li><p><strong>实时性：</strong>秒级数据采集与传输，满足实时分析需求；</p></li><li><p><strong>相关性：</strong>通过数据标准化与关联分析，挖掘数据间深层联系；</p></li><li><p><strong>扩展性：</strong>支持PB级数据规模，灵活应对业务增长。</p><p>该平台通过全链路数据处理能力，彻底解决企业大数据实时采集、分析与可视化难题，成为数据驱动决策的核心基础设施。</p></li></ul></li></ul><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><ul><li><p>使用简单的RESTful API，<strong>天然兼容多语言开发</strong>。</p></li><li><p><strong>支持水平横向扩展节点</strong>，通过增加节点来实现负载均衡及增强集群可靠性。</p></li><li><p><strong>面向文档</strong>，不使用“表”来存储数据，而使用“文档”来存储数据。</p></li><li><p><strong>无模式</strong>，无须定义好字段类型、长度等，可以直接导入文档数据。</p></li><li><p><strong>近实时存储</strong>，使每个字段都被索引且可用于搜索。</p></li><li><p><strong>响应快</strong>，海量数据下能实现秒级响应速度。</p></li><li><p><strong>易扩展</strong>，支持处理PB级的结构化或非结构化数据。</p></li><li><p><strong>多租户</strong>，支持多个业务共用Elasticsearch服务，并且确保各业务间数据的隔离性。</p></li><li><p><strong>支持多种编程语言</strong>，包含但不限于Java、Python、C#、PHP、Python、Ruby等。</p></li></ul><h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><p>Kibana是一款免费开源的工具，作为Elastic Stack的核心用户界面，主要功能：</p><ul><li><strong>数据可视化分析：</strong>支持将Elasticsearch中的数据转化为折线图、仪表盘、地理地图等<strong>多样化可视化图表</strong>，用户可通过简单拖拽操作自定义多维度数据报表，快速洞察数据趋势与关联。</li><li><strong>开发与运维支持：</strong>集成<strong>界面交互开发工具与管理工具</strong>，辅助技术人员完成<strong>查询调试、索引管理、权限配置</strong>等操作，简化开发流程并提升运维效率。</li><li><strong>集群监控与异常检测：</strong><ul><li>作为可视化安全监控平台，<strong>实时展示</strong>Elasticsearch集群的<strong>CPU、内存、索引状态</strong>等关键运维指标，提供<strong>实时运行状态看板与历史趋势曲线</strong>，帮助用户提前发现潜在风险。</li><li><strong>内置机器学习功能，自动检测数据中的异常模式</strong>（如指标突变、异常流量），追溯异常来源，实现智能化故障预警与根因分析。</li></ul></li></ul><h2 id="ELK的工作原理"><a href="#ELK的工作原理" class="headerlink" title="ELK的工作原理"></a>ELK的工作原理</h2><ol><li>在<strong>所有需要收集日志的服务器上部署</strong><code>Logstash</code>；或者先将日志进行<strong>集中化管理</strong>在日志服务器上，在日志服务器上部署 Logstash。</li><li>Logstash 收集日志（input），将日志格式化（filter）并输出（out）到 Elasticsearch 群集中。</li><li>Elasticsearch 对格式化后的数据进行<strong>索引和存储</strong>。</li><li>Kibana 从 ES 群集中<strong>查询数据生成图表</strong>，并进行前端数据的<strong>展示</strong>。</li></ol><p>总结：logstash作为日志搜集器，从数据源采集数据，并对数据进行过滤，格式化处理，然后交由Elasticsearch存储，kibana对日志进行可视化处理。</p><h2 id="典型应用场景‌"><a href="#典型应用场景‌" class="headerlink" title="典型应用场景‌"></a>典型应用场景‌</h2><p>来源于百度的应用场景分类：</p><ul><li>日志管理‌：集中采集服务器日志，实时分析异常（如网络安全事件）。‌‌</li><li>业务分析‌：电商搜索优化、用户行为分析等。‌‌</li><li>安全监控‌：构建实时威胁检测平台，识别异常登录或攻击行为</li></ul><p>Elastic Stack在<strong>全文检索、产品检索、JSON文档存储、数据聚合、坐标与地理位置检索、指标统计和分析、自动补全、自动推荐、安全分析</strong>等领域都有广泛的应用。可分为全文检索、日志分析、商业智能 3 类<strong>核心应用场景</strong>：</p><ol><li><strong>全文检索场景</strong></li><li>覆盖多场景：支持电商（淘宝/京东）、应用市场（360手机助手）、文档平台（腾讯文档）等搜索需求。</li><li>技术优势：提供自定义打分/排序、高亮显示，通过跨机房容灾实现高可用、低延迟。</li><li>企业实践：阿里巴巴、腾讯、携程等头部企业将其作为核心技术，提升用户体验与业务效率。</li></ol><ol start="2"><li><strong>日志分析场景</strong>。Elasticsearch支持多类型日志处理：</li><li>日志类型：涵盖业务日志（用户行为）、状态日志（慢查询）、系统日志（多等级）。</li><li>技术优势：基于倒排索引实现秒级日志索引与检索，满足实时分析需求。</li><li>企业应用：58集团、唯品会、国投瑞银等用于日志分析、监控与故障排查。</li></ol><ol start="3"><li><strong>商业智能场景</strong><br> 电子商务、移动App开发、广告媒体等领域的企业面临大型业务数据收集与分析的巨大挑战。</li></ol><ul><li><p><strong>Elasticsearch的核心能力：</strong></p><ul><li>具备结构化查询功能，可实现全文数据检索和聚合分析；</li><li>高效处理大数据，支持个性化分析，助力企业发现问题、辅助业务决策并挖掘商业价值。</li></ul></li><li><p><strong>典型商业智能应用场景：</strong></p><ul><li>睿思BI、百度数据可视化Sugar BI、永洪BI等商业智能系统，均借助Elasticsearch高效、实时的数据分析和可视化能力；</li><li>帮助企业理解市场趋势、优化决策过程，提升数据驱动的商业价值。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">ElasticStack</summary>
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="ElasticStack" scheme="https://southernfish.github.io/tags/ElasticStack/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构</title>
    <link href="https://southernfish.github.io/2025/07/01/server/distributed-architecture/"/>
    <id>https://southernfish.github.io/2025/07/01/server/distributed-architecture/</id>
    <published>2025-07-01T00:00:36.000Z</published>
    <updated>2025-07-10T12:47:35.025Z</updated>
    
    <content type="html"><![CDATA[<p>分布式架构（Distributed Architecture）是分布式计算技术的应用和工具，成熟的技术包括 J2EE, CORBA 和 .NET(DCOM) ，其中<code>J2EE</code>技术应用较为广泛，它简化和规范多层分布式企业应用系统的开发和部署，它可以给分布式应用软件提供在各种技术间共享资源的平台。本文参考文章：<a href="https://cloud.tencent.com/developer/article/1675926">一文读懂分布式架构</a>、</p><h1 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>分布式架构是指<strong>将一个大型系统分解成多个独立的子系统</strong>，并将这些子系统分布在不同的计算机节点上，通过网络协议相互通信，形成一个整体的系统。这种架构风格可以提高系统的可扩展性、可靠性和可用性。</p><p><strong>常见的分布式架构：</strong>SOA（面向服务的架构）、RPC（远程过程调用）、消息队列、分布式缓存等。</p><p><strong>分布式架构应用场景：</strong>适用于 <strong>对数据密集/实时要求比较高</strong>、<strong>对服务器高可用运用指数较高</strong>、<strong>大型业务复杂/统计类</strong>的系统，总的来说分布式架构适合处理大数据量、高并发和高可用性的场景，比如<strong>电商、社交网络、金融交易</strong>等。</p><h2 id="分布式架构设计理念和目标"><a href="#分布式架构设计理念和目标" class="headerlink" title="分布式架构设计理念和目标"></a><strong>分布式架构设计理念</strong>和目标</h2><p>分布式架构的核心理念：<strong>按照一定维度（功能、业务、领域）等，对系统进行拆分</strong>，通过合理的拆分结构，实现各<strong>业务模块解耦</strong>，同时通过<strong>系统级容错设计</strong>，在廉价硬件基础设施上构建起高可用、可扩展的开放技术体系。</p><p>分布式架构的设计目标分为以下方面：</p><ul><li><strong>系统拆分</strong><ul><li>以业务为导向按不同层面的业务模型上可划分为主模型、次模型。业务模型在一定的比例上能够凸显出系统的业务领域及边界</li><li>业务依赖范围，由于业务存在重复依赖，从业务边界中按照业务功能去细分</li><li>把拆分结构图梳理出来，按照系统周边影响从小到大逐渐切换</li><li>拆分过程中尽量不要引入新的技术或者方案，如需讨论评估后再实施</li></ul></li><li><strong>业务模块解耦</strong><ul><li>拆分前模块和模块间、系统和系统间可能存在强依赖，在拆分过程中需思考哪些模块需要减少依赖。依赖越少，独立性越强。</li></ul></li><li><strong>系统容错</strong><ul><li><strong>架构设计层面：</strong>重试、服务降级、熔断和限流</li><li><strong>业务功能层面：</strong>幂等、异步处理、事务补偿机制</li></ul></li><li><strong>高可用</strong><ul><li>尽量避免系统的单点出现，保证系统处于多机状态，俗称冗余。<strong>冗余</strong>指重复配置系统某些部件，当系统发生故障，冗余配置的部件介入并承担故障部件的工作，减少系统的故障时间</li><li>通过设计和监控可以提高系统正常提供服务的可靠性，但如何才能保障系统的高可用</li></ul></li></ul><h2 id="分布式架构和微服务架构的区别"><a href="#分布式架构和微服务架构的区别" class="headerlink" title="分布式架构和微服务架构的区别"></a>分布式架构和微服务架构的区别</h2><p>微服务架构： 微服务架构是一种基于分布式架构的新型软件架构风格，它将一个大型系统拆分成多个小型、轻量级的服务，每个服务都可以独立部署、扩展和维护。不同服务之间通过API通信，可以采用不同编程语言和技术栈实现。微服务架构的特点是灵活性高、可扩展性好、维护成本低、快速迭代和部署。微服务架构适合处理快速变化、多样化的业务需求，如在线教育、物联网、大数据分析等。</p><p>分布式架构和微服务架构都是用于构建大型复杂系统的架构风格，它们之间有一些<strong>本质区别</strong>，主要体现在以下方面：</p><ol><li><strong>服务粒度不同：</strong>分布式架构通常采用较粗粒度的服务，每个服务可能包含多个功能。而微服务架构则采用<strong>更细粒度的服务</strong>，每个服务只提供一项或几项特定的功能。这种差异导致了微服务架构更加灵活，可以更方便地扩展和替换服务</li><li><strong>通信机制不同：</strong>分布式架构通常使用<strong>RPC（远程过程调用）或消息队列来实现服务之间的通信</strong>，而微服务架构则更多地采用<strong>HTTP和RESTful API来实现服务之间的通信</strong>。这种差异导致了微服务架构具有更好的跨语言和跨平台的兼容性。</li><li><strong>数据一致性处理不同：</strong>在分布式架构中，数据可能分布在不同的服务中，因此需要采用特殊的协调机制来确保数据一致性，如<strong>分布式事务</strong>。而在微服务架构中，每个服务只负责自己的一部分数据，因此可以采用<strong>更简单的数据一致性处理机制</strong>，如<strong>最终一致性</strong>。</li><li><strong>架构管理方式不同：</strong>在分布式架构中，通常需要对整个架构进行统一管理和部署，因此需要<strong>采用中心化的管理方式</strong>。而在微服务架构中，每个服务可以独立部署、管理和扩展，因此更适合<strong>采用去中心化的管理方式</strong>。</li></ol><hr><h1 id="分布式架构解决痛点"><a href="#分布式架构解决痛点" class="headerlink" title="分布式架构解决痛点"></a>分布式架构解决痛点</h1><h2 id="系统宕机"><a href="#系统宕机" class="headerlink" title="系统宕机"></a><strong>系统宕机</strong></h2><ul><li>业务量增多，系统压力增大，通过监控和各方面指标发现系统频繁报警，通过优化让系统变稳定，降低负载。<em>最直接的方式</em>是增加系统容量，调整系统参数，但是通过<strong>硬件扩展</strong>存在<strong>硬件设备费用高额且后续的维护代价更大</strong>等弊端。<em>进一步优化过程</em>需要<strong>垂直或者水平拆分业务系统</strong>，按照一定维度拆分成多个模块，降低耦合性，通过合理的设计方案，从端到端、点到点优化，让系统变得健壮，为后续复杂业务提供模块化管理和运营。 </li><li>分布式架构体系具有良好的横向扩展性，通过横向扩展机器能够快速高效提高系统的并发量和吞吐量，为复杂的业务系统提供良好支撑。而分布式架构体系调用过程较长，从外界流量入口分发、代理服务、网络传输、容器、应用服务、数据存储，存在很高的优化空间，通过合理的设计方案能让系统承载更多更高的指标，从而稳定运行</li></ul><h2 id="系统瘫痪"><a href="#系统瘫痪" class="headerlink" title="系统瘫痪"></a><strong>系统瘫痪</strong></h2><ul><li><strong>机房停电、线路关闭、网络堵塞</strong>等外部因素会导致系统瘫痪。分布式架构体系中针对以上场景有很多解决方案，系统设计初考虑<strong>高可用、监控、故障转移</strong>等，确保系统高可用。</li><li><strong>多机房部署</strong>能从根源上解决由机房停电引起的事故。</li></ul><h2 id="系统故障"><a href="#系统故障" class="headerlink" title="系统故障"></a><strong>系统故障</strong></h2><p>分布式架构中讲究系统拆分模块化，使用更轻量级的模块、可用的部署策略，从一定程度上规避掉故障风险，如出现故障，通过<strong>有效的故障转移方式</strong>能让系统在短时间之内正常服务</p><h2 id="系统臃肿"><a href="#系统臃肿" class="headerlink" title="系统臃肿"></a><strong>系统臃肿</strong></h2><p>拆分模块化，模块细化后可读性、维护性会变得简单明了，针对细化后的模块可更专注开发和优化，系统庞大内核聚集多，导致臃肿。迭代维护运营成本高额，风险过大。</p><hr><h1 id="分布式架构的核心技术"><a href="#分布式架构的核心技术" class="headerlink" title="分布式架构的核心技术"></a>分布式架构的核心技术</h1><p>涵盖通信、数据管理、服务治理及容错机制。</p><h2 id="核心通信技术"><a href="#核心通信技术" class="headerlink" title="核心通信技术"></a>核心通信技术</h2><ol><li><strong>RPC框架</strong><br>基于代理机制实现跨节点透明调用，需结合<strong>序列化</strong>（<code>Protobuf</code>/<code>JSON</code>）、<strong>网络传输</strong>（<code>Netty</code>/<code>gRPC</code>）及<strong>服务发现</strong>（<code>Nacos</code>/<code>ZooKeeper</code>）。典型框架如<code>Dubbo</code>、<code>gRPC67</code>。  </li><li><strong>消息中间件</strong><br>通过异步解耦提升系统扩展性，支持发布-订阅（<code>Kafka</code>/<code>RabbitMQ</code>）和事务消息（<code>RocketMQ</code>），确保最终一致性‌</li></ol><h2 id="分布式数据管理"><a href="#分布式数据管理" class="headerlink" title="分布式数据管理"></a>分布式数据管理</h2><ol><li><p><strong>数据库分库分表</strong><br><strong>分库分表：</strong>按哈希/范围拆分数据至多节点（如<code>ShardingSphere</code>）<br><strong>多副本同步：</strong>基于<code>Raft</code>/<code>Paxos</code>协议保证数据强一致性（<code>ETCD</code>/<code>Consul</code>）。   </p></li><li><p><strong>新型存储架构</strong><br><strong>计算存储分离：</strong>如华为<code>GaussDB</code>，支持线性扩展与高并发查询<br><strong>多模数据库：</strong>整合<code>KV</code>、文档等模型，适应异构数据场景（<code>MongoDB</code>/<code>Cassandra</code>）</p></li></ol><h2 id="服务治理与协同"><a href="#服务治理与协同" class="headerlink" title="服务治理与协同"></a>服务治理与协同</h2><ol><li><p><strong>服务发现与负载均衡</strong><br> 注册中心（<code>Eureka</code>/<code>ZooKeeper</code>）动态管理节点，配合轮询/一致性哈希算法分发请求。 </p></li><li><p><strong>配置中心与链路追踪</strong><br> 集中化管理配置（<code>Spring Cloud Config</code>）</p><p> 分布式追踪（<code>SkyWalking</code>）定位跨服务延迟   </p></li></ol><h2 id="容错与高可用设计"><a href="#容错与高可用设计" class="headerlink" title="容错与高可用设计"></a>容错与高可用设计</h2><ol><li>   <strong>熔断与降级</strong><br>断路器模式（<code>Hystrix</code>/<code>Sentinel</code>）快速阻断故障服务，防止级联崩溃。  </li><li><strong>容灾与备份</strong><br>跨机房异地多活； 定期快照+日志回放（<code>Redis AOF</code>）</li></ol><h2 id="一致性保障协议"><a href="#一致性保障协议" class="headerlink" title="一致性保障协议"></a>一致性保障协议</h2><ul><li>强一致性：<code>Paxos</code>/<code>Raft</code>协议保证写操作原子性（<code>ZooKeeper</code>）</li><li>最终一致性：基于消息队列（<code>Kafka</code>）或版本向量（<code>Cassandra</code>）</li></ul><hr><h1 id="分布式架构的设计原则"><a href="#分布式架构的设计原则" class="headerlink" title="分布式架构的设计原则"></a>分布式架构的设计原则</h1><h2 id="核心设计原则"><a href="#核心设计原则" class="headerlink" title="核心设计原则"></a>核心设计原则</h2><ol><li><p><strong>CAP理论的取舍</strong></p><ul><li><p><strong>分区容错性（P）必选：</strong>网络故障不可避免，系统需保证分区发生时仍能运行。</p></li><li><p><strong>一致性（C）与可用性（A）的权衡：</strong></p><ul><li>金融系统优先CP（如<code>ZooKeeper</code>通过<code>Raft</code>协议保证强一致性）</li><li>电商等高并发场景倾向AP（如Redis允许短暂数据不一致，确保服务可用）</li></ul></li></ul></li><li><p><strong>无状态服务设计</strong></p><ul><li><p><strong>会话信息外置：</strong>用户状态存储于<code>Redis</code>等<strong>分布式缓存</strong>，而非服务节点本地，避免单点故障并支持水平扩展。</p></li><li><p><strong>请求自包含性：</strong>每次请求携带完整上下文(如<code>JWT令牌</code>)，不依赖服务端历史记录。</p><ul><li><strong>优势：</strong>简化扩容、提升容错性</li><li><strong>代价：</strong>需额外传输数据，可通过CDN缓存优化</li></ul></li></ul></li></ol><h2 id="扩展性与可维护性原则"><a href="#扩展性与可维护性原则" class="headerlink" title="扩展性与可维护性原则"></a>扩展性与可维护性原则</h2><ol><li><p><strong>服务拆分与解耦</strong></p><ul><li><p><strong>业务维度拆分：</strong>按功能划分微服务（如订单、支付服务），降低耦合度</p></li><li><p><strong>异步通信机制：</strong>消息队列（<code>Kafka</code>/<code>RocketMQ</code>）解耦服务，确保最终一致性（如订单创建后异步扣减库存）</p></li></ul></li><li><p><strong>自动化运维支持</strong></p><ul><li><p><strong>配置中心同一管理：</strong><code>Nacos</code>动态更新配置，避免服务重启动</p></li><li><p><strong>容器化部署：</strong><code>Kubernetes</code>实现自动扩缩容，应对流量波动</p></li></ul></li></ol><h2 id="高可用与容错设计"><a href="#高可用与容错设计" class="headerlink" title="高可用与容错设计"></a>高可用与容错设计</h2><ol><li><p><strong>冗余与故障转移</strong></p><ul><li><p><strong>多副本部署：</strong>数据库主从复制（<code>MySQL</code>）或分布式存储多副本（<code>HDFS</code>），主节点故障时自动切换</p></li><li><p><strong>熔断降级机制：</strong><code>Sentinel</code>/<code>Hystrix</code>在服务超时或异常时快速熔断，避免雪崩效应</p></li></ul></li><li><p><strong>容灾与数据恢复</strong></p><ul><li><p><strong>异地多活架构：</strong>跨机房部署，单机房故障不影响全局服务</p></li><li><p><strong>日志快照备份：</strong><code>Redis AOF</code>日志、数据库<code>Binlog</code>保障故障后数据可恢复</p></li></ul></li></ol><h2 id="实施要点与业务适配"><a href="#实施要点与业务适配" class="headerlink" title="实施要点与业务适配"></a>实施要点与业务适配</h2><table><thead><tr><th>场景</th><th>技术选型</th><th>典型案例</th></tr></thead><tbody><tr><td>强一致性需求</td><td>CP模式（Paxos/Raft协议）</td><td>银行转账系统</td></tr><tr><td>高并发读场景</td><td>AP模式+缓存（Redis）</td><td>电商商品查询</td></tr><tr><td>长事务业务流程</td><td>有状态服务+会话保持</td><td>支付流程</td></tr></tbody></table><p><strong>设计本质是业务与技术的平衡：</strong>金融系统牺牲可用性（<code>CP</code>）保数据强一致，社交平台则容忍延迟（<code>AP</code>）保用户体验。运维需结合监控（如<code>SkyWalking</code>）和自动化工具，持续优化架构韧性</p><hr><h1 id="如何选择适合的分布式架构方案"><a href="#如何选择适合的分布式架构方案" class="headerlink" title="如何选择适合的分布式架构方案"></a>如何选择适合的分布式架构方案</h1><p>选择适合的分布式架构方案需结合业务场景、数据特性及运维成本综合决策，以下是关键权衡维度和选型策略：</p><h2 id="业务需求驱动选型"><a href="#业务需求驱动选型" class="headerlink" title="业务需求驱动选型"></a>业务需求驱动选型</h2><ol><li><p>一致性要求</p><ul><li><p><strong>强一致性场景（如金融交易）：</strong>采用CP架构（如<code>ZooKeeper Raft协议</code>），确保数据准确但牺牲部分可用性。</p></li><li><p><strong>最终一致性场景（如社交动态）：</strong>选择AP架构（如<code>Redis缓存+Kafka异步同步</code>），优先保障服务可用性。  </p></li></ul></li><li><p>流量特征</p><ul><li><p><strong>高并发读场景：</strong>引入读写分离（<code>MySQL主从</code>） + 缓存（<code>Redis集群</code>），缓解数据库压力。</p></li><li><p><strong>高并发写场景：</strong>使用分库分表（<code>ShardingSphere</code>） + 消息队列削峰（<code>RocketMQ</code>）。</p></li></ul></li></ol><h2 id="技术维度评估"><a href="#技术维度评估" class="headerlink" title="技术维度评估"></a>技术维度评估</h2><ol><li><p><strong>数据规模与类型</strong></p><ul><li><p><strong>海量结构化数据：</strong>分布式数据库（如<code>GaussDB</code>分片存储 + 计算存储分离架构）。</p></li><li><p><strong>半结构化/时序数据：</strong>多模数据库（如<code>Cassandra</code>）或时序数据库（<code>InfluxDB</code>）。</p></li></ul></li><li><p><strong>服务治理复杂度</strong></p><ul><li><p><strong>微服务交互频繁：</strong>集成服务网格（<code>Istio</code>）实现流量控制、熔断降级。</p></li><li><p><strong>配置动态更新需求：</strong>采用配置中心（<code>Nacos</code>）替代静态配置文件。</p></li></ul></li></ol><h2 id="运维与成本考量"><a href="#运维与成本考量" class="headerlink" title="运维与成本考量"></a>运维与成本考量</h2><ol><li><p><strong>团队技术栈</strong></p><ul><li><p>Java技术栈优先<code>Spring Cloud Alibaba</code>生态（<code>Nacos+Sentinel+RocketMQ</code>）。</p></li><li><p>云原生团队选择<code>Kubernetes + Service Mesh</code>，简化容器编排和治理。</p></li></ul></li><li><p><strong>灾备与弹性</strong></p><ul><li><p><strong>金融/政务系统：</strong>异地多活架构（如单元化部署），容忍机房级故障。 </p></li><li><p><strong>普通电商：</strong>同城双活 + 自动扩缩容（<code>K8s HPA</code>），平衡成本与可用性。</p></li></ul></li></ol><h2 id="典型场景方案参考"><a href="#典型场景方案参考" class="headerlink" title="典型场景方案参考"></a>典型场景方案参考</h2><table><thead><tr><th>场景</th><th>推荐方案</th><th>核心技术组件</th></tr></thead><tbody><tr><td>支付交易（强一致）</td><td>CP模式 + TCC事务</td><td>Seata + Raft协议</td></tr><tr><td>商品秒杀（高并发）</td><td>无状态服务 + Redis分布式锁</td><td>Redis + 限流熔断（Sentinel）</td></tr><tr><td>实时日志分析</td><td>流处理架构</td><td>Kafka + Flink</td></tr></tbody></table><p><strong>决策漏斗：</strong></p><ol><li>明确业务核心指标（一致性/延迟/吞吐）</li><li>评估数据规模与增长趋势</li><li> 选择匹配团队能力的运维框架</li><li>通过POC验证性能瓶颈（如压测熔断阈值、分片扩容效率）</li></ol><hr><h1 id="分布式架构中常见的问题"><a href="#分布式架构中常见的问题" class="headerlink" title="分布式架构中常见的问题"></a>分布式架构中常见的问题</h1><h2 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h2><ol><li><p><strong>CAP理论下的矛盾</strong></p><ul><li><p><strong>强一致性（CP）场景：</strong>如金融交易系统需保证数据绝对一致，采用Raft/Paxos协议（如ZooKeeper），但网络分区时可能牺牲可用性。</p></li><li><p><strong>最终一致性（AP）场景：</strong>如社交动态更新，通过消息队列（<code>Kafka</code>）异步同步，容忍短暂不一致以保障服务可用性。</p></li></ul></li><li><p><strong>分布式事务实现难点</strong></p><ul><li><p><strong>跨服务事务</strong>：采用补偿机制（<code>Saga模式</code>）或TCC（<code>Try-Confirm-Cancel</code>）分段提交，避免长事务阻塞（如<code>Seata框架</code>）。</p></li><li><p><strong>并发冲突</strong>：结合版本向量（<code>Cassandra</code>）或乐观锁（<code>Redis WATCH</code>）解决数据冲突。</p></li></ul></li></ol><h2 id="系统可用性风险"><a href="#系统可用性风险" class="headerlink" title="系统可用性风险"></a>系统可用性风险</h2><ol><li><p><strong>服务雪崩效应</strong></p><ul><li><p><strong>触发场景</strong>：单个服务故障引发调用链连锁崩溃（如库存服务超时导致订单服务线程阻塞）</p></li><li><p><strong>防护策略：</strong></p><ul><li><p><strong>熔断降级</strong>：<code>Sentinel</code>/<code>Hystrix</code>快速隔离故障节点，设置请求國值（如<code>QPS&gt;1000</code>时熔断）</p></li><li><p><strong>服务冗余</strong>：关键服务多副本部署（<code>Kubernetes</code>自动扩缩容）。</p></li></ul></li></ul></li><li><p><strong>资源瓶颈与性能下降</strong></p><ul><li><p><strong>连接耗尽：</strong><code>Dubbo</code>等<code>RPC框架</code>长连接过多导致网络堵塞，需优化线程池配置（如动态调整最大连接数）</p></li><li><p><strong>高并发写压力：</strong>分库分表（<code>ShardingSphere</code>）+消息队列削峰（<code>RocketMQ</code>事务消息）</p></li></ul></li></ol><h2 id="运维与设计复杂度"><a href="#运维与设计复杂度" class="headerlink" title="运维与设计复杂度"></a>运维与设计复杂度</h2><ol><li><p><strong>分布式追踪困难</strong></p><ul><li><p><strong>跨服务调用链：</strong>链路追踪工具（<code>SkyWalking</code>）定位延迟节点，结合日志聚合（<code>ELK</code>）分析根因。</p></li><li><p><strong>配置管理失效：</strong>配置中心（<code>Nacos</code>）动态更新参数，避免服务重启引发配置不一致。</p></li></ul></li><li><p><strong>存储架构挑战</strong></p><table><thead><tr><th>问题类型</th><th>案例</th><th>解决方案</th></tr></thead><tbody><tr><td>分片数据倾斜</td><td>按用户ID分片导致热点账户</td><td>分片键优化（如组合键）</td></tr><tr><td>多副本同步延迟</td><td>从库读操作获取旧数据</td><td>读写分离+缓存过期策略</td></tr></tbody></table></li></ol><h2 id="安全与容灾缺陷"><a href="#安全与容灾缺陷" class="headerlink" title="安全与容灾缺陷"></a>安全与容灾缺陷</h2><ol><li><p><strong>数据安全风险</strong></p><ul><li><p><strong>泄露隐患</strong>：分布式存储节点分散，需加密传输（<code>TLS</code>）及存储（<code>AES-256</code>）;</p></li><li><p><strong>权限控制漏洞</strong>：<code>RBAC</code>模型（基于角色访问控制）限制未授权操作。</p></li></ul></li><li><p><strong>容灾能力不足</strong></p><ul><li><strong>单机房故障</strong>：异地多活架构（如单元化部署），流量自动切换至备用机房</li><li><strong>数据恢复延迟</strong>：定期快照（<code>Redis RDB</code>）+实时日志回放（<code>AOF</code>）。</li></ul></li></ol><h2 id="关键解决框架总结"><a href="#关键解决框架总结" class="headerlink" title="关键解决框架总结"></a>关键解决框架总结</h2><p><strong>一致性</strong>：CP强一致选Raft，AP场景用消息队列最终一致<br><strong>可用性</strong>：熔断限流防雪崩，容器化部署保冗余<br><strong>可维护性</strong>：链路追踪定位故障，配置中心统一管理<br><strong>注意</strong>：问题优先级需结合业务场景——金融系统优先解决数据一致性与安全性，电商平台重点保障高并发可用性。</p><hr><h1 id="分布式架构中常见的网络问题"><a href="#分布式架构中常见的网络问题" class="headerlink" title="分布式架构中常见的网络问题"></a>分布式架构中常见的网络问题</h1><h2 id="网络通信故障"><a href="#网络通信故障" class="headerlink" title="网络通信故障"></a>网络通信故障</h2><ol><li><p><strong>网络延迟与抖动</strong></p><ul><li><p><strong>问题</strong>：跨机房调用因物理距离或拥塞导致延迟波动（如数据库同步延迟超500ms）。</p></li><li><p><strong>解决</strong>：</p><ul><li>超时重试机制（如Dubbo默认1秒超时 + 指数退避重试）</li><li>就近部署<code>CDN</code>节点减少传输距离。</li></ul></li></ul></li><li><p><strong>网络分区</strong>（<code>Network Partition</code>）</p><ul><li>问题：交换机故障导致集群分裂为孤立子网，数据无法同步</li><li>容错设计：<ul><li>心跳检测：<code>ZooKeeper</code>通过ZAB协议实时探测节点存活</li><li>自动切换：<code>Redis Sentinel</code>主节点失联后触发故障转移。</li></ul></li></ul></li></ol><h2 id="服务协调失效"><a href="#服务协调失效" class="headerlink" title="服务协调失效"></a>服务协调失效</h2><ol><li><p><strong>脑裂问题</strong>（<code>Split Brain</code>）</p><ul><li><p><strong>场景</strong>：主节点集群因网络分区产生多个“主节点”，同时写入导致数据冲突（如HDFS NameNode双主）</p></li><li><p><strong>防护</strong>：</p><ul><li><p>仲裁机制：<code>Etcd</code>使用Raft协议要求多数节点确认主节点</p></li><li><p><code>Fencing</code>隔离：物理断电异常节点（如<code>Kuberetes Node Controller</code>）。</p></li></ul></li></ul></li><li><p><strong>服务发现失效</strong></p><ul><li><strong>案例</strong>：注册中心（如Nacos）宕机导致新节点无法加入集群。</li><li><strong>高可用设计</strong>：<ul><li>注册中心多副本部署 + 本地缓存服务列表（<code>Eureka Client</code>缓存机制）</li><li>健康检查主动剔除异常节点</li></ul></li></ul></li></ol><h2 id="传输可靠性问题"><a href="#传输可靠性问题" class="headerlink" title="传输可靠性问题"></a>传输可靠性问题</h2><ol><li><p><strong>数据包丢失与乱序</strong></p><ul><li><p><strong>影响</strong>：UDP协议传输监控数据时丢包导致统计误差。</p></li><li><p><strong>保障</strong>：</p><ul><li><p>TCP协议保证有序交付（牺牲部分实时性）</p></li><li><p>应用层重传校验（如<code>Kafka Producer</code>的<code>acks=all</code>确保消息不丢失）</p></li></ul></li></ul></li><li><p><strong>连接资源耗尽</strong></p><ul><li><p><strong>瓶颈</strong>：RPC框架（如<code>gRPC</code>）长连接数超过操作系统限制（Linux默认1024）</p></li><li><p><strong>优化</strong>：</p><ul><li><p>连接池复用（减少三次握手开销）</p></li><li><p>异步NIO模型（<code>Netty</code>单机支持10万连接）</p></li></ul></li></ul></li></ol><h2 id="安全与性能陷阱"><a href="#安全与性能陷阱" class="headerlink" title="安全与性能陷阱"></a>安全与性能陷阱</h2><table><thead><tr><th>问题类型</th><th>风险案例</th><th>解决方案</th></tr></thead><tbody><tr><td>中间人攻击</td><td>未加密通信导致数据篡改（如支付请求）</td><td>TLS双向认证+传输加密</td></tr><tr><td>带宽瓶颈</td><td>日志批量同步压垮千兆网卡</td><td>压缩传输（Snappy算法）+限流</td></tr></tbody></table><p><strong>关键实践：</strong><br><strong>网络诊断工具</strong>：<code>traceroute</code> 定位延识节点，<code>netstat</code> 检查连接状态<br><strong>混沌工程</strong>：模拟网络分区（如<code>Chaos Mesh</code>注入延迟）验证系统韧性</p><h2 id="总结建议"><a href="#总结建议" class="headerlink" title="总结建议"></a>总结建议</h2><p>分布式网络问题的本质是不可靠传输与复杂交互的叠加，需分层应对：</p><ol><li><strong>基础设施层</strong>：冗余网络链路（双交换机）+智能路由（BGP多线接入）</li><li><strong>协议层</strong>：根据场景选型（强一致用TCP，实时音选用QUIC）</li><li><strong>应用层</strong>：熔断降级（Sentinel）+ 重试补偿（SpringRetry）</li></ol><p><strong>注意：</strong>网络问题需结合业务容忍度设计——电商订单支付需强网络保障，而离线日志同步可接受延迟</p>]]></content>
    
    
    <summary type="html">Distributed Architecture</summary>
    
    
    
    <category term="Distributed Architecture" scheme="https://southernfish.github.io/categories/Distributed-Architecture/"/>
    
    
    <category term="system" scheme="https://southernfish.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>AWS LLM</title>
    <link href="https://southernfish.github.io/2025/06/27/large-model/aws-llm/"/>
    <id>https://southernfish.github.io/2025/06/27/large-model/aws-llm/</id>
    <published>2025-06-27T06:31:36.000Z</published>
    <updated>2025-07-10T12:47:35.024Z</updated>
    
    <content type="html"><![CDATA[<p>‌ AWS LLM算法模型是指利用大量数据进行预训练的超大型深度学习模型，通常采用 Transformer结构。这些模型能够理解语言的基本语法和知识，并通过自主学习进行无监督训练。LLM模型具有数十亿到千亿级的参数，能够捕获复杂的语言特征和模式，从而在各种自然语言处理任务中表现出色‌。</p><p>原文链接： <a href="https://blog.csdn.net/gitblog_00439/article/details/148578186">LLM工程实践指南：基于AWS SageMaker的大模型部署与推理全流程解析</a></p><h1 id="AWS-LLM-简介"><a href="#AWS-LLM-简介" class="headerlink" title="AWS LLM 简介"></a>AWS LLM 简介</h1><h2 id="模型结构与训练数据"><a href="#模型结构与训练数据" class="headerlink" title="模型结构与训练数据"></a>模型结构与训练数据</h2><p>AWS LLM主要使用<code>Transformer</code>结构，这是一种<strong>由编码器和解码器组成的神经网络架构</strong>。编码器从输入文本中提取特征，解码器则生成输出。这种结构使得模型能够并行处理整个序列，大大缩短了训练时间‌。训练数据通常来源于互联网的大量文本数据，如 <code>Common Crawl</code> 和 <code>Wikipedia</code>，这些数据包含了数十亿个网页和文章‌</p><h2 id="应用场景与性能"><a href="#应用场景与性能" class="headerlink" title="应用场景与性能"></a>应用场景与性能</h2><p>AWS LLM模型可以应用于多种场景，包括但不限于： ‌</p><ul><li><strong>自然语言理解‌：</strong>理解用户输入并生成相应的响应。 ‌</li><li><strong>文本生成‌：</strong>生成文章、邮件、代码等。 ‌</li><li><strong>知识问答‌：</strong>回答用户提出的问题。 ‌</li><li><strong>内容创作‌：</strong>生成故事、诗歌等创造性内容‌。  </li></ul><h2 id="部署与推理"><a href="#部署与推理" class="headerlink" title="部署与推理"></a>部署与推理</h2><p>在AWS平台上，可以使用 <code>Amazon SageMaker</code>进行模型的部署和推理。SageMaker提供了强大的工具和服务，支持模型的训练、部署和监控。通过SageMaker，开发者可以高效地管理和使用LLM模型，实现高效的推理和部署‌。</p><p>以下是基于<code>PacktPublishing/LLM-Engineers-Handbook</code>项目中的模型部署实践，系统性地介绍如何在AWS平台上使用SageMaker服务部署大语言模型（LLM）并进行推理应用的完整技术流程。</p><h3 id="一、AWS环境配置基础"><a href="#一、AWS环境配置基础" class="headerlink" title="一、AWS环境配置基础"></a>一、AWS环境配置基础</h3><p>在开始模型部署前，必须正确配置AWS环境。作为云计算工程师，建议采用最小权限原则进行配置：</p><ol><li><p><strong>IAM用户创建最佳实践</strong></p><ul><li><p>避免直接使用根账户凭证</p></li><li><p>为不同用途创建独立用户（如开发、测试、生产）</p></li><li><p>采用多因素认证(MFA)增强安全性</p></li><li><p>定期轮换访问密钥</p></li></ul></li><li><p><strong>AWS CLI配置技巧</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多环境配置示例</span></span><br><span class="line">aws configure --profile dev</span><br><span class="line">aws configure --profile prod</span><br></pre></td></tr></table></figure></li><li><p><strong>权限策略设计</strong></p><ul><li>生产环境推荐使用自定义策略而非预置策略</li><li>遵循最小权限原则</li><li>定期审计权限使用情况</li></ul></li></ol><h3 id="二、SageMaker角色体系解析"><a href="#二、SageMaker角色体系解析" class="headerlink" title="二、SageMaker角色体系解析"></a>二、<strong>SageMaker角色体系解析</strong></h3><ol><li><strong>用户角色与执行角色对比</strong></li></ol><table><thead><tr><th>特性</th><th>用户角色</th><th>执行角色</th></tr></thead><tbody><tr><td>使用场景</td><td>开发者操作AWS资源</td><td><code>SageMaker</code>服务内部调用</td></tr><tr><td>凭证类型</td><td>长期访问密钥</td><td>临时安全凭证(STS)</td></tr><tr><td>信任关系</td><td>无特殊信任</td><td>信任<code>sagemaker.amazonaws.com</code></td></tr><tr><td>典型权限</td><td>管理类操作权限</td><td>资源访问权限</td></tr></tbody></table><ol start="2"><li><strong>角色创建自动化脚本解析</strong><br>项目提供了两个关键Python脚本：</li></ol><ul><li><p><code>create_sagemaker_role.py</code>核心功能：</p><ul><li>使用boto3库与AWS API交互</li><li>自动生成并保存访问密钥</li><li>附加必要的托管策略</li><li>输出结果结构化存储</li></ul></li><li><p><code>create_sagemaker_execution_role.py</code>特点：</p><ul><li>建立服务信任关系</li><li>配置细粒度的资源访问权限</li><li>特别处理S3和ECR权限（模型部署必需）</li></ul></li></ul><h3 id="三、Hugging-Face模型部署实战"><a href="#三、Hugging-Face模型部署实战" class="headerlink" title="三、Hugging Face模型部署实战"></a>三、Hugging Face模型部署实战</h3><ol><li><strong>部署架构设计</strong></li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[开发者环境] </span><br><span class="line"> → [SageMaker Endpoint] </span><br><span class="line">     → [HuggingFace容器]</span><br><span class="line">         → [预训练LLM模型]</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>关键配置参数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 典型配置示例</span></span><br><span class="line">GPU_INSTANCE_TYPE = <span class="string">&quot;ml.g5.2xlarge&quot;</span>  <span class="comment"># 根据模型大小选择</span></span><br><span class="line">MAX_NEW_TOKENS = <span class="number">512</span>                 <span class="comment"># 生成文本长度限制</span></span><br><span class="line">TEMPERATURE = <span class="number">0.7</span>                    <span class="comment"># 生成多样性控制</span></span><br></pre></td></tr></table></figure></li><li><p><strong>部署策略选择</strong></p></li></ol><p>  项目实现了两种部署模式</p><ul><li><strong>模型基础部署：</strong>传统SageMaker端点</li><li><strong>推理组件部署：</strong>SageMaker新特性，支持多模型共享端点</li></ul><h3 id="四、模型推理测试与优化"><a href="#四、模型推理测试与优化" class="headerlink" title="四、模型推理测试与优化"></a>四、模型推理测试与优化</h3><ol><li><strong>测试脚本核心功能</strong></li></ol>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_text</span>(<span class="params">prompt, params</span>):</span><br><span class="line"> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> prompt: 输入提示文本</span></span><br><span class="line"><span class="string"> params: 包含temperature等生成参数</span></span><br><span class="line"><span class="string"> 返回: 模型生成的文本</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>参数调优指南</strong></li></ol><table><thead><tr><th>参数</th><th>影响范围</th><th>推荐值域</th></tr></thead><tbody><tr><td>temperature</td><td>输出多样性</td><td>0.5-1.0</td></tr><tr><td>repetition_penalty</td><td>重复内容惩罚</td><td>1.0-2.0</td></tr><tr><td>top_p</td><td>采样范围控制</td><td>0.7-0.95</td></tr></tbody></table><ol start="3"><li><strong>性能监控建议</strong></li></ol><ul><li>使用CloudWatch监控延迟和吞吐量</li><li>设置自动扩缩容策略应对流量波动</li><li>定期评估实例类型是否匹配工作负载</li></ul><h3 id="五、Makefile工程化管理"><a href="#五、Makefile工程化管理" class="headerlink" title="五、Makefile工程化管理"></a>五、Makefile工程化管理</h3><p>项目采用<code>Makefile</code>实现<strong>流程自动化</strong>，体现了现代<code>MLOps</code>实践：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deploy-inference-endpoint:</span><br><span class="line">    poetry run python llm_engineering/model/deploy/huggingface/run.py</span><br></pre></td></tr></table></figure><p><strong>典型工作流：</strong></p><ol><li><code>make create-sagemaker-execution-role</code></li><li><code>make deploy-inference-endpoint</code></li><li><code>python test.py</code> (交互测试)</li><li><code>make delete-inference-endpoint</code> (资源清理)</li></ol><h3 id="六、安全与成本最佳实践"><a href="#六、安全与成本最佳实践" class="headerlink" title="六、安全与成本最佳实践"></a>六、安全与成本最佳实践</h3><ol><li><p><strong>安全建议</strong></p><ul><li>使用VPC隔离部署环境</li><li>启用端点认证</li><li>加密模型和数据存储</li></ul></li><li><p><strong>成本优化</strong></p><ul><li>开发阶段使用较小实例</li><li>设置自动停止策略</li><li>定期清理未使用资源</li></ul></li><li><p><strong>运维监控</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aws cloudwatch get-metric-statistics \</span><br><span class="line">  --namespace AWS/SageMaker \</span><br><span class="line">  --metric-name CPUUtilization \</span><br><span class="line">  --dimensions Name=EndpointName,Value=&lt;YOUR_ENDPOINT&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">人工智能大模型（简称“大模型”）是指由人工神经网络构建的一类具有大量参数的人工智能模型，主要类别包括：大语言模型、视觉大模型、多模态大模型以及基础科学大模型等。</summary>
    
    
    
    <category term="large model" scheme="https://southernfish.github.io/categories/large-model/"/>
    
    
    <category term="large model" scheme="https://southernfish.github.io/tags/large-model/"/>
    
  </entry>
  
  <entry>
    <title>高并发（High Concurrency）</title>
    <link href="https://southernfish.github.io/2025/06/26/framwork/system-design-high-concurrency/"/>
    <id>https://southernfish.github.io/2025/06/26/framwork/system-design-high-concurrency/</id>
    <published>2025-06-26T01:13:36.000Z</published>
    <updated>2025-07-10T12:47:35.022Z</updated>
    
    <content type="html"><![CDATA[<p>高性能、高并发、高可用是构建现代大规模系统的三个关键目标，它们各自解决不同的问题，但在实际系统中往往需要综合考虑，互为补充。本篇讨论高并发应对的策略、缓存、限流、降级等。原文链接：<a href="https://blog.csdn.net/ailiandeziwei/article/details/136561585">高并发架构设计（三大利器：缓存、限流和降级）</a></p><h1 id="高并发（High-Concurrency）"><a href="#高并发（High-Concurrency）" class="headerlink" title="高并发（High Concurrency）"></a>高并发（High Concurrency）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>高并发指的是系统能够同时处理大量请求或操作的能力。在互联网应用中，用户可能会同时访问某个功能，这就要求系统能够同时处理多个用户的请求而不发生性能下降或响应延迟。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><code>热门网站</code>、<code>电商平台</code>、<code>社交媒体</code>等互联网应用中。例如，在电商平台上有大量用户同时浏览、搜索商品，提交订单等操作；社交媒体平台上有大量用户同时发布、点赞、评论等操作。这些场景需要系统能够同时处理大量请求，并保证系统的性能、可用性和用户体验。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><strong>大量请求：</strong>系统需要同时处理大量的请求，这些请求可能来自于不同的用户或客户端。 </li><li><strong>同时访问：</strong>这些请求几乎同时到达系统，需要在短时间内进行处理和响应。 </li><li><strong>资源竞争：</strong>由于大量请求同时到达，系统的资源（如CPU、内存、网络带宽等）可能会面临竞争和争夺。 </li><li><strong>响应时间要求高：</strong>高并发场景通常对系统的响应速度有较高的要求，用户期望能够快速获取响应结果。</li></ol><h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><ul><li>系统性能的下降和延迟增加</li><li>资源竞争和资源耗尽</li><li>系统稳定性和可用性的挑战</li></ul><h2 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h2><ul><li><strong>缓存：</strong>缓解系统负载压力，提高系统响应速度</li><li><strong>限流：</strong>控制并发访问量，保护系统免受过载影响</li><li><strong>降级：</strong>保证核心功能的稳定性，舍弃非关键业务或简化处理</li></ul><hr><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>缓存的工作原理是先从缓存中获取数据，如果有数据则直接返回给用户，如果没有数据则从慢速设备上读取实际数据并且将数据放入缓存</p><h2 id="常用技术"><a href="#常用技术" class="headerlink" title="常用技术"></a>常用技术</h2><table><thead><tr><th>缓存类型</th><th>介绍</th><th align="left">方案/工具</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>浏览器缓存</td><td>存储在用户设备上的缓存，用于存储静态资源和页面内容。</td><td align="left">通过设置<code>HTTP头</code>中的缓存相关字段来控制缓存行为。</td><td>1.快速响应，避免频繁访问服务器或网络<br /> 2.减少网络带宽消耗，提升网站性能</td><td>1.缓存数据可能不是最新的，需要考虑缓存一致性和更新机制的设计<br />2.缓存命中率受限于缓存容量和缓存策略的选择</td><td>1.静态资源的缓存<br />2.减少网络带宽消耗</td></tr><tr><td>客户端缓存</td><td>应用程序在用户设备上的缓存，用于存储数据、计算结果或其他业务相关的内容。</td><td align="left">使用<code>本地存储</code>、<code>SessionStorage</code>、<code>LocalStorage</code>或<code>IndexedDB</code>等<strong>Web API</strong>来进行数据的存储和读取。</td><td>1.减轻后端负载，提升系统性能<br />2.快速响应，避免频繁访问服务器或网络资源</td><td>1.缓存数据可能不是最新的，需要考虑缓存一致性和更新机制的设计<br />2.缓存命中率受限于缓存容量和缓存策略的选择</td><td>1.频繁访问的数据或计算结果<br />2.减轻后端负载</td></tr><tr><td>CDN缓存</td><td>内容分发网络的缓存，用于存储和加速静态资源的分发。</td><td align="left">部署静态资源到<code>CDN服务器</code>并配置<code>CDN缓存策略</code>，用户请求将被转发到就近的CDN节点，加速内容的分发和访问。</td><td>1.加速静态资源的访问速度，提升用户体验<br />2.减轻源服务器负载，提高系统可扩展性</td><td>1.只适用于静态资源的缓存，动态内容无法缓存<br />2.CDN配置和管理的复杂性</td><td>1.静态资源的分发和访问<br />2.加速静态资源的加载和访问</td></tr><tr><td></td><td></td><td align="left"></td><td></td><td></td><td></td></tr><tr><td>反向代理缓存</td><td>位于服务器前端的缓存，用于缓存和加速动态内容和静态资源的访问。</td><td align="left">配置<code>反向代理服务器</code>并<code>设置缓存策略</code>，将用户请求转发到缓存服务器，减轻后端服务器的负载并加速内容的访问。</td><td>1.加速内容的访问速度，提升用户体验<br />2.减轻源服务器负载，提高系统可扩展性</td><td>只适用于特定的Web服务器和应用程序</td><td>1.动态内容和静态资源的缓存和加速访问<br /> 2. 减轻后端服务器的负载</td></tr><tr><td>本地缓存</td><td>应用程序在用户设备上的缓存，用于缓存数据和资源以提高应用的性能和响应速度。</td><td align="left">使用缓存库或框架（如<code>localStorage</code>、<code>sessionStorage</code>、<code>Workbox</code>等）来实现。</td><td>1.提升应用的性能和响应速度<br />2. 减少对远程资源的依赖，提高离线使用体验</td><td>本地缓存容量受限于用户设备的存储空间</td><td>1.频繁访问的数据或资源<br /> 2.提升应用的性能和响应速度</td></tr><tr><td>分布式缓存</td><td>在分布式系统中使用的缓存，用于存储和共享数据。分布式缓存通常部署在多台服务器上，并提供高并发读写能力和数据访问的可扩展性。分布式缓存常用于大规模应用和系统中。</td><td align="left">使用分布式缓存系统（如<code>Redis</code>、<code>Memcached</code>等）来存储和访问缓存数据。</td><td>高并发读写能力和数据存储的可扩展性</td><td>1.需要额外的服务器资源来部署和管理分布式缓存系统<br /> 2.缓存一致性和数据同步问题需要考虑</td><td>1.高并发读写能力和数据存储的可扩展性<br /> 2.大规模应用和系统的缓存和数据共享</td></tr></tbody></table><p>根据具体需求和系统架构，选择适合的缓存类型和方案，以提高系统性能、减轻服务器负载、改善用户体验和保证数据一致性。</p><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>浏览器缓存是指<strong>将网页中的资源（如HTML、CSS、JavaScript、图像等）存储在用户的浏览器内部</strong>，以便在后续请求同一资源时可以直接从本地缓存中获取，而无需再次从服务器下载。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>浏览器缓存适用于<strong>静态内容变化较少的网页和静态资源</strong>，可以显著提升网站性能和用户体验，并减少服务器的负载。</p><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>使用浏览器缓存可以通过<strong>设置响应头中的<code>Expires</code>和<code>Cache-Control</code>字段来控制缓存的行为</strong>。</p><ol><li><strong>使用Expires字段：</strong>Expires字段<strong>指定了缓存的过期时间，是一个具体的日期和时间</strong>。服务器可以在响应头中添加Expires字段，告诉浏览器在该时间之前可以直接从缓存中获取资源，而无需再向服务器发起请求。例如：Expires: Mon, 31 Dec 2022 23:59:59 GMT。</li><li><strong>使用Cache-Control字段：</strong>Cache-Control字段提供了更灵活的缓存控制选项。可以通过设置<code>max-age</code>指令来指定缓存的最大有效时间，单位是秒。例如：Cache-Control: max-age=3600 表示资源可以在1小时内直接从缓存中获取。还可以使用其他指令，如no-cache表示缓存但不使用缓存、no-store表示禁止缓存等。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>浏览器缓存存储<strong>实时性不敏感的数据</strong>，如商品框架、商家评分、评价和广告词。它有过期时间，并通过响应头进行控制。实时性要求高的数据不适合使用浏览器缓存。</p><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>客户端缓存是<strong>将数据存储在浏览器</strong>中，以提高访问速度和减少服务器请求。</p><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>在大促期间，为了防止服务端承受瞬间的高流量压力，可以<strong>提前将一些素材（如js/css/image等）下发到客户端进行缓存</strong>，避免在大促期间再次请求这些素材。此外，还可以<strong>将一些兜底数据或样式文件存放在客户端缓存</strong>中，以确保在服务端异常或网络异常的情况下，保持app的正常运行。</p><h2 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>CDN（<code>Content Delivery Network</code>）是建立在承载网之上的<strong>分布式网络，由分布在不同区域的边缘节点服务器组成</strong>。 </p><p>CDN缓存通常用于<strong>存放静态页面数据、活动页面、图片等数据</strong>。</p><p>CDN的两种<strong>缓存机制</strong>：<code>推送机制</code>（将数据主动推送到CDN节点）和<code>拉取机制</code>（首次访问时从源服务器获取数据并存储在CDN节点）。</p><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>CDN缓存可以提高网站访问速度，适用于<strong>网站访问量大、访问速度慢、数据变化不频繁的场景</strong>。</p><h3 id="常用工具以及用法"><a href="#常用工具以及用法" class="headerlink" title="常用工具以及用法"></a><strong>常用工具以及用法</strong></h3><p>常见的CDN缓存工具包括<code>Cloudflare</code>、<code>Akamai</code>、<code>Fastly</code>和<code>AWS CloudFront</code>等。这些工具提供了全球分布的CDN网络，以加速内容传输和提升性能。它们<strong>提供了控制台和API，用于配置CDN缓存规则、管理缓存内容、刷新和更新缓存等</strong>。</p><h2 id="反向代理缓存"><a href="#反向代理缓存" class="headerlink" title="反向代理缓存"></a>反向代理缓存</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>反向代理缓存是指<strong>在反向代理服务器上对请求的响应进行缓存</strong>，以提高服务的性能和用户体验。它<strong>将经常请求的静态内容缓存在代理服务器上</strong>，当有用户请求同样的内容时，代理服务器会直接返回缓存的响应，而无需再次向源服务器请求。</p><h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>适用于访问外部服务速度比较慢，但是<strong>数据变化不频繁</strong>的场景。</p><h3 id="常用工具以及用法-1"><a href="#常用工具以及用法-1" class="headerlink" title="常用工具以及用法"></a><strong>常用工具以及用法</strong></h3><p>1.<strong>Nginx：</strong>一款高性能的反向代理服务器，支持反向代理缓存功能，可通过配置文件进行缓存策略的设置。Nginx代理层缓存主要以<code>Http</code>模块与<code>proxy_cacahe</code>模块进行配置即可。</p><p>2.<strong>Varnish：</strong>一个专门用于反向代理缓存的开源软件，可以高效地缓存并提供快速的响应。</p><p>3.<strong>Squid：</strong>一款功能强大的缓存代理服务器，支持反向代理缓存和正向代理缓存。</p><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>本地缓存是将数据或资源存储在客户端的存储介质中，如硬盘、内存或数据库。它可以是临时的，只在应用程序运行期间有效，或者可以是持久的，即在不同的应用程序会话中保持有效。</p><h3 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>本地缓存适用于<strong>频繁访问数据</strong>、离线访问、减少带宽消耗和提升用户体验的场景。</p><h3 id="常用工具以及用法-2"><a href="#常用工具以及用法-2" class="headerlink" title="常用工具以及用法"></a><strong>常用工具以及用法</strong></h3><p><strong>一般分为磁盘缓存、CPU缓存、应用缓存</strong></p><ol><li><strong>磁盘缓存：</strong>存储在硬盘等永久性存储介质上，用于加速数据的读取和访问。</li><li><strong><a href="https://so.csdn.net/so/search?q=CPU%E7%BC%93%E5%AD%98&spm=1001.2101.3001.7020">CPU缓存</a>：</strong>位于处理器内部的高速存储器，用于<strong>暂时存储频繁访问的数据或指令</strong>，提高计算机的性能。</li><li><strong>应用缓存：</strong>存储在内存中的应用程序数据或资源，用于提高应用程序的响应速度和用户体验。用Java服务来举例，又分为 <strong>堆内缓存 与 堆外缓存</strong> 。</li></ol><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>分布式缓存是<strong>将缓存数据分散存储在多台服务器上</strong>的缓存解决方案。</p><h3 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p><strong>高并发读取、数据共享和协同处理、提供弹性和可扩展性、降低后端请求次数</strong>等场景。</p><h3 id="常用工具以及用法-3"><a href="#常用工具以及用法-3" class="headerlink" title="常用工具以及用法"></a><strong>常用工具以及用法</strong></h3><ol><li><strong><code>Redis</code>：</strong>Redis是一种<strong>高性能的键值存储系统，支持丰富的数据类型和灵活的缓存策略</strong>。可以使用Redis搭建分布式缓存集群，利用其快速的读写能力和一致性哈希算法实现数据分片和负载均衡。</li><li><strong><code>Memcached</code>：</strong>Memcached是一种<strong>简单而快速的分布式内存对象缓存系统</strong>，用于<strong>减轻数据库负载和加速动态Web应用程序</strong>。它采用分布哈希算法进行数据分片和分布式存储。</li><li><strong><code>Hazelcast</code>：</strong>Hazelcast是一个开源的<strong>分布式内存数据网格平台</strong>，<strong>提供分布式缓存和分布式计算能力</strong>。它可以用于构建高吞吐量和高可用性的分布式缓存系统。</li></ol><h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a><strong>缓存问题</strong></h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>关键词：<strong>强调缓存和数据库都没有数据+并发访问</strong>﻿<br>缓存穿透是指数据库和缓存都没有的数据，每次都要经过缓存去访问数据库，大量的请求有可能导致DB宕机。</p><h3 id="应对策略-1"><a href="#应对策略-1" class="headerlink" title="应对策略"></a><strong>应对策略</strong></h3><ol><li><strong>使用布隆过滤器（<code>Bloom Filter</code>）：</strong>布隆过滤器是一种<strong>快速判断元素是否存在的数据结构</strong>，它可以在很小的内存占用下，快速判断一个元素是否在一个集合中。<strong>将所有可能存在的数据哈希到一个足够大的位数组中</strong>，当一个请求过来时，先经过布隆过滤器判断是否存在于缓存中，如果不存在，则直接返回，避免对数据库的查询压力。</li><li><strong>空对象缓存：</strong>对于确定不存在的数据，在缓存中也存储一个空对象，表示该数据不存在。当请求访问这些不存在的数据时，直接从缓存中返回空对象，避免每次请求都穿透到数据库层进行查询。</li><li><strong>延迟双判：</strong>当一个查询请求穿透缓存到达数据库层后，先在数据库中进行查询，如果数据库也没有对应的数据，则将这个空结果写入缓存，并设置一个较短的过期时间。这样，下次相同的查询请求就会从缓存中得到空结果，而不会再次穿透到数据库。</li><li><strong>热点数据预加载：</strong>对于一些热点数据，在系统启动时或者在缓存过期前提前异步加载到缓存中，确保缓存的热点数据一直存在，避免被频繁请求的数据因为缓存过期而导致穿透问题。</li><li><strong>限流策略：</strong>针对频繁请求的特定数据，可以设置限流策略，例如使用<code>令牌桶算法</code>或<code>漏桶算法</code>，限制对这些数据的请求频率，减轻数据库的压力。</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>关键词：<strong>强调单个热点Key过期+并发访问</strong><br>缓存击穿是指数据库有，缓存没有的热点数据，大量请求访问这个缓存不存在的数据，最后请求打到DB可能导致DB宕机。</p><h3 id="应对策略-2"><a href="#应对策略-2" class="headerlink" title="应对策略"></a><strong>应对策略</strong></h3><ol><li><strong>设置热点数据的热度时间窗口：</strong>对于热点数据，可以设置一个热度时间窗口，在这个时间窗口内，如果一个数据被频繁访问，就将其缓存时间延长，避免频繁刷新缓存导致缓存击穿。</li><li><strong>使用互斥锁或分布式锁：</strong>在缓存失效时，只允许一个线程去查询数据库，其他线程等待查询结果。可以使用互斥锁或分布式锁来实现，确保只有一个线程能够查询数据库，其他线程等待结果，避免多个线程同时查询数据库造成数据库压力过大。</li><li><strong>缓存永不过期：</strong>对于一些热点数据，可以将其缓存设置为永不过期，或者设置一个很长的过期时间，这样即使缓存失效，也有足够的时间来刷新缓存，避免缓存击穿。</li><li><strong>异步更新缓存：</strong>在缓存失效时，可以异步地去更新缓存，而不是同步地去查询数据库并刷新缓存。这样可以减少对数据库的直接访问，并且不会阻塞其他请求的响应。</li><li><strong>多级缓存架构：</strong>使用多级缓存架构，将热点数据分散到多个缓存节点上，避免单一缓存节点发生故障导致整个缓存层崩溃。当某个缓存节点失效时，可以从其他缓存节点或数据库中获取数据。</li><li><strong>熔断机制：</strong>当缓存层发生故障或无法正常工作时，可以设置熔断机制，直接访问数据库，保证系统的正常运行。</li></ol><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>关键词：<strong>强调批量Key过期+并发访问</strong>﻿<br>缓存雪崩指的是在同一时段大量的缓存键（key）同时失效，导致大量请求打到数据库，最后请求打到DB可能导致DB宕机。</p><h3 id="应对策略-3"><a href="#应对策略-3" class="headerlink" title="应对策略"></a><strong>应对策略</strong></h3><ol><li><strong>使用多级缓存架构：</strong>将缓存划分为多个层级，每个层级的缓存设置不同的过期时间。例如，将热点数据存储在近期失效的缓存层级，而将非热点数据存储在长期失效的缓存层级。这样即使某一层级的缓存失效，仍然可以从其他层级获取数据，避免所有请求直接访问数据库。</li><li><strong>设置缓存数据的随机过期时间：</strong>在设置缓存数据的过期时间时，加上一个随机值，使得不同的缓存数据在过期时刻不一致。这样可以避免大量数据同时过期，减轻数据库负荷。</li><li><strong>分布式锁或互斥锁：</strong>在缓存失效时，使用分布式锁或互斥锁来保证只有一个请求可以重新加载缓存。其他请求等待该请求完成后，直接从缓存中获取数据。这样可以避免多个请求同时访问数据库。</li><li><strong>数据预热：</strong>在系统启动或者非高峰期，提前将热点数据加载到缓存中，预热缓存。这样即使在高并发时，也能够从缓存中获取到数据，减轻数据库的压力。</li><li><strong>缓存限流：</strong>当检测到缓存失效时，可以对请求进行限流处理，限制并发请求的数量。这样可以避免大量请求同时访问数据库，导致数据库负载过大。</li><li><strong>数据库优化：</strong>对于缓存雪崩问题，除了缓存层面的应对策略，还可以从数据库层面进行优化，如提升数据库性能、增加数据库的容量等，以应对大量请求导致的数据库压力。</li></ol><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>缓存一致性指的是缓存与DB之间的数据一致性，我们需要通过各种手段来防止缓存与DB不一致，我们要保证缓存与DB的数据一致或者数据最终一致。</p><h3 id="应对策略-4"><a href="#应对策略-4" class="headerlink" title="应对策略"></a><strong>应对策略</strong></h3><p>针对缓存一致性问题，可以从不同的层次来应对：</p><ol><li><p><strong>数据库层</strong></p><ul><li><p>在数据库层面，可以使用<strong>事务</strong>来确保数据的一致性。通过<strong>将读写操作放在同一个事务中</strong>，可以保证数据的更新和查询是一致的。</p></li><li><p>使用数据库的<strong>触发器</strong>或者<strong>存储过程</strong>，在数据更新的同时，主动触发缓存的更新操作，确保缓存与数据库的数据保持一致。</p></li></ul></li><li><p><strong>缓存层</strong></p><ul><li><p>在缓存层面，可以使用缓存更新策略，通过<strong>定时任务、异步消息队列</strong>等方式，定期或者在数据更新时<strong>异步地更新缓存</strong>，保持缓存与数据库的数据一致性。</p></li><li><p>使用<strong>互斥锁或者分布式锁来保证对缓存的读写操作的原子性</strong>，避免数据冲突。</p></li><li><p>设置<strong>合适的缓存过期时间</strong>，避免缓存数据长时间过期而导致数据不一致的问题。</p></li></ul></li><li><p><strong>应用层</strong></p><ul><li><p>在应用层面，可以采用<strong>读写分离策略，将读请求和写请求分发到不同的节点</strong>，读请求直接从缓存中获取数据，写请求则更新数据库并更新缓存，保持数据的一致性。</p></li><li><p>使用<strong>缓存中间件或者缓存组件，提供自动更新缓存</strong>的功能，减少手动维护缓存的复杂性。</p></li></ul></li><li><p><strong>监控和报警</strong></p><ul><li>建立监控和报警机制，通过监控缓存层和数据库层状态、数据一致性等指标，及时发现异常情况，并触发报警，以便及时处理。</li></ul></li></ol><p>综合使用以上层次的策略，可以有效地应对缓存一致性问题，保证数据的一致性和系统的稳定性。不同层次的策略可以相互配合，形成一个完善的缓存一致性解决方案。</p><hr><h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><h2 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>再强大的系统，也怕<strong>流量短事件内集中爆发</strong>，就像银行怕挤兑一样，所以，高并发另一个必不可少的模块就是限流。</p><p>限流是一种通过<strong>控制请求的速率或数量</strong>来保护系统免受过载的技术。流控的精髓是<strong>限制单位时间内的请求量</strong>，最大程度保障系统的可靠性及可用性。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h2><p>限流是在高并发环境下，为了保护系统的稳定性和可用性而引入的一种策略。通过限制并发请求的数量或频率，可以防止系统被过多的请求压垮或耗尽资源。</p><h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a><strong>限流算法</strong></h2><p>常见的流控算法包括：<strong>固定窗口、滑动窗口、漏桶、令牌桶、滑动日志</strong>等算法。</p><h3 id="固定窗口算法（计数器）"><a href="#固定窗口算法（计数器）" class="headerlink" title="固定窗口算法（计数器）"></a>固定窗口算法（计数器）</h3><h4 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>固定窗口限流算法（<code>Fixed Window Rate Limiting Algorithm</code>）原理是<strong>在固定时间窗口(单位时间)内限制请求的数量</strong>。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>固定窗口是最简单的流控算法。即，给定<strong>时间窗口</strong>，维护一个<strong>计数器</strong>用于统计访问次数，并实现以下规则：</p><ol><li>如果<em>访问次数小于阈值</em>，则允许访问，访问次数+1；</li><li>如果<em>访问次数超出阈值</em>，则限制访问，访问次数不增；</li><li>如果<em>超过了时间窗口，计数器清零</em>，并重置清零后的首次成功访问时间为当前时间。</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedWindowRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 统计请求数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">lastAcquireTime</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 记录上一次获取请求的时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">windowUnit</span> <span class="operator">=</span> <span class="number">1000L</span>; <span class="comment">// 假设固定时间窗口是1000ms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 窗口阀值是10，表示在时间窗口内的请求数阀值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字来实现线程安全</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">// 获取系统当前时间</span></span><br><span class="line">        <span class="keyword">if</span> (currentTime - lastAcquireTime &gt; windowUnit) &#123;  <span class="comment">// 检查 当前时间距离上次获取请求的时间 是否在时间窗口内</span></span><br><span class="line">            counter = <span class="number">0</span>;  <span class="comment">// 计数器清零</span></span><br><span class="line">            lastAcquireTime = currentTime;  <span class="comment">// 开启新的时间窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (counter &lt; threshold) &#123;  <span class="comment">// 小于阀值</span></span><br><span class="line">            counter++;  <span class="comment">// 计数器加1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 超过阀值，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-6"><a href="#适用场景-6" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li>保护后端服务免受大流量冲击，避免服务崩溃</li><li>对 API 调用进行限制，保证公平使用</li><li>防止恶意用户对服务进行洪水攻击</li></ul><h4 id="优劣分析"><a href="#优劣分析" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul><li><p><strong>优势：</strong>算法简单，易于实现和理解；<strong>性能高</strong></p></li><li><p><strong>劣势：</strong>存在明显的<strong>临界问题</strong>。</p><ul><li>比如：假设限流阀值为5个请求，单位时间窗口是1s，如果我们在单位时间内的<strong>前0.8-1s</strong>和<strong>1-1.2s</strong>，分别并发5个请求。虽然都没有超过阀值，但是如果算<strong>0.8-1.2s</strong>内的，则并发数高达10，已经超过单位时间1s不超过5阀值的定义了。</li></ul></li></ul><h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><h4 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>滑动窗口算法是把大的时间窗口拆分成若干<strong>粒度更细</strong>的子窗口，每个子窗口独立统计，<strong>按子窗口时间滑动</strong>，统一限流。当滑动窗口的格子周期划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。（<strong>为了解决临界突变问题</strong>）</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>将单位时间周期分为<strong>n个小周期</strong>，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。它可以解决固定窗口临界值的问题。</p><p>假设单位时间是<strong>1s</strong>，滑动窗口算法把它划分为<strong>5个小周期</strong>，也就是滑动窗口（单位时间）被划分为<strong>5个小格子</strong>。每格表示<strong>0.2s</strong>。每过<strong>0.2s</strong>，时间窗口就会往右滑动一格。<strong>每个小周期，都有自己独立的计数器</strong>，如果请求是<strong>0.83s</strong>到达的，<strong>0.8~1.0s</strong>对应的计数器就会<strong>加1</strong>。</p><p>假设我们1s内的限流阀值还是5个请求，0.8<del>1.0s内（比如0.9s的时候）来了5个请求，落在黄色格子里。﻿时间过了1.0s这个点之后，又来5个请求，落在紫色格子里。如果是固定窗口算法，是不会被限流的，但是滑动窗口的话，每过一个小周期，它会右移一个小格。过了1.0s这个点后，会右移一小格，当前的单位时间段是0.2</del>1.2s，这个区域的请求已经超过限定的5了，已触发限流啦，实际上，紫色格子的请求都被拒绝。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/1bb637a70d4209bc6aefb86b4ae94704.png" alt="img"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Long&gt; timestamps; <span class="comment">// 存储请求的时间戳队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> windowSize; <span class="comment">// 窗口大小，即时间窗口内允许的请求数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> windowDuration; <span class="comment">// 窗口持续时间，单位：毫秒</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SlidingWindowRateLimiter</span><span class="params">(<span class="type">int</span> windowSize, <span class="type">long</span> windowDuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.windowSize = windowSize;</span><br><span class="line">        <span class="built_in">this</span>.windowDuration = windowDuration;</span><br><span class="line">        <span class="built_in">this</span>.timestamps = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字来实现线程安全</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        <span class="comment">// 删除超过窗口持续时间的时间戳</span></span><br><span class="line">        <span class="keyword">while</span> (!timestamps.isEmpty() &amp;&amp; currentTime - timestamps.peek() &gt; windowDuration) &#123;</span><br><span class="line">            timestamps.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timestamps.size() &lt; windowSize) &#123; <span class="comment">// 判断当前窗口内请求数是否小于窗口大小</span></span><br><span class="line">            timestamps.offer(currentTime); <span class="comment">// 将当前时间戳加入队列</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 超过窗口大小，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-7"><a href="#适用场景-7" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>同固定窗口的场景，且对流量限制要求较高的场景，<strong>需要更好地应对突发流量</strong>。</p><h4 id="优劣分析-1"><a href="#优劣分析-1" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul><li><p><strong>优势：</strong>简单易懂；<strong>精度高</strong>（通过调整时间窗口的大小来实现不同的限流效果）；<strong>可扩展性强</strong>（易与其他限流算法结合使用）</p></li><li><p><strong>劣势：</strong>突发流量无法处理（无法应对短时间内的大量请求，但是一旦到达限流后，请求都会直接暴力被拒绝。这样我们会损失一部分请求，这其实对于产品来说，并不太友好），需要合理调整时间窗口大小。</p></li></ul><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><h4 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a><strong>简介</strong></h4><p><strong>基于（出口）流速来做流控。</strong>在网络通信中常用于流量整形，可以很好地解决平滑度问题。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li>可以以任意速率流入水滴到漏桶（流入请求）</li><li>漏桶具有固定容量，出水速率是固定常量（流出请求）</li><li>如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）</li></ul><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a><strong>原理</strong></h4><ul><li><p><strong>思想：</strong>将数据包看作是水滴，漏桶看作是一个固定容量的水桶，数据包像水滴一样从桶的顶部流入桶中，并通过桶底的一个小孔以一定的速度流出，从而限制了数据包的流量</p></li><li><p><strong>工作原理：</strong>对于每个到来的数据包，都将其加入到漏桶中，并检查漏桶中当前的水量是否超过了漏桶的容量。若超过了容量，就将多余的数据包丢弃。若漏桶中还有水，就以一定的速率从桶底输出数据包，保证输出的速率不超过预设的速率，从而达到限流目的。</p></li></ul><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakyBucketRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> capacity; <span class="comment">// 漏桶容量，即最大允许的请求数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> rate; <span class="comment">// 漏水速率，即每秒允许通过的请求数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> water; <span class="comment">// 漏桶当前水量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> lastTime; <span class="comment">// 上一次请求通过的时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeakyBucketRateLimiter</span><span class="params">(<span class="type">long</span> capacity, <span class="type">long</span> rate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.rate = rate;</span><br><span class="line">        <span class="built_in">this</span>.water = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lastTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字来实现线程安全</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> now - lastTime; <span class="comment">// 计算从上一次请求通过到当前的时间间隔</span></span><br><span class="line">        water = Math.max(<span class="number">0</span>, water - elapsedTime * rate / <span class="number">1000</span>); <span class="comment">// 计算漏桶中的水量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (water &lt; capacity) &#123; <span class="comment">// 判断漏桶中的水量是否小于容量</span></span><br><span class="line">            water++; <span class="comment">// 漏桶中的水量加1</span></span><br><span class="line">            lastTime = now; <span class="comment">// 更新上一次请求通过的时间戳</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 漏桶已满，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-8"><a href="#适用场景-8" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>一般用于保护第三方的系统，比如自身的系统需要调用第三方的接口，为了保护第三方的系统不被自身的调用打垮，便可以通过漏斗算法进行限流，保证自身的流量平稳的打到第三方的接口上。</p><h4 id="优劣分析-2"><a href="#优劣分析-2" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul><li><p><strong>优势</strong></p><ul><li><p>可以平滑限制请求的处理速度，<strong>避免瞬间请求过多导致系统崩溃或者雪崩</strong>。</p></li><li><p>可以<strong>控制请求的处理速度</strong>，使得系统可以适应不同的流量需求，<strong>避免过载或者过度闲置</strong>。</p></li><li><p>可以通过<strong>调整桶的大小和漏出速率来满足不同的限流需求</strong>，可以灵活地适应不同的场景。</p></li></ul></li><li><p><strong>劣势</strong></p><ul><li><p>需要<strong>对请求进行缓存</strong>，会增加服务器的内存消耗。</p></li><li><p>对于流量波动比较大的场景，需要较为灵活的参数配置才能达到较好的效果。</p></li><li><p>但是面对突发流量的时候，漏桶算法还是循规蹈矩地处理请求，这不是我们想看到的啦。流量变突发时，我们肯定希望系统尽量快点处理请求，提升用户体验。</p></li></ul></li></ul><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><h4 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>基于（入口）流速来做流控的一种限流算法。</p><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>该算法维护一个固定容量的令牌桶，每秒钟会向令牌桶中放入一定数量的令牌。当有请求到来时，如果令牌桶中有足够的令牌，则请求被允许通过并从令牌桶中消耗一个令牌，否则请求被拒绝。<strong>Guava</strong>的<strong>RateLimiter</strong>限流组件，就是基于令牌桶算法实现的。</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenBucketRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> capacity; <span class="comment">// 令牌桶容量，即最大允许的请求数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> rate; <span class="comment">// 令牌产生速率，即每秒产生的令牌数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> tokens; <span class="comment">// 当前令牌数量</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService scheduler; <span class="comment">// 调度器，用于调度令牌补充任务的线程池。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TokenBucketRateLimiter</span><span class="params">(<span class="type">long</span> capacity, <span class="type">long</span> rate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.rate = rate;</span><br><span class="line">        <span class="built_in">this</span>.tokens = capacity;</span><br><span class="line">        <span class="built_in">this</span>.scheduler = <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>);</span><br><span class="line">        scheduleRefill(); <span class="comment">// 启动令牌补充任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleRefill</span><span class="params">()</span> &#123; <span class="comment">// 使用调度器定期执行令牌补充任务，每秒补充一次令牌</span></span><br><span class="line">        scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">// 通过加锁的方式更新令牌数量，确保线程安全。</span></span><br><span class="line">                tokens = Math.min(capacity, tokens + rate); <span class="comment">// 补充令牌(当前令牌数量加上产生速率)，但不超过容量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS); <span class="comment">// 每秒产生一次令牌</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字实现线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (tokens &gt; <span class="number">0</span>) &#123; <span class="comment">// 判断令牌数量是否大于0</span></span><br><span class="line">            tokens--; <span class="comment">// 消耗一个令牌</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 令牌不足，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-9"><a href="#适用场景-9" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>一般用于保护自身的系统，对调用者进行限流，保护自身的系统不被突发的流量打垮。如果自身的系统实际的处理能力强于配置的流量限制时，可以允许一定程度的流量突发，使得实际的处理速率高于配置的速率，充分利用系统资源。</p><h4 id="优劣分析-3"><a href="#优劣分析-3" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul><li><p><strong>优势</strong></p><ul><li><p><strong>稳定性高：</strong>令牌桶算法可以<strong>控制请求的处理速度</strong>，可以使系统的负载变得稳定。</p></li><li><p><strong>精度高：</strong>令牌桶算法可以根据实际情况<strong>动态调整生成令牌的速率</strong>，可以实现较高精度的限流。</p></li><li><p><strong>弹性好：</strong>令牌桶算法可以<strong>处理突发流量</strong>，可以在短时间内提供更多的处理能力，以处理突发流量。</p></li></ul></li><li><p><strong>劣势</strong></p><ul><li><p><strong>实现复杂：</strong>相对于固定窗口算法等其他限流算法，令牌桶算法的实现较为复杂。</p></li><li><p><strong>对短时请求难以处理：</strong>在短时间内有大量请求到来时，可能会导致令牌桶中的令牌被快速消耗完，从而限流。这种情况下，可以考虑使用漏桶算法。</p></li><li><p><strong>时间精度要求高：</strong>令牌桶算法<strong>需要在固定的时间间隔内生成令牌</strong>，因此要求时间精度较高，如果系统时间不准确，可能会导致限流效果不理想。</p></li></ul></li></ul><h3 id="滑动日志算法（比较冷门）"><a href="#滑动日志算法（比较冷门）" class="headerlink" title="滑动日志算法（比较冷门）"></a>滑动日志算法（比较冷门）</h3><h4 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>滑动日志限速算法需要<strong>记录请求的时间戳</strong>，通常使用有序集合来存储，我们可以在单个有序集合中跟踪用户在一个时间段内所有的请求。</p><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>滑动日志算法可以用于<strong>实现限流功能，即控制系统在单位时间内处理请求的数量</strong>，以保护系统免受过载的影响。以下是滑动日志算法用于限流的原理：</p><ol><li><strong>划分时间窗口：</strong>将时间划分为固定的时间窗口，例如每秒、每分钟或每小时等。</li><li><strong>维护滑动窗口：</strong>使用一个滑动窗口来记录每个时间窗口内的请求次数。这个滑动窗口可以是一个固定长度的队列或数组。</li><li><strong>请求计数：</strong>当一个请求到达时，将其计数加一并放入当前时间窗口中。</li><li><strong>滑动：</strong>随着时间的流逝，滑动窗口会根据当前时间窗口的长度，移除最旧的请求计数，并将新的请求计数添加到最新的时间窗口中。</li><li><strong>限流判断：</strong>在每个时间窗口结束时，统计滑动窗口中的请求计数总和，并与预设的阈值进行比较。如果总请求数超过阈值，则触发限流处理。</li><li><strong>限流处理：</strong>一旦触发限流，可以采取不同的处理策略，如拒绝请求、延迟处理、返回错误信息等。具体的限流策略可以根据实际情况进行选择。</li></ol><p>通过滑动日志算法进行限流，可以<strong>实现对单位时间内的请求进行精确控制</strong>。它<strong>基于实时统计的方式</strong>，能够动态地适应请求流量的变化，并且在内存使用上比较高效。同时，通过调整时间窗口的长度和阈值的设置，可以<strong>灵活地控制限流的精度和灵敏度</strong>。</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingLogRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> requests; <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; timestamps; <span class="comment">// 存储请求的时间戳列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> windowDuration; <span class="comment">// 窗口持续时间，单位：毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// 窗口内的请求数阀值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SlidingLogRateLimiter</span><span class="params">(<span class="type">int</span> threshold, <span class="type">long</span> windowDuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.requests = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.timestamps = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.windowDuration = windowDuration;</span><br><span class="line">        <span class="built_in">this</span>.threshold = threshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123; <span class="comment">// 使用synchronized关键字实现线程安全</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 获取当前时间戳</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除超过窗口持续时间的时间戳</span></span><br><span class="line">        <span class="keyword">while</span> (!timestamps.isEmpty() &amp;&amp; currentTime - timestamps.get(<span class="number">0</span>) &gt; windowDuration) &#123;</span><br><span class="line">            timestamps.remove(<span class="number">0</span>);</span><br><span class="line">            requests--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (requests &lt; threshold) &#123; <span class="comment">// 判断当前窗口内请求数是否小于阀值</span></span><br><span class="line">            timestamps.add(currentTime); <span class="comment">// 将当前时间戳添加到列表</span></span><br><span class="line">            requests++; <span class="comment">// 请求总数增加</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取请求成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 超过阀值，无法获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-10"><a href="#适用场景-10" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>对<strong>实时性要求高</strong>，且需要精确控制请求速率的高级限流场景。</p><h4 id="优劣分析-4"><a href="#优劣分析-4" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h4><ul><li><p><strong>优势：</strong></p><ul><li><p>滑动日志能够<strong>避免突发流量</strong>，实现较为精准的限流；</p></li><li><p>更加灵活，能够<strong>支持更加复杂的限流策略</strong>，如多级限流，每分钟不超过100次，每小时不超过300次，每天不超过1000次，我们只需要保存最近24小时所有的请求日志即可实现。</p></li></ul></li><li><p><strong>劣势：</strong>占用存储空间要高于其他限流算法。</p></li></ul><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a><strong>常用工具</strong></h2><h3 id="RateLimiter（单机）"><a href="#RateLimiter（单机）" class="headerlink" title="RateLimiter（单机）"></a>RateLimiter（单机）</h3><h4 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>基于<strong>令牌桶算法</strong>实现的一个多线程限流器，它可以将请求均匀的进行处理，当然他并不是一个分布式限流器，只是对单机进行限流。它可以应用在定时拉取接口数。通过aop、filter、Interceptor 等都可以达到限流效果。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h4><p>以下是一个基本的 RateLimiter 用法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个每秒允许2个请求的RateLimiter</span></span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 请求RateLimiter一个令牌，会阻塞当前线程直到获取到许可</span></span><br><span class="line">            rateLimiter.acquire(); </span><br><span class="line">            <span class="comment">// 执行操作</span></span><br><span class="line">            doSomeLimitedOperation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomeLimitedOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟一些操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Operation executed at: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rateLimiter.acquire()</code> 方法会阻塞当前线程直到获取到许可，确保调用 <code>doSomeLimitedOperation()</code> 操作的频率不会超过限制。</p><p><code>RateLimiter</code> 还提供了其他的方法，例如<code>tryAcquire()</code>，它会尝试获取许可而不会阻塞，立即返回获取成功或失败的结果。还可以设置等待时间上限，比如 <code>tryAcquire(long timeout, TimeUnit unit) </code>可以设置最大等待时间。</p><p>Guava的RateLimiter非常灵活，它支持平滑突发限制（<code>SmoothBursty</code>）和平滑预热限制（<code>SmoothWarmingUp</code>）等多种模式，可以根据特定的应用场景来选择合适的限流策略。</p><h3 id="sentinel（单机或者分布式）"><a href="#sentinel（单机或者分布式）" class="headerlink" title="sentinel（单机或者分布式）"></a>sentinel（单机或者分布式）</h3><h4 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h4><p><code>Sentinel</code>是阿里巴巴开源的一款面向分布式系统的<strong>流量控制和熔断降级组件</strong>。它提供了实时的<strong>流量控制、熔断降级、系统负载保护和实时监控</strong>等功能，可以帮助开发者保护系统的稳定性和可靠性。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250626112616426.png" alt="image-20250626112616426"></p><ul><li><code>DefaultController</code>：是一个非常典型的<strong>滑动窗口计数器</strong>算法实现，将当前统计的qps和请求进来的qps进行求和，小于限流值则通过，大于则计算一个等待时间，稍后再试；</li><li><code>ThrottlingController</code>：是<strong>漏斗算法</strong>的实现，实现思路已经在源码片段中加了备注；</li><li><code>WarmUpController</code>：实现参考了Guava的带预热的RateLimiter，区别是Guava侧重于请求间隔，类似前面提到的<strong>令牌桶</strong>，而Sentinel更关注于请求数，和令牌桶算法有点类似；</li><li><code>WarmUpRateLimiterController</code>：低水位使用<strong>预热算法</strong>，高水位使用<strong>滑动窗口计数器</strong>算法排队。</li></ul><h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a><strong>集群模式</strong></h4><p>Sentinel 集群限流服务端有两种启动方式：</p><ul><li>嵌入模式（Embedded）适合应用级别的限流，部署简单，但对应用性能有影响</li><li>独立模式（Alone）适合全局限流，需要独立部署</li></ul><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a><strong>用法</strong></h4><p>Sentinel的用法主要包括以下几个方面：</p><ol><li><p><strong>引入依赖：</strong>可以使用Maven或Gradle进行依赖管理。例如，在Maven项目的pom.xml文件中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>配置规则：</strong>根据实际需求，配置Sentinel的<strong>流量控制规则、熔断降级规则</strong>等。可以通过编程方式或配置文件方式进行规则的配置。例如，可以在启动类中使用<strong>注解方式</strong>配置流量控制规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(value = &quot;demo&quot;, blockHandler = &quot;handleBlock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>启动Agent：</strong>在应用启动时，启动Sentinel的Agent，开启对系统的流量控制和熔断降级功能的保护。可以通过命令行启动Agent，或者在代码中进行启动。例如，在Spring Boot的启动类中添加如下代码：</p></li><li><pre><code class="java">public static void main(String[] args) &#123;        System.setProperty(&quot;csp.sentinel.dashboard.server&quot;, &quot;localhost:8080&quot;); // 设置控制台地址    System.setProperty(&quot;project.name&quot;, &quot;your-project-name&quot;); // 设置应用名称     com.alibaba.csp.sentinel.init.InitExecutor.doInit();        SpringApplication.run(YourApplication.class, args);&#125;</code></pre></li><li><p><strong>监控和管理：</strong>使用Sentinel的控制台进行<strong>实时监控、配置管理</strong>等操作。可以通过浏览器访问<strong>Sentinel的控制台界面</strong>，查看系统的运行情况和流量控制情况。通过控制台，可以对规则进行动态修改，查看监控数据和告警信息。</p></li></ol><h3 id="Nginx（分布式）"><a href="#Nginx（分布式）" class="headerlink" title="Nginx（分布式）"></a>Nginx（分布式）</h3><h4 id="简介-14"><a href="#简介-14" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>Nginx从网关这一层面考虑，可以作为最前置的网关，抵挡大部分的网络流量，因此使用Nginx进行限流也是一个很好的选择，在Nginx中，也提供了常用的基于限流相关的策略配置。</p><h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a><strong>用法</strong></h4><p>Nginx 提供了两种限流方法：一种是<strong>控制速率</strong>，另一种是<strong>控制并发连接数</strong>。</p><h3 id="控制速率"><a href="#控制速率" class="headerlink" title="控制速率"></a><strong>控制速率</strong></h3><p>我们需要使用 <code>limit_req_zone</code> 用来限制单位时间内的请求数，即速率限制，因为Nginx的限流统计是基于毫秒的，我们设置的速度是 <code>2r/s</code>，转换一下就是500毫秒内单个IP只允许通过1个请求，从501ms开始才允许通过第2个请求。</p><h4 id="控制速率优化版"><a href="#控制速率优化版" class="headerlink" title="控制速率优化版"></a><strong>控制速率优化版</strong></h4><p>上面的速率控制虽然很精准但是在生产环境未免太苛刻了，实际情况下我们应该<strong>控制一个IP单位总时间内的总访问次数</strong>，而不是像上面那样精确到毫秒，我们可以使用 <code>burst</code> 关键字开启此设置。</p><p><code>burst=4</code>意思是<strong>每个IP最多允许4个突发请求</strong></p><h4 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a><strong>控制并发数</strong></h4><p>利用 <code>limit_conn_zone</code> 和 <code>limit_conn</code> 两个指令即可<strong>控制并发数</strong>，其中 <code>limit_conn perip 10</code> 表示<strong>限制单个 IP 同时最多能持有 10 个连接</strong>；<code>limit_conn perserver 100</code> 表示 <strong>server 同时能处理并发连接的总数为 100 个</strong>。</p><p><strong>注意：</strong>只有当 <code>request header</code> 被后端处理后，这个连接才进行计数。﻿</p><hr><h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><h2 id="简介-15"><a href="#简介-15" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>降级是在高并发或异常情况下<strong>舍弃非关键业务或简化处理的一种技术手段</strong>。按类型可分为有感降级，无感降级。</p><ul><li><strong>有感降级：</strong>主要是通过一定的监控感知到异常出现或即将出现，对调用服务进行快速失败返回或者进行切换，在指标回正的时候恢复服务调用，这个也可以称为熔断。</li><li><strong>无感降级：</strong>系统不作感知，在调用服务出现异常则自动忽略，进行空返回或无操作。降级的本质为作为服务调用方去规避提供方带来的风险。</li></ul><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>在限流中，服务调用方为每一个调用的服务维护一个有限状态机，在这个状态机会有三种状态：关闭（调用远程服务）、半打开（尝试调用远程服务）和打开（返回错误）。这三种状态之间切换的过程如下：﻿</p><ul><li>当调用失败的次数累积到一定阈值，熔断机制从关闭态切换到打开态。一般在实现时，如果调用成功一次，就会重置调用失败次数。</li><li>当熔断处于打开状态时，我们会启动一个计时器，当计时器超时后，状态切换到半打开态。也可以通过设置一个定时器，定期的探测服务是否恢复。</li><li>当熔断处于半打开状态时，请求可以达到后端服务，如果累计一定的成功次数后，状态切换到关闭态；如果出现调用失败的情况，则切换到打开态。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250626114727317.png" alt="image-20250626114727317"></p><h2 id="常用工具-1"><a href="#常用工具-1" class="headerlink" title="常用工具"></a><strong>常用工具</strong></h2><ul><li>降级开源组件：<strong>sentinel和Hystrix(不展开)</strong></li><li>手动降级：可采用<strong>系统配置开关</strong>来控制</li></ul><hr><h1 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h1><h2 id="简介-16"><a href="#简介-16" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>熔断在程序中表示“断开”。如发生了某事件，程序为了整体的稳定性，<strong>暂时（断开）停止服务一段时间</strong>，以保证程序可用时再被使用。</p><h2 id="熔断和降级的区别"><a href="#熔断和降级的区别" class="headerlink" title="熔断和降级的区别"></a><strong>熔断和降级的区别</strong></h2><ul><li><p>概念不同</p><ul><li><p>熔断程序为了整体的稳定性，所以暂时（断开）停止服务一段时间；</p></li><li><p>降级（<code>Degradation</code>）降低级别的意思，它是指程序在出现问题时，<strong>仍能保证有限功能可用</strong>的一种机制；</p></li></ul></li><li><p>触发条件不同</p><p>不同框架的熔断和降级的触发条件是不同，以<code>Hystrix</code>为例：</p><ul><li><p>Hystrix 熔断触发条件</p><ul><li>默认情况 hystrix 如果检测到 10 秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求。</li></ul></li><li><p>Hystrix 降级触发条件</p><ul><li><p>默认情况下，Hystrix 在以下 4 种条件下都会触发降级机制：</p><ul><li><p>方法抛出 <code>HystrixBadRequestException</code></p></li><li><p>方法<strong>调用超时</strong></p></li><li><p>熔断器开启拦截调用</p></li><li><p><strong>线程池或队列或信号量已满</strong></p></li></ul></li></ul></li></ul></li><li><p>归属关系不同</p><p>熔断时可能会调用降级机制，而降级时通常不会调用熔断机制。因为熔断是从全局出发，为了保证系统稳定性而停用服务，而降级是退而求其次，提供一种保底的解决方案，所以它们的归属关系是不同的（熔断 &gt; 降级）。</p></li></ul>]]></content>
    
    
    <summary type="html">高性能、高并发、高可用是现代系统设计中的三个重要指标，它们共同决定了一个系统在不同场景下的表现。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>高性能、高并发、高可用、高安全</title>
    <link href="https://southernfish.github.io/2025/06/25/framwork/system-design/"/>
    <id>https://southernfish.github.io/2025/06/25/framwork/system-design/</id>
    <published>2025-06-25T05:27:36.000Z</published>
    <updated>2025-07-10T12:47:35.022Z</updated>
    
    <content type="html"><![CDATA[<p>高性能、高并发、高可用是构建现代大规模系统的三个关键目标，它们各自解决不同的问题，但在实际系统中往往需要综合考虑，互为补充。例如，高并发可能会带来性能瓶颈，而高可用需要在性能和资源消耗之间找到平衡。通过合理的架构设计和技术选型，可以构建出既能应对大量并发请求，又具有快速响应和高可用性的系统。参考文章链接：<a href="https://blog.csdn.net/yanwenwennihao/article/details/141677135">高性能、高并发、高可用</a>、<a href="https://cloud.tencent.com/developer/article/2441609">高并发、高性能、高可用、高安全架构设计</a>、<a href="https://www.cnblogs.com/beatle-go/p/18302270">程序员的三高：高并发、高性能、高可用</a></p><h1 id="高性能（High-Performance）"><a href="#高性能（High-Performance）" class="headerlink" title="高性能（High Performance）"></a>高性能（High Performance）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>高性能指的是系统在处理请求时能够以最快的速度响应（<strong>程序处理速度非常快，所占内存少，cpu占用率低</strong>）。性能通常与系统的<strong>吞吐量和响应时间</strong>相关联。高性能系统能够在单位时间内处理大量请求，并在尽可能短的时间内提供响应。应用性能优化的时候，对于计算密集型和IO密集型还是有很大差别，需要分开来考虑。还可以增加服务器数量，内存，IO等参数提升系统的并发能力和性能，但不要浪费资源，要考虑硬件的使用率最高才能发挥到极致。</p><h2 id="关键指标"><a href="#关键指标" class="headerlink" title="关键指标"></a><strong>关键指标</strong></h2><ul><li><strong>吞吐量（<code>Throughput</code>）：</strong>系统在单位时间内处理的请求数量。通常以每秒请求数（<code>Requests Per Second, RPS</code>）或每秒事务数（<code>Transactions Per Second, TPS</code>）来衡量。</li><li><strong>响应时间（Response Time）：</strong>系统对请求进行反应的时间，及<strong>从发出请求到收到响应</strong>所需的时间，常以毫秒（ms）为单位。</li><li><strong>延迟（Latency）：</strong>系统中<strong>请求等待被处理的时间</strong>。高延迟会导致用户体验变差。</li></ul><h2 id="实现手段"><a href="#实现手段" class="headerlink" title="实现手段"></a><strong>实现手段</strong></h2><p>提高性能需要考虑，避免因为IO阻塞让CPU闲置，导致CPU的浪费，避免多线程间增加锁来保证同步，导致并行系统串行化，避免创建、销毁、维护太多进程、线程，导致操作系统浪费资源在调度上。具体如下等方面：</p><ul><li><p><strong>优化算法：</strong>使用更<strong>高效的数据结构和算法</strong>，减少时间复杂度。</p></li><li><p><strong>数据库性能优化：</strong></p><ul><li><strong>索引优化：</strong>创建适当的索引可以大幅提升查询效率。但需要注意索引的创建和维护成本，避免过多的索引影响写入性能。</li><li><strong>查询优化：</strong>优化SQL查询，避免全表扫描，尽量使用<code>JOIN</code>代替子查询，减少不必要的数据传输。</li><li><strong>数据库缓存：</strong>使用数据库缓存可以减少对数据库的访问次数，提高查询速度。</li><li><strong>数据库分区：</strong>将数据库分成多个分区，可以提高查询速度和可扩展性。</li><li><strong>数据库读写分离：</strong>将数据库的读操作和写操作分离到不同的服务器上，可以提高系统的吞吐量和并发处理能力。</li></ul></li><li><p><strong>缓存：</strong>通过在内存中存储常用数据，减少对数据库的访问，提高读取速度，提升热点数据的访问性能。</p><ul><li><p><strong>数据缓存：</strong>使用缓存（如<code>Redis</code>、<code>Memcached</code>）可以显著提高系统的响应速度。常见的<strong>缓存策略</strong>有<code>LRU（Least Recently Used）</code>、<code>LFU（Least Frequently Used）</code>。</p></li><li><p><strong>页面缓存：</strong>对于不经常变化的页面，可以使用CDN（Content Delivery Network）进行缓存，减少服务器压力。</p></li><li><p><strong>缓存根据性能由高到低分为：</strong><code>寄存器</code>、<code>L1缓存</code>、<code>L2缓存</code>、<code>L3缓存</code>、<code>本地内存</code>、<code>分布式缓存</code></p><ul><li>上层的寄存器、L1 缓存、L2 缓存是<strong>位于 CPU 核内的高速缓存</strong>，访问延迟通常在 10 纳秒以下。</li><li>L3 缓存是<strong>位于 CPU 核外部但在芯片内部的共享高速缓存</strong>，访问延迟通常在十纳秒左右。<strong>高速缓存</strong>具有成本高、容量小的特点，容量最大的 L3 缓存通常也只有几十MB。</li><li>本地内存是<strong>计算机内的主存储器</strong>，相比 CPU 芯片内部的高速缓存，内存的成本要低很多，容量通常是 GB 级别，访问延迟通常在几十到几百纳秒。</li></ul></li><li><p><strong>注意：</strong>内存和高速缓存都属于<strong>掉电易失的存储器</strong>，如果机器断电了，这类存储器中的数据就丢失了。</p></li></ul></li><li><p><strong>异步处理：</strong>将一些耗时操作（如 I/O 操作）放在后台异步执行，不阻塞主线程。</p><ul><li><strong>消息队列：</strong>使用消息队列（如<code>RabbitMQ</code>、<code>Kafka</code>）可以实现异步处理，解耦系统的各个组件。消息队列可以<strong>缓冲突发的请求</strong>，确保系统的稳定性。</li><li><strong>异步任务：</strong>通过异步任务处理（如<code>Celery</code>、<code>Resque</code>），可将<strong>不需要即时响应的任务放到后台处理</strong>，减少前端请求的响应时间。</li></ul></li><li><p><strong>资源利用优化：</strong>包括 <code>CPU</code>、<code>内存</code>、<code>磁盘 I/O</code> 的<strong>高效使用</strong>，以及<strong>减少上下文切换和锁争用</strong>。</p></li><li><p><strong>网络性能优化：</strong></p><ul><li><strong>减少网络延迟：</strong>通过CDN加速、内容压缩、减少HTTP请求等手段可以有效减少网络延迟。</li><li><strong>使用HTTP/2：</strong>HTTP/2支持多路复用、头部压缩等特性，可以显著提高网络传输效率。</li></ul></li><li><p><strong>服务性能优化</strong></p><ul><li><em>服务拆分：*<em>将单体应用拆分为微服务，各服务独立部署和扩展，可以提高整体系统的灵活性和性能。</em></em></li><li>服务降级：**在高并发场景下，对一些非核心服务进行降级处理，可以保证核心功能的稳定运行。</li></ul></li><li><p><strong>负载均衡（<code>Load Balancing</code>）</strong>：分散请求到多个服务器上，避免单个服务器过载。</p><ul><li>常用的<strong>负载均衡策略</strong>有<code>轮询</code>、<code>最少连接</code>、<code>源地址哈希</code>等。<a href="https://cloud.tencent.com/product/clb?from_column=20065&from=20065">负载均衡器</a>（如<code>Nginx</code>、<code>HAProxy</code>）。</li></ul></li></ul><h1 id="高并发（High-Concurrency）"><a href="#高并发（High-Concurrency）" class="headerlink" title="高并发（High Concurrency）"></a>高并发（High Concurrency）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>高并发指的是系统能够同时处理大量请求或操作的能力。在互联网应用中，用户可能会同时访问某个功能，这就要求系统能够同时处理多个用户的请求而不发生性能下降。</p><h2 id="关键指标-1"><a href="#关键指标-1" class="headerlink" title="关键指标"></a>关键指标</h2><ul><li><strong>并发用户数：</strong>同时承载正常使用系统功能的用户数量。</li><li><strong>并发事务数：</strong>系统能够同时处理的事务数量。</li><li><strong>QPS（Queries Per Second）：</strong>每秒钟系统处理的查询数量，反映了系统的并发处理能力。</li><li><strong>秒查询率（Queries Per Second，QPS）：</strong>每秒响应请求数，和吞吐量差不多，用于来<strong>衡量系统承载能力</strong>。</li></ul><h2 id="实现手段-1"><a href="#实现手段-1" class="headerlink" title="实现手段"></a>实现手段</h2><ul><li><strong>线程池：</strong>使用线程池技术复用线程资源，避免频繁创建和销毁线程，提升并发处理能力。</li><li><strong>无锁并发编程：</strong>减少锁的使用，或使用无锁数据结构，避免因锁竞争导致的性能瓶颈。</li><li><strong>消息队列：</strong>通过消息队列异步处理请求，削峰填谷，平滑系统的并发压力。</li><li><strong>水平扩展（<code>Horizontal Scaling</code>）：</strong>通过增加服务器节点的方式来处理更多的并发请求。<ul><li>相比之下，<strong>垂直扩展（<code>Vertical Scaling</code>）</strong>是通过增加单个服务器的硬件能力。<strong>水平扩展更具灵活性和可扩展性</strong>。</li></ul></li><li><strong>分布式架构：</strong>将系统功能分布到多个节点上，分担并发请求的压力。</li><li><strong>限流和熔断：</strong>在高并发情况下，保护系统不被突发的流量压垮，限流策略确保核心服务的稳定性。</li></ul><h1 id="高可用（High-Availability）"><a href="#高可用（High-Availability）" class="headerlink" title="高可用（High Availability）"></a>高可用（High Availability）</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>高可用指的是系统能够长时间持续稳定运行，并在出现故障时能够迅速恢复，以最小的停机时间提供服务。高可用性是衡量系统可靠性的关键指标。</p><h2 id="关键指标-2"><a href="#关键指标-2" class="headerlink" title="关键指标"></a>关键指标</h2><ul><li><strong>可用性（Availability）：</strong>系统在规定时间内可用的时间占比，通常以百分比表示。<ul><li>例如：99.9% 的可用性意味着系统每年最多停机约8小时45分钟。</li></ul></li><li><strong>故障切换时间（Failover Time）：</strong>当发生故障时，系统切换到备份系统或方案所需的时间。</li><li><strong>平均故障间隔时间（Mean Time Between Failures，MTBF）：</strong>系统在故障间的平均正常运行时间。</li><li><strong>平均修复时间（Mean Time to Repair，MTTR）：</strong>系统从故障到恢复正常服务的平均时间。</li></ul><h2 id="实现手段-2"><a href="#实现手段-2" class="headerlink" title="实现手段"></a>实现手段</h2><ul><li><strong>冗余设计：</strong>通过引入冗余（如双机热备、集群冗余等），在一个节点或组件故障时，另一个节点或组件可以无缝接管。</li><li><strong>故障转移（Failover）：</strong>在主服务器发生故障时，自动将请求转移到备份服务器上，保证服务的连续性。步骤如下：<ul><li><strong>1、故障自动侦测（<code>Auto-detect</code>）：</strong>采用健康检查、心跳等技术手段自动侦测故障节点；</li><li><strong>2、自动转移（<code>FailOver</code>）：</strong>当侦测到故障节点后，采用摘除流量、脱离集群等方式隔离故障节点，将流量转移到正常节点</li><li><strong>3、自动恢复（<code>FailBack</code>）：</strong>当故障节点恢复正常后，自动将其加入集群中，确保集群资源与故障前一致。</li></ul></li><li><strong>容错设计：</strong>设计系统时考虑各种可能的故障，并提供应对机制，如数据副本、自动重试等。<ul><li>如redis的高可用的集群方案： Redis单副本，Redis多副本（主从），Redis Sentinel（哨兵），Redis Cluster，Redis自研。</li></ul></li><li><strong>自动化运维：</strong>通过自动化脚本和工具，快速检测并修复故障，减少人为操作带来的误差和延迟。<ul><li><strong>自动化部署：</strong>使用容器化技术（如<code>Docker</code>、<code>Kubernetes</code>）实现自动化部署和管理，提高运维效率。</li><li><strong>自动化监控：</strong>通过监控系统（如<code>Prometheus</code>、<code>Zabbix</code>）实时监控系统状态，发现问题及时告警和处理。</li></ul></li><li><strong>分布式系统：</strong>将服务部署在多个地理位置或数据中心，防止单点故障带来的整体服务中断。<ul><li><strong>多数据中心：</strong>在不同的地理位置部署多个数据中心，实现跨区域的服务冗余和故障切换。</li><li><strong>主从切换：</strong>使用主从复制技术（如MySQL的主从复制）实现数据库的高可用，主库故障时可以切换到从库。</li></ul></li><li><strong>数据备份和恢复：</strong>定期备份数据，并提供快速的数据恢复机制，确保在数据损坏或丢失时能够迅速恢复。<ul><li><strong>数据备份：</strong>定期进行数据备份，确保在数据丢失或损坏时能够快速恢复。</li><li><strong>灾难恢复：</strong>制定详细的灾难恢复计划，模拟灾难场景进行演练，确保系统在灾难发生时能够迅速恢复。</li></ul></li><li><strong>过载保护：负载超过系统的承载能力时，系统会自动采取保护措施，确保自身不被压垮</strong><ul><li><strong>熔断：</strong>系统濒临崩溃的时候，<strong>立即中断服务</strong>，从而保障系统稳定避免崩溃。它类似于电器中的“保险丝”，当电流过大的时候，“保险丝”会先被烧掉，断开电流，以免电路过热烧毁电器引起火灾。</li><li><strong>限流：</strong>原理跟熔断有点类似，都是通过判断某个条件来确定是否执行某个策略。但它只处理自己能力范围之内的请求，<strong>超量的请求会被限流</strong>。限流算法：<code>计数器限流</code>、<code>滑动窗口限流</code>、<code>令牌桶限流</code>、<code>漏桶限流</code>。</li></ul></li><li><strong>降级：</strong>对<strong>非核心的功能</strong>进行降级 ，降低系统压力。 弃车保帅， 保证核心功能的正常使用 。</li></ul><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><ul><li><strong>内容分发网络（<code>CDN</code>）：</strong>内容分发网络通过在全球多个节点上分发内容，提高访问速度和可用性，防止单一节点故障影响用户访问。</li><li><strong>负载均衡：</strong>通过负载均衡器，将流量分发到多台服务器，确保即使某一台服务器出现故障，系统整体仍能继续服务。</li></ul><h1 id="高安全（High-Safety）"><a href="#高安全（High-Safety）" class="headerlink" title="高安全（High Safety）"></a>高安全（High Safety）</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>高安全是指系统能够保护用户数据和系统资源的安全，防止未经授权的访问和攻击。</p><h2 id="实现手段-3"><a href="#实现手段-3" class="headerlink" title="实现手段"></a>实现手段</h2><ul><li><strong>网络安全</strong><ul><li><strong>防火墙：</strong>配置防火墙（如<code>iptables</code>）限制不必要的网络访问，保护内部网络安全。</li><li><strong>入侵检测：</strong>部署入侵检测系统（如<code>Snort</code>、<code>Suricata</code>），实时监控和分析网络流量，发现潜在的入侵行为。</li></ul></li><li><strong>数据安全</strong><ul><li><strong>数据加密：</strong>对敏感数据进行加密存储和传输，防止数据泄露和篡改。例如，可使用 <code>SSL/TLS</code> 协议对通信内容进行加密。</li><li><strong>访问控制：</strong>通过权限控制（如<code>RBAC</code>、<code>ABAC</code>）确保只有授权用户才能访问敏感数据和功能。</li></ul></li><li><strong>应用安全</strong><ul><li><strong>身份验证：</strong>采用多因素身份验证（<code>MFA</code>）增加用户身份验证的安全性。</li><li><strong>防御常见攻击：</strong>防御常见的网络攻击（如<code>SQL注入</code>、<code>XSS</code>、<code>CSRF</code>），使用安全编码实践和<a href="https://cloud.tencent.com/product/waf?from_column=20065&from=20065">Web应用防火墙</a>（WAF）。</li></ul></li><li><strong>安全审计</strong><ul><li><strong>日志记录：</strong>记录关键操作日志，便于事后分析和审计。</li><li><strong>安全扫描：</strong>定期进行安全扫描和漏洞检测，及时修复发现的安全隐患。比如，可以使用<strong>漏洞扫描工具</strong>（如 <code>Nessus</code>）来定期扫描系统中的漏洞，并及时进行修复，防止攻击者利用漏洞进行攻击。</li><li><strong>安全监控：</strong>使用安全监控工具（如<code>Nagios</code>）实时监控系统的运行状态，可以及时发现安全事件，并采取相应的措施进行处理</li></ul></li></ul>]]></content>
    
    
    <summary type="html">高性能、高并发、高可用是现代系统设计中的三个重要指标，它们共同决定了一个系统在不同场景下的表现。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>java的加密方式</title>
    <link href="https://southernfish.github.io/2025/06/24/java/java-encription/"/>
    <id>https://southernfish.github.io/2025/06/24/java/java-encription/</id>
    <published>2025-06-24T09:53:36.000Z</published>
    <updated>2025-07-10T12:47:35.023Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，加密英文文本通常涉及到使用加密算法，比如对称加密（如AES）或非对称加密（如RSA）。本文整理了几种java常用的几种加密方法。本文转载自：<a href="https://blog.csdn.net/wa_ka_ka/article/details/148293941">Java常用加密方式</a></p><h1 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a>加密算法分类</h1><ul><li><strong>对称加密：</strong>指加密和解密的密钥相同，优点就是加解密的效率高且易于实现。</li><li><strong>非对称加密：</strong>指加密和解密的密钥不相同，也称为公私要加密。</li><li><strong>不可逆加密：</strong>特征就是加密过程不需要密钥，并且加密后的数据不能被解密，只能输入同样的数据并且经过同样的不可逆加密算法才能获取同样的加密数据。</li></ul><h1 id="加密算法的应用"><a href="#加密算法的应用" class="headerlink" title="加密算法的应用"></a>加密算法的应用</h1><ul><li><strong>数字签名：</strong>进行身份认证和数据完整性验证，主要用到了非对称密钥加密技术与数字摘要技术。</li><li><strong>数字证书：</strong>主要用来确保数字签名是安全有效的，数字证书由独立的证书发行机构发布。数字证书各不相同，每种证书可提供不同级别的可信度，该证书内包含用户的个人信息和他的公钥信息，同时还附有认证中心的签名信息。</li><li><strong>MD5：</strong>对用户密码进行加密并进行保存。</li><li><strong>网络数据加密：</strong>保障传输的数据安全，即使被截获报文，在没有密匙的情况下也无法得知报文真实内容。</li><li><strong>SSL协议：</strong>在<strong>握手阶段使用的是非对称加密</strong>，在<strong>传输阶段使用的是对称加密</strong>，即在SSL上传送的数据是使用对称密钥加密的。同时HTTPS也是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证（确认客户端连接的目标主机是否是真实正确的主机）的网络协议。</li></ul><h1 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h1><ul><li><strong>优点：</strong>算法对消息双方公开、计算量小、加解密速度快、效率高。</li><li><strong>缺点：</strong>在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。如果一方的秘钥被泄露，那么加密信息就会被破解。</li></ul><h2 id="DES介绍"><a href="#DES介绍" class="headerlink" title="DES介绍"></a>DES介绍</h2><p>DES全称为<code>Data Encryption Standard</code>，即<strong>数据加密标准</strong>，是一种<strong>使用密钥加密的<code>块算法</code><strong>，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（<code>FIPS</code>），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。但是近些年使用越来越少，因为</strong>DES使用56位密钥</strong>，以现代计算能力，24小时内即可被破解。DES加密和解密过程中，**密钥长度都必须是<code>8的倍数</code>**。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DESHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encrypt</span><span class="params">(String dataSource, String password)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// DES算法要求有一个可信任的随机数源</span></span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">        <span class="type">DESKeySpec</span> <span class="variable">desKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESKeySpec</span>(password.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 创建一个密钥工厂，然后用它对desKey进行转换</span></span><br><span class="line">        <span class="type">SecretKeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyFactory.generateSecret(desKey);</span><br><span class="line">        <span class="comment">// Cipher对象实际完成加密操作</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        <span class="comment">// 用密钥初始化Cipher对象，ENCRYPT_MODE用于将Cipher初始化为加密模式的常量</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,secretKey,random);</span><br><span class="line">        <span class="comment">// 正式对数据进行加密操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cipher.doFinal(dataSource.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decrypt</span><span class="params">(String src, String password)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">        <span class="type">DESKeySpec</span> <span class="variable">desKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESKeySpec</span>(password.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">SecretKeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyFactory.generateSecret(desKey);</span><br><span class="line">        <span class="comment">// Cipher对象实际完成解密操作</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE,secretKey,random);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cipher.doFinal(src.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加解密测试:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DESTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">DESHelper</span> <span class="variable">desHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESHelper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;原始数据：&quot;</span>+source);</span><br><span class="line">    <span class="type">byte</span>[] encryptData = desHelper.encrypt(source, <span class="string">&quot;1qaz2wsx&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;加密后数据：&quot;</span>+encryptData);</span><br><span class="line">    <span class="type">byte</span>[] decryptData = desHelper.decrypt(encryptData, <span class="string">&quot;1qaz2wsx&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;解密后数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(decryptData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IDEA介绍"><a href="#IDEA介绍" class="headerlink" title="IDEA介绍"></a>IDEA介绍</h2><ul><li>这种算法是在DES算法的基础上发展出来的，类似于<strong>三重DES</strong>。</li><li>发展IDEA也是因为感到DES具有密钥太短等缺点。</li><li><strong>DEA的密钥为128位</strong>，这么长的密钥在今后若干年内应该是安全的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDEAHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;IDEA&quot;</span>; <span class="comment">// 密钥算法</span></span><br><span class="line">    <span class="comment">// 加密、解密算法、工作模式、填充方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CIPHER_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;IDEA/ECB/ISO10126Padding&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥，只有bouncycastle支持</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[] 二进制密钥</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] initKey() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>()); <span class="comment">// 加入bouncyCastle支持</span></span><br><span class="line">        <span class="type">KeyGenerator</span> <span class="variable">kg</span> <span class="operator">=</span> KeyGenerator.getInstance(KEY_ALGORITHM);  <span class="comment">// 实例化密钥生成器</span></span><br><span class="line">        kg.init(<span class="number">128</span>); <span class="comment">// 初始化密钥生成器，IDEA要求密钥长度为128位</span></span><br><span class="line">        SecretKey secretKey=kg.generateKey(); <span class="comment">// 生成密钥</span></span><br><span class="line">        <span class="keyword">return</span> secretKey.getEncoded(); <span class="comment">// 获取二进制密钥编码形式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 二进制密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Key 密钥</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title function_">toKey</span><span class="params">(<span class="type">byte</span>[] key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key,KEY_ALGORITHM); <span class="comment">// 实例化DES密钥</span></span><br><span class="line">        <span class="keyword">return</span> secretKey; <span class="comment">// 生成密钥</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[] 加密后的数据</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encrypt(<span class="type">byte</span>[] data,<span class="type">byte</span>[] key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>()); <span class="comment">// 加入bouncyCastle支持</span></span><br><span class="line">        <span class="type">Key</span> <span class="variable">k</span> <span class="operator">=</span> toKey(key); <span class="comment">// 还原密钥</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM); <span class="comment">// 实例化</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, k);  <span class="comment">// 初始化，设置为加密模式</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data); <span class="comment">// 执行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[] 解密后的数据</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] data,<span class="type">byte</span>[] key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>()); <span class="comment">// 加入bouncyCastle支持</span></span><br><span class="line">        <span class="type">Key</span> <span class="variable">k</span> <span class="operator">=</span> toKey(key); <span class="comment">// 还原密钥</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, k); <span class="comment">// 初始化，设置为解密模式</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data); <span class="comment">// 执行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加解密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">IDEATest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;原始数据：&quot;</span>+str);</span><br><span class="line">    <span class="type">byte</span>[] key = IDEAHelper.initKey(); <span class="comment">// 初始化密钥</span></span><br><span class="line">    System.out.println(<span class="string">&quot;密钥：&quot;</span>+ Base64.encodeBase64String(key));</span><br><span class="line">    <span class="type">byte</span>[] data = IDEAHelper.encrypt(str.getBytes(), key); <span class="comment">// 加密数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;加密后数据：&quot;</span>+Base64.encodeBase64String(data));</span><br><span class="line">    data=IDEAHelper.decrypt(data, key);</span><br><span class="line">    System.out.println(<span class="string">&quot;解密后数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h1><ul><li><strong>优点：</strong>非对称加密与对称加密相比其安全性更好，只要私钥不泄露，很难被破解。</li><li><strong>缺点：</strong>加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</li></ul><h2 id="RSA介绍"><a href="#RSA介绍" class="headerlink" title="RSA介绍"></a>RSA介绍</h2><p>RSA是目前最有影响力和最常用的<strong>公钥加密算法</strong>。它能够抵抗到目前为止已知的绝大多数密码攻击，<strong>已被ISO推荐为公钥数据加密标准</strong>。<strong>RSA公开密钥密码体制的原理是：</strong>根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RSAHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SIGNATURE_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;MD5withRSA&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PUBLIC_KEY</span> <span class="operator">=</span> <span class="string">&quot;RSAPublicKey&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PRIVATE_KEY</span> <span class="operator">=</span> <span class="string">&quot;RSAPrivateKey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptBASE64(String key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.decodeBase64(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptBASE64</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用私钥对信息生成数字签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sign</span><span class="params">(<span class="type">byte</span>[] data, String privateKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 解密由base64编码的私钥</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(privateKey);</span><br><span class="line">        <span class="comment">// 构造PKCS8EncodedKeySpec对象</span></span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="comment">// KEY_ALGORITHM 指定的加密算法</span></span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">// 取私钥匙对象</span></span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">priKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 用私钥对信息生成数字签名</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        signature.initSign(priKey);</span><br><span class="line">        signature.update(data);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(signature.sign());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验数字签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sign 数字签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 校验成功返回true 失败返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(<span class="type">byte</span>[] data, String publicKey, String sign)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 解密由base64编码的公钥</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(publicKey);</span><br><span class="line">        <span class="comment">// 构造X509EncodedKeySpec对象</span></span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="comment">// KEY_ALGORITHM 指定的加密算法</span></span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">// 取公钥匙对象</span></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">pubKey</span> <span class="operator">=</span> keyFactory.generatePublic(keySpec);</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        signature.initVerify(pubKey);</span><br><span class="line">        signature.update(data);</span><br><span class="line">        <span class="comment">// 验证签名是否正常</span></span><br><span class="line">        <span class="keyword">return</span> signature.verify(decryptBASE64(sign));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptByPrivateKey(<span class="type">byte</span>[] data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得私钥</span></span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="type">Key</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 对数据解密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用私钥解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptByPrivateKey(String data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> decryptByPrivateKey(decryptBASE64(data), key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用公钥解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptByPublicKey(<span class="type">byte</span>[] data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得公钥</span></span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">x509KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="type">Key</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        <span class="comment">// 对数据解密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用公钥加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encryptByPublicKey(String data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对公钥解密</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得公钥</span></span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">x509KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="type">Key</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        <span class="comment">// 对数据加密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用私钥加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encryptByPrivateKey(<span class="type">byte</span>[] data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得私钥</span></span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="type">Key</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 对数据加密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPrivateKey</span><span class="params">(Map&lt;String, Key&gt; keyMap)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> (Key) keyMap.get(PRIVATE_KEY);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPublicKey</span><span class="params">(Map&lt;String, Key&gt; keyMap)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> keyMap.get(PUBLIC_KEY);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Key&gt; <span class="title function_">initKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGen</span> <span class="operator">=</span> KeyPairGenerator.getInstance(KEY_ALGORITHM);</span><br><span class="line">        keyPairGen.initialize(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGen.generateKeyPair();</span><br><span class="line">        Map&lt;String, Key&gt; keyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">2</span>);</span><br><span class="line">        keyMap.put(PUBLIC_KEY, keyPair.getPublic());<span class="comment">// 公钥</span></span><br><span class="line">        keyMap.put(PRIVATE_KEY, keyPair.getPrivate());<span class="comment">// 私钥</span></span><br><span class="line">        <span class="keyword">return</span> keyMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加解密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RSATest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Map&lt;String, Key&gt; keyMap = initKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">publicKey</span> <span class="operator">=</span> getPublicKey(keyMap);</span><br><span class="line">    <span class="type">String</span> <span class="variable">privateKey</span> <span class="operator">=</span> getPrivateKey(keyMap);</span><br><span class="line">    System.out.println(<span class="string">&quot;公钥：&quot;</span> + publicKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;私钥：&quot;</span> + privateKey);</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;原始数据：&quot;</span> + src);</span><br><span class="line">    <span class="type">byte</span>[] encryptByPrivateKey = encryptByPrivateKey(src.getBytes(), privateKey);</span><br><span class="line">    <span class="type">byte</span>[] encryptByPublicKey = encryptByPublicKey(src, publicKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;私钥加密后数据&quot;</span> + encryptByPrivateKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;公钥加密后数据&quot;</span> + encryptByPublicKey);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> sign(encryptByPrivateKey, privateKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;数字签名：&quot;</span> + sign);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">verify</span> <span class="operator">=</span> verify(encryptByPrivateKey, publicKey, sign);</span><br><span class="line">    System.out.println(<span class="string">&quot;签名验证结果：&quot;</span> + verify);</span><br><span class="line">    <span class="type">byte</span>[] decryptByPublicKey = decryptByPublicKey(encryptByPrivateKey, publicKey);</span><br><span class="line">    <span class="type">byte</span>[] decryptByPrivateKey = decryptByPrivateKey(encryptByPublicKey, privateKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;公钥解密私钥加密后的数据：&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(decryptByPublicKey));</span><br><span class="line">    System.out.println(<span class="string">&quot;私钥解密公钥加密后的数据：&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(decryptByPrivateKey));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不可逆算法"><a href="#不可逆算法" class="headerlink" title="不可逆算法"></a>不可逆算法</h1><h2 id="MD5介绍"><a href="#MD5介绍" class="headerlink" title="MD5介绍"></a>MD5介绍</h2><p>MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（也就是把一个任意长度的字节串变换成一定长的十六进制数字串）。主要有以下特点：</p><ol><li><strong>压缩性：</strong> 任意长度的数据，算出的MD5值长度都是固定的。</li><li><strong>容易计算：</strong> 从原数据计算出MD5值很容易。</li><li><strong>抗修改性：</strong> 对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li><li><strong>强抗碰撞：</strong> 已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MD5Helper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String s)</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md5</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] md5Bytes = md5.digest(s.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">return</span> md5ToString(md5Bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将md5数组转化为16进制字符串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">md5ToString</span><span class="params">(<span class="type">byte</span>[] md5Bytes)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">hexValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; md5Bytes.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> md5Bytes[i] &amp; <span class="number">0Xff</span>;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; <span class="number">16</span>)&#123;</span><br><span class="line">                hexValue.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            hexValue.append(Integer.toHexString(val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexValue.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MD5Test</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">    <span class="type">MD5Helper</span> <span class="variable">md5Helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MD5Helper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">src1</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src2</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;src1 加密后数据：&quot;</span> + md5Helper.encode(src1));</span><br><span class="line">    System.out.println(<span class="string">&quot;src2 加密后数据：&quot;</span> + md5Helper.encode(src2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SHA1介绍"><a href="#SHA1介绍" class="headerlink" title="SHA1介绍"></a>SHA1介绍</h2><p>对于长度小于<code>2^64位</code>的消息，SHA1会产生<strong>一个160位(40个字符)的消息摘要</strong>。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。SHA1有如下<strong>特性</strong>：</p><ul><li>不可以从消息摘要中复原信息；</li><li>两个不同的消息不会产生同样的消息摘要，(但会有1x10 ^ 48分之一的机率出现相同的消息摘要,一般使用时忽略)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SHA1Helper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String str)</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == str || str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="type">char</span>[] hexDigits = &#123; <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span> &#125;;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">mdTemp</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA1&quot;</span>); <span class="comment">// 创建SHA1算法消息摘要对象</span></span><br><span class="line">        mdTemp.update(str.getBytes(StandardCharsets.UTF_8)); <span class="comment">// 使用指定的字节数组更新摘要</span></span><br><span class="line">        <span class="type">byte</span>[] md = mdTemp.digest(); <span class="comment">// 生成hash值的字节数组</span></span><br><span class="line">        <span class="comment">// SHA1算法生成信息摘要的关键过程</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> md.length;</span><br><span class="line">        <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[j*<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">byte0</span> <span class="operator">=</span> md[i];</span><br><span class="line">            buf[k++] = hexDigits[byte0 &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0xf</span>];</span><br><span class="line">            buf[k++] = hexDigits[byte0 &amp; <span class="number">0xf</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SHA1Test</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">    <span class="type">SHA1Helper</span> <span class="variable">sha1Helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SHA1Helper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">src1</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src2</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;src1 加密后数据：&quot;</span> + sha1Helper.encode(src1));</span><br><span class="line">    System.out.println(<span class="string">&quot;src2 加密后数据：&quot;</span> + sha1Helper.encode(src2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HMAC-介绍"><a href="#HMAC-介绍" class="headerlink" title="HMAC 介绍"></a>HMAC 介绍</h2><p>HMAC 是密钥相关的<strong>哈希运算消息认证码</strong>（<code>Hash-based Message Authentication Code</code>），HMAC 运算利用 <strong>哈希算法</strong> (MD5、SHA1 等)，<strong>以 <code>一个密钥 和 一个消息</code> 为输入，生成一个 <code>消息摘要</code> 作为 输出。</strong>HMAC 发送方 和 接收方 都有的 key 进行计算，而没有该 key 的第三方，则 无法计算 出正确的 散列值，这样就可以 防止数据被篡改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HMACHelper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mac mac;</span><br><span class="line">    <span class="comment">// MAC算法可选以下多种算法：HmacMD5/HmacSHA1/HmacSHA256/HmacSHA384/HmacSHA512</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_MAC</span> <span class="operator">=</span> <span class="string">&quot;HmacMD5&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HMACHelper</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key.getBytes(StandardCharsets.UTF_8), KEY_MAC);</span><br><span class="line">        mac = Mac.getInstance(secretKey.getAlgorithm());</span><br><span class="line">        mac.init(secretKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sign</span><span class="params">(String content)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(mac.doFinal(content.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(String signature, String content)</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] result = mac.doFinal(content.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(result, signature.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">HMACTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HMACHelper</span> <span class="variable">hmacHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HMACHelper</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] signature = hmacHelper.sign(src);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> hmacHelper.verify(signature, src);</span><br><span class="line">    System.out.println(<span class="string">&quot;src 生成数字签名：&quot;</span> + signature);</span><br><span class="line">    System.out.println(<span class="string">&quot;签名验证结果：&quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在Java中，加密英文文本通常涉及到使用加密算法，比如对称加密（如AES）或非对称加密（如RSA）。本文整理了几种java常用的几种加密方法。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>超文本传输协议HTTP、HTTPS</title>
    <link href="https://southernfish.github.io/2025/06/24/framwork/http-and-https/"/>
    <id>https://southernfish.github.io/2025/06/24/framwork/http-and-https/</id>
    <published>2025-06-24T07:06:36.000Z</published>
    <updated>2025-07-10T12:47:35.021Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理了一些关于HTTP和HTTPS的相关内容。‌ 参考文章链接： <a href="https://blog.csdn.net/molangmolang/article/details/147905987">http和https的区别？（详细图文讲解）</a></p><h1 id="什么是-HTTP、HTTPS"><a href="#什么是-HTTP、HTTPS" class="headerlink" title="什么是 HTTP、HTTPS"></a>什么是 HTTP、HTTPS</h1><p><code>HTTP</code>（超文本传输协议，<code>Hypertext Transfer Protocol</code>）是一种用于<strong>分布式、协作式、超媒体信息系统</strong>的应用层协议。它允许客户端（如浏览器）与服务器之间进行通信，以请求和传输网页、图片、视频等资源。HTTP <strong>基于请求-响应模型</strong>，客户端发送请求到服务器，服务器处理请求后返回响应。</p><p><code>HTTPS</code>（安全超文本传输协议，<code>Hypertext Transfer Protocol Secure</code>）是 HTTP 的安全版本，通过在 HTTP 的基础上添加 <code>SSL/TLS（安全套接字层/传输层安全性）</code>协议来实现数据加密和安全传输。HTTPS 不仅能够传输数据，还能<strong>确保数据的机密性、完整性和身份验证，防止数据在传输过程中被窃取或篡改</strong>。</p><p> HTTP 在传输敏感信息（如用户登录信息、金融交易数据等）时存在较大的安全隐患，容易<strong>被中间人攻击、数据泄露</strong>等问题所困扰。为了解决这些问题，HTTPS 应运而生。它通过加密技术保护数据传输过程中的隐私和完整性，同时通过数字证书验证服务器的身份，确保用户与合法的服务器进行通信。此外，搜索引擎也倾向于优先推荐使用 HTTPS 的网站。</p><hr><h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>HTTP 是一种<strong>基于请求-响应模型的应用层协议</strong>，主要用于客户端（如浏览器）与服务器之间的通信。基本原理可概括为以下步骤：</p><ul><li> <strong>客户端发起请求：</strong>客户端通过浏览器或其他工具向服务器发送一个 HTTP 请求。请求中包含请求方法（如 GET、POST、PUT、DELETE 等）、请求的资源路径（URL）、HTTP 版本以及一系列<strong>请求头信息</strong>（如<code>Host</code>、<code>User-Agent</code>、<code>Accept</code>等）。</li><li><strong>服务器处理请求：</strong>服务器接收到请求后，根据请求方法和资源路径解析请求内容，并调用相应的应用程序或服务来处理请求。</li><li><strong>服务器返回响应：</strong>服务器处理完请求后，生成一个 HTTP 响应并发送回客户端。响应中包含 <strong>HTTP 状态码</strong>（如 200 表示成功，404 表示未找到等）、<strong>响应头信息</strong>（如<code>Content-Type</code>、<code>Content-Length</code>等）以及<strong>响应体</strong>（如网页内容、图片数据等）。</li><li><strong>客户端接收响应：</strong>客户端接收到服务器的响应后，解析响应内容并将其呈现给用户（如显示网页内容）。</li></ul><p>HTTP 协议<strong>基于无连接和无状态的通信方式</strong>，每次请求和响应完成后，连接即被关闭，服务器不会保存客户端的任何状态信息。这种设计使得 HTTP 协议简单高效，适合大规模的分布式网络应用。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li><strong>建立连接</strong><ol><li>客户端通过 <code>TCP/IP</code> 协议与服务器建立连接。默认情况下，HTTP 使用端口号 <code>80</code>。</li><li>客户端向服务器发送一个 TCP 连接请求，服务器接受连接后，双方建立一个可靠的 TCP 连接。</li></ol></li><li><strong>发送请求</strong><ol><li>客户端通过建立的 TCP 连接向服务器发送 HTTP 请求。请求由请求行、请求头和请求体组成。</li><li>请求行包含请求方法、资源路径和 HTTP 版本号，例如：<code>GET /index.html HTTP/1.1</code>。</li><li>请求头包含客户端的一些信息：<code>Host</code>（目标服务器地址）、<code>User-Agent</code>（客户端类型）、<code>Accept</code>（可接受的响应类型）等。</li><li>请求体（可选）包含客户端发送给服务器的数据，如表单数据、文件上传等。</li></ol></li><li><strong>服务器处理请求</strong><ol><li>服务器接收到客户端的请求后，解析请求行和请求头，确定请求的资源路径和方法。</li><li>根据请求方法和资源路径，服务器调用相应的应用程序或服务来处理请求。</li><li>如果请求方法是 GET，服务器会查找请求的资源并返回内容；如果是 POST，服务器会处理客户端提交的数据并返回结果。</li></ol></li><li><strong>返回响应</strong><ol><li>服务器处理完请求后，生成一个 HTTP 响应并发送回客户端。</li><li>响应由状态行、响应头和响应体组成。</li><li>状态行包含 HTTP 版本号、状态码和状态消息，例如：<code>HTTP/1.1 200 OK</code>。</li><li>响应头包含服务器的一些信息，如<code>Content-Type</code>（响应内容类型）、<code>Content-Length</code>（响应体长度）等。</li><li>响应体包含服务器返回的数据，如网页内容、图片数据等。</li></ol></li><li><strong>关闭连接</strong><ol><li>客户端接收到服务器的响应后，解析响应内容并将其呈现给用户。</li><li>一旦响应处理完成，客户端和服务器之间的 TCP 连接被关闭。</li></ol></li></ol><h2 id="特点与优势"><a href="#特点与优势" class="headerlink" title="特点与优势"></a>特点与优势</h2><ol><li><strong>简单高效</strong><ol><li>HTTP 协议的设计简洁明了，易于理解和实现。它基于文本格式，便于调试和开发。</li><li>HTTP 的无状态特性使每个请求和响应都独立，服务器不需要保存客户端的状态信息，提高了服务器的处理能力和扩展性。</li></ol></li><li><strong>灵活通用</strong><ol><li>HTTP 支持多种请求方法（如 GET、POST、PUT、DELETE 等），能够满足不同的应用场景。</li><li>它可以传输多种类型的数据，如文本、图片、视频等，适用于各种网络应用。</li></ol></li><li><strong>广泛支持</strong><ol><li>HTTP 是互联网上最广泛使用的协议之一，几乎所有浏览器和服务器都支持 HTTP 协议。</li><li>它与多种其他协议（如 TCP/IP、DNS 等）无缝集成，能够轻松构建复杂的网络应用。</li></ol></li><li><strong>可扩展性</strong><ol><li>HTTP 协议通过请求头和响应头提供了丰富的扩展机制，允许开发者添加自定义的头信息来实现特定的功能。</li><li>它还支持多种内容编码（如 gzip 压缩）和缓存机制，能够优化网络传输效率和性能。</li></ol></li><li><strong>兼容性强</strong><ol><li>HTTP 协议版本更新（如从 HTTP/1.1 到 HTTP/2）保持了向后兼容性，使旧的客户端和服务器能够无缝迁移到新的协议版本。</li><li>它还支持多种编程语言和开发框架，方便开发者进行开发和部署。</li></ol></li></ol><hr><h1 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h1><h2 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h2><p>HTTPS 是 HTTP 协议的安全版本，通过在 HTTP 的基础上添加 SSL/TLS（安全套接字层/传输层安全性）协议来实现数据的安全传输。其核心原理可概括为以下几个方面：</p><ol><li><p><strong>加密传输</strong></p><p>HTTPS 使用 SSL/TLS 协议对传输的数据进行加密。加密过程包括<strong>对称加密和非对称加密</strong>两种方式。在握手过程中，客户端和服务器首先使用<strong>非对称加密（如 RSA 或 ECC）交换密钥</strong>，然后使用<strong>对称加密（如 AES）对后续的通信数据进行加密</strong>。这种加密方式既保证了密钥交换的安全性，又提高了数据传输的效率。</p></li><li><p><strong>身份验证</strong></p><p>HTTPS 通过数字证书来验证服务器的身份。服务器需要从权威的证书颁发机构（CA）<strong>获取数字证书</strong>，并在握手过程中将证书发送给客户端。客户端通过<strong>验证证书的有效性</strong>（包括证书的颁发机构、有效期、域名等信息）来确认服务器的身份，防止中间人攻击。</p></li><li><p><strong>数据完整性</strong></p><p>HTTPS 使用<strong>哈希算法</strong>（如 <code>SHA-256</code>）对传输的数据进行完整性校验。在数据传输过程中，客户端和服务器会生成数据的哈希值，并在接收数据时验证哈希值是否一致。如果数据在传输过程中被篡改，哈希值将不匹配，从而确保数据的完整性。</p></li><li><p><strong>协议层级</strong></p><p>HTTPS 在 <code>TCP 层之上、HTTP 层之下</code>工作。它通过 SSL/TLS 协议封装 HTTP 数据，使得 HTTP 协议在传输过程中得到保护。默认情况下，HTTPS 使用端口号 <code>443</code>。</p></li></ol><h2 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li><strong>建立连接</strong><ol><li>客户端通过 TCP/IP 协议与服务器建立连接。默认情况下，HTTPS 使用端口号 443。</li><li>客户端向服务器发送一个 TCP 连接请求，服务器接受连接后，双方建立一个可靠的 TCP 连接。</li></ol></li><li><strong>SSL/TLS 握手</strong><ol><li>客户端向服务器发送一个<code>ClientHello</code>消息，包含客户端支持的 SSL/TLS 版本、加密算法列表、随机数等信息。</li><li>服务器收到<code>ClientHello</code>消息后，选择一种加密算法，并向客户端发送一个<code>ServerHello</code>消息，包含服务器选择的 SSL/TLS 版本、加密算法、随机数等信息。</li><li>服务器向客户端发送自己的数字证书（包括公钥），客户端验证证书的有效性。</li><li>客户端生成一个预主密钥（<code>Pre-Master Secret</code>），并使用服务器的公钥对其进行加密，然后发送给服务器。</li><li>服务器使用自己的私钥解密预主密钥，客户端和服务器分别使用预主密钥和之前交换的随机数生成主密钥（<code>Master Secret</code>），用于后续的对称加密通信。</li><li>客户端和服务器分别发送<code>ChangeCipherSpec</code>消息和<code>Finished</code>消息，表示握手完成，开始使用对称加密进行通信。</li></ol></li><li><strong>发送请求和响应</strong><ol><li>客户端通过建立的安全连接向服务器发送 HTTP 请求，请求内容经过 SSL/TLS 加密。</li><li>服务器接收到加密的请求后，解密请求内容并处理请求，然后将响应内容加密后发送回客户端。</li><li>客户端接收到加密的响应后，解密响应内容并将其呈现给用户。</li></ol></li><li><strong>关闭连接</strong><ol><li>客户端或服务器可以随时发送<code>CloseNotify</code>消息来关闭连接。</li><li>一旦连接关闭，<code>SSL/TLS</code> 会话结束。</li></ol></li></ol><h2 id="特点与优势-1"><a href="#特点与优势-1" class="headerlink" title="特点与优势"></a>特点与优势</h2><ol><li><p><strong>数据加密</strong></p><p>HTTPS 对传输的数据进行加密，防止数据在传输过程中被窃取或篡改。即使攻击者能够截获数据，也无法解密其内容，从而保护了用户的隐私和敏感信息。</p></li><li><p><strong>身份验证</strong></p><p>HTTPS 通过数字证书验证服务器身份，确保客户端与合法的服务器进行通信。这有效防止了中间人攻击，提高了网络通信的安全性。</p></li><li><p><strong>数据完整性</strong></p><p>HTTPS 使用哈希算法对数据进行完整性校验，确保数据在传输过程中未被篡改。如果数据被篡改，客户端将拒绝接收数据，从而保障了数据的完整性。</p></li><li><p><strong>兼容性强</strong></p><p>HTTPS 是基于 HTTP 协议的扩展，兼容现有的 HTTP 应用。大多数现代浏览器和服务器都支持 HTTPS，开发者可以轻松地将现有的 HTTP 应用迁移到 HTTPS。</p></li><li><p><strong>搜索引擎优化（SEO）</strong></p><p>搜索引擎（如 Google）倾向于优先推荐使用 HTTPS 的网站，因为 HTTPS 提供了更高的安全性。这有助于提升网站在搜索引擎结果页面（SERP）中的排名，增加网站的流量。</p></li><li><p><strong>提升用户信任</strong></p><p>使用 HTTPS 的网站在浏览器地址栏中会显示一个绿色的锁形图标，表明网站是安全的。这有助于提升用户对网站的信任，增加用户在网站上的停留时间和交互行为。</p></li><li><p><strong>支持 HTTP/2</strong></p><p>HTTPS 是 HTTP/2 的基础，HTTP/2 提供了更高的性能优化，如多路复用、服务器推送等。使用 HTTPS 可以更好地支持 HTTP/2 的特性，提升网站的加载速度和用户体验。</p></li></ol><hr><h1 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h1><h2 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h2><ol><li><p><strong>数据加密</strong><br><strong>HTTP：</strong>HTTP 是<strong>明文传输协议</strong>，数据在客户端和服务器之间传输时未经过加密。这意味着传输的数据（如用户名、密码、信用卡信息等）可能会被网络中的中间设备（如路由器、代理服务器）或恶意攻击者截获。<br><strong>HTTPS：</strong>HTTPS 在 HTTP 的基础上引入了 <strong>SSL/TLS 加密机制</strong>。在数据传输过程中，客户端和服务器之间通过<strong>非对称加密交换密钥</strong>，然后使用<strong>对称加密对数据进行加密</strong>。即使数据被截获，攻击者也无法解密其内容，从而有效保护了数据的机密性。</p></li><li><p><strong>数据完整性</strong><br><strong>HTTP：</strong>HTTP 协议本身<strong>不提供数据完整性校验机制</strong>。数据在传输过程中可能会被篡改，而客户端无法检测到这种篡改。<br><strong>HTTPS：</strong>HTTPS 使用<strong>哈希算法</strong>（如 SHA-256）对传输的数据进行完整性校验。在数据传输过程中，客户端和服务器会生成数据的哈希值，并<strong>在接收数据时验证哈希值是否一致</strong>。如果数据在传输过程中被篡改，哈希值将不匹配，从而确保数据的完整性。</p></li><li><p><strong>身份验证</strong><br><strong>HTTP：</strong>HTTP 协议<strong>不提供身份验证机制</strong>，无法验证服务器或客户端的身份。攻击者可以通过中间人攻击（<code>MITM</code>）伪装成合法的服务器或客户端，窃取用户数据。<br><strong>HTTPS：</strong>HTTPS 使用<strong>数字证书</strong>来验证服务器的身份。服务器需要从权威的证书颁发机构（<code>CA</code>）获取数字证书，并在握手过程中将证书发送给客户端。<strong>客户端通过验证证书的有效性</strong>（包括证书的颁发机构、有效期、域名等信息）来确认服务器的身份，从而防止中间人攻击。</p></li></ol><h2 id="协议基础"><a href="#协议基础" class="headerlink" title="协议基础"></a>协议基础</h2><ol><li><p><strong>使用的协议</strong><br><strong>HTTP：</strong>HTTP 是一种<strong>应用层协议</strong>，基于 <code>TCP/IP</code> 协议栈工作。它主要用于客户端和服务器之间的数据传输。<br><strong>HTTPS：</strong>HTTPS 是 HTTP 的安全版本，通过在 HTTP 的基础上添加 <code>SSL/TLS 协议</code>来实现数据的安全传输。SSL/TLS 是一种<strong>传输层安全协议</strong>，用于加密数据并验证通信双方的身份。</p></li><li><p><strong>端口号</strong><br><strong>HTTP：</strong>HTTP 默认使用端口号 <code>80</code>。<br><strong>HTTPS：</strong>HTTPS 默认使用端口号 <code>443</code>。</p></li></ol><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ol><li><p><strong>加载速度</strong><br><strong>HTTP：</strong>HTTP 是明文传输，数据传输速度快，但安全性差。在没有加密开销的情况下，HTTP 的加载速度通常比 HTTPS 快。<br><strong>HTTPS：</strong>HTTPS 在数据传输过程中需要进行加密和解密操作，这会增加一定的计算开销，可能导致加载速度略慢。然而，随着硬件性能的提升和 SSL/TLS 协议的优化，这种性能差距已经逐渐缩小。此外，HTTPS 支持 HTTP/2 协议，HTTP/2 通过多路复用、服务器推送等技术可以显著提升页面加载速度。</p></li><li><p><strong>对服务器的影响</strong><br><strong>HTTP：</strong>HTTP 不涉及加密和解密操作，<strong>对服务器的计算资源要求较低</strong>。<br><strong>HTTPS：</strong>HTTPS 的加密和解密操作会<strong>增加服务器的计算开销</strong>，尤其是在高并发场景下。不过，现代服务器的硬件性能已经足够强大，能够较好地处理这些额外的负载。此外，使用硬件加速（如 <code>SSL 加速卡</code>）可以进一步减轻服务器的负担。</p></li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>HTTP 的适用场景</strong></p><ol><li><strong>非敏感信息传输：</strong>HTTP 适用于传输非敏感信息，如公开的网页内容、新闻资讯等。这些信息即使被截获也不会对用户或企业造成严重损失。</li><li><strong>低安全性需求的内部网络：</strong>在企业内部网络中，如果数据传输的安全性要求不高，可以使用 HTTP 来降低系统复杂性和成本。</li><li><strong>简单的信息查询：</strong>对于一些简单的信息查询服务，如天气预报、股票行情等，HTTP 是一个高效且经济的选择。</li></ol><p><strong>HTTPS 的适用场景</strong></p><ol><li><strong>电子商务网站：</strong>电子商务网站涉及用户敏感信息（如信用卡信息、个人身份信息等），须使用 HTTPS 保护用户隐私和数据安全。</li><li><strong>金融服务：</strong>银行、证券等金融服务机构需要使用 HTTPS 来确保交易数据的安全性和完整性，防止数据泄露和欺诈行为。</li><li><strong>个人隐私保护：</strong>涉及用户个人隐私的应用（如电子邮件、社交媒体、在线医疗等）需要使用 HTTPS 来保护用户的隐私。</li><li><strong>搜索引擎优化（SEO）：</strong>搜索引擎倾向于优先推荐使用 HTTPS 的网站，为了提升网站在搜索结果中的排名，建议使用 HTTPS。</li><li><strong>需要高安全性的企业应用：</strong>对于企业内部的敏感应用（如人力资源管理系统、财务系统等），使用 HTTPS 可以有效防止数据泄露和中间人攻击。</li></ol><h1 id="HTTP-和-HTTPS-的实际应用"><a href="#HTTP-和-HTTPS-的实际应用" class="headerlink" title="HTTP 和 HTTPS 的实际应用"></a>HTTP 和 HTTPS 的实际应用</h1><h2 id="HTTP-的常见应用"><a href="#HTTP-的常见应用" class="headerlink" title="HTTP 的常见应用"></a>HTTP 的常见应用</h2><ul><li><strong>网站浏览</strong><br>HTTP 是互联网上最早广泛应用的协议之一，广泛用于普通的网站浏览场景。许多新闻网站、博客、社交媒体平台等在早期都使用 HTTP 协议来传输网页内容。例如：<ul><li><strong>新闻网站：</strong>用户通过浏览器访问新闻网站时，HTTP 协议用于从服务器获取新闻文章、图片和视频等资源。这些内容通常是公开的，对安全性要求不高，因此 HTTP 能够高效地完成任务。</li><li><strong>博客平台：</strong>博客作者发布文章后，读者可以通过 HTTP 协议访问博客页面，查看文章内容。由于博客内容大多是公开分享的，HTTP 的简单性和高效性使其成为合适的选择。</li></ul></li><li><strong>简单信息查询</strong><br>HTTP 也常用于简单的信息查询服务，如天气预报、股票行情、公共信息查询等。这些服务的特点是：<ul><li><strong>数据公开性：</strong>查询的内容通常是公开的，不需要加密保护。例如，用户查询天气信息时，数据是公开的，对安全性要求不高。</li><li><strong>高效性：</strong>HTTP 的无状态特性和简单的请求-响应模型使其能够快速处理大量用户的查询请求，适合这类对性能要求较高的场景。</li></ul></li></ul><h2 id="HTTPS-的常见应用"><a href="#HTTPS-的常见应用" class="headerlink" title="HTTPS 的常见应用"></a>HTTPS 的常见应用</h2><ul><li><strong>电子商务</strong><br>电子商务网站是 HTTPS 应用的典型场景之一。在这些网站上，用户需要输入敏感信息，如信用卡号、地址、联系方式等。HTTPS 的加密机制能够确保这些信息在传输过程中不被窃取或篡改。例如：<ul><li><strong>在线购物平台：</strong>用户在购买商品时，需要输入支付信息和个人信息。HTTPS 通过加密这些数据，确保用户的隐私和交易安全。</li><li><strong>支付网关：</strong>支付网关是处理支付交易的核心环节，必须使用 HTTPS 来保护用户的支付信息。SSL/TLS 加密和数字证书验证机制能够有效防止中间人攻击，确保交易的完整性和安全性。</li></ul></li><li><strong>金融交易</strong><br>金融行业对数据安全的要求极高，因此 HTTPS 是金融交易的必备技术。银行、证券公司等金融机构通过 HTTPS 来保护用户的账户信息、交易记录和资金操作。例如：</li><li><ul><li><strong>网上银行：</strong>用户登录网上银行时，HTTPS 用于加密登录信息，防止密码被窃取。在进行转账、查询余额等操作时，HTTPS 确保数据的安全传输。</li><li><strong>证券交易：</strong>证券交易系统需要处理大量的敏感数据，如股票买卖订单、资金流向等。HTTPS 通过加密和身份验证机制，确保交易的安全性和合规性。</li></ul></li><li><strong>个人隐私保护</strong><br>许多涉及个人隐私的应用和服务都采用了 HTTPS 来保护用户数据。例如：<ul><li><strong>社交媒体平台：</strong>用户在社交媒体上分享个人信息、照片和消息时，HTTPS 确保这些数据在传输过程中不被泄露。例如，Facebook 和 Twitter 等平台都使用 HTTPS 来保护用户的隐私。</li><li><strong>在线医疗平台：</strong>在线医疗平台涉及用户的健康信息和医疗记录，这些信息非常敏感。HTTPS 通过加密和身份验证机制，确保用户的医疗数据在传输过程中不被窃取或篡改。</li><li><strong>电子邮件服务：</strong>许多电子邮件服务提供商（如 Gmail、Outlook 等）使用 HTTPS 来保护用户的邮件内容。HTTPS 确保用户在登录邮箱、发送和接收邮件时，数据的安全性和隐私性得到保障。</li></ul></li></ul><p>HTTP 和 HTTPS 在实际应用中各有其适用场景。<strong>HTTP 适用于对安全性要求不高、注重效率的场景，而 HTTPS 则是处理敏感数据和需要高安全性的场景的首选协议</strong>。</p>]]></content>
    
    
    <summary type="html">‌本文整理了一些关于HTTP和HTTPS的相关内容。‌</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="RestfulApi" scheme="https://southernfish.github.io/categories/Framwork/RestfulApi/"/>
    
    
    <category term="RestfulApi" scheme="https://southernfish.github.io/tags/RestfulApi/"/>
    
  </entry>
  
  <entry>
    <title>数据库引擎InnoDB</title>
    <link href="https://southernfish.github.io/2025/06/24/database/database-innodb/"/>
    <id>https://southernfish.github.io/2025/06/24/database/database-innodb/</id>
    <published>2025-06-24T05:34:36.000Z</published>
    <updated>2025-07-10T12:47:35.020Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB，是<a href="https://baike.baidu.com/item/MySQL/471251?fromModule=lemma_inlink">MySQL</a>的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/1239260?fromModule=lemma_inlink">数据库引擎</a>之一，现为MySQL的默认<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/8969956?fromModule=lemma_inlink">存储引擎</a>，为[MySQL AB](<a href="https://baike.baidu.com/item/MySQL">https://baike.baidu.com/item/MySQL</a> AB/2620844?fromModule=lemma_inlink)发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由<a href="https://baike.baidu.com/item/%E7%94%B2%E9%AA%A8%E6%96%87%E5%85%AC%E5%8F%B8/430115?fromModule=lemma_inlink">甲骨文公司</a>并购。与传统的ISAM与<a href="https://baike.baidu.com/item/MyISAM/0?fromModule=lemma_inlink">MyISAM</a>相比，InnoDB的最大特色就是支持了<a href="https://baike.baidu.com/item/ACID/10738?fromModule=lemma_inlink">ACID</a>兼容的<a href="https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1/5945882?fromModule=lemma_inlink">事务</a>（Transaction）功能，类似于<a href="https://baike.baidu.com/item/PostgreSQL/530240?fromModule=lemma_inlink">PostgreSQL</a>。InnoDB采用<a href="https://baike.baidu.com/item/%E5%8F%8C%E8%BD%A8%E5%88%B6/8309993?fromModule=lemma_inlink">双轨制</a>授权，一个是<a href="https://baike.baidu.com/item/GPL/0?fromModule=lemma_inlink">GPL</a>授权，另一个是专有软件授权。</p><h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><h2 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h2><p><strong><code>InnoDB</code>索引是聚簇索引</strong>，MyISAM索引是非聚簇索引。<br><code>InnoDB</code>的<strong>主键索引的叶子节点存储着行数据</strong>，因此主键索引非常高效。<br><strong><code>MyISAM</code>索引的叶子节点存储的是行数据地址</strong>，需要再寻址一次才能得到数据。<br><strong>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据</strong>，因此查询时做到覆盖索引会非常高效。</p><h2 id="MySQL-InnoDB存储引擎的特点"><a href="#MySQL-InnoDB存储引擎的特点" class="headerlink" title="MySQL InnoDB存储引擎的特点"></a>MySQL InnoDB存储引擎的特点</h2><p><strong>事务支持：</strong>InnoDB支持ACID事务属性。<br><strong>崩溃恢复</strong>：InnoDB会<strong>将数据写入到磁盘上的日志文件</strong>中，即使在系统崩溃的情况下，也能通过这些日志文件恢复数据。<br><strong>MVCC (多版本并发控制)：</strong>InnoDB使用多版本并发控制，这允许更高的并发性。<br><strong>外键约束：</strong>InnoDB支持外键约束，这对于维护数据库的引用完整性非常有用。<br><strong>行级锁定：</strong>与表级锁定相比，InnoDB<strong>支持行级锁定，提供了更高的并发性能</strong>。<br><strong>自适应哈希索引：</strong>InnoDB会<strong>自动为频繁访问的热点数据创建哈希索引，以提高查询速度</strong>。</p><h2 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h2><p>推荐使用自增ID，不要使用UUID。<br>在InnoDB存储引擎中，主键索引是作为<strong>聚簇索引</strong>存在的，主键索引的<code>B+树</code>叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，只需要不断向后排列即可，如果是*<code>UUID</code>，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降*。<br>总之，在数据量大一些的情况下，用自增主键性能会好一些。<br>主键是聚簇索引，若没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个<strong>隐式的主键</strong>。</p><h2 id="如何使用InnoDB？"><a href="#如何使用InnoDB？" class="headerlink" title="如何使用InnoDB？"></a>如何使用InnoDB？</h2><p>在创建表时指定使用InnoDB存储引擎，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE example (</span><br><span class="line">    <span class="built_in">id</span> INT AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (<span class="built_in">id</span>)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h2 id="优化InnoDB性能的技巧"><a href="#优化InnoDB性能的技巧" class="headerlink" title="优化InnoDB性能的技巧"></a>优化InnoDB性能的技巧</h2><p><strong>配置<code>innodb_buffer_pool_size</code>：控制InnoDB缓存数据和索引的内存大小</strong>。通常设置为系统内存的50%-80%。<br><strong>调整<code>innodb_log_file_size</code>：增加日志文件的大小可以减少日志磁盘写入次数</strong>，但需要确保磁盘I/O足够快。<br><strong>使用合适的索引：</strong>确保对查询进行优化的索引。<br><strong>监控和调整<code>innodb_io_capacity</code>：</strong>这个参数<strong>控制后台I/O操作的速率</strong>，需要根据实际的磁盘I/O性能进行调整。<br><strong>批量操作：</strong>大量插入、更新或删除操作时，尽量使用<strong>事务批量处理，减少对数据库的冲击</strong>。</p><h2 id="InnoDB常见问题及解决方案？"><a href="#InnoDB常见问题及解决方案？" class="headerlink" title="InnoDB常见问题及解决方案？"></a>InnoDB常见问题及解决方案？</h2><p><strong>性能问题：</strong>若发现InnoDB性能不佳，<strong>先检查是否有足够的内存分配给<code>innodb_buffer_pool_size</code>，以及磁盘I/O是否成为瓶颈</strong>。<br><strong>锁等待：</strong>高并发下，锁等待可能导致性能下降。可<strong>通过<code>SHOW ENGINE INNODB STATUS</code>查看锁等待情况</strong>，并考虑优化查询或增加索引。<br><strong>死锁：</strong>死锁是多个事务相互等待对方释放资源的情况。MySQL会检测到死锁并自动回滚其中一个事务以解除死锁。可以<strong>通过<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>表来诊断死锁</strong>。</p><hr><h1 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h1><p>MVCC全称<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6&spm=1001.2101.3001.7020">多版本并发控制</a>，是在并发访问数据库时对操作数据做多版本管理，避免因为写数据时要加写锁而阻塞读取数据的请求问题。</p><h2 id="InnoDB的MVCC实现原理"><a href="#InnoDB的MVCC实现原理" class="headerlink" title="InnoDB的MVCC实现原理"></a>InnoDB的MVCC实现原理</h2><p>MySQL <code>InnoDB</code> 存储引擎使用多版本并发控制（MVCC，<code>Multi-Version Concurrency Control</code>）来支持高并发环境下的读写操作，而不会互相阻塞。MVCC 允许在同一个时刻有多个事务对同一数据进行操作，而不会导致数据不一致。使用软性手段既要保证串行化隔离级别的安全性同时保证系统的整体性能和吞吐量。转载自文章 <a href="https://blog.csdn.net/carolineme/article/details/145860802">Innodb MVCC实现原理</a></p><ol><li><p><strong>事务版本号</strong></p><p>每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。</p></li><li><p><strong>表格的隐藏列</strong></p><table><thead><tr><th>隐藏列名称</th><th>说明</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>记录操作该数据事务的事务ID；</td></tr><tr><td>DB_ROLL_PTR</td><td>指向上一个版本数据在undo log 里的位置指针；</td></tr><tr><td>DB_ROW_ID</td><td>隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引;</td></tr></tbody></table></li><li><p><strong>Undo log</strong></p><p>Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。<strong>主要用途：</strong></p><ul><li><p>保证事务进行<code>rollback</code>时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。</p></li><li><p><strong>用于MVCC快照读的数据</strong>，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。</p></li></ul></li><li><p><strong>Read view</strong></p><p>在innodb 中每个事务开启后都会得到一个read_view。副本主要保存了当前<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F&spm=1001.2101.3001.7020">数据库系统</a>中正处于活跃（没有commit）的事务的ID号，保存的是系统中当前不应该被本事务看到的其他事务id列表。<strong>Read view 的几个重要属性：</strong></p><table><thead><tr><th>属性名称</th><th>说明</th></tr></thead><tbody><tr><td>trx_ids</td><td>当前系统活跃(未提交)事务版本号集合</td></tr><tr><td>max_limit_id</td><td>创建当前read view 时“当前系统最大事务版本号+1”</td></tr><tr><td>min_limit_id</td><td>创建当前read view 时“系统正处于活跃事务最小版本号”</td></tr><tr><td>creator_trx_id</td><td>创建当前read view的事务版本号</td></tr></tbody></table><p><strong>Read view 匹配条件规则：</strong></p><ul><li>如果数据事务ID <code>trx_id &lt; min_limit_id</code>，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。</li><li>如果<code>trx_id&gt;= max_limit_id</code>，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</li><li>如果 <code>min_limit_id =&lt;trx_id&lt; max_limit_id</code>，<strong>需要分3种情况讨论</strong>：<ul><li>如果<code>m_ids包含trx_id</code>，则代表Read View生成时刻，这个事务还未提交，但如果数据的<code>trx_id等于creator_trx_id</code>的话，表明数据是自己生成的，因此是可见的。</li><li>如果<code>m_ids包含trx_id</code>，并且<code>trx_id不等于creator_trx_id</code>，则Read View生成时，事务未提交，并且不是自己生产的，所以当前事务也是看不见的；</li><li>如果<code>m_ids不包含trx_id</code>，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是能看见的。</li></ul></li></ul><p><code>READ_UNCOMMITTED</code> 级别的事务不会获取read view 副本；<code>RC(read commit)</code> 级别下同一个事务里面的每一次查询都会获得一个新的read view副本；<code>RR(重复读)</code>级别下的一个事务里只会获取一次read view副本，从而保证每次查询的数据都是一样的。</p></li></ol><h2 id="MVCC-Next-key-Lock-防止幻读"><a href="#MVCC-Next-key-Lock-防止幻读" class="headerlink" title="MVCC+Next-key-Lock 防止幻读"></a>MVCC+Next-key-Lock 防止幻读</h2><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p><ol><li><p><strong>执行普通 select，此时会以 MVCC 快照读的方式读取数据</strong></p><ul><li><p>在快照读的情况下，RR 隔离级别只会在<strong>事务开启后的第一次查询生成 <code>Read View</code></strong> ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。</p></li><li><p><strong>快照读</strong>是指读取数据时不是读取最新版本的数据，而是基于历史版本读取的一个快照信息（mysql读取undo log历史版本)</p></li></ul></li><li><p><strong>执行 select…for update/lock in share mode、insert、update、delete 等当前读</strong></p><ul><li>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，<strong>就会产生幻读</strong>！</li><li>InnoDB 使用 <code>Next-key Lock</code> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。</li><li>当前读是读取的数据库最新的数据，当前读和快照读不同，因为要读取最新的数据而且要保证事务的隔离性，所以当前读是需要对数据进行加锁的</li></ul></li></ol>]]></content>
    
    
    <summary type="html">‌InnoDB是为处理巨大数据量时的最大性能设计。InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>大模型</title>
    <link href="https://southernfish.github.io/2025/06/24/large-model/large-model/"/>
    <id>https://southernfish.github.io/2025/06/24/large-model/large-model/</id>
    <published>2025-06-24T03:22:36.000Z</published>
    <updated>2025-07-10T12:47:35.024Z</updated>
    
    <content type="html"><![CDATA[<p>人工智能大模型（简称“大模型”）是指由<a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/382460?fromModule=lemma_inlink">人工神经网络</a>构建的一类具有大量参数的人工智能模型。其通常先通过自监督学习或<a href="https://baike.baidu.com/item/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/9075473?fromModule=lemma_inlink">半监督学习</a>在海量数据上进行预训练，然后通过指令微调和人类对齐等方法进一步优化其性能和能力。大模型具有参数量大、训练数据大、计算资源大等特点，拥有解决通用任务、遵循人类指令、进行复杂推理等能力。器主要类别包括：<a href="https://baike.baidu.com/item/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/62884793?fromModule=lemma_inlink">大语言模型</a>、视觉大模型、<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B/63122644?fromModule=lemma_inlink">多模态大模型</a>以及基础科学大模型等。目前，大模型已在多个领域得到广泛应用，包括<a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/104812?fromModule=lemma_inlink">搜索引擎</a>、<a href="https://baike.baidu.com/item/%E6%99%BA%E8%83%BD%E4%BD%93/9446647?fromModule=lemma_inlink">智能体</a>、相关垂直产业及基础科学等领域，推动了各行业的智能化发展。</p><p>原文链接： <a href="https://zhuanlan.zhihu.com/p/1900212961517213051">大模型</a></p><h1 id="大模型"><a href="#大模型" class="headerlink" title="大模型"></a>大模型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>大模型</strong>（<code>Large Models</code>）通常指参数规模庞大（通常在十亿到万亿级别）的深度学习模型。这类模型通过在大规模数据集上进行训练，具备强大的泛化能力和复杂的任务处理能力，尤其在<strong>自然语言处理（NLP）、计算机视觉（CV）和多模态任务</strong>中表现突出。例如，<a href="https://zhida.zhihu.com/search?content_id=257103601&content_type=Article&match_order=1&q=GPT-3&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTA5NDIwMzEsInEiOiJHUFQtMyIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjI1NzEwMzYwMSwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.pRQ4bw78OW9OCPds9KYVAnts2vd5huIIdlV17yltino&zhida_source=entity">GPT-3</a>（1750亿参数）和<a href="https://zhida.zhihu.com/search?content_id=257103601&content_type=Article&match_order=1&q=PaLM&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTA5NDIwMzEsInEiOiJQYUxNIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MjU3MTAzNjAxLCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.pY7El6LSXHn6ol368EhPM_k_HmIaxDphK8H0ACiazno&zhida_source=entity">PaLM</a>（5400亿参数）是典型的大模型。</p><h2 id="大模型和小模型的区别"><a href="#大模型和小模型的区别" class="headerlink" title="大模型和小模型的区别"></a>大模型和小模型的区别</h2><table><thead><tr><th>维度</th><th>大模型</th><th>小模型</th></tr></thead><tbody><tr><td>参数规模</td><td>十亿到万亿级（如GPT-3：175B）</td><td>百万到十亿级（如<a href="https://zhida.zhihu.com/search?content_id=257103601&content_type=Article&match_order=1&q=BERT&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTA5NDIwMzEsInEiOiJCRVJUIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MjU3MTAzNjAxLCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.GgzgYV_OlNlMQ6Rk8on2UBVonjpddwn5kjEs0-wm-2k&zhida_source=entity">BERT</a>-base：110M）</td></tr><tr><td>训练数据</td><td>海量数据（TB级文本、图像等）</td><td>较小规模（GB级）</td></tr><tr><td>计算资源</td><td>需要分布式GPU/TPU集群，训练耗时数周至数月</td><td>单卡或少量GPU即可训练，耗时短</td></tr><tr><td>应用场景</td><td>通用任务（文本生成、复杂推理、多模态交互）</td><td>专用任务（分类、实体识别、轻量级部署）</td></tr><tr><td>部署成本</td><td>高昂（需云端算力支持，推理延迟高）</td><td>低成本（可嵌入手机、IoT设备）</td></tr><tr><td>能力特点</td><td>涌现能力（如零样本学习、上下文理解）</td><td>依赖任务微调，泛化能力有限</td></tr></tbody></table><h2 id="相关概念区分"><a href="#相关概念区分" class="headerlink" title="相关概念区分"></a><strong>相关概念区分</strong></h2><ul><li><strong>大模型（<code>Large Model</code>）：</strong>也称基础模型，即 <code>Foundation Model</code>，是指具有大量参数和复杂结构的机器学习模型，能够处理海量数据、完成各种复杂的任务，如<em>自然语言处理、计算机视觉、语音识别</em>等。</li><li>超大模型：超大模型是大模型的一个子集，它们的<strong>参数量远超过大模型</strong>。</li><li><strong>大语言模型（<code>Large Language Model</code>）：</strong>通常是具<strong>有大规模参数和计算能力的自然语言处理模型</strong>，例如 OpenAI 的 GPT-3 模型。这些模型可以通过大量的数据和参数进行训练，以生成人类类似的文本或回答自然语言的问题。大型语言模型在<strong>自然语言处理、文本生成和智能对话</strong>等领域有广泛应用。</li><li><strong><code>GPT（Generative Pre-trained Transformer）</code>：</strong>GPT 和 ChatGPT 都是基于 <code>Transformer</code> 架构的语言模型，但它们在设计和应用上存在区别，<code>GPT 模型</code>旨在<strong>生成自然语言文本并处理各种自然语言处理任务</strong>，如文本生成、翻译、摘要等。它通常在<strong>单向生成</strong>的情况下使用，即根据给定的文本生成连贯的输出。</li><li><strong><code>ChatGPT</code>：</strong>ChatGPT 则<strong>专注于对话和交互式对话</strong>。它经过特定的训练，以更好地处理多轮对话和上下文理解。ChatGPT 设计用于提供流畅、连贯和有趣的对话体验，以响应用户的输入并生成合适的回复。</li><li><strong>预训练模型（<code>Pre-trained Models</code>）：</strong> 在大规模数据上预训练的模型（如BERT、GPT），<strong>可通过微调适配下游任务</strong>。大模型多为预训练模型，但小模型也可预训练。</li><li><strong>基础模型（<code>Foundation Models</code>）：</strong> 斯坦福提出的概念，指<strong>通过自监督学习在大规模数据上训练、可适应多种任务的模型</strong>（如GPT-3）。大模型是基础模型的子集。</li><li><strong>多模态模型（<code>Multimodal Models</code>）：</strong> <strong>处理多种输入</strong>（文本、图像、音频）的模型（如CLIP、DALL·E）。大模型常具备多模态能力，但小模型也可设计为多模态。</li><li><strong>生成式AI（<code>Generative AI</code>）：</strong> 专注于<strong>生成内容</strong>的模型（如GPT、Stable Diffusion）。大模型常为生成式，但生成式模型不一定“大”（如小型GAN）</li></ul><h2 id="大模型的特点"><a href="#大模型的特点" class="headerlink" title="大模型的特点"></a><strong>大模型的特点</strong></h2><p><strong>参数规模超大</strong></p><ul><li><strong>量级</strong>：参数量从十亿（B）到万亿（T）级别，例如GPT-3（175B）、PaLM-2（340B）。</li><li><strong>意义</strong>：参数规模直接影响模型的“记忆容量”和复杂模式捕捉能力，是涌现（<code>Emergence</code>）能力（如逻辑推理、上下文学习）的基础。</li></ul><p><strong>训练数据海量</strong></p><ul><li><strong>数据量</strong>：通常使用<code>TB级</code>文本、图像等<strong>多模态数据</strong>（如GPT-3训练数据约45TB）。</li><li><strong>多样性</strong>：覆盖<strong>多语言、多领域</strong>（网页、书籍、代码等），降低模型对特定任务的过拟合风险。</li></ul><p><strong>计算资源密集</strong></p><ul><li><strong>训练成本</strong>：需数千张GPU/TPU并行训练数周，如GPT-3训练成本约460万美元。</li><li><strong>能耗问题</strong>：单次训练碳排放可达数百吨（如Bloom模型训练排放25吨CO₂）。</li></ul><p><strong>通用任务泛化</strong></p><ul><li><strong>少样本/零样本学习</strong>：无需微调即可完成新任务（如GPT-4直接生成代码）。</li><li><strong>多任务统一</strong>：同一模型处理文本生成、翻译、问答等多种任务（如PaLM-2）。</li></ul><p><strong>涌现能力（Emergent Abilities）</strong></p><ul><li><strong>不可预测性</strong>：模型在达到一定规模后突现出设计时未明确编程的能力，如：<ul><li><strong>上下文学习</strong>（In-context Learning）：通过示例提示调整输出。</li><li><strong>思维链</strong>（Chain-of-Thought）：分步骤推理解决数学问题。</li><li><strong>跨模态对齐</strong>：理解文本与图像的语义关联（如CLIP）。</li></ul></li></ul><h2 id="大模型的分类"><a href="#大模型的分类" class="headerlink" title="大模型的分类"></a><strong>大模型的分类</strong></h2><ul><li><strong>语言大模型（NLP）：</strong>是指在自然语言处理（<code>Natural Language Processing</code>，NLP）领域中的一类大模型，通常用于处理文本数据和理解自然语言。这类大模型的主要特点是它们在大规模语料库上进行了训练，以学习自然语言的各种语法、语义和语境规则。例如：GPT系列（OpenAI）、Bard（Google）、文心一言（百度）。</li><li><strong>视觉大模型（CV）：</strong>是指在计算机视觉（<code>Computer Vision</code>，CV）领域中使用的大模型，通常用于图像处理和分析。这类模型通过在大规模图像数据上进行训练，可以实现各种视觉任务，如图像分类、目标检测、图像分割、姿态估计、人脸识别等。例如：VIT 系列（Google）、文心UFO、华为盘古 CV、INTERN（商汤）。</li><li><strong>多模态大模型：</strong>是指<strong>能够处理多种不同类型数据的大模型</strong>，例如文本、图像、音频等多模态数据。这类模型结合了 NLP 和 CV 的能力，以实现对多模态信息的综合理解和分析，从而能够更全面地理解和处理复杂的数据。例如：DingoDB 多模向量数据库（九章云极 DataCanvas）、DALL-E(OpenAI)、悟空画画（华为）、midjourney。</li></ul><p>按照应用领域的不同，大模型主要可以分为 L0、L1、L2 三个层级：</p><ul><li><strong>通用大模型 L0：</strong>是指可以在<strong>多个领域和任务上通用</strong>的大模型。它们利用大算力、使用海量的开放数据与具有巨量参数的深度学习算法，在大规模无标注数据上进行训练，以寻找特征并发现规律，进而形成可“举一反三”的强大泛化能力，可在不进行微调或少量微调的情况下完成多场景任务，相当于 AI 完成了“通识教育”。</li><li><strong>行业大模型 L1：</strong>是指那些<strong>针对特定行业或领域</strong>的大模型。它们通常使用行业相关的数据进行预训练或微调，以提高在该领域的性能和准确度，相当于 AI 成为“行业专家”。</li><li><strong>垂直大模型 L2：</strong>是指那些<strong>针对特定任务或场景</strong>的大模型。它们通常使用任务相关的数据进行预训练或微调，以提高在该任务上的性能和效果。</li></ul><h2 id="大模型的泛化与微调"><a href="#大模型的泛化与微调" class="headerlink" title="大模型的泛化与微调"></a><strong>大模型的泛化与微调</strong></h2><p><strong>模型的泛化能力：</strong>是指一个模型在面对新的、未见过的数据时，能够正确理解和预测这些数据的能力。在机器学习和人工智能领域，模型的泛化能力是评估模型性能的重要指标之一。</p><p><strong>模型微调：</strong>给定预训练模型（Pre-trained model），基于模型进行微调（Fine Tune）。相对于从头开始训练(Training a model from scatch)，微调可以省去大量计算资源和计算时间，提高计算效率,甚至提高准确率。</p><p>模型微调的基本思想是<strong>使用少量带标签的数据对预训练模型进行再次训练，以适应特定任务</strong>。在这个过程中，模型的参数会根据新的数据分布进行调整。这种方法的好处在于，它利用了预训练模型的强大能力，同时还能够适应新的数据分布。因此，模型微调能够提高模型的泛化能力，减少过拟合现象。</p><p>常见的模型微调方法：</p><ul><li><strong><code>Fine-tuning</code>：</strong>这是最常用的微调方法。通过在预训练模型的最后一层添加一个新的分类层，然后根据新的数据集进行微调。</li><li><strong><code>Feature augmentation</code>：</strong>这种方法通过向数据中添加一些人工特征来增强模型的性能。这些特征可以是手工设计的，也可以是通过自动特征生成技术生成的。</li><li><strong><code>Transfer learning</code>：</strong>这种方法是使用在一个任务上训练过的模型作为新任务起点，然后对模型参数进行微调，以适应新任务。</li></ul><hr><h1 id="大型语言模型"><a href="#大型语言模型" class="headerlink" title="大型语言模型"></a><strong>大型语言模型</strong></h1><p>大型语言模型，一种能够以类似人类语言方式“说话”的软件。这些模型能获取上下文并生成不仅连贯而且感觉像是来自真实人类的回复。</p><p>这些语言模型通过分析大量的文本数据并学习语言使用的模式来工作。它们利用这些模式生成的文本几乎无法与人类所说或写的内容区分开来。例如，GPT-3模型拥有超过1750亿个参数，能够执行摘要生成、问答甚至创作等任务！</p><h2 id="大型语言模型的类型"><a href="#大型语言模型的类型" class="headerlink" title="大型语言模型的类型"></a><strong>大型语言模型的类型</strong></h2><ul><li><p><strong>基于自编码器的模型（Autoencoder-Based Model）</strong></p><p>它通过将输入文本编码为较低维度的表示，然后根据该表示生成新的文本。这类模型在<strong>文本摘要或内容生成</strong>等任务中表现出色。</p></li><li><p><strong>序列到序列模型（Sequence-to-Sequence Model）</strong></p><p>它接收一个输入序列（比如一个句子）并生成一个输出序列（比如翻译成另一种语言）。这些模型通常用于<strong>机器翻译和文本摘要</strong>。</p></li><li><p><strong>基于Transformer的模型（Transformer-Based Models）</strong></p><p>这些模型<strong>使用一种神经网络架构</strong>，非常擅长<strong>理解文本数据中的长距离依赖关系</strong>，使其在<strong>生成文本、翻译语言和回答问题</strong>等各种语言任务中非常有用。</p></li><li><p><strong>递归神经网络模型（Recursive Neural Network Models）</strong></p><p>递归神经网络模型被设计用于<strong>处理结构化数据</strong>，如句子的句法结构表示。这些模型对<strong>情感分析和自然语言推理</strong>等任务非常有用。</p></li><li><p><strong>分层模型（Hierarchical Models）</strong></p><p>分层模型被设计<strong>用于处理不同粒度级别的文本</strong>，例如句子、段落和文档。这些模型<strong>用于文档分类和主题建模</strong>等任务。</p></li></ul><h2 id="大型语言模型是如何工作的"><a href="#大型语言模型是如何工作的" class="headerlink" title="大型语言模型是如何工作的"></a><strong>大型语言模型是如何工作的</strong></h2><p>大型语言模型（LLM）架构是<code>Transformer</code>架构。典型的Transformer模型在处理输入数据时有四个主要步骤：</p><h3 id="词嵌入（Word-Embedding）"><a href="#词嵌入（Word-Embedding）" class="headerlink" title="词嵌入（Word Embedding）"></a><strong>词嵌入（Word Embedding）</strong></h3><p>它将单词表示为高维空间中的向量，使得相似的单词被归为一组。这有助于模型理解单词的含义，并基于此进行预测。</p><p>创建词嵌入<strong>涉及对大量文本数据进行神经网络训练</strong>，例如新闻文章或书籍。在训练过程中，网络学习根据单词在句子中的前后出现的词来预测其在给定上下文中出现的可能性。通过这个过程学习到的向量捕捉了语料库中不同单词之间的语义关系。</p><p>一旦创建了词嵌入，它们可以作为输入传递给在特定语言任务上进行训练的更大的神经网络，例如文本分类或机器翻译。通过使用词嵌入，模型能够更好地理解单词的含义，并基于这种理解做出更准确的预测。</p><h3 id="位置编码（Positional-Encoding）"><a href="#位置编码（Positional-Encoding）" class="headerlink" title="位置编码（Positional Encoding）"></a><strong>位置编码（Positional Encoding）</strong></h3><p>位置编码是<strong>帮助模型确定单词在序列中的位置</strong>的技术。它与单词的含义以及它们之间的关系无关。相反，位置编码主要用于跟踪单词的顺序。例如，当将句子”我喜欢猫”输入到模型时，位置编码可以帮助模型区分”我”是在句子的开头，而”猫”是在句子的结尾。这对于模型理解上下文和生成连贯的输出非常重要。</p><p>位置编码<strong>使用一系列特定模式的向量来表示单词的位置</strong>。这些向量与词嵌入的向量相加，以获得包含位置信息的表示。通过这种方式，模型能够将单词的位置作为输入的一部分，并在生成输出时保持一致。</p><h3 id="Transformers层"><a href="#Transformers层" class="headerlink" title="Transformers层"></a><strong>Transformers层</strong></h3><p>将Transformer层视为传统神经网络层之后的独立层。实际上，Transformer层通<strong>常作为附加层添加到传统神经网络架构</strong>中，以提高LLM在自然语言文本中<strong>建模长距离依赖性的能力</strong>。Transformer层通过<strong>并行处理</strong>整个输入序列而不是顺序处理来工作。它由两个基本组件组成：自注意力机制和前馈神经网络。</p><ul><li><p><strong>自注意力机制（Self-Attention Mechanism）</strong></p><p>它允许模型在生成输出时，有效地在输入序列的不同位置进行交互和关注。自注意力机制的关键思想是<strong>计算输入序列中每个单词之间的相关性</strong>，并将这些相关性用于权衡模型在每个位置的关注程度。</p><p>具体来说，自注意力机制计算每个单词与其他单词之间的相似度，然后将这些相似度转化为<strong>注意力权重</strong>。这些权重决定了模型在生成输出时对不同位置的输入进行关注的程度。这种自注意力机制使得模型能够根据输入序列中的上下文信息灵活地调整输出的生成。</p><p>传统的递归神经网络在处理长序列时容易出现<strong>梯度消失或梯度爆炸</strong>问题，而自注意力机制使得Transformer模型能够更好地捕捉长距离依赖关系。</p></li><li><p><strong>前馈神经网络（Feed-forward Neural Network）</strong></p><p>前馈神经网络<strong>对每个位置的表示进行进一步的处理</strong>。前馈神经网络是由多个全连接层组成的，其中每个层都有一组参数，用于将输入进行<strong>非线性变换</strong>。这个过程可以帮助模型在生成输出时引入更多的复杂性和灵活性。</p></li></ul><h3 id="文本生成"><a href="#文本生成" class="headerlink" title="文本生成"></a><strong>文本生成</strong></h3><p>LLM模型执行的最后一步；LLM经过训练和微调之后，该模型可用于根据提示或问题生成高度复杂的文本。模型通常通过种子输入进行”预热”，种子输入可以是几个单词、一个句子，甚至是一个完整段落。然后，LLM利用其学到的模式生成一个连贯且与上下文相关的回答。</p><p>文本生成依赖于一种称为<strong>自回归</strong>的技术，即<strong>模型根据它已生成的先前单词逐个生成输出序列的每个单词或标记</strong>。模型利用在训练期间学到的参数来计算下一个单词或标记的概率分布，然后选择最有可能的选择作为下一个输出。</p>]]></content>
    
    
    <summary type="html">人工智能大模型（简称“大模型”）是指由人工神经网络构建的一类具有大量参数的人工智能模型，主要类别包括：大语言模型、视觉大模型、多模态大模型以及基础科学大模型等。</summary>
    
    
    
    <category term="large model" scheme="https://southernfish.github.io/categories/large-model/"/>
    
    
    <category term="large model" scheme="https://southernfish.github.io/tags/large-model/"/>
    
  </entry>
  
  <entry>
    <title>Spring上下文</title>
    <link href="https://southernfish.github.io/2025/06/24/framwork/spring-context/"/>
    <id>https://southernfish.github.io/2025/06/24/framwork/spring-context/</id>
    <published>2025-06-24T02:16:36.000Z</published>
    <updated>2025-07-10T12:47:35.021Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring框架中，上下文（Context）是一个非常重要的概念，它代表了Spring应用的核心，用于管理应用程序中的bean（组件）的生命周期，配置信息等。Spring框架提供了多种类型的上下文实现，其中最常用的是ApplicationContext接口及其实现类。</p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>ApplicationContext是Spring框架中的核心接口，它继承自BeanFactory接口，提供了更丰富的功能。ApplicationContext不仅管理bean的创建和依赖注入，还提供了其他高级功能，如国际化和资源加载等。</p><h2 id="ApplicationContext的实现类"><a href="#ApplicationContext的实现类" class="headerlink" title="ApplicationContext的实现类"></a>ApplicationContext的实现类</h2><ol><li><p><strong>ClassPathXmlApplicationContext</strong>：从类路径下的XML文件中加载配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>FileSystemXmlApplicationContext</strong>：从文件系统中的XML文件中加载配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;path/to/applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>AnnotationConfigApplicationContext</strong>：用于加载基于Java的配置类（使用<code>@Configuration</code>注解的类）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br></pre></td></tr></table></figure></li><li><p><strong>XmlWebApplicationContext</strong>：专门为Web应用设计的<code>ApplicationContext</code>实现，用于加载Web应用的XML配置文件。</p></li><li><p><strong>AnnotationConfigWebApplicationContext</strong>：用于Web应用，加载基于Java的配置类。</p></li></ol><h2 id="使用ApplicationContext"><a href="#使用ApplicationContext" class="headerlink" title="使用ApplicationContext"></a>使用ApplicationContext</h2><ol><li><p><strong>加载配置文件或类</strong></p><ul><li><p><strong>XML配置：</strong>通过<code>ClassPathXmlApplicationContext</code>或<code>FileSystemXmlApplicationContext</code>加载XML配置文件。  </p></li><li><p><strong>Java配置：</strong>通过<code>AnnotationConfigApplicationContext</code>加载使用<code>@Configuration</code>注解的类。   </p></li></ul></li><li><p><strong>获取Bean</strong></p><p>一旦上下文被创建，你可以通过它来获取需要的<code>bean</code>或者<code>使用名称</code>：。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> context.getBean(MyBean.class); <span class="comment">// 获取bean</span></span><br><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> (MyBean) context.getBean(<span class="string">&quot;myBean&quot;</span>); <span class="comment">// 获取使用名称</span></span><br></pre></td></tr></table></figure></li><li><p><strong>关闭上下文</strong></p><p>当Spring应用结束时，应该关闭上下文以释放资源或者使用自动关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((ConfigurableApplicationContext) context).close(); <span class="comment">// 关闭上下文</span></span><br><span class="line">((AbstractApplicationContext) context).registerShutdownHook(); <span class="comment">// 注册JVM关闭钩子，自动关闭上下文</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><ul><li><strong>国际化</strong>：通过<code>MessageSource</code>获取本地化消息。</li><li><strong>事件发布</strong>：发布和监听应用事件。</li><li><strong>资源管理</strong>：加载文件资源，如属性文件、XML文件等。</li><li><strong>环境抽象</strong>：提供对不同环境的抽象，如开发、测试、生产等。</li></ul>]]></content>
    
    
    <summary type="html">‌在Spring框架中，在处理上下文（Context）时，通常指的是Spring应用中的ApplicationContext。‌</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="Spring" scheme="https://southernfish.github.io/categories/Framwork/Spring/"/>
    
    
    <category term="Spring Boot" scheme="https://southernfish.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring注解</title>
    <link href="https://southernfish.github.io/2025/06/23/framwork/spring-annotation/"/>
    <id>https://southernfish.github.io/2025/06/23/framwork/spring-annotation/</id>
    <published>2025-06-23T13:10:36.000Z</published>
    <updated>2025-07-10T12:47:35.021Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring框架中，注解是一种非常重要的特性，它极大地简化了配置和开发过程。‌Spring注解是Spring框架中用于简化配置和开发的核心机制，主要分为组件管理、依赖注入、配置类、AOP、Web开发等类别‌。</p><h1 id="Spring注解的底层实现逻辑"><a href="#Spring注解的底层实现逻辑" class="headerlink" title="Spring注解的底层实现逻辑"></a>Spring注解的底层实现逻辑</h1><h2 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h2><p>Java注解的底层实现逻辑主要包括<strong>定义注解、使用注解和通过反射获取注解</strong>。具体源码分析转载自 <a href="https://blog.csdn.net/fk1778770286/article/details/148581060">Java注解底层实现原理 - 源码分析</a></p><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p>注解是通过<code>@interface</code>关键字定义的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 默认值</span></span><br><span class="line">    <span class="type">int</span>[] numbers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>@Target</code>和<code>@Retention</code>是元注解，分别指定了注解的应用目标和保留策略。<code>ElementType.TYPE</code>表示该注解可以应用于类、接口或枚举上，<code>RetentionPolicy.RUNTIME</code>表示注解在运行时可以通过反射获取‌</p><h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p>使用注解时，只需在声明处添加相应的注解即可。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> TestClass.class.getAnnotation(MyAnnotation.class);</span><br><span class="line">        System.out.println(annotation.value()); <span class="comment">// 输出: hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码通过反射获取了<code>TestClass</code>类上的<code>MyAnnotation</code>注解，并打印了其<code>value</code>属性的值‌。</p><h3 id="反射获取注解"><a href="#反射获取注解" class="headerlink" title="反射获取注解"></a>反射获取注解</h3><p>通过反射，可以在运行时获取类、方法、参数等上的注解信息。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = TestClass.class;</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line">System.out.println(annotation.value());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取所有methods</span></span><br><span class="line">    Method[] methods = MyAnnotation.class.getClassLoader()</span><br><span class="line">          .loadClass((<span class="string">&quot;com.pdai.java.annotation.TestMyAnnotation&quot;</span>))</span><br><span class="line">          .getMethods();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(MyAnnotation.class)) &#123; <span class="comment">// 方法上是否有MyAnnotation注解</span></span><br><span class="line">            <span class="type">MyAnnotation</span> <span class="variable">anno</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class); <span class="comment">// 获取MyAnnotation对象信息</span></span><br><span class="line">            System.out.println(anno.title()); <span class="comment">// 访问注解的属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="源码分析注解的底层实现"><a href="#源码分析注解的底层实现" class="headerlink" title="源码分析注解的底层实现"></a>源码分析注解的底层实现</h2><p>从 <code>MyAnnotation annotation = clazz.getAnnotation(MyAnnotation.class);</code> 开始分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#getAnnotation】</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; A <span class="title function_">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(annotationClass);</span><br><span class="line">    <span class="keyword">return</span> (A) annotationData().annotations.get(annotationClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>annotationData().annotations.get(annotationClass);</code>：调用 <code>annotationData()</code> 方法获取<strong>当前类的注解数据</strong>，然后从 annotations 映射中获取<strong>指定类型的注解实例</strong></li><li><code>(A)</code>：将获取到的<strong>注解实例强制转换为泛型类型 A</strong></li></ul><h3 id="获取注解数据集-annotationData"><a href="#获取注解数据集-annotationData" class="headerlink" title="获取注解数据集 annotationData"></a>获取注解数据集 annotationData</h3><p>使用 <code>Atomic.casAnnotationData</code> 方法（基于 CAS <a href="https://so.csdn.net/so/search?q=%E4%B9%90%E8%A7%82%E9%94%81&spm=1001.2101.3001.7020">乐观锁</a>机制）尝试将新的 AnnotationData 对象更新到当前类中。若更新成功，返回新的 AnnotationData 对象；若失败，循环会继续重试，直到成功为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#annotationData】</span></span><br><span class="line"><span class="comment">/* 获取当前类的注解数据对象。如果缓存的注解数据已过期或不存在，则创建新的注解数据对象并尝试更新到缓存中。</span></span><br><span class="line"><span class="comment"> * 该方法使用循环重试和 CAS 操作来保证数据的一致性和线程安全。</span></span><br><span class="line"><span class="comment"> * @return 当前类的注解数据对象  */</span></span><br><span class="line"><span class="keyword">private</span> AnnotationData <span class="title function_">annotationData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="comment">// 进入无限循环，实现重试机制，直到成功获取有效的注解数据</span></span><br><span class="line">        <span class="type">AnnotationData</span> <span class="variable">annotationData</span> <span class="operator">=</span> <span class="built_in">this</span>.annotationData; <span class="comment">// 获取当前缓存的注解数据对象</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">classRedefinedCount</span> <span class="operator">=</span> <span class="built_in">this</span>.classRedefinedCount; <span class="comment">// 获取当前类的重定义计数，该值在类被重新定义时会递增</span></span><br><span class="line">        <span class="keyword">if</span> (annotationData != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            annotationData.redefinedCount == classRedefinedCount) &#123; <span class="comment">// 检查缓存的注解数据是否存在且未过期</span></span><br><span class="line">            <span class="keyword">return</span> annotationData; <span class="comment">// 若注解数据有效，直接返回缓存的对象</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若缓存的注解数据为空或已过期，乐观地创建一个新的注解数据对象</span></span><br><span class="line">        <span class="type">AnnotationData</span> <span class="variable">newAnnotationData</span> <span class="operator">=</span> createAnnotationData(classRedefinedCount);</span><br><span class="line">        <span class="comment">// 尝试使用 CAS（Compare-And-Swap）操作将新的注解数据对象更新到缓存中</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic.casAnnotationData(<span class="built_in">this</span>, annotationData, newAnnotationData)) &#123;</span><br><span class="line">            <span class="keyword">return</span> newAnnotationData; <span class="comment">// 若 CAS 操作成功，说明新的注解数据已成功更新到缓存，返回该对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 CAS 操作失败，说明在创建新对象期间，其他线程已经更新了注解数据，进入下一次循环重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建注解数据集-createAnnotationData"><a href="#构建注解数据集-createAnnotationData" class="headerlink" title="构建注解数据集 createAnnotationData"></a>构建注解数据集 createAnnotationData</h3><ul><li>调用 <code>AnnotationParser.parseAnnotations</code> 方法，解析当前类的原始注解数据，将结果存储在 <code>declaredAnnotations</code> 映射中，<em>键为注解类，值为注解实例</em></li><li><strong>处理父类继承注解：</strong>父类存在，获取父类的注解数据中的注解映射 <code>superAnnotations</code>。遍历 superAnnotations，对于每个注解，检查其是否使用了<code>@Inherited</code>元注解（通过 <code>AnnotationType.getInstance(annotationClass).isInherited()</code> 判断）。若使用了 @Inherited 元注解，且 annotations 为 null，则进行懒初始化，创建一个 LinkedHashMap 来存储继承的注解。将继承的注解添加到 annotations 映射中</li><li><strong>合并注解：</strong>若 annotations 仍为 null，说明没有继承的注解，直接将 annotations 指向 declaredAnnotations。若存在继承的注解，将 declaredAnnotations 中的注解添加到 annotations 中，当前类声明的注解会覆盖继承的注解</li><li><strong>总结：</strong>该方法的核心逻辑是解析当前类的声明注解，若父类存在，获取父类中可继承的注解，将两者合并后创建 AnnotationData 对象。这样可以保证 AnnotationData 对象包含当前类完整的注解信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#createAnnotationData】</span></span><br><span class="line"><span class="keyword">private</span> AnnotationData <span class="title function_">createAnnotationData</span><span class="params">(<span class="type">int</span> classRedefinedCount)</span> &#123;</span><br><span class="line">    <span class="comment">// ------------------------ 处理父类继承注解 ----------------------------------</span></span><br><span class="line">    <span class="comment">// 解析当前类的原始注解数据，将结果存储在 declaredAnnotations 映射中</span></span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; declaredAnnotations =</span><br><span class="line">        AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), <span class="built_in">this</span>);</span><br><span class="line">        </span><br><span class="line">    Class&lt;?&gt; superClass = getSuperclass(); <span class="comment">// 父类获取</span></span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; annotations = <span class="literal">null</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (superClass != <span class="literal">null</span>) &#123; <span class="comment">// 若父类存在</span></span><br><span class="line">        Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; superAnnotations =</span><br><span class="line">            superClass.annotationData().annotations; <span class="comment">// 获取父类的注解数据中的注解映射</span></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; e : superAnnotations.entrySet()) &#123;</span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass = e.getKey();</span><br><span class="line">            <span class="comment">// 判断每个注解是否使用了元注解@Inherited</span></span><br><span class="line">            <span class="keyword">if</span> (AnnotationType.getInstance(annotationClass).isInherited()) &#123; </span><br><span class="line">                <span class="keyword">if</span> (annotations == <span class="literal">null</span>) &#123; <span class="comment">// lazy construction （懒初始化）</span></span><br><span class="line">                    <span class="comment">// 创建一个 LinkedHashMap 来存储继承的注解</span></span><br><span class="line">                    annotations = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;((Math.max(</span><br><span class="line">                            declaredAnnotations.size(),</span><br><span class="line">                            Math.min(<span class="number">12</span>, declaredAnnotations.size() + superAnnotations.size())</span><br><span class="line">                        ) * <span class="number">4</span> + <span class="number">2</span>) / <span class="number">3</span></span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将继承的注解添加到 annotations 映射中</span></span><br><span class="line">                annotations.put(annotationClass, e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------ 处理父类继承注解 --------------------------------</span></span><br><span class="line">    <span class="comment">// --------------------------- 合并注解 ----------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (annotations == <span class="literal">null</span>) &#123; <span class="comment">// annotations 仍为 null，说明没有继承的注解</span></span><br><span class="line">        <span class="comment">// no inherited annotations -&gt; share the Map with declaredAnnotations</span></span><br><span class="line">        annotations = declaredAnnotations;</span><br><span class="line">    <span class="comment">// --------------------------- 合并注解 ----------------------------------</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 存在继承的注解 添加后，当前类声明的注解会覆盖继承的注解</span></span><br><span class="line">        <span class="comment">// at least one inherited annotation -&gt; declared may override inherited</span></span><br><span class="line">        annotations.putAll(declaredAnnotations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationData</span>(annotations, declaredAnnotations, classRedefinedCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取当前类的原始注解数据-getRawAnnotations"><a href="#获取当前类的原始注解数据-getRawAnnotations" class="headerlink" title="获取当前类的原始注解数据 getRawAnnotations"></a>获取当前类的原始注解数据 getRawAnnotations</h3><ul><li><strong>native 关键字</strong>：在 Java 里，<code>native</code> 关键字用于声明本地方法。本地方法并非用 Java 实现，而是借助其他编程语言（像 C、C++）实现。Java 虚拟机（JVM）会负责加载并调用这些本地方法。通常，本地方法用于和底层系统交互，或实现对性能要求极高的操作。</li><li><strong>byte[] 返回类型</strong>：该方法返回一个字节数组 byte[]。这意味着<strong>方法会返回当前类原始注解数据的字节表示形式</strong>。原始注解数据是注解在字节码层面的存储形式，可能包含<strong>注解类型、注解属性值</strong>等信息。</li><li><strong>元注解</strong>：作用于自定义注解类型的注解类，在JDK 1.5中提供了4个标准的元注解：<code>@Target，@Retention，@Documented，@Inherited</code>，在JDK 1.8中提供了两个元注解 <code>@Repeatable</code>和<code>@Native</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#getRawAnnotations】</span></span><br><span class="line"><span class="keyword">native</span> <span class="type">byte</span>[] getRawAnnotations();</span><br></pre></td></tr></table></figure><h3 id="获取当前类对应的常量池-getConstantPool"><a href="#获取当前类对应的常量池-getConstantPool" class="headerlink" title="获取当前类对应的常量池 getConstantPool"></a>获取当前类对应的常量池 getConstantPool</h3><p><code>getConstantPool</code> 方法是一个本地方法，其作用是获取当前类对应的常量池对象。由于需要直接访问 JVM 内部的数据结构，所以采用本地方法实现。调用该方法后，能得到一个 <code>ConstantPool</code> 对象，进而访问常量池中的常量信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#getConstantPool】</span></span><br><span class="line"><span class="keyword">native</span> ConstantPool <span class="title function_">getConstantPool</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="解析当前类的原始注解数据-parseAnnotations"><a href="#解析当前类的原始注解数据-parseAnnotations" class="headerlink" title="解析当前类的原始注解数据 parseAnnotations"></a>解析当前类的原始注解数据 parseAnnotations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationParser#parseAnnotations】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; parseAnnotations(</span><br><span class="line">        <span class="type">byte</span>[] var0, ConstantPool var1, Class&lt;?&gt; var2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (var0 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parseAnnotations2(var0, var1, var2, (Class[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BufferUnderflowException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Unexpected end of annotations.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; parseAnnotations2(</span><br><span class="line">        <span class="type">byte</span>[] var0, ConstantPool var1, Class&lt;?&gt; var2, Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;[] var3) &#123;</span><br><span class="line">    <span class="type">LinkedHashMap</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">var5</span> <span class="operator">=</span> ByteBuffer.wrap(var0);</span><br><span class="line">    <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> var5.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var7</span> <span class="operator">=</span> <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">        <span class="type">Annotation</span> <span class="variable">var8</span> <span class="operator">=</span> parseAnnotation2(var5, var1, var2, <span class="literal">false</span>, var3);</span><br><span class="line">        <span class="keyword">if</span> (var8 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">var9</span> <span class="operator">=</span> var8.annotationType();</span><br><span class="line">            <span class="keyword">if</span> (AnnotationType.getInstance(var9).retention() == RetentionPolicy.RUNTIME &amp;&amp; var4.put(var9, var8) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Duplicate annotation for class: &quot;</span> + var9 + <span class="string">&quot;: &quot;</span> + var8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体会调用到下面的 <code>parseAnnotation2</code> 方法，该方法主要都是解析注解里面的信息，解析出来的值最终会给到我们去创建代理对象用。我们重点关注的是 <code>annotationForMap</code> 这个方法，该方法里面就是通过动态代理来创建注解实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationParser#parseAnnotation2】</span></span><br><span class="line"><span class="comment">/* 解析注解字节数据，生成注解实例。</span></span><br><span class="line"><span class="comment"> * @param var0 包含注解数据的字节缓冲区</span></span><br><span class="line"><span class="comment"> * @param var1 常量池对象，用于获取注解相关的常量信息</span></span><br><span class="line"><span class="comment"> * @param var2 注解所属的类</span></span><br><span class="line"><span class="comment"> * @param var3 若为 true，在遇到类型不存在异常时抛出异常；否则跳过该注解</span></span><br><span class="line"><span class="comment"> * @param var4 要解析的注解类型数组，若为 null 则解析所有注解</span></span><br><span class="line"><span class="comment"> * @return 解析得到的注解实例，若跳过解析则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Annotation <span class="title function_">parseAnnotation2</span><span class="params">(</span></span><br><span class="line"><span class="params">    ByteBuffer var0, ConstantPool var1, Class&lt;?&gt; var2, <span class="type">boolean</span> var3, Class&lt;? extends Annotation&gt;[] var4)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> var0.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>; <span class="comment">// 从字节缓冲区读取注解类型的常量池索引</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 用于存储临时对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">var7</span> <span class="operator">=</span> <span class="string">&quot;[unknown]&quot;</span>; <span class="comment">// 注解类型名称，初始为未知</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试获取注解类型的类对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var7 = var1.getUTF8At(var5); <span class="comment">// 从常量池中获取注解类型的名称</span></span><br><span class="line">            var21 = parseSig(var7, var2); <span class="comment">// 解析签名，获取注解类型的类对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var18) &#123;</span><br><span class="line">            var21 = var1.getClassAt(var5);  <span class="comment">// 若解析签名失败，直接从常量池中获取类对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError var19) &#123; <span class="comment">// 若找不到类定义</span></span><br><span class="line">        <span class="keyword">if</span> (var3) &#123; <span class="comment">// 若 var3 为 true，抛出类型不存在异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeNotPresentException</span>(var7, var19);</span><br><span class="line">        &#125;</span><br><span class="line">        skipAnnotation(var0, <span class="literal">false</span>); <span class="comment">// 跳过当前注解的解析</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TypeNotPresentException var20) &#123; <span class="comment">// 若类型不存在</span></span><br><span class="line">        <span class="keyword">if</span> (var3) &#123; <span class="comment">// 若 var3 为 true，抛出类型不存在异常</span></span><br><span class="line">            <span class="keyword">throw</span> var20;</span><br><span class="line">        &#125;</span><br><span class="line">        skipAnnotation(var0, <span class="literal">false</span>); <span class="comment">// 跳过当前注解的解析</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否只需要解析特定类型的注解</span></span><br><span class="line">    <span class="keyword">if</span> (var4 != <span class="literal">null</span> &amp;&amp; !contains(var4, var21)) &#123; <span class="comment">// 若当前注解类型不在需要解析的类型列表中，跳过解析</span></span><br><span class="line">        skipAnnotation(var0, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 用于存储临时对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var23 = AnnotationType.getInstance(var21); <span class="comment">// 获取注解类型的元数据</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var17) &#123; <span class="comment">// 若获取元数据失败，跳过当前注解的解析</span></span><br><span class="line">            skipAnnotation(var0, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">var9</span> <span class="operator">=</span> var23.memberTypes(); <span class="comment">// 获取注解类型的成员类型映射</span></span><br><span class="line">        <span class="type">LinkedHashMap</span> <span class="variable">var10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(var23.memberDefaults()); <span class="comment">// 初始化注解成员值映射，使用默认值填充</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">var11</span> <span class="operator">=</span> var0.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>; <span class="comment">// 从字节缓冲区读取注解成员的数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var12</span> <span class="operator">=</span> <span class="number">0</span>; var12 &lt; var11; ++var12) &#123;  <span class="comment">// 遍历所有注解成员</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">var13</span> <span class="operator">=</span> var0.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>; <span class="comment">// 从字节缓冲区读取成员名称的常量池索引</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">var14</span> <span class="operator">=</span> var1.getUTF8At(var13); <span class="comment">// 从常量池中获取成员名称</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">var15</span> <span class="operator">=</span> (Class)var9.get(var14); <span class="comment">// 获取成员的类型</span></span><br><span class="line">            <span class="keyword">if</span> (var15 == <span class="literal">null</span>) &#123; <span class="comment">// 若成员类型不存在，跳过该成员值的解析</span></span><br><span class="line">                skipMemberValue(var0);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">var16</span> <span class="operator">=</span> parseMemberValue(var15, var0, var1, var2); <span class="comment">// 解析成员值</span></span><br><span class="line">                <span class="comment">// 若成员值类型不匹配，设置异常代理的成员信息</span></span><br><span class="line">                <span class="keyword">if</span> (var16 <span class="keyword">instanceof</span> AnnotationTypeMismatchExceptionProxy) &#123;</span><br><span class="line"> ((AnnotationTypeMismatchExceptionProxy)var16).setMember((Method)var23.members().get(var14));</span><br><span class="line">                &#125;</span><br><span class="line">                var10.put(var14, var16); <span class="comment">// 将解析得到的成员值放入映射中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> annotationForMap(var21, var10); <span class="comment">// 根据注解类型和成员值映射生成注解实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过java动态代理实例化注解代理对象"><a href="#通过java动态代理实例化注解代理对象" class="headerlink" title="通过java动态代理实例化注解代理对象"></a>通过java动态代理实例化注解代理对象</h3><ul><li><code>AccessController.doPrivileged</code>：该方法用于在特权环境下执行特定操作。在 Java 安全模型里，有些操作需要特定权限才能执行，使用 <code>doPrivileged</code> 可确保代码在足够权限下运行</li><li><code>annotationForMap</code> 方法利用 Java 的反射和代理机制，根据给定的注解类型和成员值映射，动态创建一个注解实例。借助 <code>AccessController</code> 确保操作在特权环境下执行，最终返回一个实现了指定注解接口的代理对象（此处需要注意，用的代理类 <code>AnnotationInvocationHandler</code>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationParser#annotationForMap】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Annotation <span class="title function_">annotationForMap</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> Class&lt;? extends Annotation&gt; var0, <span class="keyword">final</span> Map&lt;String, Object&gt; var1)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (Annotation)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Annotation&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Annotation <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Annotation)Proxy.newProxyInstance(var0.getClassLoader(), </span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;var0&#125;, </span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">AnnotationInvocationHandler</span>(var0, var1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-AnnotationInvocationHandler"><a href="#实现-AnnotationInvocationHandler" class="headerlink" title="实现 AnnotationInvocationHandler"></a>实现 AnnotationInvocationHandler</h3><ul><li><code>AnnotationInvocationHandler</code> 类中的 invoke 方法，该类实现了 <code>InvocationHandler</code> 接口。<strong>在 Java 动态代理机制里，InvocationHandler 接口的 invoke 方法是核心</strong>，当调用代理对象的方法时，实际上会调用 invoke 方法来处理</li><li><strong>处理特殊方法调用：</strong><ul><li>若被调用方法是 toString，调用 <code>toStringImpl</code> 方法生成注解的字符串表示并返回</li><li>若被调用方法是 hashCode，调用 <code>hashCodeImpl</code> 方法计算注解的哈希码并返回</li><li>若被调用方法是 <code>annotationType</code>，返回注解的类型 <code>this.type</code></li></ul></li><li><strong>处理注解成员方法调用：</strong><ul><li>若被调用方法是注解的成员方法，从 <code>memberValues</code> 映射中获取对应的值</li><li>若值为 null，说明注解实例缺少该成员的值，抛出 <code>IncompleteAnnotationException</code> 异常</li><li>若值是 <code>ExceptionProxy</code> 类型，调用 <code>generateException</code> 方法抛出异常</li><li>若值是数组且不为空，调用 <code>cloneArray</code> 方法克隆数组，避免外部修改原始数组，最后返回该值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationInvocationHandler】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6182022883658399397L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Method[] memberMethods = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = var1;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = var2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">var4</span> <span class="operator">=</span> var2.getName();</span><br><span class="line">    Class[] var5 = var2.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (var4.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.equalsImpl(var3[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var5.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (var4) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.toStringImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.hashCodeImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.type;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.get(var4);</span><br><span class="line">                <span class="keyword">if</span> (var6 == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(<span class="built_in">this</span>.type, var4);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var6 <span class="keyword">instanceof</span> ExceptionProxy) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ((ExceptionProxy)var6).generateException();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != <span class="number">0</span>) &#123;</span><br><span class="line">                        var6 = <span class="built_in">this</span>.cloneArray(var6);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> var6;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="其他相关问题"><a href="#其他相关问题" class="headerlink" title="其他相关问题"></a>其他相关问题</h1><h2 id="注解如何生效"><a href="#注解如何生效" class="headerlink" title="注解如何生效"></a>注解如何生效</h2><p><strong>编译期扫描处理，运行期反射处理。编译期扫描处理一般只有Java内置注解会用到</strong>，比如<code>@Override</code>修饰的方法，编译器会检查父类是否有相同的方法。大部分自定义的注解，都是在运行期通过反射拿到并处理。</p><h2 id="运行期如何获取注解"><a href="#运行期如何获取注解" class="headerlink" title="运行期如何获取注解"></a>运行期如何获取注解</h2><p>运行时注解<strong>存放在class文件中的<code>attributes属性表</code>中</strong>。<br><strong>反射获取注解的核心</strong>在：<code>java.lang.reflect</code>下的 <strong><code>AnnotatedElement</code><strong>接口，而</strong><code>AnnotatedElement</code></strong> 接口是所有程序元素（<code>Class</code>、<code>Method</code>和<code>Constructor</code>）的父接口。</p><h2 id="Spring加与不加注解的区别"><a href="#Spring加与不加注解的区别" class="headerlink" title="Spring加与不加注解的区别"></a>Spring加与不加注解的区别</h2><ol><li>‌<strong>配置方式</strong>‌：<ul><li>‌<strong>不加注解</strong>‌：可以<strong>通过XML配置文件来定义bean</strong>，这种方式更加直观，但需要编写XML文件。</li><li>‌<strong>加注解</strong>‌：通过使用<code>@Configuration</code>和<code>@Bean</code>注解来定义bean，这种方式更加灵活，代码更加简洁，且易于维护和修改。</li></ul></li><li>‌<strong>管理方式</strong>‌：<ul><li>‌<strong>不加注解</strong>‌：需要手动编写XML配置文件，并通过XML配置文件来管理bean的创建和依赖关系。</li><li>‌<strong>加注解</strong>‌：通过注解来定义bean，Spring框架在启动时会扫描这些注解并自动创建和管理bean，减少了手动配置的工作量。</li></ul></li></ol><hr><h1 id="常用注解及解释"><a href="#常用注解及解释" class="headerlink" title="常用注解及解释"></a>常用注解及解释</h1><h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><ul><li>‌**<code>@Component</code>**‌：用于把当前类对象存入Spring容器中。<code>@Controller、@Service、@Repository</code>都可以称为@Component，它们分别用于控制层、业务层和数据访问层。</li><li>‌**<code>@Autowired</code>**‌：自动按照类型注入Spring容器中的bean。它可以作用在变量、setter方法或构造函数上。</li><li>‌**<code>@Qualifier</code>**‌：在按照类型注入的基础上，通过名称进行注入。通常与<code>@Autowired</code>一起使用，用于解决相同类型bean的注入冲突。</li><li>‌**<code>@Inject</code>**‌：由<code>JSR-330</code>提供，用法与<code>@Autowired</code>相似，但它是Java标准的一部分，而@Autowired是Spring特有的。</li><li>‌**<code>@Resource</code>**‌：由<code>JSR-250</code>提供，按照bean的id进行注入，可以独立使用。</li><li>‌**<code>@Primary</code>**‌：当存在多个相同类型的bean时，标记首选的bean进行注入。</li></ul><h2 id="Java配置类相关注解"><a href="#Java配置类相关注解" class="headerlink" title="Java配置类相关注解"></a>Java配置类相关注解</h2><ul><li>‌**<code>@Configuration</code>**‌：声明当前类为配置类，相当于传统的XML配置文件。</li><li>‌**<code>@Bean</code>**‌：注解在方法上，声明当前方法的返回值为一个bean，替代XML中的<code>&lt;bean&gt;</code>标签。</li><li>‌**<code>@ComponentScan</code>**‌：用于指定Spring在创建容器时要扫描的包，以找到带有<code>@Component、@Repository、@Service、@Controller</code>等注解的类，并注册为bean。</li></ul><h2 id="切面（AOP）相关注解"><a href="#切面（AOP）相关注解" class="headerlink" title="切面（AOP）相关注解"></a>切面（AOP）相关注解</h2><ul><li>‌**<code>@Aspect</code>**‌：声明一个切面。</li><li>‌**<code>@After</code>**‌：在目标方法执行之后执行。</li><li>‌**<code>@Before</code>**‌：在目标方法执行之前执行。</li><li>‌**<code>@Around</code>**‌：在目标方法执行之前和之后执行，可以围绕目标方法创建一个“拦截器”。</li><li>‌**<code>@PointCut</code>**‌：声明一个切点，即指定哪些方法将被增强。</li></ul><h2 id="配置和环境相关注解"><a href="#配置和环境相关注解" class="headerlink" title="配置和环境相关注解"></a>配置和环境相关注解</h2><ul><li>‌**<code>@Value</code>**‌：用于注入基本类型和String类型的数据，支持使用<code>Spring EL</code>表达式。</li><li>‌**<code>@Profile</code>**‌：指定组件在哪个环境的情况下才能被注册到容器中。</li><li>‌**<code>@Conditional</code>**‌：通过实现Condition接口，并重写<code>matches</code>方法，从而决定该bean是否被实例化。</li></ul><h2 id="其他常用注解"><a href="#其他常用注解" class="headerlink" title="其他常用注解"></a>其他常用注解</h2><ul><li>‌**<code>@Lazy</code>**‌：用于延迟初始化bean，即只有在第一次使用时才会创建和初始化。</li><li>‌**<code>@Scope</code><strong>‌：用于指定bean的作用范围，如</strong>单例（singleton）或多例（prototype）**。</li><li>‌**<code>@EnableAsync</code>**‌：在配置类中通过此注解开启对异步任务的支持。</li><li>‌**<code>@Async</code>**‌：在实际执行的bean方法使用该注解来声明其是一个异步任务。</li><li>‌**<code>@EnableScheduling</code>**‌：在配置类上使用，开启计划任务的支持。</li><li>‌**<code>@Scheduled</code>**‌：用于声明一个定时任务。</li></ul>]]></content>
    
    
    <summary type="html">在Spring框架中，注解是一种非常重要的特性，它极大地简化了配置和开发过程。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="Spring" scheme="https://southernfish.github.io/categories/Framwork/Spring/"/>
    
    
    <category term="Spring Boot" scheme="https://southernfish.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>使用多线程解决问题</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-thread-impl/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-thread-impl/</id>
    <published>2025-06-23T12:25:36.000Z</published>
    <updated>2025-07-10T12:47:35.023Z</updated>
    
    <content type="html"><![CDATA[<p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同<a href="https://baike.baidu.com/item/%E4%B8%80%E6%97%B6%E9%97%B4/3618565?fromModule=lemma_inlink">一时间</a>执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括<a href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA/10375153?fromModule=lemma_inlink">对称多处理机</a>、<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%A0%B8%E5%BF%83/1013410?fromModule=lemma_inlink">多核心</a>处理器以及<a href="https://baike.baidu.com/item/%E8%8A%AF%E7%89%87%E7%BA%A7%E5%A4%9A%E5%A4%84%E7%90%86/924724?fromModule=lemma_inlink">芯片级多处理</a>或<a href="https://baike.baidu.com/item/%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B/22689341?fromModule=lemma_inlink">同时多线程</a>处理器。在一个程序中，这些独立运行的程序片段叫作“<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fromModule=lemma_inlink">线程</a>”（Thread），利用它编程的概念就叫作“多线程处理” 。本文简单记录一些关于线程、多线程的问题。本文记录了关于一些常见多线程业务问题处理。</p><h2 id="多线程问题-1"><a href="#多线程问题-1" class="headerlink" title="多线程问题 1"></a>多线程问题 1</h2><p><strong>问题：</strong>100个线程并发向1个银行账户中存入1元钱,并在全部完成后，打印银行账户的金额。</p><p><strong>思路：</strong>创建100个线程（<code>线程池</code>）；保证线程安全，同一时刻只有一个线程对账户进行操作（<code>Lock</code> 或者 <code>synchronized</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种加锁 synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="comment">// 获得账户余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁 存钱方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> <span class="built_in">this</span>.balance + money;</span><br><span class="line">        <span class="built_in">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种锁 lock</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="comment">// 获得账户余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁 存钱方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        reentrantLock.lock;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newBalance = balance + money;</span><br><span class="line">            balance = newBalance;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">          reentrantLock.unlock();  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存钱的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadSaveAccount</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TheadSaveAccount</span><span class="params">(Account account, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁 整个账户</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            account.deposit(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadSave</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            service.execute( <span class="keyword">new</span> <span class="title class_">TheadSaveAccount</span>(account, <span class="number">1</span>) );</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">        <span class="keyword">if</span> (service.isTerminated()) &#123;</span><br><span class="line">            System.out.println(account.getBalance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多线程是并行化的一种形式，或者是拆分工作以便同时进行处理。线程化的程序将工作拆分到多个软件线程，而不是将大量工作交给单个内核。这些线程由不同的 CPU 内核并行处理，以节省时间。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
</feed>
